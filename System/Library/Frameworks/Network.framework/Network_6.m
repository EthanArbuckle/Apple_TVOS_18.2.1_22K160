LABEL_147:
          *((_BYTE *)v160 + 476) |= 0x10u;
          if ((v53 & 0x40000) == 0)
          {
LABEL_103:
            if ((v53 & 0x80000) == 0) {
              goto LABEL_104;
            }
            goto LABEL_149;
          }

      if (v51) {
        free(v51);
      }
      v21 = 0LL;
      goto LABEL_27;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_protocol_ipv4_get_output_frames";
    v47 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = (os_log_s *)__nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null ipv4";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    if (!v77)
    {
      v48 = (os_log_s *)__nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    v60 = (char *)__nw_create_backtrace_string();
    v48 = (os_log_s *)__nwlog_obj();
    v49 = type;
    v63 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "nw_protocol_ipv4_get_output_frames";
      v81 = 2082;
      *(void *)v82 = v60;
      v62 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_106;
    }

    goto LABEL_107;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v80 = "nw_protocol_ipv4_get_output_frames";
  v47 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v77 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v77)
    {
      v48 = (os_log_s *)__nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    v60 = (char *)__nw_create_backtrace_string();
    v48 = (os_log_s *)__nwlog_obj();
    v49 = type;
    v61 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "nw_protocol_ipv4_get_output_frames";
      v81 = 2082;
      *(void *)v82 = v60;
      v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_106:
      _os_log_impl(&dword_181A5C000, v48, v49, v62, buf, 0x16u);
    }

        if (v60) {
          free(v60);
        }
        goto LABEL_73;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        v91 = "nw_protocol_shoes_connected";
        v92 = 2082;
        v93 = handle + 151;
        _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s start waiting for TFO",  buf,  0x16u);
      }

      handle[150] = 2;
    }

    ((void (*)(nw_protocol *, nw_protocol *))a1->default_input_handler->callbacks->connected)( a1->default_input_handler,  a1);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v91 = "nw_protocol_shoes_connected";
  v52 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v102) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (v102 == 17)
  {
    v53 = (os_log_s *)__nwlog_obj();
    v54 = v102;
    if (!os_log_type_enabled(v53, (os_log_type_t)v102)) {
      goto LABEL_106;
    }
    *(_DWORD *)buf = 136446210;
    v91 = "nw_protocol_shoes_connected";
    v55 = "%{public}s called with null shoes";
    goto LABEL_105;
  }

  if (type == OS_LOG_TYPE_DEFAULT)
  {
    v53 = (os_log_s *)__nwlog_obj();
    v54 = v102;
    if (!os_log_type_enabled(v53, (os_log_type_t)v102)) {
      goto LABEL_106;
    }
    *(_DWORD *)buf = 136446210;
    v91 = "nw_protocol_shoes_connected";
    v55 = "%{public}s called with null shoes, backtrace limit exceeded";
    goto LABEL_105;
  }

  v58 = (char *)__nw_create_backtrace_string();
  v53 = (os_log_s *)__nwlog_obj();
  v54 = v102;
  v59 = os_log_type_enabled(v53, (os_log_type_t)v102);
  if (!v58)
  {
    if (!v59) {
      goto LABEL_106;
    }
    *(_DWORD *)buf = 136446210;
    v91 = "nw_protocol_shoes_connected";
    v55 = "%{public}s called with null shoes, no backtrace";
    goto LABEL_105;
  }

  if (v59)
  {
    *(_DWORD *)buf = 136446466;
    v91 = "nw_protocol_shoes_connected";
    v92 = 2082;
    v93 = v58;
    _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null shoes, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v58);
  if (v52) {
    goto LABEL_107;
  }
}

            if (v90) {
              free(v90);
            }
            *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = -1;
LABEL_150:
            v100 = *(void *)(*(void *)(a1 + 48) + 8LL);
            if (*(_BYTE *)(a1 + 80))
            {
              *(void *)(v36 + 32) = 0LL;
              v101 = v36 + 32;
            }

            else
            {
              *(void *)(v36 + 16) = 0LL;
              v101 = v36 + 16;
            }

            v102 = *(uint64_t **)(v100 + 48);
            *(void *)(v101 + 8) = v102;
            *v102 = v36;
            *(void *)(v100 + 48) = v101;
            return 0LL;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v50 = v8;
          v51 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(void *)v113 = "bytes_count";
          *(_WORD *)&v113[8] = 2048;
          v114 = v17;
          *(_WORD *)v115 = 2048;
          *(void *)&v115[2] = v51;
          v52 = (char *)_os_log_send_and_compose_impl();
          v109 = OS_LOG_TYPE_ERROR;
          v107 = 0;
          if (__nwlog_fault(v52, &v109, &v107))
          {
            if (v109 == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v53 = (os_log_s *)v8[131];
              v54 = v109;
              if (os_log_type_enabled((os_log_t)v50[131], v109))
              {
                v55 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(void *)v113 = "bytes_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = v17;
                *(_WORD *)v115 = 2048;
                *(void *)&v115[2] = v55;
                v56 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_126:
                _os_log_impl(&dword_181A5C000, v53, v54, v56, buf, 0x2Au);
              }
            }

            else if (v107)
            {
              v59 = (char *)__nw_create_backtrace_string();
              v53 = (os_log_s *)__nwlog_obj();
              v54 = v109;
              v60 = os_log_type_enabled(v53, v109);
              if (v59)
              {
                if (v60)
                {
                  v61 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                  *(_DWORD *)buf = 136447234;
                  v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  v112 = 2082;
                  *(void *)v113 = "bytes_count";
                  *(_WORD *)&v113[8] = 2048;
                  v114 = v17;
                  *(_WORD *)v115 = 2048;
                  *(void *)&v115[2] = v61;
                  v116 = 2082;
                  v117 = v59;
                  _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v59);
                goto LABEL_127;
              }

              if (v60)
              {
                v85 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(void *)v113 = "bytes_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = v17;
                *(_WORD *)v115 = 2048;
                *(void *)&v115[2] = v85;
                v56 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_126;
              }
            }

            else
            {
              v53 = (os_log_s *)__nwlog_obj();
              v54 = v109;
              if (os_log_type_enabled(v53, v109))
              {
                v84 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(void *)v113 = "bytes_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = v17;
                *(_WORD *)v115 = 2048;
                *(void *)&v115[2] = v84;
                v56 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_126;
              }
            }
          }

      nw::release_if_needed<nw_protocol *>((uint64_t *)&v81);
      if (v18 != &nw_protocol_ref_counted_handle)
      {
LABEL_41:
        if (!v30) {
          goto LABEL_159;
        }
        goto LABEL_149;
      }

          if (v53) {
            free(v53);
          }
          v7 = 0LL;
          goto LABEL_20;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v67 = "nw_parameters_create_quic_stream";
        v18 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v64 = 0;
        if (__nwlog_fault(v18, &type, &v64))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v19 = (os_log_s *)(id)gLogObj;
            v20 = type;
            if (os_log_type_enabled(v19, type))
            {
              *(_DWORD *)buf = 136446210;
              v67 = "nw_parameters_create_quic_stream";
              _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s nw_quic_create_stream_options failed", buf, 0xCu);
            }
          }

          else if (v64)
          {
            v24 = __nw_create_backtrace_string();
            if (v24)
            {
              v25 = (char *)v24;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v26 = (os_log_s *)(id)gLogObj;
              v27 = type;
              if (os_log_type_enabled(v26, type))
              {
                *(_DWORD *)buf = 136446466;
                v67 = "nw_parameters_create_quic_stream";
                v68 = 2082;
                v69 = v25;
                _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s nw_quic_create_stream_options failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v25);
              if (!v18) {
                goto LABEL_60;
              }
              goto LABEL_59;
            }

            __nwlog_obj();
            v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v30 = type;
            if (os_log_type_enabled(v19, type))
            {
              *(_DWORD *)buf = 136446210;
              v67 = "nw_parameters_create_quic_stream";
              _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s nw_quic_create_stream_options failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v19 = (os_log_s *)(id)gLogObj;
            v29 = type;
            if (os_log_type_enabled(v19, type))
            {
              *(_DWORD *)buf = 136446210;
              v67 = "nw_parameters_create_quic_stream";
              _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s nw_quic_create_stream_options failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v18)
        {
LABEL_60:
          v7 = 0LL;
          goto LABEL_61;
        }

          if (*(_BYTE *)(a2 + *v8)) {
            v109 = 0LL;
          }
LABEL_149:
          *(_BYTE *)(a1 + 42) = v109 != 0;
LABEL_5:
          v4 = *v3;
          v5 = *(void *)(a2 + v4);
          v7 = *(void *)(a2 + *v6);
          if (v5 >= v7) {
            return *(_BYTE *)(a2 + *v8) == 0;
          }
          break;
        case 9u:
          v14 = PBReaderReadData();
          v15 = 16LL;
LABEL_4:
          v16 = *(void **)(a1 + v15);
          *(void *)(a1 + v15) = v14;

          goto LABEL_5;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result) {
            return result;
          }
          goto LABEL_5;
      }
    }

    v19 = 0LL;
LABEL_40:
    *v17 = 1;
    goto LABEL_41;
  }

  return *(_BYTE *)(a2 + *v8) == 0;
}

      free(v67);
      goto LABEL_148;
    }

    v68 = (os_log_s *)__nwlog_obj();
    v69 = type[0];
    if (!os_log_type_enabled(v68, type[0])) {
      goto LABEL_146;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http1_get_connection_for_protocol";
    v70 = "%{public}s called with null handle";
    goto LABEL_145;
  }

  v6 = *(_DWORD *)(v5 + 24);
  if (v6 == 2)
  {
    v8 = *(void *)(v5 + 8);
    if (v8)
    {
      v7 = (uint64_t *)(v8 + 256);
      goto LABEL_8;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http1_get_connection_for_protocol";
    v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v107 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v67, type, &v107))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v68 = (os_log_s *)__nwlog_obj();
        v69 = type[0];
        if (!os_log_type_enabled(v68, type[0])) {
          goto LABEL_146;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http1_get_connection_for_protocol";
        v70 = "%{public}s called with null handle->http1_stream";
        goto LABEL_145;
      }

      if (v107 == OS_LOG_TYPE_DEFAULT)
      {
        v68 = (os_log_s *)__nwlog_obj();
        v69 = type[0];
        if (!os_log_type_enabled(v68, type[0])) {
          goto LABEL_146;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http1_get_connection_for_protocol";
        v70 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
        goto LABEL_145;
      }

      v78 = (char *)__nw_create_backtrace_string();
      v68 = (os_log_s *)__nwlog_obj();
      v69 = type[0];
      v81 = os_log_type_enabled(v68, type[0]);
      if (!v78)
      {
        if (!v81) {
          goto LABEL_146;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http1_get_connection_for_protocol";
        v70 = "%{public}s called with null handle->http1_stream, no backtrace";
        goto LABEL_145;
      }

      if (v81)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_http1_get_connection_for_protocol";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v78;
        v80 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
        goto LABEL_127;
      }

      goto LABEL_128;
    }

  return 1LL;
}

            if (v55) {
              free(v55);
            }
            goto LABEL_149;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = (id)gLogObj;
          *(_DWORD *)type = 136446210;
          v82 = "nw_path_observer_update_block_invoke";
          v28 = (void *)_os_log_send_and_compose_impl();

          v73 = OS_LOG_TYPE_ERROR;
          v72 = 0;
          if (!__nwlog_fault((const char *)v28, &v73, &v72))
          {
LABEL_124:
            if (v28) {
              free(v28);
            }
            goto LABEL_150;
          }

          if (v73 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v33 = v73;
            if (os_log_type_enabled(v32, v73))
            {
              *(_DWORD *)type = 136446210;
              v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s nw_path_parse_necp_parameters failed",  (uint8_t *)type,  0xCu);
            }

      v30 = 0LL;
      goto LABEL_48;
    }

    objc_msgSend(MEMORY[0x189603F48], "dataWithBytes:length:", v53);
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    nw_endpoint_append_public_key(v30, v69);

LABEL_48:
    if (v29 >= v28) {
      goto LABEL_193;
    }
  }

  __nwlog_obj();
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)out = 136446978;
  *(void *)&out[4] = "nw_agent_copy_group_members_for_message";
  *(_WORD *)&out[12] = 1024;
  *(_DWORD *)&out[14] = v52;
  *(_WORD *)&out[18] = 2048;
  *(void *)&out[20] = v29;
  *(_WORD *)&out[28] = 1024;
  *(_DWORD *)&out[30] = v27;
  v78 = (char *)_os_log_send_and_compose_impl();

  v413[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v78, v413, &type))
  {
    if (v413[0] == 17)
    {
      __nwlog_obj();
      v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v80 = v413[0];
      if (os_log_type_enabled(v79, (os_log_type_t)v413[0]))
      {
        *(_DWORD *)out = 136446978;
        *(void *)&out[4] = "nw_agent_copy_group_members_for_message";
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v52;
        *(_WORD *)&out[18] = 2048;
        *(void *)&out[20] = v29;
        *(_WORD *)&out[28] = 1024;
        *(_DWORD *)&out[30] = v27;
        _os_log_impl( &dword_181A5C000,  v79,  v80,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%u)",  out,  0x22u);
      }

      goto LABEL_190;
    }

    if (type)
    {
      v85 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v86 = v413[0];
      v87 = os_log_type_enabled(v79, (os_log_type_t)v413[0]);
      if (v85)
      {
        if (v87)
        {
          *(_DWORD *)out = 136447234;
          *(void *)&out[4] = "nw_agent_copy_group_members_for_message";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v52;
          *(_WORD *)&out[18] = 2048;
          *(void *)&out[20] = v29;
          *(_WORD *)&out[28] = 1024;
          *(_DWORD *)&out[30] = v27;
          *(_WORD *)&out[34] = 2082;
          *(void *)&out[36] = v85;
          _os_log_impl( &dword_181A5C000,  v79,  v86,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%u), dumping backtrace:%{public}s",  out,  0x2Cu);
        }

        free(v85);
        goto LABEL_191;
      }

      if (v87)
      {
        *(_DWORD *)out = 136446978;
        *(void *)&out[4] = "nw_agent_copy_group_members_for_message";
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v52;
        *(_WORD *)&out[18] = 2048;
        *(void *)&out[20] = v29;
        *(_WORD *)&out[28] = 1024;
        *(_DWORD *)&out[30] = v27;
        _os_log_impl( &dword_181A5C000,  v79,  v86,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%u), no backtrace",  out,  0x22u);
      }
    }

    else
    {
      __nwlog_obj();
      v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v88 = v413[0];
      if (os_log_type_enabled(v79, (os_log_type_t)v413[0]))
      {
        *(_DWORD *)out = 136446978;
        *(void *)&out[4] = "nw_agent_copy_group_members_for_message";
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v52;
        *(_WORD *)&out[18] = 2048;
        *(void *)&out[20] = v29;
        *(_WORD *)&out[28] = 1024;
        *(_DWORD *)&out[30] = v27;
        _os_log_impl( &dword_181A5C000,  v79,  v88,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%u), backtrace limit exceeded",  out,  0x22u);
      }
    }

    v63 = 1LL;
    goto LABEL_115;
  }

  identifier = nw_protocol_definition_get_identifier(v7);
  v20 = *(void *)(a1 + 96);
  if (v20) {
    goto LABEL_82;
  }
  v21 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL);
  v22 = *(void **)(a1 + 40);
  v23 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
  v24 = *(void **)(a1 + 48);
  v25 = *(id *)(a1 + 32);
  v141 = v22;
  v143 = v23;
  v145 = v24;
  v148 = v8;
  v140 = v25;
  if (!v25)
  {
    __nwlog_obj();
    v105 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v45 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v150 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v107 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v106, v107, "%{public}s called with null handler", buf, 0xCu);
      }

      goto LABEL_203;
    }

    if (!v150)
    {
      __nwlog_obj();
      v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v123 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl( &dword_181A5C000,  v106,  v123,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_203;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v111 = type;
    v112 = os_log_type_enabled(v46, type);
    if (!backtrace_string)
    {
      if (v112)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v46, v111, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_220;
    }

    if (v112)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v153 = 2082;
      v154 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v46,  v111,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_187;
  }

  v26 = (unsigned int *)v25;
  v27 = v26[29];

  if ((_DWORD)v27 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v37 = (id)gLogObj;
    else {
      v38 = off_189BBBBC0[v27];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v153 = 2082;
    v154 = (void *)v38;
    v155 = 2082;
    v156 = "flow";
    v45 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v150 = 0;
    if (__nwlog_fault(v45, &type, &v150))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v46 = (os_log_s *)(id)gLogObj;
        v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          else {
            v48 = off_189BBBBC0[v27];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v153 = 2082;
          v154 = (void *)v48;
          v155 = 2082;
          v156 = "flow";
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }

        goto LABEL_220;
      }

      if (!v150)
      {
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v54 = type;
        if (os_log_type_enabled(v46, type))
        {
          else {
            v55 = off_189BBBBC0[v27];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v153 = 2082;
          v154 = (void *)v55;
          v155 = 2082;
          v156 = "flow";
          _os_log_impl( &dword_181A5C000,  v46,  v54,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }

        goto LABEL_220;
      }

      v49 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = type;
      v52 = os_log_type_enabled(v50, type);
      if (v49)
      {
        if (v52)
        {
          else {
            v53 = off_189BBBBC0[v27];
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v153 = 2082;
          v154 = (void *)v53;
          v155 = 2082;
          v156 = "flow";
          v157 = 2082;
          v158 = v49;
          _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v49);
        if (!v45) {
          goto LABEL_80;
        }
        goto LABEL_79;
      }

      if (v52)
      {
        else {
          v56 = off_189BBBBC0[v27];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        v153 = 2082;
        v154 = (void *)v56;
        v155 = 2082;
        v156 = "flow";
        _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }
    }

        v99 = *((void *)handle + 11);
        if (v99)
        {
          nw_queue_cancel_source(v99, v98);
          *((void *)handle + 11) = 0LL;
        }

        if (!*((void *)handle + 13)) {
          *((void *)handle + 13) = os_retain(object);
        }
        v100 = *(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16);
        if (v204[0])
        {
          if ((v100 & 0x80000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v101 = gconnectionLogObj;
            v102 = 1LL;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
              return v102;
            }
            v104 = v56 + 191;
            v107 = v56 + 176;
            v105 = *(_DWORD *)(v56 + 176);
            v106 = *(_DWORD *)(v107 + 4);
            v108 = nw_hash_table_count(*((void *)handle + 19), v103);
            *(_DWORD *)buf = 136448002;
            v191 = "nw_protocol_http2_add_input_handler";
            v192 = 2082;
            v193 = v104;
            v194 = 2080;
            v195 = (uint64_t)" ";
            v196 = 1024;
            v197 = v106;
            v198 = 1024;
            *(_DWORD *)v199 = v105;
            *(_WORD *)&v199[4] = 2048;
            *(void *)&v199[6] = a2;
            *(_WORD *)&v199[14] = 2082;
            *(void *)&v199[16] = v204;
            *(_WORD *)&v199[24] = 1024;
            *(_DWORD *)v200 = v108;
            v109 = "%{public}s %{public}s%s<i%u:s%d> added input handler %p from %{public}s, now have %u input handlers";
            v102 = 1LL;
            v110 = (os_log_s *)v101;
            v111 = 70;
            goto LABEL_162;
          }
        }

        else if ((v100 & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v112 = gconnectionLogObj;
          v102 = 1LL;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
            return v102;
          }
          v114 = v56 + 191;
          v117 = v56 + 176;
          v115 = *(_DWORD *)(v56 + 176);
          v116 = *(_DWORD *)(v117 + 4);
          v118 = nw_hash_table_count(*((void *)handle + 19), v113);
          *(_DWORD *)buf = 136447746;
          v191 = "nw_protocol_http2_add_input_handler";
          v192 = 2082;
          v193 = v114;
          v194 = 2080;
          v195 = (uint64_t)" ";
          v196 = 1024;
          v197 = v116;
          v198 = 1024;
          *(_DWORD *)v199 = v115;
          *(_WORD *)&v199[4] = 2048;
          *(void *)&v199[6] = a2;
          *(_WORD *)&v199[14] = 1024;
          *(_DWORD *)&v199[16] = v118;
          v109 = "%{public}s %{public}s%s<i%u:s%d> added input handler %p, now have %u input handlers";
          v102 = 1LL;
          v110 = (os_log_s *)v112;
          v111 = 60;
LABEL_162:
          _os_log_impl(&dword_181A5C000, v110, OS_LOG_TYPE_INFO, v109, buf, v111);
          return v102;
        }

        return 1LL;
      }

      if (handle[194] < 0) {
        goto LABEL_217;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v89 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_217;
      }
      v90 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      v191 = "nw_protocol_http2_add_input_handler";
      v192 = 2082;
      v193 = (uint64_t)(handle + 195);
      v194 = 2080;
      v195 = (uint64_t)" ";
      v196 = 1024;
      v197 = v90;
      v198 = 1024;
      *(_DWORD *)v199 = v5;
      v86 = "%{public}s %{public}s%s<i%u> stream (id %d) not found in hash node";
      v87 = (os_log_s *)v89;
      v88 = 44;
    }

    else
    {
      if (handle[194] < 0) {
        goto LABEL_217;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v84 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_217;
      }
      v85 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447490;
      v191 = "nw_protocol_http2_add_input_handler";
      v192 = 2082;
      v193 = (uint64_t)(handle + 195);
      v194 = 2080;
      v195 = (uint64_t)" ";
      v196 = 1024;
      v197 = v85;
      v198 = 1024;
      *(_DWORD *)v199 = v5;
      *(_WORD *)&v199[4] = 2048;
      *(void *)&v199[6] = a2;
      v86 = "%{public}s %{public}s%s<i%u> could not find existing stream %d to connect protocol %p with";
      v87 = (os_log_s *)v84;
      v88 = 54;
    }

    _os_log_impl(&dword_181A5C000, v87, OS_LOG_TYPE_ERROR, v86, buf, v88);
    goto LABEL_217;
  }

  if ((handle[194] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v173 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v174 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v191 = "nw_protocol_http2_add_input_handler";
      v192 = 2082;
      v193 = (uint64_t)(handle + 195);
      v194 = 2080;
      v195 = (uint64_t)" ";
      v196 = 1024;
      v197 = v174;
      _os_log_impl( &dword_181A5C000,  v173,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> detected new stream initiated from this side of the connection, allocating new stream",  buf,  0x26u);
    }
  }

  v70 = calloc(1uLL, 0x118uLL);
  v56 = (uint64_t)v70;
  if (v70)
  {
    v71 = (uint64_t)(v70 + 11);
    v70[34] = 0LL;
    *((_OWORD *)v70 + 15) = 0u;
    *((_OWORD *)v70 + 16) = 0u;
    *((_OWORD *)v70 + 13) = 0u;
    *((_OWORD *)v70 + 14) = 0u;
    *((_OWORD *)v70 + 11) = 0u;
    *((_OWORD *)v70 + 12) = 0u;
    *((_OWORD *)v70 + 9) = 0u;
    *((_OWORD *)v70 + 10) = 0u;
    *((_OWORD *)v70 + 7) = 0u;
    *((_OWORD *)v70 + 8) = 0u;
    *((_OWORD *)v70 + 5) = 0u;
    *((_OWORD *)v70 + 6) = 0u;
    *((_OWORD *)v70 + 3) = 0u;
    *((_OWORD *)v70 + 4) = 0u;
    *((_OWORD *)v70 + 1) = 0u;
    *((_OWORD *)v70 + 2) = 0u;
    *(_OWORD *)v70 = 0u;
    nw_http2_stream_init((uint64_t)v70);
    goto LABEL_92;
  }

  v171 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v171, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v191 = "strict_calloc";
  v192 = 2048;
  v193 = 1LL;
  v194 = 2048;
  v195 = 280LL;
  v172 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v172);
  if (!result)
  {
    free(v172);
    MEMORY[0x110] = 0LL;
    MEMORY[0x100] = 0u;
    MEMORY[0xF0] = 0u;
    MEMORY[0xE0] = 0u;
    MEMORY[0xD0] = 0u;
    MEMORY[0xC0] = 0u;
    MEMORY[0xB0] = 0u;
    MEMORY[0xA0] = 0u;
    MEMORY[0x90] = 0u;
    MEMORY[0x80] = 0u;
    MEMORY[0x70] = 0u;
    MEMORY[0x60] = 0u;
    MEMORY[0x50] = 0u;
    MEMORY[0x40] = 0u;
    MEMORY[0x30] = 0u;
    MEMORY[0x20] = 0u;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    nw_http2_stream_init(0LL);
    v71 = 88LL;
LABEL_92:
    v72 = 0LL;
    *(_BYTE *)v71 = (handle[194] & 0x80) != 0;
    v73 = *(_WORD *)(v56 + 188) & 0xFF7F | (*(unsigned __int8 *)(v56 + 190) << 16);
    *(_WORD *)(v56 + 188) = *(_WORD *)(v56 + 188) & 0xFF7F | handle[194] & 0x80;
    *(_BYTE *)(v56 + 190) = BYTE2(v73);
    while (1)
    {
      v74 = v204[v72];
      *(_BYTE *)(v56 + 191 + v72) = v74;
      if (!v74) {
        break;
      }
      if (++v72 == 83)
      {
        *(_BYTE *)(v56 + 274) = 0;
        break;
      }
    }

    v75 = (16 * (unsigned __int16)handle[194]) & 0x80000 | (*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0xFFF7FFFF;
    *(_WORD *)(v56 + 188) = *(_WORD *)(v56 + 188);
    *(_BYTE *)(v56 + 190) = BYTE2(v75);
    *(_DWORD *)(v56 + 180) = *((_DWORD *)handle + 92);
    v53[4] = v56;
    v76 = *(unsigned __int16 *)(v56 + 188);
    v77 = v76 | (*(unsigned __int8 *)(v56 + 190) << 16);
    if ((v76 & 0x80) == 0) {
      goto LABEL_131;
    }
    if (a1->default_input_handler)
    {
      if ((v77 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v78 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v80 = *(_DWORD *)(v56 + 176);
          v79 = *(_DWORD *)(v56 + 180);
          *(_DWORD *)buf = 136447234;
          v191 = "nw_protocol_http2_add_input_handler";
          v192 = 2082;
          v193 = v56 + 191;
          v194 = 2080;
          v195 = (uint64_t)" ";
          v196 = 1024;
          v197 = v79;
          v198 = 1024;
          *(_DWORD *)v199 = v80;
          _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%d> http2 has default_input_handler on the first stream in a listening connecti on. Is a connection trying to join while having server set on the parameters?",  buf,  0x2Cu);
        }
      }

      nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      if ((*(_BYTE *)(v56 + 168) & 1) != 0)
      {
        v81 = *(void **)(v56 + 160);
        if (v81) {
          os_release(v81);
        }
      }

      *(void *)(v56 + 160) = 0LL;
      if ((*(_BYTE *)(v56 + 152) & 1) != 0)
      {
        v82 = *(void **)(v56 + 144);
        if (v82) {
          os_release(v82);
        }
      }

      *(void *)(v56 + 144) = 0LL;
      v83 = *(void **)(v56 + 120);
      if (v83)
      {
        *(void *)(v56 + 128) = v83;
        operator delete(v83);
      }
    }

    else
    {
      if ((v77 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v181 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v183 = *(_DWORD *)(v56 + 176);
          v182 = *(_DWORD *)(v56 + 180);
          *(_DWORD *)buf = 136447234;
          v191 = "nw_protocol_http2_add_input_handler";
          v192 = 2082;
          v193 = v56 + 191;
          v194 = 2080;
          v195 = (uint64_t)" ";
          v196 = 1024;
          v197 = v182;
          v198 = 1024;
          *(_DWORD *)v199 = v183;
          _os_log_impl( &dword_181A5C000,  v181,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> responder's first stream detected, overriding stream id to 1",  buf,  0x2Cu);
        }
      }

      *(_DWORD *)(v56 + 176) = 1;
      v124 = nw_http2_add_to_id_table((uint64_t)handle, v56, (uint64_t)a2);
      v125 = *(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16);
      if (v124)
      {
        if ((v125 & 0x80000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v126 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v128 = *(_DWORD *)(v56 + 176);
            v127 = *(_DWORD *)(v56 + 180);
            v129 = v53[4];
            *(_DWORD *)buf = 136447746;
            v191 = "nw_protocol_http2_add_input_handler";
            v192 = 2082;
            v193 = v56 + 191;
            v194 = 2080;
            v195 = (uint64_t)" ";
            v196 = 1024;
            v197 = v127;
            v198 = 1024;
            *(_DWORD *)v199 = v128;
            *(_WORD *)&v199[4] = 2048;
            *(void *)&v199[6] = v56;
            *(_WORD *)&v199[14] = 2048;
            *(void *)&v199[16] = v129;
            _os_log_impl( &dword_181A5C000,  v126,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> new stream is %p, stream pointer is %p",  buf,  0x40u);
          }
        }

        goto LABEL_131;
      }

      if ((v125 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v150 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v152 = *(_DWORD *)(v56 + 176);
          v151 = *(_DWORD *)(v56 + 180);
          *(_DWORD *)buf = 136447234;
          v191 = "nw_protocol_http2_add_input_handler";
          v192 = 2082;
          v193 = v56 + 191;
          v194 = 2080;
          v195 = (uint64_t)" ";
          v196 = 1024;
          v197 = v151;
          v198 = 1024;
          *(_DWORD *)v199 = v152;
          _os_log_impl( &dword_181A5C000,  v150,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%d> Failed to add new stream to the id based hash table",  buf,  0x2Cu);
        }
      }

      nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      std::destroy_at[abi:nn180100]<http2_stream,0>(v56);
    }

    free((void *)v56);
    return 0LL;
  }

  __break(1u);
  return result;
}

          v127 = 1;
LABEL_175:
          v158 = (dispatch_object_s *)*((void *)v305 + 3);
          if (v158)
          {
            dispatch_release(v158);
            *((void *)v305 + 3) = 0LL;
          }

          _Block_object_dispose(&v281, 8);
          _Block_object_dispose(&v285, 8);
          _Block_object_dispose(&v289, 8);
          _Block_object_dispose(&v293, 8);
          _Block_object_dispose(v297, 8);
          _Block_object_dispose(v299, 8);
          _Block_object_dispose(&v300, 8);
          _Block_object_dispose(type, 8);
          if ((v127 & 1) != 0 || *((_DWORD *)v313 + 6) >= a5) {
            goto LABEL_199;
          }
        }
      }

      if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v214 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v215 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v317 = "nw_protocol_http2_get_input_frames";
          v318 = 2082;
          v319 = handle + 390;
          v320 = 2080;
          v321 = (uint64_t)" ";
          v322 = 1024;
          *(_DWORD *)v323 = v215;
          _os_log_impl( &dword_181A5C000,  v214,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> adding informational response",  buf,  0x26u);
        }
      }

      v34 = (nw_protocol_metadata *)nw_array_remove_object_at_index(*(void *)(v14 + 160), 0LL);
      v35 = http2_create_input_frame((uint64_t)handle, v14, 0LL);
      if (v35)
      {
        v36 = v35;
        nw_frame_set_metadata(v35, v34, 1, 1);
        *(void *)(v36 + 32) = 0LL;
        v37 = a6->tqh_last;
        *(void *)(v36 + 40) = v37;
        *v37 = (nw_frame *)v36;
        a6->tqh_last = (nw_frame **)(v36 + 32);
        v38 = *((unsigned int *)v313 + 6) + 1LL;
        v39 = v38 << 31 >> 31;
        *((_DWORD *)v313 + 6) = v38;
        if (v39 == v38 && (v39 & 0x8000000000000000LL) == 0) {
          goto LABEL_234;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = *((unsigned int *)v313 + 6);
        *(_DWORD *)buf = 136446978;
        v317 = "nw_protocol_http2_get_input_frames";
        v318 = 2082;
        v319 = "return_frame_count";
        v320 = 2048;
        v321 = 1LL;
        v322 = 2048;
        *(void *)v323 = v40;
        v41 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v300) = 0;
        if (__nwlog_fault(v41, type, &v300))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v42 = (os_log_s *)gLogObj;
            v43 = type[0];
            if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
            {
              v44 = *((unsigned int *)v313 + 6);
              *(_DWORD *)buf = 136446978;
              v317 = "nw_protocol_http2_get_input_frames";
              v318 = 2082;
              v319 = "return_frame_count";
              v320 = 2048;
              v321 = 1LL;
              v322 = 2048;
              *(void *)v323 = v44;
              v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_230:
              _os_log_impl(&dword_181A5C000, v42, v43, v45, buf, 0x2Au);
            }
          }

          else if ((_BYTE)v300)
          {
            v182 = (char *)__nw_create_backtrace_string();
            v42 = (os_log_s *)__nwlog_obj();
            v43 = type[0];
            v183 = os_log_type_enabled(v42, type[0]);
            if (v182)
            {
              if (v183)
              {
                v184 = *((unsigned int *)v313 + 6);
                *(_DWORD *)buf = 136447234;
                v317 = "nw_protocol_http2_get_input_frames";
                v318 = 2082;
                v319 = "return_frame_count";
                v320 = 2048;
                v321 = 1LL;
                v322 = 2048;
                *(void *)v323 = v184;
                *(_WORD *)&v323[8] = 2082;
                *(void *)&v323[10] = v182;
                _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v182);
              goto LABEL_231;
            }

            if (v183)
            {
              v186 = *((unsigned int *)v313 + 6);
              *(_DWORD *)buf = 136446978;
              v317 = "nw_protocol_http2_get_input_frames";
              v318 = 2082;
              v319 = "return_frame_count";
              v320 = 2048;
              v321 = 1LL;
              v322 = 2048;
              *(void *)v323 = v186;
              v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_230;
            }
          }

          else
          {
            v42 = (os_log_s *)__nwlog_obj();
            v43 = type[0];
            if (os_log_type_enabled(v42, type[0]))
            {
              v185 = *((unsigned int *)v313 + 6);
              *(_DWORD *)buf = 136446978;
              v317 = "nw_protocol_http2_get_input_frames";
              v318 = 2082;
              v319 = "return_frame_count";
              v320 = 2048;
              v321 = 1LL;
              v322 = 2048;
              *(void *)v323 = v185;
              v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_230;
            }
          }
        }

    if (!v40) {
      goto LABEL_149;
    }
    goto LABEL_148;
  }

  *(_BYTE *)(a3 + 190) = BYTE2(v20);
  *(_WORD *)(a3 + 188) = v20 | 0x100;
  if (a4)
  {
    v21 = *(void *)(a4 + 64);
    v23 = v21
       && (*(_BYTE *)(v21 + 66) & 0x40) != 0
       && ((v22 = *(_DWORD *)(a4 + 52)) == 0 || v22 == *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60))
       && (v20 & 0x200) == 0;
    goto LABEL_55;
  }

  __nwlog_obj();
  LODWORD(buf[0]) = 136446210;
  *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
  v257 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v374[0]) = 0;
  if (__nwlog_fault(v257, type, v374))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v258 = (os_log_s *)__nwlog_obj();
      v259 = type[0];
      if (os_log_type_enabled(v258, type[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        v260 = "%{public}s called with null frame";
LABEL_487:
        _os_log_impl(&dword_181A5C000, v258, v259, v260, (uint8_t *)buf, 0xCu);
      }
    }

    else if (LOBYTE(v374[0]))
    {
      v279 = (char *)__nw_create_backtrace_string();
      v258 = (os_log_s *)__nwlog_obj();
      v259 = type[0];
      v280 = os_log_type_enabled(v258, type[0]);
      if (v279)
      {
        if (v280)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v279;
          _os_log_impl( &dword_181A5C000,  v258,  v259,  "%{public}s called with null frame, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
        }

        free(v279);
        goto LABEL_488;
      }

      if (v280)
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        v260 = "%{public}s called with null frame, no backtrace";
        goto LABEL_487;
      }
    }

    else
    {
      v258 = (os_log_s *)__nwlog_obj();
      v259 = type[0];
      if (os_log_type_enabled(v258, type[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        v260 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_487;
      }
    }
  }

      if (v51) {
        free(v51);
      }
      v21 = 0LL;
      goto LABEL_27;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v81 = "nw_protocol_ipv6_get_output_frames";
    v47 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = (os_log_s *)__nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null ipv6";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    if (!v78)
    {
      v48 = (os_log_s *)__nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    v60 = (char *)__nw_create_backtrace_string();
    v48 = (os_log_s *)__nwlog_obj();
    v49 = type;
    v63 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      v81 = "nw_protocol_ipv6_get_output_frames";
      v82 = 2082;
      *(void *)v83 = v60;
      v62 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_106;
    }

    goto LABEL_107;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v81 = "nw_protocol_ipv6_get_output_frames";
  v47 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v78 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v78)
    {
      v48 = (os_log_s *)__nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    v60 = (char *)__nw_create_backtrace_string();
    v48 = (os_log_s *)__nwlog_obj();
    v49 = type;
    v61 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_140;
      }

      goto LABEL_141;
    }

    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v81 = "nw_protocol_ipv6_get_output_frames";
      v82 = 2082;
      *(void *)v83 = v60;
      v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_106:
      _os_log_impl(&dword_181A5C000, v48, v49, v62, buf, 0x16u);
    }

LABEL_148:
          *((_BYTE *)v160 + 476) |= 0x20u;
          if ((v53 & 0x80000) == 0)
          {
LABEL_104:
            if ((v53 & 0x20) == 0) {
              goto LABEL_105;
            }
            goto LABEL_150;
          }

        if (v67) {
          free(v67);
        }
        goto LABEL_173;
      }

      __nwlog_obj();
      v115 = (void *)objc_claimAutoreleasedReturnValue();
      v116 = *(_DWORD *)(a1 + 132);
      *(_DWORD *)buf = 136446466;
      v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
      v131 = 1024;
      *(_DWORD *)v132 = v116;
      v37 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v127 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v37, type, &v127))
      {
LABEL_107:
        if (v37) {
          free(v37);
        }
        return 0LL;
      }

      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v117 = type[0];
        if (os_log_type_enabled(v38, type[0]))
        {
          v118 = *(_DWORD *)(a1 + 132);
          *(_DWORD *)buf = 136446466;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 1024;
          *(_DWORD *)v132 = v118;
          _os_log_impl(&dword_181A5C000, v38, v117, "%{public}s port %u > NEXUS_PORT_MAX", buf, 0x12u);
        }

        goto LABEL_106;
      }

      if (v127 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v122 = type[0];
        if (os_log_type_enabled(v38, type[0]))
        {
          v123 = *(_DWORD *)(a1 + 132);
          *(_DWORD *)buf = 136446466;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 1024;
          *(_DWORD *)v132 = v123;
          _os_log_impl( &dword_181A5C000,  v38,  v122,  "%{public}s port %u > NEXUS_PORT_MAX, backtrace limit exceeded",  buf,  0x12u);
        }

        goto LABEL_106;
      }

      v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v119 = type[0];
      v120 = os_log_type_enabled(v38, type[0]);
      if (!v48)
      {
        if (v120)
        {
          v124 = *(_DWORD *)(a1 + 132);
          *(_DWORD *)buf = 136446466;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 1024;
          *(_DWORD *)v132 = v124;
          _os_log_impl(&dword_181A5C000, v38, v119, "%{public}s port %u > NEXUS_PORT_MAX, no backtrace", buf, 0x12u);
        }

        goto LABEL_106;
      }

      if (v120)
      {
        v121 = *(_DWORD *)(a1 + 132);
        *(_DWORD *)buf = 136446722;
        v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
        v131 = 1024;
        *(_DWORD *)v132 = v121;
        *(_WORD *)&v132[4] = 2082;
        *(void *)&v132[6] = v48;
        _os_log_impl( &dword_181A5C000,  v38,  v119,  "%{public}s port %u > NEXUS_PORT_MAX, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }
    }

    else
    {
      __nwlog_obj();
      v40 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
      v131 = 2112;
      *(void *)v132 = a1;
      v37 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v127 = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v41 = type[0];
        if (os_log_type_enabled(v38, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 2112;
          *(void *)v132 = a1;
          _os_log_impl( &dword_181A5C000,  v38,  v41,  "%{public}s %@: createChannel failed to create channel attributes",  buf,  0x16u);
        }

        goto LABEL_106;
      }

      if (v127 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v64 = type[0];
        if (os_log_type_enabled(v38, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 2112;
          *(void *)v132 = a1;
          _os_log_impl( &dword_181A5C000,  v38,  v64,  "%{public}s %@: createChannel failed to create channel attributes, backtrace limit exceeded",  buf,  0x16u);
        }

        goto LABEL_106;
      }

      v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v49 = type[0];
      v50 = os_log_type_enabled(v38, type[0]);
      if (!v48)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446466;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 2112;
          *(void *)v132 = a1;
          _os_log_impl( &dword_181A5C000,  v38,  v49,  "%{public}s %@: createChannel failed to create channel attributes, no backtrace",  buf,  0x16u);
        }

        goto LABEL_106;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446722;
        v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
        v131 = 2112;
        *(void *)v132 = a1;
        *(_WORD *)&v132[8] = 2082;
        *(void *)&v132[10] = v48;
        _os_log_impl( &dword_181A5C000,  v38,  v49,  "%{public}s %@: createChannel failed to create channel attributes, dumping backtrace:%{public}s",  buf,  0x20u);
      }
    }

    free(v48);
    goto LABEL_107;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v3 = *(void *)(a1 + 24);
    v4 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)buf = 136447234;
    v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
    v131 = 2080;
    *(void *)v132 = v3;
    *(_WORD *)&v132[8] = 1042;
    *(_DWORD *)&v132[10] = 16;
    *(_WORD *)&v132[14] = 2098;
    *(void *)&v132[16] = a1 + 115;
    *(_WORD *)&v132[24] = 1024;
    *(_DWORD *)&v132[26] = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEBUG,  "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] createChannel: channel already exists",  buf,  0x2Cu);
  }

  return 1LL;
}

      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (!v30)
      {
LABEL_159:
        v21 = 0LL;
        goto LABEL_160;
      }

      if (v34) {
        free(v34);
      }
      goto LABEL_35;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http_authentication_apply_cache";
    v30 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v52[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v30, type, v52))
    {
      if (type[0] == 17)
      {
        v31 = (os_log_s *)__nwlog_obj();
        v32 = type[0];
        if (!os_log_type_enabled(v31, (os_log_type_t)type[0])) {
          goto LABEL_143;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http_authentication_apply_cache";
        v33 = "%{public}s called with null http_authentication->outbound_metadata";
        goto LABEL_142;
      }

      if (v52[0] == OS_LOG_TYPE_DEFAULT)
      {
        v31 = (os_log_s *)__nwlog_obj();
        v32 = type[0];
        if (!os_log_type_enabled(v31, (os_log_type_t)type[0])) {
          goto LABEL_143;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http_authentication_apply_cache";
        v33 = "%{public}s called with null http_authentication->outbound_metadata, backtrace limit exceeded";
        goto LABEL_142;
      }

      v48 = (char *)__nw_create_backtrace_string();
      v31 = (os_log_s *)__nwlog_obj();
      v32 = type[0];
      v49 = os_log_type_enabled(v31, (os_log_type_t)type[0]);
      if (v48)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_http_authentication_apply_cache";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v48;
          _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null http_authentication->outbound_metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v48);
        if (!v30) {
          goto LABEL_38;
        }
        goto LABEL_144;
      }

      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http_authentication_apply_cache";
        v33 = "%{public}s called with null http_authentication->outbound_metadata, no backtrace";
LABEL_142:
        _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http_authentication_apply_cache";
    v30 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v52[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == 17)
    {
      v31 = (os_log_s *)__nwlog_obj();
      v32 = type[0];
      if (!os_log_type_enabled(v31, (os_log_type_t)type[0])) {
        goto LABEL_143;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http_authentication_apply_cache";
      v33 = "%{public}s called with null http_authentication";
      goto LABEL_142;
    }

    if (v52[0] == OS_LOG_TYPE_DEFAULT)
    {
      v31 = (os_log_s *)__nwlog_obj();
      v32 = type[0];
      if (!os_log_type_enabled(v31, (os_log_type_t)type[0])) {
        goto LABEL_143;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http_authentication_apply_cache";
      v33 = "%{public}s called with null http_authentication, backtrace limit exceeded";
      goto LABEL_142;
    }

    v46 = (char *)__nw_create_backtrace_string();
    v31 = (os_log_s *)__nwlog_obj();
    v32 = type[0];
    v47 = os_log_type_enabled(v31, (os_log_type_t)type[0]);
    if (!v46)
    {
      if (!v47) {
        goto LABEL_143;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http_authentication_apply_cache";
      v33 = "%{public}s called with null http_authentication, no backtrace";
      goto LABEL_142;
    }

    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_http_authentication_apply_cache";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v46;
      _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v46);
  }

      *(void *)v85 = *(void *)(j - 8);
      v85 += 8;
      j = a2[1].i64[0] - 8;
      a2[1].i64[0] = j;
      v84 = v110;
      if (!--v18) {
        goto LABEL_136;
      }
    }
  }

  v110 = v84;
LABEL_136:
  v18 = (unint64_t)v33;
  v111 = (uint64_t *)a2->i64[1];
  if (v111 != (uint64_t *)j)
  {
    while (1)
    {
      if (v85 == (char *)v15)
      {
        if ((unint64_t)v110 <= v18)
        {
          if (v15 == v18) {
            v144 = 1LL;
          }
          else {
            v144 = (uint64_t)(v15 - v18) >> 2;
          }
          v145 = calloc(v144, 8uLL);
          if (!v145) {
            goto LABEL_54;
          }
          v146 = (unint64_t)v145;
          v147 = v144 >> 2;
          j = (unint64_t)&v145[8 * (v144 >> 2)];
          v85 = (char *)j;
          v148 = v15 - (void)v110;
          if ((uint64_t *)v15 != v110)
          {
            v85 = (char *)(j + (v148 & 0xFFFFFFFFFFFFFFF8LL));
            v149 = v148 - 8;
            if (v149 >= 0x38)
            {
              v151 = 8 * v147;
              if ((unint64_t)(&v145[8 * v147] - (_BYTE *)v110) < 0x20)
              {
                v150 = &v145[8 * (v144 >> 2)];
                goto LABEL_197;
              }

              v152 = (v149 >> 3) + 1;
              v153 = 8 * (v152 & 0x3FFFFFFFFFFFFFFCLL);
              v150 = (char *)(j + v153);
              v154 = (__int128 *)(v110 + 2);
              v155 = &v145[v151 + 16];
              v156 = v152 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v157 = *v154;
                *(v155 - 1) = *(v154 - 1);
                *v155 = v157;
                v154 += 2;
                v155 += 2;
                v156 -= 4LL;
              }

              while (v156);
              if (v152 != (v152 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v110 = (uint64_t *)((char *)v110 + v153);
                goto LABEL_197;
              }
            }

            else
            {
              v150 = &v145[8 * (v144 >> 2)];
              do
              {
LABEL_197:
                v158 = *v110++;
                *(void *)v150 = v158;
                v150 += 8;
              }

              while (v150 != v85);
            }
          }

          v15 = (uint64_t)&v145[8 * v144];
          if (v18) {
            free((void *)v18);
          }
          v18 = v146;
          goto LABEL_175;
        }

        v139 = (uint64_t)((uint64_t)v110 - v18) >> 3;
        if (v139 >= -1) {
          v140 = v139 + 1;
        }
        else {
          v140 = v139 + 2;
        }
        v141 = v140 >> 1;
        v142 = (char *)&v110[-(v140 >> 1)];
        v143 = (void *)v15;
        if ((uint64_t *)v15 != v110)
        {
          memmove(v142, v110, v15 - (void)v110);
          v143 = v110;
        }

        v85 = &v142[v15 - (void)v110];
        j = (unint64_t)&v143[-v141];
      }

      else
      {
        j = (unint64_t)v110;
      }

LABEL_154:
            return;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v76 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v97 = "nw_endpoint_handler_inject_read_closed";
          v77 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v94 = 0;
          if ((__nwlog_fault(v77, &type, &v94) & 1) != 0)
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v78 = (os_log_s *)(id)gLogObj;
              v79 = type;
              if (os_log_type_enabled(v78, type))
              {
                *(_DWORD *)buf = 136446210;
                v97 = "nw_endpoint_handler_inject_read_closed";
                _os_log_impl(&dword_181A5C000, v78, v79, "%{public}s No endpoint flow", buf, 0xCu);
              }
            }

            else if (v94)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v78 = (os_log_s *)(id)gLogObj;
              v83 = type;
              v84 = os_log_type_enabled(v78, type);
              if (backtrace_string)
              {
                if (v84)
                {
                  *(_DWORD *)buf = 136446466;
                  v97 = "nw_endpoint_handler_inject_read_closed";
                  v98 = 2082;
                  *(void *)v99 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v78,  v83,  "%{public}s No endpoint flow, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(backtrace_string);
                goto LABEL_146;
              }

              if (v84)
              {
                *(_DWORD *)buf = 136446210;
                v97 = "nw_endpoint_handler_inject_read_closed";
                _os_log_impl(&dword_181A5C000, v78, v83, "%{public}s No endpoint flow, no backtrace", buf, 0xCu);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v78 = (os_log_s *)(id)gLogObj;
              v86 = type;
              if (os_log_type_enabled(v78, type))
              {
                *(_DWORD *)buf = 136446210;
                v97 = "nw_endpoint_handler_inject_read_closed";
                _os_log_impl( &dword_181A5C000,  v78,  v86,  "%{public}s No endpoint flow, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

        __break(1u);
        return;
      }

      __nwlog_obj();
      v91 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)out = 136446210;
      *(void *)&out[4] = "nw_http_client_metadata_get_transaction_count";
      LODWORD(v102) = 12;
      v101 = out;
      v84 = (char *)_os_log_send_and_compose_impl();

      string[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v117) = 0;
      if (__nwlog_fault(v84, string, &v117))
      {
        if (string[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v92 = string[0];
          if (os_log_type_enabled(v85, string[0]))
          {
            *(_DWORD *)out = 136446210;
            *(void *)&out[4] = "nw_http_client_metadata_get_transaction_count";
            _os_log_impl(&dword_181A5C000, v85, v92, "%{public}s metadata must be http_client", (uint8_t *)out, 0xCu);
          }
        }

        else if ((_BYTE)v117)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v97 = string[0];
          v98 = os_log_type_enabled(v85, string[0]);
          if (backtrace_string)
          {
            if (v98)
            {
              *(_DWORD *)out = 136446466;
              *(void *)&out[4] = "nw_http_client_metadata_get_transaction_count";
              *(_WORD *)&out[12] = 2082;
              *(void *)&out[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v85,  v97,  "%{public}s metadata must be http_client, dumping backtrace:%{public}s",  (uint8_t *)out,  0x16u);
            }

            free(backtrace_string);
            if (!v84) {
              goto LABEL_146;
            }
            goto LABEL_145;
          }

          if (v98)
          {
            *(_DWORD *)out = 136446210;
            *(void *)&out[4] = "nw_http_client_metadata_get_transaction_count";
            _os_log_impl( &dword_181A5C000,  v85,  v97,  "%{public}s metadata must be http_client, no backtrace",  (uint8_t *)out,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v100 = string[0];
          if (os_log_type_enabled(v85, string[0]))
          {
            *(_DWORD *)out = 136446210;
            *(void *)&out[4] = "nw_http_client_metadata_get_transaction_count";
            _os_log_impl( &dword_181A5C000,  v85,  v100,  "%{public}s metadata must be http_client, backtrace limit exceeded",  (uint8_t *)out,  0xCu);
          }
        }

        goto LABEL_143;
      }

  if (v43) {
    free(v43);
  }
LABEL_13:
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v30 = *(void *)(a2 + 88);
    if (v30)
    {
      v31 = v30 - 1;
      *(void *)(a2 + 88) = v31;
      if (!v31)
      {
        v32 = *(void (***)(void))(a2 + 64);
        if (v32)
        {
          *(void *)(a2 + 64) = 0LL;
          v32[2](v32);
          _Block_release(v32);
        }

        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v33 = *(const void **)(a2 + 64);
          if (v33) {
            _Block_release(v33);
          }
        }

        free((void *)a2);
      }
    }
  }

  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    v34 = *(void *)(v4 + 88);
    if (v34)
    {
      v35 = v34 - 1;
      *(void *)(v4 + 88) = v35;
      if (!v35)
      {
        v36 = *(void (***)(void))(v4 + 64);
        if (v36)
        {
          *(void *)(v4 + 64) = 0LL;
          v36[2](v36);
          _Block_release(v36);
        }

        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          v37 = *(const void **)(v4 + 64);
          if (v37) {
            _Block_release(v37);
          }
        }

        free((void *)v4);
      }
    }
  }

  if (*(void *)(a1 + 32) != a2) {
    return;
  }
  v11 = *(void *)(a1 + 48);
  if (!v11)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "__nw_protocol_connected";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = (os_log_s *)__nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "__nw_protocol_connected";
        v26 = "%{public}s called with null protocol";
        goto LABEL_71;
      }

          if (v62) {
            free(v62);
          }
          goto LABEL_48;
        }
      }

      bzero(buf, 0x3F1uLL);
      v32 = DNSServiceConstructFullName((char *const)buf, a5, a6, a7);
      if (v32)
      {
        dns_error = nw_error_create_dns_error(v32);
        if (nw_parameters_get_logging_disabled(*(void *)&v14[10]._os_unfair_lock_opaque))
        {
LABEL_101:
          os_unfair_lock_unlock(lock);

          goto LABEL_102;
        }

        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        v34 = (id)gbrowserLogObj;
        v35 = v14[48]._os_unfair_lock_opaque;
        *(_DWORD *)v79 = 136447491;
        *(void *)&v79[4] = "nw_browser_dns_service_browse_callback";
        v80 = 1024;
        v81 = v35;
        v82 = 2085;
        v83 = a5;
        v84 = 2082;
        v85 = a6;
        v86 = 2085;
        v87 = a7;
        v88 = 2114;
        v75 = dns_error;
        v89 = dns_error;
        v36 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(v104) = 16;
        v78 = 0;
        if (__nwlog_fault(v36, &v104, &v78))
        {
          if (v104 == 17)
          {
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            v37 = (os_log_s *)(id)gbrowserLogObj;
            v38 = v104;
            if (os_log_type_enabled(v37, (os_log_type_t)v104))
            {
              v39 = v14[48]._os_unfair_lock_opaque;
              *(_DWORD *)v79 = 136447491;
              *(void *)&v79[4] = "nw_browser_dns_service_browse_callback";
              v80 = 1024;
              v81 = v39;
              v82 = 2085;
              v83 = a5;
              v84 = 2082;
              v85 = a6;
              v86 = 2085;
              v87 = a7;
              v88 = 2114;
              v89 = dns_error;
              _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@",  v79,  0x3Au);
            }
          }

          else if (v78)
          {
            v43 = __nw_create_backtrace_string();
            if (v43)
            {
              v44 = (char *)v43;
              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
              }
              v45 = (os_log_s *)(id)gbrowserLogObj;
              v46 = v104;
              if (os_log_type_enabled(v45, (os_log_type_t)v104))
              {
                v47 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)v79 = 136447747;
                *(void *)&v79[4] = "nw_browser_dns_service_browse_callback";
                v80 = 1024;
                v81 = v47;
                v82 = 2085;
                v83 = a5;
                v84 = 2082;
                v85 = a6;
                v86 = 2085;
                v87 = a7;
                v88 = 2114;
                v89 = v75;
                v90 = 2082;
                v91 = v44;
                _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{ public}@, dumping backtrace:%{public}s",  v79,  0x44u);
              }

              free(v44);
              goto LABEL_98;
            }

            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            v37 = (os_log_s *)(id)gbrowserLogObj;
            v50 = v104;
            if (os_log_type_enabled(v37, (os_log_type_t)v104))
            {
              v51 = v14[48]._os_unfair_lock_opaque;
              *(_DWORD *)v79 = 136447491;
              *(void *)&v79[4] = "nw_browser_dns_service_browse_callback";
              v80 = 1024;
              v81 = v51;
              v82 = 2085;
              v83 = a5;
              v84 = 2082;
              v85 = a6;
              v86 = 2085;
              v87 = a7;
              v88 = 2114;
              v89 = dns_error;
              _os_log_impl( &dword_181A5C000,  v37,  v50,  "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{pu blic}@, no backtrace",  v79,  0x3Au);
            }
          }

          else
          {
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            v37 = (os_log_s *)(id)gbrowserLogObj;
            v48 = v104;
            if (os_log_type_enabled(v37, (os_log_type_t)v104))
            {
              v49 = v14[48]._os_unfair_lock_opaque;
              *(_DWORD *)v79 = 136447491;
              *(void *)&v79[4] = "nw_browser_dns_service_browse_callback";
              v80 = 1024;
              v81 = v49;
              v82 = 2085;
              v83 = a5;
              v84 = 2082;
              v85 = a6;
              v86 = 2085;
              v87 = a7;
              v88 = 2114;
              v89 = dns_error;
              _os_log_impl( &dword_181A5C000,  v37,  v48,  "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{pu blic}@, backtrace limit exceeded",  v79,  0x3Au);
            }
          }
        }

      if (v72) {
        free(v72);
      }
      goto LABEL_101;
    }

    if (a5 | a4)
    {
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
      }
      v24 = (os_log_s *)(id)gactivityLogObj;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_37;
      }
      if (a2 - 1 > 3) {
        v25 = "invalid";
      }
      else {
        v25 = off_189BC2D88[a2 - 1];
      }
      os_unfair_lock_opaque = v13[31]._os_unfair_lock_opaque;
      v27 = v13[32]._os_unfair_lock_opaque;
      v29 = nw_activity_get_duration(v13);
      *(_DWORD *)buf = 138544642;
      *(void *)&buf[4] = v13;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)v119 = a2;
      *(_WORD *)&v119[4] = 2082;
      *(void *)&v119[6] = v25;
      *(_WORD *)&v119[14] = 1024;
      *(_DWORD *)&v119[16] = os_unfair_lock_opaque;
      *(_WORD *)&v119[20] = 1024;
      *(_DWORD *)&v119[22] = v27;
      *(_WORD *)&v119[26] = 2048;
      v120 = v29;
      v30 = "%{public}@ complete with reason %u (%{public}s), underlying error %d:%d, duration %llums";
      v31 = v24;
      v32 = 50;
    }

    else
    {
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
      }
      v24 = (os_log_s *)(id)gactivityLogObj;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_37;
      }
      if (a2 - 1 > 3) {
        v26 = "invalid";
      }
      else {
        v26 = off_189BC2D88[a2 - 1];
      }
      v33 = nw_activity_get_duration(v13);
      *(_DWORD *)buf = 138544130;
      *(void *)&buf[4] = v13;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)v119 = a2;
      *(_WORD *)&v119[4] = 2082;
      *(void *)&v119[6] = v26;
      *(_WORD *)&v119[14] = 2048;
      *(void *)&v119[16] = v33;
      v30 = "%{public}@ complete with reason %u (%{public}s), duration %llums";
      v31 = v24;
      v32 = 38;
    }

    _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
LABEL_37:

    goto LABEL_38;
  }

  __nwlog_obj();
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446466;
  *(void *)&buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
  *(_WORD *)&buf[12] = 2082;
  *(void *)v119 = "Invalid completion reason";
  v68 = (char *)_os_log_send_and_compose_impl();

  v126[0] = 16;
  LOBYTE(v116) = 0;
  if (__nwlog_fault(v68, v126, &v116))
  {
    if (v126[0] == 17)
    {
      __nwlog_obj();
      v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v70 = v126[0];
      if (os_log_type_enabled(v69, (os_log_type_t)v126[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
        *(_WORD *)&buf[12] = 2082;
        *(void *)v119 = "Invalid completion reason";
        _os_log_impl(&dword_181A5C000, v69, v70, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }

    else if ((_BYTE)v116)
    {
      v75 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v76 = v126[0];
      v77 = os_log_type_enabled(v69, (os_log_type_t)v126[0]);
      if (v75)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
          *(_WORD *)&buf[12] = 2082;
          *(void *)v119 = "Invalid completion reason";
          *(_WORD *)&v119[8] = 2082;
          *(void *)&v119[10] = v75;
          _os_log_impl( &dword_181A5C000,  v69,  v76,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v75);
        goto LABEL_143;
      }

      if (v77)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
        *(_WORD *)&buf[12] = 2082;
        *(void *)v119 = "Invalid completion reason";
        _os_log_impl( &dword_181A5C000,  v69,  v76,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace",  buf,  0x16u);
      }
    }

    else
    {
      __nwlog_obj();
      v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v81 = v126[0];
      if (os_log_type_enabled(v69, (os_log_type_t)v126[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
        *(_WORD *)&buf[12] = 2082;
        *(void *)v119 = "Invalid completion reason";
        _os_log_impl( &dword_181A5C000,  v69,  v81,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded",  buf,  0x16u);
      }
    }
  }

        if (v99) {
          free(v99);
        }
        goto LABEL_117;
      }
    }
  }

  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

        free(v55);
        goto LABEL_149;
      }

      if (v65)
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl( &dword_181A5C000,  v56,  v64,  "%{public}s called with null !uuid_is_null(client_id), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v67 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_path_create_evaluator_for_client_id";
        _os_log_impl( &dword_181A5C000,  v56,  v67,  "%{public}s called with null !uuid_is_null(client_id), backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_149:
          *((_BYTE *)v160 + 476) |= 0x40u;
          if ((v53 & 0x20) == 0)
          {
LABEL_105:
            if ((v53 & 0x100) == 0) {
              goto LABEL_106;
            }
            goto LABEL_151;
          }

      goto LABEL_175;
    }

    if (v181 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v104 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl( &dword_181A5C000,  v78,  v104,  "%{public}s failed to add kIDSKeyRemoteCID, backtrace limit exceeded",  type,  0xCu);
      }

      goto LABEL_149;
    }

    v80 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v97 = __str[0];
    v98 = os_log_type_enabled(v78, __str[0]);
    if (!v80)
    {
      if (v98)
      {
        *(_DWORD *)type = 136446210;
        *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_181A5C000, v78, v97, "%{public}s failed to add kIDSKeyRemoteCID, no backtrace", type, 0xCu);
      }

      goto LABEL_149;
    }

    if (v98)
    {
      *(_DWORD *)type = 136446466;
      *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
      *(_WORD *)&type[12] = 2082;
      *(void *)&type[14] = v80;
      _os_log_impl( &dword_181A5C000,  v78,  v97,  "%{public}s failed to add kIDSKeyRemoteCID, dumping backtrace:%{public}s",  type,  0x16u);
    }

    goto LABEL_100;
  }

  v65 = (id)dictionary_with_initial_length;
  v66 = snprintf((char *)__str, 0x15uLL, "%llu", v173);
  v67 = v66;
  if (v66 >= 0x15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v68 = (id)gLogObj;
    v69 = v67 - 20;
    *(_DWORD *)type = 136446466;
    *(void *)&type[4] = "nw_txt_record_set_key_uint64_value";
    *(_WORD *)&type[12] = 2048;
    *(void *)&type[14] = v67 - 20;
    v70 = (char *)_os_log_send_and_compose_impl();

    v181 = OS_LOG_TYPE_ERROR;
    v180 = 0;
    if (__nwlog_fault(v70, &v181, &v180))
    {
      if (v181 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v72 = v181;
        if (os_log_type_enabled(v71, v181))
        {
          *(_DWORD *)type = 136446466;
          *(void *)&type[4] = "nw_txt_record_set_key_uint64_value";
          *(_WORD *)&type[12] = 2048;
          *(void *)&type[14] = v69;
          _os_log_impl(&dword_181A5C000, v71, v72, "%{public}s buffer was too small by %lu bytes", type, 0x16u);
        }
      }

      else
      {
        if (v180)
        {
          v100 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v172 = v181;
          v102 = os_log_type_enabled(v101, v181);
          if (v100)
          {
            if (v102)
            {
              *(_DWORD *)type = 136446722;
              *(void *)&type[4] = "nw_txt_record_set_key_uint64_value";
              *(_WORD *)&type[12] = 2048;
              *(void *)&type[14] = v69;
              *(_WORD *)&type[22] = 2082;
              v183[0] = v100;
              _os_log_impl( &dword_181A5C000,  v101,  v172,  "%{public}s buffer was too small by %lu bytes, dumping backtrace:%{public}s",  type,  0x20u);
            }

            free(v100);
          }

          else
          {
            if (v102)
            {
              *(_DWORD *)type = 136446466;
              *(void *)&type[4] = "nw_txt_record_set_key_uint64_value";
              *(_WORD *)&type[12] = 2048;
              *(void *)&type[14] = v69;
              _os_log_impl( &dword_181A5C000,  v101,  v172,  "%{public}s buffer was too small by %lu bytes, no backtrace",  type,  0x16u);
            }
          }

          goto LABEL_156;
        }

        __nwlog_obj();
        v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v105 = v181;
        if (os_log_type_enabled(v71, v181))
        {
          *(_DWORD *)type = 136446466;
          *(void *)&type[4] = "nw_txt_record_set_key_uint64_value";
          *(_WORD *)&type[12] = 2048;
          *(void *)&type[14] = v69;
          _os_log_impl( &dword_181A5C000,  v71,  v105,  "%{public}s buffer was too small by %lu bytes, backtrace limit exceeded",  type,  0x16u);
        }
      }
    }

                  if (v79) {
                    free(v79);
                  }
                }

    goto LABEL_150;
  }

  if (!v12)
  {
    __nwlog_obj();
    v65 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
    v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v66 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_181A5C000, v63, v66, "%{public}s called with null data", buf, 0xCu);
      }

      goto LABEL_149;
    }

    if (!v80)
    {
      __nwlog_obj();
      v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v78 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl( &dword_181A5C000,  v63,  v78,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_149;
    }

    v72 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v73 = type[0];
    v74 = os_log_type_enabled(v63, type[0]);
    if (!v72)
    {
      if (v74)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_181A5C000, v63, v73, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }

      goto LABEL_149;
    }

    if (v74)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
      v84 = 2082;
      v85 = v72;
      _os_log_impl( &dword_181A5C000,  v63,  v73,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_130;
  }

  v14 = (void *)*((void *)v11 + 15);
  if (v14)
  {
    v15 = v14;
    v16 = v15;
    if (((_BYTE)v15[17] & 8) == 0) {
      dispatch_assert_queue_V2(v15[1]);
    }
  }

  if (v13) {
    nw_frame_set_metadata((uint64_t)v12, v13, 1, a5);
  }
  if (a6) {
    v12[186] |= 0x80u;
  }
  if (*(_DWORD *)(*((void *)v11 + 1) + 64LL) == 3)
  {
    node = nw_hash_table_get_node(*((void *)v11 + 29), a2, 8LL);
    if (node)
    {
      v18 = *((_DWORD *)v12 + 13);
      if (v18) {
        v18 -= *((_DWORD *)v12 + 14) + *((_DWORD *)v12 + 15);
      }
      v19 = *(_DWORD *)(node + 68) + v18;
      ++*(_DWORD *)(node + 64);
      *(_DWORD *)(node + 68) = v19;
      *((void *)v12 + 4) = 0LL;
      v20 = *(void **)(node + 56);
      *((void *)v12 + 5) = v20;
      *v20 = v12;
      *(void *)(node + 56) = v12 + 32;
      v21 = *(_WORD *)(node + 84);
      if ((v21 & 0x10) != 0)
      {
        if ((v11[403] & 0x10) != 0)
        {
          if (a6) {
            *(_WORD *)(node + 84) = v21 | 0x40;
          }
        }

        else
        {
          v22 = *(void **)(node + 16);
          if (v22)
          {
            v23 = v22[3];
            if (v23)
            {
              v24 = *(void (**)(void *, char *))(v23 + 64);
              if (v24)
              {
                v25 = (void *)v22[5];
                if (v25 == &nw_protocol_ref_counted_handle)
                {
                  v45 = v22[11];
                  if (v45) {
                    v22[11] = v45 + 1;
                  }
                  v26 = -1;
                }

                else
                {
                  v26 = 0;
                }

                *(void *)buf = v22;
                buf[8] = v26;
                v46 = (void *)*((void *)v11 - 7);
                if (v46 == &nw_protocol_ref_counted_handle)
                {
                  v48 = *((void *)v11 - 1);
                  if (v48) {
                    *((void *)v11 - 1) = v48 + 1;
                  }
                  v47 = -1;
                }

                else
                {
                  v47 = 0;
                }

                *(void *)type = v11 - 96;
                v82 = v47;
                v24(v22, v11 - 96);
                if (v46 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                }
                if (v25 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
              }
            }

            if (a6)
            {
              v49 = v22[3];
              if (v49)
              {
                v50 = *(void (**)(void *, char *))(v49 + 184);
                if (v50)
                {
                  v51 = (void *)v22[5];
                  if (v51 == &nw_protocol_ref_counted_handle)
                  {
                    v57 = v22[11];
                    if (v57) {
                      v22[11] = v57 + 1;
                    }
                    v52 = -1;
                  }

                  else
                  {
                    v52 = 0;
                  }

                  *(void *)buf = v22;
                  buf[8] = v52;
                  v58 = (void *)*((void *)v11 - 7);
                  if (v58 == &nw_protocol_ref_counted_handle)
                  {
                    v60 = *((void *)v11 - 1);
                    if (v60) {
                      *((void *)v11 - 1) = v60 + 1;
                    }
                    v59 = -1;
                  }

                  else
                  {
                    v59 = 0;
                  }

                  *(void *)type = v11 - 96;
                  v82 = v59;
                  v50(v22, v11 - 96);
                  if (v58 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
                  if (v51 == &nw_protocol_ref_counted_handle)
                  {
LABEL_99:
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    goto LABEL_100;
                  }
                }
              }
            }
          }
        }
      }
    }

    else if ((v11[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
        v84 = 2082;
        v85 = v11 + 407;
        v86 = 2080;
        v87 = " ";
        v88 = 2048;
        v89 = a2;
        _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sCannot add inbound data, flow %llx does not exist",  buf,  0x2Au);
      }
    }

    goto LABEL_100;
  }

  if (a2 != -1)
  {
    __nwlog_obj();
    v70 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
    v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v71 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl( &dword_181A5C000,  v63,  v71,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW)",  buf,  0xCu);
      }

      goto LABEL_149;
    }

    if (!v80)
    {
      __nwlog_obj();
      v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v79 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl( &dword_181A5C000,  v63,  v79,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_149;
    }

    v72 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v75 = type[0];
    v76 = os_log_type_enabled(v63, type[0]);
    if (!v72)
    {
      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl( &dword_181A5C000,  v63,  v75,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), no backtrace",  buf,  0xCu);
      }

      goto LABEL_149;
    }

    if (v76)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_instance_add_inbound";
      v84 = 2082;
      v85 = v72;
      _os_log_impl( &dword_181A5C000,  v63,  v75,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), dumping backtrace:%{public}s",  buf,  0x16u);
    }

                if (!v53) {
                  goto LABEL_157;
                }
                goto LABEL_150;
              }

              if (a1->default_input_handler != a2)
              {
                if (v8[405] < 0) {
                  goto LABEL_157;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v35 = (id)gLogObj;
                default_input_handler = a1->default_input_handler;
                *(_DWORD *)buf = 136447234;
                *(void *)&buf[4] = "nw_protocol_implementation_replace_input_handler";
                v148 = 2082;
                v149 = v9 + 407;
                v150 = 2080;
                v151 = " ";
                v152 = 2048;
                *(void *)v153 = default_input_handler;
                *(_WORD *)&v153[8] = 2048;
                *(void *)&v153[10] = a2;
                v37 = (const char *)_os_log_send_and_compose_impl();

                LOBYTE(v154) = 16;
                type = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v37, &v154, &type))
                {
                  if (v154 == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v38 = (os_log_s *)(id)gLogObj;
                    v39 = v154;
                    if (os_log_type_enabled(v38, (os_log_type_t)v154))
                    {
                      v40 = a1->default_input_handler;
                      *(_DWORD *)buf = 136447234;
                      *(void *)&buf[4] = "nw_protocol_implementation_replace_input_handler";
                      v148 = 2082;
                      v149 = v9 + 407;
                      v150 = 2080;
                      v151 = " ";
                      v152 = 2048;
                      *(void *)v153 = v40;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = a2;
                      _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s %{public}s%sOld input handler does not match (%p != %p)",  buf,  0x34u);
                    }
                  }

                  else if (type)
                  {
                    v48 = (char *)__nw_create_backtrace_string();
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v38 = (os_log_s *)(id)gLogObj;
                    v49 = v154;
                    v50 = os_log_type_enabled(v38, (os_log_type_t)v154);
                    if (v48)
                    {
                      if (v50)
                      {
                        v51 = a1->default_input_handler;
                        *(_DWORD *)buf = 136447490;
                        *(void *)&buf[4] = "nw_protocol_implementation_replace_input_handler";
                        v148 = 2082;
                        v149 = v9 + 407;
                        v150 = 2080;
                        v151 = " ";
                        v152 = 2048;
                        *(void *)v153 = v51;
                        *(_WORD *)&v153[8] = 2048;
                        *(void *)&v153[10] = a2;
                        *(_WORD *)&v153[18] = 2082;
                        *(void *)&v153[20] = v48;
                        _os_log_impl( &dword_181A5C000,  v38,  v49,  "%{public}s %{public}s%sOld input handler does not match (%p != %p), dumping backtrace:%{public}s",  buf,  0x3Eu);
                      }

                      free(v48);
                      if (!v37) {
                        goto LABEL_157;
                      }
LABEL_131:
                      v89 = (char *)v37;
LABEL_156:
                      free(v89);
                      goto LABEL_157;
                    }

                    if (v50)
                    {
                      v88 = a1->default_input_handler;
                      *(_DWORD *)buf = 136447234;
                      *(void *)&buf[4] = "nw_protocol_implementation_replace_input_handler";
                      v148 = 2082;
                      v149 = v9 + 407;
                      v150 = 2080;
                      v151 = " ";
                      v152 = 2048;
                      *(void *)v153 = v88;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = a2;
                      _os_log_impl( &dword_181A5C000,  v38,  v49,  "%{public}s %{public}s%sOld input handler does not match (%p != %p), no backtrace",  buf,  0x34u);
                    }
                  }

                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v38 = (os_log_s *)(id)gLogObj;
                    v56 = v154;
                    if (os_log_type_enabled(v38, (os_log_type_t)v154))
                    {
                      v57 = a1->default_input_handler;
                      *(_DWORD *)buf = 136447234;
                      *(void *)&buf[4] = "nw_protocol_implementation_replace_input_handler";
                      v148 = 2082;
                      v149 = v9 + 407;
                      v150 = 2080;
                      v151 = " ";
                      v152 = 2048;
                      *(void *)v153 = v57;
                      *(_WORD *)&v153[8] = 2048;
                      *(void *)&v153[10] = a2;
                      _os_log_impl( &dword_181A5C000,  v38,  v56,  "%{public}s %{public}s%sOld input handler does not match (%p != %p), backtrace limit exceeded",  buf,  0x34u);
                    }
                  }
                }

                if (!v37) {
                  goto LABEL_157;
                }
                goto LABEL_131;
              }

              if (a2 != a3)
              {
                if (a2->handle == &nw_protocol_ref_counted_handle)
                {
                  v80 = a2[1].callbacks;
                  if (v80)
                  {
                    v81 = (nw_protocol_callbacks *)((char *)v80 - 1);
                    a2[1].callbacks = v81;
                    if (!v81)
                    {
                      v82 = *(void (***)(void))a2[1].flow_id;
                      if (v82)
                      {
                        *(void *)a2[1].flow_id = 0LL;
                        v82[2](v82);
                        _Block_release(v82);
                      }

                      if ((a2[1].flow_id[8] & 1) != 0)
                      {
                        v83 = *(const void **)a2[1].flow_id;
                        if (v83) {
                          _Block_release(v83);
                        }
                      }

                      free(a2);
                    }
                  }
                }

                a1->default_input_handler = a3;
                if (a3->handle == &nw_protocol_ref_counted_handle)
                {
                  v42 = a3[1].callbacks;
                  if (v42) {
                    a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v42->add_input_handler + 1);
                  }
                }
              }

              *(_OWORD *)a1->flow_id = *(_OWORD *)a3->flow_id;
              if (!a3->output_handler)
              {
                a3->output_handler = a1;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  v43 = a1[1].callbacks;
                  if (v43) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v43->add_input_handler + 1);
                  }
                }
              }

              v44 = a3->callbacks;
              if (v44)
              {
                v45 = (uint64_t (*)(nw_protocol *))v44->supports_external_data;
                if (v45)
                {
                  v46 = a3->handle;
                  if (v46 == &nw_protocol_ref_counted_handle)
                  {
                    v84 = a3[1].callbacks;
                    if (v84) {
                      a3[1].callbacks = (nw_protocol_callbacks *)((char *)&v84->add_input_handler + 1);
                    }
                    v47 = -1;
                  }

                  else
                  {
                    v47 = 0;
                  }

                  *(void *)buf = a3;
                  buf[8] = v47;
                  v85 = v45(a3);
                  v86 = v85;
                  if (v46 == &nw_protocol_ref_counted_handle)
                  {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    if (v86) {
                      goto LABEL_122;
                    }
                  }

                  else if (v85)
                  {
LABEL_122:
                    v87 = v9[403] | 2;
LABEL_125:
                    v9[403] = v87;
LABEL_126:
                    v75 = 1LL;
LABEL_158:

                    return v75;
                  }
                }
              }

              v87 = v9[403] & 0xFD;
              goto LABEL_125;
            }

            __nwlog_obj();
            v111 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_protocol_implementation_replace_input_handler";
            v53 = (const char *)_os_log_send_and_compose_impl();

            LOBYTE(v154) = 16;
            type = OS_LOG_TYPE_DEFAULT;
            if (v154 == 17)
            {
              __nwlog_obj();
              v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v112 = v154;
              if (os_log_type_enabled(v103, (os_log_type_t)v154))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = "nw_protocol_implementation_replace_input_handler";
                _os_log_impl(&dword_181A5C000, v103, v112, "%{public}s called with null new_input_handler", buf, 0xCu);
              }

    if (v41) {
      free(v41);
    }
LABEL_46:
    flow_registration = (char *)v4->flow_registration;
    if (flow_registration)
    {
      v83[0] = MEMORY[0x1895F87A8];
      v83[1] = 3221225472LL;
      v83[2] = ___ZL31nw_protocol_implementation_readP31NWConcrete_nw_protocol_instanceP11nw_protocol_block_invoke;
      v83[3] = &unk_189BC86F0;
      v84 = v8;
      nw_hash_table_apply(flow_registration, (uint64_t)v83);
    }

    v5 = BYTE4(v4->flow_in_connected);
    if ((v5 & 0x40) != 0 || v15 && (v4->flow_in_connected & 0x2000000000LL) == 0) {
      break;
    }
    if (!v15) {
      goto LABEL_152;
    }
  }

  BYTE4(v4->flow_in_connected) = v5 | 0x40;
LABEL_152:
  nw_protocol_implementation_deliver_output_available(v8);
LABEL_157:
}

      v74 = v77[0];
      ((void (**)(void, id))v9)[2](v9, v74);

      goto LABEL_150;
    }

    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "__nw_protocol_get_output_frames";
    v60 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v81) = 0;
    if (__nwlog_fault(v60, type, &v81))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v62 = type[0];
        if (os_log_type_enabled(v61, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_get_output_frames";
          _os_log_impl(&dword_181A5C000, v61, v62, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if ((_BYTE)v81)
      {
        v68 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v69 = type[0];
        v70 = os_log_type_enabled(v61, type[0]);
        if (v68)
        {
          if (v70)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = "__nw_protocol_get_output_frames";
            v86 = 2082;
            v87 = v68;
            _os_log_impl( &dword_181A5C000,  v61,  v69,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v68);
          goto LABEL_157;
        }

        if (v70)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_get_output_frames";
          _os_log_impl(&dword_181A5C000, v61, v69, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v75 = type[0];
        if (os_log_type_enabled(v61, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_get_output_frames";
          _os_log_impl( &dword_181A5C000,  v61,  v75,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    (*(void (**)(void, BOOL))(*(void *)(*(void *)(a1 + 32) + 8LL) + 16LL))( *(void *)(*(void *)(a1 + 32) + 8LL),  v79);
    v67 = *(void *)(a1 + 32);
    v68 = *(void **)(v67 + 8);
    *(void *)(v67 + 8) = 0LL;

    v69 = *(id *)(a1 + 32);
    v70 = (const void *)v69[3];
    if (v70)
    {
      CFRelease(v70);
      v69[3] = 0LL;
    }

    v71 = (const void *)v69[4];
    if (v71)
    {
      CFRelease(v71);
      v69[4] = 0LL;
    }

    v72 = (const void *)v69[5];
    if (v72)
    {
      CFRelease(v72);
      v69[5] = 0LL;
    }
  }

    nw_http2_transport_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
    return 0LL;
  }

  if (gLogDatapath)
  {
    v101 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s detected new stream initiated from this side of the connection, allocating new stream",  buf,  0x16u);
    }
  }

  v59 = calloc(1uLL, 0x28uLL);
  v60 = (uint64_t)v59;
  if (v59)
  {
    *v59 = 0LL;
    v59[1] = v59;
    v59[2] = 0LL;
    v59[3] = v59 + 2;
    *((_BYTE *)v59 + 36) &= 0xF0u;
  }

  else
  {
    v102 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v114 = "strict_calloc";
    v115 = 2048;
    v116 = 1LL;
    v117 = 2048;
    *(void *)v118 = 40LL;
    v103 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v103);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v103);
    nw_http2_transport_stream_init(0LL);
  }

  *(_DWORD *)(v60 + 32) = -1;
  v61 = v11;
  v62 = v61[12];

  *(_BYTE *)(v60 + 36) = *(_BYTE *)(v60 + 36) & 0xF7 | (v62 >> 12) & 8;
  v29[4] = v60;
  if ((*(_BYTE *)(v60 + 36) & 8) == 0) {
    goto LABEL_118;
  }
  if (a1->default_input_handler)
  {
    v63 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
LABEL_79:
      nw_http2_transport_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      free((void *)v60);
      return 0LL;
    }

    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)(handle + 205);
    v64 = "%{public}s %{public}s http2_transport has default_input_handler on the first stream in a listening connection."
          " Is a connection trying to join while having server set on the parameters?";
LABEL_78:
    _os_log_impl(&dword_181A5C000, v63, OS_LOG_TYPE_ERROR, v64, buf, 0x16u);
    goto LABEL_79;
  }

  if (gLogDatapath)
  {
    v107 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s responder's first stream detected, overriding stream id to 1",  buf,  0x16u);
    }
  }

  *(_DWORD *)(v60 + 32) = 1;
  if (!nw_http2_transport_add_to_id_table((uint64_t)handle, v60, (uint64_t)a2))
  {
    v63 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
      goto LABEL_79;
    }
    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)(handle + 205);
    v64 = "%{public}s %{public}s Failed to add new stream to the id based hash table";
    goto LABEL_78;
  }

  if (gLogDatapath)
  {
    v108 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
    {
      v109 = v29[4];
      *(_DWORD *)buf = 136446978;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 2048;
      *(void *)v118 = v60;
      *(_WORD *)&v118[8] = 2048;
      *(void *)&v118[10] = v109;
      v75 = "%{public}s %{public}s new stream is %p, stream pointer is %p";
      v76 = v108;
      v77 = 42;
      goto LABEL_212;
    }
  }

    goto LABEL_150;
  }

          if (v47) {
            free(v47);
          }
          v28 = 0LL;
          goto LABEL_46;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v82 = "nw_protocol_http1_finalize_output_frames";
        v12 = (char *)_os_log_send_and_compose_impl();
        v80 = OS_LOG_TYPE_ERROR;
        v79 = 0;
        if (__nwlog_fault(v12, &v80, &v79))
        {
          if (v80 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v13 = (os_log_s *)gLogObj;
            v14 = v80;
            if (!os_log_type_enabled((os_log_t)gLogObj, v80)) {
              goto LABEL_39;
            }
            *(_DWORD *)buf = 136446210;
            v82 = "nw_protocol_http1_finalize_output_frames";
            v15 = "%{public}s haven't sent headers, but we have someone else's frames to finalize";
            goto LABEL_38;
          }

          if (!v79)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v13 = (os_log_s *)gLogObj;
            v14 = v80;
            if (!os_log_type_enabled((os_log_t)gLogObj, v80)) {
              goto LABEL_39;
            }
            *(_DWORD *)buf = 136446210;
            v82 = "nw_protocol_http1_finalize_output_frames";
            v15 = "%{public}s haven't sent headers, but we have someone else's frames to finalize, backtrace limit exceeded";
            goto LABEL_38;
          }

          v22 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = (os_log_s *)gLogObj;
          v14 = v80;
          v23 = os_log_type_enabled((os_log_t)gLogObj, v80);
          if (v22)
          {
            if (v23)
            {
              *(_DWORD *)buf = 136446466;
              v82 = "nw_protocol_http1_finalize_output_frames";
              v83 = 2082;
              v84 = v22;
              _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s haven't sent headers, but we have someone else's frames to finalize, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v22);
            goto LABEL_39;
          }

          if (v23)
          {
            *(_DWORD *)buf = 136446210;
            v82 = "nw_protocol_http1_finalize_output_frames";
            v15 = "%{public}s haven't sent headers, but we have someone else's frames to finalize, no backtrace";
LABEL_38:
            _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
          }
        }

        v58 = (char *)v271;
        goto LABEL_150;
      }

      v33 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v34 = (id)gLogObj;
      *(_DWORD *)address = 136446466;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      address[6] = 1024;
      *(_DWORD *)&address[7] = v33;
      v35 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v282) = 0;
      if (__nwlog_fault(v35, type, &v282))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v36 = (os_log_s *)(id)gLogObj;
          v37 = type[0];
          if (os_log_type_enabled(v36, type[0]))
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v33;
            _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s socket failed %{darwin.errno}d",  (uint8_t *)address,  0x12u);
          }
        }

        else if ((_BYTE)v282)
        {
          v46 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v47 = type[0];
          v48 = os_log_type_enabled(v36, type[0]);
          if (v46)
          {
            if (v48)
            {
              *(_DWORD *)address = 136446722;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v33;
              address[9] = 2082;
              *(void *)&address[10] = v46;
              _os_log_impl( &dword_181A5C000,  v36,  v47,  "%{public}s socket failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)address,  0x1Cu);
            }

            free(v46);
            if (!v35) {
              goto LABEL_108;
            }
            goto LABEL_107;
          }

          if (v48)
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v33;
            _os_log_impl( &dword_181A5C000,  v36,  v47,  "%{public}s socket failed %{darwin.errno}d, no backtrace",  (uint8_t *)address,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v62 = type[0];
          if (os_log_type_enabled(v36, type[0]))
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v33;
            _os_log_impl( &dword_181A5C000,  v36,  v62,  "%{public}s socket failed %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)address,  0x12u);
          }
        }
      }

      if (!v35)
      {
LABEL_108:
        v38 = (nw_error *)nw_error_create_posix_error(v33);
        goto LABEL_109;
      }

        goto LABEL_219;
      }

      if (v163 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v149 = type[0];
        if (os_log_type_enabled(v116, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_http_connection_metadata_set_multipath";
          _os_log_impl( &dword_181A5C000,  v116,  v149,  "%{public}s metadata must be http_connection, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_149;
      }

      v134 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      HIDWORD(v159) = type[0];
      v136 = os_log_type_enabled(v135, type[0]);
      if (v134)
      {
        if (v136)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_http_connection_metadata_set_multipath";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v134;
          _os_log_impl( &dword_181A5C000,  v135,  BYTE4(v159),  "%{public}s metadata must be http_connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v134);
      }

      else
      {
        if (v136)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_http_connection_metadata_set_multipath";
          _os_log_impl( &dword_181A5C000,  v135,  BYTE4(v159),  "%{public}s metadata must be http_connection, no backtrace",  buf,  0xCu);
        }
      }

LABEL_150:
          *((_BYTE *)v160 + 474) |= 4u;
          if ((v53 & 0x100) == 0)
          {
LABEL_106:
            if ((v53 & 0x800) == 0) {
              goto LABEL_107;
            }
            goto LABEL_152;
          }

    if (v69) {
      free(v69);
    }
    v79 = *(void **)(v113 + 24);
    if (v79)
    {
      free(v79);
      *(void *)(v113 + 24) = 0LL;
    }

    v59 = &v112;
LABEL_155:
    _Block_object_dispose(v59, 8);
    goto LABEL_156;
  }

  fd = os_channel_get_fd();
  *((_DWORD *)v10 + 108) = fd;
  if (fd < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_channel_create";
    v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v122) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v37 = (os_log_s *)__nwlog_obj();
      v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_123;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s failed to get fd for channel";
    }

    else if ((_BYTE)v122)
    {
      v60 = (char *)__nw_create_backtrace_string();
      v37 = (os_log_s *)__nwlog_obj();
      v38 = type[0];
      v61 = os_log_type_enabled(v37, type[0]);
      if (v60)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v60;
          _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s failed to get fd for channel, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v60);
        if (!v36) {
          goto LABEL_125;
        }
        goto LABEL_124;
      }

      if (!v61) {
        goto LABEL_123;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s failed to get fd for channel, no backtrace";
    }

    else
    {
      v37 = (os_log_s *)__nwlog_obj();
      v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_123;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s failed to get fd for channel, backtrace limit exceeded";
    }

    goto LABEL_121;
  }

  if ((v13 & 1) != 0) {
    *((_WORD *)v10 + 222) |= 0x1000u;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    if ((*((_WORD *)v10 + 222) & 0x1000) != 0) {
      v21 = "enabled";
    }
    else {
      v21 = "disabled";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&buf[4] = "nw_channel_create";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v21;
    _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Channel user packet pool %{public}s", buf, 0x16u);
  }

  os_channel_ring_id();
  os_channel_ring_id();
  *((void *)v10 + 27) = os_channel_tx_ring();
  *((void *)v10 + 28) = os_channel_rx_ring();
  os_channel_read_attr();
  *(void *)type = 0LL;
  os_channel_attr_get();
  *((_DWORD *)v10 + 109) = 0;
  if ((*((_WORD *)v10 + 222) & 0x1000) != 0)
  {
    *(void *)type = 0LL;
    os_channel_attr_get();
  }

  v22 = v10 + 444;
  *((_DWORD *)v10 + 110) = 0;
  v122 = 0LL;
  os_channel_attr_get();
  v121 = 0LL;
  if (!os_channel_attr_get())
  {
    v23 = (unsigned __int16)*v22;
    v24 = v23 & 0xFFFFF7FF | (v10[446] << 16);
    *v22 = ((v121 & 1) << 11) | v23 & 0xF7FF;
    v10[446] = BYTE2(v24);
  }

  v120 = 0LL;
  os_channel_attr_get();
  if (v99)
  {
    v25 = malloc(v12);
    if (!v25)
    {
      v92 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "strict_malloc";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v12;
      v100 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort((uint64_t)v100);
      if (result) {
        goto LABEL_225;
      }
      free(v100);
    }

    *((void *)v10 + 2) = v25;
    memcpy(v25, v11, v12);
    *((_DWORD *)v10 + 106) = v12;
  }

  if (!*((_DWORD *)v10 + 109))
  {
    if ((nw_channel_check_defunct((uint64_t)v10) & 1) != 0)
    {
      v43 = 1;
      goto LABEL_67;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_channel_create";
    v93 = (char *)_os_log_send_and_compose_impl();
    v119 = OS_LOG_TYPE_ERROR;
    v118 = 0;
    if (v119 == OS_LOG_TYPE_FAULT)
    {
      v94 = (os_log_s *)__nwlog_obj();
      v95 = v119;
      if (os_log_type_enabled(v94, v119))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_channel_create";
        v96 = "%{public}s Channel slot size is 0";
LABEL_221:
        _os_log_impl(&dword_181A5C000, v94, v95, v96, buf, 0xCu);
      }
    }

    else if (v118)
    {
      v97 = (char *)__nw_create_backtrace_string();
      v94 = (os_log_s *)__nwlog_obj();
      v95 = v119;
      v98 = os_log_type_enabled(v94, v119);
      if (v97)
      {
        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v97;
          _os_log_impl( &dword_181A5C000,  v94,  v95,  "%{public}s Channel slot size is 0, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v97);
        goto LABEL_222;
      }

      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_channel_create";
        v96 = "%{public}s Channel slot size is 0, no backtrace";
        goto LABEL_221;
      }
    }

    else
    {
      v94 = (os_log_s *)__nwlog_obj();
      v95 = v119;
      if (os_log_type_enabled(v94, v119))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_channel_create";
        v96 = "%{public}s Channel slot size is 0, backtrace limit exceeded";
        goto LABEL_221;
      }
    }

      if (!v28) {
        goto LABEL_98;
      }
      goto LABEL_106;
    }

    if (gLogDatapath)
    {
      v14 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, "%{public}s resuming saved output frames", buf, 0xCu);
      }
    }

    v55 = -1;
    v56 = 0;
    v54 = -1;
    v5 = *(void *)(v4 + 104);
    if (v5)
    {
      *(void *)type = 0LL;
      v60 = type;
      v62 = 0;
      v61 = 0x2000000000LL;
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
      v65 = &unk_189BB63E8;
      *((void *)&v66 + 1) = &v54;
      v67 = v4;
      v76 = 0;
      v68 = &v55;
      v69 = v4 + 32;
      v70 = v57;
      v71 = &v56;
      *(void *)&v66 = type;
      v72 = &v58;
      v73 = a1;
      v74 = v5;
      v75 = 0LL;
      v6 = *(void *)(v4 + 32);
      do
      {
        if (!v6) {
          break;
        }
        v7 = *(void *)(v6 + 32);
        v8 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v6 = v7;
      }

      while ((v8 & 1) != 0);
      v9 = *((_DWORD *)v60 + 6);
      _Block_object_dispose(type, 8);
      if (!v57[0]) {
        goto LABEL_98;
      }
      goto LABEL_88;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
    v15 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (__nwlog_fault(v15, type, &v63))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v16 = (os_log_s *)__nwlog_obj();
        v17 = type[0];
        if (!os_log_type_enabled(v16, type[0])) {
          goto LABEL_85;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v18 = "%{public}s called with null processor";
        goto LABEL_84;
      }

      if (!v63)
      {
        v16 = (os_log_s *)__nwlog_obj();
        v17 = type[0];
        if (!os_log_type_enabled(v16, type[0])) {
          goto LABEL_85;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v18 = "%{public}s called with null processor, backtrace limit exceeded";
        goto LABEL_84;
      }

      v25 = (char *)__nw_create_backtrace_string();
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type[0];
      v26 = os_log_type_enabled(v16, type[0]);
      if (v25)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v25;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null processor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v25);
        goto LABEL_85;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v18 = "%{public}s called with null processor, no backtrace";
LABEL_84:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      }
    }

    free(v76);
    if (!v64) {
      goto LABEL_21;
    }
    goto LABEL_171;
  }

  if (!nw_parameters_get_logging_disabled(*((void *)v8 + 7)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    v10 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      if (a2 > 5) {
        v11 = "unknown";
      }
      else {
        v11 = off_189BB9C00[a2];
      }
      v12 = *((_DWORD *)v8 + 42);
      *(_DWORD *)buf = 136447234;
      *(void *)&buf[4] = "nw_connection_group_handle_connection_state_changed";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v9;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = v11;
      *(_WORD *)&buf[38] = 2112;
      v139 = v91;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] connection %@ entered state %s (error %@)",  buf,  0x30u);
    }
  }

  v119 = 0LL;
  v120 = &v119;
  v121 = 0x2020000000LL;
  v122 = 0;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = ___ZL51nw_connection_group_handle_connection_state_changedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection21nw_connection_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke;
  *(void *)&buf[24] = &unk_189BBEEE8;
  v13 = v8;
  *(void *)&buf[32] = v13;
  v14 = v9;
  v139 = v14;
  v140 = &v119;
  v15 = (void (**)(void))_Block_copy(buf);
  os_unfair_lock_lock((os_unfair_lock_t)v8 + 43);
  v15[2](v15);
  os_unfair_lock_unlock((os_unfair_lock_t)v8 + 43);

  if (*((_BYTE *)v120 + 24))
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v8 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      v16 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v17 = v13[42];
        *(_DWORD *)v135 = 136446722;
        *(void *)&v135[4] = "nw_connection_group_handle_connection_state_changed";
        *(_WORD *)&v135[12] = 1024;
        *(_DWORD *)&v135[14] = v17;
        *(_WORD *)&v135[18] = 2112;
        *(void *)&v135[20] = v14;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] connection %@ is no longer part of the group",  v135,  0x1Cu);
      }

        if (!a4) {
          goto LABEL_157;
        }
        goto LABEL_151;
      }

      v62 = *(void **)(a1 + 40);
      v63 = v10;
      v64 = v62;
      v65 = v64;
      if (v63)
      {
        if (v64)
        {
          if ((v59 & 1) == 0)
          {
            os_unfair_lock_lock((os_unfair_lock_t)v63 + 28);
            *((_BYTE *)v63 + 118) |= 0x10u;
            v66 = nw_array_create();
            v67 = (void *)*((void *)v63 + 13);
            *((void *)v63 + 13) = v66;

            nw_array_append(*((void *)v63 + 13), v65);
            os_unfair_lock_unlock((os_unfair_lock_t)v63 + 28);
          }

            if (v55) {
              free(v55);
            }
            goto LABEL_126;
          }

      if (v37) {
        free(v37);
      }
      goto LABEL_45;
    }

    __nwlog_obj();
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v94 = "__nw_protocol_input_finished";
    v58 = (char *)_os_log_send_and_compose_impl();

    v88[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v58, v88, &type))
    {
      if (v88[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v60 = v88[0];
        if (os_log_type_enabled(v59, v88[0]))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "__nw_protocol_input_finished";
          _os_log_impl(&dword_181A5C000, v59, v60, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        v74 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v75 = v88[0];
        v76 = os_log_type_enabled(v59, v88[0]);
        if (v74)
        {
          if (v76)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "__nw_protocol_input_finished";
            v95 = 2082;
            v96 = v74;
            _os_log_impl( &dword_181A5C000,  v59,  v75,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v74);
          goto LABEL_176;
        }

        if (v76)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "__nw_protocol_input_finished";
          _os_log_impl( &dword_181A5C000,  v59,  v75,  "%{public}s called with null other_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v86 = v88[0];
        if (os_log_type_enabled(v59, v88[0]))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "__nw_protocol_input_finished";
          _os_log_impl( &dword_181A5C000,  v59,  v86,  "%{public}s called with null other_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

          goto LABEL_151;
        }

        if (v72 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v67 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_local_endpoint";
            _os_log_impl( &dword_181A5C000,  v29,  v67,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v62 = type[0];
        v63 = os_log_type_enabled(v29, type[0]);
        if (!backtrace_string)
        {
          if (v63)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_local_endpoint";
            _os_log_impl(&dword_181A5C000, v29, v62, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }

          goto LABEL_150;
        }

        if (v63)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "__nw_protocol_get_local_endpoint";
          v74 = 2082;
          v75 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v62,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

          goto LABEL_151;
        }

        if (v72 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v67 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_remote_endpoint";
            _os_log_impl( &dword_181A5C000,  v29,  v67,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v62 = type[0];
        v63 = os_log_type_enabled(v29, type[0]);
        if (!backtrace_string)
        {
          if (v63)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_remote_endpoint";
            _os_log_impl(&dword_181A5C000, v29, v62, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }

          goto LABEL_150;
        }

        if (v63)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "__nw_protocol_get_remote_endpoint";
          v74 = 2082;
          v75 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v29,  v62,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

          goto LABEL_151;
        }

        if (v73 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v68 = type[0];
          if (os_log_type_enabled(v30, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_path";
            _os_log_impl( &dword_181A5C000,  v30,  v68,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_150;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v63 = type[0];
        v64 = os_log_type_enabled(v30, type[0]);
        if (!backtrace_string)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "__nw_protocol_get_path";
            _os_log_impl(&dword_181A5C000, v30, v63, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }

          goto LABEL_150;
        }

        if (v64)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "__nw_protocol_get_path";
          v75 = 2082;
          v76 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v30,  v63,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

      if (v40 == 3) {
        v79 = size + 1;
      }
      else {
        v79 = size;
      }
      if (!v79)
      {
        __nwlog_obj();
        v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v137, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "strict_malloc";
        v138 = (void *)_os_log_send_and_compose_impl();

        free(v138);
      }

      v80 = malloc(v79);
      if (v80) {
        goto LABEL_155;
      }
      __nwlog_obj();
      v139 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v139, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "strict_malloc";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v79;
      v140 = (void *)_os_log_send_and_compose_impl();

      if (!__nwlog_abort((uint64_t)v140))
      {
        free(v140);
LABEL_155:
        *((void *)v9 + 12) = v80;
        nw_dispatch_data_copyout(v11, (uint64_t)v80, size);
        v81 = v9[57];
        if (v81 == 3)
        {
          *(_BYTE *)(*((void *)v9 + 12) + size) = 0;
          v81 = v9[57];
        }

        switch(v81)
        {
          case 4:
            __nwlog_obj();
            v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
            {
              v97 = inet_ntop(2, *((const void **)v9 + 12), buf, 0x2Eu);
              *(_DWORD *)&type[0].sa_len = 136446722;
              *(void *)&type[0].sa_data[2] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&type[0].sa_data[10] = 2114;
              *(void *)&type[0].sa_data[12] = v9;
              *(_WORD *)&type[1].sa_data[4] = 2082;
              *(void *)&type[1].sa_data[6] = v97;
              _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ client request for ipv6 %{public}s",  &type[0].sa_len,  0x20u);
            }

            break;
          case 3:
            __nwlog_obj();
            v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
            {
              v96 = *((void *)v9 + 12);
              *(_DWORD *)buf = 136446722;
              *(void *)&buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&buf[12] = 2114;
              *(void *)&buf[14] = v9;
              *(_WORD *)&buf[22] = 2082;
              *(void *)&buf[24] = v96;
              _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ client request for domain %{public}s",  buf,  0x20u);
            }

            goto LABEL_224;
          case 1:
            __nwlog_obj();
            v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
            {
              v83 = inet_ntop(2, *((const void **)v9 + 12), (char *)type, 0x10u);
              *(_DWORD *)buf = 136446722;
              *(void *)&buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&buf[12] = 2114;
              *(void *)&buf[14] = v9;
              *(_WORD *)&buf[22] = 2082;
              *(void *)&buf[24] = v83;
              _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ client request for ipv4 %{public}s",  buf,  0x20u);
            }

            break;
          default:
LABEL_224:
            v9[56] = 6;
            nw_socks5_connection_inner_connection_read_range_on_queue((NWConcrete_nw_socks5_connection *)v9, 2u, 2u);
            goto LABEL_102;
        }

        goto LABEL_224;
      }

    if (v71) {
      free(v71);
    }
    v49 = -1LL;
LABEL_74:
    v220[3] = v49;
    v50 = v223;
    *(_WORD *)(*v29 + 648) = *(_WORD *)(*v29 + 648) & 0xFFDF | (32 * v223);
    if ((*(_BYTE *)(*v29 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v79 = (os_log_s *)__nwlog_obj();
        v80 = os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG);
        v50 = v223;
        if (v80)
        {
          v81 = *v29 + 114;
          v82 = v220[3];
          *(_DWORD *)v227 = 136447234;
          *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&v227[12] = 2082;
          *(void *)&v227[14] = v81;
          *(_WORD *)&v227[22] = 2080;
          v228 = " ";
          *(_WORD *)v229 = 2048;
          *(void *)&v229[2] = v82;
          *(_WORD *)&v229[10] = 1024;
          LODWORD(v230) = v223;
          _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sdecoder decoded %zd bytes, complete %{BOOL}d",  v227,  0x30u);
          v50 = v223;
        }
      }
    }

    if (v50 && !*(void *)(*(void *)&buf[8] + 40LL))
    {
      v51 = *v29;
      if (*v29)
      {
        if ((*(_BYTE *)(v51 + 198) & 1) == 0)
        {
          if (gLogDatapath)
          {
            v102 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v227 = 136446978;
              *(void *)&v227[4] = "nw_http_encoding_create_inbound_frame";
              *(_WORD *)&v227[12] = 2082;
              *(void *)&v227[14] = v51 + 114;
              *(_WORD *)&v227[22] = 2080;
              v228 = " ";
              *(_WORD *)v229 = 1024;
              *(_DWORD *)&v229[2] = 0;
              _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalled for size %u",  v227,  0x26u);
            }
          }
        }

        frame = nw_frame_cache_create_frame((uint64_t *)(v51 + 432), 0LL);
        if (frame)
        {
          v53 = frame;
          *(void *)(frame + 16) = 0LL;
          v54 = *(BOOL **)(v51 + 568);
          *(void *)(frame + 24) = v54;
          *v54 = frame;
          *(void *)(v51 + 568) = frame + 16;
          *(void *)(frame + 80) = nw_http_encoding_inbound_frame_finalizer;
          *(void *)(frame + 88) = v51;
LABEL_83:
          nw_frame_inherit_metadata(a2, v53, 1);
          *(_BYTE *)(v53 + 186) |= 0x80u;
          v55 = *(void *)&buf[8];
          *(void *)(v53 + 32) = 0LL;
          v56 = *(uint64_t **)(v55 + 48);
          *(void *)(v53 + 40) = v56;
          *v56 = v53;
          *(void *)(v55 + 48) = v53 + 32;
          goto LABEL_84;
        }

        __nwlog_obj();
        *(_DWORD *)v227 = 136446210;
        *(void *)&v227[4] = "nw_http_encoding_create_inbound_frame";
        v94 = (char *)_os_log_send_and_compose_impl();
        v226 = OS_LOG_TYPE_ERROR;
        v225 = 0;
        if (v226 == OS_LOG_TYPE_FAULT)
        {
          v100 = (os_log_s *)__nwlog_obj();
          v101 = v226;
          if (os_log_type_enabled(v100, v226))
          {
            *(_DWORD *)v227 = 136446210;
            *(void *)&v227[4] = "nw_http_encoding_create_inbound_frame";
            v97 = v100;
            v98 = v101;
            v99 = "%{public}s called with null frame";
            goto LABEL_167;
          }

      if (!v101)
      {
LABEL_152:
        v29 = 0LL;
LABEL_153:
        free(v90);
        _Block_object_dispose(&v257, 8);
LABEL_154:

        v237[3] = v29;
        v28 = (unint64_t)v222;
        goto LABEL_155;
      }

              if (v53) {
                free(v53);
              }
LABEL_61:
              _Block_object_dispose(type, 8);
              if ((v76 & 1) != 0 && object) {
                os_release(object);
              }
              if (!v34) {
                goto LABEL_66;
              }
              goto LABEL_65;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = *(unsigned int *)(v3 + 672);
            *(_DWORD *)buf = 136446978;
            *(void *)&buf[4] = "nw_http_retry_reissue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http_retry->limit";
            *(_WORD *)&buf[22] = 2048;
            v83 = 1LL;
            *(_WORD *)v84 = 2048;
            *(void *)&v84[2] = v14;
            v15 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            v77[0] = 0;
            if (__nwlog_fault(v15, type, v77))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v16 = (os_log_s *)gLogObj;
                v17 = type[0];
                if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
                {
                  v18 = *(unsigned int *)(v3 + 672);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&buf[4] = "nw_http_retry_reissue";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http_retry->limit";
                  *(_WORD *)&buf[22] = 2048;
                  v83 = 1LL;
                  *(_WORD *)v84 = 2048;
                  *(void *)&v84[2] = v18;
                  v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_45:
                  _os_log_impl(&dword_181A5C000, v16, v17, v19, buf, 0x2Au);
                }
              }

              else if (v77[0])
              {
                v23 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v16 = (os_log_s *)gLogObj;
                v17 = type[0];
                v24 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
                if (v23)
                {
                  if (v24)
                  {
                    v25 = *(unsigned int *)(v3 + 672);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&buf[4] = "nw_http_retry_reissue";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = "http_retry->limit";
                    *(_WORD *)&buf[22] = 2048;
                    v83 = 1LL;
                    *(_WORD *)v84 = 2048;
                    *(void *)&v84[2] = v25;
                    *(_WORD *)&v84[10] = 2082;
                    *(void *)&v84[12] = v23;
                    _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(v23);
                  goto LABEL_46;
                }

                if (v24)
                {
                  v27 = *(unsigned int *)(v3 + 672);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&buf[4] = "nw_http_retry_reissue";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http_retry->limit";
                  *(_WORD *)&buf[22] = 2048;
                  v83 = 1LL;
                  *(_WORD *)v84 = 2048;
                  *(void *)&v84[2] = v27;
                  v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                  goto LABEL_45;
                }
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v16 = (os_log_s *)gLogObj;
                v17 = type[0];
                if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
                {
                  v26 = *(unsigned int *)(v3 + 672);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&buf[4] = "nw_http_retry_reissue";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http_retry->limit";
                  *(_WORD *)&buf[22] = 2048;
                  v83 = 1LL;
                  *(_WORD *)v84 = 2048;
                  *(void *)&v84[2] = v26;
                  v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_45;
                }
              }
            }

      goto LABEL_151;
    }

    if (!v59)
    {
      __nwlog_obj();
      v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        __dst = 136446210;
        v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        v47 = "%{public}s called with null prefix, backtrace limit exceeded";
        goto LABEL_149;
      }

      goto LABEL_150;
    }

    v53 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v46 = type;
    v57 = os_log_type_enabled(v45, type);
    if (!v53)
    {
      if (v57)
      {
        __dst = 136446210;
        v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        v47 = "%{public}s called with null prefix, no backtrace";
        goto LABEL_149;
      }

      goto LABEL_150;
    }

    if (v57)
    {
      __dst = 136446466;
      v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
      v63 = 2082;
      v64 = v53;
      v55 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

              v100 = *v7++;
              v99 = v100;
              v16 += (unint64_t)(v100 & 0x7F) << v17;
              v17 += 7;
            }

            while ((v100 & 0x80) != 0);
            if (v17 >= 0x40)
            {
              v155 = 3821;
              if (v16 > -1 || v99 > 1) {
                v157 = v10;
              }
              else {
                v157 = v7;
              }
              v161 = 3821;
              goto LABEL_314;
            }

            v161 = 3821;
            goto LABEL_348;
          }

        if (*(_BYTE *)(a2 + *v8)) {
          v58 = 0LL;
        }
LABEL_152:
        *(_BYTE *)(a1 + 63) = v58 != 0;
        goto LABEL_4;
      case 0xBu:
        *(_BYTE *)(a1 + 64) |= 2u;
        v140 = *v3;
        v141 = *(void *)(a2 + v140);
        if (v141 == -1LL || v141 >= *(void *)(a2 + *v6))
        {
          v144 = 0LL;
LABEL_169:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_170;
        }

        v142 = v141 + 1;
        v143 = *(_BYTE *)(*(void *)(a2 + *v10) + v141);
        *(void *)(a2 + v140) = v142;
        v144 = v143 & 0x7F;
        if ((v143 & 0x80) == 0) {
          goto LABEL_170;
        }
        v145 = *v3;
        v146 = *(void *)(a2 + v145);
        if (v146 == -1LL || v146 >= *(void *)(a2 + *v6)) {
          goto LABEL_169;
        }
        v147 = v146 + 1;
        v148 = *(char *)(*(void *)(a2 + *v10) + v146);
        *(void *)(a2 + v145) = v147;
        v144 |= (unint64_t)(v148 & 0x7F) << 7;
        if ((v148 & 0x80000000) == 0) {
          goto LABEL_170;
        }
        v149 = *v3;
        v150 = *(void *)(a2 + v149);
        if (v150 == -1LL || v150 >= *(void *)(a2 + *v6)) {
          goto LABEL_169;
        }
        v151 = v150 + 1;
        v152 = *(char *)(*(void *)(a2 + *v10) + v150);
        *(void *)(a2 + v149) = v151;
        v144 |= (unint64_t)(v152 & 0x7F) << 14;
        if ((v152 & 0x80000000) == 0) {
          goto LABEL_170;
        }
        v153 = *v3;
        v154 = *(void *)(a2 + v153);
        if (v154 == -1LL || v154 >= *(void *)(a2 + *v6)) {
          goto LABEL_169;
        }
        v155 = v154 + 1;
        v156 = *(char *)(*(void *)(a2 + *v10) + v154);
        *(void *)(a2 + v153) = v155;
        v144 |= (unint64_t)(v156 & 0x7F) << 21;
        if ((v156 & 0x80000000) == 0) {
          goto LABEL_170;
        }
        v157 = *v3;
        v158 = *(void *)(a2 + v157);
        if (v158 == -1LL || v158 >= *(void *)(a2 + *v6)) {
          goto LABEL_169;
        }
        v159 = v158 + 1;
        v160 = *(char *)(*(void *)(a2 + *v10) + v158);
        *(void *)(a2 + v157) = v159;
        v144 |= (unint64_t)(v160 & 0x7F) << 28;
        if ((v160 & 0x80000000) == 0) {
          goto LABEL_170;
        }
        v194 = *v3;
        v195 = *(void *)(a2 + v194);
        if (v195 == -1LL || v195 >= *(void *)(a2 + *v6)) {
          goto LABEL_169;
        }
        v196 = v195 + 1;
        v197 = *(char *)(*(void *)(a2 + *v10) + v195);
        *(void *)(a2 + v194) = v196;
        v144 |= (unint64_t)(v197 & 0x7F) << 35;
        if (v197 < 0)
        {
          v246 = *v3;
          v247 = *(void *)(a2 + v246);
          if (v247 == -1LL || v247 >= *(void *)(a2 + *v6)) {
            goto LABEL_169;
          }
          v248 = v247 + 1;
          v249 = *(char *)(*(void *)(a2 + *v10) + v247);
          *(void *)(a2 + v246) = v248;
          v144 |= (unint64_t)(v249 & 0x7F) << 42;
          if (v249 < 0)
          {
            v250 = *v3;
            v251 = *(void *)(a2 + v250);
            if (v251 == -1LL || v251 >= *(void *)(a2 + *v6)) {
              goto LABEL_169;
            }
            v252 = v251 + 1;
            v253 = *(char *)(*(void *)(a2 + *v10) + v251);
            *(void *)(a2 + v250) = v252;
            v144 |= (unint64_t)(v253 & 0x7F) << 49;
            if (v253 < 0)
            {
              v254 = *v3;
              v255 = *(void *)(a2 + v254);
              if (v255 == -1LL || v255 >= *(void *)(a2 + *v6)) {
                goto LABEL_169;
              }
              v256 = v255 + 1;
              v257 = *(char *)(*(void *)(a2 + *v10) + v255);
              *(void *)(a2 + v254) = v256;
              v144 |= (unint64_t)(v257 & 0x7F) << 56;
              if (v257 < 0)
              {
                v258 = *v3;
                v259 = *(void *)(a2 + v258);
                if (v259 == -1LL || v259 >= *(void *)(a2 + *v6)) {
                  goto LABEL_169;
                }
                v260 = v259 + 1;
                v261 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v259);
                *(void *)(a2 + v258) = v260;
                if ((v261 & 0x80) != 0)
                {
                  v144 = 0LL;
                  goto LABEL_172;
                }

                v144 |= v261 << 63;
              }
            }
          }
        }

    goto LABEL_109;
  }

  if (type[0] == OS_LOG_TYPE_DEFAULT)
  {
    __nwlog_obj();
    v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v83 = v93;
    if (os_log_type_enabled(v74, (os_log_type_t)v93))
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      _os_log_impl( &dword_181A5C000,  v74,  v83,  "%{public}s called with null client->channel, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
    }

    goto LABEL_150;
  }

  v76 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v77 = v93;
  v78 = os_log_type_enabled(v74, (os_log_type_t)v93);
  if (!v76)
  {
    if (v78)
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      _os_log_impl( &dword_181A5C000,  v74,  v77,  "%{public}s called with null client->channel, no backtrace",  (uint8_t *)buf,  0xCu);
    }

    goto LABEL_150;
  }

  if (v78)
  {
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v76;
    _os_log_impl( &dword_181A5C000,  v74,  v77,  "%{public}s called with null client->channel, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
  }

  free(v76);
  if (v43)
  {
LABEL_110:
    v7 = (char *)v43;
    goto LABEL_13;
  }

      if (*((_DWORD *)v225 + 6) == v171)
      {
        v41 = 0LL;
LABEL_178:
        _Block_object_dispose(v204, 8);
        _Block_object_dispose(v206, 8);
        _Block_object_dispose(v208, 8);
        _Block_object_dispose(&v210, 8);
        _Block_object_dispose(&v214, 8);
        _Block_object_dispose(v218, 8);
        _Block_object_dispose(&v220, 8);
        _Block_object_dispose(&v224, 8);
        return v41;
      }

      if (*(__int16 *)(a6 + 388) < 0)
      {
LABEL_177:
        v41 = 4294966394LL;
        goto LABEL_178;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v82 = *(_DWORD *)(a6 + 368);
      buf = 136446978;
      v231 = "send_data_callback";
      v232 = 2082;
      v233 = a6 + 390;
      v234 = 2080;
      v235 = " ";
      v236 = 1024;
      v237 = v82;
      v83 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v172 = 0;
      if (__nwlog_fault(v83, &type, &v172))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v84 = (os_log_s *)gconnectionLogObj;
          v85 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_175;
          }
          v86 = *(_DWORD *)(a6 + 368);
          buf = 136446978;
          v231 = "send_data_callback";
          v232 = 2082;
          v233 = a6 + 390;
          v234 = 2080;
          v235 = " ";
          v236 = 1024;
          v237 = v86;
          v87 = "%{public}s %{public}s%s<i%u> did not write complete frame";
          goto LABEL_174;
        }

        if (!v172)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v84 = (os_log_s *)gconnectionLogObj;
          v85 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_175;
          }
          v91 = *(_DWORD *)(a6 + 368);
          buf = 136446978;
          v231 = "send_data_callback";
          v232 = 2082;
          v233 = a6 + 390;
          v234 = 2080;
          v235 = " ";
          v236 = 1024;
          v237 = v91;
          v87 = "%{public}s %{public}s%s<i%u> did not write complete frame, backtrace limit exceeded";
          goto LABEL_174;
        }

        v88 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v84 = (os_log_s *)gconnectionLogObj;
        v85 = type;
        v89 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v88)
        {
          if (v89)
          {
            v90 = *(_DWORD *)(a6 + 368);
            buf = 136447234;
            v231 = "send_data_callback";
            v232 = 2082;
            v233 = a6 + 390;
            v234 = 2080;
            v235 = " ";
            v236 = 1024;
            v237 = v90;
            v238 = 2082;
            *(void *)v239 = v88;
            _os_log_impl( &dword_181A5C000,  v84,  v85,  "%{public}s %{public}s%s<i%u> did not write complete frame, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x30u);
          }

          free(v88);
          goto LABEL_175;
        }

        if (v89)
        {
          v92 = *(_DWORD *)(a6 + 368);
          buf = 136446978;
          v231 = "send_data_callback";
          v232 = 2082;
          v233 = a6 + 390;
          v234 = 2080;
          v235 = " ";
          v236 = 1024;
          v237 = v92;
          v87 = "%{public}s %{public}s%s<i%u> did not write complete frame, no backtrace";
LABEL_174:
          _os_log_impl(&dword_181A5C000, v84, v85, v87, (uint8_t *)&buf, 0x26u);
        }
      }

        if (!*(_BYTE *)(a1 + 206)) {
          goto LABEL_267;
        }
        v67 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL);
        v68 = *(unsigned __int8 *)(a1 + 207) - (_DWORD)v67;
        v69 = v68 >= v21 ? v21 : v68;
        if (!(_DWORD)v69) {
          goto LABEL_267;
        }
        memcpy(&v6[v8], (const void *)(a1 + v67 + 152), v69);
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v69;
        *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v69;
        *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) += v69;
        v16 = v21 >= v69;
        v70 = (v21 - v69);
        LODWORD(v21) = v21 - v69;
        if (v16)
        {
LABEL_263:
          LODWORD(v8) = v69 + v8;
          v128 = *(void *)(a1 + 104);
          if ((!v128 || (*(__int16 *)(v128 + 388) & 0x80000000) == 0) && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v233 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v234 = *(void *)(a1 + 104);
              v235 = "";
              v236 = v234 == 0;
              v237 = *(_DWORD *)(v234 + 368);
              v238 = (const char *)(v234 + 390);
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              if (v236) {
                v238 = "";
              }
              *(_DWORD *)buf = 136447234;
              if (!v236) {
                v235 = " ";
              }
              v258 = v238;
              v259 = 2080;
              v260 = (size_t)v235;
              v261 = 1024;
              *(_DWORD *)v262 = v237;
              *(_WORD *)&v262[4] = 1024;
              *(_DWORD *)&v262[6] = v69;
              _os_log_impl( &dword_181A5C000,  v233,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> wrote %u bytes of datagram context",  buf,  0x2Cu);
            }
          }

                _os_log_impl(&dword_181A5C000, v94, v95, v96, buf, 0x2Au);
                goto LABEL_151;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v91 = gLogObj;
              v92 = v265[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v265[0]))
              {
                v93 = *((unsigned int *)v313 + 6);
                *(_DWORD *)buf = 136446978;
                v317 = "nw_protocol_http2_get_input_frames";
                v318 = 2082;
                v319 = "return_frame_count";
                v320 = 2048;
                v321 = 1LL;
                v322 = 2048;
                *(void *)v323 = v93;
                v94 = (os_log_s *)v91;
                v95 = v92;
                v96 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_150;
              }

        if (v54) {
          free(v54);
        }
        goto LABEL_152;
      }

      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v40 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v41 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v76 = "nw_protocol_http2_process_connected";
          v77 = 2082;
          v78 = handle + 390;
          v79 = 2080;
          v80 = " ";
          v81 = 1024;
          v82 = v41;
          _os_log_impl(&dword_181A5C000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }

    LOWORD(v28) = *((_WORD *)handle + 194);
    if ((v28 & 0x80) == 0) {
      goto LABEL_60;
    }
    goto LABEL_101;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v26 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
  {
    v27 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447234;
    v76 = "nw_protocol_http2_add_listen_handler";
    v77 = 2082;
    v78 = handle + 390;
    v79 = 2080;
    v80 = " ";
    v81 = 1024;
    v82 = v27;
    v83 = 2048;
    v84 = a2;
    _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called with listen_protocol %p",  buf,  0x30u);
  }

  v7 = *((_WORD *)handle + 194);
  if (!*((void *)handle + 18)) {
    goto LABEL_50;
  }
LABEL_6:
  if ((v7 & 0x9000) != 0x1000) {
    goto LABEL_32;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v8 = *((_DWORD *)handle + 92);
  *(_DWORD *)buf = 136446978;
  v76 = "nw_protocol_http2_add_listen_handler";
  v77 = 2082;
  v78 = handle + 390;
  v79 = 2080;
  v80 = " ";
  v81 = 1024;
  v82 = v8;
  v9 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v74 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v9, type, &v74))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v10 = (os_log_s *)gconnectionLogObj;
      v11 = type[0];
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
        goto LABEL_29;
      }
      v12 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v76 = "nw_protocol_http2_add_listen_handler";
      v77 = 2082;
      v78 = handle + 390;
      v79 = 2080;
      v80 = " ";
      v81 = 1024;
      v82 = v12;
      v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time";
      goto LABEL_28;
    }

    if (v74 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v10 = (os_log_s *)gconnectionLogObj;
      v11 = type[0];
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
        goto LABEL_29;
      }
      v17 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v76 = "nw_protocol_http2_add_listen_handler";
      v77 = 2082;
      v78 = handle + 390;
      v79 = 2080;
      v80 = " ";
      v81 = 1024;
      v82 = v17;
      v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, "
            "backtrace limit exceeded";
      goto LABEL_28;
    }

    v14 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v10 = (os_log_s *)gconnectionLogObj;
    v11 = type[0];
    v15 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
    if (v14)
    {
      if (v15)
      {
        v16 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v76 = "nw_protocol_http2_add_listen_handler";
        v77 = 2082;
        v78 = handle + 390;
        v79 = 2080;
        v80 = " ";
        v81 = 1024;
        v82 = v16;
        v83 = 2082;
        v84 = (nw_listen_protocol *)v14;
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, du mping backtrace:%{public}s",  buf,  0x30u);
      }

      free(v14);
      goto LABEL_29;
    }

    if (v15)
    {
      v18 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v76 = "nw_protocol_http2_add_listen_handler";
      v77 = 2082;
      v78 = handle + 390;
      v79 = 2080;
      v80 = " ";
      v81 = 1024;
      v82 = v18;
      v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, no backtrace";
LABEL_28:
      _os_log_impl(&dword_181A5C000, v10, v11, v13, buf, 0x26u);
    }
  }

    goto LABEL_151;
  }

  if (v12)
  {
    aBlock = v13;
    if (v13)
    {
      v14 = nw_path_parameters_copy_context(*((void **)v11 + 2));
      nw_context_assert_queue(v14);

      if (!*((void *)v11 + 5))
      {
        internal = nw_hash_table_create_internal( 7u,  16,  (const void *(*)(const void *, unsigned int *))nw_association_get_key,  (unsigned int (*)(const void *, unsigned int))nw_association_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_association_matches_key,  (void (*)(void *))nw_association_release);
        *((void *)v11 + 5) = internal;
      }

      nw_association_activate(v11, v97, a5, 0);
      node = nw_hash_table_get_node(*((void *)v11 + 5), (uint64_t)v12, 0LL);
      if (!node) {
        goto LABEL_70;
      }
      v17 = node;
      v18 = &unk_182665000;
      if (nw_path_parameters_get_logging_disabled(*((void *)v11 + 2))) {
        goto LABEL_39;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v19 = (id)gconnectionLogObj;
      logging_description = nw_endpoint_get_logging_description(*((void **)v11 + 1));
      *(_DWORD *)buf = 136446722;
      v102 = "nw_association_register_internal";
      v103 = 2082;
      v104 = (void *)logging_description;
      v105 = 2048;
      v106 = (uint64_t)v12;
      v21 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v99 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v21, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v22 = (os_log_s *)(id)gconnectionLogObj;
          v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            v24 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446722;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v24;
            v105 = 2048;
            v106 = (uint64_t)v12;
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s <nw_association %{public}s> already has handle %p registered",  buf,  0x20u);
          }
        }

        else if (v99)
        {
          v25 = __nw_create_backtrace_string();
          if (v25)
          {
            v26 = (char *)v25;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v27 = (os_log_s *)(id)gconnectionLogObj;
            v28 = type;
            if (os_log_type_enabled(v27, type))
            {
              v29 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
              *(_DWORD *)buf = 136446978;
              v102 = "nw_association_register_internal";
              v103 = 2082;
              v104 = (void *)v29;
              v105 = 2048;
              v106 = (uint64_t)v12;
              v107 = 2082;
              v108 = v26;
              _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s <nw_association %{public}s> already has handle %p registered, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v26);
            v18 = (void *)&unk_182665000;
            if (v21) {
              goto LABEL_38;
            }
            goto LABEL_39;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v22 = (os_log_s *)(id)gconnectionLogObj;
          v32 = type;
          if (os_log_type_enabled(v22, type))
          {
            v33 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446722;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v33;
            v105 = 2048;
            v106 = (uint64_t)v12;
            _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s <nw_association %{public}s> already has handle %p registered, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v22 = (os_log_s *)(id)gconnectionLogObj;
          v30 = type;
          if (os_log_type_enabled(v22, type))
          {
            v31 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446722;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v31;
            v105 = 2048;
            v106 = (uint64_t)v12;
            _os_log_impl( &dword_181A5C000,  v22,  v30,  "%{public}s <nw_association %{public}s> already has handle %p registered, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

      v18 = &unk_182665000;
      if (v21) {
LABEL_38:
      }
        free(v21);
LABEL_39:
      if (nw_hash_table_remove_node(*((void *)v11 + 5), v17)
        || nw_path_parameters_get_logging_disabled(*((void *)v11 + 2)))
      {
        goto LABEL_70;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v34 = (id)gconnectionLogObj;
      v35 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
      v95 = v18[391];
      *(_DWORD *)buf = v95;
      v102 = "nw_association_register_internal";
      v103 = 2082;
      v104 = (void *)v35;
      v105 = 2048;
      v106 = v17;
      v36 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v99 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v36, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v37 = (os_log_s *)(id)gconnectionLogObj;
          v38 = type;
          if (os_log_type_enabled(v37, type))
          {
            v39 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = v95;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v39;
            v105 = 2048;
            v106 = v17;
            _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s <nw_association %{public}s> failed to remove handle for node %p",  buf,  0x20u);
          }
        }

        else if (v99)
        {
          v40 = __nw_create_backtrace_string();
          if (v40)
          {
            v41 = (char *)v40;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v42 = (os_log_s *)(id)gconnectionLogObj;
            v43 = type;
            if (os_log_type_enabled(v42, type))
            {
              v44 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
              *(_DWORD *)buf = 136446978;
              v102 = "nw_association_register_internal";
              v103 = 2082;
              v104 = (void *)v44;
              v105 = 2048;
              v106 = v17;
              v107 = 2082;
              v108 = v41;
              _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s <nw_association %{public}s> failed to remove handle for node %p, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v41);
            if (v36) {
              goto LABEL_69;
            }
            goto LABEL_70;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v37 = (os_log_s *)(id)gconnectionLogObj;
          v47 = type;
          if (os_log_type_enabled(v37, type))
          {
            v48 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = v95;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v48;
            v105 = 2048;
            v106 = v17;
            _os_log_impl( &dword_181A5C000,  v37,  v47,  "%{public}s <nw_association %{public}s> failed to remove handle for node %p, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v37 = (os_log_s *)(id)gconnectionLogObj;
          v45 = type;
          if (os_log_type_enabled(v37, type))
          {
            v46 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = v95;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v46;
            v105 = 2048;
            v106 = v17;
            _os_log_impl( &dword_181A5C000,  v37,  v45,  "%{public}s <nw_association %{public}s> failed to remove handle for node %p, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

      if (v36) {
LABEL_69:
      }
        free(v36);
LABEL_70:
      type = OS_LOG_TYPE_DEFAULT;
      v49 = *((void *)v11 + 5);
      v50 = v12;
      v51 = nw_hash_table_add_object(v49, (uint64_t)v50, (char *)&type);
      if (type || nw_path_parameters_get_logging_disabled(*((void *)v11 + 2)))
      {
LABEL_101:
        extra = nw_hash_node_get_extra(v51);
        v68 = _Block_copy(aBlock);
        v69 = *(void **)extra;
        *(void *)extra = v68;

        *(_BYTE *)(extra + 8) = *(_BYTE *)(extra + 8) & 0xFE | a4;
        if (a4) {
          ++*((_DWORD *)v11 + 18);
        }
LABEL_103:
        v70 = (void *)aBlock;
        goto LABEL_104;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v52 = (id)gconnectionLogObj;
      v53 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
      *(_DWORD *)buf = 136446978;
      v102 = "nw_association_register_internal";
      v103 = 2082;
      v104 = (void *)v53;
      v105 = 2048;
      v106 = (uint64_t)v50;
      v107 = 2048;
      v108 = (char *)v51;
      v54 = (void *)_os_log_send_and_compose_impl();

      v99 = OS_LOG_TYPE_ERROR;
      v98 = 0;
      if (__nwlog_fault((const char *)v54, &v99, &v98))
      {
        if (v99 == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v55 = (os_log_s *)(id)gconnectionLogObj;
          v56 = v99;
          if (os_log_type_enabled(v55, v99))
          {
            v57 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446978;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v57;
            v105 = 2048;
            v106 = (uint64_t)v50;
            v107 = 2048;
            v108 = (char *)v51;
            _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p)",  buf,  0x2Au);
          }
        }

        else if (v98)
        {
          v58 = __nw_create_backtrace_string();
          if (v58)
          {
            v59 = (char *)v58;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v60 = (os_log_s *)(id)gconnectionLogObj;
            v61 = v99;
            if (os_log_type_enabled(v60, v99))
            {
              v62 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
              *(_DWORD *)buf = 136447234;
              v102 = "nw_association_register_internal";
              v103 = 2082;
              v104 = (void *)v62;
              v105 = 2048;
              v106 = (uint64_t)v50;
              v107 = 2048;
              v108 = (char *)v51;
              v109 = 2082;
              v110 = v59;
              _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v59);
            if (!v54) {
              goto LABEL_101;
            }
LABEL_100:
            free(v54);
            goto LABEL_101;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v55 = (os_log_s *)(id)gconnectionLogObj;
          v65 = v99;
          if (os_log_type_enabled(v55, v99))
          {
            v66 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446978;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v66;
            v105 = 2048;
            v106 = (uint64_t)v50;
            v107 = 2048;
            v108 = (char *)v51;
            _os_log_impl( &dword_181A5C000,  v55,  v65,  "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), no backtrace",  buf,  0x2Au);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v55 = (os_log_s *)(id)gconnectionLogObj;
          v63 = v99;
          if (os_log_type_enabled(v55, v99))
          {
            v64 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446978;
            v102 = "nw_association_register_internal";
            v103 = 2082;
            v104 = (void *)v64;
            v105 = 2048;
            v106 = (uint64_t)v50;
            v107 = 2048;
            v108 = (char *)v51;
            _os_log_impl( &dword_181A5C000,  v55,  v63,  "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), backtrace limit exceeded",  buf,  0x2Au);
          }
        }
      }

      if (!v54) {
        goto LABEL_101;
      }
      goto LABEL_100;
    }

    __nwlog_obj();
    v77 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v102 = "nw_association_register_internal";
    v78 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v99 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v78, &type, &v99))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v80 = type;
        if (os_log_type_enabled(v79, type))
        {
          *(_DWORD *)buf = 136446210;
          v102 = "nw_association_register_internal";
          _os_log_impl(&dword_181A5C000, v79, v80, "%{public}s called with null update_handler", buf, 0xCu);
        }
      }

      else
      {
        if (v99)
        {
          v88 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v90 = type;
          v91 = os_log_type_enabled(v89, type);
          if (v88)
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446466;
              v102 = "nw_association_register_internal";
              v103 = 2082;
              v104 = v88;
              _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s called with null update_handler, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v88);
          }

          else
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446210;
              v102 = "nw_association_register_internal";
              _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s called with null update_handler, no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_156;
        }

        __nwlog_obj();
        v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v94 = type;
        if (os_log_type_enabled(v79, type))
        {
          *(_DWORD *)buf = 136446210;
          v102 = "nw_association_register_internal";
          _os_log_impl( &dword_181A5C000,  v79,  v94,  "%{public}s called with null update_handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_151:
          *((_BYTE *)v160 + 474) |= 0x20u;
          if ((v53 & 0x800) == 0)
          {
LABEL_107:
            if ((v53 & 0x8000) == 0) {
              break;
            }
            goto LABEL_153;
          }

          if (v143[205] == -1)
          {
            if (*((_BYTE *)v142 + 1584)) {
              goto LABEL_153;
            }
          }

          else
          {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_80157);
            if (*((_BYTE *)v142 + 1584))
            {
LABEL_153:
            }
          }

          v110 = 0LL;
          goto LABEL_156;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v57 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
        {
          v176 = nw_endpoint_handler_get_id_string(v19);
          v177 = nw_endpoint_handler_dry_run_string(v19);
          v178 = nw_endpoint_handler_copy_endpoint(v19);
          v179 = nw_endpoint_get_logging_description(v178);
          v180 = nw_endpoint_handler_state_string(v19);
          v181 = nw_endpoint_handler_mode_string(v19);
          v182 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v176;
          v215 = 2082;
          v216 = v177;
          v217 = 2082;
          v218 = (void *)v179;
          v219 = 2082;
          v220 = v180;
          v221 = 2082;
          v222 = v181;
          v223 = 2114;
          v224 = v182;
          _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nexus no longer supported",  buf,  0x48u);
        }
      }

      else
      {
        v55 = v19;
        v56 = (*((_BYTE *)v55 + 268) & 0x20) == 0;

        if (!v56) {
          goto LABEL_139;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v57 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
        {
          v58 = nw_endpoint_handler_get_id_string(v55);
          v59 = nw_endpoint_handler_dry_run_string(v55);
          v60 = nw_endpoint_handler_copy_endpoint(v55);
          v61 = nw_endpoint_get_logging_description(v60);
          v62 = nw_endpoint_handler_state_string(v55);
          v63 = nw_endpoint_handler_mode_string(v55);
          v64 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v55);
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v58;
          v215 = 2082;
          v216 = v59;
          v217 = 2082;
          v218 = (void *)v61;
          v219 = 2082;
          v220 = v62;
          v221 = 2082;
          v222 = v63;
          v223 = 2114;
          v224 = v64;
          _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nexus no longer supported",  buf,  0x48u);
        }
      }

  __break(1u);
  return result;
}

          v107 = 100;
          goto LABEL_152;
        }

        if (!*((_BYTE *)v22 + 1537)) {
          goto LABEL_55;
        }
        __nwlog_obj();
        v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          v39 = *(void *)(*(void *)(a1 + 40) + 8LL);
          v40 = v39 + 275;
          v41 = *(void *)(v39 + 160);
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_protocol_copy_ws_definition_block_invoke_2";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v40;
          *(_WORD *)&buf[22] = 2048;
          *(void *)v158 = v41;
          v37 = v33;
          v38 = "%{public}s %{public}s input extended payload(16) = %zu";
LABEL_124:
          _os_log_impl(&dword_181A5C000, v37, OS_LOG_TYPE_DEBUG, v38, buf, 0x20u);
        }
      }

      else
      {
        if ((_DWORD)v32 == 127)
        {
          if (!nw_framer_parse_input( *(nw_framer_t *)(a1 + 32),  8uLL,  8uLL,  (uint8_t *)(v31 + 48),  &__block_literal_global_15))
          {
            v99 = 8LL;
            goto LABEL_143;
          }

          *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 160LL) = bswap64(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                                           + 48LL));
          if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 160LL) < 0x10000uLL)
          {
            __nwlog_obj();
            v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
            {
              v108 = *(void *)(*(void *)(a1 + 40) + 8LL);
              v109 = v108 + 275;
              v110 = *(void *)(v108 + 160);
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v109;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)v158 = 0xFFFF;
              *(_WORD *)&v158[4] = 2048;
              *(void *)&v158[6] = v110;
              v111 = "%{public}s %{public}s expected a payload length of greater than %u, but received %zu";
              v112 = v101;
              v113 = 38;
              goto LABEL_150;
            }

            goto LABEL_151;
          }

          if (!*((_BYTE *)v22 + 1537)) {
            goto LABEL_55;
          }
          __nwlog_obj();
          v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_125;
          }
          v34 = *(void *)(*(void *)(a1 + 40) + 8LL);
          v35 = v34 + 275;
          v36 = *(void *)(v34 + 160);
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_protocol_copy_ws_definition_block_invoke_2";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v35;
          *(_WORD *)&buf[22] = 2048;
          *(void *)v158 = v36;
          v37 = v33;
          v38 = "%{public}s %{public}s input extended payload(64) = %zu";
          goto LABEL_124;
        }

        *(void *)(v31 + 160) = v32;
        if (!*((_BYTE *)v22 + 1537))
        {
LABEL_55:
          v42 = *(void *)(*(void *)(a1 + 40) + 8LL);
          if (!*(void *)(v42 + 144))
          {
LABEL_59:
            if ((*(_BYTE *)(v42 + 232) & 8) != 0)
            {
              if (*(void *)(v42 + 136))
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v43 = (os_log_s *)(id)gLogObj;
                if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
                {
                  v44 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v44;
                  _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s state.input_buffer should not be present",  buf,  0x16u);
                }

                v42 = *(void *)(*(void *)(a1 + 40) + 8LL);
              }

              v45 = *(void *)(v42 + 160);
              if (v45)
              {
                v46 = malloc(*(void *)(v42 + 160));
                if (!v46)
                {
                  __nwlog_obj();
                  v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_enabled(v93, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "strict_malloc";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = v45;
                  v94 = (void *)_os_log_send_and_compose_impl();

                  result = __nwlog_abort((uint64_t)v94);
                  if (result)
                  {
                    __break(1u);
                    return result;
                  }

                  free(v94);
                  v42 = *(void *)(*(void *)(a1 + 40) + 8LL);
                }

                *(void *)(v42 + 136) = v46;
                v42 = *(void *)(*(void *)(a1 + 40) + 8LL);
              }
            }

            if ((*(_WORD *)(v42 + 264) & 0x80) != 0) {
              v47 = 4;
            }
            else {
              v47 = 5;
            }
            *(_DWORD *)(v42 + 228) = v47;
            v24 = *(void *)(a1 + 40);
            v22 = &qword_18C45F000;
            goto LABEL_71;
          }

          *(void *)(v42 + 152) += *(void *)(v42 + 160);
          v42 = *(void *)(*(void *)(a1 + 40) + 8LL);
          if (*(void *)(v42 + 152) <= *(void *)(v42 + 144))
          {
            if ((*(_WORD *)(v42 + 273) & 8) != 0)
            {
              *(void *)(v42 + 152) = 0LL;
              v42 = *(void *)(*(void *)(a1 + 40) + 8LL);
            }

            goto LABEL_59;
          }

          nw_ws_write_header(v42 + 48, *(void **)(a1 + 32), 8, 0x3F1u, 0LL, 0, 1);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v101 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
          {
            v102 = *(void *)(*(void *)(a1 + 40) + 8LL);
            v103 = v102 + 275;
            v106 = v102 + 144;
            v104 = *(void *)(v102 + 144);
            v105 = *(void *)(v106 + 8);
            *(_DWORD *)buf = 136446978;
            *(void *)&buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v103;
            *(_WORD *)&buf[22] = 2048;
            *(void *)v158 = v105;
            *(_WORD *)&v158[8] = 2048;
            *(void *)&v158[10] = v104;
            _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s input message size %zu exceeds maximum message size %zu",  buf,  0x2Au);
          }

          v107 = 40;
LABEL_152:

          v4 = v135;
          nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), v107);
          goto LABEL_7;
        }

        __nwlog_obj();
        v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          v90 = *(void *)(*(void *)(a1 + 40) + 8LL);
          v91 = v90 + 275;
          v92 = *(void *)(v90 + 160);
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_protocol_copy_ws_definition_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v91;
          *(_WORD *)&buf[22] = 2048;
          *(void *)v158 = v92;
          v37 = v33;
          v38 = "%{public}s %{public}s input payload length = %zu";
          goto LABEL_124;
        }
      }

          if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
          {
            if (__nwlog_connection_group_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
            }
            v92 = (os_log_s *)(id)gconnection_groupLogObj;
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
            {
              v93 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
              identifier = nw_content_context_get_identifier(v10);
              v95 = *(void **)(a1 + 40);
              *(_DWORD *)buf = 136447234;
              *(void *)&buf[4] = "nw_connection_group_read_on_connection_block_invoke";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v93;
              *(_WORD *)&buf[18] = 2048;
              *(void *)&buf[20] = v10;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = identifier;
              *(_WORD *)&buf[38] = 2112;
              v179 = v95;
              _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] final, complete content context (%p: %s), stopping reading on %@",  buf,  0x30u);
            }
          }

          goto LABEL_172;
        }

            if (v39) {
              free(v39);
            }
LABEL_37:
            if (v19 == &nw_protocol_ref_counted_handle)
            {
              nw::release_if_needed<nw_protocol *>((uint64_t *)&v75);
              if (v16 != &nw_protocol_ref_counted_handle) {
                goto LABEL_42;
              }
            }

            else if (v16 != &nw_protocol_ref_counted_handle)
            {
              goto LABEL_42;
            }

            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            goto LABEL_42;
          }

          __nwlog_obj();
          v54 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "__nw_protocol_disconnected";
          v29 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v75) = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v56 = type[0];
            if (os_log_type_enabled(v55, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "__nw_protocol_disconnected";
              _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s called with null protocol", buf, 0xCu);
            }

        goto LABEL_152;
      }

      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v71 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v71,  "%{public}s called with null instance->parent_definition->start, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v69 = type[0];
      v70 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v70)
        {
          *(_DWORD *)buf = 136446210;
          v169 = "nw_protocol_implementation_connect";
          _os_log_impl( &dword_181A5C000,  v53,  v69,  "%{public}s called with null instance->parent_definition->start, no backtrace",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      if (v70)
      {
        *(_DWORD *)buf = 136446466;
        v169 = "nw_protocol_implementation_connect";
        v170 = 2082;
        v171 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v53,  v69,  "%{public}s called with null instance->parent_definition->start, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    if (!v28)
    {
LABEL_24:
      v7 = 0LL;
      goto LABEL_9;
    }

    if (!v28)
    {
LABEL_24:
      v7 = 0LL;
      goto LABEL_9;
    }

    if (!v29)
    {
LABEL_24:
      v8 = 0LL;
      goto LABEL_9;
    }

      free(v38);
      goto LABEL_152;
    }

    __nwlog_obj();
    v123 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v163 = "nw_parameters_create_secure_http_messaging";
    v124 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v160 = 0;
    if (__nwlog_fault(v124, &type, &v160))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v126 = type;
        if (os_log_type_enabled(v125, type))
        {
          *(_DWORD *)buf = 136446210;
          v163 = "nw_parameters_create_secure_http_messaging";
          _os_log_impl(&dword_181A5C000, v125, v126, "%{public}s called with null stack", buf, 0xCu);
        }
      }

      else
      {
        if (v160)
        {
          v142 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v143 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v144 = type;
          v145 = os_log_type_enabled(v143, type);
          if (v142)
          {
            if (v145)
            {
              *(_DWORD *)buf = 136446466;
              v163 = "nw_parameters_create_secure_http_messaging";
              v164 = 2082;
              v165 = v142;
              _os_log_impl( &dword_181A5C000,  v143,  v144,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v142);
          }

          else
          {
            if (v145)
            {
              *(_DWORD *)buf = 136446210;
              v163 = "nw_parameters_create_secure_http_messaging";
              _os_log_impl(&dword_181A5C000, v143, v144, "%{public}s called with null stack, no backtrace", buf, 0xCu);
            }
          }

          goto LABEL_324;
        }

        __nwlog_obj();
        v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v152 = type;
        if (os_log_type_enabled(v125, type))
        {
          *(_DWORD *)buf = 136446210;
          v163 = "nw_parameters_create_secure_http_messaging";
          _os_log_impl( &dword_181A5C000,  v125,  v152,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

          goto LABEL_152;
        }

        if (!v94)
        {
          __nwlog_obj();
          v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v92 = type;
          if (os_log_type_enabled(v68, type))
          {
            *(_DWORD *)buf = 136446210;
            v97 = "nw_endpoint_handler_inject_read_closed";
            _os_log_impl( &dword_181A5C000,  v68,  v92,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_151;
        }

        v89 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v90 = type;
        v91 = os_log_type_enabled(v68, type);
        if (!v89)
        {
          if (v91)
          {
            *(_DWORD *)buf = 136446210;
            v97 = "nw_endpoint_handler_inject_read_closed";
            _os_log_impl(&dword_181A5C000, v68, v90, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }

          goto LABEL_151;
        }

        if (v91)
        {
          *(_DWORD *)buf = 136446466;
          v97 = "nw_endpoint_handler_inject_read_closed";
          v98 = 2082;
          *(void *)v99 = v89;
          _os_log_impl( &dword_181A5C000,  v68,  v90,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v89);
      }

        goto LABEL_152;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v82 = v87[0];
        if (os_log_type_enabled(v66, v87[0]))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_connection_read_buffer";
          _os_log_impl( &dword_181A5C000,  v66,  v82,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      v73 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v76 = v87[0];
      v77 = os_log_type_enabled(v66, v87[0]);
      if (!v73)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_connection_read_buffer";
          _os_log_impl(&dword_181A5C000, v66, v76, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_151;
      }

      if (v77)
      {
        *(_DWORD *)buf = 136446466;
        v94 = "nw_connection_read_buffer";
        v95 = 2082;
        *(void *)v96 = v73;
        _os_log_impl( &dword_181A5C000,  v66,  v76,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_134;
    }
  }

  else
  {
    __nwlog_obj();
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_connection_read_buffer";
    v65 = (char *)_os_log_send_and_compose_impl();

    v87[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v65, v87, &type))
    {
      if (v87[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v67 = v87[0];
        if (os_log_type_enabled(v66, v87[0]))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_connection_read_buffer";
          _os_log_impl(&dword_181A5C000, v66, v67, "%{public}s called with null connection", buf, 0xCu);
        }

        goto LABEL_151;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v81 = v87[0];
        if (os_log_type_enabled(v66, v87[0]))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_connection_read_buffer";
          _os_log_impl( &dword_181A5C000,  v66,  v81,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_151;
      }

      v73 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v74 = v87[0];
      v75 = os_log_type_enabled(v66, v87[0]);
      if (!v73)
      {
        if (v75)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_connection_read_buffer";
          _os_log_impl(&dword_181A5C000, v66, v74, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }

        goto LABEL_151;
      }

      if (v75)
      {
        *(_DWORD *)buf = 136446466;
        v94 = "nw_connection_read_buffer";
        v95 = 2082;
        *(void *)v96 = v73;
        _os_log_impl( &dword_181A5C000,  v66,  v74,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      if (v48) {
        free(v48);
      }
      v17 = 0;
LABEL_28:
      _Block_object_dispose(type, 8);
      if ((v80 & 1) != 0 && v79) {
        os_release(v79);
      }
      if (v12) {
        os_release(v12);
      }
      if (!v17) {
        goto LABEL_47;
      }
      goto LABEL_34;
    }

    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_http_security_process_response";
    v42 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v61[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v42, type, v61))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v43 = (os_log_s *)__nwlog_obj();
        v44 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)block = 136446210;
          *(void *)&block[4] = "nw_http_security_process_response";
          v45 = "%{public}s called with null response";
LABEL_138:
          _os_log_impl(&dword_181A5C000, v43, v44, v45, block, 0xCu);
        }
      }

      else if (v61[0])
      {
        v46 = (char *)__nw_create_backtrace_string();
        v43 = (os_log_s *)__nwlog_obj();
        v44 = type[0];
        v47 = os_log_type_enabled(v43, type[0]);
        if (v46)
        {
          if (v47)
          {
            *(_DWORD *)block = 136446466;
            *(void *)&block[4] = "nw_http_security_process_response";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = v46;
            _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s called with null response, dumping backtrace:%{public}s",  block,  0x16u);
          }

          free(v46);
          goto LABEL_139;
        }

        if (v47)
        {
          *(_DWORD *)block = 136446210;
          *(void *)&block[4] = "nw_http_security_process_response";
          v45 = "%{public}s called with null response, no backtrace";
          goto LABEL_138;
        }
      }

      else
      {
        v43 = (os_log_s *)__nwlog_obj();
        v44 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)block = 136446210;
          *(void *)&block[4] = "nw_http_security_process_response";
          v45 = "%{public}s called with null response, backtrace limit exceeded";
          goto LABEL_138;
        }
      }
    }

      free(v101);
      goto LABEL_152;
    }

    __nwlog_obj();
    v156 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v267 = 136447234;
    v268 = "nw_necp_append_tlv";
    v269 = 2048;
    *(void *)v270 = v29;
    *(_WORD *)&v270[8] = 2048;
    *(void *)v271 = v28;
    *(_WORD *)&v271[8] = 1024;
    *(_DWORD *)v272 = 16;
    *(_WORD *)&v272[4] = 1024;
    *(_DWORD *)&v272[6] = v76;
    v101 = (char *)_os_log_send_and_compose_impl();

    v262 = OS_LOG_TYPE_ERROR;
    v261 = 0;
    if (v262 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v157 = v262;
      if (os_log_type_enabled(v102, v262))
      {
        *(_DWORD *)v267 = 136447234;
        v268 = "nw_necp_append_tlv";
        v269 = 2048;
        *(void *)v270 = v29;
        *(_WORD *)&v270[8] = 2048;
        *(void *)v271 = v222;
        *(_WORD *)&v271[8] = 1024;
        *(_DWORD *)v272 = 16;
        *(_WORD *)&v272[4] = 1024;
        *(_DWORD *)&v272[6] = v76;
        _os_log_impl( &dword_181A5C000,  v102,  v157,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  v267,  0x2Cu);
      }
    }

    else if (v261)
    {
      v186 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v187 = v262;
      v188 = os_log_type_enabled(v102, v262);
      if (v186)
      {
        if (v188)
        {
          *(_DWORD *)v267 = 136447490;
          v268 = "nw_necp_append_tlv";
          v269 = 2048;
          *(void *)v270 = v29;
          *(_WORD *)&v270[8] = 2048;
          *(void *)v271 = v222;
          *(_WORD *)&v271[8] = 1024;
          *(_DWORD *)v272 = 16;
          *(_WORD *)&v272[4] = 1024;
          *(_DWORD *)&v272[6] = v76;
          *(_WORD *)v273 = 2082;
          *(void *)&v273[2] = v186;
          _os_log_impl( &dword_181A5C000,  v102,  v187,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  v267,  0x36u);
        }

        free(v186);
        goto LABEL_150;
      }

      if (v188)
      {
        *(_DWORD *)v267 = 136447234;
        v268 = "nw_necp_append_tlv";
        v269 = 2048;
        *(void *)v270 = v29;
        *(_WORD *)&v270[8] = 2048;
        *(void *)v271 = v222;
        *(_WORD *)&v271[8] = 1024;
        *(_DWORD *)v272 = 16;
        *(_WORD *)&v272[4] = 1024;
        *(_DWORD *)&v272[6] = v76;
        _os_log_impl( &dword_181A5C000,  v102,  v187,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  v267,  0x2Cu);
      }
    }

    else
    {
      __nwlog_obj();
      v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v206 = v262;
      if (os_log_type_enabled(v102, v262))
      {
        *(_DWORD *)v267 = 136447234;
        v268 = "nw_necp_append_tlv";
        v269 = 2048;
        *(void *)v270 = v29;
        *(_WORD *)&v270[8] = 2048;
        *(void *)v271 = v222;
        *(_WORD *)&v271[8] = 1024;
        *(_DWORD *)v272 = 16;
        *(_WORD *)&v272[4] = 1024;
        *(_DWORD *)&v272[6] = v76;
        _os_log_impl( &dword_181A5C000,  v102,  v206,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  v267,  0x2Cu);
      }
    }

          v5 = v579;
          if (v15) {
            free(v15);
          }
          v3 = v580;
          v4 = v14;
          goto LABEL_175;
        }

        v36 = *(void *)(v8 + 592);
        v37 = *(void **)(v8 + 600);
        if (v36)
        {
          *(void *)(v36 + 600) = v37;
          v37 = *(void **)(v8 + 600);
        }

        else
        {
          *(void *)(v3 + 216) = v37;
        }

        *v37 = v36;
        *(void *)(v8 + 592) = 0LL;
        *(void *)(v8 + 600) = 0LL;
        v97 = *(_DWORD *)(v3 + 340);
        *(_DWORD *)(v3 + 340) = v97 - 1;
        if (v97)
        {
LABEL_169:
          v128 = (unsigned __int16)*v13;
          v129 = (v128 | (*(unsigned __int8 *)(v8 + 874) << 16)) & 0xFFF7FFFF;
          *v13 = v128;
          *(_BYTE *)(v8 + 874) = BYTE2(v129);
          if ((*(_BYTE *)(v8 + 158) & 1) == 0)
          {
            if (*((_BYTE *)v4 + 1537))
            {
              v402 = v4;
              v403 = (os_log_s *)__nwlog_obj();
              v404 = os_log_type_enabled(v403, OS_LOG_TYPE_DEBUG);
              v4 = v402;
              v3 = v580;
              if (v404)
              {
                v405 = *(void *)(v8 + 488);
                v406 = *(_DWORD *)(*(void *)(v8 + 480) + 372LL);
                v407 = *(_DWORD *)(v8 + 860);
                if (v405) {
                  LODWORD(v405) = *(_DWORD *)(v405 + 424);
                }
                v408 = *(_DWORD *)(v580 + 340);
                *(_DWORD *)buf = 136448002;
                *(void *)&buf[4] = "nw_http1_remove_idle_connection";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v8 + 74;
                *(_WORD *)&buf[22] = 2080;
                v608 = (uint64_t)" ";
                *(_WORD *)v609 = 1024;
                *(_DWORD *)&v609[2] = v406;
                *(_WORD *)&v609[6] = 1024;
                *(_DWORD *)&v609[8] = v407;
                *(_WORD *)&v609[12] = 1024;
                *(_DWORD *)&v609[14] = v405;
                *(_WORD *)&v609[18] = 2048;
                *(void *)&v609[20] = v8;
                *(_WORD *)&v609[28] = 1024;
                *(_DWORD *)&v609[30] = v408;
                _os_log_impl( &dword_181A5C000,  v403,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed idle connection %p, now have %u idle connections",  buf,  0x42u);
                v3 = v580;
                v5 = v579;
                v4 = v402;
              }
            }
          }

          if (*(void *)(v8 + 784))
          {
            if ((*(_BYTE *)(v8 + 158) & 1) == 0)
            {
              if (*((_BYTE *)v4 + 1537))
              {
                v417 = v4;
                v418 = (os_log_s *)__nwlog_obj();
                v419 = os_log_type_enabled(v418, OS_LOG_TYPE_DEBUG);
                v4 = v417;
                if (v419)
                {
                  v420 = *(void *)(v8 + 488);
                  v421 = *(_DWORD *)(*(void *)(v8 + 480) + 372LL);
                  v422 = *(_DWORD *)(v8 + 860);
                  if (v420) {
                    LODWORD(v420) = *(_DWORD *)(v420 + 424);
                  }
                  *(_DWORD *)buf = 136447746;
                  *(void *)&buf[4] = "nw_http1_remove_idle_connection";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v8 + 74;
                  *(_WORD *)&buf[22] = 2080;
                  v608 = (uint64_t)" ";
                  *(_WORD *)v609 = 1024;
                  *(_DWORD *)&v609[2] = v421;
                  *(_WORD *)&v609[6] = 1024;
                  *(_DWORD *)&v609[8] = v422;
                  *(_WORD *)&v609[12] = 1024;
                  *(_DWORD *)&v609[14] = v420;
                  *(_WORD *)&v609[18] = 2048;
                  *(void *)&v609[20] = v8;
                  _os_log_impl( &dword_181A5C000,  v418,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> deactivating destroy timer for connection %p",  buf,  0x3Cu);
                  v5 = v579;
                  v4 = v417;
                }
              }
            }

            v130 = v4;
            nw_queue_cancel_source(*(void *)(v8 + 784), v2);
            v4 = v130;
            *(void *)(v8 + 784) = 0LL;
            v3 = v580;
          }

  logc = nw_endpoint_create_address(__src);
  v87 = nw_endpoint_create_address(__dst);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v88 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
  {
    description = nw_endpoint_get_description(v87);
    logging_description = nw_endpoint_get_logging_description(logc);
    *(_DWORD *)buf = 136446722;
    *(void *)&buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = description;
    *(_WORD *)&buf[22] = 2082;
    *(void *)&buf[24] = logging_description;
    _os_log_impl(&dword_181A5C000, v88, OS_LOG_TYPE_DEBUG, "%{public}s Looking up %{public}s<->%{public}s", buf, 0x20u);
  }

  v91 = v9;
  v92 = (void **)v91;
  if ((v91[167] & 1) == 0) {
    goto LABEL_155;
  }
  v95 = *((void *)v91 + 19);
  if (!v95)
  {
LABEL_169:

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v100 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v100, OS_LOG_TYPE_INFO))
    {
      v101 = nw_endpoint_get_description(v87);
      v102 = nw_endpoint_get_logging_description(logc);
      *(_DWORD *)buf = 136446722;
      *(void *)&buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v101;
      *(_WORD *)&buf[22] = 2082;
      *(void *)&buf[24] = v102;
      _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_INFO,  "%{public}s packet %{public}s<-%{public}s does not match listener",  buf,  0x20u);
    }

    goto LABEL_324;
  }

  v96 = *(unsigned __int8 *)(v95 + 1);
  if (__dst[0].sa_family == 2 && v96 == 2)
  {
    if (*(_DWORD *)(v95 + 4) != *(_DWORD *)&__dst[0].sa_data[2]) {
      goto LABEL_169;
    }
  }

  else
  {
    if (__dst[0].sa_family != 30 || v96 != 30) {
      goto LABEL_169;
    }
    v98 = *(void *)(v95 + 8);
    v97 = *(void *)(v95 + 16);
    if (v98 != *(void *)&__dst[0].sa_data[6] || v97 != *(void *)&__dst[1].sa_len) {
      goto LABEL_169;
    }
  }

            if (v43) {
              free(v43);
            }
LABEL_12:
            if (protocol_handler)
            {
              v19 = *(void (***)(uint64_t, uint64_t))(protocol_handler + 24);
              if (v19)
              {
                v20 = *v19;
                if (v20)
                {
                  v20(protocol_handler, v14);
                  goto LABEL_16;
                }
              }

              __nwlog_obj();
              v27 = (void *)objc_claimAutoreleasedReturnValue();
              v28 = *(const char **)(protocol_handler + 16);
              if (!v28) {
                v28 = "invalid";
              }
            }

            else
            {
              __nwlog_obj();
              v27 = (void *)objc_claimAutoreleasedReturnValue();
              v28 = "invalid";
            }

            *(_DWORD *)buf = 136446466;
            v94 = "nw_agent_client_attach_protocol_block_invoke";
            v95 = 2082;
            *(void *)v96 = v28;
            v51 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v91 = 0;
            if (__nwlog_fault(v51, &type, &v91))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v53 = type;
                if (os_log_type_enabled(v52, type))
                {
                  v54 = "invalid";
                  if (protocol_handler && *(void *)(protocol_handler + 16)) {
                    v54 = *(const char **)(protocol_handler + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  v95 = 2082;
                  *(void *)v96 = v54;
                  _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s protocol %{public}s has invalid add_input_handler callback",  buf,  0x16u);
                }
              }

              else if (v91)
              {
                v55 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v56 = type;
                v57 = os_log_type_enabled(v52, type);
                if (v55)
                {
                  if (v57)
                  {
                    v58 = "invalid";
                    if (protocol_handler && *(void *)(protocol_handler + 16)) {
                      v58 = *(const char **)(protocol_handler + 16);
                    }
                    *(_DWORD *)buf = 136446722;
                    v94 = "nw_agent_client_attach_protocol_block_invoke";
                    v95 = 2082;
                    *(void *)v96 = v58;
                    *(_WORD *)&v96[8] = 2082;
                    *(void *)&v96[10] = v55;
                    _os_log_impl( &dword_181A5C000,  v52,  v56,  "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s",  buf,  0x20u);
                  }

                  free(v55);
                  goto LABEL_159;
                }

                if (v57)
                {
                  v85 = "invalid";
                  if (protocol_handler && *(void *)(protocol_handler + 16)) {
                    v85 = *(const char **)(protocol_handler + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  v95 = 2082;
                  *(void *)v96 = v85;
                  _os_log_impl( &dword_181A5C000,  v52,  v56,  "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace",  buf,  0x16u);
                }
              }

              else
              {
                __nwlog_obj();
                v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v69 = type;
                if (os_log_type_enabled(v52, type))
                {
                  v70 = "invalid";
                  if (protocol_handler && *(void *)(protocol_handler + 16)) {
                    v70 = *(const char **)(protocol_handler + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  v95 = 2082;
                  *(void *)v96 = v70;
                  _os_log_impl( &dword_181A5C000,  v52,  v69,  "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded",  buf,  0x16u);
                }
              }
            }

              if (v90) {
                free(v90);
              }
              *((_DWORD *)v313 + 6) = -1;
              v15 = MEMORY[0x1895F87A8];
            }

            v133 = *((unsigned int *)v309 + 6);
            v134 = v286[3];
            v54 = __CFADD__(v133, v134);
            v135 = v133 + v134;
            *((_DWORD *)v309 + 6) = v135;
            if (v54 || HIDWORD(v135))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v136 = v286[3];
              v137 = *((unsigned int *)v309 + 6);
              *(_DWORD *)buf = 136446978;
              v317 = "nw_protocol_http2_get_input_frames";
              v318 = 2082;
              v319 = "total_bytes";
              v320 = 2048;
              v321 = v136;
              v322 = 2048;
              *(void *)v323 = v137;
              v138 = (char *)_os_log_send_and_compose_impl();
              v265[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v261) = 0;
              if (v265[0] != OS_LOG_TYPE_FAULT)
              {
                if ((_BYTE)v261)
                {
                  v146 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v147 = (os_log_s *)gLogObj;
                  v148 = v265[0];
                  v149 = os_log_type_enabled((os_log_t)gLogObj, v265[0]);
                  if (v146)
                  {
                    if (v149)
                    {
                      v150 = v286[3];
                      v151 = *((unsigned int *)v309 + 6);
                      *(_DWORD *)buf = 136447234;
                      v317 = "nw_protocol_http2_get_input_frames";
                      v318 = 2082;
                      v319 = "total_bytes";
                      v320 = 2048;
                      v321 = v150;
                      v322 = 2048;
                      *(void *)v323 = v151;
                      *(_WORD *)&v323[8] = 2082;
                      *(void *)&v323[10] = v146;
                      _os_log_impl( &dword_181A5C000,  v147,  v148,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                    }

                    free(v146);
                    goto LABEL_170;
                  }

                  if (!v149) {
                    goto LABEL_170;
                  }
                  v156 = v286[3];
                  v157 = *((unsigned int *)v309 + 6);
                  *(_DWORD *)buf = 136446978;
                  v317 = "nw_protocol_http2_get_input_frames";
                  v318 = 2082;
                  v319 = "total_bytes";
                  v320 = 2048;
                  v321 = v156;
                  v322 = 2048;
                  *(void *)v323 = v157;
                  v143 = v147;
                  v144 = v148;
                  v145 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                }

                else
                {
                  v152 = (os_log_s *)__nwlog_obj();
                  v153 = v265[0];
                  if (!os_log_type_enabled(v152, v265[0])) {
                    goto LABEL_170;
                  }
                  v154 = v286[3];
                  v155 = *((unsigned int *)v309 + 6);
                  *(_DWORD *)buf = 136446978;
                  v317 = "nw_protocol_http2_get_input_frames";
                  v318 = 2082;
                  v319 = "total_bytes";
                  v320 = 2048;
                  v321 = v154;
                  v322 = 2048;
                  *(void *)v323 = v155;
                  v143 = v152;
                  v144 = v153;
                  v145 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                }

    if (v41) {
      free(v41);
    }
    v6 = 0LL;
    goto LABEL_10;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_protocol_test_add_input_handler";
  v20 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v66 = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v21 = (os_log_s *)__nwlog_obj();
    v22 = type[0];
    if (!os_log_type_enabled(v21, type[0])) {
      goto LABEL_66;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_test_add_input_handler";
    v23 = "%{public}s called with null test";
    goto LABEL_65;
  }

  if (!v66)
  {
    v21 = (os_log_s *)__nwlog_obj();
    v22 = type[0];
    if (!os_log_type_enabled(v21, type[0])) {
      goto LABEL_66;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_test_add_input_handler";
    v23 = "%{public}s called with null test, backtrace limit exceeded";
    goto LABEL_65;
  }

  v32 = (char *)__nw_create_backtrace_string();
  v21 = (os_log_s *)__nwlog_obj();
  v22 = type[0];
  v48 = os_log_type_enabled(v21, type[0]);
  if (v32)
  {
    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_test_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v32;
      v34 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_48;
    }

LABEL_152:
          *((_BYTE *)v160 + 474) |= 0x40u;
          if ((v53 & 0x8000) == 0) {
            break;
          }
LABEL_153:
          *((_BYTE *)v160 + 475) |= 4u;
          break;
        case 8:
          if ((_DWORD)v20 == 8) {
            goto LABEL_110;
          }
          if (v20 >= 9)
          {
            __nwlog_obj();
            v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 8;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 8;
              _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_110:
            v54 = *(_DWORD *)v27;
            v55 = *(_DWORD *)(v27 + 4);
            if (v160->policy_result.direct_interface_index)
            {
              if (!v160->policy_result.delegate_interface_index)
              {
                v160->policy_result.delegate_interface_index = v55;
                v160->policy_result.delegate_interface_generation = v54;
              }
            }

            else
            {
              v160->policy_result.direct_interface_index = v55;
              v160->policy_result.direct_interface_generation = v54;
            }
          }

          break;
        case 9:
          if ((_DWORD)v20 == 24) {
            goto LABEL_123;
          }
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&buf[4] = "nw_path_verify_tlv_length";
            v164 = 1024;
            *(_DWORD *)v165 = 9;
            *(_WORD *)&v165[4] = 1024;
            *(_DWORD *)&v165[6] = v20;
            *(_WORD *)&v165[10] = 1024;
            *(_DWORD *)&v165[12] = 24;
            _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
          }

LABEL_123:
          v59 = v154 + 8;
          if (v154 != -8) {
            goto LABEL_125;
          }
          v94 = v14;
          __nwlog_obj();
          v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v95, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "_strict_reallocf";
          v153 = buf;
          v96 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v96);
          if (result) {
            goto LABEL_375;
          }
          free(v96);
          v14 = v94;
LABEL_125:
          v154 += 8;
          __ptr = (necp_client_interface_option *)reallocf(__ptr, 24LL * v59);
          if (__ptr) {
            goto LABEL_126;
          }
          v97 = v14;
          __nwlog_obj();
          v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v98, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "_strict_reallocf";
          v164 = 2048;
          *(void *)v165 = 24LL * v59;
          v153 = buf;
          v99 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v99);
          if (result) {
            goto LABEL_375;
          }
          free(v99);
          __ptr = 0LL;
          v14 = v97;
LABEL_126:
          v60 = *(_OWORD *)v27;
          v61 = (char *)__ptr + 24 * v158;
          *((void *)v61 + 2) = *(void *)(v27 + 16);
          *(_OWORD *)v61 = v60;
          LODWORD(v158) = v158 + 1;
          break;
        case 10:
          if ((_DWORD)v20 == 4) {
            goto LABEL_128;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 10;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_128:
            v160->effective_mtu = *(_DWORD *)v27;
          }

          break;
        case 11:
          flow_result_from_tlv = (os_log_s *)nw_path_create_flow_result_from_tlv( v160,  (const unsigned __int8 *)v27,  v20);
          if (flow_result_from_tlv)
          {
            flows = (uint64_t)v160->flows;
            if (!flows)
            {
              v41 = nw_array_create();
              v42 = v160->flows;
              v160->flows = (OS_nw_array *)v41;

              flows = (uint64_t)v160->flows;
            }

            nw_array_append(flows, flow_result_from_tlv);
          }

          goto LABEL_20;
        case 15:
          if ((_DWORD)v20 != 1)
          {
            __nwlog_obj();
            v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 15;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 1;
              _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }
          }

          v160->recommended_mss = *(_BYTE *)v27;
          break;
        case 17:
          if ((_DWORD)v20 == 4) {
            goto LABEL_77;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 17;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_77:
            v160->interface_time_delta = *(_DWORD *)v27;
          }

          break;
        case 18:
          if ((_DWORD)v20 == 4) {
            goto LABEL_62;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 18;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_62:
            v33 = *(_DWORD *)v27 - 1;
            if (v33 <= 5) {
              nw_path_set_reason(v160, dword_18272C8B0[v33], off_189BC3BF0[v33], v9, v10, v11, v12, v13, (char)v153);
            }
          }

          break;
        case 19:
          v56 = v160;
          v160->policy_result.flow_divert_aggregate_unit = 0;
          if ((_DWORD)v20 == 4) {
            goto LABEL_114;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 19;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

            v56 = v160;
LABEL_114:
            v56->policy_result.flow_divert_aggregate_unit = *(_DWORD *)v27;
          }

          break;
        case 156:
          if (v159)
          {
            if ((_DWORD)v20 == 16) {
              goto LABEL_121;
            }
            if (v20 >= 0x11)
            {
              __nwlog_obj();
              v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&buf[4] = "nw_path_verify_tlv_length";
                v164 = 1024;
                *(_DWORD *)v165 = 156;
                *(_WORD *)&v165[4] = 1024;
                *(_DWORD *)&v165[6] = v20;
                *(_WORD *)&v165[10] = 1024;
                *(_DWORD *)&v165[12] = 16;
                _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
              }

LABEL_121:
              v58 = v159;
              *(_OWORD *)((char *)v58 + 28) = *(_OWORD *)v27;
              v159 = v58;

              break;
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v67 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_path_parse_necp_result";
              _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s No previous endpoint to apply endpoint agent to",  buf,  0xCu);
            }

    if (v68) {
      free(v68);
    }
    v6 = *(void *)(a1 + 48);
LABEL_30:
    v9 = *(unsigned __int16 *)(v6 + 94);
    if ((~v9 & 0x14) == 0) {
      goto LABEL_31;
    }
    if ((v9 & 4) != 0)
    {
      v12 = *(unsigned int *)(v6 + 48) + (unint64_t)*(unsigned int *)(v6 + 32) + bswap32(v93 + 17);
      LODWORD(v12) = ((WORD1(v12) + (unsigned __int16)v12) >> 16) + (unsigned __int16)(WORD1(v12) + v12);
      v11 = v12 + WORD1(v12);
    }

    else
    {
      LOWORD(v11) = in6_pseudo((unsigned __int16 *)(v6 + 32), (unsigned __int16 *)(v6 + 48), bswap32(v93 + 17));
    }

    *(_WORD *)(v5 + 6) = v11;
    v13 = *(void *)(a1 + 48);
    v14 = *(_WORD *)(v13 + 94);
    if ((v14 & 0x100) == 0)
    {
LABEL_44:
      v10 = *(void *)(a1 + 48);
      v16 = *(_WORD *)(v10 + 94);
      if ((v16 & 0x100) != 0) {
        goto LABEL_52;
      }
      if ((v16 & 8) == 0) {
        goto LABEL_46;
      }
      if ((v16 & 4) != 0) {
        v24 = 20LL;
      }
      else {
        v24 = 40LL;
      }
      if ((v16 & 4) != 0) {
        v25 = 26LL;
      }
      else {
        v25 = 46LL;
      }
      if (a2)
      {
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0) {
          goto LABEL_46;
        }
        v26 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))g_channel_set_internet_checksum_handler;
        *(_BYTE *)(a2 + 203) |= 3u;
        v27 = v26(a2, 3LL, v24, v25);
        if (!v27) {
          goto LABEL_31;
        }
        v28 = v27;
        if (v27 == 45)
        {
LABEL_46:
          v17 = *(void *)(a1 + 48);
          v18 = *(_WORD *)(v17 + 94);
          if (in_finalize_cksum(a2, 6u, 1))
          {
            if (a2)
            {
              if ((*(_WORD *)(a2 + 204) & 0x100) != 0
                && g_channel_check_validity
                && (g_channel_check_validity(a2, *(void *)(a2 + 88)) & 1) == 0)
              {
LABEL_214:
                *(void *)(v17 + 64) = 0LL;
                *(void *)(v17 + 72) = 0LL;
                goto LABEL_31;
              }

  if (v129) {
    free(v129);
  }
  **(_DWORD **)(a1 + 88) = -1;
LABEL_155:
  v139 = *(void *)(*(void *)(a1 + 32) + 8LL);
  v140 = *(unsigned int *)(v139 + 24) + 1LL;
  v141 = v140 << 31 >> 31;
  *(_DWORD *)(v139 + 24) = v140;
  if (v141 != v140 || v141 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v142 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "count";
    *(_WORD *)&buf[22] = 2048;
    v292 = 1LL;
    v293 = 2048;
    v294 = v142;
    v143 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v288 = 0;
    if (__nwlog_fault(v143, &type, &v288))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v144 = (os_log_s *)gLogObj;
        v145 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v146 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1LL;
          v293 = 2048;
          v294 = v146;
          v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_170:
          _os_log_impl(&dword_181A5C000, v144, v145, v147, buf, 0x2Au);
        }
      }

      else if (v288)
      {
        v148 = (char *)__nw_create_backtrace_string();
        v144 = (os_log_s *)__nwlog_obj();
        v145 = type;
        v149 = os_log_type_enabled(v144, type);
        if (v148)
        {
          if (v149)
          {
            v150 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
            *(_DWORD *)buf = 136447234;
            *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1LL;
            v293 = 2048;
            v294 = v150;
            v295 = 2082;
            v296 = v148;
            _os_log_impl( &dword_181A5C000,  v144,  v145,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v148);
          goto LABEL_171;
        }

        if (v149)
        {
          v152 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1LL;
          v293 = 2048;
          v294 = v152;
          v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_170;
        }
      }

      else
      {
        v144 = (os_log_s *)__nwlog_obj();
        v145 = type;
        if (os_log_type_enabled(v144, type))
        {
          v151 = (_DWORD *)*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1LL;
          v293 = 2048;
          v294 = v151;
          v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_170;
        }
      }
    }

    goto LABEL_153;
  }

  if (!v7)
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null protocol", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (!v83)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl( &dword_181A5C000,  v29,  v75,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_152;
    }

    v44 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v45 = type;
    v46 = os_log_type_enabled(v29, type);
    if (!v44)
    {
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v45, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      v87 = 2082;
      v88 = v44;
      _os_log_impl( &dword_181A5C000,  v29,  v45,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_91;
  }

  if (!*(void *)(v7 + 16))
  {
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v34, "%{public}s called with null protocol->identifier", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (!v83)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v76 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl( &dword_181A5C000,  v29,  v76,  "%{public}s called with null protocol->identifier, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_152;
    }

    v44 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v47 = type;
    v48 = os_log_type_enabled(v29, type);
    if (!v44)
    {
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl( &dword_181A5C000,  v29,  v47,  "%{public}s called with null protocol->identifier, no backtrace",  buf,  0xCu);
      }

      goto LABEL_152;
    }

    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      v87 = 2082;
      v88 = v44;
      _os_log_impl( &dword_181A5C000,  v29,  v47,  "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_91;
  }

  if (!v9)
  {
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v36, "%{public}s called with null to_endpoint", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (!v83)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v77 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl( &dword_181A5C000,  v29,  v77,  "%{public}s called with null to_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_152;
    }

    v44 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v49 = type;
    v50 = os_log_type_enabled(v29, type);
    if (!v44)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v49, "%{public}s called with null to_endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      v87 = 2082;
      v88 = v44;
      _os_log_impl( &dword_181A5C000,  v29,  v49,  "%{public}s called with null to_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_91;
  }

  if (!v10)
  {
    __nwlog_obj();
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v38, "%{public}s called with null from_endpoint", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (!v83)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v78 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl( &dword_181A5C000,  v29,  v78,  "%{public}s called with null from_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_152;
    }

    v44 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v51 = type;
    v52 = os_log_type_enabled(v29, type);
    if (!v44)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v51, "%{public}s called with null from_endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      v87 = 2082;
      v88 = v44;
      _os_log_impl( &dword_181A5C000,  v29,  v51,  "%{public}s called with null from_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_91;
  }

  if (!v11)
  {
    __nwlog_obj();
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v40, "%{public}s called with null parameters", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (!v83)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v79 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl( &dword_181A5C000,  v29,  v79,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_152;
    }

    v44 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v57 = type;
    v58 = os_log_type_enabled(v29, type);
    if (!v44)
    {
      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        _os_log_impl(&dword_181A5C000, v29, v57, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_152;
    }

    if (v58)
    {
      *(_DWORD *)buf = 136446466;
      v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      v87 = 2082;
      v88 = v44;
      _os_log_impl( &dword_181A5C000,  v29,  v57,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (v53) {
      free(v53);
    }
    goto LABEL_39;
  }

  v21 = v19;
  v22 = (v21[231] & 4) == 0;

  v23 = v21;
  if (!v22) {
    goto LABEL_19;
  }
  v24 = v20;
  v25 = *(id *)(*((void *)v24 + 13) + 136LL);

  if (!v25)
  {
    __nwlog_obj();
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v65 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (__nwlog_fault(v65, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v67 = type;
        if (os_log_type_enabled(v66, type))
        {
          *(_DWORD *)buf = 136446210;
          v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl(&dword_181A5C000, v66, v67, "%{public}s called with null context", buf, 0xCu);
        }
      }

      else if (v98)
      {
        v84 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v85 = type;
        v86 = os_log_type_enabled(v66, type);
        if (v84)
        {
          if (v86)
          {
            *(_DWORD *)buf = 136446466;
            v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
            v102 = 2082;
            v103 = v84;
            _os_log_impl( &dword_181A5C000,  v66,  v85,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v84);
          goto LABEL_175;
        }

        if (v86)
        {
          *(_DWORD *)buf = 136446210;
          v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl(&dword_181A5C000, v66, v85, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v90 = type;
        if (os_log_type_enabled(v66, type))
        {
          *(_DWORD *)buf = 136446210;
          v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl( &dword_181A5C000,  v66,  v90,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(v28);
    goto LABEL_24;
  }

  __nwlog_obj();
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_protocol_implementation_get_local";
  v24 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v72 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v24, type, &v72))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_local";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v72)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v36 = type[0];
      v37 = os_log_type_enabled(v25, type[0]);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_protocol_implementation_get_local";
          v74 = 2082;
          v75 = v35;
          _os_log_impl( &dword_181A5C000,  v25,  v36,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v35);
        goto LABEL_114;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_local";
        _os_log_impl(&dword_181A5C000, v25, v36, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v52 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_local";
        _os_log_impl( &dword_181A5C000,  v25,  v52,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(v28);
    goto LABEL_24;
  }

  __nwlog_obj();
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_protocol_implementation_get_remote";
  v24 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v72 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v24, type, &v72))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_remote";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v72)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v36 = type[0];
      v37 = os_log_type_enabled(v25, type[0]);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_protocol_implementation_get_remote";
          v74 = 2082;
          v75 = v35;
          _os_log_impl( &dword_181A5C000,  v25,  v36,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v35);
        goto LABEL_114;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_remote";
        _os_log_impl(&dword_181A5C000, v25, v36, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v52 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_remote";
        _os_log_impl( &dword_181A5C000,  v25,  v52,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(v29);
    goto LABEL_24;
  }

  __nwlog_obj();
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_protocol_implementation_get_path";
  v25 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v73 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v25, type, &v73))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v27 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_path";
        _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v73)
    {
      v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v37 = type[0];
      v38 = os_log_type_enabled(v26, type[0]);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_protocol_implementation_get_path";
          v75 = 2082;
          v76 = v36;
          _os_log_impl( &dword_181A5C000,  v26,  v37,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v36);
        goto LABEL_114;
      }

      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_path";
        _os_log_impl(&dword_181A5C000, v26, v37, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v53 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_protocol_implementation_get_path";
        _os_log_impl( &dword_181A5C000,  v26,  v53,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

          if (*(_BYTE *)(a2 + *v8)) {
            v130 = 0LL;
          }
LABEL_154:
          *(_BYTE *)(a1 + 44) = v130 != 0;
          goto LABEL_5;
        case 7u:
          *(_BYTE *)(a1 + 48) |= 2u;
          v147 = *v3;
          v148 = *(void *)(a2 + v147);
          if (v148 == -1LL || v148 >= *(void *)(a2 + *v6))
          {
            v151 = 0LL;
LABEL_156:
            *(_BYTE *)(a2 + *v8) = 1;
            goto LABEL_157;
          }

          v149 = v148 + 1;
          v150 = *(_BYTE *)(*(void *)(a2 + *v10) + v148);
          *(void *)(a2 + v147) = v149;
          v151 = v150 & 0x7F;
          if ((v150 & 0x80) == 0) {
            goto LABEL_157;
          }
          v152 = *v3;
          v153 = *(void *)(a2 + v152);
          if (v153 == -1LL || v153 >= *(void *)(a2 + *v6)) {
            goto LABEL_156;
          }
          v154 = v153 + 1;
          v155 = *(char *)(*(void *)(a2 + *v10) + v153);
          *(void *)(a2 + v152) = v154;
          v151 |= (unint64_t)(v155 & 0x7F) << 7;
          if ((v155 & 0x80000000) == 0) {
            goto LABEL_157;
          }
          v156 = *v3;
          v157 = *(void *)(a2 + v156);
          if (v157 == -1LL || v157 >= *(void *)(a2 + *v6)) {
            goto LABEL_156;
          }
          v158 = v157 + 1;
          v159 = *(char *)(*(void *)(a2 + *v10) + v157);
          *(void *)(a2 + v156) = v158;
          v151 |= (unint64_t)(v159 & 0x7F) << 14;
          if ((v159 & 0x80000000) == 0) {
            goto LABEL_157;
          }
          v160 = *v3;
          v161 = *(void *)(a2 + v160);
          if (v161 == -1LL || v161 >= *(void *)(a2 + *v6)) {
            goto LABEL_156;
          }
          v162 = v161 + 1;
          v163 = *(char *)(*(void *)(a2 + *v10) + v161);
          *(void *)(a2 + v160) = v162;
          v151 |= (unint64_t)(v163 & 0x7F) << 21;
          if ((v163 & 0x80000000) == 0) {
            goto LABEL_157;
          }
          v164 = *v3;
          v165 = *(void *)(a2 + v164);
          if (v165 == -1LL || v165 >= *(void *)(a2 + *v6)) {
            goto LABEL_156;
          }
          v166 = v165 + 1;
          v167 = *(char *)(*(void *)(a2 + *v10) + v165);
          *(void *)(a2 + v164) = v166;
          v151 |= (unint64_t)(v167 & 0x7F) << 28;
          if ((v167 & 0x80000000) == 0) {
            goto LABEL_157;
          }
          v185 = *v3;
          v186 = *(void *)(a2 + v185);
          if (v186 == -1LL || v186 >= *(void *)(a2 + *v6)) {
            goto LABEL_156;
          }
          v187 = v186 + 1;
          v188 = *(char *)(*(void *)(a2 + *v10) + v186);
          *(void *)(a2 + v185) = v187;
          v151 |= (unint64_t)(v188 & 0x7F) << 35;
          if (v188 < 0)
          {
            v253 = *v3;
            v254 = *(void *)(a2 + v253);
            if (v254 == -1LL || v254 >= *(void *)(a2 + *v6)) {
              goto LABEL_156;
            }
            v255 = v254 + 1;
            v256 = *(char *)(*(void *)(a2 + *v10) + v254);
            *(void *)(a2 + v253) = v255;
            v151 |= (unint64_t)(v256 & 0x7F) << 42;
            if (v256 < 0)
            {
              v257 = *v3;
              v258 = *(void *)(a2 + v257);
              if (v258 == -1LL || v258 >= *(void *)(a2 + *v6)) {
                goto LABEL_156;
              }
              v259 = v258 + 1;
              v260 = *(char *)(*(void *)(a2 + *v10) + v258);
              *(void *)(a2 + v257) = v259;
              v151 |= (unint64_t)(v260 & 0x7F) << 49;
              if (v260 < 0)
              {
                v261 = *v3;
                v262 = *(void *)(a2 + v261);
                if (v262 == -1LL || v262 >= *(void *)(a2 + *v6)) {
                  goto LABEL_156;
                }
                v263 = v262 + 1;
                v264 = *(char *)(*(void *)(a2 + *v10) + v262);
                *(void *)(a2 + v261) = v263;
                v151 |= (unint64_t)(v264 & 0x7F) << 56;
                if (v264 < 0)
                {
                  v265 = *v3;
                  v266 = *(void *)(a2 + v265);
                  if (v266 == -1LL || v266 >= *(void *)(a2 + *v6)) {
                    goto LABEL_156;
                  }
                  v267 = v266 + 1;
                  v268 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v266);
                  *(void *)(a2 + v265) = v267;
                  if ((v268 & 0x80) != 0)
                  {
                    v151 = 0LL;
                    goto LABEL_159;
                  }

                  v151 |= v268 << 63;
                }
              }
            }
          }

      if (!v67) {
        goto LABEL_154;
      }
LABEL_153:
      free(v67);
      goto LABEL_154;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (id)gLogObj;
    v19 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)buf = 136446466;
    v97 = "nw_connection_inject_up_block_invoke";
    v98 = 1024;
    *(_DWORD *)v99 = v19;
    v20 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault((const char *)v20, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (os_log_s *)(id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          v23 = *(_DWORD *)(a1 + 80);
          *(_DWORD *)buf = 136446466;
          v97 = "nw_connection_inject_up_block_invoke";
          v98 = 1024;
          *(_DWORD *)v99 = v23;
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s Unhandled failure type: %d", buf, 0x12u);
        }
      }

      else if (v94)
      {
        v59 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (os_log_s *)(id)gLogObj;
        v60 = type;
        v61 = os_log_type_enabled(v21, type);
        if (v59)
        {
          if (v61)
          {
            v62 = *(_DWORD *)(a1 + 80);
            *(_DWORD *)buf = 136446722;
            v97 = "nw_connection_inject_up_block_invoke";
            v98 = 1024;
            *(_DWORD *)v99 = v62;
            *(_WORD *)&v99[4] = 2082;
            *(void *)&v99[6] = v59;
            _os_log_impl( &dword_181A5C000,  v21,  v60,  "%{public}s Unhandled failure type: %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v59);
          if (!v20) {
            return;
          }
LABEL_112:
          free(v20);
          return;
        }

        if (v61)
        {
          v75 = *(_DWORD *)(a1 + 80);
          *(_DWORD *)buf = 136446466;
          v97 = "nw_connection_inject_up_block_invoke";
          v98 = 1024;
          *(_DWORD *)v99 = v75;
          _os_log_impl(&dword_181A5C000, v21, v60, "%{public}s Unhandled failure type: %d, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (os_log_s *)(id)gLogObj;
        v65 = type;
        if (os_log_type_enabled(v21, type))
        {
          v66 = *(_DWORD *)(a1 + 80);
          *(_DWORD *)buf = 136446466;
          v97 = "nw_connection_inject_up_block_invoke";
          v98 = 1024;
          *(_DWORD *)v99 = v66;
          _os_log_impl( &dword_181A5C000,  v21,  v65,  "%{public}s Unhandled failure type: %d, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v20) {
      return;
    }
    goto LABEL_112;
  }

  v14 = *(void *)(a1 + 32);
  v15 = *(_BYTE *)(v14 + 109);
  v16 = *(void *)(v14 + 16);
  if ((v15 & 0x40) != 0)
  {
    if (v16 && !nw_path_parameters_get_logging_disabled(*(void *)(v16 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v57 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
      {
        v58 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)buf = 136446466;
        v97 = "nw_connection_inject_up_block_invoke";
        v98 = 1024;
        *(_DWORD *)v99 = v58;
        _os_log_impl(&dword_181A5C000, v57, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] injecting reset", buf, 0x12u);
      }
    }

    nw_endpoint_handler_inject_disconnect_error(*(void **)(*(void *)(a1 + 32) + 144LL), v3, 54LL);
  }

  else if (v16 && !nw_path_parameters_get_logging_disabled(*(void *)(v16 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v8 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v17 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      v97 = "nw_connection_inject_up_block_invoke";
      v98 = 1024;
      *(_DWORD *)v99 = v17;
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s [C%u] reset failed, not connected", buf, 0x12u);
    }

    goto LABEL_30;
  }

  if (v65) {
    free(v65);
  }
  v33 = 0LL;
LABEL_109:

  return v33;
}

      goto LABEL_153;
    }
  }

  else
  {
    v33 = 0LL;
    v32 = v8;
  }

  v54 = CFStringCreateArrayBySeparatingStrings(v4, v32, @".");
  if (!v54)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v69 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v86 = "nw_endpoint_proxy_string_matches_pattern";
    v70 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (!__nwlog_fault((const char *)v70, &type, &v83))
    {
LABEL_144:
      if (v70) {
        free(v70);
      }
      v55 = 0LL;
      goto LABEL_156;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v72 = type;
      if (os_log_type_enabled(v71, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_endpoint_proxy_string_matches_pattern";
        v73 = "%{public}s CFStringCreateArrayBySeparatingStrings failed";
LABEL_142:
        _os_log_impl(&dword_181A5C000, v71, v72, v73, buf, 0xCu);
      }
    }

    else
    {
      if (v83)
      {
        v76 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v72 = type;
        v77 = os_log_type_enabled(v71, type);
        if (v76)
        {
          if (v77)
          {
            *(_DWORD *)buf = 136446466;
            v86 = "nw_endpoint_proxy_string_matches_pattern";
            v87 = 2082;
            v88 = v76;
            _os_log_impl( &dword_181A5C000,  v71,  v72,  "%{public}s CFStringCreateArrayBySeparatingStrings failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v76);
          goto LABEL_144;
        }

        if (!v77) {
          goto LABEL_143;
        }
        *(_DWORD *)buf = 136446210;
        v86 = "nw_endpoint_proxy_string_matches_pattern";
        v73 = "%{public}s CFStringCreateArrayBySeparatingStrings failed, no backtrace";
        goto LABEL_142;
      }

      __nwlog_obj();
      v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v72 = type;
      if (os_log_type_enabled(v71, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_endpoint_proxy_string_matches_pattern";
        v73 = "%{public}s CFStringCreateArrayBySeparatingStrings failed, backtrace limit exceeded";
        goto LABEL_142;
      }
    }

    if (v24)
    {
      v65 = (char *)v24;
      goto LABEL_140;
    }

    return;
  }

  v18 = default_input_handler->callbacks;
  if (v18)
  {
    input_finished = (void (*)(void))v18->input_finished;
    if (input_finished) {
      goto LABEL_21;
    }
  }

  __nwlog_obj();
  v36 = a1->default_input_handler;
  v37 = "invalid";
  if (v36)
  {
    v38 = v36->identifier;
    if (v38) {
      v37 = (const char *)v38;
    }
  }

  *(_DWORD *)buf = 136446466;
  v82 = "nw_protocol_http_connect_input_finished";
  v83 = 2082;
  v84 = (void *)v37;
  v11 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v79 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v12 = (os_log_s *)__nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type)) {
      goto LABEL_138;
    }
    v39 = a1->default_input_handler;
    v15 = "invalid";
    if (v39)
    {
      v40 = v39->identifier;
      if (v40) {
        v15 = (const char *)v40;
      }
    }

    goto LABEL_18;
  }

  if (!v79)
  {
    v12 = (os_log_s *)__nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type)) {
      goto LABEL_138;
    }
    v57 = a1->default_input_handler;
    v58 = "invalid";
    if (v57)
    {
      v59 = v57->identifier;
      if (v59) {
        v58 = (const char *)v59;
      }
    }

    goto LABEL_104;
  }

  v47 = (char *)__nw_create_backtrace_string();
  v12 = (os_log_s *)__nwlog_obj();
  v13 = type;
  v48 = os_log_type_enabled(v12, type);
  if (!v47)
  {
    if (!v48) {
      goto LABEL_138;
    }
    v66 = a1->default_input_handler;
    v67 = "invalid";
    if (v66)
    {
      v68 = v66->identifier;
      if (v68) {
        v67 = (const char *)v68;
      }
    }

    goto LABEL_136;
  }

  if (v48)
  {
    v49 = a1->default_input_handler;
    v50 = "invalid";
    if (v49)
    {
      v51 = v49->identifier;
      if (v51) {
        v50 = (const char *)v51;
      }
    }

    *(_DWORD *)buf = 136446722;
    v82 = "nw_protocol_http_connect_input_finished";
    v83 = 2082;
    v84 = (void *)v50;
    v85 = 2082;
    v86 = v47;
    _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v47);
LABEL_138:
  if (v11)
  {
LABEL_139:
    v65 = (char *)v11;
    goto LABEL_140;
  }

      if (v72) {
        free(v72);
      }
      if (!v21) {
        return 4294966775LL;
      }
      v59 = (char *)v21;
      goto LABEL_109;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v40 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775LL;
    }
    v41 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)buf = 136446722;
    v93 = "on_begin_headers_callback";
    v94 = 2082;
    v95 = a3 + 205;
    v96 = 1024;
    *(_DWORD *)v97 = v41;
    v16 = "%{public}s %{public}s http2_transport has no listen handler when new stream (%d) is being opened, closing";
    v17 = (os_log_s *)v40;
    v18 = 28;
LABEL_20:
    _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
    return 4294966775LL;
  }

  v9 = stream_node_from_id;
  v10 = *(void *)(stream_node_from_id + 16);
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v33 = a3 + 205;
    v34 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)buf = 136446722;
    v93 = "on_begin_headers_callback";
    v94 = 2082;
    v95 = a3 + 205;
    v96 = 1024;
    *(_DWORD *)v97 = v34;
    v35 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = (os_log_s *)gLogObj;
      v37 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_107;
      }
      v38 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 136446722;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = v33;
      v96 = 1024;
      *(_DWORD *)v97 = v38;
      v39 = "%{public}s %{public}s could not get stream (%d) from node";
    }

    else if (v91)
    {
      v42 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = (os_log_s *)gLogObj;
      v37 = type[0];
      v43 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v42)
      {
        if (v43)
        {
          v44 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136446978;
          v93 = "on_begin_headers_callback";
          v94 = 2082;
          v95 = v33;
          v96 = 1024;
          *(_DWORD *)v97 = v44;
          *(_WORD *)&v97[4] = 2082;
          *(void *)&v97[6] = v42;
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s %{public}s could not get stream (%d) from node, dumping backtrace:%{public}s",  buf,  0x26u);
        }

        free(v42);
LABEL_107:
        if (v35)
        {
          v59 = (char *)v35;
LABEL_109:
          free(v59);
        }

        return 4294966775LL;
      }

      if (!v43) {
        goto LABEL_107;
      }
      v54 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 136446722;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = v33;
      v96 = 1024;
      *(_DWORD *)v97 = v54;
      v39 = "%{public}s %{public}s could not get stream (%d) from node, no backtrace";
    }

    else
    {
      v36 = (os_log_s *)__nwlog_obj();
      v37 = type[0];
      if (!os_log_type_enabled(v36, type[0])) {
        goto LABEL_107;
      }
      v48 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 136446722;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = v33;
      v96 = 1024;
      *(_DWORD *)v97 = v48;
      v39 = "%{public}s %{public}s could not get stream (%d) from node, backtrace limit exceeded";
    }

    v55 = v36;
    v56 = v37;
    v57 = 28;
LABEL_106:
    _os_log_impl(&dword_181A5C000, v55, v56, v39, buf, v57);
    goto LABEL_107;
  }

  if (gLogDatapath)
  {
    v78 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = a3 + 205;
      _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s calling connect for initial responder stream upon receipt of headers from remote client",  buf,  0x16u);
    }
  }

  v11 = *(void *)(v9 + 32);
  if (!v11)
  {
    __nwlog_obj();
    v52 = a3 + 205;
    *(_DWORD *)buf = 136446466;
    v93 = "on_begin_headers_callback";
    v94 = 2082;
    v95 = a3 + 205;
    v35 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v46 = (os_log_s *)__nwlog_obj();
      v47 = type[0];
      if (!os_log_type_enabled(v46, type[0])) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446466;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = v52;
      v39 = "%{public}s %{public}s no input handler yet attached to initial responder stream, closing stream 1";
      goto LABEL_105;
    }

    if (!v91)
    {
      v46 = (os_log_s *)__nwlog_obj();
      v47 = type[0];
      if (!os_log_type_enabled(v46, type[0])) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446466;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = v52;
      v39 = "%{public}s %{public}s no input handler yet attached to initial responder stream, closing stream 1, backtrace limit exceeded";
      goto LABEL_105;
    }

    v49 = (char *)__nw_create_backtrace_string();
    v46 = (os_log_s *)__nwlog_obj();
    v47 = type[0];
    v58 = os_log_type_enabled(v46, type[0]);
    if (!v49)
    {
      if (!v58) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446466;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = v52;
      v39 = "%{public}s %{public}s no input handler yet attached to initial responder stream, closing stream 1, no backtrace";
      goto LABEL_105;
    }

    if (v58)
    {
      *(_DWORD *)buf = 136446722;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = v52;
      v96 = 2082;
      *(void *)v97 = v49;
      v51 = "%{public}s %{public}s no input handler yet attached to initial responder stream, closing stream 1, dumping b"
            "acktrace:%{public}s";
      goto LABEL_95;
    }

    goto LABEL_96;
  }

  if (!nw_http2_transport_stream_connect(a3, v10, v11))
  {
    v12 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = *(_DWORD *)(v10 + 32);
      *(_DWORD *)buf = 136446978;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = a3 + 205;
      v96 = 1024;
      *(_DWORD *)v97 = v13;
      *(_WORD *)&v97[4] = 2048;
      *(void *)&v97[6] = v10;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s nw_http2_transport_stream_connect failed for stream id %d (%p)",  buf,  0x26u);
    }
  }

  if (!gLogDatapath) {
    return 0LL;
  }
  v79 = (os_log_s *)__nwlog_obj();
  result = os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    *(_DWORD *)buf = 136446466;
    v93 = "on_begin_headers_callback";
    v94 = 2082;
    v95 = a3 + 205;
    _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s connected initial responder stream",  buf,  0x16u);
    return 0LL;
  }

  return result;
}

      if (v48) {
        free(v48);
      }
      return (nw_browse_descriptor_t)custom;
    }

    v57 = v5[v25];
    if (!v57)
    {
LABEL_162:
      if (custom)
      {
        v75 = *(_DWORD *)&v5[v46];
        nw_browse_descriptor_set_device_types(custom, v20);
        nw_browse_descriptor_set_browse_scope(custom, v19);
        nw_browse_descriptor_set_discover_application_service_endpoints_only(custom, v44 != 0);
        nw_browse_descriptor_set_invitation_scope(custom, v75);
      }

      return (nw_browse_descriptor_t)custom;
    }

    if (application_service_with_bundle_id)
    {
      while (1)
      {
        v58 = (uint64_t)&v5[v46];
        v46 += strnlen(&v5[v46], v6 - v46);
        if (v46 >= v6) {
          break;
        }
        nw_browse_descriptor_add_device_filter(custom, v58);
        ++v46;
        if (!--v57) {
          goto LABEL_162;
        }
      }
    }

    else
    {
      while (1)
      {
        v46 += strnlen(&v5[v46], v6 - v46);
        if (v46 >= v6) {
          break;
        }
        ++v46;
        if (!--v57) {
          goto LABEL_162;
        }
      }
    }

    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v81 = "nw_path_copy_browse_descriptor_from_tlv";
    v82 = 1024;
    v83 = 202;
    v84 = 1024;
    v85 = a1;
    v86 = 2080;
    v87 = "nw_path_copy_browse_descriptor_from_tlv";
    v88 = 1024;
    v89 = 1958;
    v60 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (__nwlog_fault(v60, &type, &v78))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v62 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1958;
          _os_log_impl( &dword_181A5C000,  v61,  v62,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
        }
      }

      else if (v78)
      {
        v72 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v77 = type;
        v73 = os_log_type_enabled(v61, type);
        if (v72)
        {
          if (v73)
          {
            *(_DWORD *)buf = 136447490;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1958;
            v90 = 2082;
            v91 = v72;
            _os_log_impl( &dword_181A5C000,  v61,  v77,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
          }

          free(v72);
          goto LABEL_160;
        }

        if (v73)
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1958;
          _os_log_impl( &dword_181A5C000,  v61,  v77,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
        }
      }

      else
      {
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1958;
          _os_log_impl( &dword_181A5C000,  v61,  v74,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
        }
      }
    }

    _os_log_impl(&dword_181A5C000, v50, v51, v52, buf, 0xCu);
    goto LABEL_153;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    v4 = handle + 1373;
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v53 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          v54 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          v115 = "nw_protocol_http3_disconnected";
          v116 = 2082;
          v117 = handle + 1289;
          v118 = 2080;
          v119 = " ";
          v120 = 1024;
          v121 = v54;
          _os_log_impl(&dword_181A5C000, v53, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }

    v5 = (unsigned __int16)*v4;
    if ((v5 & 0x200) == 0)
    {
      if ((*v4 & 8) == 0) {
        nw_http3_fail_all_streams((uint64_t)handle, 260LL);
      }
      return;
    }

    v6 = v5 & 0xFFFFFDFF | (handle[1375] << 16);
    *v4 = v5 & 0xFDFF;
    handle[1375] = BYTE2(v6);
    output_handler = a1->output_handler;
    v8 = *((void *)handle + 4);
    if (v8)
    {
      v9 = *(void *)(v8 + 24);
      if (v9)
      {
        v10 = *(void (**)(void))(v9 + 8);
        if (v10)
        {
          v10();
          goto LABEL_12;
        }
      }
    }

    __nwlog_obj();
    v39 = *((void *)handle + 4);
    v40 = "invalid";
    if (v39)
    {
      v41 = *(const char **)(v39 + 16);
      if (v41) {
        v40 = v41;
      }
    }

    *(_DWORD *)buf = 136446466;
    v115 = "nw_http3_reset";
    v116 = 2082;
    v117 = (char *)v40;
    v42 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v112 = 0;
    if (__nwlog_fault(v42, &type, &v112))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v43 = (os_log_s *)__nwlog_obj();
        v44 = type;
        if (!os_log_type_enabled(v43, type)) {
          goto LABEL_136;
        }
        v45 = *((void *)handle + 4);
        v46 = "invalid";
        if (v45)
        {
          v47 = *(const char **)(v45 + 16);
          if (v47) {
            v46 = v47;
          }
        }

        *(_DWORD *)buf = 136446466;
        v115 = "nw_http3_reset";
        v116 = 2082;
        v117 = (char *)v46;
        v48 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
        goto LABEL_135;
      }

      if (!v112)
      {
        v43 = (os_log_s *)__nwlog_obj();
        v44 = type;
        if (!os_log_type_enabled(v43, type)) {
          goto LABEL_136;
        }
        v94 = *((void *)handle + 4);
        v95 = "invalid";
        if (v94)
        {
          v96 = *(const char **)(v94 + 16);
          if (v96) {
            v95 = v96;
          }
        }

        *(_DWORD *)buf = 136446466;
        v115 = "nw_http3_reset";
        v116 = 2082;
        v117 = (char *)v95;
        v48 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_135;
      }

      v75 = (char *)__nw_create_backtrace_string();
      v43 = (os_log_s *)__nwlog_obj();
      v44 = type;
      v76 = os_log_type_enabled(v43, type);
      if (v75)
      {
        if (v76)
        {
          v77 = *((void *)handle + 4);
          v78 = "invalid";
          if (v77)
          {
            v79 = *(const char **)(v77 + 16);
            if (v79) {
              v78 = v79;
            }
          }

          *(_DWORD *)buf = 136446722;
          v115 = "nw_http3_reset";
          v116 = 2082;
          v117 = (char *)v78;
          v118 = 2082;
          v119 = v75;
          _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v75);
        goto LABEL_136;
      }

      if (v76)
      {
        v97 = *((void *)handle + 4);
        v98 = "invalid";
        if (v97)
        {
          v99 = *(const char **)(v97 + 16);
          if (v99) {
            v98 = v99;
          }
        }

        *(_DWORD *)buf = 136446466;
        v115 = "nw_http3_reset";
        v116 = 2082;
        v117 = (char *)v98;
        v48 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_135:
        _os_log_impl(&dword_181A5C000, v43, v44, v48, buf, 0x16u);
      }
    }

      free(backtrace_string);
      goto LABEL_201;
    }

    if (!v87) {
      goto LABEL_201;
    }
    *(_DWORD *)buf = 136446210;
    v153 = "nw_http2_drain_next_frame_for_stream";
    v57 = "%{public}s called with null frame, no backtrace";
LABEL_200:
    _os_log_impl(&dword_181A5C000, v55, v56, v57, buf, 0xCu);
LABEL_201:
    if (v54) {
      free(v54);
    }
    return 0LL;
  }

  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v64 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v65 = *(_DWORD *)(a3 + 176);
      v66 = *(_DWORD *)(a3 + 180);
      v67 = *(_DWORD *)(v11 + 52);
      if (v67) {
        v67 -= *(_DWORD *)(v11 + 56) + *(_DWORD *)(v11 + 60);
      }
      *(_DWORD *)buf = 136447490;
      v153 = "nw_http2_drain_next_frame_for_stream";
      v154 = 2082;
      v155 = a3 + 191;
      v156 = 2080;
      *(void *)v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v66;
      v158 = 1024;
      v159 = v65;
      v160 = 1024;
      *(_DWORD *)v161 = v67;
      _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> draining output frame of %u bytes",  buf,  0x32u);
    }
  }

  v12 = *(void *)(v11 + 16);
  v13 = *(void **)(v11 + 24);
  v14 = (void *)(v11 + 16);
  if (v12)
  {
    *(void *)(v12 + 24) = v13;
    v13 = *(void **)(v11 + 24);
  }

  else
  {
    *(void *)(a3 + 24) = v13;
  }

  *v13 = v12;
  *v14 = 0LL;
  *(void *)(v11 + 24) = 0LL;
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_25_81808);
  }
  v16 = *(_DWORD *)(v11 + 52);
  v146 = a2;
  if (!v16 || v16 == *(_DWORD *)(v11 + 56) + *(_DWORD *)(v11 + 60))
  {
    v17 = *(void *)(v11 + 64);
    if (!v17 || (*(_BYTE *)(v17 + 66) & 0x40) == 0)
    {
      if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v88 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v89 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          v153 = "nw_http2_submit_data";
          v154 = 2082;
          v155 = a1 + 390;
          v156 = 2080;
          *(void *)v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v89;
          _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> skipping empty frame body",  buf,  0x26u);
        }
      }

      nw_frame_cache_return_frame(a1 + 200, v11);
      v15 = 1LL;
      goto LABEL_248;
    }
  }

  if ((*(_WORD *)(v11 + 204) & 4) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v153 = "nw_http2_submit_data";
    v79 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      v80 = (os_log_s *)__nwlog_obj();
      v81 = v149[0];
      if (!os_log_type_enabled(v80, v149[0])) {
        goto LABEL_226;
      }
      *(_DWORD *)buf = 136446210;
      v153 = "nw_http2_submit_data";
      v82 = "%{public}s called with null output_context";
LABEL_225:
      _os_log_impl(&dword_181A5C000, v80, v81, v82, buf, 0xCu);
      goto LABEL_226;
    }

    v90 = a4;
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v80 = (os_log_s *)__nwlog_obj();
      v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        v153 = "nw_http2_submit_data";
        v82 = "%{public}s called with null output_context, backtrace limit exceeded";
        goto LABEL_225;
      }

      goto LABEL_226;
    }

    v91 = (char *)__nw_create_backtrace_string();
    v80 = (os_log_s *)__nwlog_obj();
    v81 = v149[0];
    v92 = os_log_type_enabled(v80, v149[0]);
    if (!v91)
    {
      a4 = v90;
      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        v153 = "nw_http2_submit_data";
        v82 = "%{public}s called with null output_context, no backtrace";
        goto LABEL_225;
      }

      goto LABEL_226;
    }

    if (!v92) {
      goto LABEL_174;
    }
    *(_DWORD *)buf = 136446466;
    v153 = "nw_http2_submit_data";
    v154 = 2082;
    v155 = (uint64_t)v91;
    v93 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
LABEL_173:
    _os_log_impl(&dword_181A5C000, v80, v81, v93, buf, 0x16u);
    goto LABEL_174;
  }

  v18 = *(void *)(v11 + 216);
  if (!v18)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v153 = "nw_http2_submit_data";
    v79 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      v80 = (os_log_s *)__nwlog_obj();
      v81 = v149[0];
      if (!os_log_type_enabled(v80, v149[0])) {
        goto LABEL_226;
      }
      *(_DWORD *)buf = 136446210;
      v153 = "nw_http2_submit_data";
      v82 = "%{public}s called with null input_protocol";
      goto LABEL_225;
    }

    v90 = a4;
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v80 = (os_log_s *)__nwlog_obj();
      v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        v153 = "nw_http2_submit_data";
        v82 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_225;
      }

      goto LABEL_226;
    }

    v91 = (char *)__nw_create_backtrace_string();
    v80 = (os_log_s *)__nwlog_obj();
    v81 = v149[0];
    v94 = os_log_type_enabled(v80, v149[0]);
    if (!v91)
    {
      a4 = v90;
      if (v94)
      {
        *(_DWORD *)buf = 136446210;
        v153 = "nw_http2_submit_data";
        v82 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_225;
      }

      goto LABEL_226;
    }

    if (!v94) {
      goto LABEL_174;
    }
    *(_DWORD *)buf = 136446466;
    v153 = "nw_http2_submit_data";
    v154 = 2082;
    v155 = (uint64_t)v91;
    v93 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_173;
  }

  v19 = *(void *)(v18 + 56);
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v153 = "nw_http2_submit_data";
    v79 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      v80 = (os_log_s *)__nwlog_obj();
      v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        v153 = "nw_http2_submit_data";
        v82 = "%{public}s called with null node";
        goto LABEL_225;
      }

LABEL_278:
LABEL_279:
    if (!v102) {
      goto LABEL_281;
    }
    goto LABEL_280;
  }

  v107 = (char *)v106;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v108 = (os_log_s *)(id)gLogObj;
  v109 = v162;
  if (os_log_type_enabled(v108, (os_log_type_t)v162))
  {
    *(_DWORD *)buf = 136447234;
    *(void *)&buf[4] = "nw_path_parse_necp_result";
    v164 = 1024;
    *(_DWORD *)v165 = v20;
    *(_WORD *)&v165[4] = 2048;
    *(void *)&v165[6] = v15;
    *(_WORD *)&v165[14] = 2048;
    *(void *)&v165[16] = a3;
    *(_WORD *)&v165[24] = 2082;
    *(void *)&v165[26] = v107;
    _os_log_impl( &dword_181A5C000,  v108,  v109,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), dumping backtrace:%{public}s",  buf,  0x30u);
  }

  free(v107);
  if (v102) {
LABEL_280:
  }
    free(v102);
LABEL_281:
  v14 = v100;
LABEL_282:
  if (v15 != a3)
  {
    v140 = v14;
    __nwlog_obj();
    v141 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    *(void *)&buf[4] = "nw_path_parse_necp_result";
    v164 = 2048;
    *(void *)v165 = v15;
    *(_WORD *)&v165[8] = 2048;
    *(void *)&v165[10] = a3;
    v142 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v162) = 16;
    v161 = 0;
    if (__nwlog_fault(v142, &v162, &v161))
    {
      if (v162 == 17)
      {
        __nwlog_obj();
        v143 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v144 = v162;
        if (os_log_type_enabled(v143, (os_log_type_t)v162))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_path_parse_necp_result";
          v164 = 2048;
          *(void *)v165 = v15;
          *(_WORD *)&v165[8] = 2048;
          *(void *)&v165[10] = a3;
          _os_log_impl(&dword_181A5C000, v143, v144, "%{public}s cursor has unexpected value %zu != %zu", buf, 0x20u);
        }
      }

      else
      {
        if (v161)
        {
          v145 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v146 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v147 = v162;
          v148 = os_log_type_enabled(v146, (os_log_type_t)v162);
          if (v145)
          {
            if (v148)
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_parse_necp_result";
              v164 = 2048;
              *(void *)v165 = v15;
              *(_WORD *)&v165[8] = 2048;
              *(void *)&v165[10] = a3;
              *(_WORD *)&v165[18] = 2082;
              *(void *)&v165[20] = v145;
              _os_log_impl( &dword_181A5C000,  v146,  v147,  "%{public}s cursor has unexpected value %zu != %zu, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v145);
          }

          else
          {
            if (v148)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&buf[4] = "nw_path_parse_necp_result";
              v164 = 2048;
              *(void *)v165 = v15;
              *(_WORD *)&v165[8] = 2048;
              *(void *)&v165[10] = a3;
              _os_log_impl( &dword_181A5C000,  v146,  v147,  "%{public}s cursor has unexpected value %zu != %zu, no backtrace",  buf,  0x20u);
            }
          }

          goto LABEL_372;
        }

        __nwlog_obj();
        v143 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v152 = v162;
        if (os_log_type_enabled(v143, (os_log_type_t)v162))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_path_parse_necp_result";
          v164 = 2048;
          *(void *)v165 = v15;
          *(_WORD *)&v165[8] = 2048;
          *(void *)&v165[10] = a3;
          _os_log_impl( &dword_181A5C000,  v143,  v152,  "%{public}s cursor has unexpected value %zu != %zu, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

      v89 = v93;
      v90 = v94;
      v91 = 12;
      goto LABEL_224;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    *(void *)&buf[4] = "nw_http_connect_prepare_response_message";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v172 = " ";
    v34 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (__nwlog_fault(v34, type, v174))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v35 = (os_log_s *)__nwlog_obj();
        v36 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v172 = " ";
          v37 = "%{public}s %{public}s%sAlready have response message, cannot create new one";
LABEL_126:
          _os_log_impl(&dword_181A5C000, v35, v36, v37, buf, 0x20u);
        }
      }

      else if (v174[0])
      {
        v46 = (char *)__nw_create_backtrace_string();
        v35 = (os_log_s *)__nwlog_obj();
        v36 = type[0];
        v47 = os_log_type_enabled(v35, type[0]);
        if (v46)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&buf[4] = "nw_http_connect_prepare_response_message";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v172 = " ";
            LOWORD(v173) = 2082;
            *(void *)((char *)&v173 + 2) = v46;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s %{public}s%sAlready have response message, cannot create new one, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v46);
          v32 = &qword_18C45F000;
          goto LABEL_127;
        }

        v32 = &qword_18C45F000;
        if (v47)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v172 = " ";
          v37 = "%{public}s %{public}s%sAlready have response message, cannot create new one, no backtrace";
          goto LABEL_126;
        }
      }

      else
      {
        v35 = (os_log_s *)__nwlog_obj();
        v36 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v172 = " ";
          v37 = "%{public}s %{public}s%sAlready have response message, cannot create new one, backtrace limit exceeded";
          goto LABEL_126;
        }
      }
    }

  nw_frame_claim(a2, v5, v8, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v133, v8, 0);
  v135 = *(void *)(a2 + 32);
  v136 = *(void **)(a2 + 40);
  v134 = (void *)(a2 + 32);
  if (v135)
  {
    *(void *)(v135 + 40) = v136;
    v136 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 184) + 8LL) = v136;
  }

  *v136 = v135;
  *v134 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  v137 = *(void *)(a1 + 192);
  v138 = *(uint64_t **)(v137 + 8);
  *(void *)(a2 + 40) = v138;
  *v138 = a2;
  *(void *)(v137 + 8) = v134;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL);
  v139 = *(void *)(a1 + 104);
  if (!v139)
  {
    if (!gLogDatapath) {
      return 1LL;
    }
LABEL_351:
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v165 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v166 = *(void *)(a1 + 104);
      v167 = "";
      v168 = v166 == 0;
      v169 = *(_DWORD *)(v166 + 368);
      v170 = (const char *)(v166 + 390);
      v256 = "send_data_callback_block_invoke";
      v257 = 2082;
      if (v168) {
        v170 = "";
      }
      *(_DWORD *)buf = 136447234;
      if (!v168) {
        v167 = " ";
      }
      v258 = v170;
      v259 = 2080;
      v260 = (size_t)v167;
      v261 = 1024;
      *(_DWORD *)v262 = v169;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v8;
      _os_log_impl( &dword_181A5C000,  v165,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> copied %u bytes into output frame",  buf,  0x2Cu);
    }

    return 1LL;
  }

  result = 1LL;
  return result;
}

LABEL_372:
    if (v142) {
      free(v142);
    }
    v14 = v140;
  }

  v114 = v160;
  routed_interface_index = v160->policy_result.routed_interface_index;
  if (routed_interface_index)
  {
    direct_interface_index = v160->policy_result.direct_interface_index;
    if (direct_interface_index)
    {
      if (routed_interface_index != direct_interface_index)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v117 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
        {
          v118 = v160->policy_result.routed_interface_index;
          v119 = v160->policy_result.direct_interface_index;
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "nw_path_parse_necp_result";
          v164 = 1024;
          *(_DWORD *)v165 = v118;
          *(_WORD *)&v165[4] = 1024;
          *(_DWORD *)&v165[6] = v119;
          _os_log_impl( &dword_181A5C000,  v117,  OS_LOG_TYPE_ERROR,  "%{public}s Mismatch in interface results from NECP (%u != %u)",  buf,  0x18u);
        }

        v114 = v160;
        v160->policy_result.routed_interface_index = v160->policy_result.direct_interface_index;
      }
    }
  }

  netagents = v114->policy_result.netagents;
  if (netagents)
  {
    free(netagents);
    v114->policy_result.netagents = 0LL;
  }

  v114->policy_result.num_netagents = HIDWORD(v158);
  if (HIDWORD(v158))
  {
    v114->policy_result.netagents = v14;
  }

  else if (v14)
  {
    free(v14);
  }

  interface_options = v114->policy_result.interface_options;
  if (interface_options)
  {
    free(interface_options);
    v114->policy_result.interface_options = 0LL;
  }

  v114->policy_result.num_interface_options = v158;
  if ((_DWORD)v158)
  {
    v114->policy_result.interface_options = __ptr;
  }

  else if (__ptr)
  {
    free(__ptr);
  }

  v111 = 1LL;
LABEL_302:

  return v111;
}

      if (!v177)
      {
LABEL_374:
        v29 = 0LL;
        v28 = (unint64_t)&v8[v7];
LABEL_38:
        v237[3] = v29;
        v30 = *(void **)(v5 + 104);
        if (!v30) {
          goto LABEL_155;
        }
        goto LABEL_39;
      }

void sub_181AD5E04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, void *a25)
{
}

nw_endpoint_t nw_path_copy_endpoint_from_tlv(int a1, size_t __n, void *__src)
{
  unsigned int v3 = __n;
  uint64_t v127 = *MEMORY[0x1895F89C0];
  memset(__dst, 0, sizeof(__dst));
  if ((__n - 257) <= 0xFFFFFF06)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v115 = "nw_path_copy_endpoint_from_tlv";
    __int16 v116 = 1024;
    int v117 = a1;
    __int16 v118 = 1024;
    unsigned int v119 = v3;
    __int16 v120 = 2080;
    v121 = "nw_path_copy_endpoint_from_tlv";
    __int16 v122 = 1024;
    int v123 = 1693;
    v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        __int16 v116 = 1024;
        int v117 = a1;
        __int16 v118 = 1024;
        unsigned int v119 = v3;
        __int16 v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        __int16 v122 = 1024;
        int v123 = 1693;
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }

LABEL_185:
          goto LABEL_239;
        }

        size_t v53 = v52;
        host_with_numeric_port = (id *)nw_endpoint_create_srv(&__dst[0].sa_data[6]);
        if (host_with_numeric_port)
        {
          size_t v25 = v53 + 1;
          size_t v26 = v12 - (v53 + 1);
          if (v12 > v53 + 1)
          {
LABEL_80:
            nw_txt_record_t v17 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[0].sa_data[v25 + 6], v26);
            nw_endpoint_set_txt_record(host_with_numeric_port, v17);
            goto LABEL_21;
          }
        }

        return (nw_endpoint_t)host_with_numeric_port;
      case 6:
        uuid_clear((unsigned __int8 *)type);
        size_t v37 = strnlen(&__dst[0].sa_data[6], v12);
        if (v37 >= v12)
        {
          __nwlog_obj();
          v62 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1771;
          v6 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t v112 = OS_LOG_TYPE_ERROR;
          char v111 = 0;
          if (v112 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v64 = v112;
            if (os_log_type_enabled(v63, v112))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1771;
              _os_log_impl( &dword_181A5C000,  v63,  v64,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_258;
          }

          if (!v111)
          {
            __nwlog_obj();
            v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v92 = v112;
            if (os_log_type_enabled(v63, v112))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1771;
              _os_log_impl( &dword_181A5C000,  v63,  v92,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }

            goto LABEL_258;
          }

          v69 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v78 = v112;
          BOOL v79 = os_log_type_enabled(v63, v112);
          if (!v69)
          {
            if (v79)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1771;
              _os_log_impl( &dword_181A5C000,  v63,  v78,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }

            goto LABEL_258;
          }

          if (v79)
          {
            *(_DWORD *)buf = 136447490;
            v115 = "nw_path_copy_endpoint_from_tlv";
            __int16 v116 = 1024;
            int v117 = a1;
            __int16 v118 = 1024;
            unsigned int v119 = v3;
            __int16 v120 = 2080;
            v121 = "nw_path_copy_endpoint_from_tlv";
            __int16 v122 = 1024;
            int v123 = 1771;
            __int16 v124 = 2082;
            v125 = v69;
            _os_log_impl( &dword_181A5C000,  v63,  v78,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
          }
        }

        else
        {
          v38 = &__dst[0].sa_data[v37 + 7];
          size_t v39 = strnlen(v38, v12 - (v37 + 1)) + v37 + 1;
          if (v39 >= v12)
          {
            __nwlog_obj();
            v67 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136447234;
            v115 = "nw_path_copy_endpoint_from_tlv";
            __int16 v116 = 1024;
            int v117 = a1;
            __int16 v118 = 1024;
            unsigned int v119 = v3;
            __int16 v120 = 2080;
            v121 = "nw_path_copy_endpoint_from_tlv";
            __int16 v122 = 1024;
            int v123 = 1778;
            v6 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v112 = OS_LOG_TYPE_ERROR;
            char v111 = 0;
            if (v112 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v68 = v112;
              if (os_log_type_enabled(v63, v112))
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1778;
                _os_log_impl( &dword_181A5C000,  v63,  v68,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
              }

              goto LABEL_258;
            }

            if (!v111)
            {
              __nwlog_obj();
              v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v100 = v112;
              if (os_log_type_enabled(v63, v112))
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1778;
                _os_log_impl( &dword_181A5C000,  v63,  v100,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
              }

              goto LABEL_258;
            }

            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v86 = v112;
            BOOL v87 = os_log_type_enabled(v63, v112);
            if (!v69)
            {
              if (v87)
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1778;
                _os_log_impl( &dword_181A5C000,  v63,  v86,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
              }

              goto LABEL_258;
            }

            if (v87)
            {
              *(_DWORD *)buf = 136447490;
              v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1778;
              __int16 v124 = 2082;
              v125 = v69;
              _os_log_impl( &dword_181A5C000,  v63,  v86,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
            }
          }

          else
          {
            v40 = &__dst[0].sa_data[v39 + 7];
            size_t v41 = strnlen(v40, v12 - (v39 + 1)) + v39 + 1;
            if (v41 >= v12)
            {
              __nwlog_obj();
              v82 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1785;
              v6 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v112 = OS_LOG_TYPE_ERROR;
              char v111 = 0;
              if (v112 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v83 = v112;
                if (os_log_type_enabled(v63, v112))
                {
                  *(_DWORD *)buf = 136447234;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1785;
                  _os_log_impl( &dword_181A5C000,  v63,  v83,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
                }

                goto LABEL_258;
              }

              if (!v111)
              {
                __nwlog_obj();
                v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v106 = v112;
                if (os_log_type_enabled(v63, v112))
                {
                  *(_DWORD *)buf = 136447234;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1785;
                  _os_log_impl( &dword_181A5C000,  v63,  v106,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
                }

                goto LABEL_258;
              }

              v69 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v97 = v112;
              BOOL v98 = os_log_type_enabled(v63, v112);
              if (!v69)
              {
                if (v98)
                {
                  *(_DWORD *)buf = 136447234;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1785;
                  _os_log_impl( &dword_181A5C000,  v63,  v97,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
                }

                goto LABEL_258;
              }

              if (v98)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1785;
                __int16 v124 = 2082;
                v125 = v69;
                _os_log_impl( &dword_181A5C000,  v63,  v97,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
              }
            }

            else
            {
              v42 = &__dst[0].sa_data[v41 + 7];
              size_t v43 = strnlen(v42, v12 - (v41 + 1)) + v41 + 1;
              if (v43 >= v12)
              {
                __nwlog_obj();
                v93 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1792;
                v6 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v112 = OS_LOG_TYPE_ERROR;
                char v111 = 0;
                if (v112 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v94 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1792;
                    _os_log_impl( &dword_181A5C000,  v63,  v94,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
                  }

                  goto LABEL_258;
                }

                if (!v111)
                {
                  __nwlog_obj();
                  v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v109 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1792;
                    _os_log_impl( &dword_181A5C000,  v63,  v109,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
                  }

                  goto LABEL_258;
                }

                v69 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v103 = v112;
                BOOL v104 = os_log_type_enabled(v63, v112);
                if (!v69)
                {
                  if (v104)
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1792;
                    _os_log_impl( &dword_181A5C000,  v63,  v103,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
                  }

                  goto LABEL_258;
                }

                if (v104)
                {
                  *(_DWORD *)buf = 136447490;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1792;
                  __int16 v124 = 2082;
                  v125 = v69;
                  _os_log_impl( &dword_181A5C000,  v63,  v103,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
                }
              }

              else
              {
                v44 = &__dst[0].sa_data[v43 + 7];
                size_t v45 = strnlen(v44, v12 - (v43 + 1)) + v43 + 1;
                if (v45 < v12)
                {
                  int v46 = *(_DWORD *)&__dst[0].sa_data[v45 + 7];
                  int v47 = *(_DWORD *)&__dst[0].sa_data[v45 + 11];
                  size_t v48 = v45 + 9;
                  size_t v49 = v45 + 25;
                  if (v49 <= v12)
                  {
                    *(sockaddr *)type = *(sockaddr *)&__dst[0].sa_data[v48 + 6];
                    size_t v48 = v49;
                  }

                  host_with_numeric_port = (id *)nw_endpoint_create_application_service_internal( v38,  &__dst[0].sa_data[6],  (const unsigned __int8 *)type,  v40,  v42,  v46,  v47,  v44);
                  if (host_with_numeric_port) {
                    BOOL v50 = v48 + 1 >= v12;
                  }
                  else {
                    BOOL v50 = 1;
                  }
                  if (!v50)
                  {
                    nw_txt_record_t v51 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[0].sa_data[v48 + 6], v12 - v48);
                    nw_endpoint_set_txt_record(host_with_numeric_port, v51);
                  }

                  return (nw_endpoint_t)host_with_numeric_port;
                }

                __nwlog_obj();
                v101 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1799;
                v6 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v112 = OS_LOG_TYPE_ERROR;
                char v111 = 0;
                if (v112 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v102 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1799;
                    _os_log_impl( &dword_181A5C000,  v63,  v102,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
                  }

    if (v63) {
      free(v63);
    }
    goto LABEL_15;
  }

  __nwlog_obj();
  *(_DWORD *)__int16 v122 = 136446210;
  *(void *)&v122[4] = "operator()";
  os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v99) = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v60 = (os_log_s *)__nwlog_obj();
    os_log_type_t v61 = type[0];
    if (!os_log_type_enabled(v60, type[0])) {
      goto LABEL_180;
    }
    *(_DWORD *)__int16 v122 = 136446210;
    *(void *)&v122[4] = "operator()";
    v62 = "%{public}s called with null completion";
    goto LABEL_179;
  }

  if (!(_BYTE)v99)
  {
    v60 = (os_log_s *)__nwlog_obj();
    os_log_type_t v61 = type[0];
    if (!os_log_type_enabled(v60, type[0])) {
      goto LABEL_180;
    }
    *(_DWORD *)__int16 v122 = 136446210;
    *(void *)&v122[4] = "operator()";
    v62 = "%{public}s called with null completion, backtrace limit exceeded";
    goto LABEL_179;
  }

  v69 = (char *)__nw_create_backtrace_string();
  v60 = (os_log_s *)__nwlog_obj();
  os_log_type_t v61 = type[0];
  os_log_type_t v74 = os_log_type_enabled(v60, type[0]);
  if (!v69)
  {
    if (!v74) {
      goto LABEL_180;
    }
    *(_DWORD *)__int16 v122 = 136446210;
    *(void *)&v122[4] = "operator()";
    v62 = "%{public}s called with null completion, no backtrace";
    goto LABEL_179;
  }

  if (v74)
  {
    *(_DWORD *)__int16 v122 = 136446466;
    *(void *)&v122[4] = "operator()";
    *(_WORD *)&v122[12] = 2082;
    *(void *)&v122[14] = v69;
    BOOL v71 = "%{public}s called with null completion, dumping backtrace:%{public}s";
    goto LABEL_133;
  }

              goto LABEL_189;
            }

            *((_BYTE *)v14 + 108) = v85 & 0x7F;
            os_log_type_t v84 = *((_BYTE *)v14 + 109) | 2;
          }

          else
          {
            if (v20 != v10)
            {
              os_log_type_t v78 = (char *)v14 + 109;
              BOOL v79 = *((_BYTE *)v14 + 109);
              v80 = 1;
              goto LABEL_62;
            }

            *((_BYTE *)v14 + 108) |= 0x80u;
            os_log_type_t v84 = *((_BYTE *)v14 + 109) & 0xFD;
          }

          *((_BYTE *)v14 + 109) = v84;
          goto LABEL_71;
        }

    free(v93);
    if (!v67) {
      goto LABEL_1060;
    }
    goto LABEL_1059;
  }

  v4 = (uint64_t *)(v6 + 248);
LABEL_10:
  v7 = *v4;
  if (!*v4) {
    goto LABEL_1060;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnect";
    BOOL v71 = (char *)_os_log_send_and_compose_impl();
    v963[0] = 16;
    LOBYTE(aBlock) = 0;
    if (v963[0] == 17)
    {
      os_log_type_t v72 = (os_log_s *)__nwlog_obj();
      BOOL v73 = v963[0];
      if (!os_log_type_enabled(v72, (os_log_type_t)v963[0])) {
        goto LABEL_1094;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnect";
      os_log_type_t v74 = "%{public}s called with null other_protocol";
    }

    else if ((_BYTE)aBlock)
    {
      BOOL v79 = (char *)__nw_create_backtrace_string();
      os_log_type_t v72 = (os_log_s *)__nwlog_obj();
      BOOL v73 = v963[0];
      v80 = os_log_type_enabled(v72, (os_log_type_t)v963[0]);
      if (v79)
      {
        if (!v80) {
          goto LABEL_1087;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v79;
        os_log_type_t v81 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_1086;
      }

      if (!v80) {
        goto LABEL_1094;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnect";
      os_log_type_t v74 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      os_log_type_t v72 = (os_log_s *)__nwlog_obj();
      BOOL v73 = v963[0];
      if (!os_log_type_enabled(v72, (os_log_type_t)v963[0])) {
        goto LABEL_1094;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnect";
      os_log_type_t v74 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }

    goto LABEL_1093;
  }

  if (v3 != 2)
  {
    if (v3 != 3) {
      goto LABEL_1078;
    }
    os_log_type_t v8 = *((void *)handle + 2);
    if (v8)
    {
      id v9 = (uint64_t *)(v8 + 488);
      goto LABEL_17;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_stream_for_protocol";
    os_log_type_t v84 = (char *)_os_log_send_and_compose_impl();
    v963[0] = 16;
    LOBYTE(aBlock) = 0;
    if (__nwlog_fault(v84, v963, &aBlock))
    {
      if (v963[0] == 17)
      {
        BOOL v85 = (os_log_s *)__nwlog_obj();
        os_log_type_t v86 = v963[0];
        if (!os_log_type_enabled(v85, (os_log_type_t)v963[0])) {
          goto LABEL_1076;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_stream_for_protocol";
        BOOL v87 = "%{public}s called with null handle->http1_connection";
        goto LABEL_1075;
      }

      if (!(_BYTE)aBlock)
      {
        BOOL v85 = (os_log_s *)__nwlog_obj();
        os_log_type_t v86 = v963[0];
        if (!os_log_type_enabled(v85, (os_log_type_t)v963[0])) {
          goto LABEL_1076;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_stream_for_protocol";
        BOOL v87 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_1075;
      }

      os_log_type_t v97 = (char *)__nw_create_backtrace_string();
      BOOL v85 = (os_log_s *)__nwlog_obj();
      os_log_type_t v86 = v963[0];
      BOOL v98 = os_log_type_enabled(v85, (os_log_type_t)v963[0]);
      if (v97)
      {
        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_get_stream_for_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v97;
          _os_log_impl( &dword_181A5C000,  v85,  v86,  "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v97);
        goto LABEL_1076;
      }

      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_get_stream_for_protocol";
        BOOL v87 = "%{public}s called with null handle->http1_connection, no backtrace";
LABEL_1075:
        _os_log_impl(&dword_181A5C000, v85, v86, v87, buf, 0xCu);
      }
    }

              if (v41) {
                free(v41);
              }
              *(void *)&buffer = 0LL;
LABEL_188:
              v140 = cc_cmp_safe();
              v141 = v140;
              if ((unint64_t)buffer > v221)
              {
                if (v140)
                {
                  __nwlog_obj();
                  v142 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)applier = 136449282;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    *(_WORD *)&applier[12] = 2114;
                    *(void *)&applier[14] = v34;
                    *(_WORD *)&applier[22] = 2048;
                    *(void *)&applier[24] = v221;
                    *(_WORD *)&applier[32] = 1024;
                    *(_DWORD *)&applier[34] = v233;
                    *(_WORD *)&applier[38] = 1024;
                    *(_DWORD *)&applier[40] = BYTE1(v233);
                    *(_WORD *)&applier[44] = 1024;
                    *(_DWORD *)&applier[46] = BYTE2(v233);
                    *(_WORD *)&applier[50] = 1024;
                    *(_DWORD *)&applier[52] = BYTE3(v233);
                    *(_WORD *)&applier[56] = 2048;
                    v240 = buffer;
                    v241 = 1024;
                    *(_DWORD *)v242 = BYTE8(buffer);
                    *(_WORD *)&v242[4] = 1024;
                    *(_DWORD *)&v242[6] = BYTE9(buffer);
                    v243 = 1024;
                    v244 = BYTE10(buffer);
                    v245 = 1024;
                    v246 = BYTE11(buffer);
                    v247 = 2114;
                    v248 = v36;
                    _os_log_impl( &dword_181A5C000,  v142,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ ignoring received seq %llu pubKey %02x%02x%02x%02x previous seq %llu %02x%02 x%02x%02x for %{public}@",  applier,  0x64u);
                  }
                }

                goto LABEL_200;
              }

              __nwlog_obj();
              v143 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v144 = os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT);
              if (v141)
              {
                if (v144)
                {
                  *(_DWORD *)applier = 136449282;
                  *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                  *(_WORD *)&applier[12] = 2114;
                  *(void *)&applier[14] = v34;
                  *(_WORD *)&applier[22] = 2048;
                  *(void *)&applier[24] = v221;
                  *(_WORD *)&applier[32] = 1024;
                  *(_DWORD *)&applier[34] = v233;
                  *(_WORD *)&applier[38] = 1024;
                  *(_DWORD *)&applier[40] = BYTE1(v233);
                  *(_WORD *)&applier[44] = 1024;
                  *(_DWORD *)&applier[46] = BYTE2(v233);
                  *(_WORD *)&applier[50] = 1024;
                  *(_DWORD *)&applier[52] = BYTE3(v233);
                  *(_WORD *)&applier[56] = 2048;
                  v240 = buffer;
                  v241 = 1024;
                  *(_DWORD *)v242 = BYTE8(buffer);
                  *(_WORD *)&v242[4] = 1024;
                  *(_DWORD *)&v242[6] = BYTE9(buffer);
                  v243 = 1024;
                  v244 = BYTE10(buffer);
                  v245 = 1024;
                  v246 = BYTE11(buffer);
                  v247 = 2114;
                  v248 = v36;
                  v145 = "%{public}s %{public}@ saving different received seq %llu pubKey %02x%02x%02x%02x previous seq %"
                         "llu %02x%02x%02x%02x for %{public}@";
                  v146 = v143;
                  v147 = 100;
LABEL_198:
                  _os_log_impl(&dword_181A5C000, v146, OS_LOG_TYPE_DEFAULT, v145, applier, v147);
                }
              }

              else if (v144)
              {
                *(_DWORD *)applier = 136448258;
                *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                *(_WORD *)&applier[12] = 2114;
                *(void *)&applier[14] = v34;
                *(_WORD *)&applier[22] = 2048;
                *(void *)&applier[24] = v221;
                *(_WORD *)&applier[32] = 1024;
                *(_DWORD *)&applier[34] = v233;
                *(_WORD *)&applier[38] = 1024;
                *(_DWORD *)&applier[40] = BYTE1(v233);
                *(_WORD *)&applier[44] = 1024;
                *(_DWORD *)&applier[46] = BYTE2(v233);
                *(_WORD *)&applier[50] = 1024;
                *(_DWORD *)&applier[52] = BYTE3(v233);
                *(_WORD *)&applier[56] = 2048;
                v240 = buffer;
                v241 = 2114;
                *(void *)v242 = v36;
                v145 = "%{public}s %{public}@ saving same pubKey received seq %llu pubKey %02x%02x%02x%02x previous seq %"
                       "llu for %{public}@";
                v146 = v143;
                v147 = 76;
                goto LABEL_198;
              }

              v148 = v36;
              *(void *)type = v221;
              v237 = v233;
              v238 = v234;
              xpc_dictionary_set_data(*((xpc_object_t *)v34 + 13), (const char *)buf, type, 0x28uLL);
              v149 = (unsigned __int8 *)*((void *)v34 + 9);
              *(void *)applier = MEMORY[0x1895F87A8];
              *(void *)&applier[8] = 3221225472LL;
              *(void *)&applier[16] = ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke;
              *(void *)&applier[24] = &unk_189BBFE18;
              *(void *)&applier[32] = v34;
              *(void *)&applier[40] = v221;
              nw_array_apply(v149, (uint64_t)applier);

              size_t v36 = v148;
LABEL_200:

              goto LABEL_201;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v66 = v36;
            v67 = (id)gLogObj;
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nwsc_save_remote_pub_key";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v66;
            os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();

            size_t v36 = v66;
            LOBYTE(buffer) = 16;
            type[0] = OS_LOG_TYPE_DEFAULT;
            if (buffer == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v69 = (os_log_s *)(id)gLogObj;
              os_log_type_t v70 = buffer;
              if (os_log_type_enabled(v69, (os_log_type_t)buffer))
              {
                *(_DWORD *)applier = 136446466;
                *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                *(_WORD *)&applier[12] = 2114;
                *(void *)&applier[14] = v66;
                _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s Could not get identifier for endpoint %{public}@",  applier,  0x16u);
              }
            }

            else
            {
              if (type[0])
              {
                BOOL v77 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                os_log_type_t v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                BOOL v79 = buffer;
                v80 = os_log_type_enabled(v78, (os_log_type_t)buffer);
                if (v77)
                {
                  if (v80)
                  {
                    *(_DWORD *)applier = 136446722;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    *(_WORD *)&applier[12] = 2114;
                    *(void *)&applier[14] = v36;
                    *(_WORD *)&applier[22] = 2082;
                    *(void *)&applier[24] = v77;
                    _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s Could not get identifier for endpoint %{public}@, dumping backtrace:%{public}s",  applier,  0x20u);
                  }

                  free(v77);
                }

                else
                {
                  if (v80)
                  {
                    *(_DWORD *)applier = 136446466;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    *(_WORD *)&applier[12] = 2114;
                    *(void *)&applier[14] = v36;
                    _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s Could not get identifier for endpoint %{public}@, no backtrace",  applier,  0x16u);
                  }
                }

                goto LABEL_144;
              }

              __nwlog_obj();
              v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v99 = buffer;
              if (os_log_type_enabled(v69, (os_log_type_t)buffer))
              {
                *(_DWORD *)applier = 136446466;
                *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                *(_WORD *)&applier[12] = 2114;
                *(void *)&applier[14] = v66;
                _os_log_impl( &dword_181A5C000,  v69,  v99,  "%{public}s Could not get identifier for endpoint %{public}@, backtrace limit exceeded",  applier,  0x16u);
              }
            }

LABEL_144:
            if (v68) {
              free(v68);
            }
LABEL_201:

            if (v222)
            {
              v150 = *(nw_connection **)(a1 + 40);
              v151 = (nw_protocol_definition *)(id)g_tcp_definition;
              v152 = nw_connection_copy_protocol_metadata(v150, v151);

              if (nw_context_copy_implicit_context::onceToken != -1) {
                dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
              }
              v153 = (id)nw_context_copy_implicit_context::implicit_context;
              v154 = MEMORY[0x1895F87A8];
              v228[0] = MEMORY[0x1895F87A8];
              v228[1] = 3221225472LL;
              v228[2] = ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_176;
              v228[3] = &unk_189BC6E60;
              v229 = *(id *)(a1 + 32);
              v155 = v222;
              v230 = v155;
              v156 = v152;
              v231 = v156;
              nw_queue_context_async_if_needed(v153, v228);

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v157 = (os_log_s *)(id)gLogObj;
              v158 = os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT);
              if (v219 < 0)
              {
                if (v158)
                {
                  v166 = *(void *)(a1 + 32);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v166;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&buf[24] = v155;
                  LOWORD(v253[0]) = 2048;
                  *(void *)((char *)v253 + 2) = v221;
                  _os_log_impl( &dword_181A5C000,  v157,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ outgoing request %{public}@ was accepted by peer with reply seq %llu",  buf,  0x2Au);
                }

                v155->sequenceNumber = v221;
                v167 = *(void **)(a1 + 32);
                v168 = *(void **)(a1 + 40);
                v224[0] = v154;
                v224[1] = 3221225472LL;
                v224[2] = ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_177;
                v224[3] = &unk_189BBFD10;
                v225 = v167;
                v226 = v155;
                v227 = *(id *)(a1 + 40);
                nw_service_connector_accept_connection_for_request(v225, v168, v226, v224);
              }

              else
              {
                if (v158)
                {
                  v159 = "";
                  v160 = *(void *)(a1 + 32);
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_DWORD *)buf = 136447234;
                  if ((v219 & 0x40) == 0) {
                    v159 = "not ";
                  }
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v160;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&buf[24] = v155;
                  LOWORD(v253[0]) = 2082;
                  *(void *)((char *)v253 + 2) = v159;
                  WORD1(v253[1]) = 2048;
                  *(void *)((char *)&v253[1] + 4) = v221;
                  _os_log_impl( &dword_181A5C000,  v157,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ outgoing request %{public}@ was rejected (%{public}sby policy) by peer with reply seq %llu",  buf,  0x34u);
                }

                v161 = *(NWConcrete_nw_service_connector **)(a1 + 32);
                if ((v219 & 0x40) != 0)
                {
                  nw_service_connector_cancel_request_inner( v161,  v155->endpoint,  (uint64_t)v155->service,  *(void **)(a1 + 40),  0);
                  nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v155, 0LL, 0LL, 61);
                }

                else
                {
                  nwsc_request_start_path_watcher(v161, v155, *(NWConcrete_nw_connection **)(a1 + 40), 0);
                }
              }

              goto LABEL_269;
            }

            __nwlog_obj();
            v162 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v163 = v162;
            if ((v219 & 0x80) == 0)
            {
              if (os_log_type_enabled(v162, OS_LOG_TYPE_DEFAULT))
              {
                v164 = *(void *)(a1 + 32);
                v165 = *(void *)(a1 + 40);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                *(_WORD *)&buf[12] = 2114;
                *(void *)&buf[14] = v164;
                *(_WORD *)&buf[22] = 2114;
                *(void *)&buf[24] = v165;
                LOWORD(v253[0]) = 2048;
                *(void *)((char *)v253 + 2) = v221;
                _os_log_impl( &dword_181A5C000,  v163,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, denied with seq %llu",  buf,  0x2Au);
              }

LABEL_240:
              v65 = 0LL;
              nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
              goto LABEL_270;
            }

            v169 = *(void *)(a1 + 32);
            v170 = *(void *)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v169;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&buf[24] = v170;
            LOWORD(v253[0]) = 2048;
            *(void *)((char *)v253 + 2) = v221;
            v171 = (char *)_os_log_send_and_compose_impl();

            applier[0] = 16;
            LOBYTE(buffer) = 0;
            if (__nwlog_fault(v171, applier, &buffer))
            {
              if (applier[0] == 17)
              {
                __nwlog_obj();
                v172 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v173 = applier[0];
                if (os_log_type_enabled(v172, (os_log_type_t)applier[0]))
                {
                  v174 = *(void *)(a1 + 32);
                  v175 = *(void *)(a1 + 40);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v174;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&buf[24] = v175;
                  LOWORD(v253[0]) = 2048;
                  *(void *)((char *)v253 + 2) = v221;
                  _os_log_impl( &dword_181A5C000,  v172,  v173,  "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq %llu",  buf,  0x2Au);
                }
              }

              else if ((_BYTE)buffer)
              {
                v176 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v172 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v177 = applier[0];
                v178 = os_log_type_enabled(v172, (os_log_type_t)applier[0]);
                if (v176)
                {
                  if (v178)
                  {
                    v179 = *(void *)(a1 + 32);
                    v180 = *(void *)(a1 + 40);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                    *(_WORD *)&buf[12] = 2114;
                    *(void *)&buf[14] = v179;
                    *(_WORD *)&buf[22] = 2114;
                    *(void *)&buf[24] = v180;
                    LOWORD(v253[0]) = 2048;
                    *(void *)((char *)v253 + 2) = v221;
                    WORD1(v253[1]) = 2082;
                    *(void *)((char *)&v253[1] + 4) = v176;
                    _os_log_impl( &dword_181A5C000,  v172,  v177,  "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq % llu, dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(v176);
                  goto LABEL_238;
                }

                if (v178)
                {
                  v184 = *(void *)(a1 + 32);
                  v185 = *(void *)(a1 + 40);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v184;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&buf[24] = v185;
                  LOWORD(v253[0]) = 2048;
                  *(void *)((char *)v253 + 2) = v221;
                  _os_log_impl( &dword_181A5C000,  v172,  v177,  "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq %llu, no backtrace",  buf,  0x2Au);
                }
              }

              else
              {
                __nwlog_obj();
                v172 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v181 = applier[0];
                if (os_log_type_enabled(v172, (os_log_type_t)applier[0]))
                {
                  v182 = *(void *)(a1 + 32);
                  v183 = *(void *)(a1 + 40);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v182;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&buf[24] = v183;
                  LOWORD(v253[0]) = 2048;
                  *(void *)((char *)v253 + 2) = v221;
                  _os_log_impl( &dword_181A5C000,  v172,  v181,  "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq %ll u, backtrace limit exceeded",  buf,  0x2Au);
                }
              }
            }

              if (v99) {
                free(v99);
              }
              goto LABEL_309;
            }

            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
            v252 = (char *)_os_log_send_and_compose_impl();
            type[0] = 16;
            LOBYTE(v413) = 0;
            if (__nwlog_fault(v252, type, &v413))
            {
              if (type[0] == 17)
              {
                v253 = (os_log_s *)__nwlog_obj();
                v254 = type[0];
                if (!os_log_type_enabled(v253, (os_log_type_t)type[0])) {
                  goto LABEL_536;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                v255 = "%{public}s called with null http3_stream->http3_connection";
LABEL_535:
                _os_log_impl(&dword_181A5C000, v253, v254, v255, buf, 0xCu);
                goto LABEL_536;
              }

              if (!(_BYTE)v413)
              {
                v253 = (os_log_s *)__nwlog_obj();
                v254 = type[0];
                if (!os_log_type_enabled(v253, (os_log_type_t)type[0])) {
                  goto LABEL_536;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                v255 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
                goto LABEL_535;
              }

              v294 = (char *)__nw_create_backtrace_string();
              v253 = (os_log_s *)__nwlog_obj();
              v254 = type[0];
              v295 = os_log_type_enabled(v253, (os_log_type_t)type[0]);
              if (!v294)
              {
                if (!v295) {
                  goto LABEL_536;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                v255 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
                goto LABEL_535;
              }

              if (v295)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_serialize_fields";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v294;
                _os_log_impl( &dword_181A5C000,  v253,  v254,  "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v294);
            }

            if (v87) {
              free(v87);
            }
            LOBYTE(v51) = *((_BYTE *)v4 + 33);
            goto LABEL_103;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
            *(_WORD *)&buf[0].sa_data[10] = 2048;
            *(void *)&buf[0].sa_data[12] = internal;
            _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid",  &buf[0].sa_len,  0x16u);
          }

LABEL_114:
          BOOL v22 = 0LL;
          goto LABEL_115;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v52 = (id)gLogObj;
        *(_DWORD *)&buf[0].sa_len = 136446466;
        *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
        *(_WORD *)&buf[0].sa_data[10] = 2048;
        *(void *)&buf[0].sa_data[12] = a2;
        size_t v53 = (const char *)_os_log_send_and_compose_impl();

        v7 = v97;
        v102[0] = OS_LOG_TYPE_ERROR;
        v107[0] = 0;
        if (v102[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = (os_log_s *)(id)gLogObj;
          os_log_type_t v55 = v102[0];
          if (os_log_type_enabled(v54, v102[0]))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
            *(_WORD *)&buf[0].sa_data[10] = 2048;
            *(void *)&buf[0].sa_data[12] = a2;
            _os_log_impl( &dword_181A5C000,  v54,  v55,  "%{public}s Cannot add input handler %p to itself",  &buf[0].sa_len,  0x16u);
          }
        }

        else
        {
          if (v107[0])
          {
            os_log_type_t v57 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v58 = (os_log_s *)(id)gLogObj;
            os_log_type_t v59 = v102[0];
            v60 = os_log_type_enabled(v58, v102[0]);
            if (v57)
            {
              if (v60)
              {
                *(_DWORD *)&buf[0].sa_len = 136446722;
                *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                *(_WORD *)&buf[0].sa_data[10] = 2048;
                *(void *)&buf[0].sa_data[12] = a2;
                *(_WORD *)&buf[1].sa_data[4] = 2082;
                *(void *)&buf[1].sa_data[6] = v57;
                _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  &buf[0].sa_len,  0x20u);
              }

              free(v57);
              if (!v53) {
                goto LABEL_114;
              }
LABEL_112:
              v62 = (char *)v53;
LABEL_113:
              free(v62);
              goto LABEL_114;
            }

            if (v60)
            {
              *(_DWORD *)&buf[0].sa_len = 136446466;
              *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
              *(_WORD *)&buf[0].sa_data[10] = 2048;
              *(void *)&buf[0].sa_data[12] = a2;
              _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s Cannot add input handler %p to itself, no backtrace",  &buf[0].sa_len,  0x16u);
            }

LABEL_111:
            if (!v53) {
              goto LABEL_114;
            }
            goto LABEL_112;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = (os_log_s *)(id)gLogObj;
          os_log_type_t v61 = v102[0];
          if (os_log_type_enabled(v54, v102[0]))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
            *(_WORD *)&buf[0].sa_data[10] = 2048;
            *(void *)&buf[0].sa_data[12] = a2;
            _os_log_impl( &dword_181A5C000,  v54,  v61,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  &buf[0].sa_len,  0x16u);
          }
        }

        goto LABEL_111;
      }

      size_t v26 = (void *)*((void *)v4 + 111);
      os_log_type_t v27 = *((_BYTE *)v4 + 35);
      *(void *)os_log_type_t v102 = MEMORY[0x1895F87A8];
      os_log_type_t v103 = 0x40000000LL;
      BOOL v104 = __nw_socket_set_connected_fd_block_invoke;
      os_log_type_t v105 = &__block_descriptor_tmp_63972;
      os_log_type_t v106 = internal + 96;
      if ((nw_fd_wrapper_get_fd(v26, v102) & 1) == 0)
      {
        if ((*(_WORD *)(internal + 397) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          size_t v25 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_47;
          }
        }

        goto LABEL_74;
      }

      if (v26) {
        size_t v26 = os_retain(v26);
      }
      os_log_type_t v28 = *(_BYTE *)(internal + 168);
      if ((v28 & 1) != 0)
      {
        v29 = *(void **)(internal + 160);
        if (v29)
        {
          os_release(v29);
          os_log_type_t v28 = *(_BYTE *)(internal + 168);
        }
      }

      *(void *)(internal + 160) = v26;
      *(_BYTE *)(internal + 168) = v28 | 1;
      *(_DWORD *)(internal + 276) &= ~0x800u;
      if ((v27 & 0x40) != 0)
      {
        if ((nw_fd_wrapper_guard(v26) & 1) == 0 && (*(_WORD *)(internal + 397) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          size_t v36 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(void *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
            *(_WORD *)&buf[0].sa_data[10] = 2082;
            *(void *)&buf[0].sa_data[12] = internal + 404;
            size_t v32 = "%{public}s %{public}s Failed to guard socket fd";
            v33 = (os_log_s *)v36;
            size_t v34 = OS_LOG_TYPE_ERROR;
            v35 = 22;
            goto LABEL_54;
          }
        }
      }

      else if ((*(_WORD *)(internal + 397) & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        dispatch_data_t v30 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
        {
          dispatch_data_t v31 = *(_DWORD *)(internal + 268);
          *(_DWORD *)&buf[0].sa_len = 136446722;
          *(void *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
          *(_WORD *)&buf[0].sa_data[10] = 2082;
          *(void *)&buf[0].sa_data[12] = internal + 404;
          *(_WORD *)&buf[1].sa_data[4] = 1024;
          *(_DWORD *)&buf[1].sa_data[6] = v31;
          size_t v32 = "%{public}s %{public}s Not guarding connected fd %d";
          v33 = (os_log_s *)v30;
          size_t v34 = OS_LOG_TYPE_DEFAULT;
          v35 = 28;
LABEL_54:
          _os_log_impl(&dword_181A5C000, v33, v34, v32, &buf[0].sa_len, v35);
        }
      }

      *(_WORD *)(internal + 397) |= 4u;
      __int16 v116 = 0u;
      int v117 = 0u;
      v114 = 0u;
      v115 = 0u;
      memset(buf, 0, sizeof(buf));
      v101 = 128;
      if (!getsockname(*(_DWORD *)(internal + 268), buf, &v101))
      {
        *(_BYTE *)(internal + 400) = buf[0].sa_family;
        goto LABEL_74;
      }

      size_t v37 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)os_log_type_t v107 = 136446466;
      BOOL v108 = "nw_socket_set_connected_fd";
      os_log_type_t v109 = 1024;
      os_log_type_t v110 = v37;
      v38 = (void *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      os_log_type_t v99 = 0;
      if (__nwlog_fault((const char *)v38, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          size_t v39 = gLogObj;
          v40 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_72;
          }
          *(_DWORD *)os_log_type_t v107 = 136446466;
          BOOL v108 = "nw_socket_set_connected_fd";
          os_log_type_t v109 = 1024;
          os_log_type_t v110 = v37;
          size_t v41 = "%{public}s getsockname failed %{darwin.errno}d";
LABEL_69:
          v44 = (sockaddr *)v107;
          size_t v45 = (os_log_s *)v39;
LABEL_70:
          int v46 = v40;
          int v47 = 18;
LABEL_71:
          _os_log_impl(&dword_181A5C000, v45, v46, v41, &v44->sa_len, v47);
          goto LABEL_72;
        }

        if (!v99)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          size_t v39 = gLogObj;
          v40 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_72;
          }
          *(_DWORD *)os_log_type_t v107 = 136446466;
          BOOL v108 = "nw_socket_set_connected_fd";
          os_log_type_t v109 = 1024;
          os_log_type_t v110 = v37;
          size_t v41 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_69;
        }

        v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = type;
        log = (os_log_s *)gLogObj;
        size_t v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)os_log_type_t v107 = 136446722;
            BOOL v108 = "nw_socket_set_connected_fd";
            os_log_type_t v109 = 1024;
            os_log_type_t v110 = v37;
            char v111 = 2082;
            os_log_type_t v112 = v42;
            _os_log_impl( &dword_181A5C000,  log,  v40,  "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s",  v107,  0x1Cu);
          }

          free(v42);
          if (!v38) {
            goto LABEL_74;
          }
LABEL_73:
          free(v38);
          goto LABEL_74;
        }

        if (v43)
        {
          *(_DWORD *)os_log_type_t v107 = 136446466;
          BOOL v108 = "nw_socket_set_connected_fd";
          os_log_type_t v109 = 1024;
          os_log_type_t v110 = v37;
          size_t v41 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
          v44 = (sockaddr *)v107;
          size_t v45 = log;
          goto LABEL_70;
        }
      }

        if (v99) {
          free(v99);
        }
        goto LABEL_187;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v233 = nw_endpoint_handler_get_id_string(v6);
        v234 = nw_endpoint_handler_dry_run_string(v6);
        v235 = nw_endpoint_handler_copy_endpoint(v6);
        v236 = nw_endpoint_get_logging_description(v235);
        v237 = nw_endpoint_handler_state_string(v6);
        v238 = nw_endpoint_handler_mode_string(v6);
        v239 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        v359 = 2082;
        v360 = (char *)v233;
        v361 = 2082;
        v362 = v234;
        v363 = 2082;
        v364 = (void *)v236;
        v365 = 2082;
        v366 = v237;
        v367 = 2082;
        v368 = v238;
        v369 = 2114;
        v370 = v239;
        v371 = 2114;
        v372 = v347;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Starting protocol %{public}@",  buf,  0x52u);
      }
    }

    else
    {
      os_log_type_t v8 = v6;
      id v9 = *((_BYTE *)v8 + 268);

      if ((v9 & 0x20) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        unsigned int v11 = v8;

        size_t v12 = v11;
        v13 = *((_BYTE *)v8 + 268);

        if ((v13 & 1) != 0) {
          v14 = "dry-run ";
        }
        else {
          v14 = "";
        }
        v15 = nw_endpoint_handler_copy_endpoint(v12);
        nw_txt_record_t v16 = nw_endpoint_get_logging_description(v15);
        nw_txt_record_t v17 = (char *)(v11 + 42);
        v18 = v12;
        os_log_type_t v19 = v18;
        BOOL v20 = v18[30];
        else {
          os_log_type_t v21 = off_189BBBBF0[v20];
        }

        v33 = v19;
        size_t v34 = v33;
        v344 = v15;
        v35 = "path";
        switch(v6[29])
        {
          case 0u:
            break;
          case 1u:
            v35 = "resolver";
            break;
          case 2u:
            v35 = nw_endpoint_flow_mode_string(v33[31]);
            break;
          case 3u:
            v35 = "proxy";
            break;
          case 4u:
            v35 = "fallback";
            break;
          case 5u:
            v35 = "transform";
            break;
          default:
            v35 = "unknown-mode";
            break;
        }

        size_t v39 = v34;
        os_unfair_lock_lock((os_unfair_lock_t)v39 + 28);
        v40 = v39[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v39 + 28);

        size_t v41 = v40;
        *(_DWORD *)buf = 136448002;
        v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        v359 = 2082;
        v360 = v17;
        v361 = 2082;
        v362 = v14;
        v363 = 2082;
        v364 = (void *)v16;
        v365 = 2082;
        v366 = v21;
        v367 = 2082;
        v368 = v35;
        v369 = 2114;
        v370 = v41;
        v371 = 2114;
        v372 = v347;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Starting protocol %{public}@",  buf,  0x52u);
      }
    }

    goto LABEL_45;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v22 = (id)gLogObj;
  size_t v23 = v5;
  else {
    size_t v24 = off_189BBBBC0[v7];
  }
  *(_DWORD *)buf = 136446722;
  v358 = "nw_endpoint_handler_append_and_start_application_protocol";
  v359 = 2082;
  v360 = (char *)v24;
  v361 = 2082;
  v362 = "flow";
  size_t v25 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v353) = 0;
  if (__nwlog_fault(v25, type, &v353))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v26 = (os_log_s *)(id)gLogObj;
      os_log_type_t v27 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        else {
          os_log_type_t v28 = off_189BBBBC0[v7];
        }
        *(_DWORD *)buf = 136446722;
        v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        v359 = 2082;
        v360 = (char *)v28;
        v361 = 2082;
        v362 = "flow";
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    else if ((_BYTE)v353)
    {
      v29 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v26 = (os_log_s *)(id)gLogObj;
      dispatch_data_t v30 = type[0];
      dispatch_data_t v31 = os_log_type_enabled(v26, type[0]);
      if (v29)
      {
        if (v31)
        {
          else {
            size_t v32 = off_189BBBBC0[v7];
          }
          *(_DWORD *)buf = 136446978;
          v358 = "nw_endpoint_handler_append_and_start_application_protocol";
          v359 = 2082;
          v360 = (char *)v32;
          v361 = 2082;
          v362 = "flow";
          v363 = 2082;
          v364 = v29;
          _os_log_impl( &dword_181A5C000,  v26,  v30,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v29);
        if (!v25) {
          goto LABEL_87;
        }
        goto LABEL_86;
      }

      if (v31)
      {
        else {
          v38 = off_189BBBBC0[v7];
        }
        *(_DWORD *)buf = 136446722;
        v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        v359 = 2082;
        v360 = (char *)v38;
        v361 = 2082;
        v362 = "flow";
        _os_log_impl( &dword_181A5C000,  v26,  v30,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v26 = (os_log_s *)(id)gLogObj;
      size_t v36 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        else {
          size_t v37 = off_189BBBBC0[v7];
        }
        *(_DWORD *)buf = 136446722;
        v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        v359 = 2082;
        v360 = (char *)v37;
        v361 = 2082;
        v362 = "flow";
        _os_log_impl( &dword_181A5C000,  v26,  v36,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v25) {
LABEL_86:
  }
    free(v25);
LABEL_87:
  started = 0LL;
LABEL_210:

  return started;
}

LABEL_258:
                  goto LABEL_50;
                }

                if (!v111)
                {
                  __nwlog_obj();
                  v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v110 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1799;
                    _os_log_impl( &dword_181A5C000,  v63,  v110,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
                  }

                  goto LABEL_258;
                }

                v69 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v107 = v112;
                BOOL v108 = os_log_type_enabled(v63, v112);
                if (!v69)
                {
                  if (v108)
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1799;
                    _os_log_impl( &dword_181A5C000,  v63,  v107,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
                  }

                  goto LABEL_258;
                }

                if (v108)
                {
                  *(_DWORD *)buf = 136447490;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1799;
                  __int16 v124 = 2082;
                  v125 = v69;
                  _os_log_impl( &dword_181A5C000,  v63,  v107,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
                }
              }
            }
          }
        }

LABEL_239:
        free(v69);
        if (!v6) {
          return 0LL;
        }
        goto LABEL_51;
      default:
        if (!(_DWORD)v12) {
          return 0LL;
        }
        dispatch_data_t v30 = dispatch_data_create(&__dst[0].sa_data[6], v12, 0LL, 0LL);
        if (!v30) {
          return 0LL;
        }
        dispatch_data_t v31 = v30;
        host_with_numeric_port = (id *)nw_endpoint_create_custom(*(unsigned int *)&__dst[0].sa_data[2], v30, 0LL);

        return (nw_endpoint_t)host_with_numeric_port;
    }
  }

  address = nw_endpoint_create_address(__dst);
  host_with_numeric_port = (id *)address;
  if (address)
  {
    v15 = nw_endpoint_get_address(address);
    if (v3 >= 0x1D)
    {
      if (v15)
      {
        nw_txt_record_t v16 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[1].sa_data[10], v3 - 28LL);
        host_with_numeric_port = host_with_numeric_port;
        nw_txt_record_t v17 = v16;
        objc_storeStrong(host_with_numeric_port + 23, v16);

LABEL_21:
      }
    }
  }

  return (nw_endpoint_t)host_with_numeric_port;
}

  if (v90) {
    free(v90);
  }
LABEL_39:
  if (v20 == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v55 = a2[1].callbacks;
    if (v55)
    {
      v56 = (nw_protocol_callbacks *)((char *)v55 - 1);
      a2[1].callbacks = v56;
      if (!v56)
      {
        os_log_type_t v57 = *(void (***)(void))a2[1].flow_id;
        if (v57)
        {
          *(void *)a2[1].flow_id = 0LL;
          v57[2](v57);
          _Block_release(v57);
        }

        if ((a2[1].flow_id[8] & 1) != 0)
        {
          v58 = *(const void **)a2[1].flow_id;
          if (v58) {
            _Block_release(v58);
          }
        }

        free(a2);
      }
    }
  }

  if (v18 == &nw_protocol_ref_counted_handle && v17->handle == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v59 = v17[1].callbacks;
    if (v59)
    {
      v60 = (nw_protocol_callbacks *)((char *)v59 - 1);
      v17[1].callbacks = v60;
      if (!v60)
      {
        os_log_type_t v61 = *(void (***)(void))v17[1].flow_id;
        if (v61)
        {
          *(void *)v17[1].flow_id = 0LL;
          v61[2](v61);
          _Block_release(v61);
        }

        if ((v17[1].flow_id[8] & 1) != 0)
        {
          v62 = *(const void **)v17[1].flow_id;
          if (v62) {
            _Block_release(v62);
          }
        }

        v63 = v17;
        goto LABEL_116;
      }
    }
  }

          if (v78) {
            free(v78);
          }
          if ((v17 & 1) == 0) {
            goto LABEL_37;
          }
          goto LABEL_36;
        }

        __nwlog_obj();
        v42 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v133 = "nw_protocol_implementation_output_available";
        size_t v37 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v128[0] = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          size_t v43 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v133 = "nw_protocol_implementation_output_available";
            _os_log_impl( &dword_181A5C000,  v38,  v43,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_191;
        }

        if (v128[0] == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v95 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v133 = "nw_protocol_implementation_output_available";
            _os_log_impl( &dword_181A5C000,  v38,  v95,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_191;
        }

        BOOL v50 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        size_t v53 = type[0];
        v54 = os_log_type_enabled(v38, type[0]);
        if (!v50)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446210;
            v133 = "nw_protocol_implementation_output_available";
            _os_log_impl( &dword_181A5C000,  v38,  v53,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_191;
        }

        if (v54)
        {
          *(_DWORD *)buf = 136446466;
          v133 = "nw_protocol_implementation_output_available";
          v134 = 2082;
          v135 = v50;
          _os_log_impl( &dword_181A5C000,  v38,  v53,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v133 = "nw_protocol_implementation_output_available";
        size_t v37 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v128[0] = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          size_t v41 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v133 = "nw_protocol_implementation_output_available";
            _os_log_impl( &dword_181A5C000,  v38,  v41,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_191;
        }

        if (v128[0] == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v94 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v133 = "nw_protocol_implementation_output_available";
            _os_log_impl( &dword_181A5C000,  v38,  v94,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_191;
        }

        BOOL v50 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_txt_record_t v51 = type[0];
        size_t v52 = os_log_type_enabled(v38, type[0]);
        if (!v50)
        {
          if (v52)
          {
            *(_DWORD *)buf = 136446210;
            v133 = "nw_protocol_implementation_output_available";
            _os_log_impl( &dword_181A5C000,  v38,  v51,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_191;
        }

        if (v52)
        {
          *(_DWORD *)buf = 136446466;
          v133 = "nw_protocol_implementation_output_available";
          v134 = 2082;
          v135 = v50;
          _os_log_impl( &dword_181A5C000,  v38,  v51,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      goto LABEL_100;
    }

    __nwlog_obj();
    size_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v133 = "nw_protocol_implementation_output_available";
    size_t v37 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v128[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v39 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v133 = "nw_protocol_implementation_output_available";
        _os_log_impl(&dword_181A5C000, v38, v39, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v128[0])
    {
      int v47 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v48 = type[0];
      size_t v49 = os_log_type_enabled(v38, type[0]);
      if (v47)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          v133 = "nw_protocol_implementation_output_available";
          v134 = 2082;
          v135 = v47;
          _os_log_impl( &dword_181A5C000,  v38,  v48,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v47);
LABEL_251:
        if (!v37) {
          goto LABEL_58;
        }
LABEL_252:
        free(v37);
        goto LABEL_58;
      }

      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        v133 = "nw_protocol_implementation_output_available";
        _os_log_impl(&dword_181A5C000, v38, v48, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v93 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v133 = "nw_protocol_implementation_output_available";
        _os_log_impl( &dword_181A5C000,  v38,  v93,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v194) {
      free(v194);
    }
    id v5 = 0LL;
    goto LABEL_206;
  }

  v6 = (unsigned int *)v4;
  v7 = v6[29];

  if ((_DWORD)v7 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v24 = (id)gLogObj;
    size_t v25 = v5;
    else {
      size_t v26 = off_189BBBBC0[v7];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v26;
    *(_WORD *)&buf[22] = 2082;
    *(void *)&buf[24] = "fallback";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v257) = 0;
    if (__nwlog_fault(v27, type, &v257))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v28 = (os_log_s *)(id)gLogObj;
        v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          else {
            dispatch_data_t v30 = off_189BBBBC0[v7];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v30;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = "fallback";
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if ((_BYTE)v257)
      {
        dispatch_data_t v31 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v28 = (os_log_s *)(id)gLogObj;
        size_t v32 = type[0];
        v33 = os_log_type_enabled(v28, type[0]);
        if (v31)
        {
          if (v33)
          {
            else {
              size_t v34 = off_189BBBBC0[v7];
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v34;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&buf[24] = "fallback";
            *(_WORD *)&buf[32] = 2082;
            *(void *)&buf[34] = v31;
            _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v31);
          if (!v27) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }

        if (v33)
        {
          else {
            size_t v41 = off_189BBBBC0[v7];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v41;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = "fallback";
          _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v28 = (os_log_s *)(id)gLogObj;
        v35 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          else {
            size_t v36 = off_189BBBBC0[v7];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v36;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = "fallback";
          _os_log_impl( &dword_181A5C000,  v28,  v35,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    if (!v27)
    {
LABEL_34:
      id v5 = v25;
      goto LABEL_206;
    }

          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_protocol_http1_notify";
          int v47 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          os_log_type_t v92 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            size_t v48 = (os_log_s *)__nwlog_obj();
            size_t v49 = type;
            if (!os_log_type_enabled(v48, type)) {
              goto LABEL_274;
            }
            *(_DWORD *)buf = 136446210;
            os_log_type_t v95 = "nw_protocol_http1_notify";
            BOOL v50 = "%{public}s called with null http1_connection";
            goto LABEL_273;
          }

          if (!v92)
          {
            size_t v48 = (os_log_s *)__nwlog_obj();
            size_t v49 = type;
            if (!os_log_type_enabled(v48, type)) {
              goto LABEL_274;
            }
            *(_DWORD *)buf = 136446210;
            os_log_type_t v95 = "nw_protocol_http1_notify";
            BOOL v50 = "%{public}s called with null http1_connection, backtrace limit exceeded";
            goto LABEL_273;
          }

          v56 = (char *)__nw_create_backtrace_string();
          size_t v48 = (os_log_s *)__nwlog_obj();
          size_t v49 = type;
          os_log_type_t v91 = os_log_type_enabled(v48, type);
          if (!v56)
          {
            if (!v91) {
              goto LABEL_274;
            }
            *(_DWORD *)buf = 136446210;
            os_log_type_t v95 = "nw_protocol_http1_notify";
            BOOL v50 = "%{public}s called with null http1_connection, no backtrace";
            goto LABEL_273;
          }

          if (!v91) {
            goto LABEL_267;
          }
LABEL_265:
          *(_DWORD *)buf = 136446466;
          os_log_type_t v95 = "nw_protocol_http1_notify";
          BOOL v96 = 2082;
          os_log_type_t v97 = v56;
          v58 = "%{public}s called with null http1_connection, dumping backtrace:%{public}s";
          goto LABEL_266;
        }

        size_t v36 = *(void *)(v3 + 8);
        if (v36)
        {
          v14 = (uint64_t *)(v36 + 256);
          goto LABEL_52;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
        v80 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        os_log_type_t v92 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v81 = (os_log_s *)__nwlog_obj();
          v82 = type;
          if (!os_log_type_enabled(v81, type)) {
            goto LABEL_256;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
          os_log_type_t v83 = "%{public}s called with null handle->http1_stream";
        }

        else if (v92)
        {
          os_log_type_t v86 = (char *)__nw_create_backtrace_string();
          os_log_type_t v81 = (os_log_s *)__nwlog_obj();
          v82 = type;
          BOOL v87 = os_log_type_enabled(v81, type);
          if (v86)
          {
            if (v87)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
              BOOL v96 = 2082;
              os_log_type_t v97 = v86;
              _os_log_impl( &dword_181A5C000,  v81,  v82,  "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v86);
            goto LABEL_256;
          }

          if (!v87)
          {
LABEL_256:
            if (v80) {
              free(v80);
            }
            goto LABEL_258;
          }

          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
          os_log_type_t v83 = "%{public}s called with null handle->http1_stream, no backtrace";
        }

        else
        {
          os_log_type_t v81 = (os_log_s *)__nwlog_obj();
          v82 = type;
          if (!os_log_type_enabled(v81, type)) {
            goto LABEL_256;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
          os_log_type_t v83 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v81, v82, v83, buf, 0xCu);
        goto LABEL_256;
    }
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v95 = "nw_protocol_http1_notify";
  int v47 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  os_log_type_t v92 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    size_t v48 = (os_log_s *)__nwlog_obj();
    size_t v49 = type;
    if (!os_log_type_enabled(v48, type)) {
      goto LABEL_274;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v95 = "nw_protocol_http1_notify";
    BOOL v50 = "%{public}s called with null other_protocol";
    goto LABEL_273;
  }

  if (!v92)
  {
    size_t v48 = (os_log_s *)__nwlog_obj();
    size_t v49 = type;
    if (!os_log_type_enabled(v48, type)) {
      goto LABEL_274;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v95 = "nw_protocol_http1_notify";
    BOOL v50 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_273;
  }

  v56 = (char *)__nw_create_backtrace_string();
  size_t v48 = (os_log_s *)__nwlog_obj();
  size_t v49 = type;
  os_log_type_t v57 = os_log_type_enabled(v48, type);
  if (!v56)
  {
    if (!v57) {
      goto LABEL_274;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v95 = "nw_protocol_http1_notify";
    BOOL v50 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_273;
  }

  if (v57)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v95 = "nw_protocol_http1_notify";
    BOOL v96 = 2082;
    os_log_type_t v97 = v56;
    v58 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_266:
    _os_log_impl(&dword_181A5C000, v48, v49, v58, buf, 0x16u);
  }

    v131 = (void *)v217[3];
    if (v131)
    {
      free(v131);
      v217[3] = 0LL;
    }

    goto LABEL_350;
  }

  v129 = v209[14];
  v209[14] = v123;
LABEL_275:

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v132 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v132, OS_LOG_TYPE_DEBUG))
  {
    v133 = *((_DWORD *)v209 + 93);
    v134 = v209[14];
    v135 = "";
    if (*((_BYTE *)v245 + 24)) {
      v136 = ", weak";
    }
    else {
      v136 = "";
    }
    if (*((_BYTE *)v237 + 24)) {
      v137 = ", forced";
    }
    else {
      v137 = "";
    }
    if (*((_BYTE *)v233 + 24)) {
      v135 = ", preferred";
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v133;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = v134;
    *(_WORD *)&buf[28] = 2082;
    *(void *)&buf[30] = v136;
    *(_WORD *)&buf[38] = 2082;
    *(void *)&buf[40] = v137;
    v250 = 2082;
    v251 = v135;
    _os_log_impl( &dword_181A5C000,  v132,  OS_LOG_TYPE_DEBUG,  "%{public}s Fallback generation %u index %@%{public}s%{public}s%{public}s",  buf,  0x3Au);
  }

  v138 = (const unsigned __int8 *)v217[3];
  if (v138 && !uuid_is_null(v138)) {
    *(_OWORD *)(v209 + 19) = *(_OWORD *)v217[3];
  }
  v139 = (const char *)v225[3];
  if (v139 && v221[3])
  {
    v140 = v209[21];
    v141 = v209[22];
    if (!v140)
    {
      if (v141) {
        goto LABEL_294;
      }
      goto LABEL_345;
    }

    if (!v141)
    {
LABEL_294:
      __nwlog_obj();
      v142 = (void *)objc_claimAutoreleasedReturnValue();
      v143 = v209[22];
      if (v209[21]) {
        v144 = "non";
      }
      else {
        v144 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
      *(_WORD *)&buf[12] = 2082;
      if (v143) {
        v145 = "non";
      }
      else {
        v145 = "";
      }
      *(void *)&buf[14] = v144;
      *(_WORD *)&buf[22] = 2082;
      *(void *)&buf[24] = v145;
      v196 = (size_t *)buf;
      v146 = (char *)_os_log_send_and_compose_impl();

      v211 = OS_LOG_TYPE_ERROR;
      v210 = 0;
      if (v211 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v148 = v211;
        if (os_log_type_enabled(v147, v211))
        {
          if (v209[21]) {
            v149 = "non";
          }
          else {
            v149 = "";
          }
          if (v209[22]) {
            v150 = "non";
          }
          else {
            v150 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v149;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = v150;
          _os_log_impl( &dword_181A5C000,  v147,  v148,  "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull)",  buf,  0x20u);
        }

        goto LABEL_342;
      }

      if (v210)
      {
        v151 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v152 = v211;
        v153 = os_log_type_enabled(v147, v211);
        if (v151)
        {
          if (v153)
          {
            if (v209[21]) {
              v154 = "non";
            }
            else {
              v154 = "";
            }
            if (v209[22]) {
              v155 = "non";
            }
            else {
              v155 = "";
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v154;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&buf[24] = v155;
            *(_WORD *)&buf[32] = 2082;
            *(void *)&buf[34] = v151;
            _os_log_impl( &dword_181A5C000,  v147,  v152,  "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull), dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v151);
LABEL_343:
          if (v146) {
            free(v146);
          }
LABEL_345:
          v161 = xpc_array_create(0LL, 0LL);
          v162 = v209[21];
          v209[21] = v161;

          v163 = xpc_array_create(0LL, 0LL);
          v164 = v209[22];
          v209[22] = v163;

          v140 = v209[21];
          v139 = (const char *)v225[3];
          goto LABEL_346;
        }

        if (v153)
        {
          if (v209[21]) {
            v159 = "non";
          }
          else {
            v159 = "";
          }
          if (v209[22]) {
            v160 = "non";
          }
          else {
            v160 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v159;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = v160;
          _os_log_impl( &dword_181A5C000,  v147,  v152,  "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull), no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        v147 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v156 = v211;
        if (os_log_type_enabled(v147, v211))
        {
          if (v209[21]) {
            v157 = "non";
          }
          else {
            v157 = "";
          }
          if (v209[22]) {
            v158 = "non";
          }
          else {
            v158 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v157;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = v158;
          _os_log_impl( &dword_181A5C000,  v147,  v156,  "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull), backtrace limit exceeded",  buf,  0x20u);
        }
      }

void sub_181AD8820(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_address(const sockaddr *address)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (address)
  {
    v1 = -[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_address_endpoint),  &address->sa_len,  0LL);
    v2 = v1;
    if (v1)
    {
      unsigned int v3 = v1;
LABEL_11:

      return (nw_endpoint_t)v2;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    size_t v24 = "nw_endpoint_create_address";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v5, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v24 = "nw_endpoint_create_address";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s NWOSAddressEndpoint alloc/init failed", buf, 0xCu);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            size_t v24 = "nw_endpoint_create_address";
            __int16 v25 = 2082;
            size_t v26 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s NWOSAddressEndpoint alloc/init failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v5) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          size_t v24 = "nw_endpoint_create_address";
          _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s NWOSAddressEndpoint alloc/init failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v24 = "nw_endpoint_create_address";
          _os_log_impl( &dword_181A5C000,  v6,  v12,  "%{public}s NWOSAddressEndpoint alloc/init failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v5) {
      goto LABEL_11;
    }
LABEL_10:
    free(v5);
    goto LABEL_11;
  }

  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  size_t v24 = "nw_endpoint_create_address";
  v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v14, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v24 = "nw_endpoint_create_address";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null address", buf, 0xCu);
      }
    }

    else if (v21)
    {
      nw_txt_record_t v17 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          size_t v24 = "nw_endpoint_create_address";
          __int16 v25 = 2082;
          size_t v26 = v17;
          _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null address, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_41;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        size_t v24 = "nw_endpoint_create_address";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null address, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v24 = "nw_endpoint_create_address";
        _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null address, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_108:
    if (v46) {
      free(v46);
    }
    return 0LL;
  }

  v6 = *a2;
  if ((v6 + 127) <= 0x80u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (id)gLogObj;
    os_log_type_t v8 = *a2;
    *(_DWORD *)buf = 136446466;
    os_log_type_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
    v58 = 1024;
    *(_DWORD *)os_log_type_t v59 = v8;
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    size_t v53 = 0;
    if (__nwlog_fault(v9, &type, &v53))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        BOOL v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          os_log_type_t v12 = *a2;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
          v58 = 1024;
          *(_DWORD *)os_log_type_t v59 = v12;
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s Invalid sockaddr length: %u", buf, 0x12u);
        }
      }

      else if (v53)
      {
        os_log_type_t v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        nw_txt_record_t v17 = type;
        os_log_type_t v18 = os_log_type_enabled(v10, type);
        if (v16)
        {
          if (v18)
          {
            BOOL v19 = *a2;
            *(_DWORD *)buf = 136446722;
            os_log_type_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
            v58 = 1024;
            *(_DWORD *)os_log_type_t v59 = v19;
            v59[2] = 2082;
            *(void *)&v59[3] = v16;
            _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s Invalid sockaddr length: %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v16);
          if (!v9) {
            goto LABEL_35;
          }
          goto LABEL_34;
        }

        if (v18)
        {
          BOOL v22 = *a2;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
          v58 = 1024;
          *(_DWORD *)os_log_type_t v59 = v22;
          _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s Invalid sockaddr length: %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          char v21 = *a2;
          *(_DWORD *)buf = 136446466;
          os_log_type_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
          v58 = 1024;
          *(_DWORD *)os_log_type_t v59 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s Invalid sockaddr length: %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v9)
    {
LABEL_35:

      return 0LL;
    }

    if (v65) {
      free(v65);
    }
    goto LABEL_90;
  }

  *((_DWORD *)v18 + 21) = 0;
  *((_DWORD *)v18 + 2) = 0;
  os_log_type_t v20 = v18 + 3;
  objc_storeStrong((id *)v18 + 3, a2);
  if (v11) {
    char v21 = (nw_parameters_t)v11;
  }
  else {
    char v21 = nw_parameters_create();
  }
  BOOL v22 = v19[2];
  v19[2] = v21;

  size_t v23 = (nw_endpoint *)nw_parameters_copy_context(v19[2]);
  size_t v24 = v19[4];
  v19[4] = v23;

  if (nw_context_is_inline(v19[4]))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v25 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]";
    size_t v26 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    BOOL v77 = 0;
    if (__nwlog_fault(v26, type, &v77))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v27 = (os_log_s *)(id)gLogObj;
        os_log_type_t v28 = type[0];
        if (os_log_type_enabled(v27, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]";
          _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s Cannot use nw_resolver on inline contexts", buf, 0xCu);
        }
      }

      else if (v77)
      {
        size_t v34 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v27 = (os_log_s *)(id)gLogObj;
        v35 = type[0];
        size_t v36 = os_log_type_enabled(v27, type[0]);
        if (v34)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v34;
            _os_log_impl( &dword_181A5C000,  v27,  v35,  "%{public}s Cannot use nw_resolver on inline contexts, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v34);
          if (!v26) {
            goto LABEL_89;
          }
          goto LABEL_88;
        }

        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]";
          _os_log_impl( &dword_181A5C000,  v27,  v35,  "%{public}s Cannot use nw_resolver on inline contexts, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v27 = (os_log_s *)(id)gLogObj;
        v58 = type[0];
        if (os_log_type_enabled(v27, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]";
          _os_log_impl( &dword_181A5C000,  v27,  v58,  "%{public}s Cannot use nw_resolver on inline contexts, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v26)
    {
LABEL_89:

LABEL_90:
      BOOL v19 = 0LL;
      goto LABEL_91;
    }

                goto LABEL_109;
              }

              if (!v61)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v55 = type[0];
                if (os_log_type_enabled(v42, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl( &dword_181A5C000,  v42,  v55,  "%{public}s called with null endpoint->context, backtrace limit exceeded",  buf,  0xCu);
                }

                goto LABEL_108;
              }

              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              size_t v49 = type[0];
              BOOL v50 = os_log_type_enabled(v42, type[0]);
              if (!backtrace_string)
              {
                if (v50)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl( &dword_181A5C000,  v42,  v49,  "%{public}s called with null endpoint->context, no backtrace",  buf,  0xCu);
                }

                goto LABEL_108;
              }

              if (v50)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v42,  v49,  "%{public}s called with null endpoint->context, dumping backtrace:%{public}s",  buf,  0x16u);
              }
            }

            else
            {
              __nwlog_obj();
              v40 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
              size_t v41 = (void *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              os_log_type_t v61 = 0;
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                size_t v43 = type[0];
                if (os_log_type_enabled(v42, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl(&dword_181A5C000, v42, v43, "%{public}s called with null endpoint", buf, 0xCu);
                }

                goto LABEL_108;
              }

              if (!v61)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v54 = type[0];
                if (os_log_type_enabled(v42, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl( &dword_181A5C000,  v42,  v54,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
                }

                goto LABEL_108;
              }

              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              int v47 = type[0];
              size_t v48 = os_log_type_enabled(v42, type[0]);
              if (!backtrace_string)
              {
                if (v48)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl( &dword_181A5C000,  v42,  v47,  "%{public}s called with null endpoint, no backtrace",  buf,  0xCu);
                }

                goto LABEL_108;
              }

              if (v48)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_endpoint_get_connected_flow_count";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v42,  v47,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
              }
            }

            free(backtrace_string);
            goto LABEL_109;
          }
        }

    free(v79);
    if (!v16) {
      goto LABEL_76;
    }
    goto LABEL_75;
  }

  v15 = *(uint64_t **)(*((void *)v7 + 4) + 8LL);
  if (v15)
  {
    os_log_type_t v16 = 0LL;
    nw_txt_record_t v17 = 0;
    do
    {
      os_log_type_t v20 = v15;
      v15 = (uint64_t *)*v15;
      if (v20[3] == a2)
      {
        if (v16)
        {
          char v21 = v7;
          if ((v20[5] & 1) == 0)
          {
            BOOL v22 = *v20;
            size_t v23 = (void *)v20[1];
            if (*v20)
            {
              *(void *)(v22 + 8) = v23;
              size_t v23 = (void *)v20[1];
            }

            else
            {
              *(void *)(*((void *)v7 + 4) + 16LL) = v23;
            }

            *size_t v23 = v22;
            *os_log_type_t v20 = 0LL;
            v20[1] = 0LL;
            os_log_type_t v18 = nw_hash_table_get_node(*(void *)(*((void *)v7 + 4) + 24LL), v20[3], 0LL);
            nw_hash_table_remove_node(*(void *)(*((void *)v7 + 4) + 24LL), v18);
            BOOL v19 = (void *)v20[4];
            v20[4] = 0LL;

            free(v20);
          }
        }

        else
        {
          size_t v24 = (uint64_t **)v20[1];
          if (v15)
          {
            v15[1] = (uint64_t)v24;
            size_t v24 = (uint64_t **)v20[1];
          }

          else
          {
            *(void *)(*((void *)v7 + 4) + 16LL) = v24;
          }

          *size_t v24 = v15;
          nw_txt_record_t v17 = 1;
          os_log_type_t v16 = v20;
          *os_log_type_t v20 = 0LL;
          v20[1] = 0LL;
        }
      }
    }

    while (v15);
    if (v16) {
      goto LABEL_36;
    }
  }

  else
  {
    nw_txt_record_t v17 = 0;
  }

  os_log_type_t v16 = (uint64_t *)calloc(1uLL, 0x30uLL);
  if (v16)
  {
LABEL_36:
    v16[2] = a3;
    v16[3] = a2;
    v33 = _Block_copy(v10);
    size_t v34 = (void *)v16[4];
    v16[4] = (uint64_t)v33;

    v35 = (void *)(*((void *)v7 + 4) + 8LL);
    do
    {
      v35 = (void *)*v35;
      if (!v35)
      {
        *os_log_type_t v16 = 0LL;
        v16[1] = *(void *)(*((void *)v7 + 4) + 16LL);
        **(void **)(*((void *)v7 + 4) + 16LL) = v16;
        *(void *)(*((void *)v7 + 4) + 16LL) = v16;
        if ((v17 & 1) != 0) {
          goto LABEL_44;
        }
        goto LABEL_42;
      }
    }

    while ((unint64_t)v16[2] >= v35[2]);
    size_t v36 = v35[1];
    *os_log_type_t v16 = (uint64_t)v35;
    v16[1] = v36;
    *(void *)v35[1] = v16;
    v35[1] = v16;
    if ((v17 & 1) != 0)
    {
LABEL_44:
      v38 = (uint64_t *)*((void *)v7 + 4);
      if ((uint64_t *)v38[1] == v16)
      {
        size_t v39 = v38[4];
        if (!v39 || v39 > v16[2])
        {
          v40 = *v38;
          if (!*v38)
          {
            v91[0] = MEMORY[0x1895F87A8];
            v91[1] = 3221225472LL;
            v91[2] = __nw_context_reset_timer_block_with_time_block_invoke;
            v91[3] = &unk_189BC93A0;
            os_log_type_t v92 = v7;
            **((void **)v7 + 4) = nw_queue_context_create_source(v92, 2, 7, 0, v91, 0LL);

            v40 = **((void **)v7 + 4);
          }

          nw_queue_set_timer_values(v40, v16[2], 0xFFFFFFFFFFFFFFFFLL, 0LL);
          nw_queue_activate_source(**((void **)v7 + 4), v41);
          *(void *)(*((void *)v7 + 4) + 32LL) = v16[2];
        }
      }

      goto LABEL_76;
    }

  if (*(void *)v14)
  {
    if (gLogDatapath)
    {
      v175 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v175, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        _os_log_impl( &dword_181A5C000,  v175,  OS_LOG_TYPE_DEBUG,  "%{public}s resuming saved input frames",  (uint8_t *)buf,  0xCu);
      }
    }

    v54 = *(void *)(v14 + 96);
    if (v54)
    {
      *(void *)os_log_type_t type = 0LL;
      v243 = type;
      LODWORD(v245) = 0;
      v244 = 0x2000000000LL;
      buf[0] = MEMORY[0x1895F87A8];
      buf[1] = 0x40000000LL;
      buf[2] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
      v261 = (unint64_t)&unk_189BB63E8;
      v262[2] = v14;
      v263 = &v232;
      v271 = 1;
      v266 = &v233;
      v267 = &v229;
      v264 = v14;
      v265 = (unint64_t)a6;
      v262[0] = type;
      v262[1] = &v231;
      v268 = a1;
      v269 = v54;
      v270 = a2;
      os_log_type_t v55 = *(void *)v14;
      do
      {
        if (!v55) {
          break;
        }
        v56 = *(void *)(v55 + 32);
        os_log_type_t v57 = ((uint64_t (*)(void *))buf[2])(buf);
        os_log_type_t v55 = v56;
      }

      while ((v57 & 1) != 0);
      v58 = *((_DWORD *)v243 + 6);
      _Block_object_dispose(type, 8);
      goto LABEL_115;
    }

    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
    v176 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (__nwlog_fault(v176, type, v258))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v177 = (os_log_s *)__nwlog_obj();
        v178 = type[0];
        if (os_log_type_enabled(v177, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
          v179 = "%{public}s called with null processor";
LABEL_513:
          _os_log_impl(&dword_181A5C000, v177, v178, v179, (uint8_t *)buf, 0xCu);
        }
      }

      else if (LOBYTE(v258[0]))
      {
        v193 = (char *)__nw_create_backtrace_string();
        v177 = (os_log_s *)__nwlog_obj();
        v178 = type[0];
        v194 = os_log_type_enabled(v177, type[0]);
        if (v193)
        {
          if (v194)
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v193;
            _os_log_impl( &dword_181A5C000,  v177,  v178,  "%{public}s called with null processor, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
          }

          free(v193);
          goto LABEL_514;
        }

        if (v194)
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
          v179 = "%{public}s called with null processor, no backtrace";
          goto LABEL_513;
        }
      }

      else
      {
        v177 = (os_log_s *)__nwlog_obj();
        v178 = type[0];
        if (os_log_type_enabled(v177, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
          v179 = "%{public}s called with null processor, backtrace limit exceeded";
          goto LABEL_513;
        }
      }
    }

          free(v25);
          goto LABEL_109;
        }

        if (!v48) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_input_frames";
        v29 = "%{public}s called with null return_array, no backtrace";
      }

      else
      {
        v38 = (os_log_s *)__nwlog_obj();
        size_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_input_frames";
        v29 = "%{public}s called with null return_array, backtrace limit exceeded";
      }

      nw_txt_record_t v51 = v38;
      size_t v52 = v39;
      size_t v53 = 12;
      goto LABEL_106;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v57 = "__nw_protocol_get_input_frames";
    size_t v34 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v34, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "__nw_protocol_get_input_frames";
          size_t v37 = "%{public}s called with null input_protocol";
LABEL_99:
          _os_log_impl(&dword_181A5C000, v35, v36, v37, buf, 0xCu);
        }
      }

      else if (v54)
      {
        size_t v45 = (char *)__nw_create_backtrace_string();
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        int v46 = os_log_type_enabled(v35, type);
        if (v45)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v57 = "__nw_protocol_get_input_frames";
            v58 = 2082;
            os_log_type_t v59 = v45;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v45);
          goto LABEL_100;
        }

        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "__nw_protocol_get_input_frames";
          size_t v37 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_99;
        }
      }

      else
      {
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "__nw_protocol_get_input_frames";
          size_t v37 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_99;
        }
      }
    }

          free(v25);
          goto LABEL_109;
        }

        if (!v48) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_output_frames";
        v29 = "%{public}s called with null return_array, no backtrace";
      }

      else
      {
        v38 = (os_log_s *)__nwlog_obj();
        size_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_output_frames";
        v29 = "%{public}s called with null return_array, backtrace limit exceeded";
      }

      nw_txt_record_t v51 = v38;
      size_t v52 = v39;
      size_t v53 = 12;
      goto LABEL_106;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v57 = "__nw_protocol_get_output_frames";
    size_t v34 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v34, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "__nw_protocol_get_output_frames";
          size_t v37 = "%{public}s called with null input_protocol";
LABEL_99:
          _os_log_impl(&dword_181A5C000, v35, v36, v37, buf, 0xCu);
        }
      }

      else if (v54)
      {
        size_t v45 = (char *)__nw_create_backtrace_string();
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        int v46 = os_log_type_enabled(v35, type);
        if (v45)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v57 = "__nw_protocol_get_output_frames";
            v58 = 2082;
            os_log_type_t v59 = v45;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v45);
          goto LABEL_100;
        }

        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "__nw_protocol_get_output_frames";
          size_t v37 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_99;
        }
      }

      else
      {
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "__nw_protocol_get_output_frames";
          size_t v37 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_99;
        }
      }
    }

          free(v22);
          goto LABEL_109;
        }

        if (!v45) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        v54 = "__nw_protocol_register_notification";
        size_t v26 = "%{public}s called with null type, no backtrace";
      }

      else
      {
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        v54 = "__nw_protocol_register_notification";
        size_t v26 = "%{public}s called with null type, backtrace limit exceeded";
      }

      size_t v48 = v35;
      size_t v49 = v36;
      BOOL v50 = 12;
      goto LABEL_106;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v54 = "__nw_protocol_register_notification";
    dispatch_data_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    nw_txt_record_t v51 = 0;
    if (__nwlog_fault(v31, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_register_notification";
          size_t v34 = "%{public}s called with null other_protocol";
LABEL_99:
          _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
        }
      }

      else if (v51)
      {
        v42 = (char *)__nw_create_backtrace_string();
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        size_t v43 = os_log_type_enabled(v32, type);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            v54 = "__nw_protocol_register_notification";
            os_log_type_t v55 = 2082;
            v56 = v42;
            _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v42);
          goto LABEL_100;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_register_notification";
          size_t v34 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_99;
        }
      }

      else
      {
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_register_notification";
          size_t v34 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_99;
        }
      }
    }

          free(v22);
          goto LABEL_109;
        }

        if (!v45) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        v54 = "__nw_protocol_unregister_notification";
        size_t v26 = "%{public}s called with null type, no backtrace";
      }

      else
      {
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        v54 = "__nw_protocol_unregister_notification";
        size_t v26 = "%{public}s called with null type, backtrace limit exceeded";
      }

      size_t v48 = v35;
      size_t v49 = v36;
      BOOL v50 = 12;
      goto LABEL_106;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v54 = "__nw_protocol_unregister_notification";
    dispatch_data_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    nw_txt_record_t v51 = 0;
    if (__nwlog_fault(v31, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_unregister_notification";
          size_t v34 = "%{public}s called with null other_protocol";
LABEL_99:
          _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
        }
      }

      else if (v51)
      {
        v42 = (char *)__nw_create_backtrace_string();
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        size_t v43 = os_log_type_enabled(v32, type);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            v54 = "__nw_protocol_unregister_notification";
            os_log_type_t v55 = 2082;
            v56 = v42;
            _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v42);
          goto LABEL_100;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_unregister_notification";
          size_t v34 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_99;
        }
      }

      else
      {
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_unregister_notification";
          size_t v34 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_99;
        }
      }
    }

          free(v22);
          goto LABEL_109;
        }

        if (!v45) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        v54 = "__nw_protocol_updated_path";
        size_t v26 = "%{public}s called with null path, no backtrace";
      }

      else
      {
        v35 = (os_log_s *)__nwlog_obj();
        size_t v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        v54 = "__nw_protocol_updated_path";
        size_t v26 = "%{public}s called with null path, backtrace limit exceeded";
      }

      size_t v48 = v35;
      size_t v49 = v36;
      BOOL v50 = 12;
      goto LABEL_106;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v54 = "__nw_protocol_updated_path";
    dispatch_data_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    nw_txt_record_t v51 = 0;
    if (__nwlog_fault(v31, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_updated_path";
          size_t v34 = "%{public}s called with null other_protocol";
LABEL_99:
          _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
        }
      }

      else if (v51)
      {
        v42 = (char *)__nw_create_backtrace_string();
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        size_t v43 = os_log_type_enabled(v32, type);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            v54 = "__nw_protocol_updated_path";
            os_log_type_t v55 = 2082;
            v56 = v42;
            _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v42);
          goto LABEL_100;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_updated_path";
          size_t v34 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_99;
        }
      }

      else
      {
        size_t v32 = (os_log_s *)__nwlog_obj();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "__nw_protocol_updated_path";
          size_t v34 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_99;
        }
      }
    }

    if (v24) {
      free(v24);
    }
    goto LABEL_110;
  }

  __nwlog_obj();
  char v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  nw_txt_record_t v51 = "nw_protocol_instance_access_cached_content";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  size_t v48 = 0;
  if (__nwlog_fault(v12, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null instance->parent_definition->common_state->deallocate_cache_entry",  buf,  0xCu);
      }

          goto LABEL_109;
        }

        if (!(_BYTE)v104)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v19 = (os_log_s *)(id)gLogObj;
          v44 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v44,  "%{public}s called with null instance->parent_definition->stop, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        size_t v34 = __nw_create_backtrace_string();
        if (!v34)
        {
          __nwlog_obj();
          BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          size_t v48 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v109 = "nw_protocol_implementation_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v48,  "%{public}s called with null instance->parent_definition->stop, no backtrace",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        v35 = (char *)v34;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v36 = (os_log_s *)(id)gLogObj;
        size_t v37 = type[0];
        if (os_log_type_enabled(v36, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v109 = "nw_protocol_implementation_output_finished";
          os_log_type_t v110 = 2082;
          char v111 = v35;
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s called with null instance->parent_definition->stop, dumping backtrace:%{public}s",  buf,  0x16u);
        }

    nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
    if (v26 != &nw_protocol_ref_counted_handle)
    {
LABEL_56:
      if ((v34 & 1) != 0)
      {
LABEL_130:
        os_log_type_t v66 = *(void *)&v22[-1].log_str[25];
        if (v66)
        {
          if (*(_UNKNOWN **)(v66 + 40) == &nw_protocol_ref_counted_handle)
          {
            BOOL v75 = *(void *)(v66 + 88);
            if (v75)
            {
              os_log_type_t v76 = v75 - 1;
              *(void *)(v66 + 88) = v76;
              if (!v76)
              {
                BOOL v77 = *(void (***)(void))(v66 + 64);
                if (v77)
                {
                  *(void *)(v66 + 64) = 0LL;
                  v77[2](v77);
                  _Block_release(v77);
                }

                if ((*(_BYTE *)(v66 + 72) & 1) != 0)
                {
                  os_log_type_t v78 = *(const void **)(v66 + 64);
                  if (v78) {
                    _Block_release(v78);
                  }
                }

                free((void *)v66);
              }
            }
          }

          *(void *)&v22[-1].log_str[25] = 0LL;
        }

        goto LABEL_133;
      }

    *(void *)BOOL v85 = v87;
    v85 += 8;
    --j;
  }

  while (j);
  j = a2[1].u64[0];
  if (v18)
  {
    while (1)
    {
      if (v85 == (char *)v15)
      {
        if (v84 <= v33)
        {
          __srca = v33;
          else {
            int v123 = (v15 - (uint64_t)v33) >> 2;
          }
          __int16 v124 = (uint64_t *)calloc(v123, 8uLL);
          if (!v124) {
            goto LABEL_54;
          }
          v125 = v124;
          v126 = v123 >> 2;
          os_log_type_t v110 = &v124[v123 >> 2];
          BOOL v85 = (char *)v110;
          uint64_t v127 = v15 - (void)v84;
          if ((uint64_t *)v15 != v84)
          {
            BOOL v85 = (char *)v110 + (v127 & 0xFFFFFFFFFFFFFFF8LL);
            v128 = v127 - 8;
            if (v128 >= 0x38)
            {
              v130 = v126;
              if ((unint64_t)((char *)&v124[v126] - (char *)v84) < 0x20)
              {
                v129 = (char *)&v124[v123 >> 2];
                goto LABEL_170;
              }

              v131 = (v128 >> 3) + 1;
              v132 = v131 & 0x3FFFFFFFFFFFFFFCLL;
              v129 = (char *)&v110[v132];
              v133 = (__int128 *)(v84 + 2);
              v134 = &v124[v130 + 2];
              v135 = v131 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v136 = *v133;
                *((_OWORD *)v134 - 1) = *(v133 - 1);
                *(_OWORD *)v134 = v136;
                v133 += 2;
                v134 += 4;
                v135 -= 4LL;
              }

              while (v135);
              if (v131 != (v131 & 0x3FFFFFFFFFFFFFFCLL))
              {
                os_log_type_t v84 = (uint64_t *)((char *)v84 + v132 * 8);
                goto LABEL_170;
              }
            }

            else
            {
              v129 = (char *)&v124[v123 >> 2];
              do
              {
LABEL_170:
                v137 = *v84++;
                *(void *)v129 = v137;
                v129 += 8;
              }

              while (v129 != v85);
            }
          }

          v15 = (uint64_t)&v124[v123];
          if (__srca) {
            free(__srca);
          }
          v33 = v125;
          goto LABEL_148;
        }

        int v117 = v84 - v33;
        if (v117 >= -1) {
          __int16 v118 = v117 + 1;
        }
        else {
          __int16 v118 = v117 + 2;
        }
        unsigned int v119 = v118 >> 1;
        __int16 v120 = (char *)&v84[-(v118 >> 1)];
        v121 = (void *)v15;
        if ((uint64_t *)v15 != v84)
        {
          memmove(v120, v84, v15 - (void)v84);
          v121 = v84;
        }

        __int16 v122 = -v119;
        BOOL v85 = &v120[v15 - (void)v84];
        os_log_type_t v110 = &v121[v122];
      }

      else
      {
        os_log_type_t v110 = v84;
      }

    v38 = 0LL;
    goto LABEL_109;
  }
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v25 = (id)gLogObj;
      else {
        size_t v26 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      v129 = "nw_endpoint_handler_add_extra_interface_option";
      v130 = 2082;
      id_str = (char *)v26;
      v132 = 2082;
      v133 = "flow";
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v124) = 0;
      if (__nwlog_fault(v27, type, &v124))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v28 = (os_log_s *)(id)gLogObj;
          v29 = type[0];
          if (os_log_type_enabled(v28, type[0]))
          {
            else {
              dispatch_data_t v30 = off_189BBBBC0[mode];
            }
            *(_DWORD *)buf = 136446722;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            v130 = 2082;
            id_str = (char *)v30;
            v132 = 2082;
            v133 = "flow";
            _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
          }
        }

        else if ((_BYTE)v124)
        {
          dispatch_data_t v31 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v28 = (os_log_s *)(id)gLogObj;
          size_t v32 = type[0];
          v33 = os_log_type_enabled(v28, type[0]);
          if (v31)
          {
            if (v33)
            {
              else {
                size_t v34 = off_189BBBBC0[mode];
              }
              *(_DWORD *)buf = 136446978;
              v129 = "nw_endpoint_handler_add_extra_interface_option";
              v130 = 2082;
              id_str = (char *)v34;
              v132 = 2082;
              v133 = "flow";
              v134 = 2082;
              v135 = v31;
              _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v31);
            if (!v27) {
              goto LABEL_119;
            }
            goto LABEL_110;
          }

          if (v33)
          {
            else {
              v40 = off_189BBBBC0[mode];
            }
            *(_DWORD *)buf = 136446722;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            v130 = 2082;
            id_str = (char *)v40;
            v132 = 2082;
            v133 = "flow";
            _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v28 = (os_log_s *)(id)gLogObj;
          v38 = type[0];
          if (os_log_type_enabled(v28, type[0]))
          {
            else {
              size_t v39 = off_189BBBBC0[mode];
            }
            *(_DWORD *)buf = 136446722;
            v129 = "nw_endpoint_handler_add_extra_interface_option";
            v130 = 2082;
            id_str = (char *)v39;
            v132 = 2082;
            v133 = "flow";
            _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
          }
        }

        goto LABEL_108;
      }
    }

    if (!v27)
    {
LABEL_119:

      goto LABEL_120;
    }

      goto LABEL_109;
    }
  }

  else
  {
    os_log_type_t v10 = 0LL;
    id v9 = v6;
  }

  v29 = 1LL;
  if (CFStringCompare(v9, v8, 1uLL) == kCFCompareEqualTo)
  {
LABEL_130:
    v33 = 0LL;
LABEL_131:
    os_log_type_t v55 = 0LL;
    dispatch_data_t v31 = (const __CFArray *)v6;
    goto LABEL_157;
  }

  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v4, v9, @".");
  if (!ArrayBySeparatingStrings)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
    size_t v45 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v83 = 0;
    if (!__nwlog_fault((const char *)v45, &type, &v83))
    {
LABEL_127:
      if (v45) {
        free(v45);
      }
      v29 = 0LL;
      goto LABEL_130;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v46 = (os_log_s *)(id)gLogObj;
      int v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        size_t v48 = "%{public}s CFStringCreateArrayBySeparatingStrings failed";
LABEL_124:
        v80 = v46;
        os_log_type_t v81 = v47;
LABEL_125:
        _os_log_impl(&dword_181A5C000, v80, v81, v48, buf, 0xCu);
      }
    }

    else
    {
      if (v83)
      {
        os_log_type_t v66 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v46 = (os_log_s *)(id)gLogObj;
        v67 = type;
        os_log_type_t v68 = os_log_type_enabled(v46, type);
        if (v66)
        {
          if (v68)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
            BOOL v87 = 2082;
            os_log_type_t v88 = v66;
            _os_log_impl( &dword_181A5C000,  v46,  v67,  "%{public}s CFStringCreateArrayBySeparatingStrings failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v66);
          goto LABEL_127;
        }

        if (!v68) {
          goto LABEL_126;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        size_t v48 = "%{public}s CFStringCreateArrayBySeparatingStrings failed, no backtrace";
        v80 = v46;
        os_log_type_t v81 = v67;
        goto LABEL_125;
      }

      __nwlog_obj();
      int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v86 = "nw_endpoint_proxy_string_matches_pattern";
        size_t v48 = "%{public}s CFStringCreateArrayBySeparatingStrings failed, backtrace limit exceeded";
        goto LABEL_124;
      }
    }

      if (v38) {
        free(v38);
      }
      uu = 0uLL;
      if (!a2) {
        return 1LL;
      }
LABEL_11:
      os_log_type_t v7 = a2->callbacks;
      if (v7)
      {
        get_remote_endpoint = (uint64_t (*)(nw_protocol *))v7->get_remote_endpoint;
        if (get_remote_endpoint)
        {
          id v9 = (void *)get_remote_endpoint(a2);
          os_log_type_t v10 = a2->callbacks;
          if (v10)
          {
            get_path = (uint64_t (*)(nw_protocol *))v10->get_path;
            if (get_path) {
              goto LABEL_15;
            }
          }
        }

        else
        {
          id v9 = 0LL;
          get_path = (uint64_t (*)(nw_protocol *))v7->get_path;
          if (get_path)
          {
LABEL_15:
            os_log_type_t v12 = (void *)get_path(a2);
            nw_path_get_client_id(v12, &uu);
          }
        }

        if (v9)
        {
          if (!uuid_is_null((const unsigned __int8 *)&uu))
          {
            memset(out, 0, sizeof(out));
            uuid_unparse((const unsigned __int8 *)&uu, out);
            nw_dictionary_set_value(*((void *)handle + 61), out, v9);
          }
        }
      }

      return 1LL;
    }

    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      nw_txt_record_t v17 = default_input_handler->callbacks;
      if (v17)
      {
        os_log_type_t v18 = (void (*)(void))v17->connected;
        if (v18)
        {
          v18();
          return 1LL;
        }
      }
    }

    __nwlog_obj();
    size_t v24 = a1->default_input_handler;
    __int16 v25 = "invalid";
    if (v24)
    {
      size_t v26 = v24->identifier;
      if (v26) {
        __int16 v25 = (const char *)v26;
      }
    }

    *(_DWORD *)out = 136446466;
    *(void *)&out[4] = "nw_protocol_masque_connect";
    *(_WORD *)&out[12] = 2082;
    *(void *)&out[14] = v25;
    uint64_t v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    os_log_type_t v59 = 0;
    if (__nwlog_fault(v27, &uu, &v59))
    {
      if (uu == 17)
      {
        os_log_type_t v28 = (os_log_s *)__nwlog_obj();
        v29 = uu;
        if (!os_log_type_enabled(v28, (os_log_type_t)uu)) {
          goto LABEL_123;
        }
        dispatch_data_t v30 = a1->default_input_handler;
        dispatch_data_t v31 = "invalid";
        if (v30)
        {
          size_t v32 = v30->identifier;
          if (v32) {
            dispatch_data_t v31 = (const char *)v32;
          }
        }

        *(_DWORD *)out = 136446466;
        *(void *)&out[4] = "nw_protocol_masque_connect";
        *(_WORD *)&out[12] = 2082;
        *(void *)&out[14] = v31;
        v33 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_122;
      }

      if (!v59)
      {
        os_log_type_t v28 = (os_log_s *)__nwlog_obj();
        v29 = uu;
        if (!os_log_type_enabled(v28, (os_log_type_t)uu)) {
          goto LABEL_123;
        }
        size_t v53 = a1->default_input_handler;
        v54 = "invalid";
        if (v53)
        {
          os_log_type_t v55 = v53->identifier;
          if (v55) {
            v54 = (const char *)v55;
          }
        }

        *(_DWORD *)out = 136446466;
        *(void *)&out[4] = "nw_protocol_masque_connect";
        *(_WORD *)&out[12] = 2082;
        *(void *)&out[14] = v54;
        v33 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_122;
      }

      int v46 = (char *)__nw_create_backtrace_string();
      os_log_type_t v28 = (os_log_s *)__nwlog_obj();
      v29 = uu;
      int v47 = os_log_type_enabled(v28, (os_log_type_t)uu);
      if (v46)
      {
        if (v47)
        {
          size_t v48 = a1->default_input_handler;
          size_t v49 = "invalid";
          if (v48)
          {
            BOOL v50 = v48->identifier;
            if (v50) {
              size_t v49 = (const char *)v50;
            }
          }

          *(_DWORD *)out = 136446722;
          *(void *)&out[4] = "nw_protocol_masque_connect";
          *(_WORD *)&out[12] = 2082;
          *(void *)&out[14] = v49;
          *(_WORD *)&out[22] = 2082;
          *(void *)&out[24] = v46;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s",  (uint8_t *)out,  0x20u);
        }

        free(v46);
        goto LABEL_123;
      }

      if (v47)
      {
        v56 = a1->default_input_handler;
        os_log_type_t v57 = "invalid";
        if (v56)
        {
          v58 = v56->identifier;
          if (v58) {
            os_log_type_t v57 = (const char *)v58;
          }
        }

        *(_DWORD *)out = 136446466;
        *(void *)&out[4] = "nw_protocol_masque_connect";
        *(_WORD *)&out[12] = 2082;
        *(void *)&out[14] = v57;
        v33 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_122:
        _os_log_impl(&dword_181A5C000, v28, v29, v33, (uint8_t *)out, 0x16u);
      }
    }

              if (v96)
              {
                v101 = nw_content_context_create("assign address");
                metadata_for_capsule = nw_http_create_metadata_for_capsule(1LL, v96);
                nw_content_context_set_metadata_for_protocol(v101, (nw_protocol_metadata_t)metadata_for_capsule);
                nw_connection_send( *(nw_connection_t *)(*(void *)(*(void *)(a1 + 32) + 16LL) + 48LL),  0LL,  v101,  1,  &__block_literal_global_24170);
              }

              if (v98)
              {
                os_log_type_t v103 = nw_content_context_create("advertise route");
                BOOL v104 = nw_http_create_metadata_for_capsule(3LL, v98);
                nw_content_context_set_metadata_for_protocol(v103, (nw_protocol_metadata_t)v104);
                nw_connection_send( *(nw_connection_t *)(*(void *)(*(void *)(a1 + 32) + 16LL) + 48LL),  0LL,  v103,  1,  &__block_literal_global_24170);
              }

LABEL_113:
LABEL_62:
              nw_masque_connection_pair_cancel_waiting_timer(*(NWConcrete_nw_masque_connection_pair **)(a1 + 32));
              goto LABEL_63;
            }

        goto LABEL_109;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v76 = (os_log_type_t)v88.receiver;
        if (os_log_type_enabled(v59, (os_log_type_t)v88.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
          _os_log_impl( &dword_181A5C000,  v59,  v76,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v70 = (os_log_type_t)v88.receiver;
      BOOL v71 = os_log_type_enabled(v59, (os_log_type_t)v88.receiver);
      if (!v67)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_181A5C000, v59, v70, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }

        goto LABEL_108;
      }

      if (v71)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v67;
        _os_log_impl( &dword_181A5C000,  v59,  v70,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_88;
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
    v58 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v88.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v58, &v88, &type))
    {
      if (LOBYTE(v88.receiver) == 17)
      {
        __nwlog_obj();
        os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v60 = (os_log_type_t)v88.receiver;
        if (os_log_type_enabled(v59, (os_log_type_t)v88.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_181A5C000, v59, v60, "%{public}s called with null connection", buf, 0xCu);
        }

        goto LABEL_108;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v75 = (os_log_type_t)v88.receiver;
        if (os_log_type_enabled(v59, (os_log_type_t)v88.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
          _os_log_impl( &dword_181A5C000,  v59,  v75,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v68 = (os_log_type_t)v88.receiver;
      v69 = os_log_type_enabled(v59, (os_log_type_t)v88.receiver);
      if (!v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_181A5C000, v59, v68, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }

        goto LABEL_108;
      }

      if (v69)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_create";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v67;
        _os_log_impl( &dword_181A5C000,  v59,  v68,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    if (v39) {
      free(v39);
    }
    if (v28) {
      free(v28);
    }
    goto LABEL_112;
  }

  if (!http2_transport_output_frame_context_reset(v30, (uint64_t)handle, (uint64_t)a2))
  {
    size_t v43 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v82 = 136446466;
      os_log_type_t v83 = "http2_transport_create_output_frame";
      os_log_type_t v84 = 2082;
      BOOL v85 = (uint64_t)handle + 205;
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s output frame has no metadata",  v82,  0x16u);
    }

    buffer = (void *)nw_frame_get_buffer(v79[3], 0LL);
    if (buffer) {
      free(buffer);
    }
    nw_frame_reset(v79[3], 0LL, 0, 0LL, 0LL);
    size_t v45 = (void *)v79[3];
    if (v45)
    {
      os_release(v45);
      v79[3] = 0LL;
    }

          int v47 = v37;
LABEL_109:
          CFRelease(v47);
          goto LABEL_110;
        }

        if (v34 == 1)
        {
          __nwlog_obj();
          nw_txt_record_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 227;
            size_t v52 = "%{public}s %{public}s server response contains multiple permessage-deflate extensions";
LABEL_107:
            _os_log_impl(&dword_181A5C000, v51, OS_LOG_TYPE_ERROR, v52, buf, 0x16u);
          }

          goto LABEL_108;
        }

        size_t v39 = 0;
        for (j = 1LL; ; ++j)
        {
          while (1)
          {
            while (1)
            {
              if (j >= CFArrayGetCount(v37))
              {
                CFRelease(v37);
                ++v34;
                goto LABEL_49;
              }

              size_t v41 = (const __CFString *)CFArrayGetValueAtIndex(v37, j);
              *(void *)os_log_type_t v68 = 0LL;
              if (CFStringCompare(v41, @"server_no_context_takeover", 1uLL)) {
                break;
              }
              if ((v39 & 1) != 0)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                size_t v43 = v42;
                v44 = "%{public}s %{public}s Duplicate use of parameter server_no_context_takeover";
                size_t v45 = 22;
                goto LABEL_87;
              }

              v39 |= 1u;
              *(_WORD *)(a1 + 225) &= ~0x80u;
              ++j;
            }

            if (CFStringCompare(v41, @"client_no_context_takeover", 1uLL) == kCFCompareEqualTo) {
              break;
            }
            if (nw_ws_get_extension_parameter(v41, @"server_max_window_bits", (unint64_t *)v68))
            {
              if ((v39 & 4) != 0)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
LABEL_77:
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                size_t v43 = v42;
                v44 = "%{public}s %{public}s Duplicate use of parameter server_max_window_bits";
                size_t v45 = 22;
                goto LABEL_87;
              }

              if ((*(void *)v68 & 0xFFFFFFFFFFFFFFF8LL) != 8)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                *(_WORD *)&buf[22] = 2048;
                os_log_type_t v74 = *(const __CFString **)v68;
                size_t v43 = v42;
                v44 = "%{public}s %{public}s Invalid value for server_max_window_bits (%llu)";
LABEL_86:
                size_t v45 = 32;
                goto LABEL_87;
              }

              v39 |= 4u;
              *(_BYTE *)(a1 + 220) = v68[0];
              ++j;
            }

            else
            {
              if (!nw_ws_get_extension_parameter(v41, @"client_max_window_bits", (unint64_t *)v68))
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                *(_WORD *)&buf[22] = 2112;
                os_log_type_t v74 = v41;
                size_t v43 = v42;
                v44 = "%{public}s %{public}s Invalid parameter in server permessage-deflate response (%@)";
                goto LABEL_86;
              }

              if ((v39 & 8) != 0)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                goto LABEL_77;
              }

              if ((*(void *)v68 & 0xFFFFFFFFFFFFFFF8LL) != 8)
              {
                __nwlog_obj();
                v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                *(_WORD *)&buf[22] = 2048;
                os_log_type_t v74 = *(const __CFString **)v68;
                size_t v43 = v42;
                v44 = "%{public}s %{public}s Invalid value for client_max_window_bits (%llu)";
                goto LABEL_86;
              }

              v39 |= 8u;
              *(_BYTE *)(a1 + 221) = v68[0];
              ++j;
            }
          }

          if ((v39 & 2) != 0) {
            break;
          }
          v39 |= 2u;
          *(_WORD *)(a1 + 225) &= ~0x100u;
        }

        __nwlog_obj();
        v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          goto LABEL_88;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 227;
        size_t v43 = v42;
        v44 = "%{public}s %{public}s Duplicate use of parameter client_no_context_takeover";
        size_t v45 = 22;
LABEL_87:
        _os_log_impl(&dword_181A5C000, v43, OS_LOG_TYPE_ERROR, v44, buf, v45);
LABEL_88:

        CFRelease(v37);
        ++v34;
      }

      int v47 = 0LL;
LABEL_99:
      __nwlog_obj();
      BOOL v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 227;
        *(_WORD *)&buf[22] = 2112;
        os_log_type_t v74 = ValueAtIndex;
        _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response contains an extension that was not negotiated (%@",  buf,  0x20u);
      }

      if (v37) {
        goto LABEL_109;
      }
LABEL_110:
      size_t v49 = 0;
LABEL_111:
      if (theArray)
      {
        size_t v53 = v49;
        CFRelease(theArray);
        size_t v49 = v53;
      }

      if ((v49 & 1) == 0) {
        goto LABEL_116;
      }
    }

    else if ((*(_WORD *)(a1 + 225) & 0x40) != 0)
    {
      __nwlog_obj();
      int v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_INFO,  "%{public}s Not using per-message-deflate compression because server response did not include it in negotiated extensions",  buf,  0xCu);
      }

      *(_WORD *)(a1 + 225) &= ~0x40u;
    }

    v54 = CFHTTPMessageCopyAllHeaderFields(v2);
    os_log_type_t v55 = v54;
    if (v54)
    {
      CFDictionaryApplyFunction( v54,  (CFDictionaryApplierFunction)nw_ws_copy_headers_into_ws_response,  *(void **)(a1 + 48));
      CFRelease(v55);
      return 1LL;
    }

    __nwlog_obj();
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();

    v68[0] = 16;
    os_log_type_t v66 = 0;
    if (v68[0] == 17)
    {
      __nwlog_obj();
      v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = v68[0];
      if (os_log_type_enabled(v58, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl(&dword_181A5C000, v58, v59, "%{public}s CFHTTPMessageCopyAllHeaderFields failed", buf, 0xCu);
      }
    }

    else if (v66)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v61 = v68[0];
      v62 = os_log_type_enabled(v58, (os_log_type_t)v68[0]);
      if (backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v58,  v61,  "%{public}s CFHTTPMessageCopyAllHeaderFields failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_133;
      }

      if (v62)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl( &dword_181A5C000,  v58,  v61,  "%{public}s CFHTTPMessageCopyAllHeaderFields failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v63 = v68[0];
      if (os_log_type_enabled(v58, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl( &dword_181A5C000,  v58,  v63,  "%{public}s CFHTTPMessageCopyAllHeaderFields failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_133:
    if (v57) {
      free(v57);
    }
    return 0LL;
  }

  if (CFStringFind(v28, @",", 0LL).location != -1)
  {
    __nwlog_obj();
    dispatch_data_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response contains multiple Sec-WebSocket-Protocol values",  buf,  0x16u);
    }

    CFRelease(v29);
LABEL_116:
    result = 0LL;
    v13 = 4;
    goto LABEL_13;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  LOBYTE(v74) = 0;
  size_t v32 = *(void **)(a1 + 16);
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = __nw_ws_validate_server_response_block_invoke;
  applier[3] = &unk_189BC5538;
  applier[4] = buf;
  applier[5] = v29;
  xpc_array_apply(v32, applier);
  if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
  {
    CFRelease(v29);
    _Block_object_dispose(buf, 8);
    goto LABEL_47;
  }

  __nwlog_obj();
  size_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)os_log_type_t v68 = 136446722;
    *(void *)&v68[4] = "nw_ws_validate_server_response";
    v69 = 2082;
    os_log_type_t v70 = a1 + 227;
    BOOL v71 = 2112;
    os_log_type_t v72 = v29;
    _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response contains a Sec-WebSocket-Protocol value that was not advertised (%@)",  v68,  0x20u);
  }

  CFRelease(v29);
  *(_DWORD *)(a1 + 212) = 4;
  _Block_object_dispose(buf, 8);
  return 0LL;
}

          goto LABEL_109;
        }

        if (!v145[0])
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          size_t v23 = (os_log_s *)(id)gbrowserLogObj;
          os_log_type_t v66 = type[0];
          if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
          {
            v67 = v3[48]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_browser_start";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v67;
            _os_log_impl( &dword_181A5C000,  v23,  v66,  "%{public}s [B%u] nw_browser_start called on an invalid browser, backtrace limit exceeded",  buf,  0x12u);
          }

          goto LABEL_108;
        }

        size_t v48 = __nw_create_backtrace_string();
        if (!v48)
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          size_t v23 = (os_log_s *)(id)gbrowserLogObj;
          os_log_type_t v68 = type[0];
          if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
          {
            v69 = v3[48]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_browser_start";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v69;
            _os_log_impl( &dword_181A5C000,  v23,  v68,  "%{public}s [B%u] nw_browser_start called on an invalid browser, no backtrace",  buf,  0x12u);
          }

          goto LABEL_108;
        }

        size_t v49 = (char *)v48;
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        BOOL v50 = (os_log_s *)(id)gbrowserLogObj;
        nw_txt_record_t v51 = type[0];
        if (os_log_type_enabled(v50, (os_log_type_t)type[0]))
        {
          size_t v52 = v3[48]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_browser_start";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v52;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v49;
          _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s [B%u] nw_browser_start called on an invalid browser, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v49);
LABEL_109:
        if (!v22) {
          goto LABEL_152;
        }
        free(v22);
        os_log_type_t v70 = 2;
        goto LABEL_185;
      case 1u:
        os_log_type_t v28 = v3;
        v29 = nw_browse_descriptor_copy_custom_browse_block(*(void **)&v28[8]._os_unfair_lock_opaque);
        if (v29)
        {
          dispatch_data_t v30 = v29;
          if (!nw_parameters_get_logging_disabled(*(void *)&v28[10]._os_unfair_lock_opaque))
          {
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            dispatch_data_t v31 = (os_log_s *)(id)gbrowserLogObj;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              size_t v32 = v28[48]._os_unfair_lock_opaque;
              *(_DWORD *)os_log_type_t type = 136446466;
              *(void *)&type[4] = "nw_browser_start_custom_browser_locked";
              *(_WORD *)&type[12] = 1024;
              *(_DWORD *)&type[14] = v32;
              _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_DEFAULT,  "%{public}s [B%u] start: custom browser",  type,  0x12u);
            }
          }

          v33 = nw_parameters_copy_context(*(void **)&v28[10]._os_unfair_lock_opaque);
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke;
          *(void *)&buf[24] = &unk_189BC91E8;
          size_t v34 = v30;
          v141 = v34;
          v35 = v28;
          *(void *)&buf[32] = v35;
          nw_queue_context_async(v33, buf);

          goto LABEL_184;
        }

        __nwlog_obj();
        v130 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)os_log_type_t type = 136446210;
        *(void *)&type[4] = "nw_browser_start_custom_browser_locked";
        v131 = (char *)_os_log_send_and_compose_impl();

        v145[0] = 16;
        v139 = OS_LOG_TYPE_DEFAULT;
        if (v145[0] == 17)
        {
          __nwlog_obj();
          v132 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v133 = v145[0];
          if (os_log_type_enabled(v132, (os_log_type_t)v145[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            *(void *)&type[4] = "nw_browser_start_custom_browser_locked";
            _os_log_impl(&dword_181A5C000, v132, v133, "%{public}s called with null browser_block", type, 0xCu);
          }
        }

        else if (v139)
        {
          v134 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v132 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v135 = v145[0];
          v136 = os_log_type_enabled(v132, (os_log_type_t)v145[0]);
          if (v134)
          {
            if (v136)
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              *(void *)&type[4] = "nw_browser_start_custom_browser_locked";
              *(_WORD *)&type[12] = 2082;
              *(void *)&type[14] = v134;
              _os_log_impl( &dword_181A5C000,  v132,  v135,  "%{public}s called with null browser_block, dumping backtrace:%{public}s",  type,  0x16u);
            }

            free(v134);
            goto LABEL_245;
          }

          if (v136)
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            *(void *)&type[4] = "nw_browser_start_custom_browser_locked";
            _os_log_impl( &dword_181A5C000,  v132,  v135,  "%{public}s called with null browser_block, no backtrace",  type,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v132 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v137 = v145[0];
          if (os_log_type_enabled(v132, (os_log_type_t)v145[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            *(void *)&type[4] = "nw_browser_start_custom_browser_locked";
            _os_log_impl( &dword_181A5C000,  v132,  v137,  "%{public}s called with null browser_block, backtrace limit exceeded",  type,  0xCu);
          }
        }

LABEL_245:
        if (v131) {
          free(v131);
        }

        goto LABEL_152;
      case 2u:
        goto LABEL_175;
      case 3u:
        size_t v36 = v3;
        if (!nw_parameters_get_logging_disabled(*(void *)&v36[10]._os_unfair_lock_opaque))
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          size_t v37 = (os_log_s *)(id)gbrowserLogObj;
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            v38 = v36[48]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_browser_start_dns_browser_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v38;
            _os_log_impl(&dword_181A5C000, v37, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] start: dns browser", buf, 0x12u);
          }
        }

        if (nw_browse_descriptor_get_type(*(void **)&v36[8]._os_unfair_lock_opaque) == 1)
        {
          if (nw_browse_descriptor_is_meta_query(*(void **)&v36[8]._os_unfair_lock_opaque))
          {
            size_t v39 = "Invalid meta query type specified. nw_browser_start_dns_browser_locked";
LABEL_150:
            nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v36, -65540, v39);
LABEL_151:

LABEL_152:
            os_log_type_t v70 = 2;
            goto LABEL_185;
          }

          size_t v53 = getpid();
          if (!nw_parameters_has_delegated_proc_pid(*(void **)&v36[10]._os_unfair_lock_opaque, v53)
            && !nw_parameters_has_delegated_proc_uuid(*(void **)&v36[10]._os_unfair_lock_opaque))
          {
            Connection = DNSServiceCreateConnection((DNSServiceRef *)&v36[30]);
            goto LABEL_139;
          }

          if (nw_parameters_has_delegated_proc_pid(*(void **)&v36[10]._os_unfair_lock_opaque, v53))
          {
            pid = nw_parameters_get_pid(*(void **)&v36[10]._os_unfair_lock_opaque);
            if (!nw_parameters_get_logging_disabled(*(void *)&v36[10]._os_unfair_lock_opaque))
            {
              if (__nwlog_browser_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
              }
              os_log_type_t v55 = (os_log_s *)(id)gbrowserLogObj;
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
              {
                v56 = v36[48]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_browser_start_dns_browser_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v56;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = pid;
                _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] Delegating DNS service to PID %d",  buf,  0x18u);
              }
            }

            Connection = DNSServiceCreateDelegateConnection();
            if (!Connection)
            {
LABEL_139:
              if (nw_browser_fail_on_dns_error_locked( (NWConcrete_nw_browser *)v36,  Connection,  "DNSServiceCreateConnection"))
              {
                goto LABEL_151;
              }

              os_log_type_t v81 = *(_DNSServiceRef_t **)&v36[30]._os_unfair_lock_opaque;
              v82 = nw_parameters_copy_context(*(void **)&v36[10]._os_unfair_lock_opaque);
              os_log_type_t v83 = nw_context_copy_workloop(v82);
              LODWORD(v81) = DNSServiceSetDispatchQueue(v81, (dispatch_queue_t)v83);

              if (nw_browser_fail_on_dns_error_locked( (NWConcrete_nw_browser *)v36,  (int)v81,  "DNSServiceSetDispatchQueue"))
              {
                goto LABEL_151;
              }

              *(void *)&v36[32]._os_unfair_lock_opaque = *(void *)&v36[30]._os_unfair_lock_opaque;
              os_log_type_t v84 = nw_parameters_copy_required_interface(*(nw_parameters_t *)&v36[10]._os_unfair_lock_opaque);
              BOOL v85 = (char *)v84;
              if (v84) {
                os_log_type_t v86 = *((unsigned int *)v84 + 2);
              }
              else {
                os_log_type_t v86 = 0LL;
              }
              os_log_type_t v90 = nw_browser_derive_endpoint_flags((NWConcrete_nw_browser *)v36);
              bonjour_service_os_log_type_t type = nw_browse_descriptor_get_bonjour_service_type(*(nw_browse_descriptor_t *)&v36[8]._os_unfair_lock_opaque);
              bonjour_service_domain = nw_browse_descriptor_get_bonjour_service_domain(*(nw_browse_descriptor_t *)&v36[8]._os_unfair_lock_opaque);
              if (BYTE1(v36[49]._os_unfair_lock_opaque)) {
                v93 = MEMORY[0x1895FB898];
              }
              else {
                v93 = 0LL;
              }
              os_log_type_t v94 = MEMORY[0x186E0F90C]( &v36[32],  v90,  v86,  bonjour_service_type,  bonjour_service_domain,  v93,  nw_browser_dns_service_browse_callback,  v36);
              if (nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v36, v94, "DNSServiceBrowse"))
              {

                goto LABEL_152;
              }

              if ((_DWORD)v86 && !nw_parameters_get_logging_disabled(*(void *)&v36[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                }
                os_log_type_t v95 = (os_log_s *)(id)gbrowserLogObj;
                if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
                {
                  BOOL v96 = "any";
                  os_log_type_t v97 = v36[48]._os_unfair_lock_opaque;
                  *(void *)&uint8_t buf[4] = "nw_browser_start_dns_browser_locked";
                  *(_DWORD *)buf = 136446978;
                  if (v85) {
                    BOOL v96 = v85 + 104;
                  }
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v97;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v96;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v86;
                  _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] Scoping browse to %{public}s [%d]",  buf,  0x22u);
                }
              }

              if (!nw_parameters_get_logging_disabled(*(void *)&v36[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                }
                BOOL v98 = (os_log_s *)(id)gbrowserLogObj;
                if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
                {
                  os_log_type_t v99 = v36[48]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_browser_start_dns_browser_locked";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v99;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v90;
                  _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] dns: start browse with flags %#x",  buf,  0x18u);
                }
              }

LABEL_175:
              os_log_type_t v100 = v3;
              if (!nw_parameters_get_logging_disabled(*(void *)&v100[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
                }
                v101 = (os_log_s *)(id)gbrowserLogObj;
                if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                {
                  os_log_type_t v102 = v100[48]._os_unfair_lock_opaque;
                  *(_DWORD *)v145 = 136446466;
                  v146 = "nw_browser_start_path_browser_locked";
                  v147 = 1024;
                  LODWORD(v148) = v102;
                  _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEFAULT,  "%{public}s [B%u] path: start browser",  v145,  0x12u);
                }
              }

              os_log_type_t v103 = (void **)&v100[22];
              if (*(void *)&v100[22]._os_unfair_lock_opaque || *(void *)&v100[24]._os_unfair_lock_opaque)
              {

LABEL_184:
                os_log_type_t v70 = 1;
LABEL_185:
                nw_browser_set_state_locked(v3, v70, 0LL);
                os_unfair_lock_unlock(v3 + 2);
                goto LABEL_186;
              }

              evaluator_for_browse = nw_path_create_evaluator_for_browse( *(void **)&v100[8]._os_unfair_lock_opaque,  *(void **)&v100[10]._os_unfair_lock_opaque);
              if (evaluator_for_browse)
              {
                os_log_type_t v105 = MEMORY[0x1895F87A8];
                *(void *)buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = ___ZL36nw_browser_start_path_browser_lockedP21NWConcrete_nw_browser_block_invoke;
                *(void *)&buf[24] = &unk_189BC8678;
                os_log_type_t v106 = v100;
                *(void *)&buf[32] = v106;
                nw_path_evaluator_set_update_handler(evaluator_for_browse, 0LL, buf);
                objc_storeStrong((id *)&v100[22], evaluator_for_browse);
                os_log_type_t v107 = (os_unfair_lock_s *)*v103;
                if (*v103)
                {
                  BOOL v108 = v107 + 24;
                  os_log_type_t v109 = v107;
                  os_unfair_lock_lock(v108);
                  os_log_type_t v110 = v109[6];
                  os_unfair_lock_unlock(v108);
                }

                else
                {
                  os_log_type_t v110 = 0LL;
                }

                v115 = *(void **)&v100[24]._os_unfair_lock_opaque;
                *(void *)&v100[24]._os_unfair_lock_opaque = v110;

                __int16 v116 = nw_parameters_copy_context(*(void **)&v100[10]._os_unfair_lock_opaque);
                *(void *)os_log_type_t type = v105;
                *(void *)&type[8] = 3221225472LL;
                *(void *)&os_log_type_t type[16] = ___ZL36nw_browser_start_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2;
                v143 = &unk_189BC93A0;
                int v117 = v106;
                v144 = v117;
                nw_queue_context_async(v116, type);

                goto LABEL_184;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v111 = (id)gLogObj;
              *(_DWORD *)v145 = 136446210;
              v146 = "nw_browser_start_path_browser_locked";
              os_log_type_t v112 = (char *)_os_log_send_and_compose_impl();

              v139 = OS_LOG_TYPE_ERROR;
              v138 = 0;
              if ((__nwlog_fault(v112, &v139, &v138) & 1) != 0)
              {
                if (v139 == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v113 = (os_log_s *)(id)gLogObj;
                  v114 = v139;
                  if (os_log_type_enabled(v113, v139))
                  {
                    *(_DWORD *)v145 = 136446210;
                    v146 = "nw_browser_start_path_browser_locked";
                    _os_log_impl( &dword_181A5C000,  v113,  v114,  "%{public}s nw_path_create_evaluator_for_browse failed",  v145,  0xCu);
                  }
                }

                else if (v138)
                {
                  __int16 v118 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  unsigned int v119 = v139;
                  __int16 v120 = os_log_type_enabled(v113, v139);
                  if (v118)
                  {
                    if (v120)
                    {
                      *(_DWORD *)v145 = 136446466;
                      v146 = "nw_browser_start_path_browser_locked";
                      v147 = 2082;
                      v148 = v118;
                      _os_log_impl( &dword_181A5C000,  v113,  v119,  "%{public}s nw_path_create_evaluator_for_browse failed, dumping backtrace:%{public}s",  v145,  0x16u);
                    }

                    free(v118);
                    goto LABEL_213;
                  }

                  if (v120)
                  {
                    *(_DWORD *)v145 = 136446210;
                    v146 = "nw_browser_start_path_browser_locked";
                    _os_log_impl( &dword_181A5C000,  v113,  v119,  "%{public}s nw_path_create_evaluator_for_browse failed, no backtrace",  v145,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v125 = v139;
                  if (os_log_type_enabled(v113, v139))
                  {
                    *(_DWORD *)v145 = 136446210;
                    v146 = "nw_browser_start_path_browser_locked";
                    _os_log_impl( &dword_181A5C000,  v113,  v125,  "%{public}s nw_path_create_evaluator_for_browse failed, backtrace limit exceeded",  v145,  0xCu);
                  }
                }
              }

          free(v47);
          if (!v39) {
            goto LABEL_29;
          }
          goto LABEL_125;
        }

        __nwlog_obj();
        v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        size_t v41 = type;
        if (!os_log_type_enabled(v40, type)) {
          goto LABEL_123;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        v42 = "%{public}s called with null endpoint";
      }

      else
      {
        __nwlog_obj();
        v38 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        size_t v39 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        nw_txt_record_t v51 = 0;
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (v51)
          {
            size_t v45 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            size_t v41 = type;
            int v46 = os_log_type_enabled(v40, type);
            if (v45)
            {
              if (v46)
              {
                *(_DWORD *)block = 136446466;
                *(void *)&block[4] = "nw_storage_remove_items";
                *(_WORD *)&block[12] = 2082;
                *(void *)&block[14] = v45;
                _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s called with null storage, dumping backtrace:%{public}s",  block,  0x16u);
              }

              free(v45);
LABEL_124:
              if (!v39) {
                goto LABEL_29;
              }
LABEL_125:
              free(v39);
              goto LABEL_29;
            }

            if (v46)
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              v42 = "%{public}s called with null storage, no backtrace";
              goto LABEL_122;
            }
          }

          else
          {
            __nwlog_obj();
            v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            size_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              v42 = "%{public}s called with null storage, backtrace limit exceeded";
              goto LABEL_122;
            }
          }

          goto LABEL_123;
        }

        __nwlog_obj();
        v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        size_t v41 = type;
        if (!os_log_type_enabled(v40, type)) {
          goto LABEL_123;
        }
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        v42 = "%{public}s called with null storage";
      }

      if (v17) {
        free(v17);
      }
      return 0LL;
    }

    if (!v34)
    {
      os_log_type_t v18 = (os_log_s *)__nwlog_obj();
      BOOL v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        os_log_type_t v20 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
        goto LABEL_107;
      }

      goto LABEL_108;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v18 = (os_log_s *)__nwlog_obj();
    BOOL v19 = type;
    v33 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        size_t v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        os_log_type_t v20 = "%{public}s called with null out_encrypted_length, no backtrace";
        goto LABEL_107;
      }

      goto LABEL_108;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      size_t v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
      v38 = 2082;
      size_t v39 = (uint64_t)backtrace_string;
      uint64_t v27 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    if (v48) {
      free(v48);
    }
    goto LABEL_110;
  }

  memcpy(v34, a4, a5);
  *(void *)(v13 + 32) = 0LL;
  size_t v39 = *(uint64_t **)(v11 + 8);
  *(void *)(v13 + 40) = v39;
  *size_t v39 = v13;
  *(void *)(v11 + 8) = v13 + 32;
  v40 = *(void *)(v11 + 80);
  *(void *)(v11 + 80) = v40 + a5;
  if (__CFADD__(v40, a5))
  {
    if (gLogDatapath)
    {
      BOOL v87 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v88 = *(void *)(v11 + 80);
        *(_DWORD *)buf = 136446978;
        BOOL v98 = "increment_inbound_body_size";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = "inbound_body_size";
        v101 = 2048;
        os_log_type_t v102 = (const char *)a5;
        os_log_type_t v103 = 2048;
        *(void *)BOOL v104 = v88;
        _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
      }
    }

    *(void *)(v11 + 80) = -1LL;
  }

  size_t v41 = (*(unsigned __int8 *)(v11 + 190) >> 3) & 1;
  if (!gLogDatapath) {
    LOBYTE(v41) = 1;
  }
  if ((*(_WORD *)(v11 + 188) & 1) != 0)
  {
    if ((v41 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v89 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v91 = *(_DWORD *)(v11 + 176);
        os_log_type_t v90 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = (const char *)(v11 + 191);
        v101 = 2080;
        os_log_type_t v102 = " ";
        os_log_type_t v103 = 1024;
        *(_DWORD *)BOOL v104 = v90;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v91;
        os_log_type_t v105 = 2048;
        *(void *)os_log_type_t v106 = *(void *)v95;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v91;
        _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> calling input_available on protocol %p for stream %d",  buf,  0x3Cu);
      }
    }

    if (*(void *)v95)
    {
      v54 = *(void *)(*(void *)v95 + 24LL);
      if (v54)
      {
        os_log_type_t v55 = *(void (**)(void))(v54 + 64);
        if (v55)
        {
          v55();
          return 0LL;
        }
      }
    }

    __nwlog_obj();
    os_log_type_t v78 = "invalid";
    if (*(void *)v95 && *(void *)(*(void *)v95 + 16LL)) {
      os_log_type_t v78 = *(const char **)(*(void *)v95 + 16LL);
    }
    *(_DWORD *)buf = 136446466;
    BOOL v98 = "on_data_chunk_recv_callback";
    os_log_type_t v99 = 2082;
    os_log_type_t v100 = v78;
    BOOL v79 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = 0;
    if (__nwlog_fault(v79, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v80 = (os_log_s *)__nwlog_obj();
        os_log_type_t v81 = type;
        if (!os_log_type_enabled(v80, type)) {
          goto LABEL_168;
        }
        v82 = "invalid";
        if (*(void *)v95 && *(void *)(*(void *)v95 + 16LL)) {
          v82 = *(const char **)(*(void *)v95 + 16LL);
        }
        *(_DWORD *)buf = 136446466;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = v82;
        os_log_type_t v83 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_167;
      }

      if (!v94)
      {
        v80 = (os_log_s *)__nwlog_obj();
        os_log_type_t v81 = type;
        if (!os_log_type_enabled(v80, type)) {
          goto LABEL_168;
        }
        os_log_type_t v92 = "invalid";
        if (*(void *)v95 && *(void *)(*(void *)v95 + 16LL)) {
          os_log_type_t v92 = *(const char **)(*(void *)v95 + 16LL);
        }
        *(_DWORD *)buf = 136446466;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = v92;
        os_log_type_t v83 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_167;
      }

      os_log_type_t v84 = (char *)__nw_create_backtrace_string();
      v80 = (os_log_s *)__nwlog_obj();
      os_log_type_t v81 = type;
      BOOL v85 = os_log_type_enabled(v80, type);
      if (v84)
      {
        if (v85)
        {
          os_log_type_t v86 = "invalid";
          if (*(void *)v95 && *(void *)(*(void *)v95 + 16LL)) {
            os_log_type_t v86 = *(const char **)(*(void *)v95 + 16LL);
          }
          *(_DWORD *)buf = 136446722;
          BOOL v98 = "on_data_chunk_recv_callback";
          os_log_type_t v99 = 2082;
          os_log_type_t v100 = v86;
          v101 = 2082;
          os_log_type_t v102 = v84;
          _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v84);
        goto LABEL_168;
      }

      if (v85)
      {
        v93 = "invalid";
        if (*(void *)v95 && *(void *)(*(void *)v95 + 16LL)) {
          v93 = *(const char **)(*(void *)v95 + 16LL);
        }
        *(_DWORD *)buf = 136446466;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = v93;
        os_log_type_t v83 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_167:
        _os_log_impl(&dword_181A5C000, v80, v81, v83, buf, 0x16u);
      }
    }

          if (v62) {
            free(v62);
          }
          *(_DWORD *)(v18 + 184) = 0x200000;
          goto LABEL_111;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = *(int *)(v18 + 184);
        *(_DWORD *)buf = 136446978;
        v93 = "nw_protocol_http2_frame_input_finalizer";
        os_log_type_t v94 = 2082;
        os_log_type_t v95 = "stream->window_remaining";
        BOOL v96 = 2048;
        os_log_type_t v97 = v21;
        BOOL v98 = 2048;
        *(void *)os_log_type_t v99 = v35;
        size_t v36 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v90 = 0;
        if (__nwlog_fault(v36, &type, &v90))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            size_t v37 = (os_log_s *)gLogObj;
            v38 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              size_t v39 = *(int *)(v18 + 184);
              *(_DWORD *)buf = 136446978;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              os_log_type_t v94 = 2082;
              os_log_type_t v95 = "stream->window_remaining";
              BOOL v96 = 2048;
              os_log_type_t v97 = v21;
              BOOL v98 = 2048;
              *(void *)os_log_type_t v99 = v39;
              v40 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_69:
              _os_log_impl(&dword_181A5C000, v37, v38, v40, buf, 0x2Au);
            }
          }

          else if (v90)
          {
            v42 = v21;
            char v21 = (char *)__nw_create_backtrace_string();
            size_t v37 = (os_log_s *)__nwlog_obj();
            v38 = type;
            size_t v43 = os_log_type_enabled(v37, type);
            if (v21)
            {
              if (v43)
              {
                v44 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136447234;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                os_log_type_t v94 = 2082;
                os_log_type_t v95 = "stream->window_remaining";
                BOOL v96 = 2048;
                os_log_type_t v97 = (char *)v42;
                BOOL v98 = 2048;
                *(void *)os_log_type_t v99 = v44;
                *(_WORD *)&v99[8] = 2082;
                *(void *)&v99[10] = v21;
                _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v21);
              LODWORD(v21) = (_DWORD)v42;
              goto LABEL_70;
            }

            LODWORD(v21) = (_DWORD)v42;
            if (v43)
            {
              int v46 = *(int *)(v18 + 184);
              *(_DWORD *)buf = 136446978;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              os_log_type_t v94 = 2082;
              os_log_type_t v95 = "stream->window_remaining";
              BOOL v96 = 2048;
              os_log_type_t v97 = (char *)v42;
              BOOL v98 = 2048;
              *(void *)os_log_type_t v99 = v46;
              v40 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_69;
            }
          }

          else
          {
            size_t v37 = (os_log_s *)__nwlog_obj();
            v38 = type;
            if (os_log_type_enabled(v37, type))
            {
              size_t v45 = *(int *)(v18 + 184);
              *(_DWORD *)buf = 136446978;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              os_log_type_t v94 = 2082;
              os_log_type_t v95 = "stream->window_remaining";
              BOOL v96 = 2048;
              os_log_type_t v97 = v21;
              BOOL v98 = 2048;
              *(void *)os_log_type_t v99 = v45;
              v40 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_69;
            }
          }
        }

      if (v35) {
        free(v35);
      }
LABEL_110:
      output_handler = a1->output_handler;
      if (output_handler)
      {
        callbacks = output_handler->callbacks;
        if (callbacks)
        {
          connect = (void (*)(nw_protocol *, nw_protocol *))callbacks->connect;
          if (connect)
          {
            connect(output_handler, a1);
            return 1LL;
          }
        }
      }

      __nwlog_obj();
      os_log_type_t v68 = a1->output_handler;
      v69 = "invalid";
      if (v68)
      {
        identifier = v68->identifier;
        if (identifier) {
          v69 = (const char *)identifier;
        }
      }

      *(_DWORD *)buf = 136446466;
      os_log_type_t v102 = "nw_protocol_http2_connect";
      os_log_type_t v103 = 2082;
      BOOL v104 = (char *)v69;
      BOOL v71 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v99 = 0;
      if (__nwlog_fault(v71, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v72 = (os_log_s *)__nwlog_obj();
          BOOL v73 = type;
          if (!os_log_type_enabled(v72, type)) {
            goto LABEL_210;
          }
          os_log_type_t v74 = a1->output_handler;
          BOOL v75 = "invalid";
          if (v74)
          {
            os_log_type_t v76 = v74->identifier;
            if (v76) {
              BOOL v75 = (const char *)v76;
            }
          }

          *(_DWORD *)buf = 136446466;
          os_log_type_t v102 = "nw_protocol_http2_connect";
          os_log_type_t v103 = 2082;
          BOOL v104 = (char *)v75;
          BOOL v77 = "%{public}s protocol %{public}s has invalid connect callback";
          goto LABEL_209;
        }

        if (!v99)
        {
          os_log_type_t v72 = (os_log_s *)__nwlog_obj();
          BOOL v73 = type;
          if (!os_log_type_enabled(v72, type)) {
            goto LABEL_210;
          }
          os_log_type_t v90 = a1->output_handler;
          os_log_type_t v91 = "invalid";
          if (v90)
          {
            os_log_type_t v92 = v90->identifier;
            if (v92) {
              os_log_type_t v91 = (const char *)v92;
            }
          }

          *(_DWORD *)buf = 136446466;
          os_log_type_t v102 = "nw_protocol_http2_connect";
          os_log_type_t v103 = 2082;
          BOOL v104 = (char *)v91;
          BOOL v77 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
          goto LABEL_209;
        }

        BOOL v85 = (char *)__nw_create_backtrace_string();
        os_log_type_t v72 = (os_log_s *)__nwlog_obj();
        BOOL v73 = type;
        os_log_type_t v86 = os_log_type_enabled(v72, type);
        if (v85)
        {
          if (v86)
          {
            BOOL v87 = a1->output_handler;
            os_log_type_t v88 = "invalid";
            if (v87)
            {
              os_log_type_t v89 = v87->identifier;
              if (v89) {
                os_log_type_t v88 = (const char *)v89;
              }
            }

            *(_DWORD *)buf = 136446722;
            os_log_type_t v102 = "nw_protocol_http2_connect";
            os_log_type_t v103 = 2082;
            BOOL v104 = (char *)v88;
            os_log_type_t v105 = 2082;
            os_log_type_t v106 = v85;
            _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v85);
          goto LABEL_210;
        }

        if (v86)
        {
          BOOL v96 = a1->output_handler;
          os_log_type_t v97 = "invalid";
          if (v96)
          {
            BOOL v98 = v96->identifier;
            if (v98) {
              os_log_type_t v97 = (const char *)v98;
            }
          }

          *(_DWORD *)buf = 136446466;
          os_log_type_t v102 = "nw_protocol_http2_connect";
          os_log_type_t v103 = 2082;
          BOOL v104 = (char *)v97;
          BOOL v77 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
LABEL_209:
          _os_log_impl(&dword_181A5C000, v72, v73, v77, buf, 0x16u);
        }
      }

          if (v46) {
            free(v46);
          }
          goto LABEL_87;
        }

        goto LABEL_76;
      }

      __nwlog_obj();
      __buf = 136446210;
      v56 = "__nw_frame_get_ecn_flag";
      os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      size_t v53 = 0;
      if (__nwlog_fault(v20, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v21 = (os_log_s *)__nwlog_obj();
          BOOL v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_41;
          }
          __buf = 136446210;
          v56 = "__nw_frame_get_ecn_flag";
          size_t v23 = "%{public}s called with null frame";
LABEL_40:
          _os_log_impl(&dword_181A5C000, v21, v22, v23, (uint8_t *)&__buf, 0xCu);
          goto LABEL_41;
        }

        if (!v53)
        {
          char v21 = (os_log_s *)__nwlog_obj();
          BOOL v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_41;
          }
          __buf = 136446210;
          v56 = "__nw_frame_get_ecn_flag";
          size_t v23 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_40;
        }

        size_t v24 = (char *)__nw_create_backtrace_string();
        char v21 = (os_log_s *)__nwlog_obj();
        BOOL v22 = type;
        __int16 v25 = os_log_type_enabled(v21, type);
        if (!v24)
        {
          if (!v25) {
            goto LABEL_41;
          }
          __buf = 136446210;
          v56 = "__nw_frame_get_ecn_flag";
          size_t v23 = "%{public}s called with null frame, no backtrace";
          goto LABEL_40;
        }

        if (v25)
        {
          __buf = 136446466;
          v56 = "__nw_frame_get_ecn_flag";
          os_log_type_t v57 = 2082;
          v58 = v24;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s called with null frame, dumping backtrace:%{public}s",  (uint8_t *)&__buf,  0x16u);
        }

        free(v24);
      }

        free(v40);
        goto LABEL_109;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v41 = (os_log_s *)(id)gLogObj;
        size_t v45 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl( &dword_181A5C000,  v41,  v45,  "%{public}s information socket creation failed %{darwin.errno}d",  buf,  0x12u);
        }
      }

      else if (v72)
      {
        size_t v49 = __nw_create_backtrace_string();
        if (v49)
        {
          BOOL v50 = (char *)v49;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          nw_txt_record_t v51 = (os_log_s *)(id)gLogObj;
          size_t v52 = type;
          if (os_log_type_enabled(v51, type))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v43;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v50;
            _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s information socket creation failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v50);
          if (!v40) {
            goto LABEL_109;
          }
          goto LABEL_108;
        }

        __nwlog_obj();
        size_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl( &dword_181A5C000,  v41,  v56,  "%{public}s information socket creation failed %{darwin.errno}d, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v41 = (os_log_s *)(id)gLogObj;
        v54 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl( &dword_181A5C000,  v41,  v54,  "%{public}s information socket creation failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v39 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
      v40 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v72 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v41 = (os_log_s *)(id)gLogObj;
        v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s nw_interface_create failed", buf, 0xCu);
        }
      }

      else if (v72)
      {
        int v46 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v41 = (os_log_s *)(id)gLogObj;
        int v47 = type;
        size_t v48 = os_log_type_enabled(v41, type);
        if (v46)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v46;
            _os_log_impl( &dword_181A5C000,  v41,  v47,  "%{public}s nw_interface_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v46);
          if (!v40) {
            goto LABEL_109;
          }
          goto LABEL_108;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_181A5C000, v41, v47, "%{public}s nw_interface_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v41 = (os_log_s *)(id)gLogObj;
        size_t v53 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl( &dword_181A5C000,  v41,  v53,  "%{public}s nw_interface_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_107;
  }

  __nwlog_obj();
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
  os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v72 = 0;
  if (__nwlog_fault(v59, &type, &v72))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v63 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_181A5C000, v60, v63, "%{public}s called with null interface_name", buf, 0xCu);
      }
    }

    else if (v72)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v68 = type;
      v69 = os_log_type_enabled(v60, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v67;
          _os_log_impl( &dword_181A5C000,  v60,  v68,  "%{public}s called with null interface_name, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v67);
        if (!v59) {
          return 0LL;
        }
        goto LABEL_146;
      }

      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_181A5C000, v60, v68, "%{public}s called with null interface_name, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v71 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl( &dword_181A5C000,  v60,  v71,  "%{public}s called with null interface_name, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_144;
  }

LABEL_89:
    if (v34) {
      free(v34);
    }
    goto LABEL_35;
  }

  v14 = 28;
LABEL_39:
  if (!*((_DWORD *)a2 + 2) && !*((_DWORD *)a2 + 3) && *((_DWORD *)a2 + 4) == -65536)
  {
    size_t v23 = *((_WORD *)a2 + 1);
    size_t v24 = *((_DWORD *)a2 + 5);
    *((_WORD *)v5 + 116) = 528;
    *((_WORD *)v5 + 117) = v23;
    *((_DWORD *)v5 + 59) = v24;
    *((void *)v5 + 30) = 0LL;
    LOBYTE(v14) = 16;
    goto LABEL_44;
  }

      if (v35) {
        free(v35);
      }
LABEL_91:
      char v21 = 0LL;
LABEL_103:

      goto LABEL_104;
    }

    __nwlog_obj();
    size_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v61 = "nw_parameters_internal_iterate_protocol_stack";
    v29 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v59 = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (__nwlog_fault(v29, &v59, &v58))
    {
      if (v59 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        dispatch_data_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v33 = v59;
        if (os_log_type_enabled(v30, v59))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v61 = "nw_parameters_internal_iterate_protocol_stack";
          _os_log_impl(&dword_181A5C000, v30, v33, "%{public}s called with null iterator", buf, 0xCu);
        }

  if (v34) {
    free(v34);
  }
  size_t v26 = 0LL;
  if (v21 != &nw_protocol_ref_counted_handle)
  {
LABEL_31:
    if (v4 == &nw_protocol_ref_counted_handle) {
      goto LABEL_93;
    }
    goto LABEL_94;
  }

      goto LABEL_90;
    }

    if (v68 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
      v42 = type;
      if (os_log_type_enabled(v16, type))
      {
        size_t v43 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        BOOL v71 = "nw_association_mark_flow_connected";
        os_log_type_t v72 = 2082;
        BOOL v73 = (void *)v43;
        os_log_type_t v74 = 2048;
        BOOL v75 = v5;
        _os_log_impl( &dword_181A5C000,  v16,  v42,  "%{public}s <nw_association %{public}s> does not have handle %p registered, backtrace limit exceeded",  buf,  0x20u);
      }

      goto LABEL_89;
    }

    v35 = __nw_create_backtrace_string();
    if (!v35)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
      size_t v49 = type;
      if (os_log_type_enabled(v16, type))
      {
        BOOL v50 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        BOOL v71 = "nw_association_mark_flow_connected";
        os_log_type_t v72 = 2082;
        BOOL v73 = (void *)v50;
        os_log_type_t v74 = 2048;
        BOOL v75 = v5;
        _os_log_impl( &dword_181A5C000,  v16,  v49,  "%{public}s <nw_association %{public}s> does not have handle %p registered, no backtrace",  buf,  0x20u);
      }

      goto LABEL_89;
    }

    size_t v24 = (char *)v35;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
    size_t v36 = type;
    if (os_log_type_enabled(v16, type))
    {
      size_t v37 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      BOOL v71 = "nw_association_mark_flow_connected";
      os_log_type_t v72 = 2082;
      BOOL v73 = (void *)v37;
      os_log_type_t v74 = 2048;
      BOOL v75 = v5;
      os_log_type_t v76 = 2082;
      BOOL v77 = v24;
      _os_log_impl( &dword_181A5C000,  v16,  v36,  "%{public}s <nw_association %{public}s> does not have handle %p registered, dumping backtrace:%{public}s",  buf,  0x2Au);
    }
}

    free(v28);
    goto LABEL_90;
  }

  if (!v4 || nw_path_parameters_get_logging_disabled(v4[13])) {
    goto LABEL_129;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v20 = (id)gconnectionLogObj;
  char v21 = *((_DWORD *)v2 + 112);
  LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
  *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_r"
                                                                                              "eport_on_nw_queue";
  WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
  *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v21;
  BOOL v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = 16;
  os_log_type_t v70 = 0;
  if (type[0] == 17)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    size_t v23 = (os_log_s *)(id)gconnectionLogObj;
    size_t v24 = type[0];
    if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
    {
      __int16 v25 = *((_DWORD *)v2 + 112);
      LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
      *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_sta"
                                                                                                  "ts_report_on_nw_queue";
      WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
      *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v25;
      _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s [C%u] Unexpected NULL stats report", (uint8_t *)&buf, 0x12u);
    }

              __break(1u);
            }

  size_t v52 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
  {
    size_t v53 = a1[5];
    if (v53) {
      v54 = (const char *)(v53 + 96);
    }
    else {
      v54 = "";
    }
    *(_DWORD *)buf = 136446466;
    v60 = "nw_protocol_udp_get_input_frames_block_invoke";
    os_log_type_t v61 = 2082;
    v62 = (void *)v54;
    _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s UDP frame is no longer valid",  buf,  0x16u);
  }

  os_log_type_t v55 = a1[5];
  if (v55)
  {
    *(void *)(v55 + 64) = 0LL;
    *(void *)(v55 + 72) = 0LL;
  }

  return 1LL;
}

    goto LABEL_96;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v58 = "nw_framer_protocol_get_message_properties";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v55 = 0;
  if (__nwlog_fault(v12, &type, &v55))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_framer_protocol_get_message_properties";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v55)
    {
      dispatch_data_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      dispatch_data_t v31 = type;
      size_t v32 = os_log_type_enabled(v13, type);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v58 = "nw_framer_protocol_get_message_properties";
          os_log_type_t v59 = 2082;
          v60 = v30;
          _os_log_impl( &dword_181A5C000,  v13,  v31,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
        goto LABEL_82;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_framer_protocol_get_message_properties";
        _os_log_impl(&dword_181A5C000, v13, v31, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v45 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_framer_protocol_get_message_properties";
        _os_log_impl( &dword_181A5C000,  v13,  v45,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v20) {
    free(v20);
  }
}

        nw_endpoint_get_bonjour_service_name(*((nw_endpoint_t *)v1 + 3));
        nw_endpoint_get_bonjour_service_type(*((nw_endpoint_t *)v1 + 3));
        nw_endpoint_get_bonjour_service_domain(*((nw_endpoint_t *)v1 + 3));
        context = v53;
        v56 = DNSServiceResolveEx();
        if (v56 != -65569)
        {
          id v5 = v56;
          v219 = "bonjour";
          v221 = "DNSServiceResolve";
          goto LABEL_277;
        }

        nw_resolver_cancel_query_locked(v53, 0);
        v219 = "bonjour";
        os_log_type_t v7 = "DNSServiceResolve";
        goto LABEL_14;
      }

      if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
      {
        if (*v225)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v137 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_resolver_should_wait_for_awdl_trigger";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = (char *)v1 + 256;
            v138 = v137;
            v139 = "%{public}s [C%{public}s] Failed to create AWDL trigger browser";
            v140 = 22;
            goto LABEL_188;
          }
        }

        else
        {
          __nwlog_obj();
          v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
          {
            v146 = *((_DWORD *)v1 + 85);
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_resolver_should_wait_for_awdl_trigger";
            *(_WORD *)&applier[12] = 1024;
            *(_DWORD *)&applier[14] = v146;
            v138 = v137;
            v139 = "%{public}s [R%u] Failed to create AWDL trigger browser";
            v140 = 18;
LABEL_188:
            _os_log_impl(&dword_181A5C000, v138, OS_LOG_TYPE_ERROR, v139, applier, v140);
          }
        }
      }

      goto LABEL_89;
    }

    if (nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3)) != nw_endpoint_type_address)
    {
      if (nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3)) != 5)
      {
        if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
        {
          if (*v225)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v162 = (id)gconnectionLogObj;
            os_log_type_t type = nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3));
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = (char *)v1 + 256;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = type;
            v164 = (char *)_os_log_send_and_compose_impl();

            handler[0] = 16;
            applier[0] = 0;
            if (__nwlog_fault(v164, handler, applier))
            {
              if (handler[0] == 17)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v165 = (os_log_s *)(id)gconnectionLogObj;
                v166 = handler[0];
                if (os_log_type_enabled(v165, (os_log_type_t)handler[0]))
                {
                  v167 = nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3));
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = (char *)v1 + 256;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v167;
                  _os_log_impl( &dword_181A5C000,  v165,  v166,  "%{public}s [C%{public}s] unknown resolver mode of operation for type %d",  buf,  0x1Cu);
                }

                goto LABEL_273;
              }

              if (applier[0])
              {
                backtrace_string = __nw_create_backtrace_string();
                if (backtrace_string)
                {
                  v176 = (char *)backtrace_string;
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v177 = (os_log_s *)(id)gconnectionLogObj;
                  v178 = handler[0];
                  if (os_log_type_enabled(v177, (os_log_type_t)handler[0]))
                  {
                    v179 = nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3));
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = (char *)v1 + 256;
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = v179;
                    *(_WORD *)&buf[28] = 2082;
                    *(void *)&buf[30] = v176;
                    _os_log_impl( &dword_181A5C000,  v177,  v178,  "%{public}s [C%{public}s] unknown resolver mode of operation for type %d, dumping backtrace:%{public}s",  buf,  0x26u);
                  }

                  free(v176);
                  goto LABEL_274;
                }

                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v165 = (os_log_s *)(id)gconnectionLogObj;
                v187 = handler[0];
                if (os_log_type_enabled(v165, (os_log_type_t)handler[0]))
                {
                  v188 = nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3));
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = (char *)v1 + 256;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v188;
                  _os_log_impl( &dword_181A5C000,  v165,  v187,  "%{public}s [C%{public}s] unknown resolver mode of operation for type %d, no backtrace",  buf,  0x1Cu);
                }
              }

              else
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v165 = (os_log_s *)(id)gconnectionLogObj;
                v185 = handler[0];
                if (os_log_type_enabled(v165, (os_log_type_t)handler[0]))
                {
                  v186 = nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3));
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = (char *)v1 + 256;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = v186;
                  _os_log_impl( &dword_181A5C000,  v165,  v185,  "%{public}s [C%{public}s] unknown resolver mode of operation for type %d, backtrace limit exceeded",  buf,  0x1Cu);
                }
              }

    free(v55);
    if (!v38) {
      goto LABEL_29;
    }
    goto LABEL_138;
  }

  if (!v82)
  {
    __nwlog_obj();
    int v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
    v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock[0]) = 16;
    LOBYTE(v96) = 0;
    if (LOBYTE(aBlock[0]) == 17)
    {
      __nwlog_obj();
      size_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v48 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl(&dword_181A5C000, v39, v48, "%{public}s called with null socket", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (!(_BYTE)v96)
    {
      __nwlog_obj();
      size_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v76 = aBlock[0];
      if (os_log_type_enabled(v39, aBlock[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        _os_log_impl( &dword_181A5C000,  v39,  v76,  "%{public}s called with null socket, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_118;
    }

    os_log_type_t v55 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    size_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v62 = aBlock[0];
    v63 = os_log_type_enabled(v52, aBlock[0]);
    if (v55)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v55;
        _os_log_impl( &dword_181A5C000,  v52,  v62,  "%{public}s called with null socket, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_89;
    }

    if (v63)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_handle_incoming_packet";
      _os_log_impl(&dword_181A5C000, v52, v62, "%{public}s called with null socket, no backtrace", buf, 0xCu);
    }

    if (v26) {
      free(v26);
    }
    os_log_type_t v16 = 0;
    if (v11 != &nw_protocol_ref_counted_handle)
    {
LABEL_22:
      if (v8 != &nw_protocol_ref_counted_handle) {
        goto LABEL_23;
      }
      goto LABEL_93;
    }

    goto LABEL_90;
  }

  __nwlog_obj();
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  size_t v53 = "nw_protocol_implementation_get_message_properties";
  v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v50 = 0;
  if (__nwlog_fault(v13, &type, &v50))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v53 = "nw_protocol_implementation_get_message_properties";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v50)
    {
      size_t v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v25 = type;
      size_t v26 = os_log_type_enabled(v14, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          size_t v53 = "nw_protocol_implementation_get_message_properties";
          v54 = 2082;
          os_log_type_t v55 = v24;
          _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v24);
        goto LABEL_79;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        size_t v53 = "nw_protocol_implementation_get_message_properties";
        _os_log_impl(&dword_181A5C000, v14, v25, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v39 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v53 = "nw_protocol_implementation_get_message_properties";
        _os_log_impl( &dword_181A5C000,  v14,  v39,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v18) {
    free(v18);
  }
  return 0LL;
}

    goto LABEL_90;
  }

  v194 = v8;
  __nwlog_obj();
  v195 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v195, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v245 = "strict_calloc";
  v246 = 2048;
  v247 = 1LL;
  v248 = 2048;
  v249 = 336LL;
  v196 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v196);
  if (!result)
  {
    free(v196);
    os_log_type_t v8 = v194;
    id v9 = 0LL;
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

                *(void *)(v6 + 192) = v53;
                os_log_type_t v64 = (void *)nw_protocol_get_parameters((uint64_t)v54);
                if (nw_protocol_http_client_bottom_accept(v6, *(void **)(v6 + 120), v64)
                  && (nw_http_client_bottom_add_to_messaging(v6, (uint64_t)v54) & 1) != 0)
                {
                  if (v55 == 1) {
                    nw_protocol_connect(v54[4], (uint64_t)v54);
                  }
                }

                else
                {
                  if ((*(_BYTE *)(v6 + 294) & 4) == 0)
                  {
                    pthread_once(v47, v48);
                    networkd_settings_init();
                    v65 = (os_log_s *)v49[131];
                    if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
                    {
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = v50;
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v46;
                      *(_WORD *)&buf[22] = 2080;
                      __int16 v116 = " ";
                      _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sMessaging cannot accept stream",  buf,  0x20u);
                    }
                  }

                  v67 = *(char **)(v6 + 192);
                  os_log_type_t v66 = *(void *)(v6 + 200);
                  if ((unint64_t)v67 >= v66)
                  {
                    BOOL v108 = v46;
                    v69 = *(char **)(v6 + 184);
                    os_log_type_t v70 = (v67 - v69) >> 4;
                    BOOL v71 = v70 + 1;
                    os_log_type_t v72 = v66 - (void)v69;
                    if (v72 >> 3 > v71) {
                      BOOL v71 = v72 >> 3;
                    }
                    BOOL v73 = (unint64_t)v72 >= 0x7FFFFFFFFFFFFFF0LL;
                    os_log_type_t v74 = 0xFFFFFFFFFFFFFFFLL;
                    if (!v73) {
                      os_log_type_t v74 = v71;
                    }
                    if (v74 >> 60) {
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    BOOL v75 = v50;
                    os_log_type_t v76 = v48;
                    BOOL v77 = v47;
                    os_log_type_t v78 = v49;
                    BOOL v79 = 16 * v74;
                    v80 = (char *)operator new(16 * v74);
                    os_log_type_t v81 = &v80[16 * v70];
                    *(void *)os_log_type_t v81 = v54;
                    *((_DWORD *)v81 + 2) = 2;
                    if (v67 == v69)
                    {
                      os_log_type_t v83 = &v80[16 * v70];
                    }

                    else
                    {
                      v82 = &v80[16 * v70];
                      do
                      {
                        os_log_type_t v83 = v82 - 16;
                        *((_OWORD *)v82 - 1) = *((_OWORD *)v67 - 1);
                        v67 -= 16;
                        v82 -= 16;
                      }

                      while (v67 != v69);
                    }

                    os_log_type_t v68 = v81 + 16;
                    *(void *)(v6 + 184) = v83;
                    *(void *)(v6 + 192) = v81 + 16;
                    *(void *)(v6 + 200) = &v80[v79];
                    if (v69) {
                      operator delete(v69);
                    }
                    size_t v49 = v78;
                    int v47 = v77;
                    size_t v48 = v76;
                    BOOL v50 = v75;
                    int v46 = v108;
                  }

                  else
                  {
                    *(void *)v67 = v54;
                    *((_DWORD *)v67 + 2) = 2;
                    os_log_type_t v68 = v67 + 16;
                  }

                  *(void *)(v6 + 192) = v68;
                  nw_protocol_error(v54, v6);
                  nw_protocol_disconnected(v54, v6);
                }
              }
            }

            v35 = *(nw_parameters **)(v6 + 104);
            size_t v36 = nw_parameters_copy_default_protocol_stack(parameters);
            size_t v37 = nw_parameters_copy_default_protocol_stack(v35);
            v38 = nw_protocol_stack_copy_transport_protocol(v36);
            size_t v39 = nw_protocol_stack_copy_transport_protocol(v37);
            v40 = v39;
            if (v38)
            {
              if (v39)
              {
                size_t v41 = nw_protocol_options_copy_definition(v38);
                if (nw_protocol_options_matches_definition(v40, v41))
                {
                  protocol_handle = nw_protocol_options_get_protocol_handle(v38);
                  nw_parameters_set_protocol_instance(v40, v43, protocol_handle);
                  if ((*(_BYTE *)(v6 + 294) & 4) == 0)
                  {
                    if (gLogDatapath)
                    {
                      os_log_type_t v107 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_protocol_http_client_bottom_override_http_messaging";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v6 + 208;
                        *(_WORD *)&buf[22] = 2080;
                        __int16 v116 = " ";
                        *(_WORD *)int v117 = 2048;
                        *(void *)&v117[2] = v40;
                        *(_WORD *)&v117[10] = 2048;
                        *(void *)&v117[12] = v38;
                        _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sChanged http_client_bottom transport from %p to %p",  buf,  0x34u);
                      }
                    }
                  }
                }

                os_release(v40);
              }
            }

            else
            {
              v38 = v39;
              if (!v39)
              {
LABEL_72:
                if (v37) {
                  os_release(v37);
                }
                if (v36) {
                  os_release(v36);
                }
                goto LABEL_76;
              }
            }

            os_release(v38);
            goto LABEL_72;
          }

    goto LABEL_90;
  }

  if (!v4)
  {
    __nwlog_obj();
    size_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v50 = "nw_connection_remove_probe_locked";
    size_t v34 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v50 = "nw_connection_remove_probe_locked";
        _os_log_impl(&dword_181A5C000, v35, v38, "%{public}s called with null probe", buf, 0xCu);
      }
    }

    else if (v47)
    {
      v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v43 = type;
      v44 = os_log_type_enabled(v35, type);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v50 = "nw_connection_remove_probe_locked";
          nw_txt_record_t v51 = 2082;
          *(void *)size_t v52 = v42;
          _os_log_impl( &dword_181A5C000,  v35,  v43,  "%{public}s called with null probe, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v42);
        if (!v34) {
          goto LABEL_56;
        }
LABEL_91:
        free(v34);
        goto LABEL_56;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v50 = "nw_connection_remove_probe_locked";
        _os_log_impl(&dword_181A5C000, v35, v43, "%{public}s called with null probe, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v46 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v50 = "nw_connection_remove_probe_locked";
        _os_log_impl( &dword_181A5C000,  v35,  v46,  "%{public}s called with null probe, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_89;
  }

  probes = v3->probes;
  if (probes)
  {
    p_isa = &probes[2].super.super.isa->isa;
    os_log_type_t v8 = &probes[3].super.super.isa->isa;
    isa = (NWConcrete_nw_connection **)p_isa;
    if (p_isa != v8)
    {
      while (*isa != v4)
      {
        if (++isa == v8)
        {
          isa = (NWConcrete_nw_connection **)probes[3].super.super.isa;
          break;
        }
      }
    }

    if (isa != v8)
    {
      p_probes = (uint64_t *)&v3->probes;
      BOOL v11 = nw_array_create();
      os_log_type_t v12 = (void *)v11;
      if (p_isa != v8)
      {
        std::vector<nw_object_wrapper_t>::reserve(v11 + 16, probes[3].super.super.isa - probes[2].super.super.isa - 1);
        v14 = (void **)&probes[2].super.super.isa->isa;
        v13 = (void **)&probes[3].super.super.isa->isa;
        while (v14 != v13)
        {
          if (*v14 != v5) {
            nw_array_append((uint64_t)v12, *v14);
          }
          ++v14;
        }
      }

      objc_storeStrong((id *)&v3->probes, v12);
      parameters = v3->parameters;
      if (parameters && !nw_path_parameters_get_logging_disabled(*((void *)parameters + 13)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          nw_txt_record_t v17 = *p_probes;
          if (*p_probes) {
            nw_txt_record_t v17 = (uint64_t)(*(void *)(v17 + 24) - *(void *)(v17 + 16)) >> 3;
          }
          top_id = v3->top_id;
          *(_DWORD *)buf = 136446978;
          BOOL v50 = "nw_connection_remove_probe_locked";
          nw_txt_record_t v51 = 1024;
          *(_DWORD *)size_t v52 = top_id;
          *(_WORD *)&v52[4] = 2112;
          *(void *)&v52[6] = v5;
          size_t v53 = 2048;
          v54 = v17;
          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Removed probe %@ from probe list, now have %zu probes",  buf,  0x26u);
        }
      }

      cancel_group = (dispatch_group_s *)v3->cancel_group;
      if (cancel_group)
      {
        dispatch_group_leave(cancel_group);
LABEL_55:

        goto LABEL_56;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v23 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      BOOL v50 = "nw_connection_remove_probe_locked";
      size_t v24 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v47 = 0;
      if (__nwlog_fault(v24, &type, &v47))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v25 = (os_log_s *)(id)gLogObj;
          size_t v26 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v50 = "nw_connection_remove_probe_locked";
            _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Cannot remove probe from cancel group because cancel group does not exist",  buf,  0xCu);
          }
        }

        else if (v47)
        {
          uint64_t v27 = __nw_create_backtrace_string();
          if (v27)
          {
            os_log_type_t v28 = (char *)v27;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v29 = (os_log_s *)(id)gLogObj;
            dispatch_data_t v30 = type;
            if (os_log_type_enabled(v29, type))
            {
              *(_DWORD *)buf = 136446466;
              BOOL v50 = "nw_connection_remove_probe_locked";
              nw_txt_record_t v51 = 2082;
              *(void *)size_t v52 = v28;
              _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s Cannot remove probe from cancel group because cancel group does not exist, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v28);
            if (!v24) {
              goto LABEL_55;
            }
            goto LABEL_54;
          }

          __nwlog_obj();
          __int16 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          size_t v32 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v50 = "nw_connection_remove_probe_locked";
            _os_log_impl( &dword_181A5C000,  v25,  v32,  "%{public}s Cannot remove probe from cancel group because cancel group does not exist, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v25 = (os_log_s *)(id)gLogObj;
          dispatch_data_t v31 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v50 = "nw_connection_remove_probe_locked";
            _os_log_impl( &dword_181A5C000,  v25,  v31,  "%{public}s Cannot remove probe from cancel group because cancel group does not exist, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v24) {
        goto LABEL_55;
      }
LABEL_54:
      free(v24);
      goto LABEL_55;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v21 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      BOOL v50 = "nw_connection_remove_probe_locked";
      nw_txt_record_t v51 = 2112;
      *(void *)size_t v52 = v5;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_INFO,  "%{public}s Not removing probe %@ because probe list does not contain this probe",  buf,  0x16u);
    }

    goto LABEL_32;
  }

  os_log_type_t v20 = v3->parameters;
  if (v20 && !nw_path_parameters_get_logging_disabled(*((void *)v20 + 13)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v21 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      BOOL v22 = v3->top_id;
      *(_DWORD *)buf = 136446722;
      BOOL v50 = "nw_connection_remove_probe_locked";
      nw_txt_record_t v51 = 1024;
      *(_DWORD *)size_t v52 = v22;
      *(_WORD *)&v52[4] = 2112;
      *(void *)&v52[6] = v5;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Not removing probe %@ because probes array does not exist",  buf,  0x1Cu);
    }

    if (v38) {
      free(v38);
    }
    goto LABEL_97;
  }

  if (v9)
  {
    Class = object_getClass(v8);
    os_log_type_t v12 = (objc_class *)MEMORY[0x1895F9250];
    if (Class != (Class)MEMORY[0x1895F9250])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s Malformed experimental configuration blob",  buf,  0xCu);
      }

      v14 = _Block_copy(&__block_literal_global_18956);
      goto LABEL_9;
    }

    os_log_type_t v16 = (void *)nw_protocol_boringssl_copy_definition();
    identifier = nw_protocol_definition_get_identifier(v16);
    os_log_type_t v18 = v10;

    BOOL v19 = nw_endpoint_handler_copy_protocol_metadata(v7[18], v16, 0, 0);
    os_log_type_t v20 = v18 + 8;
    if (strncmp(identifier, v18 + 8, 0x20uLL))
    {
      v15 = _Block_copy(&__block_literal_global_18956);
LABEL_19:

      goto LABEL_20;
    }

    xpc_dictionary_get_value(v8, "transform");
    char v21 = (void *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = v21;
    if (v21 && object_getClass(v21) == v12)
    {
      size_t v23 = _Block_copy(&__block_literal_global_18956);
      xpc_dictionary_get_value(v22, v20);
      size_t v24 = (void *)objc_claimAutoreleasedReturnValue();
      __int16 v25 = v24;
      if (v24 && object_getClass(v24) == v12)
      {
        aBlock[0] = MEMORY[0x1895F87A8];
        aBlock[1] = 3221225472LL;
        aBlock[2] = ___ZL79nw_connection_create_experimental_probe_configuration_block_for_protocol_lockedP24NWConcrete_nw_connectionPU24objcproto13OS_xpc_object8NSObjectPKcPU36objcproto25OS_nw_protocol_definitionS1__block_invoke;
        aBlock[3] = &unk_189BB99F8;
        v62 = v25;
        os_log_type_t v64 = a3;
        v63 = v19;
        uint64_t v27 = v25;
        os_log_type_t v28 = _Block_copy(aBlock);

        v15 = _Block_copy(v28);
        goto LABEL_18;
      }
    }

    v15 = _Block_copy(&__block_literal_global_18956);
LABEL_18:

    goto LABEL_19;
  }

  __nwlog_obj();
  size_t v41 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
  v42 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v65 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    size_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v44 = type;
    if (os_log_type_enabled(v43, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
      _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null protocol_definition", buf, 0xCu);
    }
  }

  else if (v65)
  {
    v54 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    size_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v55 = type;
    v56 = os_log_type_enabled(v43, type);
    if (v54)
    {
      if (v56)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
        v69 = 2082;
        os_log_type_t v70 = v54;
        _os_log_impl( &dword_181A5C000,  v43,  v55,  "%{public}s called with null protocol_definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v54);
      goto LABEL_95;
    }

    if (v56)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
      _os_log_impl( &dword_181A5C000,  v43,  v55,  "%{public}s called with null protocol_definition, no backtrace",  buf,  0xCu);
    }
  }

  else
  {
    __nwlog_obj();
    size_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v60 = type;
    if (os_log_type_enabled(v43, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
      _os_log_impl( &dword_181A5C000,  v43,  v60,  "%{public}s called with null protocol_definition, backtrace limit exceeded",  buf,  0xCu);
    }
  }

LABEL_95:
  if (v42) {
    free(v42);
  }
LABEL_97:
  v14 = _Block_copy(&__block_literal_global_18956);
LABEL_9:
  v15 = v14;
LABEL_20:

  return v15;
}

        free(v69);
        goto LABEL_90;
      }

      *((_BYTE *)v2 + 268) &= ~2u;
      os_log_type_t v12 = v2->inactive_agent_uuids;
      v2->inactive_agent_uuids = 0LL;
      v13 = v2;

      v14 = v2->inactive_agent_dictionaries;
      v2->inactive_agent_dictionaries = 0LL;

      v15 = v2->triggered_agent_uuids;
      v2->triggered_agent_uuids = 0LL;

      if (!nw_endpoint_handler_get_minimize_logging(v13))
      {
        os_log_type_t v16 = v13;
        nw_txt_record_t v17 = *((_BYTE *)v2 + 268);

        if ((v17 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v18 = (os_log_s *)(id)gconnectionLogObj;
          BOOL v11 = 1LL;
          if (!os_log_type_enabled(v18, OS_LOG_TYPE_INFO)) {
            goto LABEL_99;
          }
          BOOL v19 = v16;

          os_log_type_t v20 = v19;
          char v21 = *((_BYTE *)v2 + 268);

          if ((v21 & 1) != 0) {
            BOOL v22 = "dry-run ";
          }
          else {
            BOOL v22 = "";
          }
          v129 = v18;
          size_t v23 = nw_endpoint_handler_copy_endpoint(v20);
          size_t v24 = nw_endpoint_get_logging_description(v23);
          __int16 v25 = v19 + 168;
          size_t v26 = v20;
          uint64_t v27 = v26;
          os_log_type_t v28 = v26[30];
          else {
            v29 = off_189BBBBF0[v28];
          }

          int v46 = v27;
          int v47 = v46;
          size_t v48 = "path";
          switch(*((_DWORD *)v46 + 29))
          {
            case 0:
              break;
            case 1:
              size_t v48 = "resolver";
              break;
            case 2:
              size_t v48 = nw_endpoint_flow_mode_string(v46[31]);
              break;
            case 3:
              size_t v48 = "proxy";
              break;
            case 4:
              size_t v48 = "fallback";
              break;
            case 5:
              size_t v48 = "transform";
              break;
            default:
              size_t v48 = "unknown-mode";
              break;
          }

          os_log_type_t v88 = v47;
          os_unfair_lock_lock(v88 + 28);
          os_log_type_t v89 = v2->current_path;
          os_unfair_lock_unlock(v88 + 28);

          *(_DWORD *)buf = 136447746;
          v140 = "nw_endpoint_handler_triggered_agents_updated";
          v141 = 2082;
          v142 = v25;
          v143 = 2082;
          v144 = v22;
          v145 = 2082;
          v146 = v24;
          v147 = 2082;
          v148 = v29;
          v149 = 2082;
          v150 = v48;
          v151 = 2114;
          v152 = v89;
          os_log_type_t v18 = v129;
          _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no inactive agents remaining",  buf,  0x48u);

          goto LABEL_71;
        }

  dataMode = self->_dataMode;
  if (dataMode >= 3)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"(unknown: %i)", self->_dataMode);
    os_log_type_t v61 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }

  else
  {
    os_log_type_t v61 = off_189BBCB20[dataMode];
  }

  [v4 setObject:v61 forKey:@"dataMode"];

  has = (__int16)self->_has;
  if ((has & 0x10) == 0)
  {
LABEL_16:
    if ((has & 0x400) == 0) {
      goto LABEL_17;
    }
    goto LABEL_97;
  }

    goto LABEL_90;
  }

  if (!v74)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v54 = (os_log_s *)(id)gLogObj;
    os_log_type_t v61 = type;
    if (os_log_type_enabled(v54, type))
    {
      if (mode > 5) {
        v62 = "unknown-mode";
      }
      else {
        v62 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v77 = "nw_endpoint_fallback_reset_expected_progress_target";
      os_log_type_t v78 = 2082;
      BOOL v79 = (void *)v62;
      v80 = 2082;
      os_log_type_t v81 = "fallback";
      _os_log_impl( &dword_181A5C000,  v54,  v61,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_89;
  }

  os_log_type_t v57 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v54 = (os_log_s *)(id)gLogObj;
  v58 = type;
  os_log_type_t v59 = os_log_type_enabled(v54, type);
  if (!v57)
  {
    if (v59)
    {
      if (mode > 5) {
        v63 = "unknown-mode";
      }
      else {
        v63 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v77 = "nw_endpoint_fallback_reset_expected_progress_target";
      os_log_type_t v78 = 2082;
      BOOL v79 = (void *)v63;
      v80 = 2082;
      os_log_type_t v81 = "fallback";
      _os_log_impl( &dword_181A5C000,  v54,  v58,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_89;
  }

  if (v59)
  {
    if (mode > 5) {
      v60 = "unknown-mode";
    }
    else {
      v60 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    BOOL v77 = "nw_endpoint_fallback_reset_expected_progress_target";
    os_log_type_t v78 = 2082;
    BOOL v79 = (void *)v60;
    v80 = 2082;
    os_log_type_t v81 = "fallback";
    v82 = 2082;
    os_log_type_t v83 = v57;
    _os_log_impl( &dword_181A5C000,  v54,  v58,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v57);
  if (v53) {
    goto LABEL_91;
  }
LABEL_92:
}

      dispatch_data_t v31 = 0LL;
LABEL_90:

      goto LABEL_91;
    }

    __nwlog_obj();
    int v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
    size_t v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v61 = 0;
    if (__nwlog_fault(v48, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        size_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v50 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
          _os_log_impl(&dword_181A5C000, v49, v50, "%{public}s called with null self->hostname", buf, 0xCu);
        }
      }

      else if (v61)
      {
        size_t v53 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        size_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v54 = type;
        os_log_type_t v55 = os_log_type_enabled(v49, type);
        if (v53)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
            v65 = 2082;
            *(void *)os_log_type_t v66 = v53;
            _os_log_impl( &dword_181A5C000,  v49,  v54,  "%{public}s called with null self->hostname, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v53);
          goto LABEL_87;
        }

        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
          _os_log_impl( &dword_181A5C000,  v49,  v54,  "%{public}s called with null self->hostname, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        size_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v58 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
          _os_log_impl( &dword_181A5C000,  v49,  v58,  "%{public}s called with null self->hostname, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      if (v44) {
        free(v44);
      }
      return 2LL;
    }
  }

  __break(1u);
  return result;
}

LABEL_90:
      if (v26) {
        free(v26);
      }
      return 0LL;
    }

    if (!v37)
    {
      __nwlog_obj();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null out_ipv6_addr, backtrace limit exceeded";
        goto LABEL_88;
      }

      goto LABEL_89;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v28 = type;
    size_t v36 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null out_ipv6_addr, no backtrace";
        goto LABEL_88;
      }

      goto LABEL_89;
    }

    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_nat64_synthesize_v6";
      size_t v41 = 2082;
      *(void *)v42 = backtrace_string;
      size_t v34 = "%{public}s called with null out_ipv6_addr, dumping backtrace:%{public}s";
      goto LABEL_74;
    }

  if (v11) {
LABEL_90:
  }
    free(v11);
LABEL_91:
  os_log_type_t v18 = 0LL;
LABEL_92:

LABEL_93:
  return v18;
}

    free(v45);
    goto LABEL_90;
  }

  __nwlog_obj();
  BOOL v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v113 = "strict_calloc";
  v114 = 2048;
  *(void *)v115 = 1LL;
  *(_WORD *)&v115[8] = 2048;
  *(void *)&v115[10] = v22;
  os_log_type_t v72 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v72);
  if (!result)
  {
    free(v72);
    __nwlog_obj();
    BOOL v73 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v113 = "nw_necp_append_tlv";
    os_log_type_t v74 = (const char *)_os_log_send_and_compose_impl();

    char v111 = OS_LOG_TYPE_ERROR;
    os_log_type_t v110 = 0;
    if (v111 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v76 = v111;
      if (os_log_type_enabled(v75, v111))
      {
        *(_DWORD *)buf = 136446210;
        v113 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v75, v76, "%{public}s called with null tlv_start", buf, 0xCu);
      }
    }

    else if (v110)
    {
      os_log_type_t v81 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v82 = v111;
      os_log_type_t v83 = os_log_type_enabled(v75, v111);
      if (v81)
      {
        if (v83)
        {
          *(_DWORD *)buf = 136446466;
          v113 = "nw_necp_append_tlv";
          v114 = 2082;
          *(void *)v115 = v81;
          _os_log_impl( &dword_181A5C000,  v75,  v82,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v81);
LABEL_153:
        if (v74)
        {
          v40 = (char *)v74;
          goto LABEL_53;
        }

        goto LABEL_54;
      }

      if (v83)
      {
        *(_DWORD *)buf = 136446210;
        v113 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v75, v82, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v88 = v111;
      if (os_log_type_enabled(v75, v111))
      {
        *(_DWORD *)buf = 136446210;
        v113 = "nw_necp_append_tlv";
        _os_log_impl( &dword_181A5C000,  v75,  v88,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_153;
  }

        os_log_type_t v78 = v79;
        goto LABEL_90;
      }

      if (!(_BYTE)v105)
      {
        BOOL v79 = v78;
        __nwlog_obj();
        v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v86 = v110[0];
        if (os_log_type_enabled(v80, (os_log_type_t)v110[0]))
        {
          buf[0] = 136446210;
          *(void *)&buf[1] = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v80,  v86,  "%{public}s called with null handler, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
        }

        goto LABEL_89;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v84 = v110[0];
      BOOL v85 = os_log_type_enabled(v83, (os_log_type_t)v110[0]);
      if (backtrace_string)
      {
        if (v85)
        {
          buf[0] = 136446466;
          *(void *)&buf[1] = "nw_endpoint_handler_get_mode";
          LOWORD(buf[3]) = 2082;
          *(void *)((char *)&buf[3] + 2) = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v83,  v84,  "%{public}s called with null handler, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
        }

        free(backtrace_string);
      }

      else
      {
        if (v85)
        {
          buf[0] = 136446210;
          *(void *)&buf[1] = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v83,  v84,  "%{public}s called with null handler, no backtrace",  (uint8_t *)buf,  0xCu);
        }
      }
    }

      goto LABEL_56;
    }

    if (!v88)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v45 = (os_log_s *)(id)gLogObj;
      size_t v52 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        os_log_type_t v91 = 2048;
        os_log_type_t v92 = a7;
        _os_log_impl( &dword_181A5C000,  v45,  v52,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_89;
    }

    size_t v48 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v49 = (os_log_s *)(id)gLogObj;
    BOOL v50 = type[0];
    nw_txt_record_t v51 = os_log_type_enabled(v49, type[0]);
    if (v48)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        os_log_type_t v91 = 2048;
        os_log_type_t v92 = a7;
        v93 = 2082;
        os_log_type_t v94 = v48;
        _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v48);
      if (!v44) {
        goto LABEL_58;
      }
      goto LABEL_57;
    }

    if (v51)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
      os_log_type_t v91 = 2048;
      os_log_type_t v92 = a7;
      _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
    }

    if (v18) {
      free(v18);
    }
    return 4294966775LL;
  }

  BOOL v11 = stream_from_id;
  input_frame = http2_create_input_frame(a6, stream_from_id, a5);
  if (!input_frame)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    size_t v24 = *(_DWORD *)(v11 + 176);
    size_t v23 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    BOOL v98 = "on_data_chunk_recv_callback";
    os_log_type_t v99 = 2082;
    os_log_type_t v100 = (const char *)(v11 + 191);
    v101 = 2080;
    os_log_type_t v102 = " ";
    os_log_type_t v103 = 1024;
    *(_DWORD *)BOOL v104 = v23;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v24;
    os_log_type_t v105 = 2048;
    *(void *)os_log_type_t v106 = a5;
    *(_WORD *)&v106[8] = 1024;
    *(_DWORD *)&v106[10] = v24;
    __int16 v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = 0;
    if (__nwlog_fault(v25, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        size_t v26 = (os_log_s *)gconnectionLogObj;
        uint64_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_103;
        }
        v29 = *(_DWORD *)(v11 + 176);
        os_log_type_t v28 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = (const char *)(v11 + 191);
        v101 = 2080;
        os_log_type_t v102 = " ";
        os_log_type_t v103 = 1024;
        *(_DWORD *)BOOL v104 = v28;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v29;
        os_log_type_t v105 = 2048;
        *(void *)os_log_type_t v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v29;
        dispatch_data_t v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d";
        goto LABEL_102;
      }

      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        size_t v26 = (os_log_s *)gconnectionLogObj;
        uint64_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_103;
        }
        v63 = *(_DWORD *)(v11 + 176);
        v62 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = (const char *)(v11 + 191);
        v101 = 2080;
        os_log_type_t v102 = " ";
        os_log_type_t v103 = 1024;
        *(_DWORD *)BOOL v104 = v62;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v63;
        os_log_type_t v105 = 2048;
        *(void *)os_log_type_t v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v63;
        dispatch_data_t v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, backtrace limit exceeded";
        goto LABEL_102;
      }

      v35 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      size_t v26 = (os_log_s *)gconnectionLogObj;
      uint64_t v27 = type;
      size_t v36 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v35)
      {
        if (v36)
        {
          v38 = *(_DWORD *)(v11 + 176);
          size_t v37 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136448002;
          BOOL v98 = "on_data_chunk_recv_callback";
          os_log_type_t v99 = 2082;
          os_log_type_t v100 = (const char *)(v11 + 191);
          v101 = 2080;
          os_log_type_t v102 = " ";
          os_log_type_t v103 = 1024;
          *(_DWORD *)BOOL v104 = v37;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = v38;
          os_log_type_t v105 = 2048;
          *(void *)os_log_type_t v106 = a5;
          *(_WORD *)&v106[8] = 1024;
          *(_DWORD *)&v106[10] = v38;
          os_log_type_t v107 = 2082;
          BOOL v108 = v35;
          _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, dumping bac ktrace:%{public}s",  buf,  0x46u);
        }

        free(v35);
        goto LABEL_103;
      }

      if (v36)
      {
        v67 = *(_DWORD *)(v11 + 176);
        os_log_type_t v66 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = (const char *)(v11 + 191);
        v101 = 2080;
        os_log_type_t v102 = " ";
        os_log_type_t v103 = 1024;
        *(_DWORD *)BOOL v104 = v66;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v67;
        os_log_type_t v105 = 2048;
        *(void *)os_log_type_t v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v67;
        dispatch_data_t v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, no backtrace";
LABEL_102:
        _os_log_impl(&dword_181A5C000, v26, v27, v30, buf, 0x3Cu);
      }
    }

    _os_log_impl(&dword_181A5C000, v23, v24, v25, buf, 0x12u);
    goto LABEL_90;
  }

  os_log_type_t v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  __nwlog_obj();
  *(_DWORD *)buf = 136446466;
  v38 = "nw_network_agent_open_control_socket";
  size_t v39 = 1024;
  v40 = v28;
  BOOL v22 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  size_t v34 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    size_t v23 = (os_log_s *)__nwlog_obj();
    size_t v24 = type;
    if (!os_log_type_enabled(v23, type)) {
      goto LABEL_90;
    }
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    size_t v39 = 1024;
    v40 = v28;
    __int16 v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d";
    goto LABEL_89;
  }

  if (!v34)
  {
    size_t v23 = (os_log_s *)__nwlog_obj();
    size_t v24 = type;
    if (!os_log_type_enabled(v23, type)) {
      goto LABEL_90;
    }
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    size_t v39 = 1024;
    v40 = v28;
    __int16 v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, backtrace limit exceeded";
    goto LABEL_89;
  }

  dispatch_data_t v30 = (char *)__nw_create_backtrace_string();
  size_t v23 = (os_log_s *)__nwlog_obj();
  size_t v24 = type;
  dispatch_data_t v31 = os_log_type_enabled(v23, type);
  if (!v30)
  {
    if (!v31) {
      goto LABEL_90;
    }
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    size_t v39 = 1024;
    v40 = v28;
    __int16 v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, no backtrace";
    goto LABEL_89;
  }

  if (v31)
  {
    *(_DWORD *)buf = 136446722;
    v38 = "nw_network_agent_open_control_socket";
    size_t v39 = 1024;
    v40 = v28;
    size_t v41 = 2082;
    v42[0] = v30;
    _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v30);
  if (v22) {
    goto LABEL_91;
  }
  return kernel_socket_internal;
}

    if (!v24) {
      return;
    }
LABEL_90:
    free(v24);
    return;
  }

  if (nw_protocol_copy_test_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83889);
  }
  if (!nw_protocol_copy_test_definition::test_definition
    || (os_log_type_t v16 = (unsigned __int8 *)os_retain((void *)nw_protocol_copy_test_definition::test_definition)) == 0LL)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v72 = "nw_protocol_test_access_options";
    size_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v25 = (os_log_s *)__nwlog_obj();
      size_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v72 = "nw_protocol_test_access_options";
      uint64_t v27 = "%{public}s called with null definition";
      goto LABEL_88;
    }

    if (!v69)
    {
      __int16 v25 = (os_log_s *)__nwlog_obj();
      size_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v72 = "nw_protocol_test_access_options";
      uint64_t v27 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_88;
    }

    v40 = (char *)__nw_create_backtrace_string();
    __int16 v25 = (os_log_s *)__nwlog_obj();
    size_t v26 = type;
    size_t v41 = os_log_type_enabled(v25, type);
    if (!v40)
    {
      if (!v41) {
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v72 = "nw_protocol_test_access_options";
      uint64_t v27 = "%{public}s called with null definition, no backtrace";
      goto LABEL_88;
    }

    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v72 = "nw_protocol_test_access_options";
      BOOL v73 = 2082;
      os_log_type_t v74 = v40;
      v42 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_63:
      _os_log_impl(&dword_181A5C000, v25, v26, v42, buf, 0x16u);
      goto LABEL_64;
    }

    goto LABEL_64;
  }

  nw_txt_record_t v17 = v16;
  os_log_type_t v18 = nw_parameters_copy_protocol_options_for_definition(v15, v16);
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v72 = "nw_protocol_test_access_options";
    size_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v32, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = (os_log_s *)gLogObj;
        size_t v34 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v72 = "nw_protocol_test_access_options";
          v35 = "%{public}s Failed to copy protocol options";
LABEL_97:
          _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0xCu);
        }
      }

      else if (v69)
      {
        size_t v43 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = (os_log_s *)gLogObj;
        size_t v34 = type;
        v44 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v43)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v72 = "nw_protocol_test_access_options";
            BOOL v73 = 2082;
            os_log_type_t v74 = v43;
            _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v43);
          goto LABEL_98;
        }

        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v72 = "nw_protocol_test_access_options";
          v35 = "%{public}s Failed to copy protocol options, no backtrace";
          goto LABEL_97;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = (os_log_s *)gLogObj;
        size_t v34 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v72 = "nw_protocol_test_access_options";
          v35 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
          goto LABEL_97;
        }
      }
    }

    if (v37) {
      free(v37);
    }
    BYTE4(a1[3].output_handler_context) = nw_parameters_get_ip_protocol(0LL);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "__nw_protocol_get_local_endpoint";
    size_t v43 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v43, type, &v154))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v44 = (os_log_s *)__nwlog_obj();
        size_t v45 = type[0];
        if (!os_log_type_enabled(v44, type[0])) {
          goto LABEL_105;
        }
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_local_endpoint";
        int v46 = "%{public}s called with null protocol";
LABEL_104:
        _os_log_impl(&dword_181A5C000, v44, v45, v46, buf, 0xCu);
        goto LABEL_105;
      }

      if (v154 == OS_LOG_TYPE_DEFAULT)
      {
        v44 = (os_log_s *)__nwlog_obj();
        size_t v45 = type[0];
        if (!os_log_type_enabled(v44, type[0])) {
          goto LABEL_105;
        }
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_local_endpoint";
        int v46 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_104;
      }

      int v47 = (char *)__nw_create_backtrace_string();
      v44 = (os_log_s *)__nwlog_obj();
      size_t v45 = type[0];
      size_t v48 = os_log_type_enabled(v44, type[0]);
      if (!v47)
      {
        if (!v48) {
          goto LABEL_105;
        }
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_local_endpoint";
        int v46 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_104;
      }

      if (v48)
      {
        *(_DWORD *)buf = 136446466;
        v157 = "__nw_protocol_get_local_endpoint";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v47;
        _os_log_impl( &dword_181A5C000,  v44,  v45,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v47);
    }

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  v1 = endpoint;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    size_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_endpoint_get_address";
    uint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v38 = "nw_endpoint_get_address";
            __int16 v39 = 2082;
            *(void *)v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_address";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181ADA014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_path_copy_interface_with_generation(void *a1, unsigned int a2, int a3)
{
  *(void *)((char *)&v52[2] + 2) = *MEMORY[0x1895F89C0];
  id v5 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (a2)
  {
    uint64_t globals_for_path = nw_context_get_globals_for_path(v5);
    os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
    if (*(void *)(globals_for_path + 88))
    {
      if (*(void *)(globals_for_path + 104)) {
        goto LABEL_8;
      }
    }

    else
    {
      int v8 = nw_dictionary_create();
      id v9 = *(void **)(globals_for_path + 88);
      *(void *)(globals_for_path + 88) = v8;

      if (*(void *)(globals_for_path + 104)) {
        goto LABEL_8;
      }
    }

    xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
    os_log_type_t v11 = *(void **)(globals_for_path + 104);
    *(void *)(globals_for_path + 104) = v10;

LABEL_8:
    lock = (os_unfair_lock_s *)(globals_for_path + 124);
    id v12 = *(id *)(globals_for_path + 88);
    xpc_object_t xdict = *(id *)(globals_for_path + 104);
    uint64_t v13 = mach_continuous_time();
    if (v13 <= 1) {
      uint64_t v14 = 1LL;
    }
    else {
      uint64_t v14 = v13;
    }
    snprintf((char *)(globals_for_path + 141), 0xAuLL, "%u", a2);
    os_log_type_t v15 = nw_dictionary_copy_value((uint64_t)v12, globals_for_path + 141);
    BOOL v16 = v15;
    if (v15 && ((nw_txt_record_t v17 = v15, v18 = v17[23], v17, !a3) || v18 == a3))
    {
      os_log_type_t v7 = v17;
      int v21 = xdict;
      xpc_dictionary_set_uint64(xdict, (const char *)(globals_for_path + 141), v14);
    }

    else
    {
      uint64_t v19 = nw_path_shared_necp_fd(v5);
      os_log_type_t v7 = nw_interface_create_from_necp(v19, a2);
      if (v7)
      {
        xpc_dictionary_set_uint64(xdict, (const char *)(globals_for_path + 141), v14);
        nw_dictionary_set_value((uint64_t)v12, (const char *)(globals_for_path + 141), v7);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v20 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          BOOL v50 = "nw_path_copy_interface_with_generation";
          __int16 v51 = 1024;
          LODWORD(v52[0]) = a2;
          WORD2(v52[0]) = 1024;
          *(_DWORD *)((char *)v52 + 6) = a3;
          _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s Cache miss for interface for index %u (generation %u)",  buf,  0x18u);
        }

        int v21 = xdict;
      }

      else
      {
        int v21 = xdict;
      }
    }

    uint64_t v22 = *(void *)(globals_for_path + 96);
    if (v22)
    {
    }

    *(void *)(globals_for_path + 96) = v14;
    if (!v5 || v5[31] != 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v23 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        BOOL v50 = "nw_path_copy_interface_with_generation";
        __int16 v51 = 1024;
        LODWORD(v52[0]) = 16;
        _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEFAULT,  "%{public}s Interface cache hit limit (%u), purging all interfaces not used recently",  buf,  0x12u);
      }
    }

    xpc_object_t v24 = xpc_array_create(0LL, 0LL);
    if (v24)
    {
      uint64_t v25 = MEMORY[0x1895F87A8];
      v43[0] = MEMORY[0x1895F87A8];
      v43[1] = 3221225472LL;
      v43[2] = __nw_path_copy_interface_with_generation_block_invoke;
      v43[3] = &unk_189BC50F8;
      id v26 = v21;
      id v44 = v26;
      uint64_t v46 = v14;
      id v27 = v24;
      id v45 = v27;
      nw_dictionary_apply((uint64_t)v12, (uint64_t)v43);
      applier[0] = v25;
      applier[1] = 3221225472LL;
      applier[2] = __nw_path_copy_interface_with_generation_block_invoke_2;
      applier[3] = &unk_189BC5120;
      id v41 = v12;
      id v42 = v26;
      xpc_array_apply(v27, applier);

LABEL_37:
LABEL_38:
      os_unfair_lock_unlock(lock);

      goto LABEL_39;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v28 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    BOOL v50 = "nw_path_copy_interface_with_generation";
    os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v48 = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (v48 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      dispatch_data_t v30 = (os_log_s *)(id)gLogObj;
      os_log_type_t v31 = v48;
      if (os_log_type_enabled(v30, v48))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v50 = "nw_path_copy_interface_with_generation";
        _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s xpc_array_create failed", buf, 0xCu);
      }
    }

    else
    {
      if (v47)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v35 = v48;
        BOOL v36 = os_log_type_enabled(v34, v48);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v50 = "nw_path_copy_interface_with_generation";
            __int16 v51 = 2082;
            v52[0] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s xpc_array_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          int v21 = xdict;
          free(backtrace_string);
          if (!v29) {
            goto LABEL_37;
          }
          goto LABEL_36;
        }

        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v50 = "nw_path_copy_interface_with_generation";
          _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s xpc_array_create failed, no backtrace", buf, 0xCu);
        }

        int v21 = xdict;
LABEL_35:
        if (!v29) {
          goto LABEL_37;
        }
LABEL_36:
        free(v29);
        goto LABEL_37;
      }

      __nwlog_obj();
      dispatch_data_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = v48;
      if (os_log_type_enabled(v30, v48))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v50 = "nw_path_copy_interface_with_generation";
        _os_log_impl( &dword_181A5C000,  v30,  v37,  "%{public}s xpc_array_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_35;
  }

  os_log_type_t v7 = 0LL;
LABEL_39:

  return v7;
}

void sub_181ADA6F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, void *a26)
{
  _Unwind_Resume(a1);
}

void *nw_dictionary_copy_value(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v17 = "nw_dictionary_copy_value";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v17 = "nw_dictionary_copy_value";
      os_log_type_t v7 = "%{public}s called with null dictionary";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          nw_txt_record_t v17 = "nw_dictionary_copy_value";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null dictionary, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_47:
        if (!v4) {
          return 0LL;
        }
LABEL_48:
        free(v4);
        return 0LL;
      }

      if (!v9) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v17 = "nw_dictionary_copy_value";
      os_log_type_t v7 = "%{public}s called with null dictionary, no backtrace";
    }

    else
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      nw_txt_record_t v17 = "nw_dictionary_copy_value";
      os_log_type_t v7 = "%{public}s called with null dictionary, backtrace limit exceeded";
    }

    goto LABEL_46;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_txt_record_t v17 = "nw_dictionary_copy_value";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v14)
      {
        id v5 = (os_log_s *)__nwlog_obj();
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v17 = "nw_dictionary_copy_value";
        os_log_type_t v7 = "%{public}s called with null key, backtrace limit exceeded";
        goto LABEL_46;
      }

      xpc_object_t v10 = (char *)__nw_create_backtrace_string();
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v11 = os_log_type_enabled(v5, type);
      if (!v10)
      {
        if (!v11) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446210;
        nw_txt_record_t v17 = "nw_dictionary_copy_value";
        os_log_type_t v7 = "%{public}s called with null key, no backtrace";
        goto LABEL_46;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        nw_txt_record_t v17 = "nw_dictionary_copy_value";
        __int16 v18 = 2082;
        uint64_t v19 = v10;
        id v12 = "%{public}s called with null key, dumping backtrace:%{public}s";
LABEL_31:
        _os_log_impl(&dword_181A5C000, v5, v6, v12, buf, 0x16u);
      }

size_t nw_dictionary_get_count(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    v1 = *(void **)(a1 + 16);
    if (v1) {
      return xpc_dictionary_get_count(v1);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_dictionary_get_count";
    unsigned int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v3, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_dictionary_get_count";
        os_log_type_t v6 = "%{public}s called with null dictionary->xpc_object";
        goto LABEL_31;
      }

      if (!v11)
      {
        int v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_dictionary_get_count";
        os_log_type_t v6 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
        goto LABEL_31;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_dictionary_get_count";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v3) {
          return 0LL;
        }
        goto LABEL_33;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_dictionary_get_count";
        os_log_type_t v6 = "%{public}s called with null dictionary->xpc_object, no backtrace";
LABEL_31:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_dictionary_get_count";
    unsigned int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_dictionary_get_count";
      os_log_type_t v6 = "%{public}s called with null dictionary";
      goto LABEL_31;
    }

    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_dictionary_get_count";
      os_log_type_t v6 = "%{public}s called with null dictionary, backtrace limit exceeded";
      goto LABEL_31;
    }

    os_log_type_t v7 = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!v7)
    {
      if (!v8) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_dictionary_get_count";
      os_log_type_t v6 = "%{public}s called with null dictionary, no backtrace";
      goto LABEL_31;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_dictionary_get_count";
      __int16 v15 = 2082;
      BOOL v16 = v7;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null dictionary, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v7);
  }

uint64_t nw_parameters_get_required_interface_index(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_parameters_get_required_interface_index";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v17 = "nw_parameters_get_required_interface_index";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_path_get_interface_index(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  v2 = (unsigned int *)v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_path_get_interface_index";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v16 = "nw_path_get_interface_index";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v16 = "nw_path_get_interface_index";
            __int16 v17 = 2082;
            __int16 v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v16 = "nw_path_get_interface_index";
          _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v16 = "nw_path_get_interface_index";
          _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181ADB640(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_prohibited_interface_types(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_has_prohibited_interface_types";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_has_prohibited_interface_types";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181ADB900(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_prohibited_interface_subtypes(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_parameters_has_prohibited_interface_subtypes";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_parameters_has_prohibited_interface_subtypes";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181ADBC04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_prohibited_interfaces(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v18 = "nw_parameters_has_prohibited_interfaces";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v18 = "nw_parameters_has_prohibited_interfaces";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181ADBEC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_prohibit_roaming(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 100LL) >> 3) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_prohibit_roaming";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_prohibit_roaming";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_parameters_are_valid(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v14 = "nw_parameters_are_valid";
  BOOL v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v14 = "nw_parameters_are_valid";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v14 = "nw_parameters_are_valid";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_path_set_reason( void *a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  char v11 = a1;
  os_log_type_t v12 = v11;
  if (!v11)
  {
    __nwlog_obj();
    id v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_path_set_reason";
    id v28 = (char *)_os_log_send_and_compose_impl();

    v36[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v28, v36, &type))
    {
      if (v36[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = v36[0];
        if (os_log_type_enabled(v29, v36[0]))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_path_set_reason";
          _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = v36[0];
        BOOL v33 = os_log_type_enabled(v29, v36[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_path_set_reason";
            __int16 v41 = 2082;
            id v42 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_51;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_path_set_reason";
          _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = v36[0];
        if (os_log_type_enabled(v29, v36[0]))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_path_set_reason";
          _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_51:
    if (v28) {
      free(v28);
    }
    goto LABEL_22;
  }

  if (!a2 || (int v13 = *((_DWORD *)v11 + 95), (v13 - 27) >= 4) && (!v13 || (a2 - 27) <= 3))
  {
    __int16 v15 = v11 + 31;
    BOOL v14 = v11[31];
    *((_DWORD *)v12 + 95) = a2;
    if (v14)
    {
      free(v14);
      void *v15 = 0LL;
    }

    v37[0] = MEMORY[0x1895F87A8];
    v37[1] = 3221225472LL;
    v37[2] = __nw_path_set_reason_block_invoke;
    v37[3] = &unk_189BC93A0;
    BOOL v16 = v12;
    v37[4] = v16;
    os_unfair_lock_lock((os_unfair_lock_t)v12 + 3);
    __nw_path_set_reason_block_invoke((uint64_t)v37);
    os_unfair_lock_unlock((os_unfair_lock_t)v12 + 3);
    if (!a3) {
      goto LABEL_21;
    }
    *(void *)BOOL v36 = &a9;
    int v17 = vasprintf((char **)v12 + 31, a3, &a9);
    __int16 v18 = *v15;
    if (v17 < 0)
    {
      if (v18)
      {
        free(v18);
        void *v15 = 0LL;
      }
    }

    else if (v18)
    {
      goto LABEL_21;
    }

    void *v15 = 0LL;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    v40 = "nw_path_set_reason";
    __int16 v41 = 2082;
    id v42 = (void *)a3;
    __int16 v43 = 1024;
    int v44 = v17;
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v20, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_path_set_reason";
          __int16 v41 = 2082;
          id v42 = (void *)a3;
          __int16 v43 = 1024;
          int v44 = v17;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s vasprintf(%{public}s) returned %d failed",  buf,  0x1Cu);
        }
      }

      else if (v35)
      {
        uint64_t v23 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446978;
            v40 = "nw_path_set_reason";
            __int16 v41 = 2082;
            id v42 = (void *)a3;
            __int16 v43 = 1024;
            int v44 = v17;
            __int16 v45 = 2082;
            uint64_t v46 = v23;
            _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s vasprintf(%{public}s) returned %d failed, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(v23);
          if (!v20) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_path_set_reason";
          __int16 v41 = 2082;
          id v42 = (void *)a3;
          __int16 v43 = 1024;
          int v44 = v17;
          _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s vasprintf(%{public}s) returned %d failed, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_path_set_reason";
          __int16 v41 = 2082;
          id v42 = (void *)a3;
          __int16 v43 = 1024;
          int v44 = v17;
          _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s vasprintf(%{public}s) returned %d failed, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

    if (v20) {
LABEL_20:
    }
      free(v20);
LABEL_21:
  }

    goto LABEL_52;
  }

  if ((*((_BYTE *)v6 + 268) & 0x20) == 0) {
    goto LABEL_24;
  }
LABEL_52:
}

  return v7;
}

    if (v10) {
      free(v10);
    }
LABEL_53:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v24 = "nw_channel_get_message_properties";
      BOOL v25 = 1042;
      *(_DWORD *)os_log_type_t v26 = 16;
      v26[2] = 2098;
      *(void *)&v26[3] = a2;
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s Can't find hash table entry for %{public,uuid_t}.16P",  buf,  0x1Cu);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v24 = "nw_channel_get_message_properties";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v21 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_channel_get_message_properties";
    BOOL v9 = "%{public}s called with null channel";
    goto LABEL_45;
  }

  if (!v21)
  {
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_channel_get_message_properties";
    BOOL v9 = "%{public}s called with null channel, backtrace limit exceeded";
    goto LABEL_45;
  }

  BOOL v16 = (char *)__nw_create_backtrace_string();
  uint64_t v7 = (os_log_s *)__nwlog_obj();
  os_log_type_t v8 = type;
  int v17 = os_log_type_enabled(v7, type);
  if (!v16)
  {
    if (!v17) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_channel_get_message_properties";
    BOOL v9 = "%{public}s called with null channel, no backtrace";
    goto LABEL_45;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v24 = "nw_channel_get_message_properties";
    BOOL v25 = 2082;
    *(void *)os_log_type_t v26 = v16;
    _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v6) {
LABEL_47:
  }
    free(v6);
}

      os_log_type_t v70 = dictionary;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      *(void *)os_log_type_t v78 = v72;
      os_log_type_t v55 = sub_181C8C078(v16, v17);
      v56 = *(void *)(v72 + 16);
      os_log_type_t v57 = (v54 & 1) == 0;
      v58 = v56 + v57;
      if (__OFADD__(v56, v57)) {
        goto LABEL_66;
      }
      os_log_type_t v59 = v54;
      if (*(void *)(v72 + 24) >= v58)
      {
        if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
          sub_181C90F98();
        }
      }

      else
      {
        sub_181C8D378(v58, isUniquelyReferenced_nonNull_native);
        v60 = sub_181C8C078(v16, v17);
        if ((v59 & 1) != (v61 & 1)) {
          goto LABEL_70;
        }
        os_log_type_t v55 = v60;
      }

      v62 = *(void **)v78;
      os_log_type_t v72 = *(void *)v78;
      if ((v59 & 1) != 0)
      {
        v63 = *(void *)(*(void *)v78 + 56LL) + 24 * v55;
        sub_181BDA14C(*(void *)v63, *(void *)(v63 + 8), *(_BYTE *)(v63 + 16));
        *(void *)v63 = v20;
        *(void *)(v63 + 8) = v19;
        *(_BYTE *)(v63 + 16) = 0;
      }

      else
      {
        *(void *)(*(void *)v78 + 8 * (v55 >> 6) + 64) |= 1LL << v55;
        os_log_type_t v64 = (uint64_t *)(v62[6] + 16 * v55);
        *os_log_type_t v64 = v16;
        v64[1] = v17;
        v65 = v62[7] + 24 * v55;
        *(void *)v65 = v20;
        *(void *)(v65 + 8) = v19;
        *(_BYTE *)(v65 + 16) = 0;
        os_log_type_t v66 = v62[2];
        uint64_t v47 = __OFADD__(v66, 1LL);
        v67 = v66 + 1;
        if (v47) {
          goto LABEL_68;
        }
        v62[2] = v67;
        swift_bridgeObjectRetain();
      }

      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease_n();
      swift_bridgeObjectRelease();
      BOOL v5 = v74;
      a1 = v75;
      dictionary = v70;
      BOOL v4 = v77;
    }

    else
    {
      BOOL v25 = (const char *)(sub_18264EACC() + 32);
      swift_bridgeObjectRetain();
      os_log_type_t v26 = (nw_txt_record *)swift_unknownObjectRetain();
      LOBYTE(v25) = nw_txt_record_set_key(v26, v25, (const uint8_t *)"", 0LL);
      swift_unknownObjectRelease();
      swift_release();
      if ((v25 & 1) != 0)
      {
        swift_bridgeObjectRetain();
        BOOL v33 = swift_isUniquelyReferenced_nonNull_native();
        *(void *)os_log_type_t v78 = v72;
        char v35 = sub_181C8C078(v16, v17);
        BOOL v36 = *(void *)(v72 + 16);
        os_log_type_t v37 = (v34 & 1) == 0;
        v38 = v36 + v37;
        if (__OFADD__(v36, v37)) {
          goto LABEL_67;
        }
        __int16 v39 = v34;
        if (*(void *)(v72 + 24) >= v38)
        {
          if ((v33 & 1) == 0) {
            sub_181C90F98();
          }
        }

        else
        {
          sub_181C8D378(v38, v33);
          v40 = sub_181C8C078(v16, v17);
          if ((v39 & 1) != (v41 & 1)) {
            goto LABEL_70;
          }
          char v35 = v40;
        }

        id v42 = *(void **)v78;
        os_log_type_t v72 = *(void *)v78;
        if ((v39 & 1) != 0)
        {
          __int16 v43 = *(void *)(*(void *)v78 + 56LL) + 24 * v35;
          sub_181BDA14C(*(void *)v43, *(void *)(v43 + 8), *(_BYTE *)(v43 + 16));
          *(_OWORD *)__int16 v43 = xmmword_1826610B0;
          *(_BYTE *)(v43 + 16) = 2;
        }

        else
        {
          *(void *)(*(void *)v78 + 8 * (v35 >> 6) + 64) |= 1LL << v35;
          int v44 = (uint64_t *)(v42[6] + 16 * v35);
          const char *v44 = v16;
          v44[1] = v17;
          __int16 v45 = v42[7] + 24 * v35;
          *(_OWORD *)__int16 v45 = xmmword_1826610B0;
          *(_BYTE *)(v45 + 16) = 2;
          uint64_t v46 = v42[2];
          uint64_t v47 = __OFADD__(v46, 1LL);
          os_log_type_t v48 = v46 + 1;
          if (v47) {
            goto LABEL_69;
          }
          v42[2] = v48;
          swift_bridgeObjectRetain();
        }

        swift_bridgeObjectRelease_n();
      }

  if (v7) {
    free(v7);
  }
  return 0LL;
}

  if (v13) {
    free(v13);
  }
  uint64_t v3 = 0LL;
LABEL_7:
}

    goto LABEL_52;
  }

  if (v8)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v7 + 2);
    if (*((_BYTE *)v7 + 113))
    {
      os_log_type_t v10 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 57);
LABEL_8:
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 2);
      if (v9) {
        v9[2](v9, v10);
      }

      goto LABEL_11;
    }

    char v11 = v7;
    os_log_type_t v12 = v8;
    int v13 = v12;
    if (!*((void *)v11 + 19))
    {
      posix_error = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 53);
LABEL_7:
      os_log_type_t v10 = posix_error;

      goto LABEL_8;
    }

    if (dispatch_data_get_size(v12) - 4294967278u < 0xFFFFFFFF00000013LL)
    {
      __nwlog_obj();
      id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        id v28 = *((void *)v11 + 3);
        os_log_type_t v29 = *((_DWORD *)v11 + 42);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v28;
        BOOL v71 = 1042;
        *(_DWORD *)os_log_type_t v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = (char *)v11 + 115;
        BOOL v73 = 1024;
        os_log_type_t v74 = v29;
        BOOL v75 = 2112;
        os_log_type_t v76 = @"Bad TX data size";
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@",  buf,  0x36u);
      }

      if (!*((void *)v11 + 19)) {
        goto LABEL_39;
      }
      goto LABEL_37;
    }

    if (!*((void *)v11 + 23))
    {
      __nwlog_obj();
      os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        BOOL v33 = *((void *)v11 + 3);
        os_log_type_t v34 = *((_DWORD *)v11 + 42);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v33;
        BOOL v71 = 1042;
        *(_DWORD *)os_log_type_t v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = (char *)v11 + 115;
        BOOL v73 = 1024;
        os_log_type_t v74 = v34;
        BOOL v75 = 2112;
        os_log_type_t v76 = @"No rx_ring";
        _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@",  buf,  0x36u);
      }

      if (!*((void *)v11 + 19)) {
        goto LABEL_39;
      }
LABEL_37:
      goto LABEL_39;
    }

    if (os_channel_available_slot_count())
    {
LABEL_60:
      os_log_type_t v68 = 0LL;
      if (os_channel_packet_alloc())
      {
        char v35 = *((void *)v11 + 19);
        __nwlog_obj();
        BOOL v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v37 = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
        if (v35)
        {
          if (!v37) {
            goto LABEL_71;
          }
          v38 = *((void *)v11 + 3);
          __int16 v39 = *((_DWORD *)v11 + 42);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v38;
          BOOL v71 = 1042;
          *(_DWORD *)os_log_type_t v72 = 16;
          *(_WORD *)&v72[4] = 2098;
          *(void *)&v72[6] = (char *)v11 + 115;
          BOOL v73 = 1024;
          os_log_type_t v74 = v39;
          BOOL v75 = 2112;
          os_log_type_t v76 = @"Failed to alloc TX packet";
          v40 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
          __int16 v41 = v36;
          id v42 = 54;
        }

        else
        {
          if (!v37) {
            goto LABEL_71;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v11;
          BOOL v71 = 2112;
          *(void *)os_log_type_t v72 = @"Failed to alloc TX packet";
          v40 = "%{public}s [%{public}@]  %@";
          __int16 v41 = v36;
          id v42 = 32;
        }

        _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
LABEL_71:

        if (*((void *)v11 + 19)) {
          goto LABEL_72;
        }
        goto LABEL_74;
      }

      __int16 v51 = *((void *)v11 + 19);
      __nwlog_obj();
      size_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v53 = os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
      if (v51)
      {
        if (!v53) {
          goto LABEL_92;
        }
        v54 = *((void *)v11 + 3);
        os_log_type_t v55 = *((_DWORD *)v11 + 42);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v54;
        BOOL v71 = 1042;
        *(_DWORD *)os_log_type_t v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = (char *)v11 + 115;
        BOOL v73 = 1024;
        os_log_type_t v74 = v55;
        BOOL v75 = 2112;
        os_log_type_t v76 = @"no TX packet";
        v56 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
        os_log_type_t v57 = v52;
        v58 = 54;
      }

      else
      {
        if (!v53) {
          goto LABEL_92;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v11;
        BOOL v71 = 2112;
        *(void *)os_log_type_t v72 = @"no TX packet";
        v56 = "%{public}s [%{public}@]  %@";
        os_log_type_t v57 = v52;
        v58 = 32;
      }

      _os_log_impl(&dword_181A5C000, v57, OS_LOG_TYPE_ERROR, v56, buf, v58);
LABEL_92:

      if (*((void *)v11 + 19))
      {
LABEL_72:
      }

        free(v7);
        goto LABEL_52;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v40 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_framer_protocol_add_input_handler";
          _os_log_impl(&dword_181A5C000, v8, v40, "%{public}s called with null framer->parent_definition", buf, 0xCu);
        }

        goto LABEL_52;
      }

      if (!(_BYTE)v56)
      {
        __nwlog_obj();
        char v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v44 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v35,  v44,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_51;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v41 = type[0];
      id v42 = os_log_type_enabled(v35, type[0]);
      if (!backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v35, v41, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_51;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
        v58 = 2082;
        os_log_type_t v59 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v35,  v41,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

        free(v15);
        goto LABEL_13;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_add_member";
        _os_log_impl(&dword_181A5C000, v16, v21, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = v34;
      if (os_log_type_enabled(v16, v34))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_add_member";
        _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_52:
      if (v14) {
        free(v14);
      }
      goto LABEL_18;
    }

    if (!v26)
    {
      __nwlog_obj();
      __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
        _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v22 = type;
    uint64_t v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
        _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_51;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_group_descriptor_add_endpoint";
      os_log_type_t v30 = 2082;
      os_log_type_t v31 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v11) {
LABEL_52:
  }
    free(v11);
LABEL_53:
}

      goto LABEL_52;
    }

    if (!v46)
    {
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v26 = type;
    id v27 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        size_t v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s nw_hash_table_create_no_lock failed, no backtrace",  buf,  0xCu);
      }

      goto LABEL_51;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      size_t v49 = "nw_protocol_instance_set_flow_for_key";
      BOOL v50 = 2082;
      __int16 v51 = (uint64_t)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

          if (v19) {
            free(v19);
          }
          if (v30 != &nw_protocol_ref_counted_handle) {
            goto LABEL_23;
          }
LABEL_22:
          nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
LABEL_23:
          if (v7 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)&v37);
          }
        }
      }
    }
  }

        goto LABEL_52;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v27 = type;
      os_log_type_t v30 = os_log_type_enabled(v26, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v50 = "nw_authentication_credential_cache_entry_get_for_proxy";
          id v28 = "%{public}s called with null cache_entry, no backtrace";
          goto LABEL_50;
        }

        goto LABEL_51;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v50 = "nw_authentication_credential_cache_entry_get_for_proxy";
        __int16 v51 = 2082;
        size_t v52 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s called with null cache_entry, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (v15) {
      free(v15);
    }
    uint64_t v7 = 0LL;
    goto LABEL_26;
  }

  os_log_type_t v29 = 0u;
  os_log_type_t v30 = 0u;
  uint64_t v3 = (char *)v1;
  BOOL v4 = v3;
  BOOL v5 = *(_OWORD *)(v3 + 56);
  *(_OWORD *)buf = *(_OWORD *)(v3 + 40);
  *(_OWORD *)&buf[16] = v5;
  if (*(void *)buf | *(void *)&buf[8] | (unint64_t)v5 | *((void *)&v5 + 1))
  {
    os_log_type_t v6 = *(_OWORD *)(v3 + 56);
    os_log_type_t v29 = *(_OWORD *)(v3 + 40);
    os_log_type_t v30 = v6;
  }

  v26[2] = v29;
  v26[3] = v30;
  if ((unint64_t)v29 | *((void *)&v29 + 1) | (unint64_t)v30 | *((void *)&v30 + 1))
  {
    v26[0] = v29;
    v26[1] = v30;
    uint64_t v7 = (id)nw_application_id_create_with_audit_token(v26);
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_application_id";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v7;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s getting application ID %@ from parameters audit token",  buf,  0x16u);
      }
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  *(_OWORD *)uu = *(_OWORD *)(*((void *)v4 + 13) + 24LL);
  if (!uuid_is_null(uu))
  {
    if (v7)
    {
      uint64_t v7 = v7;
      *((_OWORD *)v7 + 1) = *(_OWORD *)uu;

      if (!gLogDatapath) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v7 = (id)nw_application_id_create_with_uuid(uu);
      if (!gLogDatapath) {
        goto LABEL_15;
      }
    }

    __nwlog_obj();
    os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_parameters_copy_application_id";
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v7;
      *(_WORD *)&buf[22] = 1040;
      *(_DWORD *)&buf[24] = 16;
      *(_WORD *)&buf[28] = 2096;
      *(void *)&buf[30] = uu;
      _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s getting application ID %@ from parameters UUID: %{uuid_t}.16P",  buf,  0x26u);
    }
  }

      free(v34);
    }
  }

    if (v22) {
      free(v22);
    }
    return 0LL;
  }

  BOOL v14 = v13;
  if (a3)
  {
    __int16 v15 = strdup(a3);
    if (!v15)
    {
      __nwlog_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      __int16 v43 = "strict_strdup";
      os_log_type_t v26 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v26);
      if (result) {
        goto LABEL_54;
      }
      free(v26);
    }

    *((void *)v14 + 29) = v15;
  }

  if (a2)
  {
    BOOL v16 = strdup(a2);
    if (!v16)
    {
      __nwlog_obj();
      id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      __int16 v43 = "strict_strdup";
      id v28 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v28);
      if (result) {
        goto LABEL_54;
      }
      free(v28);
    }

    *((void *)v14 + 30) = v16;
  }

  if (!uuid_is_null(a4))
  {
    *(_OWORD *)(v14 + 248) = *(_OWORD *)a4;
    if (!a5) {
      goto LABEL_16;
    }
LABEL_13:
    if (*a5)
    {
      int v17 = strdup(a5);
      if (!v17)
      {
        __nwlog_obj();
        os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        __int16 v43 = "strict_strdup";
        BOOL v33 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v33);
        if (result) {
          goto LABEL_54;
        }
        free(v33);
      }

      *((void *)v14 + 33) = v17;
    }

    goto LABEL_16;
  }

  if (a5) {
    goto LABEL_13;
  }
LABEL_16:
  if (a6 && *a6)
  {
    __int16 v18 = strdup(a6);
    if (!v18)
    {
      __nwlog_obj();
      os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      __int16 v43 = "strict_strdup";
      char v35 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v35);
      if (result) {
        goto LABEL_54;
      }
      free(v35);
    }

    *((void *)v14 + 34) = v18;
  }

  if (!a7 || !*a7) {
    return (BOOL)v14;
  }
  id v19 = strdup(a7);
  if (v19) {
    goto LABEL_23;
  }
  __nwlog_obj();
  BOOL v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  __int16 v43 = "strict_strdup";
  os_log_type_t v37 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v37);
  if (!result)
  {
    free(v37);
LABEL_23:
    *((void *)v14 + 36) = v19;
    return (BOOL)v14;
  }

      if (v14) {
        free(v14);
      }
      dispatch_source_cancel((dispatch_source_t)network_config_setup_policy_event_watcher(void)::kevsrc);
    }
  }

      int v13 = 0LL;
LABEL_58:

      _Block_object_dispose(v63, 8);
      goto LABEL_59;
    }

    __nwlog_obj();
    __int16 v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v63 = 136446210;
    *(void *)&v63[4] = "nw_connection_read_multiple";
    v40 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v40, buf, &type))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        __int16 v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v44 = buf[0];
        if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v63 = 136446210;
          *(void *)&v63[4] = "nw_connection_read_multiple";
          _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null handler", v63, 0xCu);
        }

        nw_protocol_masque_reset_demux_protocol(a1);
        id v27 = handle[5].callbacks;
        if (v27)
        {
          id v28 = nw_protocol_options_access_handle(v27, &__block_literal_global_73);
          os_log_type_t v29 = handle->default_input_handler;
          if (!v29) {
            goto LABEL_107;
          }
        }

        else
        {
          id v28 = 0;
          os_log_type_t v29 = handle->default_input_handler;
          if (!v29) {
            goto LABEL_107;
          }
        }

        name = v29->identifier->name;
        if (!name)
        {
LABEL_93:
          os_log_type_t v48 = v29->default_input_handler;
          if (!v48 || (size_t v49 = v48->identifier->name) == 0LL || strncmp(v49, "ohttp", 5uLL))
          {
            if ((v28 & 1) == 0
              && (!name || strcmp(name, "tls") && strcmp(name, "quic") && strcmp(name, "quic-connection")))
            {
              goto LABEL_107;
            }

      free(v22);
      if (!v15) {
        return;
      }
LABEL_67:
      free(v15);
      return;
    }

    BOOL v16 = (os_log_s *)__nwlog_obj();
    int v17 = type;
    if (!os_log_type_enabled(v16, type)) {
      goto LABEL_66;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
    __int16 v18 = "%{public}s called with null masque->context";
LABEL_65:
    _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
    goto LABEL_66;
  }

  else {
    os_log_type_t v6 = 0LL;
  }
  globals_for_protocol = (_BYTE *)nw_context_get_globals_for_protocol(v5, v6);
  if (!globals_for_protocol)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
    __int16 v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      int v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      __int16 v18 = "%{public}s called with null globals";
      goto LABEL_65;
    }

    if (!v26)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      int v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      __int16 v18 = "%{public}s called with null globals, backtrace limit exceeded";
      goto LABEL_65;
    }

    os_log_type_t v22 = (char *)__nw_create_backtrace_string();
    BOOL v16 = (os_log_s *)__nwlog_obj();
    int v17 = type;
    BOOL v25 = os_log_type_enabled(v16, type);
    if (!v22)
    {
      if (!v25) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      __int16 v18 = "%{public}s called with null globals, no backtrace";
      goto LABEL_65;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      os_log_type_t v30 = 2082;
      os_log_type_t v31 = v22;
      os_log_type_t v24 = "%{public}s called with null globals, dumping backtrace:%{public}s";
      goto LABEL_50;
    }

    goto LABEL_51;
  }

  os_log_type_t v8 = *__s;
  globals_for_protocol[4] = v8;
  BOOL v9 = globals_for_protocol + 4;
  if (v8)
  {
    os_log_type_t v10 = __s[1];
    globals_for_protocol[5] = v10;
    if (v10)
    {
      char v11 = __s[2];
      globals_for_protocol[6] = v11;
      if (v11)
      {
        os_log_type_t v12 = __s[3];
        globals_for_protocol[7] = v12;
        if (v12)
        {
          int v13 = __s[4];
          globals_for_protocol[8] = v13;
          if (v13)
          {
            BOOL v14 = __s[5];
            globals_for_protocol[9] = v14;
            if (v14) {
              globals_for_protocol[10] = 0;
            }
          }
        }
      }
    }
  }

  if ((*(_BYTE *)(v4 + 529) & 1) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    id v19 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      os_log_type_t v29 = "nw_masque_store_cached_geohash_value";
      os_log_type_t v30 = 2082;
      os_log_type_t v31 = (char *)(v4 + 531);
      os_log_type_t v32 = 2080;
      BOOL v33 = " ";
      os_log_type_t v34 = 2082;
      char v35 = v9;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sStoring geohash hint %{public}s",  buf,  0x2Au);
    }
  }

    if (v19) {
      free(v19);
    }
LABEL_53:

LABEL_54:
    int v13 = 0LL;
    goto LABEL_55;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  char v35 = __Block_byref_object_copy__4;
  BOOL v36 = __Block_byref_object_dispose__5;
  os_log_type_t v37 = 0LL;
  v31[0] = MEMORY[0x1895F87A8];
  v31[1] = 3221225472LL;
  v31[2] = __nw_http_client_metadata_get_initial_request_block_invoke;
  v31[3] = &unk_189BC60A8;
  v31[4] = buf;
  os_log_type_t v10 = *((void *)v7 + 4);
  if (v10)
  {
    __nw_http_client_metadata_get_initial_request_block_invoke((uint64_t)v31, v10);
    char v11 = *(void **)(*(void *)&buf[8] + 40LL);
  }

  else
  {
    char v11 = 0LL;
  }

  os_log_type_t v12 = v11;
  _Block_object_dispose(buf, 8);

  if (!v12) {
    goto LABEL_54;
  }
  int v13 = nw_http_request_copy_url_request(v12, (void *)*MEMORY[0x1896020E0], 0LL);

LABEL_55:
  return (NSURLRequest *)(id)v13;
}

    if (v19) {
      free(v19);
    }
    goto LABEL_27;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v12 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_get_counts";
    _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
  }

LABEL_28:
}

      if (!v19) {
        return 0LL;
      }
      os_log_type_t v26 = (char *)v19;
LABEL_53:
      free(v26);
      return 0LL;
    }

    if (v61)
    {
      uint64_t v23 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      uint64_t v21 = type;
      os_log_type_t v24 = os_log_type_enabled(v20, type);
      if (v23)
      {
        if (v24) {
          goto LABEL_40;
        }
        goto LABEL_41;
      }

      if (!v24) {
        goto LABEL_51;
      }
      goto LABEL_49;
    }

    uint64_t v20 = (os_log_s *)__nwlog_obj();
    uint64_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_51;
    }
    goto LABEL_43;
  }

  if (output_handler_context)
  {
    char v11 = output_handler_context[4];
    if (!v11)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v18 = handle + 205;
      *(_DWORD *)buf = 136446722;
      os_log_type_t v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      os_log_type_t v66 = handle + 205;
      v67 = 2048;
      *(void *)os_log_type_t v68 = a2;
      id v19 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v61 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)gLogObj;
        uint64_t v21 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_28;
        }
        goto LABEL_51;
      }

      if (v61)
      {
        uint64_t v23 = (char *)__nw_create_backtrace_string();
        uint64_t v20 = (os_log_s *)__nwlog_obj();
        uint64_t v21 = type;
        BOOL v25 = os_log_type_enabled(v20, type);
        if (v23)
        {
          if (v25)
          {
LABEL_40:
            *(_DWORD *)buf = 136446978;
            os_log_type_t v64 = "nw_protocol_http2_transport_connect";
            v65 = 2082;
            os_log_type_t v66 = v18;
            v67 = 2048;
            *(void *)os_log_type_t v68 = a2;
            *(_WORD *)&v68[8] = 2082;
            *(void *)&v68[10] = v23;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s %{public}s hash node for protocol %p did not have stream as extra, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

        if (!v26)
        {
LABEL_53:
          os_log_type_t v29 = 0LL;
          os_log_type_t v30 = __src;
LABEL_54:
          v107[3] = (uint64_t)v29;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v43 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v116 = "nw_proxy_config_serialize_one_stack";
            int v117 = 2112;
            __int16 v118 = (size_t)v22;
            _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s Serialized proxy transport protocol %@",  buf,  0x16u);
          }

          if (!v30) {
            goto LABEL_69;
          }
          goto LABEL_68;
        }

      free(v14);
      if (!v8) {
        goto LABEL_68;
      }
LABEL_67:
      free(v8);
      goto LABEL_68;
    }

    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_66;
    }
    *(_DWORD *)buf = 136446210;
    id v28 = "nw_http1_get_http1_protocol";
    char v11 = "%{public}s called with null handle";
LABEL_65:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_66;
  }

  BOOL v4 = *(_DWORD *)(v3 + 24);
  if (v4 == 1) {
    goto LABEL_10;
  }
  if (v4 != 2)
  {
    if (v4 != 3) {
      goto LABEL_68;
    }
    BOOL v5 = *(void *)(v3 + 16);
    if (v5)
    {
      uint64_t v3 = v5 + 480;
      goto LABEL_10;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v28 = "nw_http1_get_http1_protocol";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      id v28 = "nw_http1_get_http1_protocol";
      char v11 = "%{public}s called with null handle->http1_connection";
      goto LABEL_65;
    }

    if (!v25)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      id v28 = "nw_http1_get_http1_protocol";
      char v11 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
      goto LABEL_65;
    }

    BOOL v14 = (char *)__nw_create_backtrace_string();
    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    int v17 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v17) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      id v28 = "nw_http1_get_http1_protocol";
      char v11 = "%{public}s called with null handle->http1_connection, no backtrace";
      goto LABEL_65;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      id v28 = "nw_http1_get_http1_protocol";
      os_log_type_t v29 = 2082;
      os_log_type_t v30 = v14;
      BOOL v16 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
      goto LABEL_50;
    }

    goto LABEL_51;
  }

  os_log_type_t v6 = *(void *)(v3 + 8);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v28 = "nw_http1_get_http1_protocol";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      id v28 = "nw_http1_get_http1_protocol";
      char v11 = "%{public}s called with null handle->http1_stream";
      goto LABEL_65;
    }

    if (!v25)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      id v28 = "nw_http1_get_http1_protocol";
      char v11 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_65;
    }

    BOOL v14 = (char *)__nw_create_backtrace_string();
    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    __int16 v18 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v18) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      id v28 = "nw_http1_get_http1_protocol";
      char v11 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_65;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      id v28 = "nw_http1_get_http1_protocol";
      os_log_type_t v29 = 2082;
      os_log_type_t v30 = v14;
      BOOL v16 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_50;
    }

    goto LABEL_51;
  }

  uint64_t v3 = v6 + 248;
LABEL_10:
  if (*(void *)v3)
  {
    if (a3)
    {
      uint64_t v7 = a3[1] & 0xFFFFFFF8;
      *a3 = -1;
      a3[1] = v7;
    }

    return;
  }

LABEL_52:
  if (v14) {
LABEL_53:
  }
    free(v14);
LABEL_64:
}

      free(backtrace_string);
      goto LABEL_74;
    }

    id v19 = (os_log_s *)__nwlog_obj();
    uint64_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_74;
    }
    *(_DWORD *)buf = 136446210;
    char v35 = "nw_protocol_common_copy_info";
    uint64_t v21 = "%{public}s called with null protocol";
LABEL_73:
    _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
LABEL_74:
    if (v18) {
      free(v18);
    }
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v35 = "nw_protocol_common_copy_info";
    __int16 v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v19 = (os_log_s *)__nwlog_obj();
      uint64_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      char v35 = "nw_protocol_common_copy_info";
      uint64_t v21 = "%{public}s called with null type";
      goto LABEL_73;
    }

    if (!v32)
    {
      id v19 = (os_log_s *)__nwlog_obj();
      uint64_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      char v35 = "nw_protocol_common_copy_info";
      uint64_t v21 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_73;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v19 = (os_log_s *)__nwlog_obj();
    uint64_t v20 = type;
    id v28 = os_log_type_enabled(v19, type);
    if (backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        char v35 = "nw_protocol_common_copy_info";
        BOOL v36 = 2082;
        os_log_type_t v37 = backtrace_string;
        id v27 = "%{public}s called with null type, dumping backtrace:%{public}s";
        goto LABEL_50;
      }

      goto LABEL_51;
    }

    if (!v28) {
      goto LABEL_74;
    }
    *(_DWORD *)buf = 136446210;
    char v35 = "nw_protocol_common_copy_info";
    uint64_t v21 = "%{public}s called with null type, no backtrace";
    goto LABEL_73;
  }

  v2 = *(void *)(a1 + 32);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(void **)(v2 + 40);
  if (v3 == &nw_protocol_ref_counted_handle)
  {
    BOOL v4 = *(void *)(v2 + 88);
    if (v4) {
      *(void *)(v2 + 88) = v4 + 1;
    }
  }

  BOOL v5 = *(void *)(v2 + 24);
  if (v5)
  {
    os_log_type_t v6 = *(uint64_t (**)(uint64_t))(v5 + 224);
    if (v6)
    {
      uint64_t v7 = v6(v2);
      if (v3 != &nw_protocol_ref_counted_handle) {
        return v7;
      }
      goto LABEL_10;
    }
  }

  __nwlog_obj();
  os_log_type_t v12 = *(const char **)(v2 + 16);
  *(_DWORD *)buf = 136446722;
  char v35 = "__nw_protocol_copy_info";
  if (!v12) {
    os_log_type_t v12 = "invalid";
  }
  BOOL v36 = 2082;
  os_log_type_t v37 = (void *)v12;
  v38 = 2048;
  __int16 v39 = v2;
  int v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v32 = 0;
  if (__nwlog_fault(v13, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      __int16 v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_65;
      }
      BOOL v16 = *(const char **)(v2 + 16);
      if (!v16) {
        BOOL v16 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      char v35 = "__nw_protocol_copy_info";
      BOOL v36 = 2082;
      os_log_type_t v37 = (void *)v16;
      v38 = 2048;
      __int16 v39 = v2;
      int v17 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback";
LABEL_64:
      _os_log_impl(&dword_181A5C000, v14, v15, v17, buf, 0x20u);
      goto LABEL_65;
    }

    if (!v32)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      __int16 v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_65;
      }
      os_log_type_t v29 = *(const char **)(v2 + 16);
      if (!v29) {
        os_log_type_t v29 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      char v35 = "__nw_protocol_copy_info";
      BOOL v36 = 2082;
      os_log_type_t v37 = (void *)v29;
      v38 = 2048;
      __int16 v39 = v2;
      int v17 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback, backtrace limit exceeded";
      goto LABEL_64;
    }

    os_log_type_t v22 = (char *)__nw_create_backtrace_string();
    BOOL v14 = (os_log_s *)__nwlog_obj();
    __int16 v15 = type;
    uint64_t v23 = os_log_type_enabled(v14, type);
    if (!v22)
    {
      if (!v23) {
        goto LABEL_65;
      }
      os_log_type_t v30 = *(const char **)(v2 + 16);
      if (!v30) {
        os_log_type_t v30 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      char v35 = "__nw_protocol_copy_info";
      BOOL v36 = 2082;
      os_log_type_t v37 = (void *)v30;
      v38 = 2048;
      __int16 v39 = v2;
      int v17 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback, no backtrace";
      goto LABEL_64;
    }

    if (v23)
    {
      os_log_type_t v24 = *(const char **)(v2 + 16);
      if (!v24) {
        os_log_type_t v24 = "invalid";
      }
      *(_DWORD *)buf = 136446978;
      char v35 = "__nw_protocol_copy_info";
      BOOL v36 = 2082;
      os_log_type_t v37 = (void *)v24;
      v38 = 2048;
      __int16 v39 = v2;
      v40 = 2082;
      __int16 v41 = v22;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s protocol %{public}s (%p) has invalid copy_info callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v22);
  }

                goto LABEL_112;
              }

              goto LABEL_112;
            }
          }

          else
          {
            id v27 = 0LL;
            *a1 = routed_interface_index;
          }

          if (gLogDatapath)
          {
            __nwlog_obj();
            os_log_type_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              v62 = "nw_nat64_get_interface_state_internal";
              v63 = 2082;
              *(void *)os_log_type_t v64 = v27;
              _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s bailing because path not satisfied: %{public}s",  buf,  0x16u);
            }

            goto LABEL_51;
          }

    if (v10) {
      free(v10);
    }
    goto LABEL_9;
  }

  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
  }
  BOOL v5 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (!v5)
  {
    __nwlog_obj();
    int v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v36 = "nw_quic_save_token_on_queue";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v33)
    {
      uint64_t v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v21 = type;
      os_log_type_t v22 = os_log_type_enabled(v15, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v36 = "nw_quic_save_token_on_queue";
          os_log_type_t v37 = 2082;
          v38 = (uint64_t)v20;
          _os_log_impl( &dword_181A5C000,  v15,  v21,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v20);
LABEL_62:
        if (!v14) {
          goto LABEL_8;
        }
LABEL_63:
        free(v14);
        goto LABEL_8;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_181A5C000, v15, v21, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v28 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v36 = "nw_quic_save_token_on_queue";
        _os_log_impl( &dword_181A5C000,  v15,  v28,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v13) {
      free(v13);
    }
    goto LABEL_9;
  }

  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
  }
  os_log_type_t v8 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (!v8)
  {
    __nwlog_obj();
    BOOL v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v39 = "nw_quic_save_0rtt_state_on_queue";
    int v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v36)
    {
      uint64_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v18, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v39 = "nw_quic_save_0rtt_state_on_queue";
          v40 = 2082;
          __int16 v41 = (uint64_t)v23;
          _os_log_impl( &dword_181A5C000,  v18,  v24,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
LABEL_62:
        if (!v17) {
          goto LABEL_8;
        }
LABEL_63:
        free(v17);
        goto LABEL_8;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_181A5C000, v18, v24, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl( &dword_181A5C000,  v18,  v31,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

          nw_array_append(v17, v13);
          os_log_type_t v30 = *(void *)(*(void *)(a1 + 40) + 144LL);
          if (v30)
          {
            os_log_type_t v31 = *(void *)(v30 + 24) - *(void *)(v30 + 16);
            os_log_type_t v32 = v31 >> 3;
            if (v31)
            {
              BOOL v33 = nw_array_create();
              std::vector<nw_object_wrapper_t>::reserve( v33 + 16,  ((uint64_t)(*(void *)(v30 + 24) - *(void *)(v30 + 16)) >> 3) - 1);
              char v35 = *(void ***)(v30 + 16);
              os_log_type_t v34 = *(void ***)(v30 + 24);
              while (v35 != v34)
              {
                if (*v35 != v13) {
                  nw_array_append(v33, *v35);
                }
                ++v35;
              }

    if (v21) {
      free(v21);
    }
    __int16 v18 = 0LL;
    goto LABEL_18;
  }

  if (!v9)
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__s = 136446210;
    id v42 = "nw_browser_check_and_remove_endpoints_locked";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    BOOL v36 = 0;
    if (__nwlog_fault(v21, buf, &v36))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v25 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          id v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null old_endpoint", (uint8_t *)__s, 0xCu);
        }

    if (v20) {
      free(v20);
    }
    goto LABEL_53;
  }

  os_log_type_t v24 = -9;
  if (size < 0xF7) {
    os_log_type_t v24 = size;
  }
  BOOL v25 = v24 + 8;
  if (a2) {
    *a2 = v25;
  }
  if (v25 <= 0x1Cu) {
    os_log_type_t v10 = 28LL;
  }
  else {
    os_log_type_t v10 = v25;
  }

LABEL_55:
  return v10;
}

    free(backtrace_string);
    if (!v10) {
      return;
    }
LABEL_75:
    free(v10);
    return;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v41 = "nw_protocol_http3_uni_stream_error";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v17 = (os_log_s *)__nwlog_obj();
      __int16 v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      BOOL v16 = "%{public}s called with null http3_stream";
      goto LABEL_72;
    }

    if (!v38)
    {
      int v17 = (os_log_s *)__nwlog_obj();
      __int16 v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      BOOL v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_72;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v17 = (os_log_s *)__nwlog_obj();
    __int16 v18 = type;
    id v28 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      BOOL v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_72;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      id v42 = 2082;
      __int16 v43 = backtrace_string;
      id v27 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_50;
    }

    goto LABEL_51;
  }

  if (gLogDatapath)
  {
    id v19 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_protocol_http3_uni_stream_error";
      id v42 = 2048;
      __int16 v43 = handle;
      _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }

  if ((*((_BYTE *)handle + 131) & 3) != 0 && (*((_BYTE *)handle + 131) & 8) == 0)
  {
    BOOL v4 = handle[6];
    if (v4)
    {
      BOOL v5 = *(void *)(v4 + 24);
      if (v5)
      {
        os_log_type_t v6 = *(void (**)(void))(v5 + 56);
        if (v6)
        {
          v6();
          return;
        }
      }
    }

    __nwlog_obj();
    uint64_t v7 = handle[6];
    os_log_type_t v8 = "invalid";
    if (v7)
    {
      BOOL v9 = *(const char **)(v7 + 16);
      if (v9) {
        os_log_type_t v8 = v9;
      }
    }

    *(_DWORD *)buf = 136446466;
    __int16 v41 = "nw_protocol_http3_uni_stream_error";
    id v42 = 2082;
    __int16 v43 = v8;
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v10, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_74;
        }
        int v13 = handle[6];
        BOOL v14 = "invalid";
        if (v13)
        {
          __int16 v15 = *(const char **)(v13 + 16);
          if (v15) {
            BOOL v14 = v15;
          }
        }

        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        id v42 = 2082;
        __int16 v43 = v14;
        BOOL v16 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_67:
        char v35 = v11;
        BOOL v36 = v12;
        os_log_type_t v37 = 22;
LABEL_73:
        _os_log_impl(&dword_181A5C000, v35, v36, v16, buf, v37);
        goto LABEL_74;
      }

      if (!v38)
      {
        char v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_74;
        }
        os_log_type_t v29 = handle[6];
        os_log_type_t v30 = "invalid";
        if (v29)
        {
          os_log_type_t v31 = *(const char **)(v29 + 16);
          if (v31) {
            os_log_type_t v30 = v31;
          }
        }

        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        id v42 = 2082;
        __int16 v43 = v30;
        BOOL v16 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_67;
      }

      uint64_t v20 = (char *)__nw_create_backtrace_string();
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      uint64_t v21 = os_log_type_enabled(v11, type);
      if (!v20)
      {
        if (!v21) {
          goto LABEL_74;
        }
        os_log_type_t v32 = handle[6];
        BOOL v33 = "invalid";
        if (v32)
        {
          os_log_type_t v34 = *(const char **)(v32 + 16);
          if (v34) {
            BOOL v33 = v34;
          }
        }

        *(_DWORD *)buf = 136446466;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        id v42 = 2082;
        __int16 v43 = v33;
        BOOL v16 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
        goto LABEL_67;
      }

      if (v21)
      {
        os_log_type_t v22 = handle[6];
        uint64_t v23 = "invalid";
        if (v22)
        {
          os_log_type_t v24 = *(const char **)(v22 + 16);
          if (v24) {
            uint64_t v23 = v24;
          }
        }

        *(_DWORD *)buf = 136446722;
        __int16 v41 = "nw_protocol_http3_uni_stream_error";
        id v42 = 2082;
        __int16 v43 = v23;
        int v44 = 2082;
        __int16 v45 = v20;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v20);
    }

          if (v26)
          {
            BOOL v36 = (char *)v26;
LABEL_53:
            free(v36);
          }

          return 0LL;
        }
      }

      else
      {
        int v17 = __CFADD__(a4, v12);
        id v19 = a4 + v12;
        if (!v17) {
          goto LABEL_22;
        }
      }
    }

    else
    {
      int v17 = __CFADD__(a4, v12);
      id v19 = a4 + v12;
      if (!v17) {
        goto LABEL_22;
      }
    }

    if (gLogDatapath)
    {
      uint64_t v47 = handle;
      os_log_type_t v48 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        size_t v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v54 = 2082;
        *(void *)os_log_type_t v55 = "maximum_bytes";
        *(_WORD *)&v55[8] = 2048;
        *(void *)v56 = v12;
        *(_WORD *)&v56[8] = 2048;
        os_log_type_t v57 = v19;
        _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
      }

      handle = v47;
      output_handler = a1->output_handler;
      if (!output_handler) {
        return 0LL;
      }
    }

    else
    {
      output_handler = a1->output_handler;
      if (!output_handler) {
        return 0LL;
      }
    }

    goto LABEL_23;
  }

  __break(1u);
  return result;
}

              nw_http3_signal_output_pending(*((void *)handle + 42), 0);
              return 1LL;
            }

            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
            v60 = (char *)_os_log_send_and_compose_impl();
            v101[0] = 16;
            LOBYTE(v91) = 0;
            if (__nwlog_fault(v60, v101, &v91))
            {
              if (v101[0] == 17)
              {
                os_log_type_t v61 = (os_log_s *)__nwlog_obj();
                v62 = v101[0];
                if (!os_log_type_enabled(v61, (os_log_type_t)v101[0])) {
                  goto LABEL_194;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                v63 = "%{public}s called with null http3";
                goto LABEL_193;
              }

              if (!(_BYTE)v91)
              {
                os_log_type_t v61 = (os_log_s *)__nwlog_obj();
                v62 = v101[0];
                if (!os_log_type_enabled(v61, (os_log_type_t)v101[0])) {
                  goto LABEL_194;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                v63 = "%{public}s called with null http3, backtrace limit exceeded";
                goto LABEL_193;
              }

              os_log_type_t v72 = (char *)__nw_create_backtrace_string();
              os_log_type_t v61 = (os_log_s *)__nwlog_obj();
              v62 = v101[0];
              BOOL v73 = os_log_type_enabled(v61, (os_log_type_t)v101[0]);
              if (v72)
              {
                if (v73)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v72;
                  _os_log_impl( &dword_181A5C000,  v61,  v62,  "%{public}s called with null http3, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v72);
                goto LABEL_194;
              }

              if (v73)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_should_connect";
                v63 = "%{public}s called with null http3, no backtrace";
LABEL_193:
                _os_log_impl(&dword_181A5C000, v61, v62, v63, buf, 0xCu);
              }
            }

  if (v16) {
    free(v16);
  }
LABEL_34:
}

  __break(1u);
  return result;
}

      if (!v27) {
        goto LABEL_54;
      }
      goto LABEL_52;
    }

    if (v22 >= (unint64_t)(v19 + 18) + 5)
    {
      *uint64_t v23 = a3;
      *(_DWORD *)(v23 + 1) = v20;
      if ((_DWORD)v19 != -18) {
        memcpy(v23 + 5, v21, (v19 + 18));
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v26 = (id)gLogObj;
      *(_DWORD *)buf = 136447490;
      v113 = "nw_necp_append_tlv";
      v114 = 2048;
      *(void *)v115 = v24;
      *(_WORD *)&v115[8] = 2048;
      *(void *)&v115[10] = (v19 + 18) + 5LL;
      __int16 v116 = 2048;
      os_log_type_t v90 = v25;
      *(void *)int v117 = v25;
      *(_WORD *)&v117[8] = 1024;
      *(_DWORD *)__int16 v118 = a3;
      *(_WORD *)&v118[4] = 1024;
      *(_DWORD *)&v118[6] = v19 + 18;
      id v27 = (const char *)_os_log_send_and_compose_impl();

      char v111 = OS_LOG_TYPE_ERROR;
      os_log_type_t v110 = 0;
      if (v111 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v28 = (os_log_s *)(id)gLogObj;
        os_log_type_t v29 = v111;
        if (os_log_type_enabled(v28, v111))
        {
          *(_DWORD *)buf = 136447490;
          v113 = "nw_necp_append_tlv";
          v114 = 2048;
          *(void *)v115 = v24;
          *(_WORD *)&v115[8] = 2048;
          *(void *)&v115[10] = (v19 + 18) + 5LL;
          __int16 v116 = 2048;
          *(void *)int v117 = v90;
          *(_WORD *)&v117[8] = 1024;
          *(_DWORD *)__int16 v118 = a3;
          *(_WORD *)&v118[4] = 1024;
          *(_DWORD *)&v118[6] = v19 + 18;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
        }

        goto LABEL_32;
      }

      if (!v41)
      {
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v27 = v42;
        if (os_log_type_enabled(v22, v42))
        {
          *(_DWORD *)buf = 136446466;
          __int16 v45 = "nw_path_copy_token_from_agent";
          uint64_t v46 = 1024;
          *(_DWORD *)uint64_t v47 = v18;
          _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }

        goto LABEL_51;
      }

      os_log_type_t v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = v42;
      os_log_type_t v26 = os_log_type_enabled(v22, v42);
      if (!v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v45 = "nw_path_copy_token_from_agent";
          uint64_t v46 = 1024;
          *(_DWORD *)uint64_t v47 = v18;
          _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d, no backtrace",  buf,  0x12u);
        }

        goto LABEL_51;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446722;
        __int16 v45 = "nw_path_copy_token_from_agent";
        uint64_t v46 = 1024;
        *(_DWORD *)uint64_t v47 = v18;
        *(_WORD *)&v47[4] = 2082;
        *(void *)&v47[6] = v24;
        _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v24);
    }

      free(backtrace_string);
    }

    if (v7)
    {
      os_log_type_t v30 = (char *)v7;
LABEL_60:
      free(v30);
    }

    return 0LL;
  }

  if (!a1->output_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_http_messaging_connect";
    uint64_t v7 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      BOOL v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_http_messaging_connect";
      os_log_type_t v10 = "%{public}s connect requires an output handler";
      goto LABEL_50;
    }

    if (!v35)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      BOOL v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_http_messaging_connect";
      os_log_type_t v10 = "%{public}s connect requires an output handler, backtrace limit exceeded";
      goto LABEL_50;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)gLogObj;
    BOOL v9 = type;
    os_log_type_t v26 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_http_messaging_connect";
      os_log_type_t v10 = "%{public}s connect requires an output handler, no backtrace";
      goto LABEL_50;
    }

    if (!v26)
    {
LABEL_40:
      free(backtrace_string);
      goto LABEL_51;
    }

    *(_DWORD *)buf = 136446466;
    v38 = "nw_protocol_http_messaging_connect";
    __int16 v39 = 2082;
    v40 = (nw_protocol *)backtrace_string;
    id v27 = "%{public}s connect requires an output handler, dumping backtrace:%{public}s";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v8, v9, v27, buf, 0x16u);
    goto LABEL_40;
  }

  if (handle->default_input_handler != a2)
  {
    output_handler = handle[2].output_handler;
    os_log_type_t v6 = (nw_protocol *)handle[2].handle;
    if (output_handler != v6)
    {
      while (*(nw_protocol **)output_handler->flow_id != a2)
      {
        output_handler = (nw_protocol *)((char *)output_handler + 16);
        if (output_handler == v6) {
          goto LABEL_31;
        }
      }
    }

    if (output_handler != v6)
    {
      char v11 = 1LL;
      *(_DWORD *)&output_handler->flow_id[8] = 1;
      return v11;
    }

  if (v28) {
    free(v28);
  }
  os_log_type_t v10 = 0LL;
LABEL_18:

  return v10;
}

      if (v13) {
        free(v13);
      }
      return 0LL;
    }

    if (!v29)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      __int16 v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_50;
      }

      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v14 = (os_log_s *)__nwlog_obj();
    __int16 v15 = type;
    __int16 v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_50;
      }

      goto LABEL_51;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v32 = "nw_protocol_http2_copy_info";
      BOOL v33 = 2082;
      os_log_type_t v34 = backtrace_string;
      id v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
    }

    id v27 = v40;
    *os_log_type_t v12 = v39;
    v12[1] = v27;
    id v28 = v41;
    os_log_type_t v29 = v42;
    os_log_type_t v30 = v44;
    v12[4] = v43;
    v12[5] = v30;
    v12[2] = v28;
    v12[3] = v29;
    os_log_type_t v31 = v45;
    os_log_type_t v32 = v46;
    BOOL v33 = v48;
    v12[8] = v47;
    v12[9] = v33;
    v12[6] = v31;
    v12[7] = v32;
    os_log_type_t v34 = v49;
    char v35 = v50;
    BOOL v36 = v51;
    *((void *)v12 + 26) = v52;
    v12[11] = v35;
    v12[12] = v36;
    v12[10] = v34;
    if (*((void *)&v52 + 1))
    {
      memcpy((char *)v12 + 216, *((const void **)&v52 + 1), DWORD1(v52));
      if (*((void *)&v52 + 1))
      {
        free(*((void **)&v52 + 1));
        *((void *)&v52 + 1) = 0LL;
      }
    }

    close(v3);
    uint64_t v23 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_data(v23, "data", v12, *((unsigned int *)v12 + 53) + 216LL);
    free(v12);
    return (BOOL)v23;
  }

  BOOL v25 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  buf = 136446722;
  v54 = "strict_calloc";
  os_log_type_t v55 = 2048;
  *(void *)v56 = 1LL;
  *(_WORD *)&v56[8] = 2048;
  *(void *)&v56[10] = v11;
  os_log_type_t v26 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    int v13 = DWORD1(v52);
    if (!DWORD1(v52)) {
      goto LABEL_51;
    }
    goto LABEL_13;
  }

  __break(1u);
  return result;
}

    if (v20) {
      free(v20);
    }
    return 0LL;
  }

  BOOL v4 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_browse_descriptor);
  BOOL v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v34 = "nw_browse_descriptor_create_bonjour_service";
    char v11 = (char *)_os_log_send_and_compose_impl();

    typea = OS_LOG_TYPE_ERROR;
    os_log_type_t v31 = 0;
    if (__nwlog_fault(v11, &typea, &v31))
    {
      if (typea == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        int v13 = typea;
        if (os_log_type_enabled(v12, typea))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s [nw_browse_descriptor init] failed", buf, 0xCu);
        }
      }

      else if (v31)
      {
        __int16 v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v16 = typea;
        int v17 = os_log_type_enabled(v12, typea);
        if (v15)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v34 = "nw_browse_descriptor_create_bonjour_service";
            char v35 = 2082;
            BOOL v36 = v15;
            _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s [nw_browse_descriptor init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v15);
          if (!v11) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s [nw_browse_descriptor init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        __int16 v18 = typea;
        if (os_log_type_enabled(v12, typea))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl( &dword_181A5C000,  v12,  v18,  "%{public}s [nw_browse_descriptor init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v11) {
      goto LABEL_17;
    }
LABEL_16:
    free(v11);
    goto LABEL_17;
  }

  *((_DWORD *)v4 + 2) = 1;
  os_log_type_t v6 = strdup(type);
  if (!v6)
  {
    __nwlog_obj();
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v34 = "strict_strdup";
    os_log_type_t v24 = (void *)_os_log_send_and_compose_impl();

    result = (nw_browse_descriptor_t)__nwlog_abort((uint64_t)v24);
    if ((_DWORD)result) {
      goto LABEL_54;
    }
    free(v24);
  }

  *((void *)v5 + 2) = v6;
  uint64_t v7 = strlen(type) - 1;
  if (type[v7] == 46) {
    v6[v7] = 0;
  }
  if (!domain) {
    goto LABEL_9;
  }
  os_log_type_t v8 = strdup(domain);
  if (v8)
  {
LABEL_8:
    *((void *)v5 + 3) = v8;
LABEL_9:
    *((_BYTE *)v5 + 112) &= ~1u;
    BOOL v9 = v5;
LABEL_17:

    return (nw_browse_descriptor_t)v5;
  }

  __nwlog_obj();
  id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v34 = "strict_strdup";
  os_log_type_t v29 = (void *)_os_log_send_and_compose_impl();

  result = (nw_browse_descriptor_t)__nwlog_abort((uint64_t)v29);
  if (!(_DWORD)result)
  {
    free(v29);
    goto LABEL_8;
  }

        goto LABEL_52;
      }

      if (!v41)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        id v28 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          int v44 = "nw_browse_descriptor_create_custom";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = 1000;
          _os_log_impl( &dword_181A5C000,  v10,  v28,  "%{public}s Custom browse descriptor type values must start at %d, backtrace limit exceeded",  buf,  0x12u);
        }

        goto LABEL_51;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      uint64_t v20 = type;
      uint64_t v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          int v44 = "nw_browse_descriptor_create_custom";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = 1000;
          _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s Custom browse descriptor type values must start at %d, no backtrace",  buf,  0x12u);
        }

        goto LABEL_51;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446722;
        int v44 = "nw_browse_descriptor_create_custom";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = 1000;
        v46[2] = 2082;
        *(void *)&v46[3] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s Custom browse descriptor type values must start at %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

void sub_181ADCA48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_path_set_reason_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v2 = *(void **)(v1 + 256);
  *(void *)(v1 + 256) = 0LL;
}

void *nw_path_copy_without_parameters(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = (void *)[a1 copy];
  if (v1)
  {
    nw_parameters_t v2 = nw_parameters_create();
    uint64_t v3 = (void *)v1[2];
    v1[2] = v2;

    BOOL v4 = v1;
    goto LABEL_10;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v17 = "nw_path_copy_without_parameters";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    os_log_type_t v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_path_copy_without_parameters";
      _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s [path copy] failed", buf, 0xCu);
    }

void sub_181ADCD68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_parameters_t nw_parameters_create(void)
{
  v0 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters);
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
  if (v1)
  {
    options = nw_protocol_create_options((void *)g_ip_definition);
    internet_protocol = v1->internet_protocol;
    v1->internet_protocol = (OS_nw_protocol_options *)options;
  }

  BOOL v4 = -[NWConcrete_nw_parameters initWithStack:]((id *)&v0->super.isa, v1);

  return (nw_parameters_t)v4;
}

void sub_181ADD758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_evaluator_set_logging(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 24);
    HIBYTE(v2[26]._os_unfair_lock_opaque) &= ~0x40u;
    os_unfair_lock_unlock(v2 + 24);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_path_evaluator_set_logging";
  BOOL v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_path_evaluator_set_logging";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null evaluator, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_path_evaluator_set_logging";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null evaluator, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_path_evaluator_set_update_handler(void *a1, void *a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  os_log_type_t v8 = v7;
  if (v5)
  {
    if (v7)
    {
      nw_allow_use_of_dispatch_internal();
      if (v6) {
        nw_path_evaluator_set_queue(v5, v6);
      }
      id v9 = v8;
      os_log_type_t v10 = v5;
      os_unfair_lock_lock(v5 + 24);
      char v11 = _Block_copy(v9);

      BOOL v12 = *(void **)&v10[16]._os_unfair_lock_opaque;
      *(void *)&v10[16]._os_unfair_lock_opaque = v11;

      os_unfair_lock_unlock(v5 + 24);
      nw_path_evaluator_start(v10);
      uint64_t v13 = 1LL;
      goto LABEL_6;
    }

    __nwlog_obj();
    id v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_path_evaluator_set_update_handler";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v16, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null handler", buf, 0xCu);
        }

void sub_181ADDF34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_evaluator_start(void *a1)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  nw_allow_use_of_dispatch_internal();
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v1 + 24);
    if (*((void *)v1 + 6) || (nw_path_evaluator_evaluate((NWConcrete_nw_path_evaluator *)v1, 0LL) & 1) != 0)
    {
      if ((v1[107] & 0x30) != 0)
      {
LABEL_5:
        os_unfair_lock_unlock((os_unfair_lock_t)v1 + 24);
        goto LABEL_73;
      }

      v1[107] |= 0x10u;
      id v2 = nw_parameters_copy_context(*((void **)v1 + 1));
      nw_path_watch_necp_changes(v2);
      uint64_t globals_for_path = nw_context_get_globals_for_path(v2);
      BOOL v4 = (os_unfair_lock_s *)(globals_for_path + 124);
      os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
      if ((*(_BYTE *)(globals_for_path + 140) & 1) != 0)
      {
        uint64_t v6 = *(void *)(globals_for_path + 56);
        if (v6)
        {
          nw_queue_resume_source(v6, v5);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v7 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            size_t v53 = "nw_path_evaluator_start";
            _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, "%{public}s Resuming NECP source", buf, 0xCu);
          }
        }
      }

      if ((v1[107] & 1) == 0)
      {
        uuid_unparse((const unsigned __int8 *)v1 + 80, (char *)buf);
        uint64_t v8 = *(void *)(globals_for_path + 32);
        if (!v8)
        {
          id v9 = nw_dictionary_create();
          char v11 = *(void **)(globals_for_path + 32);
          os_log_type_t v10 = (uint64_t *)(globals_for_path + 32);
          *os_log_type_t v10 = (uint64_t)v9;

          uint64_t v8 = *v10;
        }

        nw_dictionary_set_value(v8, (const char *)buf, v1);
LABEL_64:
        os_unfair_lock_unlock(v4);
        if ((v1[107] & 0x40) != 0)
        {
          char v35 = nw_parameters_copy_context(*((void **)v1 + 1));
          if (!v35 || (BOOL v36 = v35[31] == 4, v35, !v36))
          {
            if (__nwlog_path_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44346);
            }
            os_log_type_t v37 = (os_log_s *)(id)gpathLogObj;
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              logging_description = nw_endpoint_get_logging_description(*((void **)v1 + 2));
              uint64_t v39 = *((void *)v1 + 1);
              uint64_t v40 = *((void *)v1 + 6);
              *(_DWORD *)buf = 136447490;
              size_t v53 = "nw_path_evaluator_start";
              __int16 v54 = 1042;
              *(_DWORD *)os_log_type_t v55 = 16;
              *(_WORD *)&v55[4] = 2098;
              *(void *)&v55[6] = v1 + 80;
              __int16 v56 = 2082;
              os_log_type_t v57 = logging_description;
              __int16 v58 = 2112;
              uint64_t v59 = v39;
              __int16 v60 = 2112;
              uint64_t v61 = v40;
              _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%{public,uuid_t}.16P %{public}s %@]\n\tpath: %@",  buf,  0x3Au);
            }
          }
        }

        os_unfair_lock_unlock((os_unfair_lock_t)v1 + 24);

        goto LABEL_73;
      }

      if (uuid_is_null((const unsigned __int8 *)globals_for_path))
      {
        *(_OWORD *)uint64_t globals_for_path = *((_OWORD *)v1 + 5);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v16 = (id)gLogObj;
        if (!os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_DEBUG))
        {
LABEL_61:

          uint64_t v31 = *(void *)(globals_for_path + 48);
          if (!v31)
          {
            BOOL v32 = nw_array_create();
            uint64_t v34 = *(void **)(globals_for_path + 48);
            BOOL v33 = (uint64_t *)(globals_for_path + 48);
            uint64_t *v33 = v32;

            uint64_t v31 = *v33;
          }

          nw_array_append(v31, v1);
          goto LABEL_64;
        }

        *(_DWORD *)buf = 136446210;
        size_t v53 = "nw_path_evaluator_start";
        uint64_t v17 = "%{public}s Registering client as default path evaluator";
LABEL_60:
        _os_log_impl(&dword_181A5C000, (os_log_t)v16, OS_LOG_TYPE_DEBUG, v17, buf, 0xCu);
        goto LABEL_61;
      }

      nw_path_shared_necp_fd(v2);
      if (!necp_client_action())
      {
LABEL_56:
        *((_OWORD *)v1 + 5) = *(_OWORD *)globals_for_path;
        uint64_t v30 = *((void *)v1 + 6);
        if (v30) {
          *(_OWORD *)(v30 + 120) = *(_OWORD *)globals_for_path;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v16 = (id)gLogObj;
        if (!os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_61;
        }
        *(_DWORD *)buf = 136446210;
        size_t v53 = "nw_path_evaluator_start";
        uint64_t v17 = "%{public}s Adding client to default path evaluator";
        goto LABEL_60;
      }

      int v21 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      size_t v53 = "nw_path_evaluator_start";
      __int16 v54 = 1024;
      *(_DWORD *)os_log_type_t v55 = v21;
      BOOL v23 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v50 = 0;
      if (__nwlog_fault(v23, &type, &v50))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446466;
            size_t v53 = "nw_path_evaluator_start";
            __int16 v54 = 1024;
            *(_DWORD *)os_log_type_t v55 = v21;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d",  buf,  0x12u);
          }
        }

        else if (v50)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v49 = type;
          BOOL v28 = os_log_type_enabled(v24, type);
          if (backtrace_string)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446722;
              size_t v53 = "nw_path_evaluator_start";
              __int16 v54 = 1024;
              *(_DWORD *)os_log_type_t v55 = v21;
              *(_WORD *)&v55[4] = 2082;
              *(void *)&v55[6] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v24,  v49,  "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(backtrace_string);
            goto LABEL_54;
          }

          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            size_t v53 = "nw_path_evaluator_start";
            __int16 v54 = 1024;
            *(_DWORD *)os_log_type_t v55 = v21;
            _os_log_impl( &dword_181A5C000,  v24,  v49,  "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446466;
            size_t v53 = "nw_path_evaluator_start";
            __int16 v54 = 1024;
            *(_DWORD *)os_log_type_t v55 = v21;
            _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

LABEL_90:
  if (v42) {
    free(v42);
  }
LABEL_73:
}

      if (v24) {
        free(v24);
      }
      return 0LL;
    }

    if (!v44)
    {
      os_log_type_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v47 = "__nw_protocol_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = type;
    char v35 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v47 = "__nw_protocol_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v47 = "__nw_protocol_finalize_output_frames";
      os_log_type_t v48 = 2082;
      os_log_type_t v49 = backtrace_string;
      BOOL v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_62;
    }

    if (!v15) {
      goto LABEL_93;
    }
    goto LABEL_91;
  }

  uint64_t v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);

  id v7 = *((void *)v3 + 5);
  if (!v7)
  {
    if (nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
      goto LABEL_93;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v13 = (id)gconnectionLogObj;
    logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446466;
    BOOL v71 = "nw_association_mark_flow_connected";
    os_log_type_t v72 = 2082;
    BOOL v73 = (void *)logging_description;
    os_log_type_t v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v16 = (os_log_s *)(id)gconnectionLogObj;
      uint64_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        os_log_type_t v18 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        BOOL v71 = "nw_association_mark_flow_connected";
        os_log_type_t v72 = 2082;
        BOOL v73 = (void *)v18;
        _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s <nw_association %{public}s> does not have a handle hash table",  buf,  0x16u);
      }

      goto LABEL_89;
    }

    if (v68 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v16 = (os_log_s *)(id)gconnectionLogObj;
      v38 = type;
      if (os_log_type_enabled(v16, type))
      {
        uint64_t v39 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        BOOL v71 = "nw_association_mark_flow_connected";
        os_log_type_t v72 = 2082;
        BOOL v73 = (void *)v39;
        _os_log_impl( &dword_181A5C000,  v16,  v38,  "%{public}s <nw_association %{public}s> does not have a handle hash table, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_89;
    }

    BOOL v23 = __nw_create_backtrace_string();
    if (!v23)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v16 = (os_log_s *)(id)gconnectionLogObj;
      uint64_t v40 = type;
      if (os_log_type_enabled(v16, type))
      {
        __int16 v41 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        BOOL v71 = "nw_association_mark_flow_connected";
        os_log_type_t v72 = 2082;
        BOOL v73 = (void *)v41;
        _os_log_impl( &dword_181A5C000,  v16,  v40,  "%{public}s <nw_association %{public}s> does not have a handle hash table, no backtrace",  buf,  0x16u);
      }

      goto LABEL_89;
    }

    os_log_type_t v24 = (char *)v23;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v16 = (os_log_s *)(id)gconnectionLogObj;
    os_log_type_t v25 = type;
    if (os_log_type_enabled(v16, type))
    {
      os_log_type_t v26 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446722;
      BOOL v71 = "nw_association_mark_flow_connected";
      os_log_type_t v72 = 2082;
      BOOL v73 = (void *)v26;
      os_log_type_t v74 = 2082;
      BOOL v75 = v24;
      _os_log_impl( &dword_181A5C000,  v16,  v25,  "%{public}s <nw_association %{public}s> does not have a handle hash table, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    goto LABEL_60;
  }

  node = nw_hash_table_get_node(v7, (uint64_t)v5, 0LL);
  if (!node)
  {
    if (nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
      goto LABEL_93;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v19 = (id)gconnectionLogObj;
    BOOL v20 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446722;
    BOOL v71 = "nw_association_mark_flow_connected";
    os_log_type_t v72 = 2082;
    BOOL v73 = (void *)v20;
    os_log_type_t v74 = 2048;
    BOOL v75 = v5;
    os_log_type_t v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v16 = (os_log_s *)(id)gconnectionLogObj;
      int v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        id v22 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        BOOL v71 = "nw_association_mark_flow_connected";
        os_log_type_t v72 = 2082;
        BOOL v73 = (void *)v22;
        os_log_type_t v74 = 2048;
        BOOL v75 = v5;
        _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s <nw_association %{public}s> does not have handle %p registered",  buf,  0x20u);
      }

              __break(1u);
            }

    if (v58) {
      free(v58);
    }
    goto LABEL_66;
  }

    if (v37) {
      free(v37);
    }
    os_log_type_t v24 = 0LL;
    goto LABEL_24;
  }

  id v22 = v20;
  BOOL v23 = *(id *)(v22[13] + 136LL);

  if (!v23)
  {
    __nwlog_obj();
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v66 = "nw_candidate_manager_copy_workloop";
    __int16 v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_181A5C000, v42, v43, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v63)
    {
      os_log_type_t v49 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v56 = type;
      char v50 = os_log_type_enabled(v42, type);
      if (v49)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v66 = "nw_candidate_manager_copy_workloop";
          v67 = 2082;
          os_log_type_t v68 = v49;
          _os_log_impl( &dword_181A5C000,  v42,  v56,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v49);
        if (!v41) {
          goto LABEL_101;
        }
        goto LABEL_100;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_181A5C000, v42, v56, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v54 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl( &dword_181A5C000,  v42,  v54,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_98;
  }

  os_log_type_t v24 = nw_context_copy_workloop(v23);
  if (v24) {
    goto LABEL_23;
  }
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  }
  os_log_type_t v25 = (id)nw_context_copy_implicit_context::implicit_context;
  os_log_type_t v24 = nw_context_copy_workloop(v25);

  if (v24) {
    goto LABEL_23;
  }
  __nwlog_obj();
  os_log_type_t v44 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v66 = "nw_candidate_manager_copy_workloop";
  __int16 v41 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v63 = 0;
  if (__nwlog_fault(v41, &type, &v63))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v45 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_181A5C000, v42, v45, "%{public}s called with null workloop", buf, 0xCu);
      }

  if (v22) {
    free(v22);
  }
LABEL_16:
  if (v9 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v13 = *(void *)(v5 + 88);
    if (v13)
    {
      char v14 = v13 - 1;
      *(void *)(v5 + 88) = v14;
      if (!v14)
      {
        os_log_type_t v15 = *(void (***)(void))(v5 + 64);
        if (v15)
        {
          *(void *)(v5 + 64) = 0LL;
          v15[2](v15);
          _Block_release(v15);
        }

        if ((*(_BYTE *)(v5 + 72) & 1) != 0)
        {
          id v16 = *(const void **)(v5 + 64);
          if (v16) {
            _Block_release(v16);
          }
        }

        free((void *)v5);
      }
    }
  }

  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v6 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v17 = *(void *)(v6 + 88);
    if (v17)
    {
      os_log_type_t v18 = v17 - 1;
      *(void *)(v6 + 88) = v18;
      if (!v18)
      {
        os_log_type_t v19 = *(void (***)(void))(v6 + 64);
        if (v19)
        {
          *(void *)(v6 + 64) = 0LL;
          v19[2](v19);
          _Block_release(v19);
        }

        if ((*(_BYTE *)(v6 + 72) & 1) != 0)
        {
          BOOL v20 = *(const void **)(v6 + 64);
          if (v20) {
            _Block_release(v20);
          }
        }

        goto LABEL_36;
      }
    }
  }

    if (!v23)
    {
LABEL_92:
      v38 = 0LL;
      goto LABEL_93;
    }

      goto LABEL_58;
    }

    if (!v39)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_protocol_instance_access_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v38,  "%{public}s called with null instance->context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v32 = type;
    BOOL v33 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_protocol_instance_access_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s called with null instance->context, no backtrace",  buf,  0xCu);
      }

      goto LABEL_90;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      id v42 = "nw_protocol_instance_access_globals";
      __int16 v43 = 2082;
      os_log_type_t v44 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s called with null instance->context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_57;
  }

      if (!v53) {
        goto LABEL_92;
      }
LABEL_91:
      free(v53);
      goto LABEL_92;
    }

    __nwlog_obj();
    v197 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v245 = "nw_protocol_utilities_add_input_handler";
    size_t v53 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v242 = OS_LOG_TYPE_DEFAULT;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v198 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446210;
        v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_181A5C000, v54, v198, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v242)
    {
      v202 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v203 = type;
      v204 = os_log_type_enabled(v54, type);
      if (v202)
      {
        if (v204)
        {
          *(_DWORD *)buf = 136446466;
          v245 = "nw_protocol_utilities_add_input_handler";
          v246 = 2082;
          v247 = (uint64_t)v202;
          _os_log_impl( &dword_181A5C000,  v54,  v203,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v202);
        goto LABEL_90;
      }

      if (v204)
      {
        *(_DWORD *)buf = 136446210;
        v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_181A5C000, v54, v203, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v208 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446210;
        v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl( &dword_181A5C000,  v54,  v208,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    free(v50);
    if (!v34) {
      goto LABEL_30;
    }
    goto LABEL_129;
  }

  if (*((_DWORD *)self + 32) == 2 && (*((_BYTE *)self + 302) & 1) == 0)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    os_log_type_t v86 = __Block_byref_object_copy__3;
    BOOL v87 = __Block_byref_object_dispose__4;
    os_log_type_t v88 = 0LL;
    *(void *)os_log_type_t type = 0LL;
    os_log_type_t v76 = type;
    BOOL v77 = 0x3032000000LL;
    os_log_type_t v78 = __Block_byref_object_copy__17859;
    BOOL v79 = __Block_byref_object_dispose__17860;
    v80 = 0LL;
    os_log_type_t v18 = MEMORY[0x1895F87A8];
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __78__NWConcrete_nw_listener_handleInboundPacket_length_from_to_interface_socket___block_invoke;
    aBlock[3] = &unk_189BC16A8;
    aBlock[4] = self;
    aBlock[5] = buf;
    aBlock[6] = type;
    os_log_type_t v19 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)self + 2);
    v19[2](v19);
    os_unfair_lock_unlock((os_unfair_lock_t)self + 2);

    if (*(void *)(*(void *)&buf[8] + 40LL))
    {
      BOOL v20 = dispatch_data_create(a3, v11, 0LL, 0LL);
      v67[0] = v18;
      v67[1] = 3221225472LL;
      v67[2] = __78__NWConcrete_nw_listener_handleInboundPacket_length_from_to_interface_socket___block_invoke_42;
      v67[3] = &unk_189BB89C0;
      BOOL v73 = buf;
      os_log_type_t v68 = v14;
      v69 = v15;
      os_log_type_t v70 = v16;
      BOOL v71 = v17;
      int v21 = v20;
      os_log_type_t v72 = v21;
      id v22 = (void (**)(void))_Block_copy(v67);
      BOOL v23 = (void *)*((void *)v76 + 5);
      if (v23)
      {
        os_log_type_t v24 = *((_DWORD *)self + 18);
        os_log_type_t v25 = v23;
        os_log_type_t v26 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v24, 0, v22);
        dispatch_async(v25, v26);
      }

      else if (nw_context_is_inline(*((void **)self + 3)))
      {
        v22[2](v22);
      }
    }

    else
    {
      uint64_t v31 = *((void *)self + 2);
      if (!v31 || nw_path_parameters_get_logging_disabled(*(void *)(v31 + 104))) {
        goto LABEL_29;
      }
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      int v21 = (dispatch_data_s *)(id)glistenerLogObj;
      if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_DEBUG))
      {
        BOOL v32 = self;

        *(_DWORD *)os_log_type_t v81 = 136446466;
        v82 = "-[NWConcrete_nw_listener handleInboundPacket:length:from:to:interface:socket:]";
        os_log_type_t v83 = 2082;
        os_log_type_t v84 = (char *)v32 + 42;
        _os_log_impl( &dword_181A5C000,  (os_log_t)v21,  OS_LOG_TYPE_DEBUG,  "%{public}s [%{public}s] ignoring inbound packet: no new packet handler",  v81,  0x16u);
      }
    }

LABEL_29:
    _Block_object_dispose(type, 8);

    _Block_object_dispose(buf, 8);
    goto LABEL_30;
  }

  os_log_type_t v27 = *((void *)self + 2);
  if (v27 && !nw_path_parameters_get_logging_disabled(*(void *)(v27 + 104)))
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    BOOL v28 = (os_log_s *)(id)glistenerLogObj;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v29 = self;
      uint64_t v30 = (char *)v29 + 42;

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_listener handleInboundPacket:length:from:to:interface:socket:]";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v30;
      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s [%{public}s] ignoring inbound packet: not ready or no client queue",  buf,  0x16u);
    }
  }

        free(backtrace_string);
        goto LABEL_61;
      }

      if (!v49) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_client_bottom_connect";
      os_log_type_t v15 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      __int16 v43 = (os_log_s *)__nwlog_obj();
      os_log_type_t v44 = type;
      if (!os_log_type_enabled(v43, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_client_bottom_connect";
      os_log_type_t v15 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }
}

  return 1LL;
}

                          nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a1);
                          return;
                        }
                      }
                    }

                    else
                    {
                      handle[276] = v34 & 0xF0 | (4 * ((v35 & 2) != 0)) | 3;
                      if ((v34 & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        BOOL v36 = (os_log_s *)gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                        {
                          os_log_type_t v37 = *((void *)handle + 11);
                          if (v37) {
                            v38 = *(_DWORD *)(v37 + 460);
                          }
                          else {
                            v38 = -1;
                          }
                          os_log_type_t v55 = *((void *)handle + 8);
                          __int16 v56 = handle[276];
                          *(_DWORD *)buf = 136448002;
                          os_log_type_t v92 = "nw_webtransport_stream_configure_metadata_with_stream_id";
                          v93 = 2082;
                          p_identifier = (char *)(handle + 192);
                          os_log_type_t v95 = 2080;
                          BOOL v96 = " ";
                          os_log_type_t v97 = 1024;
                          BOOL v98 = v38;
                          os_log_type_t v99 = 2048;
                          os_log_type_t v100 = v55;
                          v101 = 1024;
                          *(_DWORD *)os_log_type_t v102 = (v56 >> 1) & 1;
                          *(_WORD *)&v102[4] = 1024;
                          *(_DWORD *)&v102[6] = (v56 >> 3) & 1;
                          LOWORD(v103) = 1024;
                          *(_DWORD *)((char *)&v103 + 2) = (v56 >> 2) & 1;
                          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, data gram: %u, unidirectional: %u",  buf,  0x42u);
                        }
                      }

                      nw_webtransport_metadata_set_is_peer_initiated(*((void **)handle + 20), (handle[276] & 2) != 0);
                      nw_webtransport_metadata_set_is_datagram(*((void **)handle + 20), (handle[276] & 8) != 0);
                      nw_webtransport_metadata_set_is_unidirectional(*((void **)handle + 20), (handle[276] & 4) != 0);
                    }
                  }

                  if ((handle[276] & 0x10) == 0) {
                    goto LABEL_89;
                  }
                  goto LABEL_90;
                }

                if ((handle[276] & 0x10) != 0) {
                  return;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v39 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                  return;
                }
                uint64_t v40 = *((void *)handle + 11);
                if (v40) {
                  __int16 v41 = *(_DWORD *)(v40 + 460);
                }
                else {
                  __int16 v41 = -1;
                }
                os_log_type_t v49 = *((void *)handle + 8);
                *(_DWORD *)buf = 136447234;
                os_log_type_t v92 = "nw_protocol_webtransport_http2_stream_connected";
                v93 = 2082;
                p_identifier = (char *)(handle + 192);
                os_log_type_t v95 = 2080;
                BOOL v96 = " ";
                os_log_type_t v97 = 1024;
                BOOL v98 = v41;
                os_log_type_t v99 = 2048;
                os_log_type_t v100 = v49;
                char v50 = "%{public}s %{public}s%s<i%u:s%lld> No input handler found, ignoring connected call";
                __int16 v51 = (os_log_s *)v39;
                size_t v52 = OS_LOG_TYPE_ERROR;
LABEL_81:
                _os_log_impl(&dword_181A5C000, v51, v52, v50, buf, 0x30u);
                return;
              }

              *(void *)(v23 + 424) = handle;
            }

            else
            {
              internal = *(void *)(v23 + 184);
              if (!internal)
              {
                internal = nw_hash_table_create_internal( 0x11u,  0,  (const void *(*)(const void *, unsigned int *))nw_webtransport_stream_get_key,  (unsigned int (*)(const void *, unsigned int))nw_webtransport_stream_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_webtransport_stream_matches_key,  0LL);
                *(void *)(v23 + 184) = internal;
              }

              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              nw_hash_table_add_object(internal, (uint64_t)handle, (char *)&type);
              if (type == OS_LOG_TYPE_DEFAULT)
              {
                if ((*(_BYTE *)(v23 + 548) & 2) != 0) {
                  goto LABEL_60;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v31 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_60;
                }
                BOOL v32 = *(_DWORD *)(v23 + 460);
                BOOL v33 = *((void *)handle + 8);
                *(_DWORD *)buf = 136447234;
                os_log_type_t v92 = "nw_webtransport_session_add_stream";
                v93 = 2082;
                p_identifier = (char *)(v23 + 464);
                os_log_type_t v95 = 2080;
                BOOL v96 = " ";
                os_log_type_t v97 = 1024;
                BOOL v98 = v32;
                os_log_type_t v99 = 2048;
                os_log_type_t v100 = v33;
                os_log_type_t v26 = "%{public}s %{public}s%s<i%u> WebTransport already has stream id registered for %llu";
                os_log_type_t v27 = (os_log_s *)v31;
                BOOL v28 = OS_LOG_TYPE_ERROR;
LABEL_55:
                os_log_type_t v29 = 48;
                goto LABEL_56;
              }
            }

            if ((*(_BYTE *)(v23 + 548) & 2) != 0) {
              goto LABEL_60;
            }
            if (!gLogDatapath) {
              goto LABEL_60;
            }
            os_log_type_t v78 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_60;
            }
            BOOL v79 = *(_DWORD *)(v23 + 460);
            v80 = *((void *)handle + 8);
            *(_DWORD *)buf = 136447234;
            os_log_type_t v92 = "nw_webtransport_session_add_stream";
            v93 = 2082;
            p_identifier = (char *)(v23 + 464);
            os_log_type_t v95 = 2080;
            BOOL v96 = " ";
            os_log_type_t v97 = 1024;
            BOOL v98 = v79;
            os_log_type_t v99 = 2048;
            os_log_type_t v100 = v80;
            os_log_type_t v26 = "%{public}s %{public}s%s<i%u> Added stream %llu to WebTransport streams";
            os_log_type_t v27 = v78;
            BOOL v28 = OS_LOG_TYPE_DEBUG;
            goto LABEL_55;
          }

          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v92 = "nw_webtransport_session_add_stream";
          v69 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          os_log_type_t v89 = 0;
          os_log_type_t v88 = (char *)v69;
          if (__nwlog_fault(v69, &type, &v89))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v70 = (os_log_s *)__nwlog_obj();
              BOOL v71 = type;
              if (!os_log_type_enabled(v70, type)) {
                goto LABEL_167;
              }
              *(_DWORD *)buf = 136446210;
              os_log_type_t v92 = "nw_webtransport_session_add_stream";
              os_log_type_t v72 = "%{public}s called with null webtransport_session";
              goto LABEL_166;
            }

            if (!v89)
            {
              os_log_type_t v70 = (os_log_s *)__nwlog_obj();
              BOOL v71 = type;
              if (!os_log_type_enabled(v70, type)) {
                goto LABEL_167;
              }
              *(_DWORD *)buf = 136446210;
              os_log_type_t v92 = "nw_webtransport_session_add_stream";
              os_log_type_t v72 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
              goto LABEL_166;
            }

            v82 = (char *)__nw_create_backtrace_string();
            os_log_type_t v70 = (os_log_s *)__nwlog_obj();
            BOOL v71 = type;
            os_log_type_t v83 = os_log_type_enabled(v70, type);
            if (v82)
            {
              if (v83)
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v92 = "nw_webtransport_session_add_stream";
                v93 = 2082;
                p_identifier = v82;
                _os_log_impl( &dword_181A5C000,  v70,  v71,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v82);
              goto LABEL_167;
            }

            if (v83)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v92 = "nw_webtransport_session_add_stream";
              os_log_type_t v72 = "%{public}s called with null webtransport_session, no backtrace";
LABEL_166:
              _os_log_impl(&dword_181A5C000, v70, v71, v72, buf, 0xCu);
            }
          }

                        free(v37);
                        goto LABEL_157;
                      }

            free(v51);
            goto LABEL_100;
          }

          if (v52)
          {
            __int16 v60 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)buf = 136446978;
            os_log_type_t v68 = "on_frame_recv_callback";
            v69 = 2082;
            os_log_type_t v70 = (char *)v35;
            BOOL v71 = 2048;
            *(void *)os_log_type_t v72 = v63;
            *(_WORD *)&v72[8] = 1024;
            BOOL v73 = v60;
            __int16 v41 = "%{public}s %{public}s no error callback for protocol %p attached to stream %d, no backtrace";
            goto LABEL_99;
          }
        }

        else
        {
          v38 = (os_log_s *)__nwlog_obj();
          uint64_t v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            uint64_t v59 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)buf = 136446978;
            os_log_type_t v68 = "on_frame_recv_callback";
            v69 = 2082;
            os_log_type_t v70 = (char *)v35;
            BOOL v71 = 2048;
            *(void *)os_log_type_t v72 = v63;
            *(_WORD *)&v72[8] = 1024;
            BOOL v73 = v59;
            __int16 v41 = "%{public}s %{public}s no error callback for protocol %p attached to stream %d, backtrace limit exceeded";
            goto LABEL_99;
          }
        }

    goto LABEL_91;
  }

  oblivious_http = nw_proxy_hop_create_oblivious_http( (uint64_t)gateway_key_config,  gateway_key_config_length,  (uint64_t)relay_resource_path);
  if (!oblivious_http)
  {
    __nwlog_obj();
    os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v54 = "nw_proxy_config_create_oblivious_http";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v51 = 0;
    if (__nwlog_fault(v30, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v54 = "nw_proxy_config_create_oblivious_http";
          _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null oblivious_hop", buf, 0xCu);
        }
      }

      else if (v51)
      {
        __int16 v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        __int16 v45 = os_log_type_enabled(v31, type);
        if (v43)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v54 = "nw_proxy_config_create_oblivious_http";
            os_log_type_t v55 = 2082;
            __int16 v56 = v43;
            _os_log_impl( &dword_181A5C000,  v31,  v44,  "%{public}s called with null oblivious_hop, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v43);
          goto LABEL_97;
        }

        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v54 = "nw_proxy_config_create_oblivious_http";
          _os_log_impl(&dword_181A5C000, v31, v44, "%{public}s called with null oblivious_hop, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v50 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v54 = "nw_proxy_config_create_oblivious_http";
          _os_log_impl( &dword_181A5C000,  v31,  v50,  "%{public}s called with null oblivious_hop, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if ((*(_BYTE *)(v10 + 158) & 1) == 0)
  {
    os_log_type_t v64 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
    {
      v65 = *(void *)(v10 + 488);
      os_log_type_t v66 = *(_DWORD *)(*(void *)(v10 + 480) + 372LL);
      v67 = *(_DWORD *)(v10 + 860);
      if (v65) {
        LODWORD(v65) = *(_DWORD *)(v65 + 424);
      }
      *(_DWORD *)buf = 136447746;
      BOOL v108 = "nw_http1_connection_send_final_chunk";
      os_log_type_t v109 = 2082;
      *(void *)os_log_type_t v110 = v10 + 74;
      *(_WORD *)&v110[8] = 2080;
      *(void *)&v110[10] = " ";
      char v111 = 1024;
      os_log_type_t v112 = v66;
      v113 = 1024;
      v114 = v67;
      v115 = 1024;
      __int16 v116 = v65;
      int v117 = 1024;
      *(_DWORD *)__int16 v118 = 5;
      id v22 = "%{public}s %{public}s%s<i%u:c%u:s%u> output handler refused frame request for frames of length %u";
      BOOL v23 = v64;
      os_log_type_t v24 = 56;
      goto LABEL_34;
    }
  }

      if (v28) {
        free(v28);
      }
      return 0xFFFFFFFFLL;
    }

    if (!v38)
    {
      os_log_type_t v29 = (os_log_s *)__nwlog_obj();
      uint64_t v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v41 = "nw_http1_on_header_value_complete";
        uint64_t v31 = "%{public}s called with null parsed_fields, backtrace limit exceeded";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v29 = (os_log_s *)__nwlog_obj();
    uint64_t v30 = type;
    os_log_type_t v37 = os_log_type_enabled(v29, type);
    if (!backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v41 = "nw_http1_on_header_value_complete";
        uint64_t v31 = "%{public}s called with null parsed_fields, no backtrace";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v41 = "nw_http1_on_header_value_complete";
      id v42 = 2082;
      __int16 v43 = backtrace_string;
      uint64_t v34 = "%{public}s called with null parsed_fields, dumping backtrace:%{public}s";
      goto LABEL_71;
    }

      if (v43) {
        free(v43);
      }
      return 0LL;
    }

    if (!v63[0])
    {
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      __int16 v45 = v65[0];
      if (os_log_type_enabled(v44, (os_log_type_t)v65[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        os_log_type_t v46 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v44 = (os_log_s *)__nwlog_obj();
    __int16 v45 = v65[0];
    os_log_type_t v48 = os_log_type_enabled(v44, (os_log_type_t)v65[0]);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        os_log_type_t v46 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      os_log_type_t v49 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_74:
      _os_log_impl(&dword_181A5C000, v44, v45, v49, buf, 0x16u);
    }

        goto LABEL_111;
      }

    if (v78) {
      free(v78);
    }
    __nwlog_obj();
    BOOL v87 = (void *)objc_claimAutoreleasedReturnValue();
    buf[0] = 136446210;
    *(void *)&buf[1] = "nw_endpoint_handler_copy_parent";
    os_log_type_t v88 = (char *)_os_log_send_and_compose_impl();

    v110[0] = 16;
    LOBYTE(v105) = 0;
    if (__nwlog_fault(v88, v110, &v105))
    {
      if (v110[0] == 17)
      {
        os_log_type_t v89 = v88;
        __nwlog_obj();
        os_log_type_t v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v91 = v110[0];
        if (os_log_type_enabled(v90, (os_log_type_t)v110[0]))
        {
          buf[0] = 136446210;
          *(void *)&buf[1] = "nw_endpoint_handler_copy_parent";
          _os_log_impl(&dword_181A5C000, v90, v91, "%{public}s called with null handler", (uint8_t *)buf, 0xCu);
        }

    goto LABEL_91;
  }

  v82 = nw_endpoint_handler_copy_flow(v4);
  uint64_t v6 = *((void *)v82 + 51);
  if (!v6)
  {
LABEL_47:
    os_log_type_t v91 = 0LL;
    goto LABEL_48;
  }

  id_str = v4->id_str;
  lock = &v4->lock;
  id v7 = &qword_18C45F000;
  while (1)
  {
    uint64_t v8 = *(void *)(v6 + 16);
    os_log_type_t v91 = v6;
    if (*(_DWORD *)(v8 + 36) == 2)
    {
      if (*(void *)(*(void *)(v6 + 24) + 232LL)) {
        break;
      }
    }

    os_log_type_t v25 = v4;
    os_log_type_t v26 = (*((_BYTE *)v4 + 268) & 0x20) == 0;

    if (v26)
    {
      if (v7[79] != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v12 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v27 = v25;

        BOOL v28 = v27;
        os_log_type_t v29 = (*((_BYTE *)v4 + 268) & 1) == 0;

        if (v29) {
          uint64_t v30 = "";
        }
        else {
          uint64_t v30 = "dry-run ";
        }
        uint64_t v31 = nw_endpoint_handler_copy_endpoint(v28);
        logging_description = nw_endpoint_get_logging_description(v31);
        BOOL v32 = v28;
        BOOL v33 = v32;
        state = v4->state;
        char v35 = "unknown-state";

        BOOL v36 = v33;
        os_log_type_t v37 = "path";
        switch(v4->mode)
        {
          case 0:
            break;
          case 1:
            os_log_type_t v37 = "resolver";
            break;
          case 2:
            os_log_type_t v37 = nw_endpoint_flow_mode_string(v4->mode_handler);
            break;
          case 3:
            os_log_type_t v37 = "proxy";
            break;
          case 4:
            os_log_type_t v37 = "fallback";
            break;
          case 5:
            os_log_type_t v37 = "transform";
            break;
          default:
            os_log_type_t v37 = "unknown-mode";
            break;
        }

        v38 = v12;
        uint64_t v39 = v36;
        os_unfair_lock_lock(lock);
        uint64_t v40 = v4->current_path;
        __int16 v41 = v31;
        id v7 = &qword_18C45F000;
        os_unfair_lock_unlock(lock);

        id v12 = v38;
        *(_DWORD *)buf = 136448002;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        BOOL v96 = 2082;
        os_log_type_t v97 = v4->id_str;
        BOOL v98 = 2082;
        os_log_type_t v99 = v30;
        os_log_type_t v100 = 2082;
        v101 = (void *)logging_description;
        os_log_type_t v102 = 2082;
        os_log_type_t v103 = v35;
        BOOL v104 = 2082;
        os_log_type_t v105 = v37;
        os_log_type_t v106 = 2114;
        os_log_type_t v107 = v40;
        BOOL v108 = 2082;
        os_log_type_t v109 = v8;
        _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No listener protocol for %{public}s",  buf,  0x52u);
      }

      goto LABEL_42;
    }

      if (v42) {
        free(v42);
      }
      goto LABEL_92;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v106 = "http2_create_output_frame";
    os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v103 = 0;
    if (__nwlog_fault(v68, &type, &v103))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v69 = (os_log_s *)__nwlog_obj();
        os_log_type_t v70 = type;
        if (!os_log_type_enabled(v69, type)) {
          goto LABEL_184;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v106 = "http2_create_output_frame";
        BOOL v71 = "%{public}s called with null frame";
LABEL_183:
        _os_log_impl(&dword_181A5C000, v69, v70, v71, buf, 0xCu);
        goto LABEL_184;
      }

      if (!v103)
      {
        v69 = (os_log_s *)__nwlog_obj();
        os_log_type_t v70 = type;
        if (!os_log_type_enabled(v69, type)) {
          goto LABEL_184;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v106 = "http2_create_output_frame";
        BOOL v71 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_183;
      }

      v82 = (char *)__nw_create_backtrace_string();
      v69 = (os_log_s *)__nwlog_obj();
      os_log_type_t v70 = type;
      os_log_type_t v83 = os_log_type_enabled(v69, type);
      if (!v82)
      {
        if (!v83) {
          goto LABEL_184;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v106 = "http2_create_output_frame";
        BOOL v71 = "%{public}s called with null frame, no backtrace";
        goto LABEL_183;
      }

      if (v83)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v106 = "http2_create_output_frame";
        os_log_type_t v107 = 2082;
        BOOL v108 = v82;
        _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v82);
    }

  if (v20) {
    free(v20);
  }
LABEL_14:
  if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v10 = a1[1].callbacks;
    if (v10)
    {
      char v11 = (nw_protocol_callbacks *)((char *)v10 - 1);
      a1[1].callbacks = v11;
      if (!v11)
      {
        id v12 = *(void (***)(void))a1[1].flow_id;
        if (v12)
        {
          *(void *)a1[1].flow_id = 0LL;
          v12[2](v12);
          _Block_release(v12);
        }

        if ((a1[1].flow_id[8] & 1) != 0)
        {
          uint64_t v13 = *(const void **)a1[1].flow_id;
          if (v13) {
            _Block_release(v13);
          }
        }

        free(a1);
      }
    }
  }

  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    char v14 = default_input_handler[1].callbacks;
    if (v14)
    {
      os_log_type_t v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
      default_input_handler[1].callbacks = v15;
      if (!v15)
      {
        id v16 = *(void (***)(void))default_input_handler[1].flow_id;
        if (v16)
        {
          *(void *)default_input_handler[1].flow_id = 0LL;
          v16[2](v16);
          _Block_release(v16);
        }

        if ((default_input_handler[1].flow_id[8] & 1) != 0)
        {
          uint64_t v17 = *(const void **)default_input_handler[1].flow_id;
          if (v17) {
            _Block_release(v17);
          }
        }

        os_log_type_t v18 = default_input_handler;
        goto LABEL_35;
      }
    }
  }

      if (v24) {
        free(v24);
      }
      return 0LL;
    }

    if (!v44)
    {
      os_log_type_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v47 = "__nw_protocol_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = type;
    char v35 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v47 = "__nw_protocol_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v47 = "__nw_protocol_finalize_output_frames";
      os_log_type_t v48 = 2082;
      os_log_type_t v49 = backtrace_string;
      BOOL v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_62;
    }

    if (v43) {
      free(v43);
    }
    goto LABEL_92;
  }

  BOOL v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  uint64_t v6 = v5;
  if (v4 != 2)
  {
    *(_DWORD *)os_log_type_t v68 = 136446466;
    v69 = "nw_interface_create_from_necp";
    os_log_type_t v70 = 1024;
    LODWORD(v71[0]) = v4;
    BOOL v36 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (__nwlog_fault(v36, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v37 = (os_log_s *)(id)gLogObj;
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)os_log_type_t v68 = 136446466;
          v69 = "nw_interface_create_from_necp";
          os_log_type_t v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d",  v68,  0x12u);
        }
      }

      else if (v65)
      {
        uint64_t v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v37 = (os_log_s *)(id)gLogObj;
        uint64_t v40 = type;
        __int16 v41 = os_log_type_enabled(v37, type);
        if (v39)
        {
          if (v41)
          {
            *(_DWORD *)os_log_type_t v68 = 136446722;
            v69 = "nw_interface_create_from_necp";
            os_log_type_t v70 = 1024;
            LODWORD(v71[0]) = v4;
            WORD2(v71[0]) = 2082;
            *(void *)((char *)v71 + 6) = v39;
            _os_log_impl( &dword_181A5C000,  v37,  v40,  "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, dumping backtrace:%{public}s",  v68,  0x1Cu);
          }

          free(v39);
          if (!v36) {
            return 0LL;
          }
          goto LABEL_70;
        }

        if (v41)
        {
          *(_DWORD *)os_log_type_t v68 = 136446466;
          v69 = "nw_interface_create_from_necp";
          os_log_type_t v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl( &dword_181A5C000,  v37,  v40,  "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, no backtrace",  v68,  0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v37 = (os_log_s *)(id)gLogObj;
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)os_log_type_t v68 = 136446466;
          v69 = "nw_interface_create_from_necp";
          os_log_type_t v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl( &dword_181A5C000,  v37,  v46,  "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, backtrace limit exceeded",  v68,  0x12u);
        }
      }
    }

void sub_181ADEA64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_dictionary_set_value(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_dictionary_set_value";
    id v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_dictionary_set_value";
      os_log_type_t v10 = "%{public}s called with null dictionary";
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_dictionary_set_value";
          __int16 v19 = 2082;
          BOOL v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null dictionary, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v7) {
          return;
        }
        goto LABEL_37;
      }

      if (!v12) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_dictionary_set_value";
      os_log_type_t v10 = "%{public}s called with null dictionary, no backtrace";
    }

    else
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_dictionary_set_value";
      os_log_type_t v10 = "%{public}s called with null dictionary, backtrace limit exceeded";
    }

id nw_association_copy_current_path(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_association_copy_current_path";
    char v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null association", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (!v24)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_association_copy_current_path";
        _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null association, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v27 = "nw_association_copy_current_path";
      __int16 v28 = 2082;
      os_log_type_t v29 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null association, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_24;
  }

  id v5 = nw_path_parameters_copy_context(v3[2]);
  nw_context_assert_queue(v5);

  nw_association_activate(v3, v4, 0, 1);
  if ((*((_BYTE *)v3 + 76) & 1) != 0)
  {
    __nwlog_obj();
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_association_copy_current_path";
    char v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null !association->dormant", buf, 0xCu);
      }

void sub_181ADF3F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_path_change(NWConcrete_nw_endpoint_handler *a1)
{
  buf[11] = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  v424 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v291 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
    v292 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v436[0]) = 16;
    LOBYTE(v432) = 0;
    if (LOBYTE(v436[0]) == 17)
    {
      __nwlog_obj();
      v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v294 = v436[0];
      if (os_log_type_enabled(v293, v436[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        _os_log_impl(&dword_181A5C000, v293, v294, "%{public}s called with null handler", (uint8_t *)buf, 0xCu);
      }
    }

    else if ((_BYTE)v432)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v313 = v436[0];
      BOOL v314 = os_log_type_enabled(v293, v436[0]);
      if (backtrace_string)
      {
        if (v314)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v293,  v313,  "%{public}s called with null handler, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
        }

        free(backtrace_string);
LABEL_455:
        if (!v292) {
          goto LABEL_242;
        }
LABEL_456:
        free(v292);
        goto LABEL_242;
      }

      if (v314)
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        _os_log_impl( &dword_181A5C000,  v293,  v313,  "%{public}s called with null handler, no backtrace",  (uint8_t *)buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v329 = v436[0];
      if (os_log_type_enabled(v293, v436[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        _os_log_impl( &dword_181A5C000,  v293,  v329,  "%{public}s called with null handler, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
      }
    }

LABEL_454:
    goto LABEL_455;
  }

  uint64_t v2 = (uint64_t)v1;
  current_path = v1->current_path;
  if (!current_path)
  {
    __nwlog_obj();
    v295 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
    v292 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v436[0]) = 16;
    LOBYTE(v432) = 0;
    if (LOBYTE(v436[0]) == 17)
    {
      __nwlog_obj();
      v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v296 = v436[0];
      if (os_log_type_enabled(v293, v436[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        _os_log_impl( &dword_181A5C000,  v293,  v296,  "%{public}s called with null handler->current_path",  (uint8_t *)buf,  0xCu);
      }
    }

    else if ((_BYTE)v432)
    {
      v315 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v316 = v436[0];
      BOOL v317 = os_log_type_enabled(v293, v436[0]);
      if (v315)
      {
        if (v317)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v315;
          _os_log_impl( &dword_181A5C000,  v293,  v316,  "%{public}s called with null handler->current_path, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
        }

        free(v315);
        if (!v292) {
          goto LABEL_242;
        }
        goto LABEL_456;
      }

      if (v317)
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        _os_log_impl( &dword_181A5C000,  v293,  v316,  "%{public}s called with null handler->current_path, no backtrace",  (uint8_t *)buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v330 = v436[0];
      if (os_log_type_enabled(v293, v436[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        _os_log_impl( &dword_181A5C000,  v293,  v330,  "%{public}s called with null handler->current_path, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
      }
    }

    goto LABEL_454;
  }

  id v4 = current_path;
  int v5 = *((_DWORD *)v4 + 94);

  char v6 = *(_BYTE *)(v2 + 268);
  if ((v6 & 0x20) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v7 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      if ((*((_BYTE *)v424 + 268) & 1) != 0) {
        uint64_t v8 = "dry-run ";
      }
      else {
        uint64_t v8 = "";
      }
      nw_endpoint_t v9 = nw_endpoint_handler_copy_endpoint(v424);
      logging_description = nw_endpoint_get_logging_description(v9);
      int v422 = v5;
      uint64_t state = v424->state;
      else {
        BOOL v12 = off_189BBBBF0[state];
      }
      os_log_type_t v13 = v424;
      BOOL v14 = (os_unfair_lock_s *)v13;
      os_log_type_t v15 = "path";
      switch(v13->mode)
      {
        case 0:
          break;
        case 1:
          os_log_type_t v15 = "resolver";
          break;
        case 2:
          os_log_type_t v15 = nw_endpoint_flow_mode_string(v13->mode_handler);
          break;
        case 3:
          os_log_type_t v15 = "proxy";
          break;
        case 4:
          os_log_type_t v15 = "fallback";
          break;
        case 5:
          os_log_type_t v15 = "transform";
          break;
        default:
          os_log_type_t v15 = "unknown-mode";
          break;
      }

      id v16 = v14 + 28;
      os_log_type_t v17 = v14;
      os_unfair_lock_lock(v14 + 28);
      BOOL v18 = v424->current_path;
      os_unfair_lock_unlock(v16);

      LODWORD(buf[0]) = 136447746;
      *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v424->id_str;
      HIWORD(buf[2]) = 2082;
      buf[3] = v8;
      LOWORD(buf[4]) = 2082;
      *(void *)((char *)&buf[4] + 2) = logging_description;
      WORD1(buf[5]) = 2082;
      *(void *)((char *)&buf[5] + 4) = v12;
      WORD2(buf[6]) = 2082;
      *(void *)((char *)&buf[6] + 6) = v15;
      HIWORD(buf[7]) = 2114;
      buf[8] = v18;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  (uint8_t *)buf,  0x48u);

      int v5 = v422;
    }

    uint64_t v2 = (uint64_t)v424;
    char v6 = *((_BYTE *)v424 + 268);
  }

  int v19 = *(_DWORD *)(v2 + 120);
  if (v19 != 2)
  {
    v6 &= ~8u;
    *(_BYTE *)(v2 + 268) = v6;
    if ((v19 & 0xFFFFFFFE) == 4) {
      goto LABEL_442;
    }
  }

  if ((v6 & 2) == 0)
  {
    if (v5 != 3)
    {
      *(_BYTE *)(v2 + 268) = v6 & 0xFD;
      BOOL v20 = *(void **)(v2 + 88);
      *(void *)(v2 + 88) = 0LL;
      os_log_type_t v21 = (id)v2;

      os_log_type_t v22 = (void *)v21[12];
      v21[12] = 0LL;

      BOOL v23 = (void *)v21[13];
      v21[13] = 0LL;

      uint64_t v2 = (uint64_t)v424;
    }

    if ((*(_BYTE *)(v11 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        id v16 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v245 = *(void *)(v11 + 488);
          int v246 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
          char v247 = *(_DWORD *)(v11 + 860);
          if (v245) {
            LODWORD(v245) = *(_DWORD *)(v245 + 424);
          }
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v11 + 74;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v246;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v247;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v245;
          BOOL v20 = "%{public}s %{public}s%s<i%u:c%u:s%u> already closed";
          goto LABEL_270;
        }
      }
    }

    return;
  }

  if (((*v14 | (*(unsigned __int8 *)(v11 + 874) << 16)) & 0x20000) != 0 || (*v14 & 0x14) != 0 && *(void *)(v11 + 616))
  {
    if ((*(_BYTE *)(v11 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        id v16 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v17 = *(void *)(v11 + 488);
          BOOL v18 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
          int v19 = *(_DWORD *)(v11 + 860);
          if (v17) {
            LODWORD(v17) = *(_DWORD *)(v17 + 424);
          }
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http1_detect_next_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v11 + 74;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v18;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v19;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v17;
          BOOL v20 = "%{public}s %{public}s%s<i%u:c%u:s%u> not attempting to read more on connection awaiting a new flow, awai"
                "ting disconnect or remove_input_handler";
LABEL_270:
          int v28 = v16;
          char v29 = 50;
          goto LABEL_60;
        }
      }
    }

    return;
  }

  *(void *)v394 = 0LL;
  v395 = v394;
  if (nw_protocol_get_input_frames(*(void *)(v11 + 32), v11, 1LL, 0xFFFFFFFFLL, 1LL, (uint64_t)v394))
  {
    if (!(*(_BYTE *)(v11 + 158) & 1 | (gLogDatapath == 0)))
    {
      v264 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v264, OS_LOG_TYPE_DEBUG))
      {
        v265 = *(void *)(v11 + 488);
        nw_endpoint_t v266 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
        v267 = *(_DWORD *)(v11 + 860);
        if (v265) {
          LODWORD(v265) = *(_DWORD *)(v265 + 424);
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_http1_detect_next_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v11 + 74;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v266;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v267;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v265;
        _os_log_impl( &dword_181A5C000,  v264,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> received a frame for non-idle connection, deferring new flow",  buf,  0x32u);
      }
    }

    __int16 v51 = *(_DWORD **)v394;
    if (!*(void *)v394)
    {
      if ((*(_BYTE *)(v11 + 158) & 1) != 0) {
        goto LABEL_318;
      }
      if (!gLogDatapath) {
        goto LABEL_318;
      }
      id v93 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v93, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_318;
      }
      os_log_type_t v94 = *(void *)(v11 + 488);
      os_log_type_t v95 = *(_DWORD *)(*(void *)(v11 + 480) + 372LL);
      BOOL v96 = *(_DWORD *)(v11 + 860);
      if (v94) {
        LODWORD(v94) = *(_DWORD *)(v94 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_move_frame_array_to_unprocessed_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v11 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v95;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v96;
      *(_WORD *)&buf[44] = 1024;
      *(_DWORD *)&buf[46] = v94;
      BOOL v97 = "%{public}s %{public}s%s<i%u:c%u:s%u> no additional body frames to move";
      BOOL v98 = v93;
      os_log_type_t v99 = 50;
      goto LABEL_537;
    }

    id v393 = v11 + 616;
    if (gLogDatapath)
    {
      v284 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v284, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&void buf[14] = v51;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&buf[24] = v394;
        *(_WORD *)&buf[32] = 2048;
        *(void *)&buf[34] = v11 + 616;
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 1;
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1;
        *(_WORD *)&buf[54] = 1024;
        *(_DWORD *)&buf[56] = 1;
        _os_log_impl( &dword_181A5C000,  v284,  OS_LOG_TYPE_DEBUG,  "%{public}s called: initial frame %p, source %p, destination %p, temp %u, forwards %u, append %u",  buf,  0x3Cu);
      }
    }

    size_t v52 = 0;
    *(void *)v398 = 0LL;
    *(void *)&v398[8] = v398;
    *(void *)&id v50 = 136447234LL;
    do
    {
      uint64_t v55 = (_DWORD *)*((void *)v51 + 4);
      if (!v55 && !*((void *)v51 + 5)) {
        uint64_t v55 = 0LL;
      }
      if (gLogDatapath)
      {
        v388 = v50;
        loga = (os_log_s *)__nwlog_obj();
        os_log_type_t v57 = os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG);
        id v50 = v388;
        if (v57)
        {
          __int16 v58 = v51[13];
          if (v58) {
            v58 -= v51[14] + v51[15];
          }
          if (v55)
          {
            uint64_t v59 = v55[13];
            if (v59) {
              v59 -= v55[14] + v55[15];
            }
          }

          else
          {
            uint64_t v59 = 0;
          }

          *(_DWORD *)buf = v388;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&void buf[14] = v51;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = v58;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v55;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v59;
          _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEBUG,  "%{public}s current frame: (%p, %u bytes), next frame: (%p, %u bytes)",  buf,  0x2Cu);
          id v50 = v388;
        }
      }

      __int16 v56 = *((void *)v51 + 4);
      nw_endpoint_t v53 = (void *)*((void *)v51 + 5);
      if (v56)
      {
        *(void *)(v56 + 40) = v53;
        nw_endpoint_t v53 = (void *)*((void *)v51 + 5);
      }

      else
      {
        v395 = (os_log_type_t *)*((void *)v51 + 5);
      }

      *nw_endpoint_t v53 = v56;
      __int16 v54 = *(void **)&v398[8];
      *((void *)v51 + 4) = 0LL;
      *((void *)v51 + 5) = v54;
      const char *v54 = v51;
      *(void *)&v398[8] = v51 + 8;
      ++v52;
      __int16 v51 = v55;
    }

    while (v55);
    if (!v52) {
      goto LABEL_317;
    }
    if (gLogDatapath)
    {
      v392 = v50;
      os_log_type_t v298 = (os_log_s *)__nwlog_obj();
      BOOL v299 = os_log_type_enabled(v298, OS_LOG_TYPE_DEBUG);
      id v50 = v392;
      if (v299)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v52;
        _os_log_impl( &dword_181A5C000,  v298,  OS_LOG_TYPE_DEBUG,  "%{public}s moving %u frames from temp array to destination array",  buf,  0x12u);
        id v50 = v392;
      }
    }

    BOOL v73 = *(_DWORD **)v398;
    int v74 = v52;
    if (*(void *)v398)
    {
      int v74 = v52;
      do
      {
        BOOL v77 = v73 + 8;
        int v76 = (_DWORD *)*((void *)v73 + 4);
        if (!v76 && !*((void *)v73 + 5)) {
          int v76 = 0LL;
        }
        if (gLogDatapath)
        {
          v390 = v50;
          logc = (os_log_s *)__nwlog_obj();
          BOOL v80 = os_log_type_enabled(logc, OS_LOG_TYPE_DEBUG);
          id v50 = v390;
          if (v80)
          {
            os_log_type_t v81 = v73[13];
            if (v81) {
              v81 -= v73[14] + v73[15];
            }
            if (v76)
            {
              int v82 = v76[13];
              if (v82) {
                v82 -= v76[14] + v76[15];
              }
            }

            else
            {
              int v82 = 0;
            }

            *(_DWORD *)buf = v390;
            *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&void buf[14] = v73;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = v81;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v76;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v82;
            _os_log_impl( &dword_181A5C000,  logc,  OS_LOG_TYPE_DEBUG,  "%{public}s current frame: (%p, %u bytes), next frame: (%p, %u bytes)",  buf,  0x2Cu);
            id v50 = v390;
          }
        }

        os_log_type_t v78 = *((void *)v73 + 4);
        int v79 = (void *)*((void *)v73 + 5);
        if (v78)
        {
          *(void *)(v78 + 40) = v79;
          int v79 = (void *)*((void *)v73 + 5);
        }

        else
        {
          *(void *)&v398[8] = *((void *)v73 + 5);
        }

        *int v79 = v78;
        *BOOL v77 = 0LL;
        *((void *)v73 + 5) = 0LL;
        BOOL v75 = *(void **)(v11 + 624);
        *((void *)v73 + 5) = v75;
        *BOOL v75 = v73;
        *(void *)(v11 + 624) = v77;
        --v74;
        BOOL v73 = v76;
      }

      while (v76);
      if (!v74)
      {
LABEL_317:
        if (!gLogDatapath) {
          goto LABEL_318;
        }
        id v285 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v285, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_318;
        }
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v52;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v394;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v393;
        BOOL v97 = "%{public}s moved %u frames from %p to %p";
        BOOL v98 = v285;
        os_log_type_t v99 = 38;
LABEL_537:
        _os_log_impl(&dword_181A5C000, v98, OS_LOG_TYPE_DEBUG, v97, buf, v99);
LABEL_318:
        *((_BYTE *)v14 + 2) = (*v14 | (*((unsigned __int8 *)v14 + 2) << 16) | 0x20000u) >> 16;
        return;
      }
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&void buf[14] = v74;
    BOOL v104 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    nw_endpoint_t v396 = 0;
    if (__nwlog_fault(v104, &type, &v396))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v105 = (os_log_s *)__nwlog_obj();
        uint64_t v106 = type;
        if (!os_log_type_enabled(v105, type)) {
          goto LABEL_315;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v74;
        unint64_t v107 = "%{public}s failed to deliver all temp frames, remaining %u frames";
        goto LABEL_314;
      }

      if (!v396)
      {
        id v105 = (os_log_s *)__nwlog_obj();
        uint64_t v106 = type;
        if (!os_log_type_enabled(v105, type)) {
          goto LABEL_315;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v74;
        unint64_t v107 = "%{public}s failed to deliver all temp frames, remaining %u frames, backtrace limit exceeded";
        goto LABEL_314;
      }

      os_log_type_t v110 = (char *)__nw_create_backtrace_string();
      id v105 = (os_log_s *)__nwlog_obj();
      uint64_t v106 = type;
      BOOL v111 = os_log_type_enabled(v105, type);
      if (v110)
      {
        if (v111)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v74;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v110;
          _os_log_impl( &dword_181A5C000,  v105,  v106,  "%{public}s failed to deliver all temp frames, remaining %u frames, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v110);
        goto LABEL_315;
      }

      if (v111)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v74;
        unint64_t v107 = "%{public}s failed to deliver all temp frames, remaining %u frames, no backtrace";
LABEL_314:
        _os_log_impl(&dword_181A5C000, v105, v106, v107, buf, 0x12u);
      }
    }

LABEL_252:
                uint64_t v2 = (uint64_t)v424;
                goto LABEL_253;
              }

              goto LABEL_253;
            }
          }

          else
          {
          }

          uint64_t v2 = (uint64_t)v424;
          if ((*((_BYTE *)v424 + 268) & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v63 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
            {
              if ((*((_BYTE *)v424 + 268) & 1) != 0) {
                v136 = "dry-run ";
              }
              else {
                v136 = "";
              }
              nw_endpoint_t v137 = nw_endpoint_handler_copy_endpoint(v59);
              v138 = nw_endpoint_get_logging_description(v137);
              uint64_t v139 = v424->state;
              else {
                v140 = off_189BBBBF0[v139];
              }
              v156 = v59;
              v157 = (os_unfair_lock_s *)v156;
              v158 = "path";
              switch(v424->mode)
              {
                case 0:
                  break;
                case 1:
                  v158 = "resolver";
                  break;
                case 2:
                  v158 = nw_endpoint_flow_mode_string(*((void **)v156 + 31));
                  break;
                case 3:
                  v158 = "proxy";
                  break;
                case 4:
                  v158 = "fallback";
                  break;
                case 5:
                  v158 = "transform";
                  break;
                default:
                  v158 = "unknown-mode";
                  break;
              }

              v195 = v157 + 28;
              v196 = v157;
              os_unfair_lock_lock(v157 + 28);
              v197 = v424->current_path;
              os_unfair_lock_unlock(v195);

              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v59 + 168;
              HIWORD(buf[2]) = 2082;
              buf[3] = v136;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v138;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v140;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v158;
              HIWORD(buf[7]) = 2114;
              buf[8] = v197;
              _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] agents failed to become active",  (uint8_t *)buf,  0x48u);
            }

            goto LABEL_252;
          }

            if (!v147) {
              goto LABEL_130;
            }
LABEL_253:
            free(v147);
            goto LABEL_130;
          }

          __nwlog_obj();
          v148 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v173 = v196;
          if (os_log_type_enabled(v148, v196))
          {
            nw_endpoint_t v174 = output_handler->identifier->name;
            if (!v174) {
              nw_endpoint_t v174 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            id v202 = "__nw_protocol_updated_path";
            v203 = 2082;
            v204 = (char *)v174;
            v205 = 2048;
            v206 = (const char *)output_handler;
            _os_log_impl( &dword_181A5C000,  v148,  v173,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

      else
      {
        __nwlog_obj();
        v158 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        id v202 = "__nw_protocol_updated_path";
        v147 = (char *)_os_log_send_and_compose_impl();

        v196 = OS_LOG_TYPE_ERROR;
        v195 = 0;
        if (v196 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v148 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v159 = v196;
          if (os_log_type_enabled(v148, v196))
          {
            *(_DWORD *)buf = 136446210;
            id v202 = "__nw_protocol_updated_path";
            _os_log_impl(&dword_181A5C000, v148, v159, "%{public}s called with null path", buf, 0xCu);
          }
        }

        else if (v195)
        {
          v170 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v148 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v171 = v196;
          BOOL v172 = os_log_type_enabled(v148, v196);
          if (v170)
          {
            if (v172)
            {
              *(_DWORD *)buf = 136446466;
              id v202 = "__nw_protocol_updated_path";
              v203 = 2082;
              v204 = v170;
              _os_log_impl( &dword_181A5C000,  v148,  v171,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v170);
            if (!v147) {
              goto LABEL_130;
            }
            goto LABEL_253;
          }

          if (v172)
          {
            *(_DWORD *)buf = 136446210;
            id v202 = "__nw_protocol_updated_path";
            _os_log_impl(&dword_181A5C000, v148, v171, "%{public}s called with null path, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v148 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v176 = v196;
          if (os_log_type_enabled(v148, v196))
          {
            *(_DWORD *)buf = 136446210;
            id v202 = "__nw_protocol_updated_path";
            _os_log_impl( &dword_181A5C000,  v148,  v176,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      goto LABEL_252;
    }

    if (*v23)
    {
      os_log_type_t v90 = *v23;
      os_log_type_t v91 = v90[94];

      if (v91 == 1)
      {
        v77->event = (nw_endpoint_handler_event_s)393219;
        nw_endpoint_handler_report(v77, 0LL, &v77->event.domain, 0LL);
LABEL_173:

        char v11 = v186;
        goto LABEL_174;
      }
    }

    if (nw_endpoint_handler_get_minimize_logging(v77))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v94 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
      {
        v138 = nw_endpoint_handler_get_id_string(v77);
        uint64_t v139 = nw_endpoint_handler_dry_run_string(v77);
        v140 = nw_endpoint_handler_copy_endpoint(v77);
        int v141 = nw_endpoint_get_logging_description(v140);
        char v142 = nw_endpoint_handler_state_string(v77);
        v143 = nw_endpoint_handler_mode_string(v77);
        v144 = nw_endpoint_handler_copy_current_path(v77);
        *(_DWORD *)buf = 136447746;
        id v202 = "-[NWConcrete_nw_endpoint_flow updatePathWithHandler:]";
        v203 = 2082;
        v204 = (char *)v138;
        v205 = 2082;
        v206 = v139;
        uint64_t v207 = 2082;
        v208 = (void *)v141;
        v209 = 2082;
        int v210 = v142;
        int v211 = 2082;
        char v212 = v143;
        v213 = 2114;
        v214 = v144;
        _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] path no longer satisfied, resetting",  buf,  0x48u);
      }
    }

    else
    {
      id v92 = v77;
      id v93 = (*((_BYTE *)v56 + 268) & 0x20) == 0;

      if (!v93)
      {
LABEL_155:
        nw_endpoint_flow_failed_with_error(v77, 1, 0LL);
        goto LABEL_173;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v94 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v94, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v95 = v92;

        BOOL v96 = v95;
        BOOL v97 = (*((_BYTE *)v56 + 268) & 1) == 0;

        if (v97) {
          BOOL v98 = "";
        }
        else {
          BOOL v98 = "dry-run ";
        }
        os_log_type_t v99 = nw_endpoint_handler_copy_endpoint(v96);
        os_log_type_t v100 = nw_endpoint_get_logging_description(v99);
        nw_endpoint_t v101 = v96;
        os_log_type_t v102 = v101;
        os_log_type_t v103 = v101[30];
        else {
          BOOL v104 = off_189BBBBF0[v103];
        }

        id v105 = v102;
        uint64_t v106 = "path";
        switch(v187->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v106 = "resolver";
            break;
          case 2:
            uint64_t v106 = nw_endpoint_flow_mode_string(v105[31]);
            break;
          case 3:
            uint64_t v106 = "proxy";
            break;
          case 4:
            uint64_t v106 = "fallback";
            break;
          case 5:
            uint64_t v106 = "transform";
            break;
          default:
            uint64_t v106 = "unknown-mode";
            break;
        }

        nw_endpoint_t v184 = v106;

        nw_endpoint_t v119 = v105;
        os_unfair_lock_lock((os_unfair_lock_t)v119 + 28);
        __int16 v120 = v119[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v119 + 28);

        *(_DWORD *)buf = 136447746;
        id v202 = "-[NWConcrete_nw_endpoint_flow updatePathWithHandler:]";
        v203 = 2082;
        v204 = v95->id_str;
        v205 = 2082;
        v206 = v98;
        uint64_t v207 = 2082;
        v208 = (void *)v100;
        v209 = 2082;
        int v210 = v104;
        int v211 = 2082;
        char v212 = v184;
        v213 = 2114;
        v214 = v120;
        _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] path no longer satisfied, resetting",  buf,  0x48u);
      }
    }

    goto LABEL_155;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v10 = (id)gLogObj;
  char v11 = v5;
  else {
    BOOL v12 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  id v202 = "-[NWConcrete_nw_endpoint_flow updatePathWithHandler:]";
  v203 = 2082;
  v204 = (char *)v12;
  v205 = 2082;
  v206 = "flow";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(p_shared_protocol) = 0;
  if (__nwlog_fault(v13, type, &p_shared_protocol))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        else {
          id v16 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        id v202 = "-[NWConcrete_nw_endpoint_flow updatePathWithHandler:]";
        v203 = 2082;
        v204 = (char *)v16;
        v205 = 2082;
        v206 = "flow";
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    else if ((_BYTE)p_shared_protocol)
    {
      os_log_type_t v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (os_log_s *)(id)gLogObj;
      BOOL v18 = type[0];
      int v19 = os_log_type_enabled(v14, type[0]);
      if (v17)
      {
        if (v19)
        {
          else {
            BOOL v20 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446978;
          id v202 = "-[NWConcrete_nw_endpoint_flow updatePathWithHandler:]";
          v203 = 2082;
          v204 = (char *)v20;
          v205 = 2082;
          v206 = "flow";
          uint64_t v207 = 2082;
          v208 = v17;
          _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v17);
        if (v13) {
          goto LABEL_141;
        }
        goto LABEL_174;
      }

      if (v19)
      {
        else {
          int v74 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        id v202 = "-[NWConcrete_nw_endpoint_flow updatePathWithHandler:]";
        v203 = 2082;
        v204 = (char *)v74;
        v205 = 2082;
        v206 = "flow";
        _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (os_log_s *)(id)gLogObj;
      int v72 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        else {
          BOOL v73 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        id v202 = "-[NWConcrete_nw_endpoint_flow updatePathWithHandler:]";
        v203 = 2082;
        v204 = (char *)v73;
        v205 = 2082;
        v206 = "flow";
        _os_log_impl( &dword_181A5C000,  v14,  v72,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v13) {
LABEL_141:
  }
    free(v13);
LABEL_174:
}

      if (!v89) {
        return 0LL;
      }
      os_log_type_t v68 = (char *)v89;
      goto LABEL_107;
    }

    if (!v147)
    {
      os_log_type_t v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        id v92 = "%{public}s called with null reassembly_count, backtrace limit exceeded";
        goto LABEL_251;
      }

      goto LABEL_252;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v90 = (os_log_s *)__nwlog_obj();
    os_log_type_t v91 = type[0];
    __int16 v116 = os_log_type_enabled(v90, type[0]);
    if (!backtrace_string)
    {
      if (v116)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        id v92 = "%{public}s called with null reassembly_count, no backtrace";
        goto LABEL_251;
      }

      goto LABEL_252;
    }

    if (v116)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = backtrace_string;
      v113 = "%{public}s called with null reassembly_count, dumping backtrace:%{public}s";
      goto LABEL_214;
    }

  if (v99) {
    free(v99);
  }
  return 0LL;
}

    if (v96) {
      free(v96);
    }
  }

    if (v91) {
      free(v91);
    }
    os_log_type_t v25 = 0;
    os_log_type_t v26 = 0;
LABEL_44:
    nw_frame_unclaim(a2, v19, v25, v26);
    os_log_type_t v27 = nw_frame_unclaimed_bytes(a2, 0LL);
    is_metadata_complete = nw_frame_is_metadata_complete(a2);
    uint64_t v30 = is_metadata_complete;
    if (*(void *)(*(void *)(a1[4] + 8LL) + 24LL))
    {
      uint64_t v31 = 0;
      if (v18)
      {
        BOOL v32 = v18;
        do
        {
          ++v31;
          os_log_type_t v22 = v32 > 0xF;
          v32 >>= 4;
        }

        while (v22);
      }

      nw_endpoint_t v33 = v31 + 2;
      if (is_metadata_complete) {
        uint64_t v34 = 7;
      }
      else {
        uint64_t v34 = 2;
      }
      v135 = v34;
      log = v33;
      goto LABEL_52;
    }

    os_log_type_t v95 = v18;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v140 = "nw_http1_connection_get_chunked_extra_size";
    BOOL v96 = (char *)_os_log_send_and_compose_impl();
    v138 = OS_LOG_TYPE_ERROR;
    nw_endpoint_t v137 = 0;
    if (__nwlog_fault(v96, &v138, &v137))
    {
      if (v138 == OS_LOG_TYPE_FAULT)
      {
        BOOL v97 = (os_log_s *)__nwlog_obj();
        BOOL v98 = v138;
        if (!os_log_type_enabled(v97, v138)) {
          goto LABEL_220;
        }
        *(_DWORD *)buf = 136446210;
        v140 = "nw_http1_connection_get_chunked_extra_size";
        os_log_type_t v99 = "%{public}s called with null http1_connection";
LABEL_218:
        uint64_t v127 = v97;
LABEL_219:
        _os_log_impl(&dword_181A5C000, v127, v98, v99, buf, 0xCu);
        goto LABEL_220;
      }

      if (!v137)
      {
        BOOL v97 = (os_log_s *)__nwlog_obj();
        BOOL v98 = v138;
        if (!os_log_type_enabled(v97, v138)) {
          goto LABEL_220;
        }
        *(_DWORD *)buf = 136446210;
        v140 = "nw_http1_connection_get_chunked_extra_size";
        os_log_type_t v99 = "%{public}s called with null http1_connection, backtrace limit exceeded";
        goto LABEL_218;
      }

      unint64_t v112 = (char *)__nw_create_backtrace_string();
      v113 = (os_log_s *)__nwlog_obj();
      BOOL v98 = v138;
      loga = v113;
      id v114 = os_log_type_enabled(v113, v138);
      if (v112)
      {
        if (v114)
        {
          *(_DWORD *)buf = 136446466;
          v140 = "nw_http1_connection_get_chunked_extra_size";
          int v141 = 2082;
          char v142 = v112;
          _os_log_impl( &dword_181A5C000,  loga,  v98,  "%{public}s called with null http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v112);
      }

      else if (v114)
      {
        *(_DWORD *)buf = 136446210;
        v140 = "nw_http1_connection_get_chunked_extra_size";
        os_log_type_t v99 = "%{public}s called with null http1_connection, no backtrace";
        uint64_t v127 = loga;
        goto LABEL_219;
      }
    }

                        if (v115) {
                          free(v115);
                        }
                        BOOL v85 = v625;
LABEL_255:
                        uint64_t v127 = (uint64_t *)v634[1];
                        nw_endpoint_t v128 = *v127;
                        os_log_type_t v95 = v630;
                        if (*v127)
                        {
                          nw_frame_set_metadata(*v127, 0LL, 0, v85);
                          if (v85)
                          {
                            if ((*(_BYTE *)(v630 + 158) & 1) == 0)
                            {
                              if (gLogDatapath)
                              {
                                v134 = (os_log_s *)__nwlog_obj();
                                if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
                                {
                                  v135 = *(void *)(v630 + 488);
                                  if (v135) {
                                    LODWORD(v135) = *(_DWORD *)(v135 + 424);
                                  }
                                  os_log_type_t v95 = v630;
                                  v136 = *(_DWORD *)(*(void *)(v630 + 480) + 372LL);
                                  nw_endpoint_t v137 = *(_DWORD *)(v630 + 860);
                                  *(_DWORD *)buf = 136447746;
                                  *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                                  v638 = 2082;
                                  *(void *)v639 = v621;
                                  *(_WORD *)&v639[8] = 2080;
                                  *(void *)&v639[10] = " ";
                                  *(_WORD *)&v639[18] = 1024;
                                  *(_DWORD *)v640 = v136;
                                  *(_WORD *)&v640[4] = 1024;
                                  *(_DWORD *)&v640[6] = v137;
                                  *(_WORD *)v641 = 1024;
                                  *(_DWORD *)&v641[2] = v135;
                                  *(_WORD *)&v641[6] = 2048;
                                  *(void *)&v641[8] = v128;
                                  _os_log_impl( &dword_181A5C000,  v134,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> setting complete on last output frame %p",  buf,  0x3Cu);
                                  BOOL v85 = v625;
                                }
                              }
                            }
                          }
                        }

                        os_log_type_t v94 = v101;
                        nw_protocol_finalize_output_frames(v101, (uint64_t)&v633);
                        v129 = *(void *)type;
                        id v93 = v628;
                        if (*(void *)type)
                        {
                          *(void *)&v647 = 0LL;
                          *((void *)&v647 + 1) = &v647;
                          v649 = 0;
                          v648 = 0x2000000000LL;
                          *(void *)&v643 = MEMORY[0x1895F87A8];
                          *((void *)&v643 + 1) = 0x40000000LL;
                          v644 = ___ZL30nw_http1_connection_send_bytesP19nw_http1_connectionPhjb_block_invoke;
                          v645 = &unk_189BBD8B8;
                          v646 = &v647;
                          do
                          {
                            if (!v129) {
                              break;
                            }
                            uint64_t v130 = *(void *)(v129 + 32);
                            v131 = ((uint64_t (*)(__int128 *))v644)(&v643);
                            v129 = v130;
                          }

                          while ((v131 & 1) != 0);
                          os_log_type_t v95 = v630;
                          if ((*(_BYTE *)(v630 + 158) & 1) == 0)
                          {
                            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                            networkd_settings_init();
                            v132 = (os_log_s *)gLogObj;
                            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                            {
                              v133 = *(void *)(v630 + 488);
                              if (v133) {
                                LODWORD(v133) = *(_DWORD *)(v133 + 424);
                              }
                              BOOL v98 = *(_DWORD *)(*(void *)(v630 + 480) + 372LL);
                              os_log_type_t v99 = *(_DWORD *)(v630 + 860);
                              os_log_type_t v100 = *(_DWORD *)(*((void *)&v647 + 1) + 24LL);
                              *(_DWORD *)buf = 136447746;
                              *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                              v638 = 2082;
                              *(void *)v639 = v621;
                              *(_WORD *)&v639[8] = 2080;
                              *(void *)&v639[10] = " ";
                              *(_WORD *)&v639[18] = 1024;
                              *(_DWORD *)v640 = v98;
                              *(_WORD *)&v640[4] = 1024;
                              *(_DWORD *)&v640[6] = v99;
                              *(_WORD *)v641 = 1024;
                              *(_DWORD *)&v641[2] = v133;
                              *(_WORD *)&v641[6] = 1024;
                              *(_DWORD *)&v641[8] = v100;
                              _os_log_impl( &dword_181A5C000,  v132,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> failed to use %u frames, marking as failed",  buf,  0x38u);
                            }
                          }

                          _Block_object_dispose(&v647, 8);
                        }

                        if (!v97)
                        {
                          char v6 = v627;
                          os_log_type_t v86 = v614;
                          goto LABEL_347;
                        }

                        goto LABEL_212;
                      }

                      nw_frame_collapse(v103);
                      nw_frame_unclaim(v103, v111, v109, 0);
                      unint64_t v112 = *(void *)(v103 + 32);
                      v113 = *(void **)(v103 + 40);
                      if (v112)
                      {
                        *(void *)(v112 + 40) = v113;
                        v113 = *(void **)(v103 + 40);
                      }

                      else
                      {
                        v636 = *(os_log_type_t **)(v103 + 40);
                      }

                      void *v113 = v112;
                      id v114 = v634;
                      *(void *)(v103 + 32) = 0LL;
                      *(void *)(v103 + 40) = v114;
                      *id v114 = v103;
                      v634 = (uint64_t *)(v103 + 32);
                      if (v105)
                      {
                        os_log_type_t v103 = v105;
                        if (v97) {
                          continue;
                        }
                      }

                      goto LABEL_255;
                    }
                  }

                  v592 = v86;
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                  v593 = (char *)_os_log_send_and_compose_impl();
                  LOBYTE(v643) = 16;
                  LOBYTE(v647) = 0;
                  if (__nwlog_fault(v593, &v643, &v647))
                  {
                    if (v643 == 17)
                    {
                      v594 = (os_log_s *)__nwlog_obj();
                      v595 = v643;
                      if (!os_log_type_enabled(v594, (os_log_type_t)v643)) {
                        goto LABEL_1091;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                      v596 = "%{public}s called with null output_handler";
                      goto LABEL_1089;
                    }

                    if (!(_BYTE)v647)
                    {
                      v594 = (os_log_s *)__nwlog_obj();
                      v595 = v643;
                      if (!os_log_type_enabled(v594, (os_log_type_t)v643)) {
                        goto LABEL_1091;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                      v596 = "%{public}s called with null output_handler, backtrace limit exceeded";
                      goto LABEL_1089;
                    }

                    v607 = (char *)__nw_create_backtrace_string();
                    v604 = (os_log_s *)__nwlog_obj();
                    v605 = v643;
                    v610 = os_log_type_enabled(v604, (os_log_type_t)v643);
                    if (v607)
                    {
                      if (!v610) {
                        goto LABEL_1075;
                      }
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                      v638 = 2082;
                      *(void *)v639 = v607;
                      v609 = "%{public}s called with null output_handler, dumping backtrace:%{public}s";
LABEL_1074:
                      _os_log_impl(&dword_181A5C000, v604, v605, v609, buf, 0x16u);
LABEL_1075:
                      free(v607);
                      if (!v593) {
                        goto LABEL_1093;
                      }
                      goto LABEL_1092;
                    }

                    if (v610)
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_send_bytes";
                      v596 = "%{public}s called with null output_handler, no backtrace";
                      goto LABEL_1100;
                    }
                  }

LABEL_121:
              uint64_t v2 = (uint64_t)v424;
            }

                    nw_endpoint_handler_report(v14, 0LL, v41, 0LL);
                    goto LABEL_122;
                  }
                }

                else if (a2 != 2)
                {
                  v353 = 0LL;
                  goto LABEL_119;
                }

                v353 = 0LL;
                os_log_type_t v68 = *((void *)v44 + 118);
                if (v68)
                {
                  __int16 v41 = a4;
                  if (v10)
                  {
                    id v70 = *(id **)(v68 + 16);
                    v69 = *(id **)(v68 + 24);
                    if (v70 != v69)
                    {
                      while (*v70 != v10)
                      {
                        if (++v70 == v69)
                        {
                          id v70 = v69;
                          break;
                        }
                      }
                    }

                    v353 = 0LL;
                    if (a4)
                    {
                      if (v70 != v69)
                      {
                        if (*a4 == 3 && a4[1] == 4)
                        {
LABEL_117:
                          v353 = v10;
                          v348 = 1;
                          goto LABEL_120;
                        }

                        v353 = 0LL;
                      }
                    }
                  }

    os_log_type_t v64 = v37;
    v65 = v38;
    nw_endpoint_t v66 = 12;
LABEL_122:
    _os_log_impl(&dword_181A5C000, v64, v65, v39, buf, v66);
    goto LABEL_123;
  }

  if (v11) {
    id v16 = (_DWORD)v12 == 0;
  }
  else {
    id v16 = 1;
  }
  os_log_type_t v17 = !v16;
  os_log_type_t v99 = v17;
  if (!v16) {
    os_channel_attr_set_key();
  }
  os_channel_attr_set();
  if ((v13 & 1) != 0) {
    os_channel_attr_set();
  }
  if ((v13 & 2) != 0) {
    os_channel_attr_set();
  }
  os_channel_attr_set();
  if (a3 >= 0x10000)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&void buf[14] = a3;
    BOOL v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v122) = 0;
    if (__nwlog_fault(v36, type, &v122))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v88 = (os_log_s *)__nwlog_obj();
        os_log_type_t v89 = type[0];
        if (os_log_type_enabled(v88, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = a3;
          uint64_t v39 = "%{public}s port %u > NEXUS_PORT_MAX";
LABEL_211:
          os_log_type_t v64 = v88;
          v65 = v89;
          nw_endpoint_t v66 = 18;
          goto LABEL_122;
        }
      }

      else if ((_BYTE)v122)
      {
        os_log_type_t v90 = (char *)__nw_create_backtrace_string();
        nw_endpoint_t v88 = (os_log_s *)__nwlog_obj();
        os_log_type_t v89 = type[0];
        os_log_type_t v91 = os_log_type_enabled(v88, type[0]);
        if (v90)
        {
          if (v91)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_channel_create";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&void buf[14] = a3;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v90;
            _os_log_impl( &dword_181A5C000,  v88,  v89,  "%{public}s port %u > NEXUS_PORT_MAX, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v90);
          if (!v36) {
            goto LABEL_125;
          }
          goto LABEL_124;
        }

        if (v91)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = a3;
          uint64_t v39 = "%{public}s port %u > NEXUS_PORT_MAX, no backtrace";
          goto LABEL_211;
        }
      }

      else
      {
        nw_endpoint_t v88 = (os_log_s *)__nwlog_obj();
        os_log_type_t v89 = type[0];
        if (os_log_type_enabled(v88, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = a3;
          uint64_t v39 = "%{public}s port %u > NEXUS_PORT_MAX, backtrace limit exceeded";
          goto LABEL_211;
        }
      }
    }

    if (v98) {
      free(v98);
    }
    return 0LL;
  }

  uint64_t v3 = a3;
  id v4 = a2;
  int v5 = (char *)*((void *)&xmmword_18C45F4E8 + 1);
  char v6 = (char *)xmmword_18C45F4E8;
  id v7 = *((void *)&xmmword_18C45F4E8 + 1) - xmmword_18C45F4E8;
  if (*((void *)&xmmword_18C45F4E8 + 1) == (void)xmmword_18C45F4E8) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = 32 * (*((void *)&xmmword_18C45F4E8 + 1) - xmmword_18C45F4E8) - 1;
  }
  nw_endpoint_t v9 = qword_18C45F508;
  os_log_type_t v10 = qword_18C45F500 + qword_18C45F508;
  if (v8 != qword_18C45F500 + qword_18C45F508) {
    goto LABEL_89;
  }
  if ((unint64_t)qword_18C45F500 < 0x100)
  {
    BOOL v23 = v7 >> 3;
    if (v7 >> 3 < (unint64_t)((qword_18C45F4F8 - qword_18C45F4E0) >> 3))
    {
      if (qword_18C45F4F8 != *((void *)&xmmword_18C45F4E8 + 1))
      {
        result = (char *)calloc(0x100uLL, 0x10uLL);
        if (result)
        {
          *(void *)buf = result;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_back( &qword_18C45F4E0,  buf);
LABEL_88:
          char v6 = (char *)xmmword_18C45F4E8;
          os_log_type_t v10 = qword_18C45F508 + qword_18C45F500;
LABEL_89:
          int v82 = (void *)(*(void *)&v6[(v10 >> 5) & 0x7FFFFFFFFFFFFF8LL] + 16LL * v10);
          void *v82 = v4;
          v82[1] = v3;
          ++qword_18C45F508;
          return (char *)v9;
        }

        goto LABEL_124;
      }

      result = (char *)calloc(0x100uLL, 0x10uLL);
      if (!result) {
        goto LABEL_124;
      }
      *(void *)buf = result;
      std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front( (const void **)&qword_18C45F4E0,  buf);
      id v37 = (char *)*((void *)&xmmword_18C45F4E8 + 1);
      v38 = (char *)(xmmword_18C45F4E8 + 8);
      uint64_t v39 = *(void *)xmmword_18C45F4E8;
      *(void *)&xmmword_18C45F4E8 = xmmword_18C45F4E8 + 8;
      if (*((void *)&xmmword_18C45F4E8 + 1) != qword_18C45F4F8)
      {
LABEL_106:
        *(void *)id v37 = v39;
        *((void *)&xmmword_18C45F4E8 + 1) += 8LL;
        goto LABEL_88;
      }

      uint64_t v40 = (uint64_t)&v38[-qword_18C45F4E0];
      if ((unint64_t)v38 > qword_18C45F4E0)
      {
        __int16 v41 = v40 >> 3;
        os_log_type_t v15 = v40 >> 3 < -1;
        BOOL v42 = (v40 >> 3) + 2;
        if (v15) {
          __int16 v43 = v42;
        }
        else {
          __int16 v43 = v41 + 1;
        }
        os_log_type_t v44 = v43 >> 1;
        __int16 v45 = -v44;
        nw_endpoint_t v46 = &v38[-8 * v44];
        BOOL v47 = *((void *)&xmmword_18C45F4E8 + 1) - (void)v38;
        if (*((char **)&xmmword_18C45F4E8 + 1) != v38)
        {
          memmove(&v38[-8 * v44], v38, *((void *)&xmmword_18C45F4E8 + 1) - (void)v38);
          v38 = (char *)xmmword_18C45F4E8;
        }

        id v37 = &v46[v47];
        *(void *)&xmmword_18C45F4E8 = &v38[8 * v45];
        *((void *)&xmmword_18C45F4E8 + 1) = &v46[v47];
        goto LABEL_106;
      }

      if (*((void *)&xmmword_18C45F4E8 + 1) == qword_18C45F4E0) {
        os_log_type_t v83 = 1LL;
      }
      else {
        os_log_type_t v83 = (*((void *)&xmmword_18C45F4E8 + 1) - qword_18C45F4E0) >> 2;
      }
      result = (char *)calloc(v83, 8uLL);
      if (!result) {
        goto LABEL_124;
      }
      os_log_type_t v84 = &result[8 * (v83 >> 2)];
      BOOL v85 = (uint64_t *)xmmword_18C45F4E8;
      id v37 = v84;
      os_log_type_t v86 = *((void *)&xmmword_18C45F4E8 + 1) - xmmword_18C45F4E8;
      if (*((void *)&xmmword_18C45F4E8 + 1) != (void)xmmword_18C45F4E8)
      {
        id v37 = &v84[v86 & 0xFFFFFFFFFFFFFFF8LL];
        BOOL v87 = v86 - 8;
        if (v87 < 0x38)
        {
          nw_endpoint_t v88 = &result[8 * (v83 >> 2)];
          goto LABEL_103;
        }

        os_log_type_t v89 = &result[8 * (v83 >> 2)];
        nw_endpoint_t v88 = v89;
        if ((unint64_t)&v89[-xmmword_18C45F4E8] < 0x20)
        {
          do
          {
LABEL_103:
            BOOL v96 = *v85++;
            *(void *)nw_endpoint_t v88 = v96;
            v88 += 8;
          }

          while (v88 != v37);
          goto LABEL_104;
        }

        os_log_type_t v90 = (v87 >> 3) + 1;
        os_log_type_t v91 = 8 * (v90 & 0x3FFFFFFFFFFFFFFCLL);
        nw_endpoint_t v88 = &v84[v91];
        id v92 = (__int128 *)(xmmword_18C45F4E8 + 16);
        id v93 = v89 + 16;
        os_log_type_t v94 = v90 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          os_log_type_t v95 = *v92;
          *(v93 - 1) = *(v92 - 1);
          void *v93 = v95;
          v92 += 2;
          v93 += 2;
          v94 -= 4LL;
        }

        while (v94);
        if (v90 != (v90 & 0x3FFFFFFFFFFFFFFCLL))
        {
          BOOL v85 = (uint64_t *)((char *)v85 + v91);
          goto LABEL_103;
        }
      }

  if (*(_BYTE *)(v14 + 140) == 2)
  {
LABEL_147:
    nw_protocol_plugin_metadata_report_transfer(v14, (uint64_t)a1, *(void *)(v14 + 48), v229, 1LL);
    goto LABEL_148;
  }

  if (!(_DWORD)v15) {
    goto LABEL_141;
  }
LABEL_139:
  if (!v232 || !v231)
  {
    if (!gLogDatapath) {
      goto LABEL_147;
    }
    os_log_type_t v64 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_147;
    }
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v65 = "%{public}s returning frames from input_frames_pending_delivery and saved input frames";
    goto LABEL_464;
  }

  if (v26) {
    os_release(v26);
  }
}
      }
    }
  }

  else
  {
    BOOL v42 = v20;
    __nwlog_obj();
    os_log_type_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_pac_resolver_create_with_url";
    __int16 v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v80 = 0;
    if (__nwlog_fault(v45, &type, &v80))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_endpoint_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_pac_resolver_create_with_url";
          _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s called with null pacURL", buf, 0xCu);
        }

        goto LABEL_106;
      }

      if (!v80)
      {
        __nwlog_obj();
        nw_endpoint_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v73 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_pac_resolver_create_with_url";
          _os_log_impl( &dword_181A5C000,  v46,  v73,  "%{public}s called with null pacURL, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_106;
      }

      __int16 v58 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v60 = type;
      uint64_t v61 = os_log_type_enabled(v59, type);
      if (v58)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v83 = "nw_pac_resolver_create_with_url";
          os_log_type_t v84 = 2082;
          BOOL v85 = v58;
          _os_log_impl( &dword_181A5C000,  v59,  v60,  "%{public}s called with null pacURL, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_86;
      }

      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v83 = "nw_pac_resolver_create_with_url";
        _os_log_impl(&dword_181A5C000, v59, v60, "%{public}s called with null pacURL, no backtrace", buf, 0xCu);
      }

      goto LABEL_121;
    }
  }

    goto LABEL_122;
  }

  if (nw_proxy_config_get_int64(v5, (uint64_t)@"ProxyAutoConfigEnable", 1LL))
  {
    string = nw_proxy_config_get_string(v5);
    id v7 = nw_proxy_config_get_string(v5);
    if (string)
    {
      pac_script = nw_proxy_config_create_pac_script(string);
      pac_url = pac_script;
      if (pac_script)
      {
        nw_proxy_config_apply_common_keys(pac_script, v5, 0);
LABEL_10:
        nw_array_append(*(void *)(a1 + 32), pac_url);

        goto LABEL_11;
      }

      goto LABEL_87;
    }

    if (v7)
    {
      url = nw_endpoint_create_url(v7);
      pac_url = nw_proxy_config_create_pac_url(url);

      if (pac_url)
      {
        nw_proxy_config_apply_common_keys(pac_url, v5, 0);
        goto LABEL_10;
      }

      if (*((_BYTE *)v12 + 1537))
      {
        v176 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v176, OS_LOG_TYPE_DEBUG))
        {
          v177 = *(_DWORD *)(v45 + 372);
          uint64_t v178 = *(_DWORD *)(v45 + 368) + *(_DWORD *)(v45 + 364);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v45 + 74;
          *(_WORD *)&buf[22] = 2080;
          v209 = (uint64_t)" ";
          *(_WORD *)int v210 = 1024;
          *(_DWORD *)&v210[2] = v177;
          *(_WORD *)&v210[6] = 1024;
          *(_DWORD *)&v210[8] = v178;
          *(_WORD *)&v210[12] = 2048;
          *(void *)&v210[14] = v46;
          _os_log_impl( &dword_181A5C000,  v176,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> decreased connection pool width to %u after removing non-reusable connection %p",  buf,  0x36u);
        }
      }

      goto LABEL_122;
    }

    goto LABEL_125;
  }

  if (!nw_protocol_options_is_masque(v9[5]))
  {
    __nwlog_obj();
    id v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    os_log_type_t v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null nw_protocol_options_is_masque(hop->options)",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    if (!(_BYTE)v54)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v46 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v46,  "%{public}s called with null nw_protocol_options_is_masque(hop->options), backtrace limit exceeded",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    BOOL v32 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    nw_endpoint_t v33 = type[0];
    uint64_t v34 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v34)
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v33,  "%{public}s called with null nw_protocol_options_is_masque(hop->options), no backtrace",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    if (v34)
    {
      *(_DWORD *)out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl( &dword_181A5C000,  v14,  v33,  "%{public}s called with null nw_protocol_options_is_masque(hop->options), dumping backtrace:%{public}s",  (uint8_t *)out,  0x16u);
    }

    goto LABEL_75;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    os_log_type_t v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v19 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null header", (uint8_t *)out, 0xCu);
      }

      goto LABEL_121;
    }

    if (!(_BYTE)v54)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v47 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v47,  "%{public}s called with null header, backtrace limit exceeded",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    BOOL v32 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v35 = type[0];
    BOOL v36 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v36)
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v35,  "%{public}s called with null header, no backtrace",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    if (v36)
    {
      *(_DWORD *)out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl( &dword_181A5C000,  v14,  v35,  "%{public}s called with null header, dumping backtrace:%{public}s",  (uint8_t *)out,  0x16u);
    }

    goto LABEL_75;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    os_log_type_t v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null value_prefix", (uint8_t *)out, 0xCu);
      }

      goto LABEL_121;
    }

    if (!(_BYTE)v54)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v48 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v48,  "%{public}s called with null value_prefix, backtrace limit exceeded",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    BOOL v32 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v37 = type[0];
    v38 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v38)
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v37,  "%{public}s called with null value_prefix, no backtrace",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    if (v38)
    {
      *(_DWORD *)out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl( &dword_181A5C000,  v14,  v37,  "%{public}s called with null value_prefix, dumping backtrace:%{public}s",  (uint8_t *)out,  0x16u);
    }

    goto LABEL_75;
  }

  if (!a4)
  {
    __nwlog_obj();
    os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    os_log_type_t v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v23 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A5C000, v14, v23, "%{public}s called with null value_suffix", (uint8_t *)out, 0xCu);
      }

      goto LABEL_121;
    }

    if (!(_BYTE)v54)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v49,  "%{public}s called with null value_suffix, backtrace limit exceeded",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    BOOL v32 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v39 = type[0];
    uint64_t v40 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v40)
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v39,  "%{public}s called with null value_suffix, no backtrace",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    if (v40)
    {
      *(_DWORD *)out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl( &dword_181A5C000,  v14,  v39,  "%{public}s called with null value_suffix, dumping backtrace:%{public}s",  (uint8_t *)out,  0x16u);
    }

    goto LABEL_75;
  }

  if (!a5)
  {
    __nwlog_obj();
    int v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)out = 136446210;
    *(void *)&out[4] = "nw_proxy_hop_add_token_header";
    os_log_type_t v13 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v54) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl(&dword_181A5C000, v14, v25, "%{public}s called with null token_agent", (uint8_t *)out, 0xCu);
      }

      goto LABEL_121;
    }

    if (!(_BYTE)v54)
    {
      __nwlog_obj();
      BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v50 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v50,  "%{public}s called with null token_agent, backtrace limit exceeded",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    BOOL v32 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v41 = type[0];
    BOOL v42 = os_log_type_enabled(v14, type[0]);
    if (!v32)
    {
      if (v42)
      {
        *(_DWORD *)out = 136446210;
        *(void *)&out[4] = "nw_proxy_hop_add_token_header";
        _os_log_impl( &dword_181A5C000,  v14,  v41,  "%{public}s called with null token_agent, no backtrace",  (uint8_t *)out,  0xCu);
      }

      goto LABEL_121;
    }

    if (v42)
    {
      *(_DWORD *)out = 136446466;
      *(void *)&out[4] = "nw_proxy_hop_add_token_header";
      *(_WORD *)&out[12] = 2082;
      *(void *)&out[14] = v32;
      _os_log_impl( &dword_181A5C000,  v14,  v41,  "%{public}s called with null token_agent, dumping backtrace:%{public}s",  (uint8_t *)out,  0x16u);
    }

                                if (!v55) {
                                  goto LABEL_198;
                                }
LABEL_122:
                                free(v55);
                                goto LABEL_198;
                              }

  *(_OWORD *)((char *)v286 + 376) = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  if (nw_endpoint_handler_get_minimize_logging(v9))
  {
    if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) == 0)
    {
      v259 = a3;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v260 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v260, OS_LOG_TYPE_DEBUG))
      {
        int v261 = nw_endpoint_handler_get_id_string(v9);
        char v262 = nw_endpoint_handler_dry_run_string(v9);
        v263 = nw_endpoint_handler_copy_endpoint(v9);
        v264 = nw_endpoint_get_logging_description(v263);
        v265 = nw_endpoint_handler_state_string(v9);
        nw_endpoint_t v266 = nw_endpoint_handler_mode_string(v9);
        v267 = nw_endpoint_handler_copy_current_path(v9);
        *(_DWORD *)buf = 136448258;
        v292 = "nw_endpoint_flow_setup_protocols";
        v293 = 2082;
        os_log_type_t v294 = (char *)v261;
        v295 = 2082;
        os_log_type_t v296 = (nw_protocol *)v262;
        v297 = 2082;
        os_log_type_t v298 = (void *)v264;
        BOOL v299 = 2082;
        uint64_t v300 = (void *)v265;
        uint64_t v301 = 2082;
        v302 = v266;
        int v303 = 2114;
        char v304 = v267;
        v305 = 1042;
        LODWORD(v306[0]) = 16;
        WORD2(v306[0]) = 2098;
        *(void *)((char *)v306 + 6) = (char *)v286 + 376;
        _os_log_impl( &dword_181A5C000,  v260,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] generated flow id %{public,uuid_t}.16P",  buf,  0x58u);
      }

      a3 = v259;
    }

    goto LABEL_128;
  }

  os_log_type_t v110 = v9;
  BOOL v111 = (*((_BYTE *)v110 + 268) & 0x20) == 0;

  if (v111)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v80 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
    {
      unint64_t v112 = nw_endpoint_handler_get_id_string(v110);
      v113 = nw_endpoint_handler_dry_run_string(v110);
      id v114 = nw_endpoint_handler_copy_endpoint(v110);
      v279 = a3;
      char v115 = nw_endpoint_get_logging_description(v114);
      __int16 v116 = nw_endpoint_handler_state_string(v110);
      int v117 = nw_endpoint_handler_mode_string(v110);
      __int16 v118 = nw_endpoint_handler_copy_current_path(v110);
      *(_DWORD *)buf = 136448258;
      v292 = "nw_endpoint_flow_setup_protocols";
      v293 = 2082;
      os_log_type_t v294 = (char *)v112;
      v295 = 2082;
      os_log_type_t v296 = (nw_protocol *)v113;
      v297 = 2082;
      os_log_type_t v298 = (void *)v115;
      BOOL v299 = 2082;
      uint64_t v300 = (void *)v116;
      uint64_t v301 = 2082;
      v302 = v117;
      int v303 = 2114;
      char v304 = v118;
      v305 = 1042;
      LODWORD(v306[0]) = 16;
      WORD2(v306[0]) = 2098;
      *(void *)((char *)v306 + 6) = (char *)v286 + 376;
      _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] generated flow id %{public,uuid_t}.16P",  buf,  0x58u);

      a3 = v279;
    }

    goto LABEL_127;
  }

      free(v74);
      if (!v61) {
        goto LABEL_80;
      }
LABEL_156:
      os_log_type_t v57 = (char *)v61;
      goto LABEL_79;
    }

    if (v76)
    {
      *(_DWORD *)buf = 136446210;
      id v105 = "nw_endpoint_flow_find_protocol_to_join";
      _os_log_impl(&dword_181A5C000, v67, v75, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
    }

      if (v35) {
        free(v35);
      }
LABEL_15:
      if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v22 = a1[1].callbacks;
        if (v22)
        {
          BOOL v23 = (nw_protocol_callbacks *)((char *)v22 - 1);
          a1[1].callbacks = v23;
          if (!v23)
          {
            int v24 = *(void (***)(void))a1[1].flow_id;
            if (v24)
            {
              *(void *)a1[1].flow_id = 0LL;
              v24[2](v24);
              _Block_release(v24);
            }

            if ((a1[1].flow_id[8] & 1) != 0)
            {
              os_log_type_t v25 = *(const void **)a1[1].flow_id;
              if (v25) {
                _Block_release(v25);
              }
            }

            free(a1);
          }
        }
      }

      if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v26 = default_input_handler[1].callbacks;
        if (v26)
        {
          os_log_type_t v27 = (nw_protocol_callbacks *)((char *)v26 - 1);
          default_input_handler[1].callbacks = v27;
          if (!v27)
          {
            int v28 = *(void (***)(void))default_input_handler[1].flow_id;
            if (v28)
            {
              *(void *)default_input_handler[1].flow_id = 0LL;
              v28[2](v28);
              _Block_release(v28);
            }

            if ((default_input_handler[1].flow_id[8] & 1) != 0)
            {
              char v29 = *(const void **)default_input_handler[1].flow_id;
              if (v29) {
                _Block_release(v29);
              }
            }

            free(default_input_handler);
            return 1LL;
          }
        }
      }

      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v63 = "__nw_protocol_connected";
    __int16 v45 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v60 = 0;
    if (__nwlog_fault(v45, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v46 = (os_log_s *)__nwlog_obj();
        BOOL v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_136;
        }
        *(_DWORD *)buf = 136446210;
        v63 = "__nw_protocol_connected";
        os_log_type_t v48 = "%{public}s called with null protocol";
        goto LABEL_135;
      }

      if (!v60)
      {
        nw_endpoint_t v46 = (os_log_s *)__nwlog_obj();
        BOOL v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_136;
        }
        *(_DWORD *)buf = 136446210;
        v63 = "__nw_protocol_connected";
        os_log_type_t v48 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_135;
      }

      __int16 v56 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v46 = (os_log_s *)__nwlog_obj();
      BOOL v47 = type;
      os_log_type_t v57 = os_log_type_enabled(v46, type);
      if (v56)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446466;
          v63 = "__nw_protocol_connected";
          os_log_type_t v64 = 2082;
          v65 = (nw_protocol *)v56;
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v56);
        goto LABEL_136;
      }

      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        v63 = "__nw_protocol_connected";
        os_log_type_t v48 = "%{public}s called with null protocol, no backtrace";
LABEL_135:
        _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
      }
    }

    if (v49) {
      free(v49);
    }
    os_log_type_t v21 = 0LL;
    id v16 = 0LL;
    uint64_t v55 = 0LL;
    goto LABEL_227;
  }

  if (a2->identifier) {
    identifier = a2->identifier;
  }
  else {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  if (!strncmp(identifier->name, "quic", 4uLL))
  {
LABEL_152:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "nw_protocol_ipv6_add_input_handler";
    os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    uint64_t v154 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v69 = (os_log_s *)__nwlog_obj();
      id v70 = type[0];
      if (os_log_type_enabled(v69, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v157 = "nw_protocol_ipv6_add_input_handler";
        BOOL v71 = "%{public}s Attempt to add quic to ip";
        goto LABEL_362;
      }

LABEL_351:
            id v271 = *(id *)(v2 + 248);
            [v271 updatePathWithHandler:v2];

            goto LABEL_440;
          }

          if (!minimize_logging)
          {
            if ((logging_disabled & 1) != 0)
            {
LABEL_296:
              nw_endpoint_handler_handle_failure(v2);
              nw_endpoint_handler_report((void *)v2, 0LL, 0LL, 0LL);
              goto LABEL_441;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v181 = (id)gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)v181, OS_LOG_TYPE_INFO))
            {
LABEL_234:

              uint64_t v2 = (uint64_t)v424;
              goto LABEL_296;
            }

                    if (v131) {
                      os_release(v131);
                    }
                    return;
                  }

            if (v123) {
              free(v123);
            }
            goto LABEL_154;
          }

            if (v186) {
              free(v186);
            }
            goto LABEL_233;
          }

          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
          v173 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v228[0] = 0;
          os_log_type_t v44 = (uint64_t)v221;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            nw_endpoint_t v174 = (os_log_s *)__nwlog_obj();
            v175 = type[0];
            if (!os_log_type_enabled(v174, type[0])) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            v176 = "%{public}s called with null options_protocol";
            goto LABEL_384;
          }

          if (!v228[0])
          {
            nw_endpoint_t v174 = (os_log_s *)__nwlog_obj();
            v175 = type[0];
            id v70 = v218;
            if (!os_log_type_enabled(v174, type[0])) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            v176 = "%{public}s called with null options_protocol, backtrace limit exceeded";
            goto LABEL_384;
          }

          uint64_t v201 = (char *)__nw_create_backtrace_string();
          nw_endpoint_t v174 = (os_log_s *)__nwlog_obj();
          v175 = type[0];
          v204 = os_log_type_enabled(v174, type[0]);
          if (!v201)
          {
            os_log_type_t v44 = (uint64_t)v221;
            id v70 = v218;
            if (!v204) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            v176 = "%{public}s called with null options_protocol, no backtrace";
            goto LABEL_384;
          }

          if (v204)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v201;
            v203 = "%{public}s called with null options_protocol, dumping backtrace:%{public}s";
            goto LABEL_332;
          }

          goto LABEL_333;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
        v173 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v228[0] = 0;
        if (type[0] != OS_LOG_TYPE_FAULT)
        {
          if (!v228[0])
          {
            nw_endpoint_t v174 = (os_log_s *)__nwlog_obj();
            v175 = type[0];
            id v70 = v218;
            if (!os_log_type_enabled(v174, type[0])) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            v176 = "%{public}s called with null parameters, backtrace limit exceeded";
            goto LABEL_384;
          }

          uint64_t v201 = (char *)__nw_create_backtrace_string();
          nw_endpoint_t v174 = (os_log_s *)__nwlog_obj();
          v175 = type[0];
          id v202 = os_log_type_enabled(v174, type[0]);
          if (!v201)
          {
            os_log_type_t v44 = (uint64_t)v221;
            id v70 = v218;
            if (!v202) {
              goto LABEL_385;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            v176 = "%{public}s called with null parameters, no backtrace";
            goto LABEL_384;
          }

          if (v202)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v201;
            v203 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
LABEL_332:
            _os_log_impl(&dword_181A5C000, v174, v175, v203, buf, 0x16u);
          }

LABEL_233:
            v182 = nw_endpoint_handler_get_id_string((void *)v2);
            v183 = nw_endpoint_handler_dry_run_string((void *)v2);
            nw_endpoint_t v184 = nw_endpoint_handler_copy_endpoint((void *)v2);
            v185 = nw_endpoint_get_logging_description(v184);
            v186 = nw_endpoint_handler_state_string((void *)v2);
            v187 = nw_endpoint_handler_mode_string((void *)v2);
            id v188 = nw_endpoint_handler_copy_current_path((void *)v2);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v182;
            HIWORD(buf[2]) = 2082;
            buf[3] = v183;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v185;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v186;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v187;
            HIWORD(buf[7]) = 2114;
            buf[8] = v188;
            _os_log_impl( &dword_181A5C000,  (os_log_t)v181,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow is no longer satisfied",  (uint8_t *)buf,  0x48u);

            goto LABEL_234;
          }

          if ((logging_disabled & 1) != 0) {
            goto LABEL_296;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v181 = (id)gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)v181, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_234;
          }
          goto LABEL_466;
        }

        if (*(int *)(v2 + 120) > 2)
        {
LABEL_441:
          _Block_object_dispose(&v432, 8);
          goto LABEL_442;
        }

        id v93 = (id)v2;
        os_log_type_t v94 = v93;
        os_log_type_t v95 = *(void **)(v2 + 32);
        if (v95)
        {
          BOOL v96 = v95;
          BOOL v97 = (v96[12] & 0x4000000000LL) == 0;

          if (!v97)
          {
            uint64_t v2 = (uint64_t)v424;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            BOOL v98 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
            {
              os_log_type_t v99 = nw_endpoint_handler_get_id_string(v94);
              os_log_type_t v100 = nw_endpoint_handler_dry_run_string(v94);
              nw_endpoint_t v101 = nw_endpoint_handler_copy_endpoint(v94);
              os_log_type_t v102 = nw_endpoint_get_logging_description(v101);
              os_log_type_t v103 = nw_endpoint_handler_state_string(v94);
              BOOL v104 = nw_endpoint_handler_mode_string(v94);
              id v105 = nw_endpoint_handler_copy_current_path(v94);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v99;
              HIWORD(buf[2]) = 2082;
              buf[3] = v100;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v102;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v103;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v104;
              HIWORD(buf[7]) = 2114;
              buf[8] = v105;
              _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying to satisfy agents",  (uint8_t *)buf,  0x48u);
            }

            goto LABEL_294;
          }
        }

        else
        {
        }

        uint64_t v2 = (uint64_t)v424;
        if ((*((_BYTE *)v424 + 268) & 0x20) != 0) {
          goto LABEL_295;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v98 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v98, OS_LOG_TYPE_INFO))
        {
          v170 = v94;

          v171 = v170;
          BOOL v172 = (*((_BYTE *)v424 + 268) & 1) == 0;

          if (v172) {
            v173 = "";
          }
          else {
            v173 = "dry-run ";
          }
          nw_endpoint_t v174 = nw_endpoint_handler_copy_endpoint(v171);
          v175 = nw_endpoint_get_logging_description(v174);
          v176 = v171;
          v177 = v176;
          uint64_t v178 = v424->state;
          v423 = v175;
          v179 = v173;
          else {
            v180 = off_189BBBBF0[v178];
          }

          v192 = v177;
          v193 = v192;
          v194 = "path";
          switch(v424->mode)
          {
            case 0:
              break;
            case 1:
              v194 = "resolver";
              break;
            case 2:
              v194 = nw_endpoint_flow_mode_string(v192[31]);
              break;
            case 3:
              v194 = "proxy";
              break;
            case 4:
              v194 = "fallback";
              break;
            case 5:
              v194 = "transform";
              break;
            default:
              v194 = "unknown-mode";
              break;
          }

          v221 = v193;
          os_unfair_lock_lock(v221 + 28);
          v222 = v424->current_path;
          os_unfair_lock_unlock(v221 + 28);

          LODWORD(buf[0]) = 136447746;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v170 + 168;
          HIWORD(buf[2]) = 2082;
          buf[3] = v179;
          LOWORD(buf[4]) = 2082;
          *(void *)((char *)&buf[4] + 2) = v423;
          WORD1(buf[5]) = 2082;
          *(void *)((char *)&buf[5] + 4) = v180;
          WORD2(buf[6]) = 2082;
          *(void *)((char *)&buf[6] + 6) = v194;
          HIWORD(buf[7]) = 2114;
          buf[8] = v222;
          _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying to satisfy agents",  (uint8_t *)buf,  0x48u);
        }

      if (v81) {
        free(v81);
      }
      goto LABEL_53;
    }

    BOOL v98 = 1;
    char v6 = a2->handle;
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      id v7 = a2[1].callbacks;
      if (v7) {
        a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
      }
    }

    uint64_t v8 = a1->handle;
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      nw_endpoint_t v9 = a1[1].callbacks;
      if (v9) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v9->add_input_handler + 1);
      }
    }

    os_log_type_t v10 = a2->callbacks;
    if (v10)
    {
      char v11 = (void (*)(nw_protocol *, nw_protocol *, uint64_t, char *, uint64_t))v10->notify;
      if (v11)
      {
        v11(a2, a1, 23LL, &v98, 1LL);
        goto LABEL_16;
      }
    }

    __nwlog_obj();
    __int16 v54 = a2->identifier;
    *(_DWORD *)buf = 136446722;
    os_log_type_t v102 = "__nw_protocol_notify";
    if (!v54) {
      __int16 v54 = (nw_protocol_identifier *)"invalid";
    }
    os_log_type_t v103 = 2082;
    BOOL v104 = (nw_protocol *)v54;
    id v105 = 2048;
    uint64_t v106 = a2;
    uint64_t v55 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v99 = 0;
    if (__nwlog_fault(v55, &type, &v99))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v56 = (os_log_s *)__nwlog_obj();
        os_log_type_t v57 = type;
        if (!os_log_type_enabled(v56, type)) {
          goto LABEL_197;
        }
        __int16 v58 = a2->identifier;
        if (!v58) {
          __int16 v58 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v102 = "__nw_protocol_notify";
        os_log_type_t v103 = 2082;
        BOOL v104 = (nw_protocol *)v58;
        id v105 = 2048;
        uint64_t v106 = a2;
        uint64_t v59 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
        goto LABEL_196;
      }

      if (!v99)
      {
        __int16 v56 = (os_log_s *)__nwlog_obj();
        os_log_type_t v57 = type;
        if (!os_log_type_enabled(v56, type)) {
          goto LABEL_197;
        }
        os_log_type_t v89 = a2->identifier;
        if (!v89) {
          os_log_type_t v89 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v102 = "__nw_protocol_notify";
        os_log_type_t v103 = 2082;
        BOOL v104 = (nw_protocol *)v89;
        id v105 = 2048;
        uint64_t v106 = a2;
        uint64_t v59 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
        goto LABEL_196;
      }

      BOOL v71 = (char *)__nw_create_backtrace_string();
      __int16 v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = type;
      int v72 = os_log_type_enabled(v56, type);
      if (v71)
      {
        if (v72)
        {
          BOOL v73 = a2->identifier;
          if (!v73) {
            BOOL v73 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446978;
          os_log_type_t v102 = "__nw_protocol_notify";
          os_log_type_t v103 = 2082;
          BOOL v104 = (nw_protocol *)v73;
          id v105 = 2048;
          uint64_t v106 = a2;
          unint64_t v107 = 2082;
          unint64_t v108 = v71;
          _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v71);
        goto LABEL_197;
      }

      if (v72)
      {
        id v93 = a2->identifier;
        if (!v93) {
          id v93 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v102 = "__nw_protocol_notify";
        os_log_type_t v103 = 2082;
        BOOL v104 = (nw_protocol *)v93;
        id v105 = 2048;
        uint64_t v106 = a2;
        uint64_t v59 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
LABEL_196:
        _os_log_impl(&dword_181A5C000, v56, v57, v59, buf, 0x20u);
      }
    }

          id v150 = 1LL;
          goto LABEL_208;
        }

    if (!extended_dns_error_code) {
      goto LABEL_253;
    }
    BOOL v172 = *(void *)(v278 + 32);
    if (!*(_WORD *)(v172 + 344) || v82 == 1)
    {
      *(_WORD *)(v172 + 344) = extended_dns_error_code;
      v173 = *(void **)(*(void *)(v278 + 32) + 224LL);
      if (v173)
      {
        free(v173);
        *(void *)(*(void *)(v278 + 32) + 224LL) = 0LL;
      }

      if (extended_dns_error_text && (v78 - 3) <= 1)
      {
        nw_endpoint_t v174 = strdup(extended_dns_error_text);
        if (!v174)
        {
          __nwlog_obj();
          v263 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v263, OS_LOG_TYPE_ERROR);
          *(_DWORD *)BOOL v299 = 136446210;
          *(void *)&v299[4] = "strict_strdup";
          v264 = (void *)_os_log_send_and_compose_impl();

          if (__nwlog_abort((uint64_t)v264))
          {
            __break(1u);
            return;
          }

          free(v264);
        }

        *(void *)(*(void *)(v278 + 32) + 224LL) = v174;
      }
    }

    if (extended_dns_error_code != 4)
    {
LABEL_253:
      switch(v82)
      {
        case 1:
          v189 = 0;
          v191 = 0;
          v190 = 2;
          break;
        case 4:
          v189 = 0;
          v191 = 0;
          v190 = -2147483646;
          break;
        case 3:
LABEL_256:
          negative_reason = dnssd_getaddrinfo_result_get_negative_reason();
          v182 = *(void *)(v278 + 32);
          if (v182)
          {
            if ((*(_BYTE *)(v182 + 346) & 0x20) != 0)
            {
LABEL_285:
              v190 = 0;
              v191 = negative_reason - 3 < 2;
              v189 = -65554;
              int v82 = 3;
              break;
            }

            if (*(_BYTE *)(v182 + 256))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v183 = (os_log_s *)(id)gconnectionLogObj;
              if (!os_log_type_enabled(v183, OS_LOG_TYPE_INFO)) {
                goto LABEL_284;
              }
              nw_endpoint_t v184 = "<unknown reason>";
              if (negative_reason <= 5) {
                nw_endpoint_t v184 = off_189BB6DA0[negative_reason];
              }
              v185 = *(void *)(v278 + 32) + 256LL;
              *(_DWORD *)BOOL v299 = 136446722;
              *(void *)&v299[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
              *(_WORD *)&v299[12] = 2082;
              *(void *)&v299[14] = v185;
              *(_WORD *)&v299[22] = 2082;
              *(void *)&v299[24] = v184;
              v186 = v183;
              v187 = "%{public}s [C%{public}s] Got DNS negative reason: %{public}s";
              id v188 = 32;
              goto LABEL_283;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v183 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v183, OS_LOG_TYPE_INFO))
            {
              v193 = "<unknown reason>";
              if (negative_reason <= 5) {
                v193 = off_189BB6DA0[negative_reason];
              }
              v194 = *(_DWORD *)(*(void *)(v278 + 32) + 340LL);
              *(_DWORD *)BOOL v299 = 136446722;
              *(void *)&v299[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
              *(_WORD *)&v299[12] = 1024;
              *(_DWORD *)&v299[14] = v194;
              *(_WORD *)&v299[18] = 2082;
              *(void *)&v299[20] = v193;
              v186 = v183;
              v187 = "%{public}s [R%u] Got DNS negative reason: %{public}s";
              id v188 = 28;
LABEL_283:
              _os_log_impl(&dword_181A5C000, v186, OS_LOG_TYPE_INFO, v187, v299, v188);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v183 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v183, OS_LOG_TYPE_INFO))
            {
              v192 = "<unknown reason>";
              if (negative_reason <= 5) {
                v192 = off_189BB6DA0[negative_reason];
              }
              *(_DWORD *)BOOL v299 = 136446466;
              *(void *)&v299[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
              *(_WORD *)&v299[12] = 2082;
              *(void *)&v299[14] = v192;
              v186 = v183;
              v187 = "%{public}s Got DNS negative reason: %{public}s";
              id v188 = 22;
              goto LABEL_283;
            }
          }

      if (!v35)
      {
LABEL_32:

        goto LABEL_175;
      }

              if (v131) {
                free(v131);
              }
              LODWORD(v130) = -1;
              nw_endpoint_t v9 = v348;
              BOOL v14 = v346;
              goto LABEL_236;
            }

            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v364 = "nw_http1_connection_write_chunk_trailer";
            v194 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(__len[1]) = 16;
            type[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v194, &__len[1], type))
            {
              if (LOBYTE(__len[1]) == 17)
              {
                v195 = (os_log_s *)__nwlog_obj();
                v196 = __len[1];
                if (!os_log_type_enabled(v195, __len[1])) {
                  goto LABEL_329;
                }
                *(_DWORD *)buf = 136446210;
                v364 = "nw_http1_connection_write_chunk_trailer";
                v197 = v195;
                v198 = v196;
                char v199 = "%{public}s called with null buffer";
                goto LABEL_328;
              }

              if (type[0] == OS_LOG_TYPE_DEFAULT)
              {
                v218 = (os_log_s *)__nwlog_obj();
                v219 = __len[1];
                nw_endpoint_t v9 = v348;
                if (!os_log_type_enabled(v218, __len[1])) {
                  goto LABEL_329;
                }
                *(_DWORD *)buf = 136446210;
                v364 = "nw_http1_connection_write_chunk_trailer";
                v197 = v218;
                v198 = v219;
                char v199 = "%{public}s called with null buffer, backtrace limit exceeded";
                goto LABEL_328;
              }

              v206 = (char *)__nw_create_backtrace_string();
              uint64_t v207 = (os_log_s *)__nwlog_obj();
              v208 = __len[1];
              v209 = os_log_type_enabled(v207, __len[1]);
              if (v206)
              {
                if (v209)
                {
                  *(_DWORD *)buf = 136446466;
                  v364 = "nw_http1_connection_write_chunk_trailer";
                  id v365 = 2082;
                  *(void *)v366 = v206;
                  _os_log_impl( &dword_181A5C000,  v207,  v208,  "%{public}s called with null buffer, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v206);
                nw_endpoint_t v9 = v348;
                goto LABEL_329;
              }

              nw_endpoint_t v9 = v348;
              if (v209)
              {
                *(_DWORD *)buf = 136446210;
                v364 = "nw_http1_connection_write_chunk_trailer";
                v197 = v207;
                v198 = v208;
                char v199 = "%{public}s called with null buffer, no backtrace";
LABEL_328:
                _os_log_impl(&dword_181A5C000, v197, v198, v199, buf, 0xCu);
              }
            }

LABEL_294:
        uint64_t v2 = (uint64_t)v424;
LABEL_295:
        goto LABEL_441;
      }

      BOOL v71 = has_custom_proxy_configs;
      int v72 = *(_DWORD *)(v2 + 120);
      if (v72 == 1 && *(_DWORD *)(v2 + 116) == 2 && *(void *)(v2 + 248))
      {
        if (v5 != 1 && !*((_BYTE *)v433 + 24))
        {
          if (v24)
          {
            *(_DWORD *)(v2 + 80) = 393217;
            nw_endpoint_handler_report((void *)v2, 0LL, (_WORD *)(v2 + 80), 0LL);
          }

          goto LABEL_260;
        }

        *(_DWORD *)(v2 + 80) = 196609;
        nw_endpoint_handler_report((void *)v2, 0LL, (_WORD *)(v2 + 80), 0LL);
        BOOL v73 = (void **)(id)v2;
        if (*(_DWORD *)(v2 + 120) != 1
          || (int v74 = *(_DWORD *)(v2 + 116)) != 0
          && (v74 != 2 || (nw_endpoint_flow_get_is_leaf_handler(*(void **)(v2 + 248)) & 1) != 0)
          || (*(_BYTE *)(v2 + 268) & 1) != 0)
        {

          uint64_t v2 = (uint64_t)v424;
        }

        else
        {
          BOOL should_fallback = nw_path_should_fallback(*(void **)(v2 + 64), 0);

          uint64_t v2 = (uint64_t)v424;
          if (should_fallback)
          {
LABEL_260:
            uint64_t v200 = mach_continuous_time();
            if (v200 <= 1) {
              uint64_t v201 = 1LL;
            }
            else {
              uint64_t v201 = v200;
            }
            *(void *)(v2 + 128) = v201;
            id v202 = *(id *)(v2 + 248);
            [v202 startWithHandler:v2];

            goto LABEL_440;
          }
        }

        if (!nw_endpoint_handler_should_transform(v73[3], *(void **)(v2 + 32))
          && !nw_endpoint_proxy_handler_should_use_proxy(v73, *(void **)(v2 + 64), v71)
          && !nw_parameters_has_persistent_protocol_in_stack(*(void **)(v2 + 32))
          && nw_path_can_support_endpoint(*(void **)(v2 + 64), v73[3]))
        {
          nw_endpoint_flow_reset_is_leaf_handler(*(void **)(v2 + 248), 1);
        }

        goto LABEL_260;
      }

      if (v5 == 1 || *((_BYTE *)v433 + 24))
      {
        int v76 = *(_DWORD *)(v2 + 116);
        if (v72 == 1 && !v76)
        {
          *(_DWORD *)(v2 + 80) = 196609;
          nw_endpoint_handler_report((void *)v2, 0LL, (_WORD *)(v2 + 80), 0LL);
          if (*(_DWORD *)(v2 + 120) == 5) {
            goto LABEL_441;
          }
          os_unfair_lock_lock((os_unfair_lock_t)(v2 + 112));
          if ((*(_BYTE *)(v2 + 268) & 1) == 0
            && nw_endpoint_handler_has_persistent_application_protocols(v2)
            && !nw_path_can_support_endpoint(*(void **)(v2 + 64), *(void **)(v2 + 24)))
          {
            *(_DWORD *)(v2 + 116) = 2;
            uint64_t v207 = *(void *)(v2 + 72);
            v208 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
            *((_BYTE *)v208 + 32) = *((_BYTE *)v208 + 32) & 0xFC | (v207 == 0);
            v209 = *(void **)(v2 + 248);
            *(void *)(v2 + 248) = v208;
LABEL_396:

            v155 = v424;
            goto LABEL_397;
          }

          BOOL v77 = (void **)(id)v2;
          os_log_type_t v78 = v77;
          if (*(_DWORD *)(v2 + 120) != 1
            || (int v79 = *(_DWORD *)(v2 + 116)) != 0
            && (v79 != 2 || (nw_endpoint_flow_get_is_leaf_handler(v77[31]) & 1) != 0)
            || (*(_BYTE *)(v2 + 268) & 1) != 0)
          {
          }

          else
          {
            BOOL v80 = nw_path_should_fallback(*(void **)(v2 + 64), 0);

            if (v80)
            {
              if ((*((_BYTE *)v424 + 268) & 1) != 0 || v78[9])
              {
                v424->mode = 4;
                os_log_type_t v81 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_fallback);
LABEL_395:
                v209 = v78[31];
                v78[31] = v81;
                goto LABEL_396;
              }

              goto LABEL_393;
            }
          }

          v155 = v424;
          if (nw_endpoint_handler_should_transform(v78[3], v424->parameters))
          {
            if ((*((_BYTE *)v424 + 268) & 1) != 0 || v78[9])
            {
              v424->mode = 5;
              os_log_type_t v81 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_transform);
              goto LABEL_395;
            }
          }

          else if (nw_endpoint_proxy_handler_should_use_proxy(v78, v424->current_path, v71))
          {
            if ((*((_BYTE *)v424 + 268) & 1) != 0 || v78[9])
            {
              v424->mode = 3;
              os_log_type_t v81 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_proxy);
              goto LABEL_395;
            }
          }

          else
          {
            if (nw_path_can_support_endpoint(v424->current_path, v78[3]))
            {
              v424->mode = 2;
              v198 = v78[9];
              os_log_type_t v81 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
              char v199 = (uint64_t)v81->connected_child & 0xFC | (v198 == 0LL) | 2;
LABEL_394:
              LOBYTE(v81->connected_child) = v199;
              goto LABEL_395;
            }

            if (!nw_path_can_resolve_endpoint(v424->current_path, v78[3]))
            {
LABEL_397:
              os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 112));
              uint64_t v300 = mach_continuous_time();
              if (v300 <= 1) {
                uint64_t v301 = 1LL;
              }
              else {
                uint64_t v301 = v300;
              }
              v155->start_time = v301;
              v302 = v155->mode_handler;
              -[NWConcrete_nw_endpoint_mode_handler startWithHandler:](v302, "startWithHandler:", v155);

              goto LABEL_440;
            }

            if ((*((_BYTE *)v424 + 268) & 1) != 0 || v78[9])
            {
              v424->mode = 1;
              os_log_type_t v81 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_resolver);
              goto LABEL_395;
            }
          }

              LOBYTE(v64) = 0;
              v63 = v240;
              goto LABEL_310;
            }

    _os_log_impl(&dword_181A5C000, v199, OS_LOG_TYPE_ERROR, v198, buf, v200);
    goto LABEL_295;
  }

LABEL_393:
          v424->mode = 2;
          os_log_type_t v81 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
          char v199 = (uint64_t)v81->connected_child & 0xFC | 1;
          goto LABEL_394;
        }

        if (v76 != 2 || nw_path_changed_from_previous(*(void **)(v2 + 64)))
        {
          *(_DWORD *)(v2 + 80) = 327681;
          nw_endpoint_handler_report((void *)v2, 0LL, (_WORD *)(v2 + 80), 0LL);
          if (*(_DWORD *)(v2 + 120) == 5) {
            goto LABEL_441;
          }
        }

        if (!nw_endpoint_handler_should_reset_for_fallback((NWConcrete_nw_endpoint_handler *)v2)
          || *(void *)(v2 + 136)
          || ((uint64_t v106 = mach_continuous_time(), v106 <= 1) ? (v107 = 1LL) : (v107 = v106),
              unint64_t v108 = *(void *)(v2 + 128),
              v107 < v108))
        {
LABEL_439:
          id v328 = *(id *)(v2 + 248);
          [v328 updatePathWithHandler:v2];

          goto LABEL_440;
        }

        unint64_t v109 = nw_delta_nanos(v108, v107);
        unint64_t timeout_nanos_for_path = nw_endpoint_fallback_get_timeout_nanos_for_path(*(void **)(v2 + 64));
        BOOL v111 = timeout_nanos_for_path >= v109;
        unint64_t v112 = timeout_nanos_for_path - v109;
        if (v112 == 0 || !v111)
        {
          int v223 = nw_endpoint_handler_get_minimize_logging((void *)v2);
          char v224 = nw_endpoint_handler_get_logging_disabled((void *)v2);
          if (v223)
          {
            if ((v224 & 1) != 0) {
              goto LABEL_305;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v225 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v225, OS_LOG_TYPE_DEBUG))
            {
              v359 = nw_endpoint_handler_get_id_string(v424);
              v360 = nw_endpoint_handler_dry_run_string(v424);
              nw_endpoint_t v361 = nw_endpoint_handler_copy_endpoint(v424);
              v362 = nw_endpoint_get_logging_description(v361);
              v363 = nw_endpoint_handler_state_string(v424);
              v364 = nw_endpoint_handler_mode_string(v424);
              id v365 = nw_endpoint_handler_copy_current_path(v424);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v359;
              HIWORD(buf[2]) = 2082;
              buf[3] = v360;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v362;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v363;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v364;
              HIWORD(buf[7]) = 2114;
              buf[8] = v365;
              _os_log_impl( &dword_181A5C000,  v225,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback became enabled on path and timeout has already passed, resetting",  (uint8_t *)buf,  0x48u);
            }
          }

          else
          {
            if ((v224 & 1) != 0)
            {
LABEL_305:
              nw_endpoint_handler_reset_mode(v2, 1LL);
              goto LABEL_439;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v225 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v225, OS_LOG_TYPE_INFO))
            {
              v226 = nw_endpoint_handler_get_id_string((void *)v2);
              v227 = nw_endpoint_handler_dry_run_string((void *)v2);
              nw_endpoint_t v228 = nw_endpoint_handler_copy_endpoint((void *)v2);
              v229 = nw_endpoint_get_logging_description(v228);
              v230 = nw_endpoint_handler_state_string((void *)v2);
              v231 = nw_endpoint_handler_mode_string((void *)v2);
              id v232 = nw_endpoint_handler_copy_current_path((void *)v2);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v226;
              HIWORD(buf[2]) = 2082;
              buf[3] = v227;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v229;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v230;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v231;
              HIWORD(buf[7]) = 2114;
              buf[8] = v232;
              _os_log_impl( &dword_181A5C000,  v225,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback became enabled on path and timeout has already passed, resetting",  (uint8_t *)buf,  0x48u);
            }
          }

          uint64_t v2 = (uint64_t)v424;
          goto LABEL_305;
        }

        v113 = *(void **)(v2 + 40);
        v426[0] = MEMORY[0x1895F87A8];
        v426[1] = 3221225472LL;
        v426[2] = ___ZL31nw_endpoint_handler_path_changeP30NWConcrete_nw_endpoint_handler_block_invoke_138;
        v426[3] = &unk_189BC93A0;
        id v114 = (id)v2;
        id v427 = v114;
        *(void *)(v2 + 136) = nw_queue_context_create_source(v113, 2, 3, 0, v426, 0LL);
        LODWORD(v113) = nw_endpoint_handler_get_minimize_logging(v114);
        char v115 = nw_endpoint_handler_get_logging_disabled(v114);
        if ((_DWORD)v113)
        {
          if ((v115 & 1) != 0)
          {
LABEL_149:
            uint64_t v124 = *(void *)(v2 + 136);
            if (v124)
            {
              dispatch_time_t v125 = dispatch_time(0x8000000000000000LL, v112);
              nw_queue_set_timer_values(v124, v125, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
              nw_queue_activate_source(*(void *)(v2 + 136), v126);
LABEL_438:

              uint64_t v2 = (uint64_t)v424;
              goto LABEL_439;
            }

            __nwlog_obj();
            v272 = (void *)objc_claimAutoreleasedReturnValue();
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            v273 = (char *)_os_log_send_and_compose_impl();

            LOBYTE(v436[0]) = 16;
            char v425 = 0;
            if (__nwlog_fault(v273, v436, &v425))
            {
              if (LOBYTE(v436[0]) == 17)
              {
                __nwlog_obj();
                v274 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v275 = v436[0];
                if (os_log_type_enabled(v274, v436[0]))
                {
                  LODWORD(buf[0]) = 136446210;
                  *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
                  _os_log_impl( &dword_181A5C000,  v274,  v275,  "%{public}s nw_queue_context_create_source(timer) failed",  (uint8_t *)buf,  0xCu);
                }
              }

              else if (v425)
              {
                v297 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v274 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v298 = v436[0];
                BOOL v299 = os_log_type_enabled(v274, v436[0]);
                if (v297)
                {
                  if (v299)
                  {
                    LODWORD(buf[0]) = 136446466;
                    *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
                    WORD2(buf[1]) = 2082;
                    *(void *)((char *)&buf[1] + 6) = v297;
                    _os_log_impl( &dword_181A5C000,  v274,  v298,  "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
                  }

                  free(v297);
                  goto LABEL_436;
                }

                if (v299)
                {
                  LODWORD(buf[0]) = 136446210;
                  *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
                  _os_log_impl( &dword_181A5C000,  v274,  v298,  "%{public}s nw_queue_context_create_source(timer) failed, no backtrace",  (uint8_t *)buf,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                v274 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v318 = v436[0];
                if (os_log_type_enabled(v274, v436[0]))
                {
                  LODWORD(buf[0]) = 136446210;
                  *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
                  _os_log_impl( &dword_181A5C000,  v274,  v318,  "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
                }
              }
            }

    if (v257) {
      free(v257);
    }
    goto LABEL_543;
  }

  id v4 = v3;
  nw_context_assert_queue(v3->context);
  if ((*((_BYTE *)v4 + 109) & 0x40) != 0)
  {
    int v5 = nw_endpoint_handler_copy_connected_flow_handler(v4->parent_endpoint_handler);
  }

  else
  {
    int v5 = 0LL;
  }

  char v6 = v4;
  v381 = v6->parameters;

  if (v5)
  {
    id v7 = v5;
    nw_endpoint_t v375 = v7[4];
  }

  else
  {
    nw_endpoint_t v375 = 0LL;
  }

  uint64_t v8 = *((char *)v6 + 108);
  nw_endpoint_t v9 = v8 & 1 | (4 * ((v8 >> 5) & 1)) | (v8 >> 1) & 2;
  if ((v8 & 0x80000000) != 0) {
    v9 |= 8u;
  }
  a2->connection_report_reason = v9 & 0xFFFFFFDF | (v8 >> 2) & 0x10 | (32 * ((*((unsigned __int8 *)v4 + 109) >> 1) & 1));
  v374 = v5;
  a2->apple_host = nw_connection_stats_get_apple_host(v6);
  os_log_type_t v10 = v6;
  parameters = v6->parameters;
  if (parameters
    && (effective_process_name = (const char *)nw_parameters_get_effective_process_name(parameters)) != 0LL)
  {
    apple_app_for_string = nw_connection_stats_get_apple_app_for_string(effective_process_name);
  }

  else
  {
    if (nw_connection_stats_get_current_app(BOOL *)::onceToken != -1) {
      dispatch_once(&nw_connection_stats_get_current_app(BOOL *)::onceToken, &__block_literal_global_61_78430);
    }
    apple_app_for_string = nw_connection_stats_get_current_app(BOOL *)::current_app;
  }

  a2->apple_app = apple_app_for_string;
  BOOL v14 = (unsigned __int8 *)nw_parameters_get_effective_process_name(v6->parameters);
  if (v14)
  {
    effective_bundle_id = a2->effective_bundle_id;
    id v16 = 256LL;
    while (1)
    {
      os_log_type_t v17 = *v14;
      *effective_bundle_id = v17;
      if (!v17) {
        break;
      }
      ++effective_bundle_id;
      ++v14;
      if ((unint64_t)--v16 <= 1)
      {
        *effective_bundle_id = 0;
        break;
      }
    }
  }

  if (nw_utilities_get_self_name::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44151);
  }
  BOOL v18 = (unsigned __int8 *)nw_utilities_get_self_name::name;
  if (nw_utilities_get_self_name::name)
  {
    bundle_id = a2->bundle_id;
    BOOL v20 = 256LL;
    while (1)
    {
      os_log_type_t v21 = *v18;
      *bundle_id = v21;
      if (!v21) {
        break;
      }
      ++bundle_id;
      ++v18;
      if ((unint64_t)--v20 <= 1)
      {
        *bundle_id = 0;
        break;
      }
    }
  }

  if (nw_parameters_get_effective_bundle_id(v6->parameters)
    || (os_log_type_t v22 = v6->parameters, v23 = getpid(), nw_parameters_has_delegated_proc_pid(v22, v23))
    || nw_parameters_has_delegated_proc_uuid(v6->parameters))
  {
    *(_DWORD *)((char *)a2 + 1706) |= 0x800000u;
  }

  else
  {
    if (nw_connection_stats_get_current_app(BOOL *)::onceToken != -1) {
      dispatch_once(&nw_connection_stats_get_current_app(BOOL *)::onceToken, &__block_literal_global_61_78430);
    }
    os_log_type_t v84 = 0x800000;
    if (!nw_connection_stats_get_current_app(BOOL *)::is_daemon) {
      os_log_type_t v84 = 0;
    }
    BOOL v85 = *(_DWORD *)((char *)a2 + 1706) & 0xFF7FFFFF | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32);
    *(_DWORD *)((char *)a2 + 1706) = *(_DWORD *)((char *)a2 + 1706) & 0xFF7FFFFF | v84;
    *((_WORD *)a2 + 855) = WORD2(v85);
  }

  int v24 = v10;
  uuid_clear(a2->connection_uuid);
  *(_OWORD *)a2->connection_uuid = *(_OWORD *)v24->top_uuid;

  nw_connection_get_parent_uuid(v24, a2->parent_uuid);
  a2->seconds_since_interface_change = v24->interface_time_delta;
  v380 = v6;
  if (!v381)
  {
    size_t v52 = v375;
    if (!v375)
    {
      uint64_t v55 = 1;
      goto LABEL_40;
    }

    goto LABEL_38;
  }

  os_log_type_t v25 = v381;
  os_log_type_t v26 = v25[92];

  a2->connection_mode = v26;
  tfo = nw_parameters_get_tfo(v25);
  int v28 = (unsigned int *)((char *)a2 + 1706);
  char v29 = 4096;
  if (!tfo) {
    char v29 = 0;
  }
  uint64_t v30 = *(_DWORD *)((char *)a2 + 1706) & 0xFFFFEFFF | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32);
  *int v28 = *(_DWORD *)((char *)a2 + 1706) & 0xFFFFEFFF | v29;
  *((_WORD *)a2 + 855) = WORD2(v30);
  uint64_t v31 = v25;
  BOOL v32 = *(_DWORD *)(*((void *)v31 + 13) + 103LL) != 0;

  nw_endpoint_t v33 = *v28 & 0xFFFFDFFF | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32);
  *int v28 = *v28 & 0xFFFFDFFF | (v32 << 13);
  *((_WORD *)a2 + 855) = WORD2(v33);
  uint64_t v34 = v31;
  char v35 = *(_DWORD *)(*((void *)v31 + 13) + 103LL);

  a2->multipath_service_os_log_type_t type = v35;
  BOOL v36 = v34;
  id v37 = *(_DWORD *)(*((void *)v31 + 13) + 72LL);

  a2->traffic_class = v37;
  v38 = v36;
  uint64_t v39 = *(_WORD *)(*((void *)v31 + 13) + 100LL) & 1;

  uint64_t v40 = *v28 & 0xF7FFFFFF | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32);
  *int v28 = *v28 & 0xF7FFFFFF | (v39 << 27);
  *((_WORD *)a2 + 855) = WORD2(v40);
  __int16 v41 = v38;
  BOOL v42 = *(_WORD *)(*((void *)v31 + 13) + 100LL) & 2;

  __int16 v43 = *v28 & 0xEFFFFFFF | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32);
  *int v28 = *v28 & 0xEFFFFFFF | (v42 << 27);
  *((_WORD *)a2 + 855) = WORD2(v43);
  os_log_type_t v44 = v41;
  __int16 v45 = *((_DWORD *)v44 + 24) & 0x400;

  nw_endpoint_t v46 = (*v28 | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32)) & 0xFFFFFFFEFFFFFFFFLL;
  *int v28 = *v28;
  *((_WORD *)a2 + 855) = (v46 | (v45 << 22)) >> 32;
  BOOL v47 = v44;
  LODWORD(v45) = *(unsigned __int16 *)(*((void *)v31 + 13) + 108LL);

  os_log_type_t v48 = *v28 & 0xFFFFFFFD | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32);
  *int v28 = *v28 & 0xFFFFFFFD | (v45 >> 14) & 2;
  *((_WORD *)a2 + 855) = WORD2(v48);
  os_log_type_t v49 = v47;
  id v50 = (*(unsigned __int8 *)(*((void *)v31 + 13) + 110LL) << 16) & 0x40000;

  __int16 v51 = (*v28 | ((unint64_t)*((unsigned __int16 *)a2 + 855) << 32)) & 0xFFFFFDFFFFFFFFFFLL | (v50 << 23);
  *int v28 = *v28;
  *((_WORD *)a2 + 855) = WORD2(v51);
  size_t v52 = v375;
  if (v375)
  {
LABEL_38:
    __int16 v56 = v52;
    __int16 v54 = *(unsigned __int16 *)(v56[13] + 108LL) | (*(unsigned __int8 *)(v56[13] + 110LL) << 16);

    uint64_t v55 = 0;
    int v28 = (unsigned int *)((char *)a2 + 1706);
    goto LABEL_39;
  }

  nw_endpoint_t v53 = v49;
  __int16 v54 = *(unsigned __int16 *)(*((void *)v31 + 13) + 108LL) | (*(unsigned __int8 *)(*((void *)v31 + 13) + 110LL) << 16);

  uint64_t v55 = 1;
LABEL_39:
  *int v28 = *v28 & 0xFFFFFFFE | (v54 >> 14) & 1;
LABEL_40:
  os_log_type_t v57 = v5;
  __int16 v58 = MEMORY[0x1895F87A8];
  v377 = v57;
  if (v5 || (os_log_type_t v57 = v24->parent_endpoint_handler) != 0LL)
  {
    uint64_t v59 = v57;
    os_unfair_lock_lock(&v59->lock);
    __int16 v60 = v59->current_path;
    os_unfair_lock_unlock(&v59->lock);
    v373 = v59;

    if (v60)
    {
      uint64_t v61 = v60;
      BOOL v62 = *((_BYTE *)v61 + 473);

      if ((v62 & 0x40) != 0) {
        *(_DWORD *)((char *)a2 + 1706) |= 0x40000u;
      }
      v63 = v61;
      os_log_type_t v64 = *((char *)v61 + 473);

      if (v64 < 0) {
        *(_DWORD *)((char *)a2 + 1706) |= 0x80000u;
      }
      if (nw_path_is_expensive(v63)) {
        *(_DWORD *)((char *)a2 + 1706) |= 0x2000000u;
      }
      if (nw_path_is_constrained(v63)) {
        *(_DWORD *)((char *)a2 + 1706) |= 0x4000000u;
      }
      v65 = (unsigned __int8 *)nw_path_copy_resolver_configs(v63);
      v409[0] = v58;
      v409[1] = 3221225472LL;
      v409[2] = ___ZL49nw_connection_stats_fill_in_nw_report_on_nw_queueP24NWConcrete_nw_connectionP22nw_connection_report_s_block_invoke;
      v409[3] = &__block_descriptor_40_e35_B24__0Q8__NSObject_OS_nw_object__16l;
      v409[4] = a2;
      nw_array_apply(v65, (uint64_t)v409);
    }
  }

  else
  {
    v373 = 0LL;
  }

  v408 = 0;
  event_milliseconds = nw_connection_get_event_milliseconds(v24, 1, 2, &v408, 0LL);
  if (event_milliseconds != -1)
  {
    v67 = event_milliseconds;
    os_log_type_t v68 = 0LL;
    *(_DWORD *)((char *)a2 + 1706) |= 4u;
    while (1)
    {
      v69 = nw_connection_get_event_milliseconds(v24, 1, 3, &v408, v68);
      if (v69 == -1) {
        break;
      }
      os_log_type_t v68 = (v68 + 1);
      if (v69 >= v67)
      {
        a2->path_trigger_milliseconds = v69 - v67;
        break;
      }
    }
  }

  id v407 = 0;
  id v70 = nw_connection_get_event_milliseconds(v24, 4, 1, &v407, 0LL);
  nw_endpoint_t v382 = a2;
  if (v381)
  {
    BOOL v71 = v381;
    if (nw_context_has_proxies(*(void **)(*((void *)v71 + 13) + 136LL)))
    {
    }

    else
    {
      int v72 = *((void *)v71 + 22) == 0LL;

      if (v72) {
        goto LABEL_63;
      }
    }

    *(_DWORD *)((char *)a2 + 1706) |= 0x10u;
  }

                    if (v295) {
                      free(v295);
                    }
                    nw_endpoint_t v162 = 0;
                    if ((v158 & 1) == 0)
                    {
LABEL_223:
                      if ((v356 & 1) != 0)
                      {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                        if (v162)
                        {
LABEL_225:
                          if (output_handler != (nw_protocol *)v51)
                          {
                            v163 = output_handler->callbacks;
                            if (v163 && v163->add_input_handler)
                            {
                              if (nw_protocol_add_input_handler((uint64_t)output_handler, v51))
                              {
                                int minimize_logging = nw_endpoint_handler_get_minimize_logging(v48);
                                v165 = nw_endpoint_handler_get_logging_disabled(v48);
                                if (minimize_logging)
                                {
                                  if ((v165 & 1) != 0) {
                                    goto LABEL_206;
                                  }
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  id v166 = (os_log_s *)(id)gconnectionLogObj;
                                  if (os_log_type_enabled(v166, OS_LOG_TYPE_DEBUG))
                                  {
                                    v315 = nw_endpoint_handler_get_id_string(v48);
                                    os_log_type_t v316 = nw_endpoint_handler_dry_run_string(v48);
                                    BOOL v317 = nw_endpoint_handler_copy_endpoint(v48);
                                    os_log_type_t v318 = nw_endpoint_get_logging_description(v317);
                                    int v319 = v48;
                                    char v320 = nw_endpoint_handler_state_string(v48);
                                    v321 = nw_endpoint_handler_mode_string(v319);
                                    v322 = nw_endpoint_handler_copy_current_path(v319);
                                    *(_DWORD *)buf = 136448002;
                                    id v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                    v359 = 2082;
                                    v360 = (char *)v315;
                                    nw_endpoint_t v361 = 2082;
                                    v362 = v316;
                                    v363 = 2082;
                                    v364 = (void *)v318;
                                    id v365 = 2082;
                                    v366 = v320;
                                    v367 = 2082;
                                    nw_endpoint_t v368 = v321;
                                    v369 = 2114;
                                    v370 = v322;
                                    v371 = 2114;
                                    id v372 = v347;
                                    _os_log_impl( &dword_181A5C000,  v166,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] S uccessfully repaired protocol stack after failed %{public}@ insertion",  buf,  0x52u);
                                  }
                                }

                                else
                                {
                                  if ((v165 & 1) != 0)
                                  {
LABEL_206:
                                    started = 0LL;
LABEL_207:

                                    os_log_type_t v64 = parameters;
LABEL_208:

                                    goto LABEL_209;
                                  }

                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  id v166 = (os_log_s *)(id)gconnectionLogObj;
                                  if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
                                  {
                                    v167 = nw_endpoint_handler_get_id_string(v48);
                                    v168 = nw_endpoint_handler_dry_run_string(v48);
                                    v169 = nw_endpoint_handler_copy_endpoint(v48);
                                    v170 = nw_endpoint_get_logging_description(v169);
                                    v171 = v48;
                                    BOOL v172 = nw_endpoint_handler_state_string(v48);
                                    v173 = nw_endpoint_handler_mode_string(v171);
                                    nw_endpoint_t v174 = nw_endpoint_handler_copy_current_path(v171);
                                    *(_DWORD *)buf = 136448002;
                                    id v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                    v359 = 2082;
                                    v360 = (char *)v167;
                                    nw_endpoint_t v361 = 2082;
                                    v362 = v168;
                                    v363 = 2082;
                                    v364 = (void *)v170;
                                    id v365 = 2082;
                                    v366 = v172;
                                    v367 = 2082;
                                    nw_endpoint_t v368 = v173;
                                    v369 = 2114;
                                    v370 = v174;
                                    v371 = 2114;
                                    id v372 = v347;
                                    _os_log_impl( &dword_181A5C000,  v166,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] S uccessfully repaired protocol stack after failed %{public}@ insertion",  buf,  0x52u);
                                  }
                                }

                                goto LABEL_206;
                              }
                            }

                            else
                            {
                              __nwlog_obj();
                              uint64_t v207 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR))
                              {
                                *(_DWORD *)buf = 136446466;
                                id v358 = "nw_protocol_utilities_add_input_handler";
                                v359 = 2048;
                                v360 = (char *)output_handler;
                                _os_log_impl( &dword_181A5C000,  v207,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid",  buf,  0x16u);
                              }
                            }

LABEL_436:
            if (v273) {
              free(v273);
            }
            goto LABEL_438;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          __int16 v116 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG))
          {
            v366 = nw_endpoint_handler_get_id_string(v114);
            v367 = nw_endpoint_handler_dry_run_string(v114);
            nw_endpoint_t v368 = nw_endpoint_handler_copy_endpoint(v114);
            v369 = nw_endpoint_get_logging_description(v368);
            v370 = nw_endpoint_handler_state_string(v114);
            v371 = nw_endpoint_handler_mode_string(v114);
            id v372 = nw_endpoint_handler_copy_current_path(v114);
            LODWORD(buf[0]) = 136448002;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v366;
            HIWORD(buf[2]) = 2082;
            buf[3] = v367;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v369;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v370;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v371;
            HIWORD(buf[7]) = 2114;
            buf[8] = v372;
            LOWORD(buf[9]) = 2048;
            *(void *)((char *)&buf[9] + 2) = v112 / 0xF4240;
            _os_log_impl( &dword_181A5C000,  v116,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback became enabled o n path, setting timer for %llums before resetting",  (uint8_t *)buf,  0x52u);
          }
        }

        else
        {
          if ((v115 & 1) != 0) {
            goto LABEL_149;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          __int16 v116 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v116, OS_LOG_TYPE_INFO))
          {
            int v117 = nw_endpoint_handler_get_id_string(v114);
            __int16 v118 = nw_endpoint_handler_dry_run_string(v114);
            nw_endpoint_t v119 = nw_endpoint_handler_copy_endpoint(v114);
            __int16 v120 = nw_endpoint_get_logging_description(v119);
            v121 = nw_endpoint_handler_state_string(v114);
            __int16 v122 = nw_endpoint_handler_mode_string(v114);
            id v123 = nw_endpoint_handler_copy_current_path(v114);
            LODWORD(buf[0]) = 136448002;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v117;
            HIWORD(buf[2]) = 2082;
            buf[3] = v118;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v120;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v121;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v122;
            HIWORD(buf[7]) = 2114;
            buf[8] = v123;
            LOWORD(buf[9]) = 2048;
            *(void *)((char *)&buf[9] + 2) = v112 / 0xF4240;
            _os_log_impl( &dword_181A5C000,  v116,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback became enabled o n path, setting timer for %llums before resetting",  (uint8_t *)buf,  0x52u);
          }
        }

        uint64_t v2 = (uint64_t)v424;
        goto LABEL_149;
      }

      if (!v24)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v159 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
        {
          v160 = nw_endpoint_handler_get_id_string(v424);
          v161 = nw_endpoint_handler_dry_run_string(v424);
          nw_endpoint_t v162 = nw_endpoint_handler_copy_endpoint(v424);
          v163 = nw_endpoint_get_logging_description(v162);
          v164 = nw_endpoint_handler_state_string(v424);
          v165 = nw_endpoint_handler_mode_string(v424);
          id v166 = nw_endpoint_handler_copy_current_path(v424);
          LODWORD(buf[0]) = 136448002;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v160;
          HIWORD(buf[2]) = 2082;
          buf[3] = v161;
          LOWORD(buf[4]) = 2082;
          *(void *)((char *)&buf[4] + 2) = v163;
          WORD1(buf[5]) = 2082;
          *(void *)((char *)&buf[5] + 4) = v164;
          WORD2(buf[6]) = 2082;
          *(void *)((char *)&buf[6] + 6) = v165;
          HIWORD(buf[7]) = 2114;
          buf[8] = v166;
          LOWORD(buf[9]) = 1024;
          *(_DWORD *)((char *)&buf[9] + 2) = v5;
          _os_log_impl( &dword_181A5C000,  v159,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] endpoint handler path in unknown state: %d",  (uint8_t *)buf,  0x4Eu);
        }

        goto LABEL_518;
      }

      *(_DWORD *)(v2 + 80) = 393217;
      nw_endpoint_handler_report((void *)v2, 0LL, (_WORD *)(v2 + 80), 0LL);
      if (*(_DWORD *)(v2 + 120) == 5) {
        goto LABEL_441;
      }
      if (nw_endpoint_handler_should_start_fallback((NWConcrete_nw_endpoint_handler *)v2))
      {
        int v141 = nw_endpoint_handler_get_minimize_logging((void *)v2);
        char v142 = nw_endpoint_handler_get_logging_disabled((void *)v2);
        if (v141)
        {
          if ((v142 & 1) != 0)
          {
LABEL_184:
            os_unfair_lock_lock((os_unfair_lock_t)(v2 + 112));
            if ((*(_BYTE *)(v2 + 268) & 1) != 0 || *(void *)(v2 + 72))
            {
              *(_DWORD *)(v2 + 116) = 4;
              v151 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_fallback);
            }

            else
            {
              *(_DWORD *)(v2 + 116) = 2;
              v151 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
              LOBYTE(v151->primary_child) = (uint64_t)v151->primary_child & 0xFC | 1;
            }

            v152 = *(void **)(v2 + 248);
            *(void *)(v2 + 248) = v151;

            os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 112));
            uint64_t v153 = mach_continuous_time();
            if (v153 <= 1) {
              uint64_t v154 = 1LL;
            }
            else {
              uint64_t v154 = v153;
            }
LABEL_376:
            v424->start_time = v154;
            v290 = v424->mode_handler;
            -[NWConcrete_nw_endpoint_mode_handler startWithHandler:](v290, "startWithHandler:", v424);

            goto LABEL_440;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v143 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
          {
            v345 = nw_endpoint_handler_get_id_string(v424);
            v346 = nw_endpoint_handler_dry_run_string(v424);
            nw_endpoint_t v347 = nw_endpoint_handler_copy_endpoint(v424);
            v348 = nw_endpoint_get_logging_description(v347);
            v349 = nw_endpoint_handler_state_string(v424);
            v350 = nw_endpoint_handler_mode_string(v424);
            id v351 = nw_endpoint_handler_copy_current_path(v424);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v345;
            HIWORD(buf[2]) = 2082;
            buf[3] = v346;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v348;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v349;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v350;
            HIWORD(buf[7]) = 2114;
            buf[8] = v351;
            _os_log_impl( &dword_181A5C000,  v143,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying fallback with unsatisfied path",  (uint8_t *)buf,  0x48u);
          }
        }

        else
        {
          if ((v142 & 1) != 0) {
            goto LABEL_184;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v143 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v143, OS_LOG_TYPE_INFO))
          {
            v144 = nw_endpoint_handler_get_id_string((void *)v2);
            v145 = nw_endpoint_handler_dry_run_string((void *)v2);
            nw_endpoint_t v146 = nw_endpoint_handler_copy_endpoint((void *)v2);
            v147 = nw_endpoint_get_logging_description(v146);
            v148 = nw_endpoint_handler_state_string((void *)v2);
            v149 = nw_endpoint_handler_mode_string((void *)v2);
            id v150 = nw_endpoint_handler_copy_current_path((void *)v2);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v144;
            HIWORD(buf[2]) = 2082;
            buf[3] = v145;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v147;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v148;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v149;
            HIWORD(buf[7]) = 2114;
            buf[8] = v150;
            _os_log_impl( &dword_181A5C000,  v143,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying fallback with unsatisfied path",  (uint8_t *)buf,  0x48u);
          }
        }

        uint64_t v2 = (uint64_t)v424;
        goto LABEL_184;
      }

      int v210 = *(_DWORD *)(v2 + 116);
      if (v210)
      {
LABEL_274:
        if (v210 == 2)
        {
          if (*(_DWORD *)(v2 + 120) == 3 || !nw_endpoint_flow_get_is_leaf_handler(*(void **)(v2 + 248)))
          {
            int v261 = nw_endpoint_handler_get_minimize_logging((void *)v2);
            char v262 = nw_endpoint_handler_get_logging_disabled((void *)v2);
            if (v261)
            {
              if ((v262 & 1) != 0) {
                goto LABEL_351;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v263 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v263, OS_LOG_TYPE_DEBUG))
              {
                v380 = nw_endpoint_handler_get_id_string(v424);
                v381 = nw_endpoint_handler_dry_run_string(v424);
                nw_endpoint_t v382 = nw_endpoint_handler_copy_endpoint(v424);
                v383 = nw_endpoint_get_logging_description(v382);
                v384 = nw_endpoint_handler_state_string(v424);
                v385 = nw_endpoint_handler_mode_string(v424);
                id v386 = nw_endpoint_handler_copy_current_path(v424);
                LODWORD(buf[0]) = 136447746;
                *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
                WORD2(buf[1]) = 2082;
                *(void *)((char *)&buf[1] + 6) = v380;
                HIWORD(buf[2]) = 2082;
                buf[3] = v381;
                LOWORD(buf[4]) = 2082;
                *(void *)((char *)&buf[4] + 2) = v383;
                WORD1(buf[5]) = 2082;
                *(void *)((char *)&buf[5] + 4) = v384;
                WORD2(buf[6]) = 2082;
                *(void *)((char *)&buf[6] + 6) = v385;
                HIWORD(buf[7]) = 2114;
                buf[8] = v386;
                _os_log_impl( &dword_181A5C000,  v263,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow handling updated path",  (uint8_t *)buf,  0x48u);
              }
            }

            else
            {
              if ((v262 & 1) != 0) {
                goto LABEL_351;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v263 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v263, OS_LOG_TYPE_INFO))
              {
                v264 = nw_endpoint_handler_get_id_string((void *)v2);
                v265 = nw_endpoint_handler_dry_run_string((void *)v2);
                nw_endpoint_t v266 = nw_endpoint_handler_copy_endpoint((void *)v2);
                v267 = nw_endpoint_get_logging_description(v266);
                v268 = nw_endpoint_handler_state_string((void *)v2);
                v269 = nw_endpoint_handler_mode_string((void *)v2);
                id v270 = nw_endpoint_handler_copy_current_path((void *)v2);
                LODWORD(buf[0]) = 136447746;
                *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
                WORD2(buf[1]) = 2082;
                *(void *)((char *)&buf[1] + 6) = v264;
                HIWORD(buf[2]) = 2082;
                buf[3] = v265;
                LOWORD(buf[4]) = 2082;
                *(void *)((char *)&buf[4] + 2) = v267;
                WORD1(buf[5]) = 2082;
                *(void *)((char *)&buf[5] + 4) = v268;
                WORD2(buf[6]) = 2082;
                *(void *)((char *)&buf[6] + 6) = v269;
                HIWORD(buf[7]) = 2114;
                buf[8] = v270;
                _os_log_impl( &dword_181A5C000,  v263,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow handling updated path",  (uint8_t *)buf,  0x48u);
              }
            }

            uint64_t v2 = (uint64_t)v424;
            goto LABEL_351;
          }

          int v246 = nw_endpoint_handler_get_minimize_logging((void *)v2);
          char v247 = nw_endpoint_handler_get_logging_disabled((void *)v2);
          if (!v246)
          {
            if ((v247 & 1) != 0) {
              goto LABEL_296;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v181 = (id)gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)v181, OS_LOG_TYPE_INFO)) {
              goto LABEL_234;
            }
            goto LABEL_233;
          }

          if ((v247 & 1) != 0) {
            goto LABEL_296;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v181 = (id)gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)v181, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_234;
          }
LABEL_466:
          v338 = nw_endpoint_handler_get_id_string(v424);
          v339 = nw_endpoint_handler_dry_run_string(v424);
          nw_endpoint_t v340 = nw_endpoint_handler_copy_endpoint(v424);
          v341 = nw_endpoint_get_logging_description(v340);
          v342 = nw_endpoint_handler_state_string(v424);
          v343 = nw_endpoint_handler_mode_string(v424);
          id v344 = nw_endpoint_handler_copy_current_path(v424);
          LODWORD(buf[0]) = 136447746;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v338;
          HIWORD(buf[2]) = 2082;
          buf[3] = v339;
          LOWORD(buf[4]) = 2082;
          *(void *)((char *)&buf[4] + 2) = v341;
          WORD1(buf[5]) = 2082;
          *(void *)((char *)&buf[5] + 4) = v342;
          WORD2(buf[6]) = 2082;
          *(void *)((char *)&buf[6] + 6) = v343;
          HIWORD(buf[7]) = 2114;
          buf[8] = v344;
          _os_log_impl( &dword_181A5C000,  (os_log_t)v181,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow is no longer satisfied",  (uint8_t *)buf,  0x48u);

          goto LABEL_234;
        }

        if (v210 == 3)
        {
          int v211 = nw_endpoint_handler_get_minimize_logging((void *)v2);
          char v212 = nw_endpoint_handler_get_logging_disabled((void *)v2);
          if (v211)
          {
            if ((v212 & 1) != 0) {
              goto LABEL_351;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v213 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v213, OS_LOG_TYPE_DEBUG))
            {
              v373 = nw_endpoint_handler_get_id_string(v424);
              v374 = nw_endpoint_handler_dry_run_string(v424);
              nw_endpoint_t v375 = nw_endpoint_handler_copy_endpoint(v424);
              v376 = nw_endpoint_get_logging_description(v375);
              v377 = nw_endpoint_handler_state_string(v424);
              v378 = nw_endpoint_handler_mode_string(v424);
              id v379 = nw_endpoint_handler_copy_current_path(v424);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v373;
              HIWORD(buf[2]) = 2082;
              buf[3] = v374;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v376;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v377;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v378;
              HIWORD(buf[7]) = 2114;
              buf[8] = v379;
              _os_log_impl( &dword_181A5C000,  v213,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] handling unsatisfied up dated path for proxy",  (uint8_t *)buf,  0x48u);
            }
          }

          else
          {
            if ((v212 & 1) != 0) {
              goto LABEL_351;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v213 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v213, OS_LOG_TYPE_INFO))
            {
              v214 = nw_endpoint_handler_get_id_string((void *)v2);
              v215 = nw_endpoint_handler_dry_run_string((void *)v2);
              nw_endpoint_t v216 = nw_endpoint_handler_copy_endpoint((void *)v2);
              v217 = nw_endpoint_get_logging_description(v216);
              v218 = nw_endpoint_handler_state_string((void *)v2);
              v219 = nw_endpoint_handler_mode_string((void *)v2);
              id v220 = nw_endpoint_handler_copy_current_path((void *)v2);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v214;
              HIWORD(buf[2]) = 2082;
              buf[3] = v215;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v217;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v218;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v219;
              HIWORD(buf[7]) = 2114;
              buf[8] = v220;
              _os_log_impl( &dword_181A5C000,  v213,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] handling unsatisfied up dated path for proxy",  (uint8_t *)buf,  0x48u);
            }
          }

          uint64_t v2 = (uint64_t)v424;
          goto LABEL_351;
        }

        if (nw_endpoint_handler_should_perform_CrazyIvan46((NWConcrete_nw_endpoint_handler *)v2)
          || nw_endpoint_handler_should_do_local_only_resolution((NWConcrete_nw_endpoint_handler *)v2))
        {
          int v248 = nw_endpoint_handler_get_minimize_logging((void *)v2);
          char v249 = nw_endpoint_handler_get_logging_disabled((void *)v2);
          if (v248)
          {
            if ((v249 & 1) != 0)
            {
LABEL_338:
              os_unfair_lock_lock((os_unfair_lock_t)(v2 + 112));
              if ((*(_BYTE *)(v2 + 268) & 1) != 0 || *(void *)(v2 + 72))
              {
                *(_DWORD *)(v2 + 116) = 1;
                v258 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_resolver);
              }

              else
              {
                *(_DWORD *)(v2 + 116) = 2;
                v258 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
                LOBYTE(v258->connected_child) = (uint64_t)v258->connected_child & 0xFC | 1;
              }

              v259 = *(void **)(v2 + 248);
              *(void *)(v2 + 248) = v258;

              os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 112));
              uint64_t v260 = mach_continuous_time();
              if (v260 <= 1) {
                uint64_t v154 = 1LL;
              }
              else {
                uint64_t v154 = v260;
              }
              goto LABEL_376;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v250 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v250, OS_LOG_TYPE_DEBUG))
            {
              v387 = nw_endpoint_handler_get_id_string(v424);
              v388 = nw_endpoint_handler_dry_run_string(v424);
              nw_endpoint_t v389 = nw_endpoint_handler_copy_endpoint(v424);
              v390 = nw_endpoint_get_logging_description(v389);
              v391 = nw_endpoint_handler_state_string(v424);
              v392 = nw_endpoint_handler_mode_string(v424);
              id v393 = nw_endpoint_handler_copy_current_path(v424);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v387;
              HIWORD(buf[2]) = 2082;
              buf[3] = v388;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v390;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v391;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v392;
              HIWORD(buf[7]) = 2114;
              buf[8] = v393;
              _os_log_impl( &dword_181A5C000,  v250,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying resolution with unsatisfied path",  (uint8_t *)buf,  0x48u);
            }
          }

          else
          {
            if ((v249 & 1) != 0) {
              goto LABEL_338;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v250 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v250, OS_LOG_TYPE_INFO))
            {
              v251 = nw_endpoint_handler_get_id_string((void *)v2);
              v252 = nw_endpoint_handler_dry_run_string((void *)v2);
              nw_endpoint_t v253 = nw_endpoint_handler_copy_endpoint((void *)v2);
              v254 = nw_endpoint_get_logging_description(v253);
              v255 = nw_endpoint_handler_state_string((void *)v2);
              v256 = nw_endpoint_handler_mode_string((void *)v2);
              id v257 = nw_endpoint_handler_copy_current_path((void *)v2);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v251;
              HIWORD(buf[2]) = 2082;
              buf[3] = v252;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v254;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v255;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v256;
              HIWORD(buf[7]) = 2114;
              buf[8] = v257;
              _os_log_impl( &dword_181A5C000,  v250,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying resolution with unsatisfied path",  (uint8_t *)buf,  0x48u);
            }
          }

          uint64_t v2 = (uint64_t)v424;
          goto LABEL_338;
        }

        if (!*(_DWORD *)(v2 + 116))
        {
          int v319 = nw_endpoint_handler_get_minimize_logging((void *)v2);
          char v320 = nw_endpoint_handler_get_logging_disabled((void *)v2);
          if (v319)
          {
            uint64_t v2 = (uint64_t)v424;
            if ((v320 & 1) != 0) {
              goto LABEL_296;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v181 = (id)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)v181, OS_LOG_TYPE_DEBUG))
            {
              v408 = nw_endpoint_handler_get_id_string(v424);
              v409 = nw_endpoint_handler_dry_run_string(v424);
              nw_endpoint_t v410 = nw_endpoint_handler_copy_endpoint(v424);
              v411 = nw_endpoint_get_logging_description(v410);
              v412 = nw_endpoint_handler_state_string(v424);
              v413 = nw_endpoint_handler_mode_string(v424);
              id v414 = nw_endpoint_handler_copy_current_path(v424);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v408;
              HIWORD(buf[2]) = 2082;
              buf[3] = v409;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v411;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v412;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v413;
              HIWORD(buf[7]) = 2114;
              buf[8] = v414;
              _os_log_impl( &dword_181A5C000,  (os_log_t)v181,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] triggering cell",  (uint8_t *)buf,  0x48u);
            }
          }

          else
          {
            uint64_t v2 = (uint64_t)v424;
            if ((v320 & 1) != 0) {
              goto LABEL_296;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v181 = (id)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)v181, OS_LOG_TYPE_INFO))
            {
              v321 = nw_endpoint_handler_get_id_string(v424);
              v322 = nw_endpoint_handler_dry_run_string(v424);
              nw_endpoint_t v323 = nw_endpoint_handler_copy_endpoint(v424);
              v324 = nw_endpoint_get_logging_description(v323);
              v325 = nw_endpoint_handler_state_string(v424);
              v326 = nw_endpoint_handler_mode_string(v424);
              id v327 = nw_endpoint_handler_copy_current_path(v424);
              LODWORD(buf[0]) = 136447746;
              *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v321;
              HIWORD(buf[2]) = 2082;
              buf[3] = v322;
              LOWORD(buf[4]) = 2082;
              *(void *)((char *)&buf[4] + 2) = v324;
              WORD1(buf[5]) = 2082;
              *(void *)((char *)&buf[5] + 4) = v325;
              WORD2(buf[6]) = 2082;
              *(void *)((char *)&buf[6] + 6) = v326;
              HIWORD(buf[7]) = 2114;
              buf[8] = v327;
              _os_log_impl( &dword_181A5C000,  (os_log_t)v181,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] triggering cell",  (uint8_t *)buf,  0x48u);
            }
          }

          goto LABEL_234;
        }

        int v303 = nw_endpoint_handler_get_minimize_logging((void *)v2);
        char v304 = nw_endpoint_handler_get_logging_disabled((void *)v2);
        if (v303)
        {
          if ((v304 & 1) != 0) {
            goto LABEL_441;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v159 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v159, OS_LOG_TYPE_DEBUG))
          {
            v401 = nw_endpoint_handler_get_id_string(v424);
            v402 = nw_endpoint_handler_dry_run_string(v424);
            nw_endpoint_t v403 = nw_endpoint_handler_copy_endpoint(v424);
            v404 = nw_endpoint_get_logging_description(v403);
            v405 = nw_endpoint_handler_state_string(v424);
            v406 = nw_endpoint_handler_mode_string(v424);
            id v407 = nw_endpoint_handler_copy_current_path(v424);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v401;
            HIWORD(buf[2]) = 2082;
            buf[3] = v402;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v404;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v405;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v406;
            HIWORD(buf[7]) = 2114;
            buf[8] = v407;
            _os_log_impl( &dword_181A5C000,  v159,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring unsatisfied path",  (uint8_t *)buf,  0x48u);
          }
        }

        else
        {
          if ((v304 & 1) != 0) {
            goto LABEL_441;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v159 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v159, OS_LOG_TYPE_INFO))
          {
            v305 = nw_endpoint_handler_get_id_string(v424);
            v306 = nw_endpoint_handler_dry_run_string(v424);
            nw_endpoint_t v307 = nw_endpoint_handler_copy_endpoint(v424);
            v308 = nw_endpoint_get_logging_description(v307);
            v309 = nw_endpoint_handler_state_string(v424);
            v310 = nw_endpoint_handler_mode_string(v424);
            id v311 = nw_endpoint_handler_copy_current_path(v424);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v305;
            HIWORD(buf[2]) = 2082;
            buf[3] = v306;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v308;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v309;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v310;
            HIWORD(buf[7]) = 2114;
            buf[8] = v311;
            _os_log_impl( &dword_181A5C000,  v159,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring unsatisfied path",  (uint8_t *)buf,  0x48u);
          }
        }

LABEL_518:
        goto LABEL_440;
      }

      if (nw_endpoint_handler_should_transform(*(void **)(v2 + 24), *(void **)(v2 + 32)))
      {
        int v233 = nw_endpoint_handler_get_minimize_logging((void *)v2);
        char v234 = nw_endpoint_handler_get_logging_disabled((void *)v2);
        if (v233)
        {
          if ((v234 & 1) != 0)
          {
LABEL_314:
            os_unfair_lock_lock((os_unfair_lock_t)(v2 + 112));
            if ((*(_BYTE *)(v2 + 268) & 1) != 0 || *(void *)(v2 + 72))
            {
              *(_DWORD *)(v2 + 116) = 5;
              v243 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_transform);
            }

            else
            {
              *(_DWORD *)(v2 + 116) = 2;
              v243 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
              LOBYTE(v243->blocked_protocols) = (uint64_t)v243->blocked_protocols & 0xFC | 1;
            }

            v244 = *(void **)(v2 + 248);
            *(void *)(v2 + 248) = v243;

            os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 112));
            uint64_t v245 = mach_continuous_time();
            if (v245 <= 1) {
              uint64_t v154 = 1LL;
            }
            else {
              uint64_t v154 = v245;
            }
            goto LABEL_376;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v235 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v235, OS_LOG_TYPE_DEBUG))
          {
            v394 = nw_endpoint_handler_get_id_string(v424);
            v395 = nw_endpoint_handler_dry_run_string(v424);
            nw_endpoint_t v396 = nw_endpoint_handler_copy_endpoint(v424);
            v397 = nw_endpoint_get_logging_description(v396);
            v398 = nw_endpoint_handler_state_string(v424);
            v399 = nw_endpoint_handler_mode_string(v424);
            id v400 = nw_endpoint_handler_copy_current_path(v424);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v394;
            HIWORD(buf[2]) = 2082;
            buf[3] = v395;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v397;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v398;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v399;
            HIWORD(buf[7]) = 2114;
            buf[8] = v400;
            _os_log_impl( &dword_181A5C000,  v235,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying transform with unsatisfied path",  (uint8_t *)buf,  0x48u);
          }
        }

        else
        {
          if ((v234 & 1) != 0) {
            goto LABEL_314;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v235 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v235, OS_LOG_TYPE_INFO))
          {
            v236 = nw_endpoint_handler_get_id_string((void *)v2);
            v237 = nw_endpoint_handler_dry_run_string((void *)v2);
            nw_endpoint_t v238 = nw_endpoint_handler_copy_endpoint((void *)v2);
            v239 = nw_endpoint_get_logging_description(v238);
            v240 = nw_endpoint_handler_state_string((void *)v2);
            v241 = nw_endpoint_handler_mode_string((void *)v2);
            id v242 = nw_endpoint_handler_copy_current_path((void *)v2);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v236;
            HIWORD(buf[2]) = 2082;
            buf[3] = v237;
            LOWORD(buf[4]) = 2082;
            *(void *)((char *)&buf[4] + 2) = v239;
            WORD1(buf[5]) = 2082;
            *(void *)((char *)&buf[5] + 4) = v240;
            WORD2(buf[6]) = 2082;
            *(void *)((char *)&buf[6] + 6) = v241;
            HIWORD(buf[7]) = 2114;
            buf[8] = v242;
            _os_log_impl( &dword_181A5C000,  v235,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying transform with unsatisfied path",  (uint8_t *)buf,  0x48u);
          }
        }

        uint64_t v2 = (uint64_t)v424;
        goto LABEL_314;
      }

      int v210 = *(_DWORD *)(v2 + 116);
      if (v210) {
        goto LABEL_274;
      }
      if (!v71 && !nw_path_has_proxy_settings(*(void **)(v2 + 64))
        || (nw_parameters_get_proxy_applied(*(void **)(v2 + 32)) & 1) != 0
        || (nw_parameters_get_no_proxy(*(void **)(v2 + 32)) & 1) != 0
        || !nw_endpoint_proxy_unsatisfied_handler_should_use_proxy(*(void **)(v2 + 64)))
      {
        int v210 = *(_DWORD *)(v2 + 116);
        goto LABEL_274;
      }

      int v276 = nw_endpoint_handler_get_minimize_logging((void *)v2);
      char v277 = nw_endpoint_handler_get_logging_disabled((void *)v2);
      if (v276)
      {
        if ((v277 & 1) != 0)
        {
LABEL_370:
          os_unfair_lock_lock(&v424->lock);
          if ((*((_BYTE *)v424 + 268) & 1) != 0 || v424->parent_handler)
          {
            v286 = v424;
            v424->mode = 3;
            v287 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_proxy);
          }

          else
          {
            v286 = v424;
            v424->mode = 2;
            v287 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
            LOBYTE(v287->connected_child) = (uint64_t)v287->connected_child & 0xFC | 1;
          }

          mode_handler = v286->mode_handler;
          v286->mode_handler = (NWConcrete_nw_endpoint_mode_handler *)v287;

          os_unfair_lock_unlock(&v424->lock);
          uint64_t v289 = mach_continuous_time();
          if (v289 <= 1) {
            uint64_t v154 = 1LL;
          }
          else {
            uint64_t v154 = v289;
          }
          goto LABEL_376;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v278 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v278, OS_LOG_TYPE_DEBUG))
        {
          v415 = nw_endpoint_handler_get_id_string(v424);
          v416 = nw_endpoint_handler_dry_run_string(v424);
          nw_endpoint_t v417 = nw_endpoint_handler_copy_endpoint(v424);
          v418 = nw_endpoint_get_logging_description(v417);
          v419 = nw_endpoint_handler_state_string(v424);
          v420 = nw_endpoint_handler_mode_string(v424);
          id v421 = nw_endpoint_handler_copy_current_path(v424);
          LODWORD(buf[0]) = 136447746;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v415;
          HIWORD(buf[2]) = 2082;
          buf[3] = v416;
          LOWORD(buf[4]) = 2082;
          *(void *)((char *)&buf[4] + 2) = v418;
          WORD1(buf[5]) = 2082;
          *(void *)((char *)&buf[5] + 4) = v419;
          WORD2(buf[6]) = 2082;
          *(void *)((char *)&buf[6] + 6) = v420;
          HIWORD(buf[7]) = 2114;
          buf[8] = v421;
          _os_log_impl( &dword_181A5C000,  v278,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying proxy with unsatisfied path",  (uint8_t *)buf,  0x48u);
        }
      }

      else
      {
        if ((v277 & 1) != 0) {
          goto LABEL_370;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v278 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v278, OS_LOG_TYPE_INFO))
        {
          v279 = nw_endpoint_handler_get_id_string(v424);
          v280 = nw_endpoint_handler_dry_run_string(v424);
          nw_endpoint_t v281 = nw_endpoint_handler_copy_endpoint(v424);
          v282 = nw_endpoint_get_logging_description(v281);
          v283 = nw_endpoint_handler_state_string(v424);
          v284 = nw_endpoint_handler_mode_string(v424);
          id v285 = nw_endpoint_handler_copy_current_path(v424);
          LODWORD(buf[0]) = 136447746;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v279;
          HIWORD(buf[2]) = 2082;
          buf[3] = v280;
          LOWORD(buf[4]) = 2082;
          *(void *)((char *)&buf[4] + 2) = v282;
          WORD1(buf[5]) = 2082;
          *(void *)((char *)&buf[5] + 4) = v283;
          WORD2(buf[6]) = 2082;
          *(void *)((char *)&buf[6] + 6) = v284;
          HIWORD(buf[7]) = 2114;
          buf[8] = v285;
          _os_log_impl( &dword_181A5C000,  v278,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] trying proxy with unsatisfied path",  (uint8_t *)buf,  0x48u);
        }
      }

      goto LABEL_370;
    }

    uint64_t v432 = 0LL;
    v433 = &v432;
    uint64_t v434 = 0x2020000000LL;
    char v435 = 0;
    if (v5 != 2)
    {
      int v24 = 0;
      goto LABEL_58;
    }

    if (!nw_path_may_span_multiple_interfaces(*(void **)(v2 + 64)))
    {
      int v5 = 2;
      int v24 = 1;
      goto LABEL_58;
    }

    v436[0] = 0LL;
    v436[1] = v436;
    v436[2] = 0x2020000000LL;
    LOBYTE(v437) = 0;
    os_log_type_t v25 = *(nw_path **)(v2 + 64);
    enumerate_block[0] = MEMORY[0x1895F87A8];
    enumerate_block[1] = 3221225472LL;
    enumerate_block[2] = ___ZL31nw_endpoint_handler_path_changeP30NWConcrete_nw_endpoint_handler_block_invoke;
    enumerate_block[3] = &unk_189BBBB70;
    os_log_type_t v26 = (void **)(id)v2;
    v429 = v26;
    v430 = v436;
    v431 = &v432;
    nw_path_enumerate_interfaces(v25, enumerate_block);
    if (*((_BYTE *)v433 + 24) || *(_BYTE *)(v436[1] + 24LL) || !nw_parameters_get_use_awdl(v26[4]))
    {
LABEL_47:

      _Block_object_dispose(v436, 8);
      int v5 = 2;
      int v24 = 1;
      uint64_t v2 = (uint64_t)v424;
      goto LABEL_58;
    }

    os_log_type_t v27 = nw_interface_create_with_name("awdl0");
    if (!v27 || (nw_path_interface_prohibited_by_parameters(v424->current_path, v27) & 1) != 0)
    {
LABEL_46:

      goto LABEL_47;
    }

    int v28 = nw_endpoint_handler_get_minimize_logging(v26);
    char v29 = nw_endpoint_handler_get_logging_disabled(v26);
    if (v28)
    {
      if ((v29 & 1) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v30 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        v352 = nw_endpoint_handler_get_id_string(v26);
        v353 = nw_endpoint_handler_dry_run_string(v26);
        nw_endpoint_t v354 = nw_endpoint_handler_copy_endpoint(v26);
        v355 = nw_endpoint_get_logging_description(v354);
        v356 = nw_endpoint_handler_state_string(v26);
        v357 = nw_endpoint_handler_mode_string(v26);
        id v358 = nw_endpoint_handler_copy_current_path(v26);
        LODWORD(buf[0]) = 136447746;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v352;
        HIWORD(buf[2]) = 2082;
        buf[3] = v353;
        LOWORD(buf[4]) = 2082;
        *(void *)((char *)&buf[4] + 2) = v355;
        WORD1(buf[5]) = 2082;
        *(void *)((char *)&buf[5] + 4) = v356;
        WORD2(buf[6]) = 2082;
        *(void *)((char *)&buf[6] + 6) = v357;
        HIWORD(buf[7]) = 2114;
        buf[8] = v358;
        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] overriding unsatisfied, awdl eligible",  (uint8_t *)buf,  0x48u);
      }
    }

    else
    {
      if ((v29 & 1) != 0)
      {
LABEL_45:
        *((_BYTE *)v433 + 24) = 1;
        goto LABEL_46;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v30 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        uint64_t v31 = nw_endpoint_handler_get_id_string(v26);
        BOOL v32 = nw_endpoint_handler_dry_run_string(v26);
        nw_endpoint_t v33 = nw_endpoint_handler_copy_endpoint(v26);
        uint64_t v34 = nw_endpoint_get_logging_description(v33);
        char v35 = nw_endpoint_handler_state_string(v26);
        BOOL v36 = nw_endpoint_handler_mode_string(v26);
        id v37 = nw_endpoint_handler_copy_current_path(v26);
        LODWORD(buf[0]) = 136447746;
        *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v31;
        HIWORD(buf[2]) = 2082;
        buf[3] = v32;
        LOWORD(buf[4]) = 2082;
        *(void *)((char *)&buf[4] + 2) = v34;
        WORD1(buf[5]) = 2082;
        *(void *)((char *)&buf[5] + 4) = v35;
        WORD2(buf[6]) = 2082;
        *(void *)((char *)&buf[6] + 6) = v36;
        HIWORD(buf[7]) = 2114;
        buf[8] = v37;
        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] overriding unsatisfied, awdl eligible",  (uint8_t *)buf,  0x48u);
      }
    }

    goto LABEL_45;
  }

  v38 = (char *)(id)v2;
  uint64_t v39 = v38;
  uint64_t v40 = (void *)*((void *)v38 + 4);
  if (v40)
  {
    __int16 v41 = v40;
    BOOL v42 = (v41[12] & 0x4000000000LL) == 0;

    if (!v42)
    {
      uint64_t v2 = (uint64_t)v424;
      if ((nw_endpoint_handler_get_logging_disabled(v39) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v43 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v44 = nw_endpoint_handler_get_id_string(v39);
          __int16 v45 = nw_endpoint_handler_dry_run_string(v39);
          nw_endpoint_t v46 = nw_endpoint_handler_copy_endpoint(v39);
          BOOL v47 = nw_endpoint_get_logging_description(v46);
          os_log_type_t v48 = nw_endpoint_handler_state_string(v39);
          os_log_type_t v49 = nw_endpoint_handler_mode_string(v39);
          id v50 = nw_endpoint_handler_copy_current_path(v39);
          LODWORD(buf[0]) = 136447746;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v44;
          HIWORD(buf[2]) = 2082;
          buf[3] = v45;
          LOWORD(buf[4]) = 2082;
          *(void *)((char *)&buf[4] + 2) = v47;
          WORD1(buf[5]) = 2082;
          *(void *)((char *)&buf[5] + 4) = v48;
          WORD2(buf[6]) = 2082;
          *(void *)((char *)&buf[6] + 6) = v49;
          HIWORD(buf[7]) = 2114;
          buf[8] = v50;
          _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] triggered agents have not yet updated",  (uint8_t *)buf,  0x48u);
        }

            if (*(void *)(v106 + 248))
            {
              if (!*(void *)(v110 + 488))
              {
                *(void *)(v106 + 256) = v110;
                *(void *)(v110 + 488) = v106;
                nw_protocol_set_output_handler(v106, *(void *)(v110 + 32));
                nw_protocol_set_input_handler(v110, *(void *)(v106 + 48));
                *(_OWORD *)uint64_t v106 = *(_OWORD *)v110;
                v315 = v937[5];
                BOOL v317 = v937[2];
                os_log_type_t v316 = v937[3];
                *(_OWORD *)(v110 + 128) = v937[4];
                *(_OWORD *)(v110 + 144) = v315;
                *(_OWORD *)(v110 + 96) = v317;
                *(_OWORD *)(v110 + 112) = v316;
                os_log_type_t v318 = v937[1];
                *(_OWORD *)(v110 + 64) = *v937;
                *(_OWORD *)(v110 + 80) = v318;
                nw_http_transaction_metadata_set_connection_metadata(*(void **)(v106 + 352), *(void **)(v110 + 768));
                *v115 &= 0xFFD7u;
                *(_DWORD *)(v110 + 864) = 1;
                if ((*(_BYTE *)(v110 + 158) & 1) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  int v319 = (os_log_s *)gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    char v320 = *(void *)(v110 + 488);
                    v321 = *(_DWORD *)(*(void *)(v110 + 480) + 372LL);
                    v322 = *(_DWORD *)(v110 + 860);
                    if (v320) {
                      LODWORD(v320) = *(_DWORD *)(v320 + 424);
                    }
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&void buf[14] = v110 + 74;
                    *(_WORD *)&buf[22] = 2080;
                    v961 = (uint64_t)" ";
                    *(_WORD *)v962 = 1024;
                    *(_DWORD *)&v962[2] = v321;
                    *(_WORD *)&v962[6] = 1024;
                    *(_DWORD *)&v962[8] = v322;
                    *(_WORD *)&v962[12] = 1024;
                    *(_DWORD *)&v962[14] = v320;
                    _os_log_impl( &dword_181A5C000,  v319,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: reading",  buf,  0x32u);
                  }
                }

                if ((*(_BYTE *)(v106 + 158) & 1) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  nw_endpoint_t v323 = (os_log_s *)gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                  {
                    v324 = *(void *)(v106 + 256);
                    v325 = *(_DWORD *)(*(void *)(v106 + 248) + 372LL);
                    if (v324) {
                      LODWORD(v324) = *(_DWORD *)(v324 + 860);
                    }
                    v326 = *(_DWORD *)(v106 + 424);
                    *(_DWORD *)buf = 136448002;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&void buf[14] = v106 + 74;
                    *(_WORD *)&buf[22] = 2080;
                    v961 = (uint64_t)" ";
                    *(_WORD *)v962 = 1024;
                    *(_DWORD *)&v962[2] = v325;
                    *(_WORD *)&v962[6] = 1024;
                    *(_DWORD *)&v962[8] = v324;
                    *(_WORD *)&v962[12] = 1024;
                    *(_DWORD *)&v962[14] = v326;
                    *(_WORD *)&v962[18] = 2048;
                    *(void *)&v962[20] = v106;
                    *(_WORD *)&v962[28] = 2048;
                    *(void *)&v962[30] = v110;
                    _os_log_impl( &dword_181A5C000,  v323,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:c%u:s%u> stream (%p) now using connection %p",  buf,  0x46u);
                  }
                }

                goto LABEL_546;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v309 = *(void *)(v110 + 488);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&void buf[14] = v110;
              *(_WORD *)&buf[22] = 2048;
              v961 = v309;
              v310 = (char *)_os_log_send_and_compose_impl();
              v963[0] = 16;
              LOBYTE(aBlock) = 0;
              if (__nwlog_fault(v310, v963, &aBlock))
              {
                if (v963[0] == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v311 = (os_log_s *)gLogObj;
                  v312 = v963[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v963[0])) {
                    goto LABEL_544;
                  }
                  os_log_type_t v313 = *(void *)(v110 + 488);
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&void buf[14] = v110;
                  *(_WORD *)&buf[22] = 2048;
                  v961 = v313;
                  BOOL v314 = "%{public}s Connection %p already has a stream (%p)";
                  goto LABEL_543;
                }

                if (!(_BYTE)aBlock)
                {
                  id v311 = (os_log_s *)__nwlog_obj();
                  v312 = v963[0];
                  if (!os_log_type_enabled(v311, (os_log_type_t)v963[0])) {
                    goto LABEL_544;
                  }
                  os_log_type_t v330 = *(void *)(v110 + 488);
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&void buf[14] = v110;
                  *(_WORD *)&buf[22] = 2048;
                  v961 = v330;
                  BOOL v314 = "%{public}s Connection %p already has a stream (%p), backtrace limit exceeded";
                  goto LABEL_543;
                }

                id v327 = (char *)__nw_create_backtrace_string();
                id v311 = (os_log_s *)__nwlog_obj();
                v312 = v963[0];
                id v328 = os_log_type_enabled(v311, (os_log_type_t)v963[0]);
                if (v327)
                {
                  if (v328)
                  {
                    os_log_type_t v329 = *(void *)(v110 + 488);
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                    *(_WORD *)&buf[12] = 2048;
                    *(void *)&void buf[14] = v110;
                    *(_WORD *)&buf[22] = 2048;
                    v961 = v329;
                    *(_WORD *)v962 = 2082;
                    *(void *)&v962[2] = v327;
                    _os_log_impl( &dword_181A5C000,  v311,  v312,  "%{public}s Connection %p already has a stream (%p), dumping backtrace:%{public}s",  buf,  0x2Au);
                  }

                  free(v327);
                  goto LABEL_544;
                }

                if (v328)
                {
                  v331 = *(void *)(v110 + 488);
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&void buf[14] = v110;
                  *(_WORD *)&buf[22] = 2048;
                  v961 = v331;
                  BOOL v314 = "%{public}s Connection %p already has a stream (%p), no backtrace";
LABEL_543:
                  _os_log_impl(&dword_181A5C000, v311, v312, v314, buf, 0x20u);
                }
              }

LABEL_241:
LABEL_242:
        uint64_t v2 = (uint64_t)v424;
        goto LABEL_442;
      }

      goto LABEL_442;
    }
  }

  else
  {
  }

  uint64_t v2 = (uint64_t)v424;
  if ((*((_BYTE *)v424 + 268) & 0x20) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    __int16 v43 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      if ((*((_BYTE *)v424 + 268) & 1) != 0) {
        uint64_t v127 = "dry-run ";
      }
      else {
        uint64_t v127 = "";
      }
      nw_endpoint_t v128 = nw_endpoint_handler_copy_endpoint(v39);
      v129 = nw_endpoint_get_logging_description(v128);
      uint64_t v130 = v424->state;
      v131 = v127;
      else {
        v132 = off_189BBBBF0[v130];
      }
      v133 = v39;
      v134 = (os_unfair_lock_s *)v133;
      v135 = "path";
      switch(*((_DWORD *)v133 + 29))
      {
        case 0:
          break;
        case 1:
          v135 = "resolver";
          break;
        case 2:
          v135 = nw_endpoint_flow_mode_string(*((void **)v133 + 31));
          break;
        case 3:
          v135 = "proxy";
          break;
        case 4:
          v135 = "fallback";
          break;
        case 5:
          v135 = "transform";
          break;
        default:
          v135 = "unknown-mode";
          break;
      }

      v189 = v134 + 28;
      v190 = v134;
      os_unfair_lock_lock(v134 + 28);
      v191 = v424->current_path;
      os_unfair_lock_unlock(v189);

      LODWORD(buf[0]) = 136447746;
      *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v39 + 168;
      HIWORD(buf[2]) = 2082;
      buf[3] = v131;
      LOWORD(buf[4]) = 2082;
      *(void *)((char *)&buf[4] + 2) = v129;
      WORD1(buf[5]) = 2082;
      *(void *)((char *)&buf[5] + 4) = v132;
      WORD2(buf[6]) = 2082;
      *(void *)((char *)&buf[6] + 6) = v135;
      HIWORD(buf[7]) = 2114;
      buf[8] = v191;
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] triggered agents have not yet updated",  (uint8_t *)buf,  0x48u);
    }

    goto LABEL_241;
  }

          uint64_t v124 = *(void *)(a1 + 48);
          if (v124)
          {
            result = 0LL;
            ++*(void *)(v124 + 8);
            return result;
          }

          return 0LL;
        }

        if (v16 == 20)
        {
          BOOL v75 = vaddlvq_u32(*v15) + v15[1].u32[0];
        }

        else
        {
          if (v16 - 4 > 0x1B)
          {
            uint64_t v127 = ((v16 - 4) >> 2) + 1;
            nw_endpoint_t v128 = 4 * (v127 & 0x7FFFFFF8);
            v129 = v15 + 1;
            uint64_t v130 = 0uLL;
            v131 = v127 & 0x7FFFFFF8;
            v132 = 0uLL;
            v133 = 0uLL;
            v134 = 0uLL;
            do
            {
              v135 = v129[-1];
              v132 = (int64x2_t)vaddw_high_u32((uint64x2_t)v132, v135);
              uint64_t v130 = (int64x2_t)vaddw_u32((uint64x2_t)v130, *(uint32x2_t *)v135.i8);
              v134 = (int64x2_t)vaddw_high_u32((uint64x2_t)v134, *v129);
              v133 = (int64x2_t)vaddw_u32((uint64x2_t)v133, *(uint32x2_t *)v129->i8);
              v129 += 2;
              v131 -= 8LL;
            }

            while (v131);
            BOOL v75 = vaddvq_s64(vaddq_s64(vaddq_s64(v133, v130), vaddq_s64(v134, v132)));
            if ((v127 & 0x7FFFFFF8) == v127) {
              goto LABEL_129;
            }
            dispatch_time_t v125 = &v15->i32[v127 & 0x7FFFFFF8];
            uint64_t v126 = v16 - v128;
          }

          else
          {
            BOOL v75 = 0LL;
            dispatch_time_t v125 = (__int32 *)v15;
            uint64_t v126 = v16;
          }

          do
          {
            v136 = *v125++;
            v75 += v136;
            v126 -= 4;
          }

          while (v126);
        }

    if (v91) {
      free(v91);
    }
    id v50 = 0LL;
    goto LABEL_179;
  }

  xpc_dictionary_set_uint64(v4, (const char *)networkd_privileged_key_type, 0x11uLL);
  xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_interface_name, a1);
  xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_second_interface_name, a2);
  char v6 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_setup_feth_pair", v5);
  id v7 = v6;
  if (v6)
  {
    Class = object_getClass(v6);
    if (Class != (Class)MEMORY[0x1895F9250])
    {
      if (Class != (Class)MEMORY[0x1895F9268])
      {
        nw_endpoint_t v9 = (void *)MEMORY[0x186E12534](v7);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        unint64_t v109 = "networkd_privileged_setup_feth_pair";
        os_log_type_t v110 = 2082;
        *(void *)BOOL v111 = v9;
        char v11 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint64_t v106 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v12 = (os_log_s *)(id)gLogObj;
          os_log_type_t v13 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v109 = "networkd_privileged_setup_feth_pair";
            os_log_type_t v110 = 2082;
            *(void *)BOOL v111 = v9;
            _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
          }

    goto LABEL_242;
  }

  if (v29)
  {
    uint64_t v30 = v24;
    uint64_t v31 = v5;
    BOOL v32 = v10;
    v167 = 0LL;
    v168 = &v167;
    v169 = 0x2020000000LL;
    v170 = 0;
    v163 = 0LL;
    v164 = &v163;
    v165 = 0x2020000000LL;
    id v166 = 0LL;
    nw_endpoint_t v33 = MEMORY[0x1895F87A8];
    uint64_t v34 = v27[1];
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_protocol_stack_insert_application_protocol_before_block_invoke;
    BOOL v172 = (char *)&unk_189BB8C40;
    *((void *)&v173 + 1) = &v167;
    char v35 = v29;
    *(void *)&v173 = v35;
    nw_endpoint_t v174 = &v163;
    nw_array_apply(v34, (uint64_t)buf);
    if (*((_BYTE *)v168 + 24))
    {
      nw_array_insert_object_at_index((uint64_t)v27[1], v28, (char *)v164[3]);
      os_log_type_t v10 = v32;
      int v5 = v31;
      int v24 = v30;
    }

    else
    {
      BOOL v42 = v27[2];
      __int16 v43 = v33;
      os_log_type_t v10 = v32;
      int v5 = v31;
      int v24 = v30;
      if (!v42)
      {
        os_log_type_t v44 = nw_array_create();
        __int16 v45 = v27;
        BOOL v47 = v27[2];
        nw_endpoint_t v46 = (BOOL *)(v27 + 2);
        *nw_endpoint_t v46 = v44;

        BOOL v42 = (unsigned __int8 *)*v46;
        os_log_type_t v27 = v45;
      }

      *(void *)os_log_type_t type = v43;
      v157 = 3221225472LL;
      v158 = __nw_protocol_stack_insert_application_protocol_before_block_invoke_2;
      v159 = &unk_189BB8C40;
      v161 = &v167;
      v160 = v35;
      nw_endpoint_t v162 = &v163;
      nw_array_apply(v42, (uint64_t)type);
      nw_array_insert_object_at_index((uint64_t)v27[2], v28, (char *)v164[3]);
    }

    _Block_object_dispose(&v163, 8);
    _Block_object_dispose(&v167, 8);
    goto LABEL_32;
  }

  __nwlog_obj();
  __int16 v118 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
  char v115 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v167) = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    __int16 v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    nw_endpoint_t v119 = type[0];
    if (os_log_type_enabled(v116, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
      _os_log_impl(&dword_181A5C000, v116, v119, "%{public}s called with null insert_before", buf, 0xCu);
    }

    goto LABEL_241;
  }

  if (!(_BYTE)v167)
  {
    __nwlog_obj();
    __int16 v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v145 = type[0];
    if (os_log_type_enabled(v116, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
      _os_log_impl( &dword_181A5C000,  v116,  v145,  "%{public}s called with null insert_before, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_241;
  }

  uint64_t v126 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  __int16 v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v127 = type[0];
  nw_endpoint_t v128 = os_log_type_enabled(v116, type[0]);
  if (!v126)
  {
    if (v128)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
      _os_log_impl(&dword_181A5C000, v116, v127, "%{public}s called with null insert_before, no backtrace", buf, 0xCu);
    }

    goto LABEL_241;
  }

  if (v128)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v126;
    _os_log_impl( &dword_181A5C000,  v116,  v127,  "%{public}s called with null insert_before, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v126);
  if (v115) {
LABEL_243:
  }
    free(v115);
LABEL_32:

  os_log_type_t v48 = *((unsigned __int16 *)v5 + 302);
  os_log_type_t v49 = v28;
  id v50 = v49;
  if (v5[609])
  {
    *((_WORD *)v49 + 68) = v48;
    snprintf(v49 + 48, 0x54uLL, "[%s%s:%u]", "", v5 + 609, v48);
  }

  __int16 v51 = v50;
  *((void *)v51 + 2) = v24;

  *(_OWORD *)int v24 = *((_OWORD *)v5 + 18);
  size_t v52 = *(uint64_t (***)(uint64_t, uint64_t))(v24 + 24);
  if (!v52 || (nw_endpoint_t v53 = *v52) == 0LL || (v53(v24, v10) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v62 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&void buf[14] = v5 + 609;
      *(_WORD *)&buf[22] = 2114;
      BOOL v172 = v155;
      _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_ERROR,  "%{public}s %s Failed to attach %{public}@ protocol",  buf,  0x20u);
    }

    goto LABEL_52;
  }

  nw_protocol_set_output_handler(v10, v24);
  __int16 v54 = *((void *)v5 + 39);
  if (!v54
    || (uint64_t v55 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v54 + 16)) == 0LL
    || (v55(v5 + 288, v10, v24) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v67 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&void buf[14] = v5 + 609;
      *(_WORD *)&buf[22] = 2114;
      BOOL v172 = v155;
      _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s %s Failed to replace flow protocol with %{public}@ protocol",  buf,  0x20u);
    }

    os_log_type_t v68 = *(void *)(v24 + 24);
    if (v68 && (v69 = *(unsigned int (**)(uint64_t, uint64_t, void))(v68 + 8)) != 0LL && v69(v24, v10, 0LL))
    {
      id v70 = (unsigned int (**)(char *, uint64_t))*((void *)v5 + 39);
      if (v70)
      {
        BOOL v71 = *v70;
        if (v71)
        {
          if (v71(v5 + 288, v10))
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v62 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
              *(_WORD *)&buf[12] = 2080;
              *(void *)&void buf[14] = v5 + 609;
              *(_WORD *)&buf[22] = 2114;
              BOOL v172 = v155;
              _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_ERROR,  "%{public}s %s Successfully repaired protocol stack after failed %{public}@ insertion",  buf,  0x20u);
            }

  __break(1u);
  return result;
}

  __int16 v60 = 1LL;
LABEL_242:
  *((_BYTE *)v11 + 35) &= ~1u;
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_80157);
  }
LABEL_247:

LABEL_313:
  return v60;
}

              uint64_t v126 = *(unsigned __int16 *)(v6 + 188);
              uint64_t v127 = v126 | (*(unsigned __int8 *)(v6 + 190) << 16);
              if ((v126 & 0x40) == 0)
              {
                *(_BYTE *)(v6 + 190) = BYTE2(v127);
                *(_WORD *)(v6 + 188) = v127 | 0x40;
                nw_protocol_error(*(void **)v238, a3);
                nw_protocol_disconnected(*(void **)v238, a3);
              }

              return 0LL;
            }
          }
        }

        v113 = (*(unsigned __int8 *)(v6 + 190) >> 3) & 1;
        if (!gLogDatapath) {
          LOBYTE(v113) = 1;
        }
        if ((*(_WORD *)(v6 + 188) & 1) == 0)
        {
          if ((v113 & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v114 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              __int16 v116 = *(_DWORD *)(v6 + 176);
              char v115 = *(_DWORD *)(v6 + 180);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              v240 = 2082;
              v241 = (void *)(v6 + 191);
              id v242 = 2080;
              v243 = " ";
              v244 = 1024;
              uint64_t v245 = v115;
              int v246 = 1024;
              *(_DWORD *)char v247 = v116;
              *(_WORD *)&v247[4] = 2048;
              *(void *)&v247[6] = *(void *)v238;
              *(_WORD *)&v247[14] = 1024;
              *(_DWORD *)&v247[16] = v116;
              _os_log_impl( &dword_181A5C000,  v114,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> suppressing input_available on protocol %p for stream %d that is not yet open",  buf,  0x3Cu);
            }
          }

          goto LABEL_219;
        }

        if ((v113 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v215 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v217 = *(_DWORD *)(v6 + 176);
            nw_endpoint_t v216 = *(_DWORD *)(v6 + 180);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            v240 = 2082;
            v241 = (void *)(v6 + 191);
            id v242 = 2080;
            v243 = " ";
            v244 = 1024;
            uint64_t v245 = v216;
            int v246 = 1024;
            *(_DWORD *)char v247 = v217;
            *(_WORD *)&v247[4] = 2048;
            *(void *)&v247[6] = *(void *)v238;
            *(_WORD *)&v247[14] = 1024;
            *(_DWORD *)&v247[16] = v217;
            _os_log_impl( &dword_181A5C000,  v215,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> calling input_available on protocol %p for stream %d",  buf,  0x3Cu);
          }
        }

        if (*(void *)v238)
        {
          int v117 = *(void *)(*(void *)v238 + 24LL);
          if (v117)
          {
            __int16 v118 = *(void (**)(void))(v117 + 64);
            if (v118)
            {
              v118();
              goto LABEL_219;
            }
          }
        }

        __nwlog_obj();
        v189 = "invalid";
        if (*(void *)v238 && *(void *)(*(void *)v238 + 16LL)) {
          v189 = *(const char **)(*(void *)v238 + 16LL);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
        v240 = 2082;
        v241 = (void *)v189;
        v190 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v236 = 0;
        if (__nwlog_fault(v190, &type, &v236))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v191 = (os_log_s *)__nwlog_obj();
            v192 = type;
            if (!os_log_type_enabled(v191, type)) {
              goto LABEL_404;
            }
            v193 = "invalid";
            if (*(void *)v238 && *(void *)(*(void *)v238 + 16LL)) {
              v193 = *(const char **)(*(void *)v238 + 16LL);
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            v240 = 2082;
            v241 = (void *)v193;
            v194 = "%{public}s protocol %{public}s has invalid input_available callback";
            goto LABEL_403;
          }

          if (!v236)
          {
            v191 = (os_log_s *)__nwlog_obj();
            v192 = type;
            if (!os_log_type_enabled(v191, type)) {
              goto LABEL_404;
            }
            int v223 = "invalid";
            if (*(void *)v238 && *(void *)(*(void *)v238 + 16LL)) {
              int v223 = *(const char **)(*(void *)v238 + 16LL);
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            v240 = 2082;
            v241 = (void *)v223;
            v194 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
            goto LABEL_403;
          }

          v204 = (char *)__nw_create_backtrace_string();
          v191 = (os_log_s *)__nwlog_obj();
          v192 = type;
          v205 = os_log_type_enabled(v191, type);
          if (v204)
          {
            if (v205)
            {
              v206 = "invalid";
              if (*(void *)v238 && *(void *)(*(void *)v238 + 16LL)) {
                v206 = *(const char **)(*(void *)v238 + 16LL);
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              v240 = 2082;
              v241 = (void *)v206;
              id v242 = 2082;
              v243 = v204;
              _os_log_impl( &dword_181A5C000,  v191,  v192,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v204);
            goto LABEL_404;
          }

          if (v205)
          {
            v229 = "invalid";
            if (*(void *)v238 && *(void *)(*(void *)v238 + 16LL)) {
              v229 = *(const char **)(*(void *)v238 + 16LL);
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            v240 = 2082;
            v241 = (void *)v229;
            v194 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_403:
            _os_log_impl(&dword_181A5C000, v191, v192, v194, buf, 0x16u);
          }
        }

  BOOL v96 = nw_parameters_copy_protocol_options_legacy(v16, a1);
  if (v96)
  {
    BOOL v97 = v96;
    BOOL v98 = v97;
    os_log_type_t v99 = 0LL;
    HIBYTE(a1[3].output_handler_context) = 0;
    os_log_type_t v100 = (char *)&a1[3].output_handler_context + 7;
    nw_endpoint_t v101 = 84LL;
    while (1)
    {
      os_log_type_t v102 = v97[v99 + 48];
      v100[v99] = v102;
      if (!v102) {
        break;
      }
      --v101;
      ++v99;
      if (v101 <= 1)
      {
        v100[v99] = 0;
        break;
      }
    }

    hop_limit = nw_ip_options_get_hop_limit(v98);
    if (hop_limit) {
      BOOL v104 = hop_limit;
    }
    else {
      BOOL v104 = 64;
    }
    BYTE5(a1[3].output_handler_context) = v104;
    if (nw_ip_options_get_use_minimum_mtu(v98)) {
      id v105 = 2;
    }
    else {
      id v105 = 0;
    }
    BYTE6(a1[3].output_handler_context) = BYTE6(a1[3].output_handler_context) & 0xFD | v105;
    if (nw_ip_options_get_calculate_receive_time(v98)) {
      uint64_t v106 = 4;
    }
    else {
      uint64_t v106 = 0;
    }
    BYTE6(a1[3].output_handler_context) = BYTE6(a1[3].output_handler_context) & 0xFB | v106;
    if (nw_ip_options_get_receive_hop_limit(v98)) {
      unint64_t v107 = 16;
    }
    else {
      unint64_t v107 = 0;
    }
    BYTE6(a1[3].output_handler_context) = BYTE6(a1[3].output_handler_context) & 0xEF | v107;
    os_release(v98);
  }

  else
  {
    BYTE5(a1[3].output_handler_context) = 64;
  }

  unint64_t v108 = 1LL;
  nw_protocol_ip_register_segmentation_offload_notification(a1, 1);
  return v108;
}

LABEL_442:
}

void sub_181AE3824( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_should_ignore_path_result(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[34] >> 6) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v16 = "nw_endpoint_flow_should_ignore_path_result";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_endpoint_flow_should_ignore_path_result";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          id v16 = "nw_endpoint_flow_should_ignore_path_result";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_endpoint_flow_should_ignore_path_result";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_endpoint_flow_should_ignore_path_result";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_parameters_to_ne_app_context(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_to_ne_app_context";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_to_ne_app_context";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_parameters_to_ne_app_context";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_44:
        if (!v12) {
          goto LABEL_10;
        }
LABEL_45:
        free(v12);
        goto LABEL_10;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_to_ne_app_context";
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_to_ne_app_context";
        _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181AE449C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_block_trackers(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[100] >> 1) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_get_block_trackers";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_block_trackers";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_get_block_trackers";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_block_trackers";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_block_trackers";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_parameters_has_custom_proxy_configs(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = nw_context_has_proxies(*(void **)(v1[13] + 136LL)) || v2[22] != 0LL;
    goto LABEL_5;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181AE49F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_has_proxies(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if ((v1[34]._os_unfair_lock_opaque & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      os_unfair_lock_lock(v2 + 20);
      uint64_t v7 = *(void *)&v2[14]._os_unfair_lock_opaque;
      if (!v7 || *(void *)(v7 + 16) == *(void *)(v7 + 24))
      {
        BOOL v8 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
        uint64_t v9 = *(void *)(v8 + 56);
        if (v9) {
          BOOL v4 = *(void *)(v9 + 16) != *(void *)(v9 + 24);
        }
        else {
          BOOL v4 = 0LL;
        }
      }

      else
      {
        BOOL v4 = 1LL;
      }

      os_unfair_lock_unlock(v2 + 20);
    }

    else
    {
      uint64_t v3 = *(void *)&v2[14]._os_unfair_lock_opaque;
      if (!v3 || *(void *)(v3 + 16) == *(void *)(v3 + 24))
      {
        BOOL v5 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
        uint64_t v6 = *(void *)(v5 + 56);
        if (v6) {
          BOOL v4 = *(void *)(v6 + 16) != *(void *)(v6 + 24);
        }
        else {
          BOOL v4 = 0LL;
        }
      }

      else
      {
        BOOL v4 = 1LL;
      }
    }

    goto LABEL_19;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v22 = "nw_context_has_proxies";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_context_has_proxies";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v22 = "nw_context_has_proxies";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_context_has_proxies";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_context_has_proxies";
        _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181AE4D58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_get_client_id(void *a1, unsigned __int8 *a2)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_endpoint_handler_get_client_id";
    BOOL v42 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (__nwlog_fault(v42, &type, &v66))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_endpoint_handler_get_client_id";
          _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v66)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        BOOL v47 = os_log_type_enabled(v43, type);
        if (backtrace_string)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            v69 = "nw_endpoint_handler_get_client_id";
            __int16 v70 = 2082;
            BOOL v71 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_81;
        }

        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_endpoint_handler_get_client_id";
          _os_log_impl(&dword_181A5C000, v43, v46, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v62 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_endpoint_handler_get_client_id";
          _os_log_impl( &dword_181A5C000,  v43,  v62,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181AE56D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_get_client_id(void *a1, _OWORD *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  BOOL v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(v3 + 120);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  nw_endpoint_t v17 = "nw_path_get_client_id";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v17 = "nw_path_get_client_id";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v17 = "nw_path_get_client_id";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v17 = "nw_path_get_client_id";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v17 = "nw_path_get_client_id";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

const char *nw_endpoint_event_event_string(int a1, int a2)
{
  switch(a1)
  {
    case 1:
      unsigned __int16 v2 = a2 - 1;
      uint64_t v3 = off_189BBC1A8;
      goto LABEL_16;
    case 2:
      unsigned __int16 v2 = a2 - 1;
      uint64_t v3 = off_189BBC1F8;
      goto LABEL_16;
    case 3:
      unsigned __int16 v2 = a2 - 1;
      uint64_t v3 = off_189BBC238;
      goto LABEL_16;
    case 4:
      unsigned __int16 v2 = a2 - 1;
      uint64_t v3 = off_189BBC2B0;
      goto LABEL_16;
    case 5:
      unsigned __int16 v2 = a2 - 1;
      uint64_t v3 = off_189BBC2E0;
      goto LABEL_16;
    case 6:
      unsigned __int16 v2 = a2 - 1;
      uint64_t v3 = off_189BBC320;
      goto LABEL_16;
    case 7:
      unsigned __int16 v2 = a2 - 1;
      uint64_t v3 = off_189BBC308;
LABEL_16:
      result = v3[v2];
      break;
    default:
LABEL_17:
      result = "unknown";
      break;
  }

  return result;
}

LABEL_195:
              BOOL v77 = 0LL;
              goto LABEL_196;
            }
          }

          else
          {
          }

          v200[0] = 0;
          os_log_type_t v64 = v62[88]._os_unfair_lock_opaque;
          if (!v64) {
            goto LABEL_64;
          }
          goto LABEL_67;
        }
      }

      BOOL v47 = ", proxy";
      goto LABEL_45;
    }

    __nwlog_obj();
    v138 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_create_description";
    uint64_t v139 = (char *)_os_log_send_and_compose_impl();

    out[0] = 16;
    applier[0] = 0;
    if (__nwlog_fault(v139, out, applier))
    {
      if (out[0] == 17)
      {
        __nwlog_obj();
        v140 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v141 = out[0];
        if (os_log_type_enabled(v140, (os_log_type_t)out[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_create_description";
          _os_log_impl(&dword_181A5C000, v140, v141, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (applier[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v140 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v143 = out[0];
        v144 = os_log_type_enabled(v140, (os_log_type_t)out[0]);
        if (backtrace_string)
        {
          if (v144)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_create_description";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v140,  v143,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_193;
        }

        if (v144)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_create_description";
          _os_log_impl(&dword_181A5C000, v140, v143, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v140 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v145 = out[0];
        if (os_log_type_enabled(v140, (os_log_type_t)out[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_create_description";
          _os_log_impl( &dword_181A5C000,  v140,  v145,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      goto LABEL_208;
    }

    if (!(_BYTE)v167)
    {
      __nwlog_obj();
      os_log_type_t v91 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v136 = type[0];
      if (os_log_type_enabled(v91, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
        _os_log_impl( &dword_181A5C000,  v91,  v136,  "%{public}s called with null orig_protocol_options, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_195;
    }

    unint64_t v107 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v108 = type[0];
    unint64_t v109 = os_log_type_enabled(v104, type[0]);
    if (v107)
    {
      if (v109)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v107;
        _os_log_impl( &dword_181A5C000,  v104,  v108,  "%{public}s called with null orig_protocol_options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v107);
LABEL_208:
      if (!v90)
      {
LABEL_210:
        __int16 v41 = 0LL;
        goto LABEL_88;
      }

    goto LABEL_41;
  }

  __nwlog_obj();
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
  BOOL v32 = (char *)_os_log_send_and_compose_impl();

  type[0] = 16;
  LOBYTE(v279) = 0;
  if (__nwlog_fault(v32, type, &v279))
  {
    if (type[0] == 17)
    {
      __nwlog_obj();
      nw_endpoint_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v34 = type[0];
      if (os_log_type_enabled(v33, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
        _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)v279)
    {
      nw_endpoint_t v50 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v51 = type[0];
      size_t v52 = os_log_type_enabled(v33, (os_log_type_t)type[0]);
      if (v50)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v50;
          _os_log_impl( &dword_181A5C000,  v33,  v51,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v50);
        goto LABEL_184;
      }

      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
        _os_log_impl(&dword_181A5C000, v33, v51, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v66 = type[0];
      if (os_log_type_enabled(v33, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_add_input_handler";
        _os_log_impl( &dword_181A5C000,  v33,  v66,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

                  __int16 v45 = 0LL;
                  goto LABEL_196;
                }

                if (a2)
                {
                  nw_endpoint_t v25 = v16;
                  output_handler_context = (char *)a2->output_handler_context;
                  if (output_handler_context)
                  {
                    if ((*((_WORD *)output_handler_context + 42) & 2) == 0) {
                      *((_BYTE *)v21 + 402) |= 0x10u;
                    }
                    uint64_t v28 = (uint64_t *)(output_handler_context + 48);
                    os_log_type_t v27 = *((void *)output_handler_context + 6);
                    if (v27)
                    {
                      os_log_type_t v100 = v21;
                      BOOL v111 = 0LL;
                      unint64_t v112 = &v111;
                      v113 = 0x2020000000LL;
                      id v114 = a5;
                      v109[0] = 0LL;
                      v109[1] = v109;
                      v109[2] = 0x2020000000LL;
                      os_log_type_t v110 = a4;
                      *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
                      os_log_type_t v102 = 3221225472LL;
                      os_log_type_t v103 = (uint64_t)___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
                      BOOL v104 = &unk_189BB7818;
                      id v105 = &v111;
                      uint64_t v106 = &v115;
                      unint64_t v107 = output_handler_context + 32;
                      unint64_t v108 = a6;
                      do
                      {
                        if (!v27) {
                          break;
                        }
                        char v29 = *(void *)(v27 + 32);
                        uint64_t v30 = ((uint64_t (*)(os_log_type_t *))v103)(type);
                        os_log_type_t v27 = v29;
                      }

                      while ((v30 & 1) != 0);
                      uint64_t v31 = *((_DWORD *)output_handler_context + 17);
                      if (v31 < a3)
                      {
                        if ((v24[405] & 0x80000000) == 0 && gLogDatapath)
                        {
                          BOOL v32 = *((_DWORD *)output_handler_context + 17);
                          __nwlog_obj();
                          nw_endpoint_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
                          {
                            uint64_t v34 = *((_DWORD *)output_handler_context + 17);
                            *(_DWORD *)buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&void buf[14] = (char *)v100 + 407;
                            *(_WORD *)&buf[22] = 2080;
                            __int16 v120 = " ";
                            LOWORD(v121) = 1024;
                            *(_DWORD *)((char *)&v121 + 2) = v34;
                            WORD3(v121) = 1024;
                            DWORD2(v121) = a3;
                            _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sPending inbound bytes %u < minimum bytes %u",  buf,  0x2Cu);
                          }

                          uint64_t v31 = v32;
                        }

                        goto LABEL_50;
                      }

                      if (v31 <= a4)
                      {
                        BOOL v42 = *((_DWORD *)output_handler_context + 16);
                        __int16 v41 = *((void *)output_handler_context + 6);
                        if (v42 <= a5)
                        {
                          if (v41)
                          {
                            *a6->tqh_last = (nw_frame *)v41;
                            *(void *)(*((void *)output_handler_context + 6) + 40LL) = a6->tqh_last;
                            a6->tqh_last = (nw_frame **)*((void *)output_handler_context + 7);
                            *((void *)output_handler_context + 6) = 0LL;
                            *((void *)output_handler_context + 7) = v28;
                          }

                          *((_DWORD *)v116 + 6) = v42;
                          *((void *)output_handler_context + 8) = 0LL;
LABEL_50:
                          _Block_object_dispose(v109, 8);
                          _Block_object_dispose(&v111, 8);
                          os_log_type_t v16 = v25;
                          if (v31 >= a3)
                          {
LABEL_51:
                            __int16 v45 = *((unsigned int *)v116 + 6);
LABEL_196:
                            _Block_object_dispose(&v115, 8);
LABEL_197:

LABEL_198:
                            return v45;
                          }

                          goto LABEL_195;
                        }
                      }

                      else
                      {
                        __int16 v41 = *v28;
                      }

                      *(void *)buf = MEMORY[0x1895F87A8];
                      *(void *)&buf[8] = 3221225472LL;
                      *(void *)&buf[16] = ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_278;
                      __int16 v120 = (const char *)&unk_189BB7840;
                      *(void *)&v121 = &v111;
                      *((void *)&v121 + 1) = v109;
                      __int16 v122 = &v115;
                      id v123 = a1;
                      uint64_t v124 = (nw_protocol *)(output_handler_context + 32);
                      dispatch_time_t v125 = a6;
                      do
                      {
                        if (!v41) {
                          break;
                        }
                        __int16 v43 = *(void *)(v41 + 32);
                        os_log_type_t v44 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                        __int16 v41 = v43;
                      }

                      while ((v44 & 1) != 0);
                      goto LABEL_50;
                    }

    goto LABEL_196;
  }

  if (a5)
  {
    BOOL v12 = v11;
    os_log_type_t v13 = *(id *)(v12[13] + 136LL);

    nw_context_assert_queue(v13);
  }

  char v14 = v11;
  v14[12] = v14[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;

  os_log_type_t v15 = v14;
  os_log_type_t v16 = v14[12];

  if ((v16 & 0x1000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_endpoint_t v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&void buf[14] = v137;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s prohibit joining for connection to connected fd %{public}@",  buf,  0x16u);
    }

    __int16 v18 = v15;
    v14[12] |= 0x800000uLL;
  }

  if (!v138)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    *(void *)&buf[24] = __Block_byref_object_copy__24148;
    *(void *)v144 = __Block_byref_object_dispose__24149;
    *(void *)&v144[8] = 0LL;
    v140[0] = MEMORY[0x1895F87A8];
    v140[1] = 3221225472LL;
    v140[2] = ___ZL51nw_connection_create_with_connected_socket_internalPU27objcproto16OS_nw_fd_wrapper8NSObjectPU27objcproto16OS_nw_parametersS_PU25objcproto14OS_nw_endpointS_S5_b_block_invoke;
    v140[3] = &unk_189BC78E8;
    v140[4] = buf;
    fd = nw_fd_wrapper_get_fd(v137, v140);
    v138 = (fd & 1) != 0 ? *(id *)(*(void *)&buf[8] + 40LL) : 0LL;
    _Block_object_dispose(buf, 8);

    if (!fd) {
      goto LABEL_198;
    }
  }

  uint64_t v20 = v136;
  if (v136) {
    goto LABEL_16;
  }
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  *(void *)&buf[24] = __Block_byref_object_copy__24148;
  *(void *)v144 = __Block_byref_object_dispose__24149;
  *(void *)&v144[8] = 0LL;
  v139[0] = MEMORY[0x1895F87A8];
  v139[1] = 3221225472LL;
  v139[2] = ___ZL51nw_connection_create_with_connected_socket_internalPU27objcproto16OS_nw_fd_wrapper8NSObjectPU27objcproto16OS_nw_parametersS_PU25objcproto14OS_nw_endpointS_S5_b_block_invoke_2;
  v139[3] = &unk_189BC78E8;
  v139[4] = buf;
  nw_fd_wrapper_get_fd(v137, v139);
  uint64_t v20 = (nw_endpoint *)*(id *)(*(void *)&buf[8] + 40LL);
  _Block_object_dispose(buf, 8);

  if (v20) {
LABEL_16:
  }
    nw_parameters_set_local_endpoint((nw_parameters_t)v15, v20);
  v136 = v20;
  os_log_type_t v21 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]( (void **)objc_alloc(&OBJC_CLASS___NWConcrete_nw_connection),  v138,  v15,  0);
  BOOL v22 = v21;
  if (!v21)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v35 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
    BOOL v36 = (char *)_os_log_send_and_compose_impl();

    v149[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v149[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v37 = (os_log_s *)(id)gLogObj;
      v38 = v149[0];
      if (os_log_type_enabled(v37, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed",  buf,  0xCu);
      }

      goto LABEL_113;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v37 = (os_log_s *)(id)gLogObj;
      os_log_type_t v62 = v149[0];
      if (os_log_type_enabled(v37, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        _os_log_impl( &dword_181A5C000,  v37,  v62,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_113;
    }

    os_log_type_t v48 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v49 = (os_log_s *)(id)gLogObj;
    nw_endpoint_t v50 = v149[0];
    __int16 v51 = os_log_type_enabled(v49, (os_log_type_t)v149[0]);
    if (v48)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v48;
        _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

          free(v119);
          goto LABEL_196;
        }

        *(_BYTE *)unint64_t v112 = v111;
        *(_DWORD *)(v112 + 1) = v114;
        if (v113 == -1)
        {
LABEL_181:
          id v123 = v112 + v114 + 5;
LABEL_197:
          v237[3] = v123;
          nw_endpoint_t v128 = nw_proxy_config_serialize_one_stack(v2, v123, v28);
          v237[3] = v128;
          goto LABEL_198;
        }

        if (v1)
        {
          memcpy((void *)(v112 + 5), v1, v114);
          goto LABEL_181;
        }

        id v220 = v2;
        __nwlog_obj();
        id v202 = (void *)objc_claimAutoreleasedReturnValue();
        v203 = v111;
        *(_DWORD *)v267 = 136446722;
        v268 = "nw_necp_append_tlv";
        v269 = 1024;
        *(_DWORD *)id v270 = v111;
        *(_WORD *)&v270[4] = 1024;
        *(_DWORD *)&v270[6] = v114;
        BOOL v172 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v257) = 0;
        if (__nwlog_fault(v172, type, &v257))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v173 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v204 = type[0];
            if (os_log_type_enabled(v173, type[0]))
            {
              *(_DWORD *)v267 = 136446722;
              v268 = "nw_necp_append_tlv";
              v269 = 1024;
              *(_DWORD *)id v270 = v203;
              *(_WORD *)&v270[4] = 1024;
              *(_DWORD *)&v270[6] = v114;
              _os_log_impl(&dword_181A5C000, v173, v204, "%{public}s type=%u length=%u but value is NULL", v267, 0x18u);
            }
          }

          else if ((_BYTE)v257)
          {
            int v211 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v173 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            char v212 = type[0];
            v213 = os_log_type_enabled(v173, type[0]);
            if (v211)
            {
              if (v213)
              {
                *(_DWORD *)v267 = 136446978;
                v268 = "nw_necp_append_tlv";
                v269 = 1024;
                *(_DWORD *)id v270 = v203;
                *(_WORD *)&v270[4] = 1024;
                *(_DWORD *)&v270[6] = v114;
                *(_WORD *)id v271 = 2082;
                *(void *)&v271[2] = v211;
                _os_log_impl( &dword_181A5C000,  v173,  v212,  "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s",  v267,  0x22u);
              }

              free(v211);
              if (!v172) {
                goto LABEL_383;
              }
              goto LABEL_382;
            }

            if (v213)
            {
              *(_DWORD *)v267 = 136446722;
              v268 = "nw_necp_append_tlv";
              v269 = 1024;
              *(_DWORD *)id v270 = v203;
              *(_WORD *)&v270[4] = 1024;
              *(_DWORD *)&v270[6] = v114;
              _os_log_impl( &dword_181A5C000,  v173,  v212,  "%{public}s type=%u length=%u but value is NULL, no backtrace",  v267,  0x18u);
            }
          }

          else
          {
            __nwlog_obj();
            v173 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v214 = type[0];
            if (os_log_type_enabled(v173, type[0]))
            {
              *(_DWORD *)v267 = 136446722;
              v268 = "nw_necp_append_tlv";
              v269 = 1024;
              *(_DWORD *)id v270 = v203;
              *(_WORD *)&v270[4] = 1024;
              *(_DWORD *)&v270[6] = v114;
              _os_log_impl( &dword_181A5C000,  v173,  v214,  "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded",  v267,  0x18u);
            }
          }

          goto LABEL_380;
        }

      free(v65);
      goto LABEL_196;
    }

    if (v94)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_create";
      os_log_type_t v68 = "%{public}s called with null parameters, no backtrace";
LABEL_193:
      _os_log_impl(&dword_181A5C000, v66, v67, v68, buf, 0xCu);
      goto LABEL_194;
    }

    goto LABEL_194;
  }

  BOOL v32 = (char *)calloc(1uLL, 0x1B0uLL);
  if (!v32)
  {
    BOOL v71 = v13;
    __int16 v72 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&void buf[14] = 1LL;
    *(_WORD *)&buf[22] = 2048;
    *(void *)&buf[24] = 432LL;
    BOOL v73 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v73);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v73);
    os_log_type_t v13 = v71;
  }

  *((_OWORD *)v32 + 25) = 0u;
  *((_OWORD *)v32 + 26) = 0u;
  *((_OWORD *)v32 + 23) = 0u;
  *((_OWORD *)v32 + 24) = 0u;
  *((_OWORD *)v32 + 21) = 0u;
  *((_OWORD *)v32 + 22) = 0u;
  *((_OWORD *)v32 + 19) = 0u;
  *((_OWORD *)v32 + 20) = 0u;
  *((_OWORD *)v32 + 17) = 0u;
  *((_OWORD *)v32 + 18) = 0u;
  *((_OWORD *)v32 + 15) = 0u;
  *((_OWORD *)v32 + 16) = 0u;
  *((_OWORD *)v32 + 13) = 0u;
  *((_OWORD *)v32 + 14) = 0u;
  *((_OWORD *)v32 + 11) = 0u;
  *((_OWORD *)v32 + 12) = 0u;
  *((_OWORD *)v32 + 9) = 0u;
  *((_OWORD *)v32 + 10) = 0u;
  *((_OWORD *)v32 + 7) = 0u;
  *((_OWORD *)v32 + 8) = 0u;
  *((_OWORD *)v32 + 5) = 0u;
  *((_OWORD *)v32 + 6) = 0u;
  *((_OWORD *)v32 + 3) = 0u;
  *((_OWORD *)v32 + 4) = 0u;
  *((_OWORD *)v32 + 1) = 0u;
  *((_OWORD *)v32 + 2) = 0u;
  *(_OWORD *)BOOL v32 = 0u;
  *((void *)v32 + 2) = *(void *)(v8 + 16);
  *((void *)v32 + 3) = &nw_protocol_http1_get_callbacks(void)::http1_protocol_callbacks;
  *((_DWORD *)v32 + 60) = 2;
  *((void *)v32 + 28) = v32;
  *((void *)v32 + 5) = v32 + 216;
  *((void *)v32 + 31) = v8;
  nw_protocol_set_input_handler((uint64_t)v32, (uint64_t)v4);
  nw_protocol_set_output_handler((uint64_t)v32, *(void *)(v8 + 32));
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  *(void *)&buf[24] = v32;
  *(void *)aBlock = v12;
  *(void *)&aBlock[8] = v13[397];
  *(void *)&aBlock[16] = ___ZL22nw_http1_stream_createP11nw_protocolP17nw_protocol_http1P11nw_endpointP13nw_parameters_block_invoke;
  v280 = (uint64_t)&unk_189BBD868;
  *(void *)nw_endpoint_t v281 = buf;
  *((void *)v32 + 39) = _Block_copy(aBlock);
  _Block_object_dispose(buf, 8);
  nw_endpoint_t v33 = os_retain(v31);
  uint64_t v34 = v32[344];
  if ((v34 & 1) != 0)
  {
    char v35 = (void *)*((void *)v32 + 42);
    if (v35)
    {
      os_release(v35);
      uint64_t v34 = v32[344];
    }
  }

  *((void *)v32 + 42) = v33;
  v32[344] = v34 | 1;
  BOOL v36 = os_retain(parameters);
  id v37 = v32[328];
  if ((v37 & 1) != 0)
  {
    v38 = (void *)*((void *)v32 + 40);
    if (v38)
    {
      os_release(v38);
      id v37 = v32[328];
    }
  }

  *((void *)v32 + 40) = v36;
  v32[328] = v37 | 1;
  if ((v32[158] & 1) == 0)
  {
    if (*((_BYTE *)v9 + 1537))
    {
      BOOL v75 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
      {
        __int16 v76 = *((void *)v32 + 32);
        BOOL v77 = *(_DWORD *)(*((void *)v32 + 31) + 372LL);
        if (v76) {
          LODWORD(v76) = *(_DWORD *)(v76 + 860);
        }
        __int16 v78 = *((_DWORD *)v32 + 106);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_http1_stream_create";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v32 + 74;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = " ";
        *(_WORD *)&_BYTE buf[32] = 1024;
        *(_DWORD *)&buf[34] = v77;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v76;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v78;
        *(_WORD *)&buf[50] = 2048;
        *(void *)&buf[52] = v32;
        _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> created %p",  buf,  0x3Cu);
      }
    }
  }

  v4->output_handler_context = v32;
  uint64_t v39 = parameters;
  id v40 = *(id *)(v39[13] + 136);

  __int16 v41 = v32[272];
  if ((v41 & 1) != 0)
  {
    BOOL v42 = (void *)*((void *)v32 + 33);
    if (v42)
    {
      os_release(v42);
      __int16 v41 = v32[272];
    }
  }

  *((void *)v32 + 33) = v40;
  v32[272] = v41 | 1;
  __int16 v43 = _nw_http_parsed_fields_create();
  os_log_type_t v44 = v32[408];
  if ((v44 & 1) != 0)
  {
    os_log_type_t v46 = (void *)*((void *)v32 + 50);
    __int16 v45 = (uint64_t)v271;
    if (v46)
    {
      os_release(v46);
      os_log_type_t v44 = v32[408];
    }
  }

  else
  {
    __int16 v45 = (uint64_t)v271;
  }

  *((void *)v32 + 50) = v43;
  v32[408] = v44 | 1;
  v32[208] = *(_BYTE *)(v8 + 376) & 1;
  BOOL v47 = nw_parameters_copy_protocol_options_legacy(v39, (nw_protocol *)v8);
  os_log_type_t v48 = v47;
  if (!v47 || (singleton = nw_http_messaging_options_copy_transaction_metadata(v47)) == 0LL)
  {
    if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_59_74543);
    }
    singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_transaction_definition_definition);
  }

  nw_endpoint_t v50 = v32[360];
  if ((v50 & 1) != 0)
  {
    __int16 v51 = (void *)*((void *)v32 + 44);
    if (v51)
    {
      os_release(v51);
      nw_endpoint_t v50 = v32[360];
    }
  }

  *((void *)v32 + 44) = singleton;
  v32[360] = v50 | 1;
  if (v48) {
    os_release(v48);
  }
  size_t v52 = a1->handle;
  if (!v52) {
    goto LABEL_197;
  }
LABEL_69:
  if (v52[6] != 2) {
    goto LABEL_213;
  }
  if (!v32)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
    os_log_type_t v89 = (char *)_os_log_send_and_compose_impl();
    aBlock[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (aBlock[0] == 17)
    {
      os_log_type_t v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = aBlock[0];
      if (!os_log_type_enabled(v90, (os_log_type_t)aBlock[0])) {
        goto LABEL_451;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
      id v92 = "%{public}s called with null http1_stream";
    }

    else if (type)
    {
      os_log_type_t v103 = (char *)__nw_create_backtrace_string();
      os_log_type_t v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = aBlock[0];
      BOOL v104 = os_log_type_enabled(v90, (os_log_type_t)aBlock[0]);
      if (v103)
      {
        if (v104)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v103;
          _os_log_impl( &dword_181A5C000,  v90,  v91,  "%{public}s called with null http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v103);
        goto LABEL_451;
      }

      if (!v104)
      {
LABEL_451:
        if (v89) {
          free(v89);
        }
        goto LABEL_453;
      }

      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
      id v92 = "%{public}s called with null http1_stream, no backtrace";
    }

    else
    {
      os_log_type_t v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = aBlock[0];
      if (!os_log_type_enabled(v90, (os_log_type_t)aBlock[0])) {
        goto LABEL_451;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
      id v92 = "%{public}s called with null http1_stream, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v90, v91, v92, buf, 0xCu);
    goto LABEL_451;
  }

  if (parameters)
  {
    nw_endpoint_t v53 = nw_parameters_copy_protocol_options_legacy(parameters, a1);
    if (v53)
    {
      id v54 = v53;
      if ((v32[158] & 1) == 0)
      {
        if (*((_BYTE *)v9 + 1537))
        {
          os_log_type_t v99 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v100 = *((void *)v32 + 32);
            nw_endpoint_t v101 = *(_DWORD *)(*((void *)v32 + 31) + 372LL);
            if (v100) {
              LODWORD(v100) = *(_DWORD *)(v100 + 860);
            }
            os_log_type_t v102 = *((_DWORD *)v32 + 106);
            *(_DWORD *)buf = 136448770;
            *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v32 + 74;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&buf[24] = " ";
            *(_WORD *)&_BYTE buf[32] = 1024;
            *(_DWORD *)&buf[34] = v101;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v100;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v102;
            *(_WORD *)&buf[50] = 2048;
            *(void *)&buf[52] = v32;
            *(_WORD *)&buf[60] = 2048;
            *(void *)&buf[62] = v8;
            *(_WORD *)&buf[70] = 2048;
            *(void *)&buf[72] = a1;
            *(_WORD *)int v276 = 2048;
            *(void *)&v276[2] = parameters;
            char v277 = 2048;
            v278 = v54;
            _os_log_impl( &dword_181A5C000,  v99,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http1_stream protocol %p, set protocol instance to %p instead of %p i n parameters %p options %p",  buf,  0x64u);
          }
        }
      }

      if (nw_protocol_copy_http1_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http1_definition_onceToken, &__block_literal_global_72463);
      }
      uint64_t v55 = (id)nw_protocol_copy_http1_definition_http1_definition;
      __int16 v56 = v54;
      *((void *)v56 + 2) = v8;

      if (v55) {
        os_release(v55);
      }
      os_release(v56);
      __int16 v45 = (uint64_t)v271;
    }

    goto LABEL_214;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
  os_log_type_t v95 = (char *)_os_log_send_and_compose_impl();
  aBlock[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v95, aBlock, &type))
  {
    if (aBlock[0] == 17)
    {
      BOOL v96 = (os_log_s *)__nwlog_obj();
      BOOL v97 = aBlock[0];
      if (!os_log_type_enabled(v96, (os_log_type_t)aBlock[0])) {
        goto LABEL_474;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
      BOOL v98 = "%{public}s called with null parameters";
      goto LABEL_473;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v96 = (os_log_s *)__nwlog_obj();
      BOOL v97 = aBlock[0];
      if (!os_log_type_enabled(v96, (os_log_type_t)aBlock[0])) {
        goto LABEL_474;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
      BOOL v98 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_473;
    }

    id v105 = (char *)__nw_create_backtrace_string();
    BOOL v96 = (os_log_s *)__nwlog_obj();
    BOOL v97 = aBlock[0];
    uint64_t v106 = os_log_type_enabled(v96, (os_log_type_t)aBlock[0]);
    if (v105)
    {
      if (v106)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v105;
        _os_log_impl( &dword_181A5C000,  v96,  v97,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v105);
      goto LABEL_474;
    }

    if (v106)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
      BOOL v98 = "%{public}s called with null parameters, no backtrace";
LABEL_473:
      _os_log_impl(&dword_181A5C000, v96, v97, v98, buf, 0xCu);
    }
  }

        if (v35) {
          free(v35);
        }
        os_log_type_t v16 = 0LL;
        goto LABEL_15;
      }

      if (!v80)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        id v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          v38 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = (os_log_s *)__nwlog_obj();
      id v37 = type;
      __int16 v58 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          v38 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        BOOL v85 = backtrace_string;
        uint64_t v59 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_124:
        _os_log_impl(&dword_181A5C000, v36, v37, v59, buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_195;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  int v83 = "_http_vle_encode";
  __int16 v84 = 2048;
  BOOL v85 = (const char *)a3;
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  free(v28);
  char v29 = *(void *)(a1 + 32);
  os_log_type_t v11 = a1 + 32;
  os_log_type_t v16 = *(char **)(*(void *)(v29 + 8) + 24LL);
  os_log_type_t v13 = v11 + 8;
LABEL_15:
  *(void *)(*(void *)(*(void *)v11 + 8LL) + 24LL) = v16;
  nw_endpoint_t v17 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
  if (!v17)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v83 = "nw_http_fillout_binary_message_inner_block_invoke_2";
    uint64_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v80 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v32 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor";
LABEL_183:
      _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
      goto LABEL_184;
    }

    if (!v80)
    {
      BOOL v32 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }

    __int16 v51 = (char *)__nw_create_backtrace_string();
    BOOL v32 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v33 = type;
    size_t v52 = os_log_type_enabled(v32, type);
    if (!v51)
    {
      if (!v52) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }

    if (!v52) {
      goto LABEL_107;
    }
LABEL_106:
    *(_DWORD *)buf = 136446466;
    int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    __int16 v84 = 2082;
    BOOL v85 = v51;
    _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
    goto LABEL_107;
  }

  if (a3)
  {
    if (a2)
    {
      __int16 v18 = *(void *)(*(void *)v13 + 8LL);
      if (*(void *)(v18 + 24) >= a3)
      {
        memcpy(v17, a2, a3);
        char v19 = *(void *)(v18 + 24);
        *(void *)(v18 + 24) = v19 - a3;
        if (v19 < a3)
        {
          if (gLogDatapath)
          {
            __int16 v70 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              BOOL v71 = *(void *)(v18 + 24);
              *(_DWORD *)buf = 136446978;
              int v83 = "_http_safe_append";
              __int16 v84 = 2082;
              BOOL v85 = "*remaining";
              uint64_t v86 = 2048;
              BOOL v87 = a3;
              nw_endpoint_t v88 = 2048;
              os_log_type_t v89 = v71;
              _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v18 + 24) = 0LL;
        }

        v17 += a3;
        goto LABEL_23;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      v67 = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      __int16 v45 = __src;
      __int16 v72 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (v72)
      {
        *(_DWORD *)buf = 136446466;
        int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        BOOL v85 = v67;
        v69 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_143;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null data";
LABEL_208:
          _os_log_impl(&dword_181A5C000, v44, v45, v46, buf, 0xCu);
        }

        if (v35) {
          free(v35);
        }
        os_log_type_t v16 = 0LL;
        goto LABEL_15;
      }

      if (!v80)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        id v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          v38 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = (os_log_s *)__nwlog_obj();
      id v37 = type;
      __int16 v58 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          v38 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        BOOL v85 = backtrace_string;
        uint64_t v59 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_124:
        _os_log_impl(&dword_181A5C000, v36, v37, v59, buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_195;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  int v83 = "_http_vle_encode";
  __int16 v84 = 2048;
  BOOL v85 = (const char *)a3;
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  free(v28);
  char v29 = *(void *)(a1 + 32);
  os_log_type_t v11 = a1 + 32;
  os_log_type_t v16 = *(char **)(*(void *)(v29 + 8) + 24LL);
  os_log_type_t v13 = v11 + 8;
LABEL_15:
  *(void *)(*(void *)(*(void *)v11 + 8LL) + 24LL) = v16;
  nw_endpoint_t v17 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
  if (!v17)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v83 = "nw_http_fillout_binary_message_inner_block_invoke_2";
    uint64_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v80 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v32 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor";
LABEL_183:
      _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
      goto LABEL_184;
    }

    if (!v80)
    {
      BOOL v32 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }

    __int16 v51 = (char *)__nw_create_backtrace_string();
    BOOL v32 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v33 = type;
    size_t v52 = os_log_type_enabled(v32, type);
    if (!v51)
    {
      if (!v52) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }

    if (!v52) {
      goto LABEL_107;
    }
LABEL_106:
    *(_DWORD *)buf = 136446466;
    int v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    __int16 v84 = 2082;
    BOOL v85 = v51;
    _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
    goto LABEL_107;
  }

  if (a3)
  {
    if (a2)
    {
      __int16 v18 = *(void *)(*(void *)v13 + 8LL);
      if (*(void *)(v18 + 24) >= a3)
      {
        memcpy(v17, a2, a3);
        char v19 = *(void *)(v18 + 24);
        *(void *)(v18 + 24) = v19 - a3;
        if (v19 < a3)
        {
          if (gLogDatapath)
          {
            __int16 v70 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              BOOL v71 = *(void *)(v18 + 24);
              *(_DWORD *)buf = 136446978;
              int v83 = "_http_safe_append";
              __int16 v84 = 2082;
              BOOL v85 = "*remaining";
              uint64_t v86 = 2048;
              BOOL v87 = a3;
              nw_endpoint_t v88 = 2048;
              os_log_type_t v89 = v71;
              _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v18 + 24) = 0LL;
        }

        v17 += a3;
        goto LABEL_23;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      v67 = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      __int16 v45 = __src;
      __int16 v72 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (v72)
      {
        *(_DWORD *)buf = 136446466;
        int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        BOOL v85 = v67;
        v69 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_143;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null data";
LABEL_208:
          _os_log_impl(&dword_181A5C000, v44, v45, v46, buf, 0xCu);
        }

        if (v35) {
          free(v35);
        }
        os_log_type_t v16 = 0LL;
        goto LABEL_15;
      }

      if (!v80)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        id v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          v38 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = (os_log_s *)__nwlog_obj();
      id v37 = type;
      __int16 v58 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          v38 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        BOOL v85 = backtrace_string;
        uint64_t v59 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_124:
        _os_log_impl(&dword_181A5C000, v36, v37, v59, buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_195;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  int v83 = "_http_vle_encode";
  __int16 v84 = 2048;
  BOOL v85 = (const char *)a3;
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  free(v28);
  char v29 = *(void *)(a1 + 32);
  os_log_type_t v11 = a1 + 32;
  os_log_type_t v16 = *(char **)(*(void *)(v29 + 8) + 24LL);
  os_log_type_t v13 = v11 + 8;
LABEL_15:
  *(void *)(*(void *)(*(void *)v11 + 8LL) + 24LL) = v16;
  nw_endpoint_t v17 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
  if (!v17)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke_2";
    uint64_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v80 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v32 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor";
LABEL_183:
      _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
      goto LABEL_184;
    }

    if (!v80)
    {
      BOOL v32 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }

    __int16 v51 = (char *)__nw_create_backtrace_string();
    BOOL v32 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v33 = type;
    size_t v52 = os_log_type_enabled(v32, type);
    if (!v51)
    {
      if (!v52) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      int v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      uint64_t v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }

    if (!v52) {
      goto LABEL_107;
    }
LABEL_106:
    *(_DWORD *)buf = 136446466;
    int v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
    __int16 v84 = 2082;
    BOOL v85 = v51;
    _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
    goto LABEL_107;
  }

  if (a3)
  {
    if (a2)
    {
      __int16 v18 = *(void *)(*(void *)v13 + 8LL);
      if (*(void *)(v18 + 24) >= a3)
      {
        memcpy(v17, a2, a3);
        char v19 = *(void *)(v18 + 24);
        *(void *)(v18 + 24) = v19 - a3;
        if (v19 < a3)
        {
          if (gLogDatapath)
          {
            __int16 v70 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              BOOL v71 = *(void *)(v18 + 24);
              *(_DWORD *)buf = 136446978;
              int v83 = "_http_safe_append";
              __int16 v84 = 2082;
              BOOL v85 = "*remaining";
              uint64_t v86 = 2048;
              BOOL v87 = a3;
              nw_endpoint_t v88 = 2048;
              os_log_type_t v89 = v71;
              _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v18 + 24) = 0LL;
        }

        v17 += a3;
        goto LABEL_23;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      v67 = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      __int16 v45 = __src;
      __int16 v72 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_208;
        }

        goto LABEL_209;
      }

      if (v72)
      {
        *(_DWORD *)buf = 136446466;
        int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        BOOL v85 = v67;
        v69 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_143;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v83 = "_http_safe_append";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        __int16 v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          int v83 = "_http_safe_append";
          os_log_type_t v46 = "%{public}s called with null data";
LABEL_208:
          _os_log_impl(&dword_181A5C000, v44, v45, v46, buf, 0xCu);
        }

    if (v66) {
      free(v66);
    }
    uint64_t v6 = (unsigned __int16 *)(a1 + 736);
    goto LABEL_198;
  }

  if ((v4 & 1) == 0)
  {
    BOOL v12 = (os_log_s *)__nwlog_obj();
    result = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    char v14 = *(_DWORD *)(*(void *)(a1 + 336) + 1280LL);
    os_log_type_t v15 = *(void **)(a1 + 240);
    os_log_type_t v16 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = a1 + 636;
    *(_WORD *)&buf[22] = 2080;
    id v427 = (__n128 (*)(uint64_t, uint64_t))" ";
    LOWORD(v428) = 1024;
    *(_DWORD *)((char *)&v428 + 2) = v14;
    HIWORD(v428) = 2048;
    v429 = v15;
    *(_WORD *)v430 = 1024;
    *(_DWORD *)&v430[2] = v16;
    _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> called, state %u - already sending headers",  buf,  0x36u);
  }

  return 0LL;
}

                free(v95);
                if (!v83) {
                  goto LABEL_431;
                }
                goto LABEL_430;
              }

              if (v157)
              {
                *(_DWORD *)address = 136447235;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v274;
                address[9] = 2113;
                *(void *)&address[10] = v8;
                address[14] = 2114;
                *(void *)&address[15] = v75;
                v284 = 1024;
                id v285 = v135;
                _os_log_impl( &dword_181A5C000,  v96,  v156,  "%{public}s bind(%d, %{private}@) %{public}@ failed %{darwin.errno}d, no backtrace",  (uint8_t *)address,  0x2Cu);
              }

LABEL_193:
    if (v139) {
      free(v139);
    }
    goto LABEL_195;
  }

  uint64_t v6 = v5;
LABEL_197:
  _Block_object_dispose(&v161, 8);

  return (NSString *)v6;
}

          if (!v67) {
            goto LABEL_141;
          }
          goto LABEL_194;
        }

        __nwlog_obj();
        v65 = (void *)objc_claimAutoreleasedReturnValue();
        char v66 = networkd_privileged_result_to_string(v45);
        *(_DWORD *)buf = 136446722;
        unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
        os_log_type_t v110 = 2048;
        *(void *)BOOL v111 = v45;
        *(_WORD *)&v111[8] = 2082;
        *(void *)&v111[10] = v66;
        v67 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint64_t v106 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v69 = type;
          if (os_log_type_enabled(v68, type))
          {
            *(_DWORD *)buf = 136446722;
            unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
            os_log_type_t v110 = 2048;
            *(void *)BOOL v111 = v45;
            *(_WORD *)&v111[8] = 2082;
            *(void *)&v111[10] = v66;
            _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s received internal failure result code: [%lld] %{public}s",  buf,  0x20u);
          }
        }

        else if (v106)
        {
          int v79 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v80 = type;
          id v81 = os_log_type_enabled(v68, type);
          if (v79)
          {
            if (v81)
            {
              *(_DWORD *)buf = 136446978;
              unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
              os_log_type_t v110 = 2048;
              *(void *)BOOL v111 = v45;
              *(_WORD *)&v111[8] = 2082;
              *(void *)&v111[10] = v66;
              unint64_t v112 = 2082;
              v113 = v79;
              _os_log_impl( &dword_181A5C000,  v68,  v80,  "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v79);
            goto LABEL_193;
          }

          if (v81)
          {
            *(_DWORD *)buf = 136446722;
            unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
            os_log_type_t v110 = 2048;
            *(void *)BOOL v111 = v45;
            *(_WORD *)&v111[8] = 2082;
            *(void *)&v111[10] = v66;
            _os_log_impl( &dword_181A5C000,  v68,  v80,  "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v87 = type;
          if (os_log_type_enabled(v68, type))
          {
            *(_DWORD *)buf = 136446722;
            unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
            os_log_type_t v110 = 2048;
            *(void *)BOOL v111 = v45;
            *(_WORD *)&v111[8] = 2082;
            *(void *)&v111[10] = v66;
            _os_log_impl( &dword_181A5C000,  v68,  v87,  "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded",  buf,  0x20u);
          }
        }

        goto LABEL_193;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v19 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
      uint64_t v20 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint64_t v106 = 0;
      if (__nwlog_fault(v20, &type, &v106))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v21 = (os_log_s *)(id)gLogObj;
          BOOL v22 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
            _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s received NULL response", buf, 0xCu);
          }
        }

        else if (v106)
        {
          char v29 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v21 = (os_log_s *)(id)gLogObj;
          uint64_t v30 = type;
          uint64_t v31 = os_log_type_enabled(v21, type);
          if (v29)
          {
            if (v31)
            {
              *(_DWORD *)buf = 136446466;
              unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
              os_log_type_t v110 = 2082;
              *(void *)BOOL v111 = v29;
              _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s received NULL response, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v29);
            if (!v20) {
              goto LABEL_82;
            }
            goto LABEL_81;
          }

          if (v31)
          {
            *(_DWORD *)buf = 136446210;
            unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
            _os_log_impl(&dword_181A5C000, v21, v30, "%{public}s received NULL response, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v21 = (os_log_s *)(id)gLogObj;
          uint64_t v39 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
            _os_log_impl( &dword_181A5C000,  v21,  v39,  "%{public}s received NULL response, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v20)
      {
LABEL_82:
        nw_endpoint_t v53 = 0LL;
LABEL_181:

LABEL_182:
        return v53;
      }

  if (v69) {
    free(v69);
  }
}

                goto LABEL_197;
              }

              if (!v160)
              {
                __nwlog_obj();
                BOOL v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                id v105 = type;
                if (os_log_type_enabled(v85, type))
                {
                  *(_DWORD *)buf = 136446210;
                  v163 = "nw_parameters_create_secure_http_messaging";
                  _os_log_impl( &dword_181A5C000,  v85,  v105,  "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded",  buf,  0xCu);
                }

                goto LABEL_193;
              }

              os_log_type_t v94 = __nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v96 = type;
              BOOL v97 = os_log_type_enabled(v95, type);
              uint64_t v153 = (char *)v94;
              if (v94)
              {
                if (v97)
                {
                  *(_DWORD *)buf = 136446466;
                  v163 = "nw_parameters_create_secure_http_messaging";
                  v164 = 2082;
                  v165 = (char *)v94;
                  _os_log_impl( &dword_181A5C000,  v95,  v96,  "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                if (!v88)
                {
LABEL_195:
                  uint64_t v30 = 0LL;
                  goto LABEL_104;
                }

                        if (!v88) {
                          goto LABEL_91;
                        }
LABEL_194:
                        free(v88);
                        goto LABEL_91;
                      }

                      __nwlog_obj();
                      os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      unint64_t v112 = v123;
                      if (os_log_type_enabled(v89, v123))
                      {
                        v113 = (const char *)*((void *)v46 + 2);
                        if (!v113) {
                          v113 = "invalid";
                        }
                        *(_DWORD *)buf = 136446722;
                        v129 = "__nw_protocol_updated_path";
                        uint64_t v130 = 2082;
                        id_str = (char *)v113;
                        v132 = 2048;
                        v133 = v46;
                        _os_log_impl( &dword_181A5C000,  v89,  v112,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded",  buf,  0x20u);
                      }
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    os_log_type_t v102 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 136446210;
                    v129 = "__nw_protocol_updated_path";
                    nw_endpoint_t v88 = (char *)_os_log_send_and_compose_impl();

                    id v123 = OS_LOG_TYPE_ERROR;
                    __int16 v122 = 0;
                    if (v123 == OS_LOG_TYPE_FAULT)
                    {
                      __nwlog_obj();
                      os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v103 = v123;
                      if (os_log_type_enabled(v89, v123))
                      {
                        *(_DWORD *)buf = 136446210;
                        v129 = "__nw_protocol_updated_path";
                        _os_log_impl(&dword_181A5C000, v89, v103, "%{public}s called with null path", buf, 0xCu);
                      }
                    }

                    else if (v122)
                    {
                      unint64_t v109 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v110 = v123;
                      BOOL v111 = os_log_type_enabled(v89, v123);
                      if (v109)
                      {
                        if (v111)
                        {
                          *(_DWORD *)buf = 136446466;
                          v129 = "__nw_protocol_updated_path";
                          uint64_t v130 = 2082;
                          id_str = v109;
                          _os_log_impl( &dword_181A5C000,  v89,  v110,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v109);
                        if (!v88) {
                          goto LABEL_91;
                        }
                        goto LABEL_194;
                      }

                      if (v111)
                      {
                        *(_DWORD *)buf = 136446210;
                        v129 = "__nw_protocol_updated_path";
                        _os_log_impl( &dword_181A5C000,  v89,  v110,  "%{public}s called with null path, no backtrace",  buf,  0xCu);
                      }
                    }

                    else
                    {
                      __nwlog_obj();
                      os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      char v115 = v123;
                      if (os_log_type_enabled(v89, v123))
                      {
                        *(_DWORD *)buf = 136446210;
                        v129 = "__nw_protocol_updated_path";
                        _os_log_impl( &dword_181A5C000,  v89,  v115,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
                      }
                    }
                  }

                  goto LABEL_193;
                }
              }

              else
              {
              }
            }

            else if (nw_endpoint_handler_get_minimize_logging(v9))
            {
              if (v11[79] != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              __int16 v45 = (id)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)v45, OS_LOG_TYPE_DEBUG))
              {
                id_string = nw_endpoint_handler_get_id_string(v119);
                BOOL v96 = nw_endpoint_handler_dry_run_string(v119);
                BOOL v97 = nw_endpoint_handler_copy_endpoint(v119);
                logging_description = nw_endpoint_get_logging_description(v97);
                os_log_type_t v99 = nw_endpoint_handler_state_string(v119);
                os_log_type_t v100 = nw_endpoint_handler_mode_string(v119);
                nw_endpoint_t v101 = nw_endpoint_handler_copy_current_path(v119);
                *(_DWORD *)buf = 136447746;
                v129 = "nw_endpoint_handler_add_extra_interface_option";
                uint64_t v130 = 2082;
                id_str = (char *)id_string;
                v132 = 2082;
                v133 = v96;
                v134 = 2082;
                v135 = (void *)logging_description;
                v136 = 2082;
                nw_endpoint_t v137 = v99;
                v138 = 2082;
                uint64_t v139 = v100;
                v140 = 2114;
                int v141 = v101;
                _os_log_impl( &dword_181A5C000,  (os_log_t)v45,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping adding extra interface option, no active flow registration",  buf,  0x48u);
              }
            }

            else
            {
              uint64_t v55 = v9;
              __int16 v56 = (*((_BYTE *)v55 + 268) & 0x20) == 0;

              if (!v56)
              {
LABEL_118:

                goto LABEL_119;
              }

              if (v11[79] != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              __int16 v45 = (id)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)v45, OS_LOG_TYPE_INFO))
              {
                nw_endpoint_t v57 = v55;

                __int16 v58 = v57;
                uint64_t v59 = (*((_BYTE *)v55 + 268) & 1) == 0;

                if (v59) {
                  __int16 v60 = "";
                }
                else {
                  __int16 v60 = "dry-run ";
                }
                id v61 = nw_endpoint_handler_copy_endpoint(v58);
                os_log_type_t v62 = nw_endpoint_get_logging_description(v61);
                v63 = v58;
                os_log_type_t v64 = v63;
                v65 = v63[30];
                else {
                  char v66 = off_189BBBBF0[v65];
                }

                BOOL v73 = v64;
                __int16 v74 = "path";
                switch(v119->mode)
                {
                  case 0:
                    break;
                  case 1:
                    __int16 v74 = "resolver";
                    break;
                  case 2:
                    __int16 v74 = nw_endpoint_flow_mode_string(v73[31]);
                    break;
                  case 3:
                    __int16 v74 = "proxy";
                    break;
                  case 4:
                    __int16 v74 = "fallback";
                    break;
                  case 5:
                    __int16 v74 = "transform";
                    break;
                  default:
                    __int16 v74 = "unknown-mode";
                    break;
                }

                __int16 v118 = v74;

                BOOL v75 = v73;
                os_unfair_lock_lock((os_unfair_lock_t)v75 + 28);
                __int16 v76 = v75[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v75 + 28);

                *(_DWORD *)buf = 136447746;
                v129 = "nw_endpoint_handler_add_extra_interface_option";
                uint64_t v130 = 2082;
                id_str = v57->id_str;
                v132 = 2082;
                v133 = v60;
                v134 = 2082;
                v135 = (void *)v62;
                v136 = 2082;
                nw_endpoint_t v137 = v66;
                v138 = 2082;
                uint64_t v139 = v118;
                v140 = 2114;
                int v141 = v76;
                _os_log_impl( &dword_181A5C000,  (os_log_t)v45,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping adding extra interface option, no active flow registration",  buf,  0x48u);
              }
            }

  uint64_t v130 = (char *)a1->handle;
  if (!v130)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
    uint64_t v153 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(aBlock[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v154 = (os_log_s *)__nwlog_obj();
      v155 = type[0];
      if (!os_log_type_enabled(v154, type[0])) {
        goto LABEL_422;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
      v156 = "%{public}s called with null handle";
      goto LABEL_421;
    }

    if (!LOBYTE(aBlock[0]))
    {
      uint64_t v154 = (os_log_s *)__nwlog_obj();
      v155 = type[0];
      if (!os_log_type_enabled(v154, type[0])) {
        goto LABEL_422;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
      v156 = "%{public}s called with null handle, backtrace limit exceeded";
      goto LABEL_421;
    }

    v164 = (char *)__nw_create_backtrace_string();
    uint64_t v154 = (os_log_s *)__nwlog_obj();
    v155 = type[0];
    v165 = os_log_type_enabled(v154, type[0]);
    if (!v164)
    {
      if (!v165) {
        goto LABEL_422;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
      v156 = "%{public}s called with null handle, no backtrace";
      goto LABEL_421;
    }

    if (v165)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v164;
      _os_log_impl( &dword_181A5C000,  v154,  v155,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v164);
LABEL_422:
    if (!v153) {
      goto LABEL_424;
    }
LABEL_423:
    free(v153);
    goto LABEL_424;
  }

  v131 = *((_DWORD *)v130 + 6);
  if (v131 == 2)
  {
    v133 = *((void *)v130 + 1);
    if (v133)
    {
      v132 = (uint64_t *)(v133 + 256);
      goto LABEL_199;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
    uint64_t v153 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(aBlock[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v154 = (os_log_s *)__nwlog_obj();
      v155 = type[0];
      if (!os_log_type_enabled(v154, type[0])) {
        goto LABEL_422;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
      v156 = "%{public}s called with null handle->http1_stream";
      goto LABEL_421;
    }

    if (!LOBYTE(aBlock[0]))
    {
      uint64_t v154 = (os_log_s *)__nwlog_obj();
      v155 = type[0];
      if (!os_log_type_enabled(v154, type[0])) {
        goto LABEL_422;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
      v156 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_421;
    }

    v186 = (char *)__nw_create_backtrace_string();
    uint64_t v154 = (os_log_s *)__nwlog_obj();
    v155 = type[0];
    v187 = os_log_type_enabled(v154, type[0]);
    if (v186)
    {
      if (v187)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v186;
        _os_log_impl( &dword_181A5C000,  v154,  v155,  "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v186);
      if (!v153) {
        goto LABEL_424;
      }
      goto LABEL_423;
    }

    if (v187)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_connection_for_protocol";
      v156 = "%{public}s called with null handle->http1_stream, no backtrace";
LABEL_421:
      _os_log_impl(&dword_181A5C000, v154, v155, v156, buf, 0xCu);
      goto LABEL_422;
    }

    goto LABEL_422;
  }

  if (v131 != 3)
  {
LABEL_424:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
    v149 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(aBlock[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v150 = (os_log_s *)gLogObj;
      v151 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_440;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
      v152 = "%{public}s called with null http1_connection";
      goto LABEL_439;
    }

    if (!LOBYTE(aBlock[0]))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v150 = (os_log_s *)gLogObj;
      v151 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_440;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
      v152 = "%{public}s called with null http1_connection, backtrace limit exceeded";
      goto LABEL_439;
    }

    v161 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v150 = (os_log_s *)gLogObj;
    v151 = type[0];
    id v242 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!v161)
    {
      if (!v242) {
        goto LABEL_440;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
      v152 = "%{public}s called with null http1_connection, no backtrace";
      goto LABEL_439;
    }

    if (!v242)
    {
LABEL_433:
      free(v161);
      if (!v149) {
        return;
      }
LABEL_441:
      free(v149);
      return;
    }

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v161;
    v163 = "%{public}s called with null http1_connection, dumping backtrace:%{public}s";
LABEL_432:
    _os_log_impl(&dword_181A5C000, v150, v151, v163, buf, 0x16u);
    goto LABEL_433;
  }

  v132 = (uint64_t *)(v130 + 16);
LABEL_199:
  v134 = *v132;
  if (!*v132) {
    goto LABEL_424;
  }
  v135 = *(void *)(v134 + 488);
  if (v135) {
    nw_protocol_connected(*(void **)(v135 + 48), (uint64_t)v4);
  }
  if (*(nw_protocol **)(v134 + 32) == v4)
  {
    if (!(*(_BYTE *)(v134 + 158) & 1 | (gLogDatapath == 0)))
    {
      v170 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v170, OS_LOG_TYPE_DEBUG))
      {
        v171 = *(void *)(v134 + 488);
        BOOL v172 = *(_DWORD *)(*(void *)(v134 + 480) + 372LL);
        v173 = *(_DWORD *)(v134 + 860);
        if (v171) {
          LODWORD(v171) = *(_DWORD *)(v171 + 424);
        }
        identifier = v4->identifier;
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v134 + 74;
        *(_WORD *)&buf[22] = 2080;
        v268 = (uint64_t)" ";
        v269 = 1024;
        *(_DWORD *)id v270 = v172;
        *(_WORD *)&v270[4] = 1024;
        *(_DWORD *)&v270[6] = v173;
        LOWORD(v271) = 1024;
        *(_DWORD *)((char *)&v271 + 2) = v171;
        HIWORD(v271) = 2080;
        *(void *)v272 = identifier;
        _os_log_impl( &dword_181A5C000,  v170,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> connected protocol %s is our output_handler, forwarding",  buf,  0x3Cu);
      }
    }

    *(_WORD *)(v134 + 872) |= 0x40u;
    int v141 = *(void *)(v134 + 488);
    if (v141)
    {
      *(_WORD *)(v141 + 428) |= 0x4000u;
      char v142 = *(void **)(v141 + 352);
      v258[0] = MEMORY[0x1895F87A8];
      v258[1] = 0x40000000LL;
      v258[2] = ___ZL27nw_protocol_http1_connectedP11nw_protocolS0__block_invoke;
      v258[3] = &__block_descriptor_tmp_86_41072;
      v258[4] = v141;
      nw_http_transaction_metadata_set_event_handler(v142, v258);
      v143 = *(void *)(v134 + 488);
      if (v143) {
        v144 = *(void **)(v143 + 48);
      }
      else {
        v144 = 0LL;
      }
      nw_protocol_connected(v144, v143);
    }
  }

  else if (!(*(_BYTE *)(v134 + 158) & 1 | (gLogDatapath == 0)))
  {
    v136 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
    {
      nw_endpoint_t v137 = *(void *)(v134 + 488);
      v138 = *(_DWORD *)(*(void *)(v134 + 480) + 372LL);
      uint64_t v139 = *(_DWORD *)(v134 + 860);
      if (v137) {
        LODWORD(v137) = *(_DWORD *)(v137 + 424);
      }
      v140 = v4->identifier;
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_connected";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v134 + 74;
      *(_WORD *)&buf[22] = 2080;
      v268 = (uint64_t)" ";
      v269 = 1024;
      *(_DWORD *)id v270 = v138;
      *(_WORD *)&v270[4] = 1024;
      *(_DWORD *)&v270[6] = v139;
      LOWORD(v271) = 1024;
      *(_DWORD *)((char *)&v271 + 2) = v137;
      HIWORD(v271) = 2080;
      *(void *)v272 = v140;
      _os_log_impl( &dword_181A5C000,  v136,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> connected protocol %s is not our output_handler, ignoring",  buf,  0x3Cu);
    }
  }

  if (v67) {
    free(v67);
  }
}

      if (!v62) {
        return 0LL;
      }
      id v61 = (char *)v62;
      goto LABEL_122;
    }

    if (!v99)
    {
      v63 = (os_log_s *)__nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_192;
      }

      goto LABEL_193;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v63 = (os_log_s *)__nwlog_obj();
    os_log_type_t v64 = type;
    __int16 v82 = os_log_type_enabled(v63, type);
    if (!backtrace_string)
    {
      if (v82)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_192;
      }

      goto LABEL_193;
    }

    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v102 = "nw_protocol_http2_connect";
      os_log_type_t v103 = 2082;
      BOOL v104 = backtrace_string;
      __int16 v80 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_166;
    }

void sub_181AE6C38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,id a60,char a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a55, 8);
  _Unwind_Resume(a1);
}

BOOL nw_path_is_viable(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  unsigned __int16 v2 = v1;
  if (v1)
  {
    if ((v1[474] & 8) == 0)
    {
      uint64_t v3 = v1;
      if (nw_path_uses_nexus_internal(v3, 0)
        && (uint64_t nexus_agent = nw_path_get_nexus_agent(v3, 0), *(_DWORD *)(nexus_agent + 212) > 0xCBu))
      {
        unsigned int v5 = *(_DWORD *)(nexus_agent + 216);

        if (v5 <= 4 && (v5 & 0xFFFFFFFD) != 0) {
          goto LABEL_7;
        }
      }

      else
      {
      }

      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000LL;
      char v21 = 0;
      flows = (unsigned __int8 *)v3->flows;
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 3221225472LL;
      v17[2] = __nw_path_is_viable_block_invoke;
      v17[3] = &unk_189BC50D0;
      v17[4] = buf;
      nw_array_apply(flows, (uint64_t)v17);
      BOOL v6 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
      _Block_object_dispose(buf, 8);
      goto LABEL_10;
    }

void sub_181AE7048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_has_dns(nw_path_t path)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v1 = path;
  unsigned __int16 v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_has_dns";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_has_dns";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_has_dns";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_has_dns";
          _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_has_dns";
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181AE7364(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_resolver_config *nw_resolver_config_create_with_dictionary(void *a1)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  unsigned __int16 v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v40 = "nw_resolver_config_create_with_dictionary";
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();

    v36[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v36[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null dictionary", buf, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = v36[0];
      BOOL v29 = os_log_type_enabled(v23, v36[0]);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          id v40 = "nw_resolver_config_create_with_dictionary";
          __int16 v41 = 2082;
          BOOL v42 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s called with null dictionary, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v22) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_181A5C000, v23, v28, "%{public}s called with null dictionary, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl( &dword_181A5C000,  v23,  v33,  "%{public}s called with null dictionary, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_61;
  }

  if (object_getClass(v1) != (Class)MEMORY[0x1895F9250])
  {
    __nwlog_obj();
    nw_endpoint_t v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v40 = "nw_resolver_config_create_with_dictionary";
    uint64_t v22 = (char *)_os_log_send_and_compose_impl();

    v36[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v36[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary))",  buf,  0xCu);
      }
    }

    else if (type)
    {
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = v36[0];
      BOOL v32 = os_log_type_enabled(v23, v36[0]);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          id v40 = "nw_resolver_config_create_with_dictionary";
          __int16 v41 = 2082;
          BOOL v42 = v30;
          _os_log_impl( &dword_181A5C000,  v23,  v31,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
LABEL_62:
        if (!v22)
        {
LABEL_64:
          uint64_t v3 = 0LL;
          goto LABEL_28;
        }

void sub_181AE7B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_set_provider_description(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  BOOL v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_provider_description_block_invoke;
    v14[3] = &unk_189BC66E8;
    uint64_t v5 = (os_unfair_lock_s *)v3;
    v14[4] = v5;
    v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_provider_description_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_resolver_config_set_provider_description";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_resolver_config_set_provider_description";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_resolver_config_set_provider_description";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181AE810C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_provider_description_block_invoke(uint64_t a1)
{
}

BOOL nw_path_is_expensive(nw_path_t path)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    __int16 v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_path_is_expensive";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v20, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_path_is_expensive";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v30 = "nw_path_is_expensive";
            __int16 v31 = 2082;
            BOOL v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_path_is_expensive";
          _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_path_is_expensive";
          _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

unsigned __int8 *nw_path_copy_connected_interface(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    id v3 = v1[11];
    if (v3)
    {
      BOOL v4 = v3;
    }

    else
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000LL;
      __int16 v19 = __Block_byref_object_copy__67543;
      uint64_t v20 = __Block_byref_object_dispose__67544;
      id v21 = 0LL;
      uint64_t v5 = v1[9];
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 3221225472LL;
      v15[2] = __nw_path_copy_connected_interface_block_invoke;
      v15[3] = &unk_189BC50D0;
      v15[4] = buf;
      nw_array_apply(v5, (uint64_t)v15);
      BOOL v4 = (unsigned __int8 *)*(id *)(*(void *)&buf[8] + 40LL);
      _Block_object_dispose(buf, 8);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

BOOL nw_path_is_constrained(nw_path_t path)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    __int16 v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_path_is_constrained";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v20, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_path_is_constrained";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v30 = "nw_path_is_constrained";
            __int16 v31 = 2082;
            BOOL v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_path_is_constrained";
          _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_path_is_constrained";
          _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

BOOL nw_path_should_fallback(void *a1, char a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    int v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "nw_path_should_fallback";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v19 = "nw_path_should_fallback";
            __int16 v20 = 2082;
            id v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v19 = "nw_path_should_fallback";
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181AE8DE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_no_fallback(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 108LL) >> 5) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_no_fallback";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_no_fallback";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_no_fallback";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_fallback_applied(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 108LL) >> 11) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_fallback_applied";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_fallback_applied";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_path_allows_multipath(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_path_allows_multipath";
    __int16 v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v6, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            char v16 = "nw_path_allows_multipath";
            __int16 v17 = 2082;
            BOOL v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_allows_multipath";
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181AE9610(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_should_start_fallback(NWConcrete_nw_endpoint_handler *a1)
{
  id v1 = a1;
  nw_path_t v2 = v1;
  BOOL v4 = v1->state == 1
    && ((int mode = v1->mode) == 0 || mode == 2 && (nw_endpoint_flow_get_is_leaf_handler(v1->mode_handler) & 1) == 0)
    && (*((_BYTE *)v2 + 268) & 1) == 0
    && nw_path_should_fallback(v2->current_path, 0);

  return v4;
}

void sub_181AE96B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_get_is_leaf_handler(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[32] >> 1) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_endpoint_flow_get_is_leaf_handler";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_endpoint_flow_get_is_leaf_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_endpoint_flow_get_is_leaf_handler";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null flow, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_endpoint_flow_get_is_leaf_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_endpoint_flow_get_is_leaf_handler";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

BOOL nw_endpoint_handler_should_transform(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  BOOL v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v27 = "nw_endpoint_handler_should_transform";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        char v27 = "nw_endpoint_handler_should_transform";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (!v24)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        char v27 = "nw_endpoint_handler_should_transform";
        _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        char v27 = "nw_endpoint_handler_should_transform";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      char v27 = "nw_endpoint_handler_should_transform";
      __int16 v28 = 2082;
      BOOL v29 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_24;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v27 = "nw_endpoint_handler_should_transform";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        char v27 = "nw_endpoint_handler_should_transform";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null parameters", buf, 0xCu);
      }

LABEL_103:
  uint64_t v86 = nw_endpoint_handler_get_minimize_logging(v42);
  BOOL v87 = nw_endpoint_handler_get_logging_disabled(v42);
  v227 = v43;
  if (v86)
  {
    if ((v87 & 1) != 0) {
      goto LABEL_112;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    nw_endpoint_t v88 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
    {
      v197 = nw_endpoint_handler_get_id_string(v42);
      v198 = nw_endpoint_handler_dry_run_string(v42);
      char v199 = nw_endpoint_handler_copy_endpoint(v42);
      uint64_t v200 = nw_endpoint_get_logging_description(v199);
      uint64_t v201 = nw_endpoint_handler_state_string(v42);
      id v202 = nw_endpoint_handler_mode_string(v42);
      v203 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v42);
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow startWithHandler:]";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v197;
      *(_WORD *)&buf[22] = 2082;
      v240 = v198;
      *(_WORD *)v241 = 2082;
      *(void *)&v241[2] = v200;
      id v242 = 2082;
      v243 = v201;
      v244 = 2082;
      uint64_t v245 = v202;
      int v246 = 2114;
      char v247 = v203;
      _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Multilayer packet logging enabled",  buf,  0x48u);
    }

    goto LABEL_111;
  }

  if ((v87 & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    nw_endpoint_t v88 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v88, OS_LOG_TYPE_INFO))
    {
      os_log_type_t v89 = nw_endpoint_handler_get_id_string(v42);
      os_log_type_t v90 = nw_endpoint_handler_dry_run_string(v42);
      logb = v88;
      os_log_type_t v91 = nw_endpoint_handler_copy_endpoint(v42);
      id v92 = nw_endpoint_get_logging_description(v91);
      id v93 = nw_endpoint_handler_state_string(v42);
      os_log_type_t v94 = nw_endpoint_handler_mode_string(v42);
      os_log_type_t v95 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v42);
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow startWithHandler:]";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v89;
      *(_WORD *)&buf[22] = 2082;
      v240 = v90;
      *(_WORD *)v241 = 2082;
      *(void *)&v241[2] = v92;
      id v242 = 2082;
      v243 = v93;
      v244 = 2082;
      uint64_t v245 = v94;
      int v246 = 2114;
      char v247 = v95;
      _os_log_impl( &dword_181A5C000,  logb,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Multilayer packet logging enabled",  buf,  0x48u);

      nw_endpoint_t v88 = logb;
    }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v102 = (id)gLogObj;
  if (mode > 5) {
    os_log_type_t v103 = "unknown-mode";
  }
  else {
    os_log_type_t v103 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  uint64_t v139 = "nw_endpoint_flow_initialize_protocol";
  v140 = 2082;
  int v141 = (void *)v103;
  char v142 = 2082;
  v143 = "flow";
  BOOL v104 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v136 = 0;
  if (!__nwlog_fault((const char *)v104, &type, &v136))
  {
LABEL_135:
    if (!v104) {
      goto LABEL_137;
    }
LABEL_136:
    free(v104);
    goto LABEL_137;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v105 = (os_log_s *)(id)gLogObj;
    uint64_t v106 = type;
    if (os_log_type_enabled(v105, type))
    {
      if (mode > 5) {
        unint64_t v107 = "unknown-mode";
      }
      else {
        unint64_t v107 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v139 = "nw_endpoint_flow_initialize_protocol";
      v140 = 2082;
      int v141 = (void *)v107;
      char v142 = 2082;
      v143 = "flow";
      _os_log_impl( &dword_181A5C000,  v105,  v106,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

LABEL_104:
    if (!v31) {
      goto LABEL_93;
    }
    goto LABEL_105;
  }

  if (!v67)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v32 = (os_log_s *)(id)gconnectionLogObj;
    size_t v52 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      nw_endpoint_t v53 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      BOOL v71 = "nw_association_mark_flow_connected";
      __int16 v72 = 2082;
      BOOL v73 = (void *)v53;
      __int16 v74 = 2048;
      BOOL v75 = v28;
      __int16 v76 = 2048;
      BOOL v77 = (char *)v9;
      _os_log_impl( &dword_181A5C000,  v32,  v52,  "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), backtrace limit exceeded",  buf,  0x2Au);
    }

    goto LABEL_103;
  }

  os_log_type_t v44 = __nw_create_backtrace_string();
  if (!v44)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v32 = (os_log_s *)(id)gconnectionLogObj;
    id v54 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      uint64_t v55 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      BOOL v71 = "nw_association_mark_flow_connected";
      __int16 v72 = 2082;
      BOOL v73 = (void *)v55;
      __int16 v74 = 2048;
      BOOL v75 = v28;
      __int16 v76 = 2048;
      BOOL v77 = (char *)v9;
      _os_log_impl( &dword_181A5C000,  v32,  v54,  "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), no backtrace",  buf,  0x2Au);
    }

    goto LABEL_103;
  }

  __int16 v45 = (char *)v44;
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v46 = (os_log_s *)(id)gconnectionLogObj;
  BOOL v47 = v68;
  if (os_log_type_enabled(v46, v68))
  {
    os_log_type_t v48 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136447234;
    BOOL v71 = "nw_association_mark_flow_connected";
    __int16 v72 = 2082;
    BOOL v73 = (void *)v48;
    __int16 v74 = 2048;
    BOOL v75 = v28;
    __int16 v76 = 2048;
    BOOL v77 = (char *)v9;
    __int16 v78 = 2082;
    int v79 = v45;
    _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), dumping backtrace:%{public}s",  buf,  0x34u);
  }

  free(v45);
  if (v31)
  {
LABEL_105:
    __int16 v51 = (char *)v31;
    goto LABEL_92;
  }

  return v111;
}

    if (v41) {
      free(v41);
    }
    uint64_t v59 = (dispatch_queue_s *)v65[25];
    if (v59)
    {
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = __nw_write_request_create_block_invoke;
      block[3] = &unk_189BC8740;
      os_log_type_t v68 = aBlock;
      dispatch_async(v59, block);
    }

    else
    {
      posix_error = nw_error_create_posix_error(22);
      (*((void (**)(id, _DWORD *))aBlock + 2))(aBlock, posix_error);
    }

    goto LABEL_18;
  }

  if (!v13) {
    goto LABEL_20;
  }
  BOOL v14 = (os_unfair_lock_s *)v13;
  if (v14 == (os_unfair_lock_s *)&__block_literal_global_5_41854)
  {

    goto LABEL_20;
  }

  os_log_type_t v15 = v14;
  if (v14 == (os_unfair_lock_s *)&__block_literal_global_4
    || v14 == (os_unfair_lock_s *)&__block_literal_global_3_41839
    || v14 == (os_unfair_lock_s *)&__block_literal_global_41831)
  {

    goto LABEL_15;
  }

  os_unfair_lock_lock(v14 + 28);
  char v16 = BYTE2(v15[29]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v15 + 28);

  if ((v16 & 0x40) != 0)
  {
LABEL_20:
    BOOL v20 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_write_request);
    os_log_type_t v19 = v20;
    if (v20)
    {
      os_log_type_t v17 = v11;
      if (v11) {
        os_log_type_t v21 = v11;
      }
      else {
        os_log_type_t v21 = (void *)MEMORY[0x1895F8AA8];
      }
      p_data = (dispatch_data_t *)&v20->data;
      objc_storeStrong((id *)&v20->data, v21);
      objc_storeStrong((id *)&v19->context, a2);
      objc_storeStrong((id *)&v19->original_message, a3);
      *((_BYTE *)v19 + 12_Block_object_dispose((const void *)(v67 - 152), 8) = *((_BYTE *)v19 + 128) & 0xFE | a4;
      __int16 v23 = _Block_copy(aBlock);
      completion = v19->completion;
      v19->completion = v23;

      objc_storeStrong((id *)&v19->connection, a5);
      v19->qos_class = qos_class_self();
      BOOL v25 = (double *)v12;
      os_log_type_t v26 = v25;
      char v27 = 0.5;
      if (v25 != (double *)&__block_literal_global_5_41854
        && v25 != (double *)&__block_literal_global_4
        && v25 != (double *)&__block_literal_global_3_41839
        && v25 != (double *)&__block_literal_global_41831
        && (*((_BYTE *)v25 + 118) & 1) == 0)
      {
        char v27 = v25[10];
      }

      __int16 v28 = 0;
      v19->relative_priority = v27;
      if (!v17 && a4)
      {
        BOOL v29 = v26;
        __int16 v28 = 0;
        if (v26 != (double *)&__block_literal_global_41831 && v26 != (double *)&__block_literal_global_5_41854)
        {
          __int16 v28 = 8;
        }
      }

      *((_BYTE *)v19 + 12_Block_object_dispose((const void *)(v67 - 152), 8) = *((_BYTE *)v19 + 128) & 0xF7 | v28;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_32859);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled())
      {
        if (*p_data) {
          dispatch_data_get_size(*p_data);
        }
        context = v19->context;
        if (context) {
          nw_content_context_get_is_final(context);
        }
        kdebug_trace();
      }

      uint64_t v30 = v19;
      goto LABEL_62;
    }

    os_log_type_t v17 = v11;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v31 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v72 = "nw_write_request_create";
    BOOL v32 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v32, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = (os_log_s *)(id)gLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v72 = "nw_write_request_create";
          _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed",  buf,  0xCu);
        }
      }

      else if (v69)
      {
        char v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = (os_log_s *)(id)gLogObj;
        BOOL v36 = type;
        char v37 = os_log_type_enabled(v33, type);
        if (v35)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v72 = "nw_write_request_create";
            BOOL v73 = 2082;
            __int16 v74 = v35;
            _os_log_impl( &dword_181A5C000,  v33,  v36,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v35);
          if (!v32) {
            goto LABEL_62;
          }
          goto LABEL_61;
        }

        if (v37)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v72 = "nw_write_request_create";
          _os_log_impl( &dword_181A5C000,  v33,  v36,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = (os_log_s *)(id)gLogObj;
        v38 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v72 = "nw_write_request_create";
          _os_log_impl( &dword_181A5C000,  v33,  v38,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v32)
    {
LABEL_62:

      goto LABEL_63;
    }

    if (v47) {
      free(v47);
    }
    goto LABEL_8;
  }

  BOOL v11 = a1 + 204;
  if ((*(_WORD *)(a1 + 204) & 8) != 0) {
    return;
  }
LABEL_15:
  os_log_type_t v12 = *(void **)(a1 + 168);
  if (v12)
  {
    os_release(v12);
    *(void *)(a1 + 16_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
  }

  if (object)
  {
    *(void *)(a1 + 16_Block_object_dispose((const void *)(v67 - 152), 8) = os_retain(object);
    os_log_type_t v13 = *(unsigned __int16 *)(a1 + 204);
    BOOL v14 = v13 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v13 & 0x20) == 0)
    {
      os_log_type_t v15 = object;
      *(_OWORD *)(a1 + 136) = *((_OWORD *)v15 + 1);

      BOOL v14 = *(unsigned __int16 *)(a1 + 204) | (*(unsigned __int8 *)(a1 + 206) << 16);
    }

    *(_BYTE *)(v11 + 2) = BYTE2(v14);
    *(_WORD *)BOOL v11 = v14 | 8;
  }

  char v16 = a1 + 120;
  os_log_type_t v17 = *(void *)(a1 + 64);
  if (a4) {
    BOOL v18 = 64;
  }
  else {
    BOOL v18 = 0;
  }
  *(_BYTE *)(a1 + 186) = *(_BYTE *)(a1 + 186) & 0xBF | v18;
  if (!v17)
  {
    *(void *)(a1 + 64) = v16;
    *(void *)(a1 + 72) = v16;
    *(void *)(a1 + 120) = 0LL;
    *(void *)(a1 + 12_Block_object_dispose((const void *)(v67 - 152), 8) = a1 + 64;
    return;
  }

  if (v17 != v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    __int16 v60 = "__nw_frame_set_metadata";
    id v61 = 2048;
    os_log_type_t v62 = v17;
    v63 = 2048;
    os_log_type_t v64 = a1 + 120;
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    nw_endpoint_t v57 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v20 = (os_log_s *)gLogObj;
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v60 = "__nw_frame_set_metadata";
      id v61 = 2048;
      os_log_type_t v62 = v17;
      v63 = 2048;
      os_log_type_t v64 = v16;
      os_log_type_t v22 = "%{public}s Existing metadata %p doesn't match expected %p";
      goto LABEL_68;
    }

    if (!v57)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v20 = (os_log_s *)gLogObj;
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v60 = "__nw_frame_set_metadata";
      id v61 = 2048;
      os_log_type_t v62 = v17;
      v63 = 2048;
      os_log_type_t v64 = v16;
      os_log_type_t v22 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
      goto LABEL_68;
    }

    v38 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = (os_log_s *)gLogObj;
    os_log_type_t v21 = type[0];
    uint64_t v39 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446978;
        __int16 v60 = "__nw_frame_set_metadata";
        id v61 = 2048;
        os_log_type_t v62 = v17;
        v63 = 2048;
        os_log_type_t v64 = v16;
        v65 = 2082;
        char v66 = v38;
        _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v38);
      if (!v19) {
        return;
      }
LABEL_71:
      free(v19);
      return;
    }

    if (v39)
    {
      *(_DWORD *)buf = 136446722;
      __int16 v60 = "__nw_frame_set_metadata";
      id v61 = 2048;
      os_log_type_t v62 = v17;
      v63 = 2048;
      os_log_type_t v64 = v16;
      os_log_type_t v22 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
LABEL_68:
      id v40 = v20;
      __int16 v41 = v21;
      BOOL v42 = 32;
LABEL_69:
      _os_log_impl(&dword_181A5C000, v40, v41, v22, buf, v42);
    }

            if (v7)
            {
              __int16 v72 = *((void *)v7 + 3);
              if (v72)
              {
                BOOL v73 = *(void (**)(const char *, char *, uint64_t))(v72 + 8);
                if (v73)
                {
                  __int16 v74 = (void *)*((void *)v7 + 5);
                  if (v74 == &nw_protocol_ref_counted_handle)
                  {
                    __int16 v76 = *((void *)v7 + 11);
                    if (v76) {
                      *((void *)v7 + 11) = v76 + 1;
                    }
                    *(void *)buf = v7;
                    BOOL v75 = buf[8] | 1;
                  }

                  else
                  {
                    *(void *)buf = v7;
                    BOOL v75 = buf[8] & 0xFE;
                  }

                  buf[8] = v75;
                  BOOL v77 = (void *)*((void *)v6 + 52);
                  if (v77 == &nw_protocol_ref_counted_handle)
                  {
                    int v79 = *((void *)v6 + 58);
                    if (v79) {
                      *((void *)v6 + 5_Block_object_dispose((const void *)(v67 - 152), 8) = v79 + 1;
                    }
                    *(void *)os_log_type_t type = (char *)v6 + 376;
                    __int16 v78 = v362 | 1;
                  }

                  else
                  {
                    *(void *)os_log_type_t type = (char *)v6 + 376;
                    __int16 v78 = v362 & 0xFE;
                  }

                  v362 = v78;
                  v73(v7, (char *)v6 + 376, 1LL);
                  if (v77 == &nw_protocol_ref_counted_handle)
                  {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                    if (v74 != &nw_protocol_ref_counted_handle) {
                      goto LABEL_118;
                    }
                  }

                  else if (v74 != &nw_protocol_ref_counted_handle)
                  {
                    goto LABEL_118;
                  }

                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
              }
            }

    goto LABEL_104;
  }

  __int16 v7 = (__int128 *)*((void *)a2 + 2);
  if (v7)
  {
    os_log_type_t v8 = nw_endpoint_copy_registrar_for_identifier(v5, v7, 0);
    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v19 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        logging_description = nw_endpoint_get_logging_description(v6);
        os_log_type_t v21 = (unsigned __int8 *)*((void *)a2 + 2);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&void buf[14] = logging_description;
        *(_WORD *)&buf[22] = 2080;
        unint64_t v112 = v21;
        *(_WORD *)v113 = 2048;
        *(void *)&v113[2] = v21;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %s failed to find registrar, cannot add edges for %s identifier %p",  buf,  0x2Au);
      }

      goto LABEL_54;
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        __int16 v60 = (unsigned __int8 *)*((void *)a2 + 2);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&void buf[14] = v8;
        *(_WORD *)&buf[22] = 2080;
        unint64_t v112 = v60;
        *(_WORD *)v113 = 2048;
        *(void *)&v113[2] = v60;
        _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEBUG,  "%{public}s got registrar %@, adding edges for %s identifier %p",  buf,  0x2Au);
      }
    }

    BOOL v9 = v8;
    os_log_type_t v10 = v6;
    if (*((void *)a2 + 2))
    {
      BOOL v11 = *((void *)a2 + 3);
      if (!v11) {
        goto LABEL_18;
      }
      os_log_type_t v12 = *(void (**)(unsigned __int8 *))(v11 + 136);
      if (!v12) {
        goto LABEL_18;
      }
      v12(a2);
      os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v15 = *((void *)a2 + 2);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&void buf[14] = v9;
        *(_WORD *)&buf[22] = 2048;
        unint64_t v112 = a2;
        *(_WORD *)v113 = 2080;
        *(void *)&v113[2] = v15;
        *(_WORD *)&v113[10] = 2112;
        *(void *)&v113[12] = v13;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s has endpoint %@, adding edges",  buf,  0x34u);
      }

      if (!v13)
      {
LABEL_18:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v22 = *((void *)a2 + 2);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
          *(_WORD *)&buf[12] = 2112;
          *(void *)&void buf[14] = v9;
          *(_WORD *)&buf[22] = 2048;
          unint64_t v112 = a2;
          *(_WORD *)v113 = 2080;
          *(void *)&v113[2] = v22;
          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s does not have endpoint, cannot add edges",  buf,  0x2Au);
        }

        goto LABEL_52;
      }

      char v16 = v13;
      os_log_type_t v17 = (*((_BYTE *)v16 + 231) & 4) == 0;

      if (v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
          *(_WORD *)&buf[12] = 2112;
          *(void *)&void buf[14] = v16;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %@ is not registered, cannot add edges",  buf,  0x16u);
        }

        goto LABEL_52;
      }

      __int16 v23 = *((void *)a2 + 3);
      if (!v23) {
        goto LABEL_37;
      }
      char v24 = *(void (**)(unsigned __int8 *))(v23 + 112);
      if (!v24) {
        goto LABEL_37;
      }
      BOOL v25 = v24(a2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v26 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        char v27 = *((void *)a2 + 2);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&void buf[14] = v9;
        *(_WORD *)&buf[22] = 2048;
        unint64_t v112 = a2;
        *(_WORD *)v113 = 2080;
        *(void *)&v113[2] = v27;
        *(_WORD *)&v113[10] = 2112;
        *(void *)&v113[12] = v25;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s has parameters %@, adding edges",  buf,  0x34u);
      }

      os_log_type_t v103 = (void *)v25;

      if (!v25)
      {
LABEL_37:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v47 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v48 = *((void *)a2 + 2);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
          *(_WORD *)&buf[12] = 2112;
          *(void *)&void buf[14] = v9;
          *(_WORD *)&buf[22] = 2048;
          unint64_t v112 = a2;
          *(_WORD *)v113 = 2080;
          *(void *)&v113[2] = v48;
          _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s does not have parameters, cannot add edges",  buf,  0x2Au);
        }

        goto LABEL_51;
      }

      os_log_type_t v102 = v9;
      nw_endpoint_t v101 = v16;
      if (a3)
      {
        if (a3 == 1)
        {
          os_log_type_t v99 = v10;
          __int16 v28 = v102;
          *(void *)os_log_type_t type = 0LL;
          id v105 = (uint64_t)type;
          uint64_t v106 = 0x3032000000LL;
          unint64_t v107 = __Block_byref_object_copy__3860;
          unint64_t v108 = __Block_byref_object_dispose__3861;
          unint64_t v109 = 0LL;
          BOOL v29 = *((void *)a2 + 4);
          uint64_t v30 = MEMORY[0x1895F87A8];
          __int16 v31 = &unk_182665000;
          if (v29 && (BOOL v32 = *(void *)(v29 + 24)) != 0 && (v33 = *(uint64_t (**)(void))(v32 + 224)) != 0LL)
          {
            os_log_type_t v34 = (unsigned __int8 *)v33();
            if (gLogDatapath)
            {
              __nwlog_obj();
              BOOL v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_copy_tls_metadata_for_protocol";
                *(_WORD *)&buf[12] = 2112;
                *(void *)&void buf[14] = v28;
                *(_WORD *)&buf[22] = 2112;
                unint64_t v112 = v34;
                *(_WORD *)v113 = 2048;
                *(void *)&v113[2] = a2;
                _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ got back metadata array %@ for protocol %p",  buf,  0x2Au);
              }

              __int16 v31 = (void *)&unk_182665000;
            }

            *(void *)buf = v30;
            *(void *)&buf[8] = v31[390];
            *(void *)&buf[16] = ___ZL61nw_protocol_instance_registrar_copy_tls_metadata_for_protocolP41NWConcrete_nw_protocol_instance_registrarP11nw_protocol_block_invoke;
            unint64_t v112 = (unsigned __int8 *)&unk_189BC7338;
            *(void *)v113 = v28;
            *(void *)&v113[8] = type;
            *(void *)&v113[16] = a2;
            nw_array_apply(v34, (uint64_t)buf);

            os_log_type_t v10 = v99;
            char v35 = *(os_log_s **)v113;
          }

          else
          {
            if (!gLogDatapath)
            {
              BOOL v36 = 0LL;
              os_log_type_t v10 = v99;
LABEL_33:
              BOOL v98 = v36;
              _Block_object_dispose(type, 8);

              if (!v98)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                size_t v52 = (os_log_s *)(id)gLogObj;
                if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_copy_adjacent_endpoints_for_instance";
                  *(_WORD *)&buf[12] = 2112;
                  *(void *)&void buf[14] = v28;
                  _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ there are no adjacent endpoints because TLS is not in the stack",  buf,  0x16u);
                }

                object = 0LL;
                os_log_type_t v46 = 0LL;
LABEL_45:

                if (v46 && *(void *)(v46 + 24) != *(void *)(v46 + 16))
                {
                  if (*((void *)a2 + 2))
                  {
                    if (gLogDatapath)
                    {
                      __nwlog_obj();
                      __int16 v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
                      {
                        int v83 = *((void *)a2 + 2);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
                        *(_WORD *)&buf[12] = 2112;
                        *(void *)&void buf[14] = v102;
                        *(_WORD *)&buf[22] = 2048;
                        unint64_t v112 = a2;
                        *(_WORD *)v113 = 2080;
                        *(void *)&v113[2] = v83;
                        *(_WORD *)&v113[10] = 2112;
                        *(void *)&v113[12] = v46;
                        _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p (%s) has adjacent endpoints %@",  buf,  0x34u);
                      }
                    }

                    *(void *)buf = MEMORY[0x1895F87A8];
                    *(void *)&buf[8] = 3221225472LL;
                    *(void *)&buf[16] = __nw_protocol_instance_registrar_add_edges_for_instance_block_invoke;
                    unint64_t v112 = (unsigned __int8 *)&unk_189BBED00;
                    *(void *)v113 = v102;
                    id v114 = a2;
                    *(void *)&v113[8] = v10;
                    *(void *)&v113[16] = v103;
                    nw_array_apply((unsigned __int8 *)v46, (uint64_t)buf);

                    goto LABEL_50;
                  }

                  __nwlog_obj();
                  __int16 v78 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
                  int v79 = (char *)_os_log_send_and_compose_impl();

                  type[0] = OS_LOG_TYPE_ERROR;
                  os_log_type_t v110 = 0;
                  if (__nwlog_fault(v79, type, &v110))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      __nwlog_obj();
                      __int16 v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      id v81 = type[0];
                      if (os_log_type_enabled(v80, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
                        _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s called with null protocol->identifier",  buf,  0xCu);
                      }
                    }

                    else if (v110)
                    {
                      nw_endpoint_t v88 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      __int16 v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v89 = type[0];
                      os_log_type_t v90 = os_log_type_enabled(v80, type[0]);
                      if (v88)
                      {
                        if (v90)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&void buf[14] = v88;
                          _os_log_impl( &dword_181A5C000,  v80,  v89,  "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v88);
                        goto LABEL_149;
                      }

                      if (v90)
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
                        _os_log_impl( &dword_181A5C000,  v80,  v89,  "%{public}s called with null protocol->identifier, no backtrace",  buf,  0xCu);
                      }
                    }

                    else
                    {
                      __nwlog_obj();
                      __int16 v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      os_log_type_t v94 = type[0];
                      if (os_log_type_enabled(v80, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_add_edges_for_instance";
                        _os_log_impl( &dword_181A5C000,  v80,  v94,  "%{public}s called with null protocol->identifier, backtrace limit exceeded",  buf,  0xCu);
                      }
                    }
                  }

    free(v57);
    if (!v45) {
      goto LABEL_67;
    }
    goto LABEL_134;
  }

  if ((*((char *)v7 + 190) & 0x80000000) == 0 && *((int *)v7 + 10) < 3)
  {
    *(void *)os_log_type_t type = 0LL;
    BOOL v85 = type;
    uint64_t v86 = 0x3032000000LL;
    BOOL v87 = __Block_byref_object_copy__8579;
    nw_endpoint_t v88 = __Block_byref_object_dispose__8580;
    os_log_type_t v10 = v7;
    BOOL v11 = v8;
    os_log_type_t v12 = (void *)nw_content_context_copy_connection(v11);
    if (!v12 && !nw_parameters_get_logging_disabled(*((void *)v10 + 7)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      os_log_type_t v62 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
      {
        v63 = *((_DWORD *)v10 + 42);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_find_connection_for_message";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v63;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v11;
        _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Did not find connection for message (%@), returning nil",  buf,  0x1Cu);
      }
    }

    os_log_type_t v89 = v12;
    os_log_type_t v13 = v11;
    BOOL v14 = v13;
    os_log_type_t v15 = 0LL;
    if (v13 != (os_unfair_lock_s *)&__block_literal_global_5_41854
      && v13 != (os_unfair_lock_s *)&__block_literal_global_4
      && v13 != (os_unfair_lock_s *)&__block_literal_global_3_41839
      && v13 != (os_unfair_lock_s *)&__block_literal_global_41831)
    {
      os_unfair_lock_lock(v13 + 28);
      if ((v14[29]._os_unfair_lock_opaque & 0x200000) != 0
        && (char v16 = *(void *)&v14[26]._os_unfair_lock_opaque) != 0
        && *(void *)(v16 + 24) - *(void *)(v16 + 16) >= 0x19uLL)
      {
        nw_array_get_object_at_index(v16, 3uLL);
        os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
      }

      else
      {
        os_log_type_t v15 = 0LL;
      }

      os_unfair_lock_unlock(v14 + 28);
    }

    if (*((void *)v85 + 5))
    {
      os_log_type_t v17 = MEMORY[0x1895F87A8];
      aBlock[0] = MEMORY[0x1895F87A8];
      aBlock[1] = 3221225472LL;
      aBlock[2] = __nw_connection_group_reply_block_invoke;
      aBlock[3] = &unk_189BBEEE8;
      BOOL v18 = v10;
      id v81 = v18;
      int v83 = type;
      os_log_type_t v19 = v73;
      __int16 v82 = v19;
      BOOL v20 = (void (**)(void))_Block_copy(aBlock);
      os_unfair_lock_lock((os_unfair_lock_t)v10 + 43);
      v20[2](v20);
      os_unfair_lock_unlock((os_unfair_lock_t)v10 + 43);

      os_log_type_t v21 = (NWConcrete_nw_connection *)*((void *)v85 + 5);
      if (v21)
      {
        nw_connection_group_touch_connection(v18, v21);
        os_log_type_t v22 = (nw_connection *)*((void *)v85 + 5);
        completion[0] = v17;
        completion[1] = 3221225472LL;
        completion[2] = __nw_connection_group_reply_block_invoke_20;
        completion[3] = &unk_189BB71A0;
        __int16 v76 = v18;
        BOOL v77 = v14;
        __int16 v78 = v19;
        int v79 = v74;
        nw_connection_send(v22, v79, v78, 1, completion);
      }

      goto LABEL_66;
    }

    char logging_disabled = nw_parameters_get_logging_disabled(*((void *)v10 + 7));
    if (!v74 || !v15)
    {
      if (!logging_disabled)
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        os_log_type_t v26 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          char v27 = *((_DWORD *)v10 + 42);
          __int16 v28 = v9;
          if (v28 == (char *)&__block_literal_global_41831)
          {
            BOOL v29 = "Default Message";
          }

          else if (v28 == (char *)&__block_literal_global_3_41839)
          {
            BOOL v29 = "Final Message";
          }

          else if (v28 == (char *)&__block_literal_global_4)
          {
            BOOL v29 = "Default Stream";
          }

          else if (v28 == (char *)&__block_literal_global_5_41854)
          {
            BOOL v29 = "New Inbound Message";
          }

          else
          {
            BOOL v29 = v28 + 24;
          }

          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v27;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v14;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = v29;
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] context %p does not have connection and is not multicast with content, dropping reply context %s",  buf,  0x26u);
        }
      }

      goto LABEL_66;
    }

    if (gLogDatapath) {
      char v24 = logging_disabled;
    }
    else {
      char v24 = 1;
    }
    if ((v24 & 1) == 0)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v67 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v68 = *((_DWORD *)v10 + 42);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v68;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v14;
        _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Replying to multicast message (%@), sending direct response",  buf,  0x1Cu);
      }
    }

    if (*((void *)v10 + 12))
    {
      BOOL v25 = nw_connection_group_copy_remote_endpoint_for_message(v10, (nw_content_context_t)v14);
      nw_connection_group_send_message(v10, v74, v25, v9, &__block_literal_global_8845);

LABEL_66:
      _Block_object_dispose(type, 8);

      goto LABEL_67;
    }

    __int16 v70 = v10;
    uint64_t v30 = v15;
    __int16 v72 = v14;
    BOOL v71 = v9;
    __int16 v31 = v74;
    os_log_type_t v91 = 0LL;
    id v92 = &v91;
    os_log_type_t v94 = -1;
    BOOL v32 = MEMORY[0x1895F87A8];
    id v93 = 0x2020000000LL;
    v90[0] = MEMORY[0x1895F87A8];
    v90[1] = 3221225472LL;
    v90[2] = ___ZL42nw_connection_group_send_message_on_socketP30NWConcrete_nw_connection_groupPU27objcproto16OS_nw_fd_wrapper8NSObjectPU32objcproto21OS_nw_content_contextS1_S5_PU27objcproto16OS_dispatch_dataS1__block_invoke;
    v90[3] = &unk_189BC78E8;
    v90[4] = &v91;
    nw_fd_wrapper_get_fd(v30, v90);
    if ((v92[3] & 0x80000000) != 0)
    {
      v38 = v70;
      if (!nw_parameters_get_logging_disabled(*((void *)v10 + 7)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        char v35 = (os_log_s *)(id)gconnection_groupLogObj;
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          goto LABEL_64;
        }
        id v40 = *((_DWORD *)v70 + 42);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_on_socket";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v40;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v30;
        __int16 v41 = "%{public}s [G%u] Failed to get socket for %@";
LABEL_57:
        _os_log_impl(&dword_181A5C000, v35, OS_LOG_TYPE_ERROR, v41, buf, 0x1Cu);
        goto LABEL_64;
      }
    }

    else
    {
      v69 = v30;
      size = dispatch_data_get_size(v31);
      if (size)
      {
        os_log_type_t v34 = size;
        char v35 = (os_log_s *)nw_content_context_copy_remote_endpoint(v72);
        BOOL v36 = (void *)*((void *)v10 + 7);
        if (v35)
        {
          char v37 = nw_parameters_copy_context(v36);
          *(void *)buf = v32;
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL42nw_connection_group_send_message_on_socketP30NWConcrete_nw_connection_groupPU27objcproto16OS_nw_fd_wrapper8NSObjectPU32objcproto21OS_nw_content_contextS1_S5_PU27objcproto16OS_dispatch_dataS1__block_invoke_145;
          *(void *)&_BYTE buf[24] = &unk_189BB72B0;
          nw_endpoint_t v101 = v34;
          *(void *)&_BYTE buf[32] = v31;
          v38 = v70;
          BOOL v96 = v70;
          BOOL v97 = v35;
          os_log_type_t v100 = &v91;
          BOOL v98 = v72;
          os_log_type_t v99 = v71;
          nw_queue_context_async(v37, buf);

          uint64_t v30 = v69;
          uint64_t v39 = *(os_log_s **)&buf[32];
        }

        else
        {
          if (nw_parameters_get_logging_disabled((uint64_t)v36))
          {
            char v35 = 0LL;
            uint64_t v30 = v69;
            v38 = v70;
            goto LABEL_64;
          }

          uint64_t v30 = v69;
          v38 = v70;
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          uint64_t v39 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          {
            uint64_t v43 = *((_DWORD *)v70 + 42);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_on_socket";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&void buf[14] = v43;
            _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] Cannot send without remote endpoint",  buf,  0x12u);
          }
        }

LABEL_64:
        goto LABEL_65;
      }

      v38 = v70;
      if (!nw_parameters_get_logging_disabled(*((void *)v10 + 7)))
      {
        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        char v35 = (os_log_s *)(id)gconnection_groupLogObj;
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          goto LABEL_64;
        }
        BOOL v42 = *((_DWORD *)v70 + 42);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_on_socket";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v42;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = 0LL;
        __int16 v41 = "%{public}s [G%u] Cannot send %zu-length data for multicast connection group";
        goto LABEL_57;
      }
    }

        if (!v72) {
          goto LABEL_105;
        }
LABEL_104:
        free(v72);
        goto LABEL_105;
      }

      __nwlog_obj();
      id v105 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
      os_log_type_t v102 = (char *)_os_log_send_and_compose_impl();

      v180[0] = 16;
      handler[0] = 0;
      if (v180[0] == 17)
      {
        __nwlog_obj();
        os_log_type_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v106 = v180[0];
        if (os_log_type_enabled(v103, (os_log_type_t)v180[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_181A5C000, v103, v106, "%{public}s called with null group->listener", buf, 0xCu);
        }
      }

      else if (handler[0])
      {
        __int16 v120 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v121 = v180[0];
        __int16 v122 = os_log_type_enabled(v103, (os_log_type_t)v180[0]);
        if (v120)
        {
          if (v122)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v120;
            _os_log_impl( &dword_181A5C000,  v103,  v121,  "%{public}s called with null group->listener, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v120);
          if (!v102) {
            goto LABEL_106;
          }
          goto LABEL_250;
        }

        if (v122)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl( &dword_181A5C000,  v103,  v121,  "%{public}s called with null group->listener, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v141 = v180[0];
        if (os_log_type_enabled(v103, (os_log_type_t)v180[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl( &dword_181A5C000,  v103,  v141,  "%{public}s called with null group->listener, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v101 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
      os_log_type_t v102 = (char *)_os_log_send_and_compose_impl();

      v180[0] = 16;
      handler[0] = 0;
      if (v180[0] == 17)
      {
        __nwlog_obj();
        os_log_type_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v104 = v180[0];
        if (os_log_type_enabled(v103, (os_log_type_t)v180[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_181A5C000, v103, v104, "%{public}s called with null group", buf, 0xCu);
        }
      }

      else if (handler[0])
      {
        int v117 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v118 = v180[0];
        nw_endpoint_t v119 = os_log_type_enabled(v103, (os_log_type_t)v180[0]);
        if (v117)
        {
          if (v119)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v117;
            _os_log_impl( &dword_181A5C000,  v103,  v118,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v117);
LABEL_249:
          if (!v102) {
            goto LABEL_106;
          }
LABEL_250:
          free(v102);
          goto LABEL_106;
        }

        if (v119)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl(&dword_181A5C000, v103, v118, "%{public}s called with null group, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v140 = v180[0];
        if (os_log_type_enabled(v103, (os_log_type_t)v180[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          _os_log_impl( &dword_181A5C000,  v103,  v140,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_249;
  }

  if (v3 == 4)
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      id v4 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        BOOL v5 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] The group has already been cancelled and cannot be started again. You must create a new group object and start it.",  buf,  0x12u);
      }

  if (v42) {
LABEL_104:
  }
    free(v42);
LABEL_105:
  os_log_type_t v13 = 0LL;
LABEL_37:

  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    v38 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      uint64_t v39 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      *(_DWORD *)aBlock = 136446978;
      *(void *)&aBlock[4] = "nw_connection_group_reconcile_members_block_invoke";
      *(_WORD *)&aBlock[12] = 1024;
      *(_DWORD *)&aBlock[14] = v39;
      *(_WORD *)&aBlock[18] = 2112;
      *(void *)&aBlock[20] = v13;
      *(_WORD *)&aBlock[28] = 2112;
      *(void *)&aBlock[30] = v8;
      _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] created connection %@ to endpoint %@",  aBlock,  0x26u);
    }
  }

  return 1LL;
}

            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
            goto LABEL_104;
          }

          nw::release_if_needed<nw_protocol *>((uint64_t *)&v103);
          if (v17 == &nw_protocol_ref_counted_handle) {
            goto LABEL_71;
          }
LABEL_52:
          os_log_type_t v34 = (void *)*((void *)v5 - 6);
          if (!v34) {
            goto LABEL_104;
          }
          goto LABEL_53;
        }
      }

      __nwlog_obj();
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v68 = (const char *)*((void *)v13 + 2);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_error";
      if (!v68) {
        os_log_type_t v68 = "invalid";
      }
      unint64_t v108 = 2082;
      unint64_t v109 = (char *)v68;
      os_log_type_t v110 = 2048;
      BOOL v111 = v13;
      v69 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v102 = OS_LOG_TYPE_ERROR;
      nw_endpoint_t v101 = 0;
      if (__nwlog_fault(v69, &v102, &v101))
      {
        if (v102 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v71 = v102;
          if (os_log_type_enabled(v70, v102))
          {
            __int16 v72 = (const char *)*((void *)v13 + 2);
            if (!v72) {
              __int16 v72 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_error";
            unint64_t v108 = 2082;
            unint64_t v109 = (char *)v72;
            os_log_type_t v110 = 2048;
            BOOL v111 = v13;
            _os_log_impl( &dword_181A5C000,  v70,  v71,  "%{public}s protocol %{public}s (%p) has invalid error callback",  buf,  0x20u);
          }
        }

        else if (v101)
        {
          __int16 v76 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          __int16 v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v77 = v102;
          __int16 v78 = os_log_type_enabled(v70, v102);
          if (v76)
          {
            if (v78)
            {
              int v79 = (const char *)*((void *)v13 + 2);
              if (!v79) {
                int v79 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_error";
              unint64_t v108 = 2082;
              unint64_t v109 = (char *)v79;
              os_log_type_t v110 = 2048;
              BOOL v111 = v13;
              unint64_t v112 = 2082;
              v113 = (unint64_t)v76;
              _os_log_impl( &dword_181A5C000,  v70,  v77,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v76);
            goto LABEL_178;
          }

          if (v78)
          {
            os_log_type_t v90 = (const char *)*((void *)v13 + 2);
            if (!v90) {
              os_log_type_t v90 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_error";
            unint64_t v108 = 2082;
            unint64_t v109 = (char *)v90;
            os_log_type_t v110 = 2048;
            BOOL v111 = v13;
            _os_log_impl( &dword_181A5C000,  v70,  v77,  "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          __int16 v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          nw_endpoint_t v88 = v102;
          if (os_log_type_enabled(v70, v102))
          {
            os_log_type_t v89 = (const char *)*((void *)v13 + 2);
            if (!v89) {
              os_log_type_t v89 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_error";
            unint64_t v108 = 2082;
            unint64_t v109 = (char *)v89;
            os_log_type_t v110 = 2048;
            BOOL v111 = v13;
            _os_log_impl( &dword_181A5C000,  v70,  v88,  "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

              goto LABEL_68;
            }

            if (!v54)
            {
              __nwlog_obj();
              __int16 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v47 = type;
              if (os_log_type_enabled(v23, type))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
                _os_log_impl( &dword_181A5C000,  v23,  v47,  "%{public}s called with null instance->parent_definition->extended_state->handle_outbound, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_103;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            __int16 v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            __int16 v41 = type;
            BOOL v42 = os_log_type_enabled(v23, type);
            if (!backtrace_string)
            {
              if (v42)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
                _os_log_impl( &dword_181A5C000,  v23,  v41,  "%{public}s called with null instance->parent_definition->extended_state->handle_outbound, no backtrace",  buf,  0xCu);
              }

              goto LABEL_103;
            }

            if (v42)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_finalize_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v23,  v41,  "%{public}s called with null instance->parent_definition->extended_state->handle_outbound, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            goto LABEL_67;
          }

  if (v25) {
    free(v25);
  }
  os_log_type_t v22 = 0LL;
LABEL_28:

  return v22;
}

      free(backtrace_string);
      if (!v33) {
        goto LABEL_9;
      }
      goto LABEL_135;
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v67 = "nw_parameters_create_quic_stream";
    uint64_t v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v64 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v67 = "nw_parameters_create_quic_stream";
        _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s called with null configure_quic_stream", buf, 0xCu);
      }

      goto LABEL_133;
    }

    if (!v64)
    {
      __nwlog_obj();
      os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v56 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v67 = "nw_parameters_create_quic_stream";
        _os_log_impl( &dword_181A5C000,  v34,  v56,  "%{public}s called with null configure_quic_stream, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_133;
    }

    BOOL v42 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v43 = type;
    os_log_type_t v44 = os_log_type_enabled(v34, type);
    if (!v42)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v67 = "nw_parameters_create_quic_stream";
        _os_log_impl( &dword_181A5C000,  v34,  v43,  "%{public}s called with null configure_quic_stream, no backtrace",  buf,  0xCu);
      }

      goto LABEL_133;
    }

    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v67 = "nw_parameters_create_quic_stream";
      os_log_type_t v68 = 2082;
      v69 = v42;
      _os_log_impl( &dword_181A5C000,  v34,  v43,  "%{public}s called with null configure_quic_stream, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v42);
  }

      if (v30) {
        free(v30);
      }
      return 0LL;
    }

    if (!v41)
    {
      __int16 v31 = (os_log_s *)__nwlog_obj();
      BOOL v32 = buf[0];
      if (os_log_type_enabled(v31, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)nw_endpoint_t v50 = 136446210;
        *(void *)&v50[4] = "nw_protocol_http_client_bottom_add_input_handler";
        uint64_t v33 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_102;
      }

      goto LABEL_103;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v31 = (os_log_s *)__nwlog_obj();
    BOOL v32 = buf[0];
    id v40 = os_log_type_enabled(v31, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)nw_endpoint_t v50 = 136446210;
        *(void *)&v50[4] = "nw_protocol_http_client_bottom_add_input_handler";
        uint64_t v33 = "%{public}s called with null options, no backtrace";
        goto LABEL_102;
      }

      goto LABEL_103;
    }

    if (v40)
    {
      *(_DWORD *)nw_endpoint_t v50 = 136446466;
      *(void *)&v50[4] = "nw_protocol_http_client_bottom_add_input_handler";
      *(_WORD *)&v50[12] = 2082;
      *(void *)&v50[14] = backtrace_string;
      BOOL v36 = "%{public}s called with null options, dumping backtrace:%{public}s";
      goto LABEL_86;
    }

    uint64_t v39 = v43;
    id v40 = v44;
    __int16 v41 = 12;
    goto LABEL_60;
  }

  if (!*((void *)handle + 12))
  {
    id v4 = mach_continuous_approximate_time();
    if (v4 <= 1) {
      BOOL v5 = 1LL;
    }
    else {
      BOOL v5 = v4;
    }
    *((void *)handle + 12) = v5;
  }

  if (*((nw_protocol **)handle + 6) != a2)
  {
    __int16 v6 = *((void *)handle + 23);
    __int16 v7 = *((void *)handle + 24);
    if (v6 != v7)
    {
      while (*(nw_protocol **)v6 != a2)
      {
        v6 += 16LL;
        if (v6 == v7) {
          goto LABEL_19;
        }
      }
    }

    if (v6 != v7)
    {
      os_log_type_t v8 = 1LL;
      *(_DWORD *)(v6 + _Block_object_dispose((const void *)(v67 - 152), 8) = 1;
      return v8;
    }

                _os_log_impl(&dword_181A5C000, v69, v70, v71, (uint8_t *)&v105, 0x22u);
                goto LABEL_104;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v67 = (os_log_s *)(id)gLogObj;
              os_log_type_t v68 = buf;
              if (os_log_type_enabled(v67, (os_log_type_t)buf))
              {
                id v105 = 136446978;
                uint64_t v106 = "-[ManagedNetworkSettings reloadMNS]";
                unint64_t v107 = 1024;
                LODWORD(v108[0]) = v91;
                WORD2(v108[0]) = 2114;
                *(void *)((char *)v108 + 6) = v30;
                HIWORD(v108[1]) = 1024;
                LODWORD(v108[2]) = v79;
                v69 = v67;
                __int16 v70 = v68;
                BOOL v71 = "%{public}s MNS error writing %d to sysctl %{public}@ %{darwin.errno}d";
                goto LABEL_103;
              }

    if (v25)
    {
      BOOL v75 = (char *)v25;
LABEL_125:
      free(v75);
      return;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v85 = "nw_http_connect_fail";
  size_t v52 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v82 = 0;
  if (__nwlog_fault(v52, &type, &v82))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
      id v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_123;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v85 = "nw_http_connect_fail";
      uint64_t v55 = "%{public}s called with null http_connect";
LABEL_122:
      _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
      goto LABEL_123;
    }

    if (!v82)
    {
      nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
      id v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_123;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v85 = "nw_http_connect_fail";
      uint64_t v55 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_122;
    }

    uint64_t v67 = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
    id v54 = type;
    os_log_type_t v68 = os_log_type_enabled(v53, type);
    if (!v67)
    {
      if (!v68) {
        goto LABEL_123;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v85 = "nw_http_connect_fail";
      uint64_t v55 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_122;
    }

    if (v68)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v85 = "nw_http_connect_fail";
      uint64_t v86 = 2082;
      BOOL v87 = v67;
      _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null http_connect, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v67);
  }

  [MEMORY[0x189607968] numberWithBool:self->_reuseLocalAddress];
  __int16 v70 = (void *)objc_claimAutoreleasedReturnValue();
  [v4 setObject:v70 forKey:@"reuseLocalAddress"];

  has = (__int16)self->_has;
  if ((has & 0x200) == 0)
  {
LABEL_24:
    if ((has & 8) == 0) {
      goto LABEL_25;
    }
    goto LABEL_105;
  }

      free(v61);
      if (!v52) {
        return;
      }
LABEL_426:
      free(v52);
      return;
    }

    goto LABEL_89;
  }

  os_log_type_t v12 = *((void *)handle + 2);
  if (!v12)
  {
LABEL_89:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
    size_t v52 = (char *)_os_log_send_and_compose_impl();
    v268[0] = 16;
    v260[0] = OS_LOG_TYPE_DEFAULT;
    if (v268[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v53 = (os_log_s *)gLogObj;
      id v54 = v268[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v268[0])) {
        goto LABEL_425;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
      uint64_t v55 = "%{public}s called with null http1_connection";
      goto LABEL_424;
    }

    if (v260[0] == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v53 = (os_log_s *)gLogObj;
      id v54 = v268[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v268[0])) {
        goto LABEL_425;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
      uint64_t v55 = "%{public}s called with null http1_connection, backtrace limit exceeded";
      goto LABEL_424;
    }

    id v61 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_endpoint_t v53 = (os_log_s *)gLogObj;
    id v54 = v268[0];
    os_log_type_t v62 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v268[0]);
    if (!v61)
    {
      if (!v62) {
        goto LABEL_425;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
      uint64_t v55 = "%{public}s called with null http1_connection, no backtrace";
      goto LABEL_424;
    }

    if (!v62) {
      goto LABEL_103;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_disconnected";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v61;
    v63 = "%{public}s called with null http1_connection, dumping backtrace:%{public}s";
LABEL_102:
    _os_log_impl(&dword_181A5C000, v53, v54, v63, buf, 0x16u);
    goto LABEL_103;
  }

  os_log_type_t v13 = (unsigned __int16 *)(v12 + 872);
  BOOL v14 = *(unsigned __int16 *)(v12 + 872);
  os_log_type_t v15 = v14 | (*(unsigned __int8 *)(v12 + 874) << 16);
  if ((v14 & 0x2000) != 0)
  {
    if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
      goto LABEL_111;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v56 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_111;
    }
    nw_endpoint_t v57 = *(void *)(v12 + 488);
    __int16 v58 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
    uint64_t v59 = *(_DWORD *)(v12 + 860);
    if (v57) {
      LODWORD(v57) = *(_DWORD *)(v57 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_connection_finish_input";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&_BYTE buf[24] = " ";
    *(_WORD *)&_BYTE buf[32] = 1024;
    *(_DWORD *)&buf[34] = v58;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v59;
    LOWORD(v265) = 1024;
    *(_DWORD *)((char *)&v265 + 2) = v57;
    __int16 v60 = "%{public}s %{public}s%s<i%u:c%u:s%u> input already finished, returning";
LABEL_110:
    _os_log_impl(&dword_181A5C000, v56, OS_LOG_TYPE_INFO, v60, buf, 0x32u);
    goto LABEL_111;
  }

  *(_BYTE *)(v12 + 874) = BYTE2(v15);
  char *v13 = v15 | 0x2000;
  if ((v15 & 0x40000) != 0)
  {
    if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
      goto LABEL_111;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v56 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_111;
    }
    os_log_type_t v64 = *(void *)(v12 + 488);
    v65 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
    char v66 = *(_DWORD *)(v12 + 860);
    if (v64) {
      LODWORD(v64) = *(_DWORD *)(v64 + 424);
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_http1_connection_finish_input";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&_BYTE buf[24] = " ";
    *(_WORD *)&_BYTE buf[32] = 1024;
    *(_DWORD *)&buf[34] = v65;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v66;
    LOWORD(v265) = 1024;
    *(_DWORD *)((char *)&v265 + 2) = v64;
    __int16 v60 = "%{public}s %{public}s%s<i%u:c%u:s%u> already getting input frames, returning";
    goto LABEL_110;
  }

  v259 = (_WORD *)(v12 + 872);
  char v16 = 0;
  *(void *)uint64_t v260 = 0LL;
  int v261 = v260;
  do
  {
    input_frames = nw_protocol_get_input_frames( *(void *)(v12 + 32),  v12,  1LL,  0xFFFFFFFFLL,  0xFFFFFFFFLL,  (uint64_t)v260);
    BOOL v18 = *(nw_protocol **)v260;
    if (!*(void *)v260) {
      goto LABEL_26;
    }
    if (gLogDatapath)
    {
      nw_endpoint_t v50 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&void buf[14] = v18;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&_BYTE buf[24] = v260;
        *(_WORD *)&_BYTE buf[32] = 2048;
        *(void *)&buf[34] = v12 + 616;
        *(_WORD *)&buf[42] = 1024;
        LODWORD(v265) = 1;
        WORD2(v265) = 1024;
        *(_DWORD *)((char *)&v265 + 6) = 1;
        WORD5(v265) = 1024;
        HIDWORD(v265) = 1;
        _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s called: initial frame %p, source %p, destination %p, temp %u, forwards %u, append %u",  buf,  0x3Cu);
      }
    }

    os_log_type_t v19 = 0;
    *(void *)v268 = 0LL;
    *(void *)&v268[8] = v268;
    do
    {
      output_handler = v18->output_handler;
      if (!output_handler && !v18->handle) {
        output_handler = 0LL;
      }
      if (gLogDatapath)
      {
        char v24 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          default_input_handler_high = HIDWORD(v18->default_input_handler);
          if (default_input_handler_high) {
            default_input_handler_high -= LODWORD(v18->output_handler_context) + HIDWORD(v18->output_handler_context);
          }
          if (output_handler)
          {
            os_log_type_t v26 = HIDWORD(output_handler->default_input_handler);
            if (v26) {
              v26 -= LODWORD(output_handler->output_handler_context) + HIDWORD(output_handler->output_handler_context);
            }
          }

          else
          {
            os_log_type_t v26 = 0;
          }

          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&void buf[14] = v18;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&_BYTE buf[24] = default_input_handler_high;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = output_handler;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v26;
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s current frame: (%p, %u bytes), next frame: (%p, %u bytes)",  buf,  0x2Cu);
        }
      }

      os_log_type_t v22 = v18->output_handler;
      __int16 v23 = v18->handle;
      if (v22)
      {
        v22->handle = v23;
        __int16 v23 = v18->handle;
      }

      else
      {
        int v261 = (os_log_type_t *)v18->handle;
      }

      *__int16 v23 = v22;
      BOOL v20 = *(nw_protocol ***)&v268[8];
      v18->output_handler = 0LL;
      v18->handle = v20;
      *BOOL v20 = v18;
      *(void *)&v268[8] = &v18->output_handler;
      ++v19;
      BOOL v18 = output_handler;
    }

    while (output_handler);
    if (v19)
    {
      if (gLogDatapath)
      {
        __int16 v51 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v19;
          _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s moving %u frames from temp array to destination array",  buf,  0x12u);
        }
      }

      char v27 = *(_DWORD **)v268;
      __int16 v28 = v19;
      if (!*(void *)v268) {
        goto LABEL_67;
      }
      __int16 v28 = v19;
      do
      {
        uint64_t v30 = v27 + 8;
        __int16 v31 = (_DWORD *)*((void *)v27 + 4);
        if (!v31 && !*((void *)v27 + 5)) {
          __int16 v31 = 0LL;
        }
        if (gLogDatapath)
        {
          os_log_type_t v34 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
          {
            char v35 = v27[13];
            if (v35) {
              v35 -= v27[14] + v27[15];
            }
            if (v31)
            {
              BOOL v36 = v31[13];
              if (v36) {
                v36 -= v31[14] + v31[15];
              }
            }

            else
            {
              BOOL v36 = 0;
            }

            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&void buf[14] = v27;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&_BYTE buf[24] = v35;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v31;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v36;
            _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEBUG,  "%{public}s current frame: (%p, %u bytes), next frame: (%p, %u bytes)",  buf,  0x2Cu);
          }
        }

        BOOL v32 = *((void *)v27 + 4);
        uint64_t v33 = (void *)*((void *)v27 + 5);
        if (v32)
        {
          *(void *)(v32 + 40) = v33;
          uint64_t v33 = (void *)*((void *)v27 + 5);
        }

        else
        {
          *(void *)&v268[8] = *((void *)v27 + 5);
        }

        os_unfair_lock_s *v33 = v32;
        *uint64_t v30 = 0LL;
        *((void *)v27 + 5) = 0LL;
        BOOL v29 = *(void **)(v12 + 624);
        *((void *)v27 + 5) = v29;
        *BOOL v29 = v27;
        *(void *)(v12 + 624) = v30;
        --v28;
        char v27 = v31;
      }

      while (v31);
      if (v28)
      {
LABEL_67:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v28;
        char v37 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v262 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = gLogObj;
          uint64_t v39 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_81;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v28;
          id v40 = (os_log_s *)v38;
          __int16 v41 = v39;
          BOOL v42 = "%{public}s failed to deliver all temp frames, remaining %u frames";
        }

        else if (v262)
        {
          uint64_t v43 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v44 = (os_log_s *)gLogObj;
          __int16 v45 = type;
          os_log_type_t v46 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v43)
          {
            if (v46)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&void buf[14] = v28;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v43;
              _os_log_impl( &dword_181A5C000,  v44,  v45,  "%{public}s failed to deliver all temp frames, remaining %u frames, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v43);
            goto LABEL_81;
          }

          if (!v46)
          {
LABEL_81:
            if (v37) {
              free(v37);
            }
            goto LABEL_25;
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v28;
          id v40 = v44;
          __int16 v41 = v45;
          BOOL v42 = "%{public}s failed to deliver all temp frames, remaining %u frames, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v47 = gLogObj;
          os_log_type_t v48 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_81;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_move_frame_array";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v28;
          id v40 = (os_log_s *)v47;
          __int16 v41 = v48;
          BOOL v42 = "%{public}s failed to deliver all temp frames, remaining %u frames, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v40, v41, v42, buf, 0x12u);
        goto LABEL_81;
      }
    }

    if (v15) {
      free(v15);
    }
    handle = a1->handle;
    if (handle)
    {
      BOOL v29 = handle[6];
      if (v29 != 2) {
        return;
      }
LABEL_107:
      if (*((void *)handle + 1)) {
        return;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v45 = "nw_http1_get_connection_for_protocol";
      uint64_t v30 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v42 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v31 = (os_log_s *)__nwlog_obj();
        BOOL v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_122;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        uint64_t v33 = "%{public}s called with null handle->http1_stream";
      }

      else if (v42)
      {
        os_log_type_t v34 = (char *)__nw_create_backtrace_string();
        __int16 v31 = (os_log_s *)__nwlog_obj();
        BOOL v32 = type;
        char v35 = os_log_type_enabled(v31, type);
        if (v34)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v45 = "nw_http1_get_connection_for_protocol";
            os_log_type_t v46 = 2082;
            BOOL v47 = v34;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v34);
          goto LABEL_122;
        }

        if (!v35)
        {
LABEL_122:
          if (v30) {
            free(v30);
          }
          return;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        uint64_t v33 = "%{public}s called with null handle->http1_stream, no backtrace";
      }

      else
      {
        __int16 v31 = (os_log_s *)__nwlog_obj();
        BOOL v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_122;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        uint64_t v33 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
      goto LABEL_122;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v45 = "nw_http1_get_connection_for_protocol";
    BOOL v36 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v42 = 0;
    __nwlog_fault(v36, &type, &v42);
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v37 = (os_log_s *)__nwlog_obj();
      v38 = type;
      *(_DWORD *)buf = 136446210;
      __int16 v45 = "nw_http1_get_connection_for_protocol";
      uint64_t v39 = "%{public}s called with null handle";
    }

    else
    {
      if (v42)
      {
        id v40 = __nw_create_backtrace_string();
        char v37 = (os_log_s *)__nwlog_obj();
        v38 = type;
        if (!v40)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v45 = "nw_http1_get_connection_for_protocol";
          uint64_t v39 = "%{public}s called with null handle, no backtrace";
          goto LABEL_132;
        }

        *(_DWORD *)buf = 136446466;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        os_log_type_t v46 = 2082;
        BOOL v47 = (void *)v40;
        _os_log_impl( &dword_181A5C000,  v37,  type,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
        __break(1u);
      }

      char v37 = (os_log_s *)__nwlog_obj();
      v38 = type;
      *(_DWORD *)buf = 136446210;
      __int16 v45 = "nw_http1_get_connection_for_protocol";
      uint64_t v39 = "%{public}s called with null handle, backtrace limit exceeded";
    }

    if (v15) {
      free(v15);
    }
    handle = a1->handle;
    if (handle)
    {
      BOOL v29 = handle[6];
      if (v29 != 2) {
        return;
      }
LABEL_107:
      if (*((void *)handle + 1)) {
        return;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v45 = "nw_http1_get_connection_for_protocol";
      uint64_t v30 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v42 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v31 = (os_log_s *)__nwlog_obj();
        BOOL v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_122;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        uint64_t v33 = "%{public}s called with null handle->http1_stream";
      }

      else if (v42)
      {
        os_log_type_t v34 = (char *)__nw_create_backtrace_string();
        __int16 v31 = (os_log_s *)__nwlog_obj();
        BOOL v32 = type;
        char v35 = os_log_type_enabled(v31, type);
        if (v34)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v45 = "nw_http1_get_connection_for_protocol";
            os_log_type_t v46 = 2082;
            BOOL v47 = v34;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v34);
          goto LABEL_122;
        }

        if (!v35)
        {
LABEL_122:
          if (v30) {
            free(v30);
          }
          return;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        uint64_t v33 = "%{public}s called with null handle->http1_stream, no backtrace";
      }

      else
      {
        __int16 v31 = (os_log_s *)__nwlog_obj();
        BOOL v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_122;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        uint64_t v33 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
      goto LABEL_122;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v45 = "nw_http1_get_connection_for_protocol";
    BOOL v36 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v42 = 0;
    __nwlog_fault(v36, &type, &v42);
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v37 = (os_log_s *)__nwlog_obj();
      v38 = type;
      *(_DWORD *)buf = 136446210;
      __int16 v45 = "nw_http1_get_connection_for_protocol";
      uint64_t v39 = "%{public}s called with null handle";
    }

    else
    {
      if (v42)
      {
        id v40 = __nw_create_backtrace_string();
        char v37 = (os_log_s *)__nwlog_obj();
        v38 = type;
        if (!v40)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v45 = "nw_http1_get_connection_for_protocol";
          uint64_t v39 = "%{public}s called with null handle, no backtrace";
          goto LABEL_132;
        }

        *(_DWORD *)buf = 136446466;
        __int16 v45 = "nw_http1_get_connection_for_protocol";
        os_log_type_t v46 = 2082;
        BOOL v47 = (void *)v40;
        _os_log_impl( &dword_181A5C000,  v37,  type,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
        __break(1u);
      }

      char v37 = (os_log_s *)__nwlog_obj();
      v38 = type;
      *(_DWORD *)buf = 136446210;
      __int16 v45 = "nw_http1_get_connection_for_protocol";
      uint64_t v39 = "%{public}s called with null handle, backtrace limit exceeded";
    }

        if (v71) {
          free(v71);
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = -1;
        goto LABEL_106;
      }
    }

    *(void *)(*(void *)(a1 + 56) + 8LL) = v66;
    goto LABEL_83;
  }

  char v16 = v15 - v7;
  if (v15 <= v7) {
    return 0LL;
  }
  if (*(_BYTE *)(a1 + 81))
  {
    if (*(_BYTE *)(a1 + 80))
    {
      BOOL v18 = *(void *)(a2 + 32);
      os_log_type_t v19 = *(void **)(a2 + 40);
      os_log_type_t v17 = (void *)(a2 + 32);
      if (v18)
      {
        *(void *)(v18 + 40) = v19;
        **(void **)(a2 + 40) = v18;
        goto LABEL_48;
      }
    }

    else
    {
      BOOL v18 = *(void *)(a2 + 16);
      os_log_type_t v19 = *(void **)(a2 + 24);
      os_log_type_t v17 = (void *)(a2 + 16);
      if (v18)
      {
        *(void *)(v18 + 24) = v19;
        os_log_type_t v19 = *(void **)(a2 + 24);
LABEL_47:
        *os_log_type_t v19 = v18;
LABEL_48:
        *os_log_type_t v17 = 0LL;
        v17[1] = 0LL;
        *(void *)os_log_type_t type = a2;
        BOOL v36 = nw_frame_split((uint64_t *)type, v16);
        if (v36)
        {
          char v37 = v36;
          v38 = *(uint64_t **)(a1 + 56);
          uint64_t v39 = *(void *)type;
          id v40 = v38 + 1;
          __int16 v41 = *v38;
          if (*(_BYTE *)(a1 + 80))
          {
            *(void *)(*(void *)type + 32LL) = v41;
            BOOL v42 = v39 + 32;
            uint64_t v43 = (void *)(v41 + 40);
          }

          else
          {
            *(void *)(*(void *)type + 16LL) = v41;
            BOOL v42 = v39 + 16;
            uint64_t v43 = (void *)(v41 + 24);
          }

          if (v41) {
            id v40 = v43;
          }
          const char *v40 = v42;
          os_unfair_lock_s *v38 = v39;
          *(void *)(v42 + _Block_object_dispose((const void *)(v67 - 152), 8) = v38;
          uint64_t v55 = *(void *)(*(void *)(a1 + 40) + 8LL);
          __int16 v56 = *(_DWORD *)(v55 + 24);
          *(_DWORD *)(v55 + 24) = v56 + v16;
          if (!__CFADD__(v56, (_DWORD)v16)) {
            goto LABEL_137;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          nw_endpoint_t v57 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          os_log_type_t v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
          BOOL v111 = 2082;
          unint64_t v112 = "bytes_count";
          v113 = 2048;
          id v114 = v16;
          char v115 = 2048;
          *(void *)__int16 v116 = v57;
          __int16 v58 = (char *)_os_log_send_and_compose_impl();
          unint64_t v108 = OS_LOG_TYPE_ERROR;
          uint64_t v106 = 0;
          if (__nwlog_fault(v58, &v108, &v106))
          {
            if (v108 == OS_LOG_TYPE_FAULT)
            {
              uint64_t v59 = (os_log_s *)__nwlog_obj();
              __int16 v60 = v108;
              if (os_log_type_enabled(v59, v108))
              {
                id v61 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                os_log_type_t v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
                BOOL v111 = 2082;
                unint64_t v112 = "bytes_count";
                v113 = 2048;
                id v114 = v16;
                char v115 = 2048;
                *(void *)__int16 v116 = v61;
                os_log_type_t v62 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_133:
                _os_log_impl(&dword_181A5C000, v59, v60, v62, buf, 0x2Au);
              }
            }

            else if (v106)
            {
              uint64_t v86 = (char *)__nw_create_backtrace_string();
              uint64_t v59 = (os_log_s *)__nwlog_obj();
              __int16 v60 = v108;
              BOOL v87 = os_log_type_enabled(v59, v108);
              if (v86)
              {
                if (v87)
                {
                  nw_endpoint_t v88 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                  *(_DWORD *)buf = 136447234;
                  os_log_type_t v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
                  BOOL v111 = 2082;
                  unint64_t v112 = "bytes_count";
                  v113 = 2048;
                  id v114 = v16;
                  char v115 = 2048;
                  *(void *)__int16 v116 = v88;
                  *(_WORD *)&v116[8] = 2082;
                  int v117 = v86;
                  _os_log_impl( &dword_181A5C000,  v59,  v60,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v86);
                goto LABEL_134;
              }

              if (v87)
              {
                os_log_type_t v90 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                os_log_type_t v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
                BOOL v111 = 2082;
                unint64_t v112 = "bytes_count";
                v113 = 2048;
                id v114 = v16;
                char v115 = 2048;
                *(void *)__int16 v116 = v90;
                os_log_type_t v62 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_133;
              }
            }

            else
            {
              uint64_t v59 = (os_log_s *)__nwlog_obj();
              __int16 v60 = v108;
              if (os_log_type_enabled(v59, v108))
              {
                os_log_type_t v89 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
                *(_DWORD *)buf = 136446978;
                os_log_type_t v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
                BOOL v111 = 2082;
                unint64_t v112 = "bytes_count";
                v113 = 2048;
                id v114 = v16;
                char v115 = 2048;
                *(void *)__int16 v116 = v89;
                os_log_type_t v62 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_133;
              }
            }
          }

    if (!v30)
    {
LABEL_105:

      return 4LL;
    }

              v306 = 1LL;
              goto LABEL_125;
            }
          }
        }

        if (v308) {
          goto LABEL_104;
        }
        __int16 v84 = *((_DWORD *)v24 + 6);
        BOOL v85 = *(_DWORD *)(v68 + 4);
LABEL_102:
        if (v84 <= v85) {
          goto LABEL_104;
        }
        goto LABEL_103;
      }
    }

    *(void *)&buf[8 * v306] = v24;
    BOOL v71 = (unint64_t)v310;
    __int16 v76 = v312;
    if (!v306)
    {
      v306 = 1LL;
      goto LABEL_76;
    }

    __int16 v82 = *(_DWORD *)(*(void *)&buf[8] + 24LL);
    os_log_type_t v90 = *(_DWORD *)(*(void *)buf + 24LL);
    if (v82 <= v90) {
      __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1767, "candidates[1]->ete_id > candidates[0]->ete_id");
    }
    v306 = 2LL;
    id v81 = 2;
    if (v308)
    {
      int v79 = 0LL;
      v305 = 1;
      v308 = 1;
      goto LABEL_119;
    }

    os_log_type_t v95 = *(_DWORD *)(v68 + 4);
    v306 = 2LL;
    id v81 = 2;
    if (v82 <= v95)
    {
      int v79 = 0LL;
      v308 = 0;
      v305 = 1;
LABEL_119:
      int v83 = 2LL;
      __int16 v80 = 0LL;
      char v24 = *(uint64_t **)&buf[8];
      goto LABEL_195;
    }

    if (v90 <= v95)
    {
      v306 = 2LL;
      id v81 = 2;
      if ((*(_DWORD *)(*(void *)buf + 32LL)
                        + *(_DWORD *)(*(void *)buf + 28LL)
                        + *(_DWORD *)(v68 + 20)
                        - (*(_DWORD *)(v68 + 32)
                         + *(_DWORD *)(v68 + 16))) >= *(_DWORD *)(v68 + 20) >> 2)
      {
        int v79 = 0LL;
        v308 = 0;
        __int16 v82 = *(_DWORD *)(*(void *)buf + 24LL);
        v305 = 1;
        int v83 = 2LL;
        __int16 v80 = 0LL;
        char v24 = *(uint64_t **)buf;
        goto LABEL_195;
      }
    }

    else
    {
      v306 = 2LL;
    }

              free(v15);
              goto LABEL_104;
            }

            if (v42)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_parse_necp_client_id";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&void buf[14] = v6;
              _os_log_impl(&dword_181A5C000, v16, v41, "%{public}s NECP buffer too short %zu, no backtrace", buf, 0x16u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v16 = (os_log_s *)(id)gLogObj;
            nw_endpoint_t v50 = type;
            if (os_log_type_enabled(v16, type))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_parse_necp_client_id";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&void buf[14] = v6;
              _os_log_impl( &dword_181A5C000,  v16,  v50,  "%{public}s NECP buffer too short %zu, backtrace limit exceeded",  buf,  0x16u);
            }
          }
        }

        if (!v15) {
          goto LABEL_104;
        }
        goto LABEL_103;
      }

      BOOL v18 = 0LL;
      os_log_type_t v19 = v6 - 5LL;
      BOOL v20 = v8 + 1;
      v140 = v8 + 5;
      v144 = v19;
      v145 = v8;
      v143 = v8 + 1;
      while (1)
      {
        if (v18 > v19)
        {
          os_log_type_t v34 = v18;
          if (v18 == v6) {
            goto LABEL_133;
          }
          goto LABEL_224;
        }

        os_log_type_t v21 = v8[v18];
        os_log_type_t v22 = *(unsigned int *)&v20[v18];
        if (!(_DWORD)v22)
        {
          __int16 v28 = 0LL;
          goto LABEL_56;
        }

        if (v22 <= 0xFFFFFFF9
          && v6 >= (unint64_t)(v22 + 5)
          && (unint64_t)v6 - (v22 + 5) >= v18)
        {
          __int16 v28 = &v140[v18];
          goto LABEL_56;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v24 = (id)gLogObj;
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&void buf[14] = v18;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v153 = v6;
        uint64_t v154 = 1024;
        *(_DWORD *)v155 = v22;
        BOOL v25 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v148 = 0;
        if (__nwlog_fault((const char *)v25, &type, &v148))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v26 = (os_log_s *)(id)gLogObj;
            char v27 = type;
            if (os_log_type_enabled(v26, type))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&void buf[14] = v18;
              *(_WORD *)&buf[22] = 2048;
              uint64_t v153 = v6;
              uint64_t v154 = 1024;
              *(_DWORD *)v155 = v22;
              _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u",  buf,  0x26u);
            }

          free(v58);
        }
      }

            [MEMORY[0x189607968] numberWithUnsignedInt:v218];
            BOOL v97 = (void *)objc_claimAutoreleasedReturnValue();
            [v8 setObject:v97 forKeyedSubscript:@"proxyMilliseconds"];

            BOOL v96 = v255;
            goto LABEL_104;
        }
      }
    }

    __int16 v58 = @"NW_PROXY_TYPE_INVALID";
    if (v214 <= 3000)
    {
      __int16 v60 = @"NW_PROXY_TYPE_PAC_URL";
      id v61 = @"NW_PROXY_TYPE_HTTP";
      os_log_type_t v62 = @"NW_PROXY_TYPE_HTTPS";
      if (v214 != 2002) {
        os_log_type_t v62 = @"NW_PROXY_TYPE_INVALID";
      }
      if (v214 != 2001) {
        id v61 = v62;
      }
      if (v214 != 1002) {
        __int16 v60 = v61;
      }
      if (v214 == 1001) {
        __int16 v58 = @"NW_PROXY_TYPE_PAC_SCRIPT";
      }
      if (v214 == 1) {
        __int16 v58 = @"NW_PROXY_TYPE_DIRECT";
      }
      if (v214 <= 1001) {
        uint64_t v59 = v58;
      }
      else {
        uint64_t v59 = v60;
      }
    }

    else
    {
      switch(v214)
      {
        case 3001:
          uint64_t v59 = @"NW_PROXY_TYPE_SOCKSV4";
          break;
        case 3002:
          uint64_t v59 = @"NW_PROXY_TYPE_SOCKSV5";
          break;
        case 3003:
          uint64_t v59 = @"NW_PROXY_TYPE_SHOES";
          break;
        case 3004:
          uint64_t v59 = @"NW_PROXY_TYPE_HTTP_CONNECT";
          break;
        case 3005:
          uint64_t v59 = @"NW_PROXY_TYPE_TCP_CONVERTER";
          break;
        case 3006:
          uint64_t v59 = @"NW_PROXY_TYPE_MASQUE";
          break;
        default:
          if (v214 == 4002) {
            __int16 v58 = @"NW_PROXY_TYPE_SECURE_HTTPS";
          }
          if (v214 == 4001) {
            uint64_t v59 = @"NW_PROXY_TYPE_HTTPS_TRANSPARENT";
          }
          else {
            uint64_t v59 = v58;
          }
          break;
      }
    }

    [v8 setObject:v59 forKeyedSubscript:@"usedProxyType"];
    goto LABEL_85;
  }

  BOOL v9 = objc_alloc_init(MEMORY[0x189603FC8]);
  if (v9)
  {
    os_log_type_t v10 = (void *)MEMORY[0x189607968];
    [v7 report];
    [v10 numberWithBool:v203];
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    [v9 setObject:v11 forKeyedSubscript:@"delegated"];

    [v7 report];
    else {
      os_log_type_t v12 = off_189BC5B20[v202 - 2];
    }
    [v9 setObject:v12 forKeyedSubscript:@"reportReason"];
    [v7 clientIdentifier];
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    [v9 setObject:v15 forKeyedSubscript:@"clientIdentifier"];

    [v9 objectForKeyedSubscript:@"delegated"];
    char v16 = (void *)objc_claimAutoreleasedReturnValue();

    if (v16)
    {
      [v7 sourceIdentifier];
      os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
      [v9 setObject:v17 forKeyedSubscript:@"sourceAppIdentifier"];
    }

    [v7 _createStatisticsReportDictionaryFromStruct:v208];
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    [v9 setObject:v18 forKeyedSubscript:@"connectionStatisticsReport"];

    [v9 objectForKeyedSubscript:@"connectionStatisticsReport"];
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();

    if (v19)
    {
      [v7 report];
      [v7 _createFallbackReportDictionaryFromStruct:&v273];
      BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
      [v9 setObject:v20 forKeyedSubscript:@"cellularFallbackReport"];

      [v9 objectForKeyedSubscript:@"cellularFallbackReport"];
      os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();

      if (v21)
      {
        [v7 layer2Report];
        os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();

        if (v22)
        {
          [v7 layer2Report];
          __int16 v23 = (void *)objc_claimAutoreleasedReturnValue();
          [v23 objectForKeyedSubscript:@"cellularRadioTechnology"];
          char v24 = (void *)objc_claimAutoreleasedReturnValue();
          [v9 objectForKeyedSubscript:@"cellularFallbackReport"];
          BOOL v25 = v7;
          os_log_type_t v26 = (void *)objc_claimAutoreleasedReturnValue();
          [v26 setObject:v24 forKeyedSubscript:@"cellularRadioTechnology"];

          [v25 layer2Report];
          char v27 = (void *)objc_claimAutoreleasedReturnValue();
          [v27 objectForKeyedSubscript:@"wifiRadioTechnology"];
          __int16 v28 = (void *)objc_claimAutoreleasedReturnValue();
          [v9 objectForKeyedSubscript:@"cellularFallbackReport"];
          BOOL v29 = (void *)objc_claimAutoreleasedReturnValue();
          [v29 setObject:v28 forKeyedSubscript:@"wifiRadioTechnology"];

          __int16 v7 = v25;
          [v25 layer2Report];
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
          [v30 objectForKeyedSubscript:@"cellularBand"];
          __int16 v31 = (void *)objc_claimAutoreleasedReturnValue();
          [v9 objectForKeyedSubscript:@"cellularFallbackReport"];
          BOOL v32 = (void *)objc_claimAutoreleasedReturnValue();
          [v32 setObject:v31 forKeyedSubscript:@"cellularBand"];

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v33 = (os_log_s *)(id)gLogObj;
          os_log_type_t v34 = v9;
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            [v9 objectForKeyedSubscript:@"cellularFallbackReport"];
            char v35 = (void *)objc_claimAutoreleasedReturnValue();
            v264 = 136446466;
            v265 = "-[NWConnectionStatistics dictionaryReport]";
            nw_endpoint_t v266 = 2114;
            v267 = v35;
            _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s Added radio technology and cellular band to legacy cellular fallback report: %{public}@",  (uint8_t *)&v264,  0x16u);
          }
        }

        else
        {
          os_log_type_t v34 = v9;
          __nwlog_obj();
          uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            v264 = 136446210;
            v265 = "-[NWConnectionStatistics dictionaryReport]";
            _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s Could not add radio technology and cellular band as layer2Report is nil",  (uint8_t *)&v264,  0xCu);
          }
        }

        v63 = objc_alloc_init(MEMORY[0x189603FA8]);
        [v7 report];
        if (v201)
        {
          os_log_type_t v64 = 0LL;
          v65 = &v268;
          while (1)
          {
            [v7 report];
            char v66 = [v7 _createStatisticsReportDictionaryFromStruct:v65];
            if (!v66) {
              break;
            }
            uint64_t v67 = (void *)v66;
            [v63 addObject:v66];

            ++v64;
            [v7 report];
            v65 += 27;
            if (v64 >= v201) {
              goto LABEL_73;
            }
          }

          __nwlog_obj();
          __int16 v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
          {
            [v7 clientIdentifier];
            BOOL v71 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v260 = 136446466;
            int v261 = "-[NWConnectionStatistics dictionaryReport]";
            char v262 = 2114;
            v263 = v71;
            _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_ERROR,  "%{public}s failing to create a fallback report for %{public}@",  (uint8_t *)&v260,  0x16u);
          }

          BOOL v9 = v34;
          goto LABEL_61;
        }

    free(backtrace_string);
    goto LABEL_117;
  }

  if (handle->default_input_handler != a2)
  {
    output_handler = handle[2].output_handler;
    __int16 v6 = (nw_protocol *)handle[2].handle;
    os_log_type_t v8 = output_handler;
    if (output_handler != v6)
    {
      while (*(nw_protocol **)v8->flow_id != a2)
      {
        os_log_type_t v8 = (nw_protocol *)((char *)v8 + 16);
        if (v8 == v6) {
          goto LABEL_29;
        }
      }
    }

    if (v8 != v6)
    {
      p_identifier = &v8->identifier;
      if (&v8->identifier != (nw_protocol_identifier **)v6)
      {
        os_log_type_t v10 = (char *)v6 - (char *)v8 - 32;
        if (v10 > 0xF)
        {
          BOOL v11 = ((char *)v8 - (char *)output_handler) >> 4;
          os_log_type_t v12 = (v10 >> 4) + 1;
          os_log_type_t v13 = 16 * (v12 & 0x1FFFFFFFFFFFFFFELL);
          os_log_type_t v8 = (nw_protocol *)((char *)v8 + v13);
          BOOL v14 = (uint64_t)(&output_handler->callbacks + 2 * v11);
          os_log_type_t v15 = v12 & 0x1FFFFFFFFFFFFFFELL;
          do
          {
            char v16 = *(void *)(v14 + 8);
            *(void *)(v14 - 24) = *(void *)(v14 - 8);
            *(void *)(v14 - _Block_object_dispose((const void *)(v67 - 152), 8) = v16;
            LODWORD(v16) = *(_DWORD *)(v14 + 16);
            *(_DWORD *)(v14 - 16) = *(_DWORD *)v14;
            *(_DWORD *)BOOL v14 = v16;
            v14 += 32LL;
            v15 -= 2LL;
          }

          while (v15);
          if (v12 == (v12 & 0x1FFFFFFFFFFFFFFELL)) {
            goto LABEL_17;
          }
          p_identifier = (nw_protocol_identifier **)((char *)p_identifier + v13);
        }

        do
        {
          *(void *)v8->flow_id = *p_identifier;
          *(_DWORD *)&v8->flow_id[8] = *((_DWORD *)p_identifier + 2);
          os_log_type_t v8 = (nw_protocol *)((char *)v8 + 16);
          p_identifier += 2;
        }

        while (p_identifier != (nw_protocol_identifier **)v6);
      }

              *((_BYTE *)v4 + 33) = v51 & 0x7F;
              goto LABEL_104;
            }

            __nwlog_obj();
            *(_DWORD *)&buf[0].sa_len = 136446210;
            *(void *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
            BOOL v87 = (char *)_os_log_send_and_compose_impl();
            v102[0] = OS_LOG_TYPE_ERROR;
            v107[0] = 0;
            if (__nwlog_fault(v87, v102, v107))
            {
              if (v102[0] == OS_LOG_TYPE_FAULT)
              {
                nw_endpoint_t v88 = (os_log_s *)__nwlog_obj();
                os_log_type_t v89 = v102[0];
                if (os_log_type_enabled(v88, v102[0]))
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(void *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                  os_log_type_t v90 = "%{public}s called with null socket_handler";
LABEL_184:
                  _os_log_impl(&dword_181A5C000, v88, v89, v90, &buf[0].sa_len, 0xCu);
                }
              }

              else if (v107[0])
              {
                os_log_type_t v91 = (char *)__nw_create_backtrace_string();
                nw_endpoint_t v88 = (os_log_s *)__nwlog_obj();
                os_log_type_t v89 = v102[0];
                id v92 = os_log_type_enabled(v88, v102[0]);
                if (v91)
                {
                  if (v92)
                  {
                    *(_DWORD *)&buf[0].sa_len = 136446466;
                    *(void *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                    *(_WORD *)&buf[0].sa_data[10] = 2082;
                    *(void *)&buf[0].sa_data[12] = v91;
                    _os_log_impl( &dword_181A5C000,  v88,  v89,  "%{public}s called with null socket_handler, dumping backtrace:%{public}s",  &buf[0].sa_len,  0x16u);
                  }

                  free(v91);
                  goto LABEL_185;
                }

                if (v92)
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(void *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                  os_log_type_t v90 = "%{public}s called with null socket_handler, no backtrace";
                  goto LABEL_184;
                }
              }

              else
              {
                nw_endpoint_t v88 = (os_log_s *)__nwlog_obj();
                os_log_type_t v89 = v102[0];
                if (os_log_type_enabled(v88, v102[0]))
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(void *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                  os_log_type_t v90 = "%{public}s called with null socket_handler, backtrace limit exceeded";
                  goto LABEL_184;
                }
              }
            }

    if (v25) {
      free(v25);
    }
    return 4294966394LL;
  }

  os_log_type_t v13 = input_frame;
  if (!*(void *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(void *)(input_frame + 88)))
  {
    char v16 = 0;
    os_log_type_t v34 = 0LL;
  }

  else
  {
    os_log_type_t v15 = *(_DWORD *)(v13 + 52);
    BOOL v14 = *(unsigned int *)(v13 + 56);
    if (v15) {
      char v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    }
    else {
      char v16 = 0;
    }
    os_log_type_t v34 = (void *)(*(void *)(v13 + 112) + v14);
  }

  if (v16 != a5)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) != 0)
    {
LABEL_110:
      nw_frame_finalize(v13);
      return 4294966394LL;
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v47 = *(_DWORD *)(v11 + 176);
    os_log_type_t v46 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    BOOL v98 = "on_data_chunk_recv_callback";
    os_log_type_t v99 = 2082;
    os_log_type_t v100 = (const char *)(v11 + 191);
    nw_endpoint_t v101 = 2080;
    os_log_type_t v102 = " ";
    os_log_type_t v103 = 1024;
    *(_DWORD *)BOOL v104 = v46;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v47;
    id v105 = 1024;
    *(_DWORD *)uint64_t v106 = v16;
    *(_WORD *)&v106[4] = 2048;
    *(void *)&v106[6] = a5;
    os_log_type_t v48 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v94 = 0;
    if (__nwlog_fault(v48, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v49 = (os_log_s *)gconnectionLogObj;
        nw_endpoint_t v50 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_108;
        }
        size_t v52 = *(_DWORD *)(v11 + 176);
        __int16 v51 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = (const char *)(v11 + 191);
        nw_endpoint_t v101 = 2080;
        os_log_type_t v102 = " ";
        os_log_type_t v103 = 1024;
        *(_DWORD *)BOOL v104 = v51;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v52;
        id v105 = 1024;
        *(_DWORD *)uint64_t v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(void *)&v106[6] = a5;
        nw_endpoint_t v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame";
        goto LABEL_107;
      }

      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v49 = (os_log_s *)gconnectionLogObj;
        nw_endpoint_t v50 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_108;
        }
        v65 = *(_DWORD *)(v11 + 176);
        os_log_type_t v64 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = (const char *)(v11 + 191);
        nw_endpoint_t v101 = 2080;
        os_log_type_t v102 = " ";
        os_log_type_t v103 = 1024;
        *(_DWORD *)BOOL v104 = v64;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v65;
        id v105 = 1024;
        *(_DWORD *)uint64_t v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(void *)&v106[6] = a5;
        nw_endpoint_t v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame, backtrace limit exceeded";
        goto LABEL_107;
      }

      __int16 v56 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v49 = (os_log_s *)gconnectionLogObj;
      nw_endpoint_t v50 = type;
      nw_endpoint_t v57 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v56)
      {
        if (v57)
        {
          uint64_t v59 = *(_DWORD *)(v11 + 176);
          __int16 v58 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136448002;
          BOOL v98 = "on_data_chunk_recv_callback";
          os_log_type_t v99 = 2082;
          os_log_type_t v100 = (const char *)(v11 + 191);
          nw_endpoint_t v101 = 2080;
          os_log_type_t v102 = " ";
          os_log_type_t v103 = 1024;
          *(_DWORD *)BOOL v104 = v58;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = v59;
          id v105 = 1024;
          *(_DWORD *)uint64_t v106 = v16;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = a5;
          unint64_t v107 = 2082;
          unint64_t v108 = v56;
          _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_crea te_input_frame, dumping backtrace:%{public}s",  buf,  0x46u);
        }

        free(v56);
        goto LABEL_108;
      }

      if (v57)
      {
        v69 = *(_DWORD *)(v11 + 176);
        os_log_type_t v68 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        BOOL v98 = "on_data_chunk_recv_callback";
        os_log_type_t v99 = 2082;
        os_log_type_t v100 = (const char *)(v11 + 191);
        nw_endpoint_t v101 = 2080;
        os_log_type_t v102 = " ";
        os_log_type_t v103 = 1024;
        *(_DWORD *)BOOL v104 = v68;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v69;
        id v105 = 1024;
        *(_DWORD *)uint64_t v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(void *)&v106[6] = a5;
        nw_endpoint_t v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame, no backtrace";
LABEL_107:
        _os_log_impl(&dword_181A5C000, v49, v50, v53, buf, 0x3Cu);
      }
    }

    if (v20)
    {
      BOOL v71 = (char *)v20;
LABEL_105:
      free(v71);
      return 1LL;
    }

    return 1LL;
  }

  BOOL v5 = object;
  __int16 v6 = *(void *)nw_hash_node_get_extra(a2);
  if (!v6)
  {
    BOOL v29 = *(void *)(a1 + 32);
    if (!v29 || (*(__int16 *)(v29 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v30 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        __int16 v31 = *(void *)(a1 + 32);
        BOOL v32 = (const char *)(v31 + 390);
        uint64_t v33 = "";
        os_log_type_t v34 = v31 == 0;
        char v35 = *(_DWORD *)(v31 + 368);
        if (v34) {
          BOOL v32 = "";
        }
        os_log_type_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        nw_endpoint_t v101 = 2082;
        *(_DWORD *)buf = 136446978;
        if (!v34) {
          uint64_t v33 = " ";
        }
        os_log_type_t v102 = v32;
        os_log_type_t v103 = 2080;
        BOOL v104 = v33;
        id v105 = 1024;
        uint64_t v106 = v35;
        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> input protocol has no stream, masking input_finished with disconnected",  buf,  0x26u);
      }
    }

    if (!a16)
    {
LABEL_90:
      if (v34) {
        goto LABEL_91;
      }
      goto LABEL_105;
    }

LABEL_230:
    if (v169) {
      free(v169);
    }
    goto LABEL_232;
  }

  int v211 = nw_endpoint_handler_copy_endpoint(v228);
  loga = (os_log_t)nw_endpoint_handler_copy_parameters(v228);
  output_handler = v218->shared_protocol.protocol.output_handler;
  if (!output_handler)
  {
LABEL_174:
    v160 = v228;
    if ((nw_endpoint_handler_get_logging_disabled(v228) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v161 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
      {
        nw_endpoint_t v162 = nw_endpoint_handler_get_id_string(v228);
        v163 = nw_endpoint_handler_dry_run_string(v228);
        v164 = nw_endpoint_handler_copy_endpoint(v228);
        v165 = nw_endpoint_get_logging_description(v164);
        id v166 = nw_endpoint_handler_state_string(v228);
        v167 = nw_endpoint_handler_mode_string(v228);
        v168 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v228);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_setup_cloned_protocols";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v162;
        *(_WORD *)&buf[22] = 2082;
        v240 = v163;
        *(_WORD *)v241 = 2082;
        *(void *)&v241[2] = v165;
        id v242 = 2082;
        v243 = v166;
        v244 = 2082;
        uint64_t v245 = v167;
        int v246 = 2114;
        char v247 = v168;
        _os_log_impl( &dword_181A5C000,  v161,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] could not find protocol to jo in in existing protocol stack",  buf,  0x48u);
      }

      v160 = v228;
    }

    nw_endpoint_flow_failed_with_error(v160, 1, 0LL);
    goto LABEL_181;
  }

  lock = &v228->lock;
  while (1)
  {
    identifier = output_handler->identifier;
    if (identifier->mapping != 2) {
      goto LABEL_121;
    }
    os_log_type_t v103 = v229;
    if (nw_parameters_has_protocol_in_stack(loga, output_handler->identifier->name)) {
      break;
    }
    v129 = v228;
    uint64_t v130 = (v229[67] & 0x20) == 0;

    if (!v130) {
      goto LABEL_121;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v117 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
    {
      v131 = v129;

      v132 = v131;
      v133 = (v229[67] & 1) == 0;

      if (v133) {
        v134 = "";
      }
      else {
        v134 = "dry-run ";
      }
      v135 = nw_endpoint_handler_copy_endpoint(v132);
      v217 = nw_endpoint_get_logging_description(v135);
      v136 = v132;
      nw_endpoint_t v137 = v136;
      v138 = v230[30];
      uint64_t v139 = "unknown-state";
      v215 = v139;

      v140 = v137;
      int v141 = "path";
      switch(v3[29])
      {
        case 0u:
          break;
        case 1u:
          int v141 = "resolver";
          break;
        case 2u:
          int v141 = nw_endpoint_flow_mode_string(v228->mode_handler);
          break;
        case 3u:
          int v141 = "proxy";
          break;
        case 4u:
          int v141 = "fallback";
          break;
        case 5u:
          int v141 = "transform";
          break;
        default:
          int v141 = "unknown-mode";
          break;
      }

      char v212 = identifier;
      char v142 = v135;
      v143 = v117;
      v144 = v140;
      os_unfair_lock_lock(lock);
      v145 = v228->current_path;
      os_unfair_lock_unlock(lock);

      int v117 = v143;
      *(_DWORD *)buf = 136448002;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_setup_cloned_protocols";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v228->id_str;
      *(_WORD *)&buf[22] = 2082;
      v240 = v134;
      *(_WORD *)v241 = 2082;
      *(void *)&v241[2] = v217;
      id v242 = 2082;
      v243 = v215;
      v244 = 2082;
      uint64_t v245 = v141;
      int v246 = 2114;
      char v247 = v145;
      int v248 = 2082;
      char v249 = v212;
      _os_log_impl( &dword_181A5C000,  v143,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot join protocol %{public}s (not in request stack)",  buf,  0x52u);
    }

    if (v95) {
      free(v95);
    }
    nw_endpoint_t v53 = 0LL;
    goto LABEL_182;
  }

  __nwlog_obj();
  os_log_type_t v90 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
  os_log_type_t v91 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v106 = 0;
  if (__nwlog_fault(v91, &type, &v106))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v93 = type;
      if (os_log_type_enabled(v92, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
        _os_log_impl(&dword_181A5C000, v92, v93, "%{public}s called with null interface_name", buf, 0xCu);
      }
    }

    else if (v106)
    {
      BOOL v98 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v99 = type;
      os_log_type_t v100 = os_log_type_enabled(v92, type);
      if (v98)
      {
        if (v100)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
          os_log_type_t v110 = 2082;
          *(void *)BOOL v111 = v98;
          _os_log_impl( &dword_181A5C000,  v92,  v99,  "%{public}s called with null interface_name, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v98);
        goto LABEL_224;
      }

      if (v100)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
        _os_log_impl(&dword_181A5C000, v92, v99, "%{public}s called with null interface_name, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v104 = type;
      if (os_log_type_enabled(v92, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v109 = "networkd_privileged_set_agent_on_interface_internal";
        _os_log_impl( &dword_181A5C000,  v92,  v104,  "%{public}s called with null interface_name, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v83) {
      free(v83);
    }
    goto LABEL_137;
  }

  __nwlog_obj();
  __int16 v80 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  nw_endpoint_t v101 = "networkd_privileged_teardown_feth_pair";
  BOOL v77 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v98 = 0;
  if (__nwlog_fault(v77, &type, &v98))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v81 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_181A5C000, v78, v81, "%{public}s called with null ifname2", buf, 0xCu);
      }
    }

    else if (v98)
    {
      os_log_type_t v89 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v90 = type;
      os_log_type_t v91 = os_log_type_enabled(v78, type);
      if (v89)
      {
        if (v91)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v101 = "networkd_privileged_teardown_feth_pair";
          os_log_type_t v102 = 2082;
          *(void *)os_log_type_t v103 = v89;
          _os_log_impl( &dword_181A5C000,  v78,  v90,  "%{public}s called with null ifname2, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v89);
        if (v77) {
          goto LABEL_226;
        }
        return;
      }

      if (v91)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_181A5C000, v78, v90, "%{public}s called with null ifname2, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v96 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl( &dword_181A5C000,  v78,  v96,  "%{public}s called with null ifname2, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_224;
  }

        os_release(v22);
        goto LABEL_231;
      }

                    goto LABEL_231;
                  }

                  if (!v537[0])
                  {
                    __nwlog_obj();
                    v136 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    v507 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      _os_log_impl( &dword_181A5C000,  v136,  v507,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
                    }

                    goto LABEL_230;
                  }

                  v496 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v136 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v497 = aBlock[0];
                  v498 = os_log_type_enabled(v136, (os_log_type_t)aBlock[0]);
                  if (!v496)
                  {
                    if (v498)
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      _os_log_impl( &dword_181A5C000,  v136,  v497,  "%{public}s called with null handler, no backtrace",  buf,  0xCu);
                    }

                    goto LABEL_230;
                  }

                  if (v498)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&void buf[14] = v496;
                    _os_log_impl( &dword_181A5C000,  v136,  v497,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v496);
                }

              nw_endpoint_handler_report(v471, v9, a4, v472);
              v205 = *((void *)v42 + 2);
              if (v205) {
                v205 = (uint64_t)(*(void *)(v205 + 24) - *(void *)(v205 + 16)) >> 3;
              }
              v206 = *((void *)v42 + 1);
              if (v206) {
                v206 = (uint64_t)(*(void *)(v206 + 24) - *(void *)(v206 + 16)) >> 3;
              }
              if (v205 == v206)
              {
                has_unresolved_proxies = nw_endpoint_proxy_has_unresolved_proxies(v471, 0LL);
                v208 = nw_endpoint_handler_get_minimize_logging(v471);
                v209 = nw_endpoint_handler_get_logging_disabled(v471);
                if (has_unresolved_proxies)
                {
                  if (v208)
                  {
                    if ((v209 & 1) != 0) {
                      goto LABEL_217;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v151 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
                    {
                      v345 = nw_endpoint_handler_get_id_string(v471);
                      v346 = nw_endpoint_handler_dry_run_string(v471);
                      nw_endpoint_t v347 = nw_endpoint_handler_copy_endpoint(v471);
                      v348 = nw_endpoint_get_logging_description(v347);
                      v349 = nw_endpoint_handler_state_string(v471);
                      v350 = nw_endpoint_handler_mode_string(v471);
                      id v351 = nw_endpoint_handler_copy_current_path(v471);
                      *(_DWORD *)buf = 136447746;
                      v481 = "nw_endpoint_proxy_receive_report";
                      v482 = 2082;
                      v483 = (uint64_t)v345;
                      v484 = 2082;
                      v485 = (uint64_t)v346;
                      v486 = 2082;
                      v487 = v348;
                      v488 = 2082;
                      v489 = v349;
                      v490 = 2082;
                      v491 = v350;
                      v492 = 2114;
                      v493 = v351;
                      _os_log_impl( &dword_181A5C000,  v151,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children fa iled, but still waiting on resolution",  buf,  0x48u);
                    }
                  }

                  else
                  {
                    if ((v209 & 1) != 0) {
                      goto LABEL_217;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v151 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v151, OS_LOG_TYPE_INFO))
                    {
                      int v210 = nw_endpoint_handler_get_id_string(v471);
                      int v211 = nw_endpoint_handler_dry_run_string(v471);
                      char v212 = nw_endpoint_handler_copy_endpoint(v471);
                      v213 = nw_endpoint_get_logging_description(v212);
                      v214 = nw_endpoint_handler_state_string(v471);
                      v215 = nw_endpoint_handler_mode_string(v471);
                      nw_endpoint_t v216 = nw_endpoint_handler_copy_current_path(v471);
                      *(_DWORD *)buf = 136447746;
                      v481 = "nw_endpoint_proxy_receive_report";
                      v482 = 2082;
                      v483 = (uint64_t)v210;
                      v484 = 2082;
                      v485 = (uint64_t)v211;
                      v486 = 2082;
                      v487 = v213;
                      v488 = 2082;
                      v489 = v214;
                      v490 = 2082;
                      v491 = v215;
                      v492 = 2114;
                      v493 = v216;
                      _os_log_impl( &dword_181A5C000,  v151,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children fa iled, but still waiting on resolution",  buf,  0x48u);
                    }
                  }

                  goto LABEL_192;
                }

                if (v208)
                {
                  if ((v209 & 1) != 0) {
                    goto LABEL_263;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v219 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v219, OS_LOG_TYPE_DEBUG))
                  {
                    v352 = nw_endpoint_handler_get_id_string(v471);
                    v353 = nw_endpoint_handler_dry_run_string(v471);
                    nw_endpoint_t v354 = nw_endpoint_handler_copy_endpoint(v471);
                    v355 = nw_endpoint_get_logging_description(v354);
                    v356 = nw_endpoint_handler_state_string(v471);
                    v357 = nw_endpoint_handler_mode_string(v471);
                    id v358 = nw_endpoint_handler_copy_current_path(v471);
                    *(_DWORD *)buf = 136447746;
                    v481 = "nw_endpoint_proxy_receive_report";
                    v482 = 2082;
                    v483 = (uint64_t)v352;
                    v484 = 2082;
                    v485 = (uint64_t)v353;
                    v486 = 2082;
                    v487 = v355;
                    v488 = 2082;
                    v489 = v356;
                    v490 = 2082;
                    v491 = v357;
                    v492 = 2114;
                    v493 = v358;
                    _os_log_impl( &dword_181A5C000,  v219,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed",  buf,  0x48u);
                  }

                  goto LABEL_262;
                }

                if ((v209 & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v219 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v219, OS_LOG_TYPE_INFO))
                  {
                    v237 = nw_endpoint_handler_get_id_string(v471);
                    nw_endpoint_t v238 = nw_endpoint_handler_dry_run_string(v471);
                    v239 = nw_endpoint_handler_copy_endpoint(v471);
                    v240 = nw_endpoint_get_logging_description(v239);
                    v241 = nw_endpoint_handler_state_string(v471);
                    id v242 = nw_endpoint_handler_mode_string(v471);
                    v243 = nw_endpoint_handler_copy_current_path(v471);
                    *(_DWORD *)buf = 136447746;
                    v481 = "nw_endpoint_proxy_receive_report";
                    v482 = 2082;
                    v483 = (uint64_t)v237;
                    v484 = 2082;
                    v485 = (uint64_t)v238;
                    v486 = 2082;
                    v487 = v240;
                    v488 = 2082;
                    v489 = v241;
                    v490 = 2082;
                    v491 = v242;
                    v492 = 2114;
                    v493 = v243;
                    _os_log_impl( &dword_181A5C000,  v219,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed",  buf,  0x48u);
                  }

    BOOL v104 = (*v64 & 4) == 0;
    id v105 = 1204;
    uint64_t v106 = 1104;
    goto LABEL_231;
  }

  __int16 v31 = *(void *)(a1 + 40);
  if (!v31 || (*(_BYTE *)(v31 + 529) & 1) == 0)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    BOOL v5 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
    {
      BOOL v32 = *(void *)(a1 + 40);
      uint64_t v33 = v32 == 0;
      if (v32) {
        os_log_type_t v34 = (const char *)(v32 + 531);
      }
      else {
        os_log_type_t v34 = "";
      }
      char v35 = " ";
      if (v33) {
        char v35 = "";
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = v34;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&void buf[14] = v35;
      os_log_type_t v10 = "%{public}s%sReceived unexpected input frame without HTTP metadata";
      goto LABEL_13;
    }
  }

  __break(1u);
  return result;
}

    if (v90) {
      free(v90);
    }
    goto LABEL_14;
  }

  BOOL v9 = *v8;
  if (v9 > 0x1A || ((1 << v9) & 0x40CF400) == 0 || (os_log_type_t v10 = (__int128 *)(v8 + 16), uuid_is_null(v8 + 16)))
  {
LABEL_14:
    os_log_type_t v296 = nw_agent_client_create((unsigned __int8 *)v402[3], v298, *(void **)(*(void *)&buf[8] + 40LL));
    goto LABEL_36;
  }

  uu = *v10;
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)&uu, out);
  os_log_type_t v15 = (NWConcrete_nw_agent_client *)nw_dictionary_copy_value( *(void *)&v298[184]._os_unfair_lock_opaque,  (uint64_t)out);
  char v16 = (unsigned __int8 *)v402[3];
  os_log_type_t v296 = v15;
  if (v15)
  {
    if (v16)
    {
      os_log_type_t v17 = *v16;
      if (v17 == 15 || v17 == 12)
      {
        BOOL v18 = *(void *)&v298[184]._os_unfair_lock_opaque;
        os_log_type_t v19 = 0LL;
LABEL_35:
        nw_dictionary_set_value(v18, out, v19);
        goto LABEL_36;
      }

      goto LABEL_36;
    }

    __nwlog_obj();
    os_log_type_t v103 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v413 = 136446210;
    id v414 = "nw_agent_should_remove_client_for_message";
    BOOL v104 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v405 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v106 = type;
      if (os_log_type_enabled(v105, type))
      {
        *(_DWORD *)v413 = 136446210;
        id v414 = "nw_agent_should_remove_client_for_message";
        _os_log_impl(&dword_181A5C000, v105, v106, "%{public}s called with null message", v413, 0xCu);
      }
    }

    else if (v405)
    {
      BOOL v111 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v112 = type;
      v113 = os_log_type_enabled(v105, type);
      if (v111)
      {
        if (v113)
        {
          *(_DWORD *)v413 = 136446466;
          id v414 = "nw_agent_should_remove_client_for_message";
          v415 = 2082;
          v416 = v111;
          _os_log_impl( &dword_181A5C000,  v105,  v112,  "%{public}s called with null message, dumping backtrace:%{public}s",  v413,  0x16u);
        }

        free(v111);
        if (!v104) {
          goto LABEL_36;
        }
LABEL_591:
        free(v104);
        goto LABEL_36;
      }

      if (v113)
      {
        *(_DWORD *)v413 = 136446210;
        id v414 = "nw_agent_should_remove_client_for_message";
        _os_log_impl(&dword_181A5C000, v105, v112, "%{public}s called with null message, no backtrace", v413, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v163 = type;
      if (os_log_type_enabled(v105, type))
      {
        *(_DWORD *)v413 = 136446210;
        id v414 = "nw_agent_should_remove_client_for_message";
        _os_log_impl( &dword_181A5C000,  v105,  v163,  "%{public}s called with null message, backtrace limit exceeded",  v413,  0xCu);
      }
    }

    goto LABEL_589;
  }

  os_log_type_t v296 = nw_agent_client_create(v16, v298, *(void **)(*(void *)&buf[8] + 40LL));
  char v24 = (unsigned __int8 *)v402[3];
  if (!v24)
  {
    __nwlog_obj();
    unint64_t v108 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v413 = 136446210;
    id v414 = "nw_agent_should_add_client_for_message";
    BOOL v104 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v405 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v109 = type;
      if (os_log_type_enabled(v105, type))
      {
        *(_DWORD *)v413 = 136446210;
        id v414 = "nw_agent_should_add_client_for_message";
        _os_log_impl(&dword_181A5C000, v105, v109, "%{public}s called with null message", v413, 0xCu);
      }
    }

    else if (v405)
    {
      v160 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v161 = type;
      nw_endpoint_t v162 = os_log_type_enabled(v105, type);
      if (v160)
      {
        if (v162)
        {
          *(_DWORD *)v413 = 136446466;
          id v414 = "nw_agent_should_add_client_for_message";
          v415 = 2082;
          v416 = v160;
          _os_log_impl( &dword_181A5C000,  v105,  v161,  "%{public}s called with null message, dumping backtrace:%{public}s",  v413,  0x16u);
        }

        free(v160);
LABEL_590:
        if (!v104) {
          goto LABEL_36;
        }
        goto LABEL_591;
      }

      if (v162)
      {
        *(_DWORD *)v413 = 136446210;
        id v414 = "nw_agent_should_add_client_for_message";
        _os_log_impl(&dword_181A5C000, v105, v161, "%{public}s called with null message, no backtrace", v413, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v165 = type;
      if (os_log_type_enabled(v105, type))
      {
        *(_DWORD *)v413 = 136446210;
        id v414 = "nw_agent_should_add_client_for_message";
        _os_log_impl( &dword_181A5C000,  v105,  v165,  "%{public}s called with null message, backtrace limit exceeded",  v413,  0xCu);
      }
    }

LABEL_120:
LABEL_121:
    output_handler = output_handler->output_handler;
    if (!output_handler) {
      goto LABEL_174;
    }
  }

  callbacks = output_handler->callbacks;
  get_remote_endpoint = (uint64_t (*)(nw_protocol *))callbacks->get_remote_endpoint;
  uint64_t v106 = (void *)get_remote_endpoint(output_handler);
  unint64_t v107 = (void *)((uint64_t (*)(nw_protocol *))output_handler->callbacks->get_parameters)(output_handler);
  if ((nw_endpoint_is_equal(v106, v211, 3LL) & 1) == 0)
  {
    unint64_t v108 = nw_endpoint_copy_proxy_original_endpoint(v211);
    if ((nw_endpoint_is_equal(v106, (void *)v108, 3LL) & 1) == 0)
    {
      unint64_t v109 = nw_endpoint_copy_proxy_original_endpoint(v106);
      if ((nw_endpoint_is_equal((void *)v109, v211, 3LL) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v149 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_133;
        }
        id v150 = output_handler->identifier;
        v151 = nw_endpoint_get_logging_description(v211);
        v152 = nw_endpoint_get_logging_description(v106);
        uint64_t v153 = nw_endpoint_copy_proxy_original_endpoint(v211);
        uint64_t v154 = nw_endpoint_get_logging_description((void *)v153);
        v155 = nw_endpoint_copy_proxy_original_endpoint(v106);
        v156 = nw_endpoint_get_logging_description((void *)v155);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_can_join_existing";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v150;
        *(_WORD *)&buf[22] = 2082;
        v240 = v151;
        os_log_type_t v103 = v229;
        *(_WORD *)v241 = 2082;
        *(void *)&v241[2] = v152;
        id v242 = 2082;
        v243 = v154;
        v244 = 2082;
        uint64_t v245 = v156;
        unint64_t v112 = (os_log_s *)v149;
        v113 = "%{public}s Cannot join existing protocol %{public}s, endpoints do not match (%{public}s != %{public}s), ("
               "original %{public}s, existing original %{public}s)";
        id v114 = 62;
        goto LABEL_132;
      }
    }
  }

  if (!nw_parameters_are_compatible(loga, -1LL, v107, (uint64_t)output_handler, 0))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v110 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      BOOL v111 = output_handler->identifier;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_can_join_existing";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v111;
      unint64_t v112 = (os_log_s *)v110;
      v113 = "%{public}s Cannot join existing protocol %{public}s, parameters do not match";
      id v114 = 22;
LABEL_132:
      _os_log_impl(&dword_181A5C000, v112, OS_LOG_TYPE_DEBUG, v113, buf, v114);
    }

                  os_unfair_lock_unlock(v45);
                  if (!v58) {
                    goto LABEL_122;
                  }
                  goto LABEL_121;
                }

      if (*((void *)v363 + 4))
      {
        if (nw_endpoint_handler_get_minimize_logging(v41))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v111 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
          {
            v308 = nw_endpoint_handler_get_id_string(v41);
            v309 = nw_endpoint_handler_dry_run_string(v41);
            v310 = nw_endpoint_handler_copy_endpoint(v41);
            id v311 = nw_endpoint_get_logging_description(v310);
            v312 = nw_endpoint_handler_state_string(v41);
            os_log_type_t v313 = nw_endpoint_handler_mode_string(v41);
            BOOL v314 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v41);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v308;
            *(_WORD *)&buf[22] = 2082;
            id v379 = v309;
            *(_WORD *)v380 = 2082;
            *(void *)&v380[2] = v311;
            *(_WORD *)&v380[10] = 2082;
            *(void *)&v380[12] = v312;
            v381 = 2082;
            nw_endpoint_t v382 = v313;
            v383 = 2114;
            v384 = v314;
            _os_log_impl( &dword_181A5C000,  v111,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already connected, ignori ng update from resolver",  buf,  0x48u);
          }
        }

        else
        {
          unint64_t v109 = v41;
          os_log_type_t v110 = (*((_BYTE *)v109 + 268) & 0x20) == 0;

          if (!v110)
          {
LABEL_334:
            __int16 v28 = v346;
LABEL_335:

            goto LABEL_336;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v111 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
          {
            unint64_t v112 = v109;

            v113 = v112;
            id v114 = (*((_BYTE *)v109 + 268) & 1) == 0;

            if (v114) {
              char v115 = "";
            }
            else {
              char v115 = "dry-run ";
            }
            __int16 v116 = nw_endpoint_handler_copy_endpoint(v113);
            int v117 = nw_endpoint_get_logging_description(v116);
            __int16 v118 = v113;
            nw_endpoint_t v119 = v118;
            __int16 v120 = v9->state;
            else {
              v121 = off_189BBBBF0[v120];
            }

            v134 = v119;
            v135 = v134;
            v136 = "path";
            switch(v7[29])
            {
              case 0u:
                break;
              case 1u:
                v136 = "resolver";
                break;
              case 2u:
                v136 = nw_endpoint_flow_mode_string(v134[31]);
                break;
              case 3u:
                v136 = "proxy";
                break;
              case 4u:
                v136 = "fallback";
                break;
              case 5u:
                v136 = "transform";
                break;
              default:
                v136 = "unknown-mode";
                break;
            }

            v291 = v135;
            os_unfair_lock_lock((os_unfair_lock_t)v291 + 28);
            v292 = v291[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v291 + 28);

            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v112->id_str;
            *(_WORD *)&buf[22] = 2082;
            id v379 = v115;
            *(_WORD *)v380 = 2082;
            *(void *)&v380[2] = v117;
            *(_WORD *)&v380[10] = 2082;
            *(void *)&v380[12] = v121;
            v381 = 2082;
            nw_endpoint_t v382 = v136;
            v383 = 2114;
            v384 = v292;
            _os_log_impl( &dword_181A5C000,  v111,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already connected, ignori ng update from resolver",  buf,  0x48u);
          }
        }

        goto LABEL_334;
      }

      nw_endpoint_t v347 = v7;
      v339 = a3;
      *((_DWORD *)v363 + 4) = a3;
      __int16 v122 = v41;
      id v123 = (*((_BYTE *)v122 + 268) & 0x20) == 0;
      v367 = v122;

      if (v123)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v124 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
        {
          dispatch_time_t v125 = nw_endpoint_handler_get_id_string(v367);
          uint64_t v126 = nw_endpoint_handler_dry_run_string(v367);
          uint64_t v127 = nw_endpoint_handler_copy_endpoint(v367);
          nw_endpoint_t v128 = nw_endpoint_get_logging_description(v127);
          v129 = nw_endpoint_handler_state_string(v367);
          uint64_t v130 = nw_endpoint_handler_mode_string(v367);
          v131 = nw_endpoint_handler_copy_current_path(v367);
          v132 = v131;
          if (v339 > 2) {
            v133 = "unknown";
          }
          else {
            v133 = off_189BBBA38[v339];
          }
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v125;
          *(_WORD *)&buf[22] = 2082;
          id v379 = v126;
          *(_WORD *)v380 = 2082;
          *(void *)&v380[2] = v128;
          *(_WORD *)&v380[10] = 2082;
          *(void *)&v380[12] = v129;
          v381 = 2082;
          nw_endpoint_t v382 = v130;
          v383 = 2114;
          v384 = (OS_nw_path *)v131;
          v385 = 2082;
          id v386 = v133;
          _os_log_impl( &dword_181A5C000,  v124,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolver is %{public}s",  buf,  0x52u);
        }
      }

      nw_endpoint_t v137 = v363;
      v138 = *((id *)v363 + 12);
      uint64_t v139 = v138;
      v140 = (void *)*((void *)v363 + 11);
      if (v140)
      {
        combined_array = nw_array_create_combined_array(v138, v140);

        uint64_t v139 = combined_array;
        nw_endpoint_t v137 = v363;
      }

      nw_endpoint_t v340 = v139;
      if (v139)
      {
        if (v139[3] != v139[2])
        {
          char v142 = *((void *)v137 + 8);
          if (v142)
          {
            nw_queue_cancel_source(v142, (uint64_t)v140);
            *((void *)v137 + _Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
          }
        }
      }

      if (v339 - 1 > 1)
      {
LABEL_333:

        goto LABEL_334;
      }

      object = v139;
      obj = nw_array_create();
      v143 = *((void *)v363 + 5);
      location = (uint64_t *)((char *)v363 + 40);
      if (v143)
      {
        v144 = *((unsigned int *)v363 + 5);
      }

      else
      {
        LODWORD(v144) = *((_DWORD *)v363 + 5);
        if ((_DWORD)v144) {
          LODWORD(v144) = 0;
        }
      }

      if ((_DWORD)v144)
      {
        v145 = 0LL;
        v348 = v144;
        lock = &v367->lock;
        while (1)
        {
          nw_endpoint_t v146 = nw_array_get_object_at_index(*location, v145);
          nw_array_append(obj, (void *)v146);
          id v358 = (void *)v146;
          v147 = nw_endpoint_handler_copy_endpoint((void *)v146);
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL44nw_endpoint_resolver_array_contains_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke;
          id v379 = (const char *)&unk_189BC85B0;
          *(void *)v380 = v147;
          v148 = v147;
          LOBYTE(v146) = nw_array_apply(object, (uint64_t)buf);

          if ((v146 & 1) == 0) {
            break;
          }
          if (nw_endpoint_handler_get_minimize_logging(v367))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            log = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
            {
              v194 = nw_endpoint_handler_get_id_string(v367);
              v195 = nw_endpoint_handler_dry_run_string(v367);
              v342 = nw_endpoint_handler_copy_endpoint(v367);
              v196 = nw_endpoint_get_logging_description(v342);
              v197 = nw_endpoint_handler_state_string(v367);
              v198 = nw_endpoint_handler_mode_string(v367);
              char v199 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
              uint64_t v200 = nw_endpoint_get_logging_description(v148);
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v194;
              *(_WORD *)&buf[22] = 2082;
              id v379 = v195;
              *(_WORD *)v380 = 2082;
              *(void *)&v380[2] = v196;
              *(_WORD *)&v380[10] = 2082;
              *(void *)&v380[12] = v197;
              v381 = 2082;
              nw_endpoint_t v382 = v198;
              v383 = 2114;
              v384 = v199;
              v385 = 2082;
              id v386 = v200;
              _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Started endpoint %{publ ic}s is no longer resolved",  buf,  0x52u);

              goto LABEL_196;
            }

            v151 = log;
            goto LABEL_197;
          }

          v149 = v367;
          id v150 = (*((_BYTE *)v367 + 268) & 0x20) == 0;

          if (v150)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v151 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v151, OS_LOG_TYPE_INFO))
            {
              log = v151;
              v152 = v149;

              uint64_t v153 = v152;
              LODWORD(v152) = (*((_BYTE *)v367 + 268) & 1) == 0;

              if ((_DWORD)v152) {
                uint64_t v154 = "";
              }
              else {
                uint64_t v154 = "dry-run ";
              }
              v155 = nw_endpoint_handler_copy_endpoint(v153);
              v156 = nw_endpoint_get_logging_description(v155);
              v157 = v153;
              v158 = v157;
              v159 = v351->state;
              v160 = "unknown-state";

              v161 = v158;
              nw_endpoint_t v162 = "path";
              switch(v347[29])
              {
                case 0u:
                  break;
                case 1u:
                  nw_endpoint_t v162 = "resolver";
                  break;
                case 2u:
                  nw_endpoint_t v162 = nw_endpoint_flow_mode_string(v367->mode_handler);
                  break;
                case 3u:
                  nw_endpoint_t v162 = "proxy";
                  break;
                case 4u:
                  nw_endpoint_t v162 = "fallback";
                  break;
                case 5u:
                  nw_endpoint_t v162 = "transform";
                  break;
                default:
                  nw_endpoint_t v162 = "unknown-mode";
                  break;
              }

              v190 = v161;
              os_unfair_lock_lock(lock);
              v191 = v367->current_path;
              os_unfair_lock_unlock(lock);

              v192 = v191;
              v193 = nw_endpoint_get_logging_description(v148);
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v367->id_str;
              *(_WORD *)&buf[22] = 2082;
              id v379 = v154;
              *(_WORD *)v380 = 2082;
              *(void *)&v380[2] = v156;
              *(_WORD *)&v380[10] = 2082;
              *(void *)&v380[12] = v160;
              v381 = 2082;
              nw_endpoint_t v382 = v162;
              v383 = 2114;
              v384 = v192;
              v385 = 2082;
              id v386 = v193;
              _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Started endpoint %{publ ic}s is no longer resolved",  buf,  0x52u);

              goto LABEL_196;
            }

            goto LABEL_197;
          }

        os_log_type_t v10 = 0LL;
LABEL_135:
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_51910);
        }
        goto LABEL_137;
      }

      if (v20 != 4) {
        goto LABEL_135;
      }
      unint64_t v108 = 0LL;
      unint64_t v109 = (uint64_t)&v108;
      os_log_type_t v110 = 0x3032000000LL;
      BOOL v111 = __Block_byref_object_copy__52020;
      unint64_t v112 = __Block_byref_object_dispose__52021;
      os_log_type_t v21 = v10;
      v113 = v21;
      __int16 v23 = (unint64_t)v15[10];
      os_log_type_t v22 = (unint64_t)v15[11];
      char v24 = v23 >= v22;
      BOOL v25 = v23 - v22;
      if (v25 == 0 || !v24)
      {
LABEL_119:

        _Block_object_dispose(&v108, 8);
        goto LABEL_120;
      }

      if (v24) {
        os_log_type_t v26 = v25;
      }
      else {
        os_log_type_t v26 = 0LL;
      }
      char v115 = 0LL;
      __int16 v116 = &v115;
      int v117 = 0x2020000000LL;
      char v27 = &v118;
      LOBYTE(v11_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
      os_log_type_t v89 = v12;
      while (1)
      {
        nw_endpoint_t v101 = 0LL;
        os_log_type_t v102 = &v101;
        BOOL v104 = 0;
        os_log_type_t v103 = 0x2020000000LL;
        *(_BYTE *)char v27 = 0;
        __int16 v28 = *(dispatch_data_s **)(v109 + 40);
        BOOL v29 = dispatch_data_get_size(v28);
        uint64_t v30 = v29;
        applier[0] = MEMORY[0x1895F87A8];
        if (v26 >= v29) {
          __int16 v31 = v29;
        }
        else {
          __int16 v31 = v26;
        }
        applier[1] = 3221225472LL;
        applier[2] = __nw_read_request_receive_block_invoke;
        applier[3] = &unk_189BC0A28;
        os_log_type_t v100 = v31;
        BOOL v32 = v15;
        os_log_type_t v95 = v32;
        BOOL v96 = &v108;
        BOOL v97 = &v101;
        BOOL v98 = &v115;
        os_log_type_t v99 = v30;
        dispatch_data_apply(v28, applier);
        uint64_t v33 = (char *)v15[11] + *((unsigned int *)v102 + 6);
        v15[11] = v33;
        if (!v33 || ((_BYTE)v15[22] & 4) != 0) {
          goto LABEL_49;
        }
        char v35 = v32;
        BOOL v36 = v15[7];
        if (!v36)
        {
          __nwlog_obj();
          id v61 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          id v123 = "nw_read_request_start_file_updates";
          os_log_type_t v62 = (char *)_os_log_send_and_compose_impl();

          LOBYTE(location) = 16;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v62, &location, &type))
          {
            if (location == 17)
            {
              __nwlog_obj();
              v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v64 = location;
              if (os_log_type_enabled(v63, (os_log_type_t)location))
              {
                *(_DWORD *)buf = 136446210;
                id v123 = "nw_read_request_start_file_updates";
                _os_log_impl(&dword_181A5C000, v63, v64, "%{public}s called with null request->connection", buf, 0xCu);
              }

              goto LABEL_87;
            }

            if (type)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              char v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v67 = location;
              log = v66;
              os_log_type_t v68 = os_log_type_enabled(v66, (os_log_type_t)location);
              if (backtrace_string)
              {
                if (v68)
                {
                  *(_DWORD *)buf = 136446466;
                  id v123 = "nw_read_request_start_file_updates";
                  uint64_t v124 = 2082;
                  *(void *)dispatch_time_t v125 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  log,  v67,  "%{public}s called with null request->connection, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(backtrace_string);
              }

              else
              {
                if (v68)
                {
                  *(_DWORD *)buf = 136446210;
                  id v123 = "nw_read_request_start_file_updates";
                  _os_log_impl( &dword_181A5C000,  log,  v67,  "%{public}s called with null request->connection, no backtrace",  buf,  0xCu);
                }
              }
            }

            else
            {
              __nwlog_obj();
              v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v69 = location;
              if (os_log_type_enabled(v63, (os_log_type_t)location))
              {
                *(_DWORD *)buf = 136446210;
                id v123 = "nw_read_request_start_file_updates";
                _os_log_impl( &dword_181A5C000,  v63,  v69,  "%{public}s called with null request->connection, backtrace limit exceeded",  buf,  0xCu);
              }

  if (v38) {
LABEL_121:
  }
    free(v38);
LABEL_130:
}

    if (v42) {
      free(v42);
    }
    __int16 v28 = 0LL;
    goto LABEL_36;
  }

  os_log_type_t v26 = nw_protocol_options_copy_definition(v24);
  if (nw_protocol_copy_http_redirect_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_31_73205);
  }
  char v27 = nw_protocol_definition_is_equal( v26,  (nw_protocol_definition_t)nw_protocol_copy_http_redirect_definition_http_redirect_definition);

  if (!v27)
  {
    __nwlog_obj();
    BOOL v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_redirect_options_copy_handler_queue";
    BOOL v42 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v42, type, &v69))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v48 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_copy_handler_queue";
          _os_log_impl(&dword_181A5C000, v43, v48, "%{public}s protocol options are not http redirect", buf, 0xCu);
        }

                  free(v47);
                  goto LABEL_121;
                }

                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v38 = (id)gLogObj;
                *(_DWORD *)buf = 136446210;
                id v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                uint64_t v39 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t type = OS_LOG_TYPE_ERROR;
                v147 = 0;
                if (__nwlog_fault(v39, &type, &v147))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v40 = (os_log_s *)(id)gLogObj;
                    __int16 v41 = type;
                    if (os_log_type_enabled(v40, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      id v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                      _os_log_impl(&dword_181A5C000, v40, v41, "%{public}s nw_tls_create_options failed", buf, 0xCu);
                    }

    free(v57);
    if (!v13) {
      goto LABEL_68;
    }
    goto LABEL_67;
  }

  if (*(_UNKNOWN **)(v9 + 40) != &nw_protocol_ref_counted_handle)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)applier = 136446210;
    *(void *)&void applier[4] = "nw_socket_add_initial_inbound_data";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v6_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v50 = (os_log_s *)gLogObj;
      __int16 v51 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_66;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&void applier[4] = "nw_socket_add_initial_inbound_data";
      size_t v52 = "%{public}s called with null socket_handler";
    }

    else if ((_BYTE)v68)
    {
      os_log_type_t v62 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v50 = (os_log_s *)gLogObj;
      __int16 v51 = type[0];
      v63 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v62)
      {
        if (v63)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&void applier[4] = "nw_socket_add_initial_inbound_data";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = v62;
          _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null socket_handler, dumping backtrace:%{public}s",  applier,  0x16u);
        }

        free(v62);
        if (!v13) {
          goto LABEL_68;
        }
        goto LABEL_67;
      }

      if (!v63)
      {
LABEL_66:
        if (!v13)
        {
LABEL_68:

LABEL_74:
          return;
        }

                      uint64_t v59 = 0LL;
LABEL_121:

                      goto LABEL_122;
                    }

                    if ((*((_BYTE *)v26 + 268) & 0x20) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      os_log_type_t v46 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                      {
                        if ((*((_BYTE *)v26 + 268) & 1) != 0) {
                          BOOL v47 = "dry-run ";
                        }
                        else {
                          BOOL v47 = "";
                        }
                        os_log_type_t v48 = nw_endpoint_handler_copy_endpoint(v26);
                        os_log_type_t v49 = nw_endpoint_get_logging_description(v48);
                        nw_endpoint_t v50 = *((unsigned int *)v26 + 30);
                        uint64_t v106 = v47;
                        unint64_t v107 = v48;
                        id v105 = v49;
                        else {
                          __int16 v51 = off_189BBBBF0[v50];
                        }
                        os_log_type_t v103 = v51;
                        id v61 = v26;
                        os_log_type_t v62 = "path";
                        switch(*((_DWORD *)v26 + 29))
                        {
                          case 0:
                            break;
                          case 1:
                            os_log_type_t v62 = "resolver";
                            break;
                          case 2:
                            os_log_type_t v62 = nw_endpoint_flow_mode_string(v26[31]);
                            break;
                          case 3:
                            os_log_type_t v62 = "proxy";
                            break;
                          case 4:
                            os_log_type_t v62 = "fallback";
                            break;
                          case 5:
                            os_log_type_t v62 = "transform";
                            break;
                          default:
                            os_log_type_t v62 = "unknown-mode";
                            break;
                        }

                        BOOL v104 = v62;

                        os_log_type_t v64 = v61 + 28;
                        v65 = v61;
                        os_unfair_lock_lock(v61 + 28);
                        char v66 = v65[8];
                        os_unfair_lock_unlock(v64);

                        *(_DWORD *)buf = 136447746;
                        char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        __int16 v116 = 2082;
                        *(void *)int v117 = v26 + 21;
                        *(_WORD *)&v117[8] = 2082;
                        *(void *)&v117[10] = v106;
                        __int16 v118 = 2082;
                        nw_endpoint_t v119 = v105;
                        __int16 v120 = 2082;
                        v121 = v103;
                        __int16 v122 = 2082;
                        id v123 = v104;
                        uint64_t v124 = 2114;
                        dispatch_time_t v125 = v66;
                        _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nw_endpoint_f low_pre_attach_protocols",  buf,  0x48u);
                      }
                    }

                    nw_endpoint_handler_cancel(v26, 1LL, 0);
LABEL_102:
                    uint64_t v30 = 0LL;
                    goto LABEL_103;
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  BOOL v42 = (id)gLogObj;
                  *(_DWORD *)buf = 136446210;
                  char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                  uint64_t v43 = (char *)_os_log_send_and_compose_impl();

                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  unint64_t v112 = 0;
                  if ((__nwlog_fault(v43, &type, &v112) & 1) != 0)
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v44 = (os_log_s *)(id)gLogObj;
                      __int16 v45 = type;
                      if (os_log_type_enabled(v44, type))
                      {
                        *(_DWORD *)buf = 136446210;
                        char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl( &dword_181A5C000,  v44,  v45,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed",  buf,  0xCu);
                      }
                    }

                    else if (v112)
                    {
                      uint64_t v55 = (char *)__nw_create_backtrace_string();
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v44 = (os_log_s *)(id)gLogObj;
                      __int16 v56 = type;
                      nw_endpoint_t v57 = os_log_type_enabled(v44, type);
                      if (v55)
                      {
                        if (v57)
                        {
                          *(_DWORD *)buf = 136446466;
                          char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                          __int16 v116 = 2082;
                          *(void *)int v117 = v55;
                          _os_log_impl( &dword_181A5C000,  v44,  v56,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v55);
                        if (!v43) {
                          goto LABEL_102;
                        }
                        goto LABEL_93;
                      }

                      if (v57)
                      {
                        *(_DWORD *)buf = 136446210;
                        char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl( &dword_181A5C000,  v44,  v56,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, no backtrace",  buf,  0xCu);
                      }
                    }

                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v44 = (os_log_s *)(id)gLogObj;
                      v63 = type;
                      if (os_log_type_enabled(v44, type))
                      {
                        *(_DWORD *)buf = 136446210;
                        char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl( &dword_181A5C000,  v44,  v63,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, backtrace limit exceeded",  buf,  0xCu);
                      }
                    }
                  }

                  if (!v43) {
                    goto LABEL_102;
                  }
LABEL_93:
                  free(v43);
                  goto LABEL_102;
                }

                __nwlog_obj();
                os_log_type_t v91 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136446210;
                char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                nw_endpoint_t v88 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t type = OS_LOG_TYPE_ERROR;
                unint64_t v112 = 0;
                if (__nwlog_fault(v88, &type, &v112))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    id v92 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      char v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_181A5C000, v89, v92, "%{public}s called with null parameters", buf, 0xCu);
                    }

            BOOL v98 = *(_DWORD *)(v13 + 448);
            if (v98 != 1)
            {
              if (!v98)
              {
                if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                {
                  if (gLogDatapath)
                  {
                    v215 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEBUG))
                    {
                      nw_endpoint_t v216 = *(void *)(v63 + 88);
                      if (v216) {
                        v217 = *(_DWORD *)(v216 + 460);
                      }
                      else {
                        v217 = -1;
                      }
                      v231 = *(void *)(v63 + 64);
                      *(_DWORD *)buf = 136447746;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&void buf[14] = v63 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v217;
                      *(_WORD *)&v532[6] = 2048;
                      *(void *)&v532[8] = v231;
                      *(_WORD *)&v532[16] = 2048;
                      *(void *)&v532[18] = v63;
                      *(_WORD *)&v532[26] = 1024;
                      os_log_type_t v64 = v520;
                      *(_DWORD *)&v532[28] = v520;
                      _os_log_impl( &dword_181A5C000,  v215,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u",  buf,  0x40u);
                    }
                  }
                }

                os_log_type_t v99 = *(void *)(v63 + 88);
                if (*(void *)(v99 + 416) == v63)
                {
                  if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v219 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v219, OS_LOG_TYPE_DEBUG))
                      {
                        id v220 = *(void *)(v63 + 88);
                        if (v220) {
                          v221 = *(_DWORD *)(v220 + 460);
                        }
                        else {
                          v221 = -1;
                        }
                        v256 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&void buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v221;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v256;
                        _os_log_impl( &dword_181A5C000,  v219,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream",  buf,  0x30u);
                        os_log_type_t v64 = v520;
                      }
                    }
                  }

                  nw_protocol_connected(*(void **)(v63 + 48), v63);
                }

                else
                {
                  if (nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken != -1) {
                    dispatch_once( &nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken,  &__block_literal_global_28);
                  }
                  *(void *)(v63 + 24) = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
                  nw_protocol_set_output_handler(v63, v99);
                  os_log_type_t v100 = nw_parameters_copy_protocol_options_legacy(*(void **)(v63 + 144), (nw_protocol *)v63);
                  if (v100)
                  {
                    nw_endpoint_t v101 = v100;
                    if (v64)
                    {
                      if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                      {
                        if (gLogDatapath)
                        {
                          __int16 v116 = (os_log_s *)__nwlog_obj();
                          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG))
                          {
                            int v117 = *(void *)(v63 + 88);
                            if (v117) {
                              __int16 v118 = *(_DWORD *)(v117 + 460);
                            }
                            else {
                              __int16 v118 = -1;
                            }
                            v259 = *(void *)(v63 + 64);
                            *(_DWORD *)buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&void buf[14] = v63 + 192;
                            *(_WORD *)&buf[22] = 2080;
                            v531 = (uint64_t)" ";
                            *(_WORD *)v532 = 1024;
                            *(_DWORD *)&v532[2] = v118;
                            *(_WORD *)&v532[6] = 2048;
                            *(void *)&v532[8] = v259;
                            _os_log_impl( &dword_181A5C000,  v116,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment to setup metadata",  buf,  0x30u);
                            os_log_type_t v64 = v520;
                          }
                        }
                      }
                    }

                    else if (nw_protocol_options_is_webtransport(v100))
                    {
                      *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xFC | 1;
                      if (nw_webtransport_options_get_is_datagram(v101)) {
                        os_log_type_t v102 = 8;
                      }
                      else {
                        os_log_type_t v102 = 0;
                      }
                      *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xF7 | v102;
                      is_unidirectional = nw_webtransport_options_get_is_unidirectional(v101);
                      BOOL v104 = *(_BYTE *)(v63 + 276);
                      if (is_unidirectional) {
                        id v105 = 4;
                      }
                      else {
                        id v105 = 0;
                      }
                      *(_BYTE *)(v63 + 276) = v104 & 0xFB | v105;
                      if ((v104 & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        uint64_t v106 = (os_log_s *)gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                        {
                          unint64_t v107 = *(void *)(v63 + 88);
                          if (v107) {
                            unint64_t v108 = *(_DWORD *)(v107 + 460);
                          }
                          else {
                            unint64_t v108 = -1;
                          }
                          v155 = *(void *)(v63 + 64);
                          v156 = *(unsigned __int8 *)(v63 + 276);
                          *(_DWORD *)buf = 136448002;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&void buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v108;
                          *(_WORD *)&v532[6] = 2048;
                          *(void *)&v532[8] = v155;
                          *(_WORD *)&v532[16] = 1024;
                          *(_DWORD *)&v532[18] = (v156 >> 1) & 1;
                          *(_WORD *)&v532[22] = 1024;
                          *(_DWORD *)&v532[24] = (v156 >> 3) & 1;
                          *(_WORD *)&v532[28] = 1024;
                          *(_DWORD *)&v532[30] = (v156 >> 2) & 1;
                          _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, data gram: %u, unidirectional: %u",  buf,  0x42u);
                        }
                      }

                      nw_webtransport_metadata_set_is_peer_initiated( *(void **)(v63 + 160),  (*(_BYTE *)(v63 + 276) & 2) != 0);
                      nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 8) != 0);
                      nw_webtransport_metadata_set_is_unidirectional( *(void **)(v63 + 160),  (*(_BYTE *)(v63 + 276) & 4) != 0);
                    }

                    else if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v138 = (os_log_s *)gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v139 = *(void *)(v63 + 88);
                        if (v139) {
                          v140 = *(_DWORD *)(v139 + 460);
                        }
                        else {
                          v140 = -1;
                        }
                        nw_endpoint_t v162 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&void buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v140;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v162;
                        _os_log_impl( &dword_181A5C000,  v138,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream",  buf,  0x30u);
                      }
                    }

                    os_release(v101);
                  }

                  else if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v113 = (os_log_s *)gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                    {
                      id v114 = *(void *)(v63 + 88);
                      if (v114) {
                        char v115 = *(_DWORD *)(v114 + 460);
                      }
                      else {
                        char v115 = -1;
                      }
                      v145 = *(void *)(v63 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&void buf[14] = v63 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v115;
                      *(_WORD *)&v532[6] = 2048;
                      *(void *)&v532[8] = v145;
                      _os_log_impl( &dword_181A5C000,  v113,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring",  buf,  0x30u);
                    }
                  }
                }

                if (v63 != *(void *)(v13 + 416)) {
                  nw_protocol_connected((void *)v63, v13);
                }
              }

    if (v44) {
      free(v44);
    }
    return 1LL;
  }

  *(void *)os_log_type_t v62 = a2;
  __int16 v6 = nghttp2_submit_headers();
  if (v6 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = nghttp2_strerror();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v64 = "nw_http2_transport_send_headers";
    v65 = 2082;
    char v66 = v14;
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v60 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v16 = (os_log_s *)gLogObj;
      os_log_type_t v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_65;
      }
      BOOL v18 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      os_log_type_t v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      char v66 = v18;
      os_log_type_t v19 = "%{public}s nghttp2_submit_headers: %{public}s failed";
    }

    else if (v60)
    {
      BOOL v20 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v16 = (os_log_s *)gLogObj;
      os_log_type_t v17 = type;
      os_log_type_t v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v20)
      {
        if (v21)
        {
          os_log_type_t v22 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          os_log_type_t v64 = "nw_http2_transport_send_headers";
          v65 = 2082;
          char v66 = v22;
          uint64_t v67 = 2082;
          *(void *)os_log_type_t v68 = v20;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s nghttp2_submit_headers: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v20);
        goto LABEL_65;
      }

      if (!v21) {
        goto LABEL_65;
      }
      __int16 v31 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      os_log_type_t v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      char v66 = v31;
      os_log_type_t v19 = "%{public}s nghttp2_submit_headers: %{public}s failed, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v16 = (os_log_s *)gLogObj;
      os_log_type_t v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_65;
      }
      __int16 v28 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      os_log_type_t v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      char v66 = v28;
      os_log_type_t v19 = "%{public}s nghttp2_submit_headers: %{public}s failed, backtrace limit exceeded";
    }

    BOOL v32 = v16;
    uint64_t v33 = v17;
LABEL_64:
    _os_log_impl(&dword_181A5C000, v32, v33, v19, buf, 0x16u);
    goto LABEL_65;
  }

  __int16 v7 = *(void *)v62;
  os_log_type_t v8 = *(_DWORD *)(*(void *)v62 + 32LL);
  if (v8 == -1)
  {
    if ((*(_BYTE *)(*(void *)v62 + 36LL) & 8) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      os_log_type_t v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      char v66 = a1 + 205;
      os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      __int16 v60 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v23 = (os_log_s *)gLogObj;
        char v24 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_65;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_http2_transport_send_headers";
        v65 = 2082;
        char v66 = a1 + 205;
        os_log_type_t v19 = "%{public}s %{public}s Responder stream cannot have id of -1 after opening";
        goto LABEL_63;
      }

      if (!v60)
      {
        __int16 v23 = (os_log_s *)__nwlog_obj();
        char v24 = type;
        if (!os_log_type_enabled(v23, type)) {
          goto LABEL_65;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_http2_transport_send_headers";
        v65 = 2082;
        char v66 = a1 + 205;
        os_log_type_t v19 = "%{public}s %{public}s Responder stream cannot have id of -1 after opening, backtrace limit exceeded";
        goto LABEL_63;
      }

      BOOL v25 = (char *)__nw_create_backtrace_string();
      __int16 v23 = (os_log_s *)__nwlog_obj();
      char v24 = type;
      BOOL v29 = os_log_type_enabled(v23, type);
      if (!v25)
      {
        if (!v29) {
          goto LABEL_65;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_http2_transport_send_headers";
        v65 = 2082;
        char v66 = a1 + 205;
        os_log_type_t v19 = "%{public}s %{public}s Responder stream cannot have id of -1 after opening, no backtrace";
        goto LABEL_63;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v64 = "nw_http2_transport_send_headers";
        v65 = 2082;
        char v66 = a1 + 205;
        uint64_t v67 = 2082;
        *(void *)os_log_type_t v68 = v25;
        char v27 = "%{public}s %{public}s Responder stream cannot have id of -1 after opening, dumping backtrace:%{public}s";
        goto LABEL_46;
      }

LABEL_121:
      if (v50) {
        free(v50);
      }
      goto LABEL_123;
    }

    if (!v80)
    {
      __nwlog_obj();
      __int16 v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v66 = type[0];
      if (os_log_type_enabled(v51, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_proxy_config_supports_connection";
        _os_log_impl( &dword_181A5C000,  v51,  v66,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_120;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v62 = type[0];
    v63 = os_log_type_enabled(v51, type[0]);
    if (!backtrace_string)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_proxy_config_supports_connection";
        _os_log_impl(&dword_181A5C000, v51, v62, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_120;
    }

    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_proxy_config_supports_connection";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v51,  v62,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

      free(v63);
    }

        if (v61) {
          free(v61);
        }
        *(_DWORD *)(v8 + 344) = 0;
        os_log_type_t v15 = object;
        if ((*(_WORD *)(v11 + 428) & 8) == 0)
        {
LABEL_140:
          if ((*(_BYTE *)(v11 + 158) & 1) == 0)
          {
            if (gLogDatapath)
            {
              v278 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v278, OS_LOG_TYPE_DEBUG))
              {
                v279 = *(void *)(v11 + 256);
                v280 = *(_DWORD *)(*(void *)(v11 + 248) + 372LL);
                if (v279) {
                  LODWORD(v279) = *(_DWORD *)(v279 + 860);
                }
                nw_endpoint_t v281 = *(_DWORD *)(v11 + 424);
                v282 = *(_DWORD *)(v8 + 344);
                *(_DWORD *)buf = 136448258;
                *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v11 + 74;
                *(_WORD *)&buf[22] = 2080;
                *(void *)&_BYTE buf[24] = " ";
                *(_WORD *)&_BYTE buf[32] = 1024;
                *(_DWORD *)&buf[34] = v280;
                *(_WORD *)&buf[38] = 1024;
                *(_DWORD *)&buf[40] = v279;
                *(_WORD *)&buf[44] = 1024;
                *(_DWORD *)&buf[46] = v281;
                *(_WORD *)&buf[50] = 1024;
                *(_DWORD *)&buf[52] = v281;
                *(_WORD *)&buf[56] = 2048;
                *(void *)&buf[58] = v11;
                *(_WORD *)&buf[66] = 1024;
                *(_DWORD *)&buf[68] = v282;
                _os_log_impl( &dword_181A5C000,  v278,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed stream %u (%p), now have %u streams",  buf,  0x48u);
              }
            }
          }

          if (v13)
          {
            if (v15)
            {
              uint64_t v86 = (char *)calloc(1uLL, 0x1B0uLL);
              if (!v86)
              {
                v287 = (os_log_s *)__nwlog_obj();
                os_log_type_enabled(v287, OS_LOG_TYPE_ERROR);
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "strict_calloc";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&void buf[14] = 1LL;
                *(_WORD *)&buf[22] = 2048;
                *(void *)&_BYTE buf[24] = 432LL;
                v288 = (void *)_os_log_send_and_compose_impl();
                result = __nwlog_abort((uint64_t)v288);
                if (result)
                {
                  __break(1u);
                  return result;
                }

                free(v288);
              }

              *((_OWORD *)v86 + 25) = 0u;
              *((_OWORD *)v86 + 26) = 0u;
              *((_OWORD *)v86 + 23) = 0u;
              *((_OWORD *)v86 + 24) = 0u;
              *((_OWORD *)v86 + 21) = 0u;
              *((_OWORD *)v86 + 22) = 0u;
              *((_OWORD *)v86 + 19) = 0u;
              *((_OWORD *)v86 + 20) = 0u;
              *((_OWORD *)v86 + 17) = 0u;
              *((_OWORD *)v86 + 1_Block_object_dispose((const void *)(v67 - 152), 8) = 0u;
              *((_OWORD *)v86 + 15) = 0u;
              *((_OWORD *)v86 + 16) = 0u;
              *((_OWORD *)v86 + 13) = 0u;
              *((_OWORD *)v86 + 14) = 0u;
              *((_OWORD *)v86 + 11) = 0u;
              *((_OWORD *)v86 + 12) = 0u;
              *((_OWORD *)v86 + 9) = 0u;
              *((_OWORD *)v86 + 10) = 0u;
              *((_OWORD *)v86 + 7) = 0u;
              *((_OWORD *)v86 + _Block_object_dispose((const void *)(v67 - 152), 8) = 0u;
              *((_OWORD *)v86 + 5) = 0u;
              *((_OWORD *)v86 + 6) = 0u;
              *((_OWORD *)v86 + 3) = 0u;
              *((_OWORD *)v86 + 4) = 0u;
              *((_OWORD *)v86 + 1) = 0u;
              *((_OWORD *)v86 + 2) = 0u;
              *(_OWORD *)uint64_t v86 = 0u;
              *((void *)v86 + 2) = *(void *)(v8 + 16);
              *((void *)v86 + 3) = &nw_protocol_http1_get_callbacks(void)::http1_protocol_callbacks;
              *((_DWORD *)v86 + 60) = 2;
              *((void *)v86 + 2_Block_object_dispose((const void *)(v67 - 152), 8) = v86;
              *((void *)v86 + 5) = v86 + 216;
              *((void *)v86 + 31) = v8;
              nw_protocol_set_input_handler((uint64_t)v86, (uint64_t)v376);
              nw_protocol_set_output_handler((uint64_t)v86, *(void *)(v8 + 32));
              *(void *)buf = 0LL;
              *(void *)&buf[8] = buf;
              *(void *)&buf[16] = 0x2000000000LL;
              *(void *)&_BYTE buf[24] = v86;
              *(void *)aBlock = MEMORY[0x1895F87A8];
              *(void *)&aBlock[8] = 0x40000000LL;
              *(void *)&aBlock[16] = ___ZL22nw_http1_stream_createP11nw_protocolP17nw_protocol_http1P11nw_endpointP13nw_parameters_block_invoke;
              v385 = (uint64_t)&unk_189BBD868;
              *(void *)id v386 = buf;
              *((void *)v86 + 39) = _Block_copy(aBlock);
              _Block_object_dispose(buf, 8);
              BOOL v87 = os_retain(v13);
              nw_endpoint_t v88 = v86[344];
              if ((v88 & 1) != 0)
              {
                os_log_type_t v89 = (void *)*((void *)v86 + 42);
                if (v89)
                {
                  os_release(v89);
                  nw_endpoint_t v88 = v86[344];
                }
              }

              *((void *)v86 + 42) = v87;
              v86[344] = v88 | 1;
              os_log_type_t v90 = os_retain(v15);
              os_log_type_t v91 = v86[328];
              if ((v91 & 1) != 0)
              {
                id v92 = (void *)*((void *)v86 + 40);
                if (v92)
                {
                  os_release(v92);
                  os_log_type_t v91 = v86[328];
                }
              }

              *((void *)v86 + 40) = v90;
              v86[328] = v91 | 1;
              if ((v86[158] & 1) == 0)
              {
                if (gLogDatapath)
                {
                  v293 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v293, OS_LOG_TYPE_DEBUG))
                  {
                    os_log_type_t v294 = *((void *)v86 + 32);
                    v295 = *(_DWORD *)(*((void *)v86 + 31) + 372LL);
                    if (v294) {
                      LODWORD(v294) = *(_DWORD *)(v294 + 860);
                    }
                    os_log_type_t v296 = *((_DWORD *)v86 + 106);
                    *(_DWORD *)buf = 136447746;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_create";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&void buf[14] = v86 + 74;
                    *(_WORD *)&buf[22] = 2080;
                    *(void *)&_BYTE buf[24] = " ";
                    *(_WORD *)&_BYTE buf[32] = 1024;
                    *(_DWORD *)&buf[34] = v295;
                    *(_WORD *)&buf[38] = 1024;
                    *(_DWORD *)&buf[40] = v294;
                    *(_WORD *)&buf[44] = 1024;
                    *(_DWORD *)&buf[46] = v296;
                    *(_WORD *)&buf[50] = 2048;
                    *(void *)&buf[52] = v86;
                    _os_log_impl( &dword_181A5C000,  v293,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> created %p",  buf,  0x3Cu);
                  }
                }
              }

              v376->output_handler_context = v86;
              id v93 = v15;
              os_log_type_t v94 = *(id *)(v93[13] + 136LL);

              os_log_type_t v95 = v86[272];
              if ((v95 & 1) != 0)
              {
                BOOL v96 = (void *)*((void *)v86 + 33);
                if (v96)
                {
                  os_release(v96);
                  os_log_type_t v95 = v86[272];
                }
              }

              *((void *)v86 + 33) = v94;
              v86[272] = v95 | 1;
              BOOL v97 = _nw_http_parsed_fields_create();
              BOOL v98 = v86[408];
              if ((v98 & 1) != 0)
              {
                os_log_type_t v99 = (void *)*((void *)v86 + 50);
                if (v99)
                {
                  os_release(v99);
                  BOOL v98 = v86[408];
                }
              }

              *((void *)v86 + 50) = v97;
              v86[408] = v98 | 1;
              v86[208] = *(_BYTE *)(v8 + 376) & 1;
              os_log_type_t v100 = nw_parameters_copy_protocol_options_legacy(v93, (nw_protocol *)v8);
              nw_endpoint_t v101 = v100;
              if (!v100 || (singleton = nw_http_messaging_options_copy_transaction_metadata(v100)) == 0LL)
              {
                if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
                  dispatch_once( &nw_protocol_copy_http_transaction_definition_onceToken,  &__block_literal_global_59_74543);
                }
                singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_transaction_definition_definition);
              }

              os_log_type_t v103 = v86[360];
              if ((v103 & 1) != 0)
              {
                BOOL v104 = (void *)*((void *)v86 + 44);
                if (v104)
                {
                  os_release(v104);
                  os_log_type_t v103 = v86[360];
                }
              }

              *((void *)v86 + 44) = singleton;
              v86[360] = v103 | 1;
              if (v101) {
                os_release(v101);
              }
              id v105 = nw_parameters_copy_protocol_options_legacy(v93, (nw_protocol *)v11);
              if (v105)
              {
                uint64_t v106 = v105;
                if ((v86[158] & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    id v311 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v311, OS_LOG_TYPE_DEBUG))
                    {
                      v312 = *((void *)v86 + 32);
                      os_log_type_t v313 = *(_DWORD *)(*((void *)v86 + 31) + 372LL);
                      if (v312) {
                        LODWORD(v312) = *(_DWORD *)(v312 + 860);
                      }
                      BOOL v314 = *((_DWORD *)v86 + 106);
                      *(_DWORD *)buf = 136448770;
                      *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&void buf[14] = v86 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      *(void *)&_BYTE buf[24] = " ";
                      *(_WORD *)&_BYTE buf[32] = 1024;
                      *(_DWORD *)&buf[34] = v313;
                      *(_WORD *)&buf[38] = 1024;
                      *(_DWORD *)&buf[40] = v312;
                      *(_WORD *)&buf[44] = 1024;
                      *(_DWORD *)&buf[46] = v314;
                      *(_WORD *)&buf[50] = 2048;
                      *(void *)&buf[52] = v86;
                      *(_WORD *)&buf[60] = 2048;
                      *(void *)&buf[62] = v8;
                      *(_WORD *)&buf[70] = 2048;
                      *(void *)&buf[72] = v11;
                      *(_WORD *)v381 = 2048;
                      *(void *)&v381[2] = v93;
                      nw_endpoint_t v382 = 2048;
                      v383 = v106;
                      _os_log_impl( &dword_181A5C000,  v311,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http1_stream protocol %p, set protocol instance to %p inste ad of %p in parameters %p options %p",  buf,  0x64u);
                    }
                  }
                }

                if (nw_protocol_copy_http1_definition_onceToken != -1) {
                  dispatch_once(&nw_protocol_copy_http1_definition_onceToken, &__block_literal_global_72463);
                }
                unint64_t v107 = (id)nw_protocol_copy_http1_definition_http1_definition;
                unint64_t v108 = v106;
                *((void *)v108 + 2) = v8;

                if (v107) {
                  os_release(v107);
                }
                os_release(v108);
              }

              nw_protocol_set_input_handler((uint64_t)v86, (uint64_t)v376);
              *(_OWORD *)uint64_t v86 = *(_OWORD *)v376->flow_id;
              nw_protocol_set_output_handler((uint64_t)v376, (uint64_t)v86);
              unint64_t v109 = (uint64_t *)*((void *)v86 + 40);
              if (v109)
              {
                os_log_type_t v110 = nw_parameters_copy_protocol_options_legacy(*((void **)v86 + 40), (nw_protocol *)v8);
                if (v110)
                {
                  BOOL v111 = v110;
                  if ((v86[158] & 1) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v315 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v315, OS_LOG_TYPE_DEBUG))
                      {
                        os_log_type_t v316 = *((void *)v86 + 32);
                        BOOL v317 = *(_DWORD *)(*((void *)v86 + 31) + 372LL);
                        if (v316) {
                          LODWORD(v316) = *(_DWORD *)(v316 + 860);
                        }
                        os_log_type_t v318 = *((_DWORD *)v86 + 106);
                        *(_DWORD *)buf = 136448770;
                        *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&void buf[14] = v86 + 74;
                        *(_WORD *)&buf[22] = 2080;
                        *(void *)&_BYTE buf[24] = " ";
                        *(_WORD *)&_BYTE buf[32] = 1024;
                        *(_DWORD *)&buf[34] = v317;
                        *(_WORD *)&buf[38] = 1024;
                        *(_DWORD *)&buf[40] = v316;
                        *(_WORD *)&buf[44] = 1024;
                        *(_DWORD *)&buf[46] = v318;
                        *(_WORD *)&buf[50] = 2048;
                        *(void *)&buf[52] = v86;
                        *(_WORD *)&buf[60] = 2048;
                        *(void *)&buf[62] = v86;
                        *(_WORD *)&buf[70] = 2048;
                        *(void *)&buf[72] = v8;
                        *(_WORD *)v381 = 2048;
                        *(void *)&v381[2] = v109;
                        nw_endpoint_t v382 = 2048;
                        v383 = v111;
                        _os_log_impl( &dword_181A5C000,  v315,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http1_stream protocol %p, set protocol instance to %p ins tead of %p in parameters %p options %p",  buf,  0x64u);
                      }
                    }
                  }

                  if (nw_protocol_copy_http1_definition_onceToken != -1) {
                    dispatch_once(&nw_protocol_copy_http1_definition_onceToken, &__block_literal_global_72463);
                  }
                  unint64_t v112 = (id)nw_protocol_copy_http1_definition_http1_definition;
                  v113 = v111;
                  *((void *)v113 + 2) = v86;

                  if (v112) {
                    os_release(v112);
                  }
                  os_release(v113);
                }

                *(_DWORD *)v381 = 0;
                memset(buf, 0, sizeof(buf));
                id v114 = nw_parameters_copy_protocol_options_legacy(*((void **)v86 + 40), (nw_protocol *)v86);
                char v115 = v114;
                if (v114)
                {
                  __int16 v116 = v114;
                  int v117 = 0LL;
                  buf[0] = 0;
                  while (1)
                  {
                    __int16 v118 = v116[v117 + 48];
                    buf[v117] = v118;
                    if (!v118) {
                      break;
                    }
                    if (++v117 == 83)
                    {
                      v381[3] = 0;
                      break;
                    }
                  }
                }

                else if ((v86[158] & 1) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  nw_endpoint_t v119 = (os_log_s *)gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  {
                    __int16 v120 = *((void *)v86 + 32);
                    v121 = *(_DWORD *)(*((void *)v86 + 31) + 372LL);
                    if (v120) {
                      LODWORD(v120) = *(_DWORD *)(v120 + 860);
                    }
                    __int16 v122 = *((_DWORD *)v86 + 106);
                    *(_DWORD *)aBlock = 136448002;
                    *(void *)&aBlock[4] = "nw_http1_stream_add_input_handler";
                    *(_WORD *)&aBlock[12] = 2082;
                    *(void *)&aBlock[14] = v86 + 74;
                    *(_WORD *)&aBlock[22] = 2080;
                    v385 = (uint64_t)" ";
                    *(_WORD *)id v386 = 1024;
                    *(_DWORD *)&v386[2] = v121;
                    *(_WORD *)&v386[6] = 1024;
                    *(_DWORD *)&v386[8] = v120;
                    *(_WORD *)&v386[12] = 1024;
                    *(_DWORD *)&v386[14] = v122;
                    *(_WORD *)&v386[18] = 2048;
                    *(void *)&v386[20] = v86;
                    *(_WORD *)&v386[28] = 2048;
                    *(void *)&v386[30] = v109;
                    _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> Failed to access options for protocol %p, parameters %p",  aBlock,  0x46u);
                  }
                }

                v373 = v13;
                if ((*(_BYTE *)(v8 + 158) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    v297 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v297, OS_LOG_TYPE_DEBUG))
                    {
                      os_log_type_t v298 = *(_DWORD *)(v8 + 372);
                      *(_DWORD *)aBlock = 136447234;
                      *(void *)&aBlock[4] = "nw_http1_add_stream";
                      *(_WORD *)&aBlock[12] = 2082;
                      *(void *)&aBlock[14] = v8 + 74;
                      *(_WORD *)&aBlock[22] = 2080;
                      v385 = (uint64_t)" ";
                      *(_WORD *)id v386 = 1024;
                      *(_DWORD *)&v386[2] = v298;
                      *(_WORD *)&v386[6] = 2048;
                      *(void *)&v386[8] = v86;
                      _os_log_impl( &dword_181A5C000,  v297,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream (%p)",  aBlock,  0x30u);
                    }
                  }
                }

                *((void *)v86 + 35) = 0LL;
                id v123 = *(void **)(v8 + 240);
                *((void *)v86 + 36) = v123;
                *id v123 = v86;
                *(void *)(v8 + 240) = v86 + 280;
                uint64_t v124 = *(unsigned int *)(v8 + 344) + 1LL;
                dispatch_time_t v125 = v124 << 31 >> 31;
                *(_DWORD *)(v8 + 344) = v124;
                if (v125 == v124 && (v125 & 0x8000000000000000LL) == 0)
                {
LABEL_220:
                  nw_endpoint_t v137 = *(unsigned int *)(v8 + 356) + 1LL;
                  v138 = v137 << 31 >> 31;
                  *(_DWORD *)(v8 + 356) = v137;
                  if (v138 == v137 && (v138 & 0x8000000000000000LL) == 0) {
                    goto LABEL_239;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v139 = *(unsigned int *)(v8 + 356);
                  *(_DWORD *)aBlock = 136446978;
                  *(void *)&aBlock[4] = "nw_http1_add_stream";
                  *(_WORD *)&aBlock[12] = 2082;
                  *(void *)&aBlock[14] = "http1->next_stream_log_num";
                  *(_WORD *)&aBlock[22] = 2048;
                  v385 = 1LL;
                  *(_WORD *)id v386 = 2048;
                  *(void *)&v386[2] = v139;
                  v140 = (char *)_os_log_send_and_compose_impl();
                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  v378 = 0;
                  if (__nwlog_fault(v140, &type, &v378))
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      int v141 = (os_log_s *)gLogObj;
                      char v142 = type;
                      if (os_log_type_enabled((os_log_t)gLogObj, type))
                      {
                        v143 = *(unsigned int *)(v8 + 356);
                        *(_DWORD *)aBlock = 136446978;
                        *(void *)&aBlock[4] = "nw_http1_add_stream";
                        *(_WORD *)&aBlock[12] = 2082;
                        *(void *)&aBlock[14] = "http1->next_stream_log_num";
                        *(_WORD *)&aBlock[22] = 2048;
                        v385 = 1LL;
                        *(_WORD *)id v386 = 2048;
                        *(void *)&v386[2] = v143;
                        v144 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_235:
                        _os_log_impl(&dword_181A5C000, v141, v142, v144, aBlock, 0x2Au);
                      }
                    }

                    else if (v378)
                    {
                      v145 = (char *)__nw_create_backtrace_string();
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      int v141 = (os_log_s *)gLogObj;
                      char v142 = type;
                      nw_endpoint_t v146 = os_log_type_enabled((os_log_t)gLogObj, type);
                      if (v145)
                      {
                        if (v146)
                        {
                          v147 = *(unsigned int *)(v8 + 356);
                          *(_DWORD *)aBlock = 136447234;
                          *(void *)&aBlock[4] = "nw_http1_add_stream";
                          *(_WORD *)&aBlock[12] = 2082;
                          *(void *)&aBlock[14] = "http1->next_stream_log_num";
                          *(_WORD *)&aBlock[22] = 2048;
                          v385 = 1LL;
                          *(_WORD *)id v386 = 2048;
                          *(void *)&v386[2] = v147;
                          *(_WORD *)&v386[10] = 2082;
                          *(void *)&v386[12] = v145;
                          _os_log_impl( &dword_181A5C000,  v141,  v142,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  aBlock,  0x34u);
                        }

                        free(v145);
                        goto LABEL_236;
                      }

                      if (v146)
                      {
                        v149 = *(unsigned int *)(v8 + 356);
                        *(_DWORD *)aBlock = 136446978;
                        *(void *)&aBlock[4] = "nw_http1_add_stream";
                        *(_WORD *)&aBlock[12] = 2082;
                        *(void *)&aBlock[14] = "http1->next_stream_log_num";
                        *(_WORD *)&aBlock[22] = 2048;
                        v385 = 1LL;
                        *(_WORD *)id v386 = 2048;
                        *(void *)&v386[2] = v149;
                        v144 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                        goto LABEL_235;
                      }
                    }

                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      int v141 = (os_log_s *)gLogObj;
                      char v142 = type;
                      if (os_log_type_enabled((os_log_t)gLogObj, type))
                      {
                        v148 = *(unsigned int *)(v8 + 356);
                        *(_DWORD *)aBlock = 136446978;
                        *(void *)&aBlock[4] = "nw_http1_add_stream";
                        *(_WORD *)&aBlock[12] = 2082;
                        *(void *)&aBlock[14] = "http1->next_stream_log_num";
                        *(_WORD *)&aBlock[22] = 2048;
                        v385 = 1LL;
                        *(_WORD *)id v386 = 2048;
                        *(void *)&v386[2] = v148;
                        v144 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                        goto LABEL_235;
                      }
                    }
                  }

        if (v27) {
          free(v27);
        }
        BOOL v14 = 0LL;
        goto LABEL_21;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      __int16 v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        size_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        uint64_t v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_181A5C000, v28, v29, v43, buf, 0x16u);
      }
    }

    free(v41);
    goto LABEL_120;
  }

        if (v27) {
          free(v27);
        }
        BOOL v14 = 0LL;
        goto LABEL_21;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      __int16 v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        size_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        uint64_t v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_181A5C000, v28, v29, v43, buf, 0x16u);
      }
    }

    free(v41);
    goto LABEL_120;
  }

        if (v27) {
          free(v27);
        }
        BOOL v14 = 0LL;
        goto LABEL_21;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      __int16 v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        size_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        uint64_t v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_181A5C000, v28, v29, v43, buf, 0x16u);
      }
    }

    free(v41);
    goto LABEL_120;
  }

        if (v27) {
          free(v27);
        }
        BOOL v14 = 0LL;
        goto LABEL_21;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      __int16 v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          uint64_t v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        size_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        uint64_t v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_181A5C000, v28, v29, v43, buf, 0x16u);
      }
    }

    free(v41);
    goto LABEL_120;
  }

  if (v64) {
    free(v64);
  }
LABEL_20:
}
            }
          }

    if (v51) {
      free(v51);
    }
    os_log_type_t v13 = 0LL;
    goto LABEL_63;
  }

  *(void *)uint64_t v67 = 0LL;
  os_log_type_t v68 = v67;
  v69 = 0x2020000000LL;
  __int16 v70 = 0LL;
  os_log_type_t v64 = v9;
  if ((nw_endpoint_flow_is_multipath(v9) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_ERROR, "%{public}s Called on non-Multipath connection", buf, 0xCu);
    }

    goto LABEL_53;
  }

  BOOL v11 = (os_log_s *)nw_endpoint_flow_copy_connected_socket_wrapper(v10);
  os_log_type_t v12 = v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v30 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
      _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_DEBUG, "%{public}s connected_fd is not yet set", buf, 0xCu);
    }

    os_log_type_t v12 = 0LL;
    goto LABEL_53;
  }

  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = ___Z46nw_endpoint_flow_copy_multipath_subflow_countsP27NWConcrete_nw_endpoint_flow_block_invoke;
  int v79 = &unk_189BC78E8;
  __int16 v80 = v67;
  if ((nw_fd_wrapper_get_fd(v11, buf) & 1) == 0)
  {
LABEL_53:
    os_log_type_t v13 = 0LL;
    goto LABEL_54;
  }

  os_log_type_t v13 = xpc_dictionary_create(0LL, 0LL, 0LL);
  os_log_type_t v62 = v12;
  if (!v13)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = (id)gLogObj;
    *(_DWORD *)BOOL v71 = 136446210;
    __int16 v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    key[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v39, key, &type))
    {
      if (key[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v40 = (os_log_s *)(id)gLogObj;
        __int16 v41 = key[0];
        if (os_log_type_enabled(v40, (os_log_type_t)key[0]))
        {
          *(_DWORD *)BOOL v71 = 136446210;
          __int16 v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A5C000, v40, v41, "%{public}s xpc_dictionary_create failed", v71, 0xCu);
        }
      }

      else if (type)
      {
        BOOL v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v40 = (os_log_s *)(id)gLogObj;
        uint64_t v43 = key[0];
        os_log_type_t v44 = os_log_type_enabled(v40, (os_log_type_t)key[0]);
        if (v42)
        {
          if (v44)
          {
            *(_DWORD *)BOOL v71 = 136446466;
            __int16 v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
            BOOL v73 = 2082;
            v74[0] = v42;
            _os_log_impl( &dword_181A5C000,  v40,  v43,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  v71,  0x16u);
          }

          free(v42);
          goto LABEL_83;
        }

        if (v44)
        {
          *(_DWORD *)BOOL v71 = 136446210;
          __int16 v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_181A5C000, v40, v43, "%{public}s xpc_dictionary_create failed, no backtrace", v71, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v40 = (os_log_s *)(id)gLogObj;
        __int16 v45 = key[0];
        if (os_log_type_enabled(v40, (os_log_type_t)key[0]))
        {
          *(_DWORD *)BOOL v71 = 136446210;
          __int16 v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl( &dword_181A5C000,  v40,  v45,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  v71,  0xCu);
        }
      }
    }

                goto LABEL_121;
              }

    if (v44) {
      free(v44);
    }
LABEL_12:
    BOOL v14 = necp_client_action();
    os_log_type_t v15 = v14 == 0;
    if (!v14)
    {
LABEL_51:
      free(v13);
      goto LABEL_52;
    }

    char v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v16 == 45 || v16 == 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v17 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_path_agent_action";
        v65 = 1024;
        *(_DWORD *)char v66 = v16;
        _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d",  buf,  0x12u);
      }

      goto LABEL_51;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    os_log_type_t v64 = "nw_path_agent_action";
    v65 = 1024;
    *(_DWORD *)char v66 = v16;
    __int16 v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v61 = 0;
    if (__nwlog_fault(v23, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v64 = "nw_path_agent_action";
          v65 = 1024;
          *(_DWORD *)char v66 = v16;
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
        }
      }

      else if (v61)
      {
        os_log_type_t v26 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v27 = type;
        __int16 v28 = os_log_type_enabled(v24, type);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v64 = "nw_path_agent_action";
            v65 = 1024;
            *(_DWORD *)char v66 = v16;
            *(_WORD *)&v66[4] = 2082;
            *(void *)&v66[6] = v26;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v26);
          goto LABEL_49;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v64 = "nw_path_agent_action";
          v65 = 1024;
          *(_DWORD *)char v66 = v16;
          _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        char v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v64 = "nw_path_agent_action";
          v65 = 1024;
          *(_DWORD *)char v66 = v16;
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    goto LABEL_86;
  }

  if (!v16)
  {
    __nwlog_obj();
    os_log_type_t v62 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();

    v80[0] = 16;
    uu[0] = 0;
    if (v80[0] == 17)
    {
      __nwlog_obj();
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v63 = v80[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v80[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v30, v63, "%{public}s called with null parameters", buf, 0xCu);
      }

      goto LABEL_85;
    }

    if (!uu[0])
    {
      __nwlog_obj();
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v70 = v80[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v80[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v30,  v70,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_85;
    }

    uint64_t v39 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v67 = v80[0];
    os_log_type_t v68 = os_log_type_enabled(v40, (os_log_type_t)v80[0]);
    if (v39)
    {
      if (v68)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v39;
        _os_log_impl( &dword_181A5C000,  v40,  v67,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_70;
    }

    if (v68)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
      _os_log_impl(&dword_181A5C000, v40, v67, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
    }

    goto LABEL_120;
  }

  BOOL v18 = v16;
  os_log_type_t v19 = *(id *)(v18[13] + 136LL);

  nw_context_assert_queue(v19);
  if (!v17 && (a1 - 421890) <= 9 && ((1 << (a1 - 2)) & 0x307) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v26 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      char v27 = off_189BC7480[a1 - 421890];
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v27;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s symptom reported when no path found",  buf,  0x16u);
    }

    goto LABEL_88;
  }

  if (nw_connection_get_symptom_reporter_handle::once != -1) {
    dispatch_once(&nw_connection_get_symptom_reporter_handle::once, &__block_literal_global_78285);
  }
  if (!nw_connection_get_symptom_reporter_handle::symptom_reporter)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v28 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();

    v80[0] = 16;
    uu[0] = 0;
    if (v80[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v30 = (os_log_s *)(id)gLogObj;
      __int16 v31 = v80[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v80[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s nw_connection_get_symptom_reporter_handle failed",  buf,  0xCu);
      }

      goto LABEL_85;
    }

    if (!uu[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v30 = (os_log_s *)(id)gLogObj;
      nw_endpoint_t v57 = v80[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v80[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v30,  v57,  "%{public}s nw_connection_get_symptom_reporter_handle failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_85;
    }

    uint64_t v39 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v40 = (os_log_s *)(id)gLogObj;
    __int16 v41 = v80[0];
    BOOL v42 = os_log_type_enabled(v40, (os_log_type_t)v80[0]);
    if (v39)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v39;
        _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s nw_connection_get_symptom_reporter_handle failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_70;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
      _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s nw_connection_get_symptom_reporter_handle failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_120;
  }

  BOOL v20 = symptom_new();
  if (!v20)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v32 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();

    v80[0] = 16;
    uu[0] = 0;
    if (v80[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v30 = (os_log_s *)(id)gLogObj;
      uint64_t v33 = v80[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v80[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v30, v33, "%{public}s symptom_new failed", buf, 0xCu);
      }

    free(v71);
    goto LABEL_121;
  }

  if (!identifier)
  {
    __nwlog_obj();
    uint64_t v245 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    BOOL v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v298 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v246 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v233, v246, "%{public}s called with null identifier", buf, 0xCu);
      }

      goto LABEL_399;
    }

    if (v298 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      int v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v268 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl( &dword_181A5C000,  v233,  v268,  "%{public}s called with null identifier, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_399;
    }

    char v247 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v260 = type[0];
    int v261 = os_log_type_enabled(v72, type[0]);
    if (!v247)
    {
      if (v261)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v72, v260, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (v261)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      uint64_t v300 = 2082;
      uint64_t v301 = (uint64_t)v247;
      _os_log_impl( &dword_181A5C000,  v72,  v260,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_369;
  }

  if (!v286)
  {
    __nwlog_obj();
    v250 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    BOOL v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v298 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v251 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v233, v251, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_399;
    }

    if (v298 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      int v233 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v269 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl( &dword_181A5C000,  v233,  v269,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_399;
    }

    char v247 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v262 = type[0];
    v263 = os_log_type_enabled(v72, type[0]);
    if (!v247)
    {
      if (v263)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v72, v262, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (v263)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      uint64_t v300 = 2082;
      uint64_t v301 = (uint64_t)v247;
      _os_log_impl( &dword_181A5C000,  v72,  v262,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (v53) {
      free(v53);
    }
    return -902LL;
  }

  if ((*(__int16 *)(a7 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    nw_endpoint_t v57 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      __int16 v58 = *(_DWORD *)(a7 + 368);
      *(_DWORD *)buf = 136446978;
      __int16 v72 = "data_source_read_callback";
      BOOL v73 = 2082;
      __int16 v74 = a7 + 390;
      BOOL v75 = 2080;
      __int16 v76 = " ";
      BOOL v77 = 1024;
      __int16 v78 = v58;
      _os_log_impl(&dword_181A5C000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  os_log_type_t v12 = *a6;
  if (!v12)
  {
    if ((*(__int16 *)(a7 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v25 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v26 = *(_DWORD *)(a7 + 368);
        *(_DWORD *)buf = 136446978;
        __int16 v72 = "data_source_read_callback";
        BOOL v73 = 2082;
        __int16 v74 = a7 + 390;
        BOOL v75 = 2080;
        __int16 v76 = " ";
        BOOL v77 = 1024;
        __int16 v78 = v26;
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> received unexpected NULL frame in data source",  buf,  0x26u);
      }
    }

    char v27 = 0LL;
    *a5 |= 1u;
    return v27;
  }

  *(void *)os_log_type_t type = 0LL;
  stream_from_id = nw_http2_get_stream_from_id(a7, a2, type);
  BOOL v14 = 0;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  os_log_type_t v15 = (id)nw_protocol_copy_http_definition_http_definition;
  char v16 = nw_frame_copy_metadata_for_protocol(v12, (uint64_t)v15);
  if (v15) {
    os_release(v15);
  }
  if (!v16 || !nw_http_metadata_is_capsule(v16))
  {
    if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x40000) != 0)
    {
      metadata_for_capsule = nw_http_create_metadata_for_capsule(0LL, MEMORY[0x1895F8AA8]);
      nw_frame_set_metadata(v12, (nw_protocol_metadata *)metadata_for_capsule, 0, 1);
      if (metadata_for_capsule) {
        os_release(metadata_for_capsule);
      }
      BOOL v29 = *(_DWORD *)(v12 + 52);
      if (v29 && (uint64_t v30 = v29 - (*(_DWORD *)(v12 + 56) + *(_DWORD *)(v12 + 60)), v30 >= 0x40))
      {
        if (v30 >= 0x4000)
        {
          if (v30 >> 30) {
            BOOL v14 = 10;
          }
          else {
            BOOL v14 = 6;
          }
        }

        else
        {
          BOOL v14 = 4;
        }
      }

      else
      {
        BOOL v14 = 3;
      }
    }

    else
    {
      BOOL v14 = 0;
    }

    if (v16) {
      goto LABEL_63;
    }
LABEL_64:
    BOOL v36 = *(_DWORD *)(v12 + 52);
    if (v36) {
      v36 -= *(_DWORD *)(v12 + 56) + *(_DWORD *)(v12 + 60);
    }
    char v37 = v36 + v14;
    if (v36 + v14 >= a4) {
      v38 = a4;
    }
    else {
      v38 = v36 + v14;
    }
    if (v38 >= 0x3FF6) {
      char v27 = 16374LL;
    }
    else {
      char v27 = v38;
    }
    uint64_t v39 = *(void *)(v12 + 64);
    if (v39)
    {
      id v40 = *(_BYTE *)(v39 + 66);
      __int16 v41 = *(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16);
      if ((v40 & 0x40) != 0)
      {
        BOOL v42 = (v41 >> 19) & 1;
        if (!gLogDatapath) {
          LOBYTE(v42) = 1;
        }
        if ((*(_WORD *)(stream_from_id + 188) & 0x200) == 0)
        {
          if ((v42 & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v43 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              __int16 v45 = *(_DWORD *)(stream_from_id + 176);
              os_log_type_t v44 = *(_DWORD *)(stream_from_id + 180);
              *(_DWORD *)buf = 136447490;
              __int16 v72 = "data_source_read_callback";
              BOOL v73 = 2082;
              __int16 v74 = stream_from_id + 191;
              BOOL v75 = 2080;
              __int16 v76 = " ";
              BOOL v77 = 1024;
              __int16 v78 = v44;
              int v79 = 1024;
              __int16 v80 = v45;
              id v81 = 2048;
              __int16 v82 = v12;
              _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> omitting no_end_stream flag and allowing end stream to be set because f rame %p is complete",  buf,  0x36u);
            }
          }

          goto LABEL_92;
        }

        if ((v42 & 1) != 0) {
          goto LABEL_91;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v64 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
LABEL_91:
          *a5 |= 2u;
LABEL_92:
          if ((_DWORD)v27 == v37) {
            size_t v52 = 5;
          }
          else {
            size_t v52 = 4;
          }
          *a5 |= v52;
          if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v59 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              id v61 = *(_DWORD *)(stream_from_id + 176);
              __int16 v60 = *(_DWORD *)(stream_from_id + 180);
              *(_DWORD *)buf = 136447490;
              __int16 v72 = "data_source_read_callback";
              BOOL v73 = 2082;
              __int16 v74 = stream_from_id + 191;
              BOOL v75 = 2080;
              __int16 v76 = " ";
              BOOL v77 = 1024;
              __int16 v78 = v60;
              int v79 = 1024;
              __int16 v80 = v61;
              id v81 = 1024;
              LODWORD(v82) = v27;
              _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> skipped copying %u bytes in data_source_read_callback",  buf,  0x32u);
            }
          }

          return v27;
        }

        char v66 = *(_DWORD *)(stream_from_id + 176);
        v65 = *(_DWORD *)(stream_from_id + 180);
        *(_DWORD *)buf = 136447234;
        __int16 v72 = "data_source_read_callback";
        BOOL v73 = 2082;
        __int16 v74 = stream_from_id + 191;
        BOOL v75 = 2080;
        __int16 v76 = " ";
        BOOL v77 = 1024;
        __int16 v78 = v65;
        int v79 = 1024;
        __int16 v80 = v66;
        os_log_type_t v49 = "%{public}s %{public}s%s<i%u:s%d> setting no_end_stream flag because stream is in CONNECT mode";
        nw_endpoint_t v50 = (os_log_s *)v64;
        __int16 v51 = 44;
LABEL_89:
        _os_log_impl(&dword_181A5C000, v50, OS_LOG_TYPE_DEBUG, v49, buf, v51);
        goto LABEL_91;
      }
    }

    else
    {
      __int16 v41 = *(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16);
    }

    if ((v41 & 0x80000) != 0 || !gLogDatapath) {
      goto LABEL_91;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v46 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_91;
    }
    os_log_type_t v48 = *(_DWORD *)(stream_from_id + 176);
    BOOL v47 = *(_DWORD *)(stream_from_id + 180);
    *(_DWORD *)buf = 136447490;
    __int16 v72 = "data_source_read_callback";
    BOOL v73 = 2082;
    __int16 v74 = stream_from_id + 191;
    BOOL v75 = 2080;
    __int16 v76 = " ";
    BOOL v77 = 1024;
    __int16 v78 = v47;
    int v79 = 1024;
    __int16 v80 = v48;
    id v81 = 2048;
    __int16 v82 = v12;
    os_log_type_t v49 = "%{public}s %{public}s%s<i%u:s%d> setting no_end_stream flag because frame %p is not complete";
    nw_endpoint_t v50 = (os_log_s *)v46;
    __int16 v51 = 54;
    goto LABEL_89;
  }

  capsule_os_log_type_t type = nw_http_metadata_get_capsule_type(v16);
  BOOL v18 = (dispatch_data_s *)nw_http_metadata_copy_capsule_data(v16);
  os_log_type_t v19 = v18;
  if (v18)
  {
    size = dispatch_data_get_size(v18);
    if (!(size | capsule_type)) {
      goto LABEL_14;
    }
  }

  else
  {
    size = 0LL;
    if (!capsule_type)
    {
LABEL_14:
      os_log_type_t v21 = *(_DWORD *)(v12 + 52);
      if (v21) {
        v21 -= *(_DWORD *)(v12 + 56) + *(_DWORD *)(v12 + 60);
      }
      os_log_type_t v22 = v21;
      __int16 v23 = 1;
      if (v21 < 0x40uLL) {
        goto LABEL_17;
      }
      goto LABEL_50;
    }
  }

  if (capsule_type >= 0x40)
  {
    if (capsule_type >= 0x4000)
    {
      if (capsule_type >> 30)
      {
        if (capsule_type >> 62)
        {
          __int16 v31 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          __int16 v72 = "_http_vle_length";
          BOOL v73 = 2048;
          __int16 v74 = capsule_type;
          BOOL v32 = (void *)_os_log_send_and_compose_impl();
          result = __nwlog_abort((uint64_t)v32);
          if ((_DWORD)result) {
            goto LABEL_127;
          }
          free(v32);
          __int16 v23 = 0;
        }

        else
        {
          __int16 v23 = 8;
        }
      }

      else
      {
        __int16 v23 = 4;
      }
    }

    else
    {
      __int16 v23 = 2;
    }
  }

  else
  {
    __int16 v23 = 1;
  }

  os_log_type_t v22 = size;
  if (size < 0x40)
  {
LABEL_17:
    char v24 = 1;
    goto LABEL_58;
  }

      if (v41)
      {
        id v61 = (char *)v41;
LABEL_122:
        free(v61);
      }

      return 0LL;
    }

    if (v99)
    {
      nw_endpoint_t v50 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v42 = (os_log_s *)gconnectionLogObj;
      uint64_t v43 = type;
      __int16 v51 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v50)
      {
        if (v51) {
          goto LABEL_91;
        }
        goto LABEL_92;
      }

      if (!v51) {
        goto LABEL_120;
      }
      goto LABEL_118;
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v42 = (os_log_s *)gconnectionLogObj;
    uint64_t v43 = type;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
      goto LABEL_120;
    }
    goto LABEL_100;
  }

  if (output_handler_context)
  {
    char v24 = output_handler_context[4];
    if (!v24)
    {
      if (handle[194] < 0) {
        return 0LL;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v46 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      os_log_type_t v102 = "nw_protocol_http2_connect";
      os_log_type_t v103 = 2082;
      BOOL v104 = (char *)(handle + 195);
      id v105 = 2080;
      uint64_t v106 = " ";
      unint64_t v107 = 1024;
      unint64_t v108 = v46;
      unint64_t v109 = 2048;
      *(void *)os_log_type_t v110 = a2;
      __int16 v41 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v99 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v42 = (os_log_s *)gconnectionLogObj;
        uint64_t v43 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_63;
        }
        goto LABEL_120;
      }

      if (v99)
      {
        nw_endpoint_t v50 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v42 = (os_log_s *)gconnectionLogObj;
        uint64_t v43 = type;
        size_t v52 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v50)
        {
          if (v52)
          {
LABEL_91:
            nw_endpoint_t v53 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136447490;
            os_log_type_t v102 = "nw_protocol_http2_connect";
            os_log_type_t v103 = 2082;
            BOOL v104 = (char *)(handle + 195);
            id v105 = 2080;
            uint64_t v106 = " ";
            unint64_t v107 = 1024;
            unint64_t v108 = v53;
            unint64_t v109 = 2048;
            *(void *)os_log_type_t v110 = a2;
            *(_WORD *)&v110[8] = 2082;
            *(void *)BOOL v111 = v50;
            _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, dumping backtrace:%{public}s",  buf,  0x3Au);
          }

void sub_181AEBE44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, void *a26, void *a27, void *a28)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_initialize_protocol(void *a1, uint64_t a2, int a3)
{
  uint64_t v154 = *MEMORY[0x1895F89C0];
  __int16 v6 = a1;
  __int16 v7 = v6;
  if (!v6)
  {
    __nwlog_obj();
    uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v139 = "nw_endpoint_handler_get_mode";
    BOOL v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v136 = 0;
    if (__nwlog_fault(v87, &type, &v136))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_endpoint_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v89 = type;
        if (os_log_type_enabled(v88, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v139 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v88, v89, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v136)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_endpoint_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v91 = type;
        BOOL v92 = os_log_type_enabled(v88, type);
        if (backtrace_string)
        {
          if (v92)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v139 = "nw_endpoint_handler_get_mode";
            __int16 v140 = 2082;
            int v141 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v88,  v91,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_100;
        }

        if (v92)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v139 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v88, v91, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        nw_endpoint_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v98 = type;
        if (os_log_type_enabled(v88, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v139 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v88,  v98,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_100:
    if (v87) {
      free(v87);
    }
    unsigned int mode = 0;
    goto LABEL_103;
  }

  unsigned int mode = v6->mode;

  if (mode == 2)
  {
    BOOL v9 = nw_endpoint_handler_copy_flow(v7);
    os_log_type_t v10 = v9;
    if ((*((_BYTE *)v9 + 32) & 8) == 0)
    {
      *((_BYTE *)v9 + 32) |= 8u;
      strcpy((char *)v9 + 48, "endpoint_flow");
      *((void *)v9 + 10) = 0x100000004LL;
      if (a3)
      {
        *((void *)v9 + 19) = nw_flow_input_available;
        *((void *)v9 + 20) = nw_flow_output_available;
        *((void *)v9 + 34) = nw_flow_input_finished;
        BOOL v11 = nw_flow_supports_external_data;
        os_log_type_t v12 = nw_flow_notify;
        os_log_type_t v13 = nw_flow_disconnected;
      }

      else
      {
        *((void *)v9 + 44) = nw_protocol_default_input_flush;
        *((void *)v9 + 24) = nw_protocol_default_link_state;
        *((void *)v9 + 25) = nw_protocol_default_get_parameters;
        *((void *)v9 + 26) = nw_protocol_default_get_path;
        *((void *)v9 + 27) = nw_protocol_default_get_local;
        *((void *)v9 + 32) = nw_protocol_default_updated_path;
        *((void *)v9 + 36) = nw_protocol_default_get_output_local;
        *((void *)v9 + 37) = nw_protocol_default_get_output_interface;
        *((void *)v9 + 13) = nw_protocol_default_replace_input_handler;
        *((void *)v9 + 14) = nw_protocol_default_connect;
        *((void *)v9 + 15) = nw_protocol_default_disconnect;
        *((void *)v9 + 16) = nw_protocol_default_connected;
        *((void *)v9 + 42) = nw_protocol_default_get_message_properties;
        *((void *)v9 + 43) = nw_protocol_default_reset;
        *((void *)v9 + 3_Block_object_dispose((const void *)(v67 - 152), 8) = nw_protocol_default_waiting_for_output;
        *((void *)v9 + 39) = nw_protocol_default_copy_info;
        *((void *)v9 + 2_Block_object_dispose((const void *)(v67 - 152), 8) = nw_protocol_default_get_remote;
        *((void *)v9 + 29) = nw_protocol_default_register_notification;
        *((void *)v9 + 30) = nw_protocol_default_unregister_notification;
        *((void *)v9 + 40) = nw_protocol_default_add_listen_handler;
        *((void *)v9 + 41) = nw_protocol_default_remove_listen_handler;
        *((void *)v9 + 11) = nw_flow_passthrough_add_input_handler;
        *((void *)v9 + 12) = nw_flow_passthrough_remove_input_handler;
        *((void *)v9 + 22) = nw_flow_passthrough_get_output_frames;
        *((void *)v9 + 23) = nw_flow_passthrough_finalize_output_frames;
        *((void *)v9 + 20) = nw_flow_passthrough_output_available;
        *((void *)v9 + 21) = nw_flow_passthrough_get_input_frames;
        *((void *)v9 + 1_Block_object_dispose((const void *)(v67 - 152), 8) = nw_protocol_default_error;
        *((void *)v9 + 19) = nw_flow_passthrough_input_available;
        *((void *)v9 + 34) = nw_flow_passthrough_input_finished;
        *((void *)v9 + 35) = nw_protocol_default_output_finished;
        BOOL v11 = nw_flow_passthrough_supports_external_data;
        os_log_type_t v12 = nw_flow_passthrough_notify;
        os_log_type_t v13 = nw_flow_passthrough_disconnected;
      }

      *((void *)v9 + 33) = v11;
      *((void *)v9 + 17) = v13;
      *((void *)v9 + 1_Block_object_dispose((const void *)(v67 - 152), 8) = nw_flow_error;
      *((void *)v9 + 14) = nw_flow_connect;
      *((void *)v9 + 16) = nw_flow_connected;
      *((void *)v9 + 25) = nw_flow_get_parameters;
      *((void *)v9 + 26) = nw_flow_get_path;
      *((void *)v9 + 31) = v12;
      *((void *)v9 + 32) = nw_flow_updated_path;
      *((void *)v9 + 27) = nw_flow_get_local;
      *((void *)v9 + 2_Block_object_dispose((const void *)(v67 - 152), 8) = nw_flow_get_remote;
      *((void *)v9 + 45) = nw_flow_listener_new_flow;
      *((void *)v9 + 46) = nw_flow_listener_disconnected;
      uint64_t internal = nw_hash_table_create_internal( 7u,  0,  (const void *(*)(const void *, unsigned int *))nw_flow_protocol_get_key,  (unsigned int (*)(const void *, unsigned int))nw_flow_protocol_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_flow_protocol_matches_key,  (void (*)(void *))nw_flow_protocol_release);
      *((void *)v10 + 10_Block_object_dispose((const void *)(v67 - 152), 8) = internal;
    }

    __int16 v15 = *(_WORD *)(a2 + 332);
    if ((v15 & 1) != 0) {
      goto LABEL_73;
    }
    *(_WORD *)(a2 + 332) = v15 | 1;
    objc_storeStrong((id *)(a2 + 160), a1);
    char v16 = v7;
    os_log_type_t v17 = v10;
    BOOL v18 = v17;
    v135 = v16;
    if ((*((_BYTE *)v10 + 32) & 8) != 0)
    {
      os_log_type_t v19 = v16;
      id v20 = v19[4];

      os_log_type_t v21 = *(void **)(a2 + 176);
      *(void *)(a2 + 176) = v20;

      id v22 = nw_parameters_copy_context(*(void **)(a2 + 176));
      __int16 v23 = *(void **)(a2 + 184);
      *(void *)(a2 + 184) = v22;

      *(void *)(a2 + 16) = (char *)v18 + 48;
      *(void *)(a2 + 24) = (char *)v18 + 88;
      *(void *)(a2 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = a2;
      *(void *)(a2 + 64) = (char *)v18 + 360;
      *(void *)(a2 + 136) = a2;
      *(void *)(a2 + 112) = &g_replay_protocol_identifier;
      *(void *)(a2 + 120) = &g_replay_protocol_callbacks;
      uint64_t v24 = *(void *)(a2 + 40);
      if (!v24)
      {
        *(void *)(a2 + 40) = a2;
        goto LABEL_72;
      }

      if (v24 == a2) {
        goto LABEL_72;
      }
      BOOL v25 = v19;
      char v26 = *((_BYTE *)v25 + 268);

      if ((v26 & 0x20) != 0) {
        goto LABEL_72;
      }
      __int16 v120 = (char *)v18;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v27 = (id)gconnectionLogObj;
      __int16 v28 = v25;

      BOOL v29 = v28;
      char v30 = *((_BYTE *)v25 + 268);

      if ((v30 & 1) != 0) {
        __int16 v31 = "dry-run ";
      }
      else {
        __int16 v31 = "";
      }
      nw_endpoint_t v32 = nw_endpoint_handler_copy_endpoint(v29);
      logging_description = nw_endpoint_get_logging_description(v32);
      v129 = (char *)(v28 + 21);
      uint64_t v33 = v29;
      os_log_type_t v34 = v33;
      uint64_t v35 = v33[30];
      else {
        BOOL v36 = off_189BBBBF0[v35];
      }
      os_log_t log = (os_log_t)v36;
      uint64_t v126 = v25;

      char v37 = v34;
      v38 = v37;
      int v117 = v34;
      uint64_t v39 = "path";
      switch(v7->mode)
      {
        case 0:
          break;
        case 1:
          uint64_t v39 = "resolver";
          break;
        case 2:
          uint64_t v39 = nw_endpoint_flow_mode_string(v37[31]);
          break;
        case 3:
          uint64_t v39 = "proxy";
          break;
        case 4:
          uint64_t v39 = "fallback";
          break;
        case 5:
          uint64_t v39 = "transform";
          break;
        default:
          uint64_t v39 = "unknown-mode";
          break;
      }

      id v40 = v38;
      os_unfair_lock_lock((os_unfair_lock_t)v40 + 28);
      id v41 = v40[8];
      lock = (os_unfair_lock_s *)(v40 + 14);
      os_unfair_lock_unlock((os_unfair_lock_t)v40 + 28);
      nw_endpoint_t v119 = v40;

      *(_DWORD *)buf = 136447746;
      uint64_t v139 = "nw_flow_protocol_initialize";
      __int16 v140 = 2082;
      int v141 = v129;
      __int16 v142 = 2082;
      v143 = v31;
      __int16 v144 = 2082;
      v145 = (void *)logging_description;
      __int16 v146 = 2082;
      v147 = log;
      __int16 v148 = 2082;
      v149 = v39;
      __int16 v150 = 2114;
      id v151 = v41;
      v134 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v136 = 0;
      if (__nwlog_fault(v134, &type, &v136))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v42 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v43 = type;
          if (os_log_type_enabled(v42, type))
          {
            loga = v42;
            os_log_type_t v44 = v119;

            __int16 v45 = v44;
            BOOL v46 = (*((_BYTE *)v126 + 268) & 1) == 0;

            if (v46) {
              BOOL v47 = "";
            }
            else {
              BOOL v47 = "dry-run ";
            }
            nw_endpoint_t v48 = nw_endpoint_handler_copy_endpoint(v45);
            os_log_type_t v49 = nw_endpoint_get_logging_description(v48);
            nw_endpoint_t v50 = v45;
            __int16 v51 = v50;
            uint64_t v52 = v117[30];
            else {
              nw_endpoint_t v53 = off_189BBBBF0[v52];
            }
            nw_endpoint_t v128 = v53;

            BOOL v73 = v51;
            __int16 v74 = "path";
            switch(v7->mode)
            {
              case 0:
                break;
              case 1:
                __int16 v74 = "resolver";
                break;
              case 2:
                __int16 v74 = nw_endpoint_flow_mode_string(v73[31]);
                break;
              case 3:
                __int16 v74 = "proxy";
                break;
              case 4:
                __int16 v74 = "fallback";
                break;
              case 5:
                __int16 v74 = "transform";
                break;
              default:
                __int16 v74 = "unknown-mode";
                break;
            }

            __int16 v118 = v74;

            int v83 = v73;
            os_unfair_lock_lock(lock);
            id v84 = v119[8];
            os_unfair_lock_unlock(lock);

            *(_DWORD *)buf = 136447746;
            uint64_t v139 = "nw_flow_protocol_initialize";
            __int16 v140 = 2082;
            int v141 = v129;
            __int16 v142 = 2082;
            v143 = v47;
            __int16 v144 = 2082;
            v145 = (void *)v49;
            __int16 v146 = 2082;
            v147 = (void *)v128;
            __int16 v148 = 2082;
            v149 = v118;
            __int16 v150 = 2114;
            id v151 = v84;
            _os_log_impl( &dword_181A5C000,  loga,  v43,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle non- NULL at initialization",  buf,  0x48u);

            BOOL v42 = loga;
          }

          goto LABEL_70;
        }

        if (v136)
        {
          id v54 = __nw_create_backtrace_string();
          if (v54)
          {
            uint64_t v55 = (char *)v54;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            __int16 v56 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v57 = type;
            if (os_log_type_enabled(v56, type))
            {
              id_string = nw_endpoint_handler_get_id_string(v119);
              logb = v56;
              uint64_t v127 = nw_endpoint_handler_dry_run_string(v119);
              nw_endpoint_t v130 = nw_endpoint_handler_copy_endpoint(v119);
              uint64_t v59 = id_string;
              __int16 v60 = nw_endpoint_get_logging_description(v130);
              id v61 = nw_endpoint_handler_state_string(v119);
              os_log_type_t v62 = nw_endpoint_handler_mode_string(v119);
              id v63 = nw_endpoint_handler_copy_current_path(v119);
              *(_DWORD *)buf = 136448002;
              uint64_t v139 = "nw_flow_protocol_initialize";
              __int16 v140 = 2082;
              int v141 = (void *)v59;
              __int16 v142 = 2082;
              v143 = v127;
              __int16 v144 = 2082;
              v145 = (void *)v60;
              __int16 v146 = 2082;
              v147 = (void *)v61;
              __int16 v148 = 2082;
              v149 = v62;
              __int16 v150 = 2114;
              id v151 = v63;
              __int16 v152 = 2082;
              uint64_t v153 = v55;
              _os_log_impl( &dword_181A5C000,  logb,  v57,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle no n-NULL at initialization, dumping backtrace:%{public}s",  buf,  0x52u);

              __int16 v56 = logb;
            }

            free(v55);
            goto LABEL_70;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v64 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v75 = type;
          if (os_log_type_enabled(v64, type))
          {
            __int16 v76 = nw_endpoint_handler_get_id_string(v119);
            logd = v64;
            BOOL v77 = nw_endpoint_handler_dry_run_string(v119);
            __int16 v78 = v76;
            nw_endpoint_t v132 = nw_endpoint_handler_copy_endpoint(v119);
            int v79 = nw_endpoint_get_logging_description(v132);
            __int16 v80 = nw_endpoint_handler_state_string(v119);
            id v81 = nw_endpoint_handler_mode_string(v119);
            id v82 = nw_endpoint_handler_copy_current_path(v119);
            *(_DWORD *)buf = 136447746;
            uint64_t v139 = "nw_flow_protocol_initialize";
            __int16 v140 = 2082;
            int v141 = (void *)v78;
            __int16 v142 = 2082;
            v143 = v77;
            __int16 v144 = 2082;
            v145 = (void *)v79;
            __int16 v146 = 2082;
            v147 = (void *)v80;
            __int16 v148 = 2082;
            v149 = v81;
            __int16 v150 = 2114;
            id v151 = v82;
            _os_log_impl( &dword_181A5C000,  logd,  v75,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle non- NULL at initialization, no backtrace",  buf,  0x48u);

            os_log_type_t v64 = logd;
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v64 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v65 = type;
          if (os_log_type_enabled(v64, type))
          {
            char v66 = nw_endpoint_handler_get_id_string(v119);
            logc = v64;
            uint64_t v67 = nw_endpoint_handler_dry_run_string(v119);
            os_log_type_t v68 = v66;
            nw_endpoint_t v131 = nw_endpoint_handler_copy_endpoint(v119);
            v69 = nw_endpoint_get_logging_description(v131);
            __int16 v70 = nw_endpoint_handler_state_string(v119);
            BOOL v71 = nw_endpoint_handler_mode_string(v119);
            id v72 = nw_endpoint_handler_copy_current_path(v119);
            *(_DWORD *)buf = 136447746;
            uint64_t v139 = "nw_flow_protocol_initialize";
            __int16 v140 = 2082;
            int v141 = (void *)v68;
            __int16 v142 = 2082;
            v143 = v67;
            __int16 v144 = 2082;
            v145 = (void *)v69;
            __int16 v146 = 2082;
            v147 = (void *)v70;
            __int16 v148 = 2082;
            v149 = v71;
            __int16 v150 = 2114;
            id v151 = v72;
            _os_log_impl( &dword_181A5C000,  logc,  v65,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle non- NULL at initialization, backtrace limit exceeded",  buf,  0x48u);

            os_log_type_t v64 = logc;
          }
        }
      }

    if (v39) {
      free(v39);
    }
    goto LABEL_114;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v87 = "nw_context_get_globals_for_protocol";
    os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();

    BOOL v85 = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v43, &v85, &type))
    {
      if (v85 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v45 = v85;
        if (os_log_type_enabled(v44, v85))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        nw_endpoint_t v53 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v54 = v85;
        uint64_t v55 = os_log_type_enabled(v44, v85);
        if (v53)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v87 = "nw_context_get_globals_for_protocol";
            nw_endpoint_t v88 = 2082;
            os_log_type_t v89 = v53;
            _os_log_impl( &dword_181A5C000,  v44,  v54,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v53);
          goto LABEL_105;
        }

        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_181A5C000, v44, v54, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v64 = v85;
        if (os_log_type_enabled(v44, v85))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl( &dword_181A5C000,  v44,  v64,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      free(backtrace_string);
      goto LABEL_117;
    }

    id v41 = (os_log_s *)__nwlog_obj();
    BOOL v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_117;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v59 = "nw_protocol_ipv4_remove_input_handler";
    os_log_type_t v43 = "%{public}s called with null protocol";
LABEL_116:
    _os_log_impl(&dword_181A5C000, v41, v42, v43, buf, 0xCu);
LABEL_117:
    if (v44) {
      free(v44);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (handle == &nw_protocol_ref_counted_handle) {
    p_output_handler = &a1[1].output_handler;
  }
  else {
    p_output_handler = 0LL;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v59 = "nw_protocol_ipv4_remove_input_handler";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v56 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v41 = (os_log_s *)__nwlog_obj();
      BOOL v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_117;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "nw_protocol_ipv4_remove_input_handler";
      os_log_type_t v43 = "%{public}s called with null ipv4";
      goto LABEL_116;
    }

    if (!v56)
    {
      id v41 = (os_log_s *)__nwlog_obj();
      BOOL v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_117;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "nw_protocol_ipv4_remove_input_handler";
      os_log_type_t v43 = "%{public}s called with null ipv4, backtrace limit exceeded";
      goto LABEL_116;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v41 = (os_log_s *)__nwlog_obj();
    BOOL v42 = type;
    nw_endpoint_t v53 = os_log_type_enabled(v41, type);
    if (backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v59 = "nw_protocol_ipv4_remove_input_handler";
        __int16 v60 = 2082;
        id v61 = backtrace_string;
        uint64_t v52 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
        goto LABEL_99;
      }

      goto LABEL_100;
    }

    if (!v53) {
      goto LABEL_117;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v59 = "nw_protocol_ipv4_remove_input_handler";
    os_log_type_t v43 = "%{public}s called with null ipv4, no backtrace";
    goto LABEL_116;
  }

  if (a2)
  {
    if (a2->output_handler == a1)
    {
      callbacks = a1[1].callbacks;
      if (callbacks)
      {
        BOOL v9 = (nw_protocol_callbacks *)((char *)callbacks - 1);
        a1[1].callbacks = v9;
        if (!v9)
        {
          os_log_type_t v10 = *(void (***)(void))a1[1].flow_id;
          if (v10)
          {
            *(void *)a1[1].flow_id = 0LL;
            v10[2](v10);
            _Block_release(v10);
          }

          if ((a1[1].flow_id[8] & 1) != 0)
          {
            BOOL v11 = *(const void **)a1[1].flow_id;
            if (v11) {
              _Block_release(v11);
            }
          }

          free(a1);
        }
      }

      a2->output_handler = 0LL;
    }

    goto LABEL_18;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v59 = "__nw_protocol_get_output_handler";
  BOOL v46 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v56 = 0;
  if (__nwlog_fault(v46, &type, &v56))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v47 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "__nw_protocol_get_output_handler";
      os_log_type_t v49 = "%{public}s called with null protocol";
      goto LABEL_121;
    }

    if (!v56)
    {
      BOOL v47 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "__nw_protocol_get_output_handler";
      os_log_type_t v49 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_121;
    }

    id v54 = (char *)__nw_create_backtrace_string();
    BOOL v47 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v48 = type;
    uint64_t v55 = os_log_type_enabled(v47, type);
    if (v54)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v59 = "__nw_protocol_get_output_handler";
        __int16 v60 = 2082;
        id v61 = v54;
        _os_log_impl( &dword_181A5C000,  v47,  v48,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v54);
      goto LABEL_122;
    }

    if (v55)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "__nw_protocol_get_output_handler";
      os_log_type_t v49 = "%{public}s called with null protocol, no backtrace";
LABEL_121:
      _os_log_impl(&dword_181A5C000, v47, v48, v49, buf, 0xCu);
    }
  }

    goto LABEL_101;
  }

  if (!nw_txt_record_set_key_data_value((void *)dictionary_with_initial_length, "lcid", v19))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v83 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446210;
    *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    __int16 v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    id v181 = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v78 = (os_log_s *)(id)gLogObj;
      id v84 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_181A5C000, v78, v84, "%{public}s failed to add kIDSKeyLocalCID", type, 0xCu);
      }
    }

    else if (v181)
    {
      os_log_type_t v90 = __nw_create_backtrace_string();
      if (v90)
      {
        os_log_type_t v91 = (char *)v90;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v92 = (os_log_s *)(id)gLogObj;
        id v93 = __str[0];
        if (os_log_type_enabled(v92, __str[0]))
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&type[12] = 2082;
          *(void *)&type[14] = v91;
          _os_log_impl( &dword_181A5C000,  v92,  v93,  "%{public}s failed to add kIDSKeyLocalCID, dumping backtrace:%{public}s",  type,  0x16u);
        }

        free(v91);
        if (!v74) {
          goto LABEL_177;
        }
        goto LABEL_176;
      }

      __nwlog_obj();
      __int16 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v103 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_181A5C000, v78, v103, "%{public}s failed to add kIDSKeyLocalCID, no backtrace", type, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v78 = (os_log_s *)(id)gLogObj;
      os_log_type_t v99 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl( &dword_181A5C000,  v78,  v99,  "%{public}s failed to add kIDSKeyLocalCID, backtrace limit exceeded",  type,  0xCu);
      }
    }

    goto LABEL_149;
  }

  if (!nw_txt_record_set_key_data_value((void *)dictionary_with_initial_length, "rcid", v178))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_endpoint_t v88 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446210;
    *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    __int16 v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    id v181 = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v78 = (os_log_s *)(id)gLogObj;
      os_log_type_t v89 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_181A5C000, v78, v89, "%{public}s failed to add kIDSKeyRemoteCID", type, 0xCu);
      }

    if (v36) {
      free(v36);
    }
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __networkd_privileged_set_opportunistic_async_block_invoke;
    __int16 v56 = (const char *)&unk_189BC8740;
    os_log_type_t v57 = v12;
    dispatch_async(v11, buf);
    char v16 = v57;
    goto LABEL_31;
  }

  __nwlog_obj();
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
  __int16 v28 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  nw_endpoint_t v53 = 0;
  if (__nwlog_fault(v28, &type, &v53))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
        _os_log_impl(&dword_181A5C000, v29, v34, "%{public}s called with null completion", buf, 0xCu);
      }

    if (v61) {
      free(v61);
    }
    goto LABEL_102;
  }

  if (*((_DWORD *)v5 + 11))
  {
    os_log_type_t v8 = v5 + 51;
    if (!v6) {
      goto LABEL_6;
    }
    if (!*v8)
    {
      BOOL v9 = (uint64_t)(v5 + 7);
      goto LABEL_9;
    }

    if (nw_interface_deep_compare(*v8, v6))
    {
LABEL_6:
      BOOL v9 = (uint64_t)(v5 + 7);
      if (v5[51])
      {
LABEL_10:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          if (v7)
          {
            BOOL v11 = v7;
            os_log_type_t v12 = v11[84];

            os_log_type_t v13 = nw_interface_radio_type_to_string(v12);
          }

          else
          {
            os_log_type_t v13 = "none";
          }

          *(_DWORD *)buf = 136446978;
          os_log_type_t v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
          os_log_type_t v95 = 2048;
          BOOL v96 = (const char *)v9;
          os_log_type_t v97 = 2112;
          *(void *)os_log_type_t v98 = v7;
          *(_WORD *)&v98[8] = 2080;
          os_log_type_t v99 = v13;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s found path report %p for interface %@[%s]",  buf,  0x2Au);
        }

        goto LABEL_103;
      }

  if (v13) {
LABEL_101:
  }
    free(v13);
LABEL_102:
  __int16 v76 = 0LL;
LABEL_143:

  return v76;
}

          os_log_type_t v68 = (void *)v165[5];
          v69 = *(_DWORD *)(*(void *)(a1 + 32) + 16LL);
          block[0] = MEMORY[0x1895F87A8];
          block[1] = 3221225472LL;
          block[2] = ___ZL38nw_connection_group_read_on_connectionP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke_2;
          block[3] = &unk_189BB7288;
          v155 = v63;
          v156 = data;
          __int16 v70 = *(id *)(a1 + 32);
          v159 = a4;
          v157 = v70;
          v158 = type;
          BOOL v71 = v68;
          id v72 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v69, 0, block);
          dispatch_async(v71, v72);

          BOOL v73 = v155;
          goto LABEL_107;
        }

        __nwlog_obj();
        unint64_t v108 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_connection";
        __int16 v152 = (void *)_os_log_send_and_compose_impl();

        v177 = OS_LOG_TYPE_ERROR;
        v176 = 0;
        if (!__nwlog_fault((const char *)v152, &v177, &v176))
        {
LABEL_290:
          if (v152) {
            free(v152);
          }
          goto LABEL_100;
        }

        if (v177 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v109 = v177;
          if (os_log_type_enabled(v106, v177))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_content_context_set_connection";
            _os_log_impl(&dword_181A5C000, v106, v109, "%{public}s called with null connection", buf, 0xCu);
          }

    goto LABEL_101;
  }

    if (v34) {
      free(v34);
    }
    BOOL v14 = 0LL;
    goto LABEL_14;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v57 = "__nw_protocol_get_input_frames";
  char v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  id v54 = 0;
  if (__nwlog_fault(v30, &type, &v54))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v31 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_input_frames";
        uint64_t v33 = "%{public}s called with null protocol";
LABEL_93:
        _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
      }
    }

    else if (v54)
    {
      os_log_type_t v43 = (char *)__nw_create_backtrace_string();
      __int16 v31 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v32 = type;
      os_log_type_t v44 = os_log_type_enabled(v31, type);
      if (v43)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v57 = "__nw_protocol_get_input_frames";
          __int16 v58 = 2082;
          uint64_t v59 = v43;
          _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_94;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_input_frames";
        uint64_t v33 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
    }

    else
    {
      __int16 v31 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_input_frames";
        uint64_t v33 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
    }
  }

    if (v34) {
      free(v34);
    }
    BOOL v14 = 0LL;
    goto LABEL_14;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v57 = "__nw_protocol_get_output_frames";
  char v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  id v54 = 0;
  if (__nwlog_fault(v30, &type, &v54))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v31 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_output_frames";
        uint64_t v33 = "%{public}s called with null protocol";
LABEL_93:
        _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
      }
    }

    else if (v54)
    {
      os_log_type_t v43 = (char *)__nw_create_backtrace_string();
      __int16 v31 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v32 = type;
      os_log_type_t v44 = os_log_type_enabled(v31, type);
      if (v43)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v57 = "__nw_protocol_get_output_frames";
          __int16 v58 = 2082;
          uint64_t v59 = v43;
          _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_94;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_output_frames";
        uint64_t v33 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
    }

    else
    {
      __int16 v31 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "__nw_protocol_get_output_frames";
        uint64_t v33 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
    }
  }

    if (v31) {
      free(v31);
    }
    BOOL v11 = 0LL;
    goto LABEL_14;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v54 = "__nw_protocol_register_notification";
  id v27 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v51 = 0;
  if (__nwlog_fault(v27, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_register_notification";
        char v30 = "%{public}s called with null protocol";
LABEL_93:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      }
    }

    else if (v51)
    {
      id v40 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      id v41 = os_log_type_enabled(v28, type);
      if (v40)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          id v54 = "__nw_protocol_register_notification";
          uint64_t v55 = 2082;
          __int16 v56 = v40;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v40);
        goto LABEL_94;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_register_notification";
        char v30 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
    }

    else
    {
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_register_notification";
        char v30 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
    }
  }

    if (v31) {
      free(v31);
    }
    BOOL v11 = 0LL;
    goto LABEL_14;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v54 = "__nw_protocol_unregister_notification";
  id v27 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v51 = 0;
  if (__nwlog_fault(v27, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_unregister_notification";
        char v30 = "%{public}s called with null protocol";
LABEL_93:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      }
    }

    else if (v51)
    {
      id v40 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      id v41 = os_log_type_enabled(v28, type);
      if (v40)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          id v54 = "__nw_protocol_unregister_notification";
          uint64_t v55 = 2082;
          __int16 v56 = v40;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v40);
        goto LABEL_94;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_unregister_notification";
        char v30 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
    }

    else
    {
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_unregister_notification";
        char v30 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
    }
  }

    if (v31) {
      free(v31);
    }
    BOOL v11 = 0LL;
    goto LABEL_14;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v54 = "__nw_protocol_updated_path";
  id v27 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v51 = 0;
  if (__nwlog_fault(v27, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_updated_path";
        char v30 = "%{public}s called with null protocol";
LABEL_93:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      }
    }

    else if (v51)
    {
      id v40 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      id v41 = os_log_type_enabled(v28, type);
      if (v40)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          id v54 = "__nw_protocol_updated_path";
          uint64_t v55 = 2082;
          __int16 v56 = v40;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v40);
        goto LABEL_94;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_updated_path";
        char v30 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
    }

    else
    {
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "__nw_protocol_updated_path";
        char v30 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
    }
  }
}

    goto LABEL_101;
  }

  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0LL;
    }
    os_log_type_t v8 = p_output_handler;
    BOOL v9 = (NWConcrete_nw_protocol_instance *)v8;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v10 = v8[1];
      if (v10)
      {
        if (v10[1].identifier)
        {
          BOOL v11 = v5;
          os_log_type_t v12 = v11[2];

          *(void *)buf = 0LL;
          os_log_type_t v13 = nw_protocol_implementation_lookup_path_by_protocol(v9, a2, (unint64_t *)buf);
          if (v13)
          {
            BOOL v14 = v13;
            if (v12 == 1)
            {
              char v16 = *(_BYTE *)(v13 + 137) | 2;
            }

            else
            {
              if (v12 || (__int16 v15 = *(_BYTE *)(v13 + 137), *(_BYTE *)(v13 + 137) = v15 & 0xFD, (v15 & 4) == 0))
              {
LABEL_19:
                var17 = (void (*)(NWConcrete_nw_protocol_instance *, uint64_t, void))v9->parent_definition->extended_state->var17;
                if (var17)
                {
                  id v20 = *(void *)buf;
LABEL_25:
                  var17(v9, v20, (BYTE3(v9->flow_in_connected) >> 2) & 1);
                  goto LABEL_26;
                }

                goto LABEL_26;
              }

              nw_protocol_implementation_output_available(a1, a2);
              char v16 = *(_BYTE *)(v14 + 137) & 0xFB;
            }

            *(_BYTE *)(v14 + 137) = v16;
            goto LABEL_19;
          }

          if (v12 == 1)
          {
            BOOL v18 = BYTE3(v9->flow_in_connected) | 4;
          }

          else
          {
            if (v12 || (os_log_type_t v17 = BYTE3(v9->flow_in_connected), BYTE3(v9->flow_in_connected) = v17 & 0xFB, (v17 & 8) == 0))
            {
LABEL_23:
              var17 = (void (*)(NWConcrete_nw_protocol_instance *, uint64_t, void))v9->parent_definition->extended_state->var17;
              if (var17)
              {
                id v20 = 0LL;
                goto LABEL_25;
              }

            if ((v8[405] & 0x80000000) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v47 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446978;
                nw_endpoint_t v53 = "nw_protocol_implementation_get_message_properties";
                id v54 = 2082;
                uint64_t v55 = v8 + 407;
                __int16 v56 = 2080;
                os_log_type_t v57 = " ";
                __int16 v58 = 2048;
                uint64_t v59 = a2;
                _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p",  buf,  0x2Au);
              }
            }

            goto LABEL_104;
          }

          __nwlog_obj();
          uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v53 = "__nw_protocol_get_output_handler_context";
          BOOL v36 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          nw_endpoint_t v50 = 0;
          if (__nwlog_fault(v36, &type, &v50))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              char v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v38 = type;
              if (os_log_type_enabled(v37, type))
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v53 = "__nw_protocol_get_output_handler_context";
                _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null protocol", buf, 0xCu);
              }
            }

            else if (v50)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              char v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v44 = type;
              __int16 v45 = os_log_type_enabled(v37, type);
              if (backtrace_string)
              {
                if (v45)
                {
                  *(_DWORD *)buf = 136446466;
                  nw_endpoint_t v53 = "__nw_protocol_get_output_handler_context";
                  id v54 = 2082;
                  uint64_t v55 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v37,  v44,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(backtrace_string);
                goto LABEL_98;
              }

              if (v45)
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v53 = "__nw_protocol_get_output_handler_context";
                _os_log_impl( &dword_181A5C000,  v37,  v44,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              char v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v46 = type;
              if (os_log_type_enabled(v37, type))
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v53 = "__nw_protocol_get_output_handler_context";
                _os_log_impl( &dword_181A5C000,  v37,  v46,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

  if (v17) {
    free(v17);
  }
  return 0LL;
}

      if (v18) {
        free(v18);
      }
      should_proxy_transport_at_level = 0;
      os_log_type_t v10 = 0LL;
      goto LABEL_112;
    }

    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_proxy_config_copy_protocol_stack_for_listener";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v90) = 16;
    os_log_type_t v89 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v14, &v90, &v89))
    {
      if (v90 == 17)
      {
        __nwlog_obj();
        __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v16 = v90;
        if (os_log_type_enabled(v15, (os_log_type_t)v90))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_proxy_config_copy_protocol_stack_for_listener";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null config", buf, 0xCu);
        }
      }

      else if (v89)
      {
        BOOL v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v26 = v90;
        id v27 = os_log_type_enabled(v15, (os_log_type_t)v90);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_proxy_config_copy_protocol_stack_for_listener";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v25;
            _os_log_impl( &dword_181A5C000,  v15,  v26,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v25);
          goto LABEL_53;
        }

        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_proxy_config_copy_protocol_stack_for_listener";
          _os_log_impl(&dword_181A5C000, v15, v26, "%{public}s called with null config, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = v90;
        if (os_log_type_enabled(v15, (os_log_type_t)v90))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_proxy_config_copy_protocol_stack_for_listener";
          _os_log_impl( &dword_181A5C000,  v15,  v34,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

                      direct = 0LL;
LABEL_140:

LABEL_141:
                      if (direct) {
                        nw_array_append(v79, direct);
                      }
                      goto LABEL_70;
                    }

LABEL_101:
      if (v33) {
        free(v33);
      }
      goto LABEL_17;
    }

    if (!v49)
    {
      __nwlog_obj();
      os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v52 = "nw_write_request_create_idempotent";
        _os_log_impl( &dword_181A5C000,  v34,  v43,  "%{public}s Send content may only be nil if the request is marked as complete, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_100;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v39 = type;
    id v40 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v52 = "nw_write_request_create_idempotent";
        _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s Send content may only be nil if the request is marked as complete, no backtrace",  buf,  0xCu);
      }

      goto LABEL_100;
    }

    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v52 = "nw_write_request_create_idempotent";
      nw_endpoint_t v53 = 2082;
      id v54 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s Send content may only be nil if the request is marked as complete, dumping backtrace:%{public}s",  buf,  0x16u);
    }

      free(v28);
      if (!v8) {
        return;
      }
LABEL_226:
      free(v8);
      return;
    }

    goto LABEL_225;
  }

  if (*((void *)handle + 28))
  {
    uint64_t v33 = *((_WORD *)handle + 184);
    if (*((void *)handle + 25)) {
      goto LABEL_130;
    }
    if ((v33 & 0x80) == 0)
    {
      if (gLogDatapath)
      {
        BOOL v111 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          BOOL v172 = " ";
          _os_log_impl(&dword_181A5C000, v111, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }

    if (!*((void *)handle + 25))
    {
      *((void *)handle + 25) = CFHTTPMessageCreateEmpty((CFAllocatorRef)*MEMORY[0x189604DB0], 0);
      *((_DWORD *)handle + 66) = 0;
      *((void *)handle + 32) = 0LL;
      __int16 v45 = *((_WORD *)handle + 184);
      LOBYTE(v33) = v45 & 0xFD;
      *((_WORD *)handle + 184) = v45 & 0xFFFD;
      goto LABEL_130;
    }

    uint64_t v33 = *((_WORD *)handle + 184);
    if ((v33 & 0x80) != 0)
    {
LABEL_130:
      nw_endpoint_t v48 = MEMORY[0x1895F87A8];
      *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
      id v166 = 0x40000000LL;
      v167 = ___ZL36nw_http_connect_process_inbound_dataP24nw_protocol_http_connect_block_invoke;
      v168 = &__block_descriptor_tmp_17_35877;
      v169 = handle;
      os_log_type_t v49 = *((void *)handle + 28);
      do
      {
        if (!v49) {
          break;
        }
        nw_endpoint_t v50 = *(void *)(v49 + 32);
        __int16 v51 = ((uint64_t (*)(os_log_type_t *))v167)(type);
        os_log_type_t v49 = v50;
      }

      while ((v51 & 1) != 0);
      uint64_t v52 = *((unsigned __int16 *)handle + 184);
      if ((v33 & 2) != 0)
      {
        if ((v52 & 0x80) == 0)
        {
          if (*((_BYTE *)v32 + 1537))
          {
            os_log_type_t v43 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              BOOL v172 = " ";
              os_log_type_t v44 = "%{public}s %{public}s%sResponse message was already complete, ignoring extra data...";
              goto LABEL_144;
            }
          }
        }

        return;
      }

      nw_endpoint_t v53 = (v52 >> 7) & 1;
      if (!*((_BYTE *)v32 + 1537)) {
        LOBYTE(v53) = 1;
      }
      if ((v52 & 2) == 0)
      {
        if ((v53 & 1) == 0)
        {
          os_log_type_t v43 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            BOOL v172 = " ";
            os_log_type_t v44 = "%{public}s %{public}s%sResponse message is not complete, waiting for more data...";
            goto LABEL_144;
          }
        }

        return;
      }

      if ((v53 & 1) == 0)
      {
        os_log_type_t v112 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          BOOL v172 = " ";
          _os_log_impl( &dword_181A5C000,  v112,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sResponse message is complete",  buf,  0x20u);
        }
      }

      if ((*((_WORD *)handle + 184) & 0x80) == 0)
      {
        if (*((_BYTE *)v32 + 1537))
        {
          v113 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            BOOL v172 = " ";
            _os_log_impl(&dword_181A5C000, v113, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
          }
        }
      }

      id v54 = (__CFHTTPMessage *)*((void *)handle + 25);
      if (v54)
      {
        uint64_t v55 = *((_WORD *)handle + 184);
        if ((v55 & 2) == 0)
        {
          if ((v55 & 0x80) != 0) {
            return;
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          BOOL v172 = " ";
          os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
          v174[0] = 16;
          v170 = 0;
          if (__nwlog_fault(v8, v174, &v170))
          {
            if (v174[0] == 17)
            {
              BOOL v9 = (os_log_s *)__nwlog_obj();
              os_log_type_t v10 = v174[0];
              if (!os_log_type_enabled(v9, (os_log_type_t)v174[0])) {
                goto LABEL_225;
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              BOOL v172 = " ";
              BOOL v11 = "%{public}s %{public}s%sCannot process response that is not yet complete";
              goto LABEL_223;
            }

            if (!v170)
            {
              BOOL v9 = (os_log_s *)__nwlog_obj();
              os_log_type_t v10 = v174[0];
              if (!os_log_type_enabled(v9, (os_log_type_t)v174[0])) {
                goto LABEL_225;
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              BOOL v172 = " ";
              BOOL v11 = "%{public}s %{public}s%sCannot process response that is not yet complete, backtrace limit exceeded";
              goto LABEL_223;
            }

            __int16 v28 = (char *)__nw_create_backtrace_string();
            BOOL v9 = (os_log_s *)__nwlog_obj();
            os_log_type_t v10 = v174[0];
            __int16 v70 = os_log_type_enabled(v9, (os_log_type_t)v174[0]);
            if (!v28)
            {
              if (!v70) {
                goto LABEL_225;
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              BOOL v172 = " ";
              BOOL v11 = "%{public}s %{public}s%sCannot process response that is not yet complete, no backtrace";
              goto LABEL_223;
            }

            if (v70)
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              BOOL v172 = " ";
              LOWORD(v173) = 2082;
              *(void *)((char *)&v173 + 2) = v28;
              char v30 = "%{public}s %{public}s%sCannot process response that is not yet complete, dumping backtrace:%{public}s";
              goto LABEL_98;
            }

            goto LABEL_100;
          }

        *(_DWORD *)buf = 136446466;
        int v83 = "nw_protocol_http_connect_disconnected";
        id v84 = 2082;
        BOOL v85 = (void *)v59;
        os_log_type_t v17 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_139;
      }

  [MEMORY[0x189607968] numberWithBool:self->_longOutstandingQueries];
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();
  [v4 setObject:v67 forKey:@"longOutstandingQueries"];

  has = (__int16)self->_has;
  if ((has & 0x2000) == 0)
  {
LABEL_21:
    if ((has & 0x4000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_102;
  }

        if (v37) {
          free(v37);
        }
        return 4294966775LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      if ((_DWORD)result)
      {
        BOOL v25 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446722;
        os_log_type_t v68 = "on_frame_recv_callback";
        v69 = 2082;
        __int16 v70 = (char *)(a3 + 205);
        BOOL v71 = 1024;
        *(_DWORD *)id v72 = v25;
        BOOL v11 = "%{public}s %{public}s no input handler found for stream %d, ignoring RST_STREAM";
        os_log_type_t v12 = (os_log_s *)v24;
        os_log_type_t v13 = OS_LOG_TYPE_INFO;
        goto LABEL_40;
      }

      break;
    case 4:
      if (!gLogDatapath) {
        return 0LL;
      }
      BOOL v14 = (os_log_s *)__nwlog_obj();
      result = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v68 = "on_frame_recv_callback";
        v69 = 2082;
        __int16 v70 = (char *)(a3 + 205);
        BOOL v11 = "%{public}s %{public}s received complete SETTINGS frame";
LABEL_26:
        os_log_type_t v12 = v14;
        os_log_type_t v13 = OS_LOG_TYPE_DEBUG;
        os_log_type_t v17 = 22;
        goto LABEL_41;
      }

      return result;
    case 5:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v18 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        os_log_type_t v19 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446722;
        os_log_type_t v68 = "on_frame_recv_callback";
        v69 = 2082;
        __int16 v70 = (char *)(a3 + 205);
        BOOL v71 = 1024;
        *(_DWORD *)id v72 = v19;
        BOOL v11 = "%{public}s %{public}s received a complete PUSH_PROMISE frame on stream %d -- currently not supported";
LABEL_29:
        os_log_type_t v12 = (os_log_s *)v18;
        os_log_type_t v13 = OS_LOG_TYPE_ERROR;
LABEL_40:
        os_log_type_t v17 = 28;
        goto LABEL_41;
      }

      return result;
    case 7:
      if (gLogDatapath)
      {
        BOOL v46 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v68 = "on_frame_recv_callback";
          v69 = 2082;
          __int16 v70 = (char *)(a3 + 205);
          _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s received complete GOAWAY frame, tearing down tunnel connection",  buf,  0x16u);
        }
      }

      nw_http2_transport_connection_close(a3);
      return 0LL;
    case 8:
      if (!gLogDatapath) {
        return 0LL;
      }
      id v20 = (os_log_s *)__nwlog_obj();
      result = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        os_log_type_t v21 = *(_DWORD *)(a2 + 8);
        id v22 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v68 = "on_frame_recv_callback";
        v69 = 2082;
        __int16 v70 = (char *)(a3 + 205);
        BOOL v71 = 1024;
        *(_DWORD *)id v72 = v21;
        *(_WORD *)&v72[4] = 1024;
        *(_DWORD *)&v72[6] = v22;
        BOOL v11 = "%{public}s %{public}s received window update frame for stream %d, window size increment %d";
        os_log_type_t v12 = v20;
        os_log_type_t v13 = OS_LOG_TYPE_DEBUG;
        os_log_type_t v17 = 34;
LABEL_41:
        _os_log_impl(&dword_181A5C000, v12, v13, v11, buf, v17);
        return 0LL;
      }

      return result;
    default:
      return result;
  }

  return result;
}

  if (v36) {
    free(v36);
  }
  return 0LL;
}

        if (!v29) {
          return 1LL;
        }
        goto LABEL_101;
      }

              __break(1u);
              return;
            }
          }

          else
          {
            id v61 = (os_log_s *)__nwlog_obj(v9, v10);
            os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446210;
            id v72 = "_strict_strlcat";
            os_log_type_t v62 = (void *)_os_log_send_and_compose_impl();
            free(v62);
            uint64_t v24 = v7 + v11;
            if (v7 + v11) {
              goto LABEL_21;
            }
          }

    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }

  if (v5)
  {
    if (__s)
    {
      __int16 v15 = *(void *)(*v10 + 8LL);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        char v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            os_log_type_t v44 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              __int16 v45 = *(void *)(v15 + 24);
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "_http_safe_append";
              uint64_t v52 = 2082;
              nw_endpoint_t v53 = "*remaining";
              id v54 = 2048;
              uint64_t v55 = v5;
              __int16 v56 = 2048;
              os_log_type_t v57 = v45;
              _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v15 + 24) = 0LL;
        }

        v14 += v5;
        goto LABEL_21;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      id v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        uint64_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        os_log_type_t v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
        }

    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }

  if (v5)
  {
    if (__s)
    {
      __int16 v15 = *(void *)(*v10 + 8LL);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        char v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            os_log_type_t v44 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              __int16 v45 = *(void *)(v15 + 24);
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "_http_safe_append";
              uint64_t v52 = 2082;
              nw_endpoint_t v53 = "*remaining";
              id v54 = 2048;
              uint64_t v55 = v5;
              __int16 v56 = 2048;
              os_log_type_t v57 = v45;
              _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v15 + 24) = 0LL;
        }

        v14 += v5;
        goto LABEL_21;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      id v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        uint64_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        os_log_type_t v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
        }

    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }

  if (v5)
  {
    if (__s)
    {
      __int16 v15 = *(void *)(*v10 + 8LL);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        char v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            os_log_type_t v44 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              __int16 v45 = *(void *)(v15 + 24);
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "_http_safe_append";
              uint64_t v52 = 2082;
              nw_endpoint_t v53 = "*remaining";
              id v54 = 2048;
              uint64_t v55 = v5;
              __int16 v56 = 2048;
              os_log_type_t v57 = v45;
              _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v15 + 24) = 0LL;
        }

        v14 += v5;
        goto LABEL_21;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      id v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        uint64_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        os_log_type_t v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
        }

    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }

  if (v5)
  {
    if (__s)
    {
      __int16 v15 = *(void *)(*v10 + 8LL);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        char v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            os_log_type_t v44 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              __int16 v45 = *(void *)(v15 + 24);
              *(_DWORD *)buf = 136446978;
              __int16 v51 = "_http_safe_append";
              uint64_t v52 = 2082;
              nw_endpoint_t v53 = "*remaining";
              id v54 = 2048;
              uint64_t v55 = v5;
              __int16 v56 = 2048;
              os_log_type_t v57 = v45;
              _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v15 + 24) = 0LL;
        }

        v14 += v5;
        goto LABEL_21;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      id v41 = (char *)__nw_create_backtrace_string();
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }

        goto LABEL_120;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "_http_safe_append";
        uint64_t v52 = 2082;
        nw_endpoint_t v53 = v41;
        os_log_type_t v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "_http_safe_append";
      id v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__src == 17)
      {
        __int16 v28 = (os_log_s *)__nwlog_obj();
        BOOL v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "_http_safe_append";
          char v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
        }

LABEL_101:
  if (v10) {
LABEL_102:
  }
    free(v10);
LABEL_103:
  os_log_type_t v64 = 0LL;
LABEL_197:

  return v64;
}

          uint64_t v86 = 0;
          goto LABEL_101;
        }

        os_log_type_t v44 = *((void *)v3 + 6);
        __int16 v45 = *((void *)v3 + 11);
        BOOL v46 = (nw_error *)*((void *)v3 + 19);
        if (v46) {
          error_code = nw_error_get_error_code(v46);
        }
        else {
          error_code = 0LL;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v44 + 16))(v44, v45, error_code);
        break;
      case 3:
        char v26 = *((void *)v3 + 20);
        if (v26)
        {
          id v27 = (uint64_t)(*(void *)(v26 + 24) - *(void *)(v26 + 16)) >> 3;
          __int16 v28 = *((void *)v3 + 21);
          if (v28)
          {
LABEL_28:
            BOOL v29 = (uint64_t)(*(void *)(v28 + 24) - *(void *)(v28 + 16)) >> 3;
            goto LABEL_47;
          }
        }

        else
        {
          id v27 = 0LL;
          __int16 v28 = *((void *)v3 + 21);
          if (v28) {
            goto LABEL_28;
          }
        }

        BOOL v29 = 0LL;
LABEL_47:
        __int16 v152 = 0LL;
        uint64_t v153 = &v152;
        uint64_t v154 = 0x2020000000LL;
        v155 = 0LL;
        __int16 v148 = 0LL;
        v149 = &v148;
        __int16 v150 = 0x2020000000LL;
        id v151 = 0LL;
        if (!v27) {
          goto LABEL_53;
        }
        if (!(v27 >> 61)) {
          goto LABEL_49;
        }
        __nwlog_obj();
        int v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v117, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v163 = "strict_calloc";
        __int16 v118 = (void *)_os_log_send_and_compose_impl();

        free(v118);
LABEL_49:
        nw_endpoint_t v48 = calloc(v27, 8uLL);
        if (v48) {
          goto LABEL_50;
        }
        __nwlog_obj();
        nw_endpoint_t v119 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v119, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        v163 = "strict_calloc";
        v164 = 2048;
        *(void *)v165 = v27;
        *(_WORD *)&v165[8] = 2048;
        *(void *)&v165[10] = 8LL;
        __int16 v120 = (void *)_os_log_send_and_compose_impl();

        free(v120);
LABEL_50:
        v153[3] = (uint64_t)v48;
        if (!(v27 >> 61)) {
          goto LABEL_51;
        }
        __nwlog_obj();
        v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v121, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v163 = "strict_calloc";
        __int16 v122 = (void *)_os_log_send_and_compose_impl();

        free(v122);
LABEL_51:
        os_log_type_t v49 = calloc(v27, 8uLL);
        if (v49) {
          goto LABEL_52;
        }
        __nwlog_obj();
        id v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v123, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        v163 = "strict_calloc";
        v164 = 2048;
        *(void *)v165 = v27;
        *(_WORD *)&v165[8] = 2048;
        *(void *)&v165[10] = 8LL;
        uint64_t v124 = (void *)_os_log_send_and_compose_impl();

        if (!__nwlog_abort((uint64_t)v124))
        {
          free(v124);
LABEL_52:
          v149[3] = (uint64_t)v49;
          nw_endpoint_t v50 = (unsigned __int8 *)*((void *)v3 + 20);
          v142[0] = MEMORY[0x1895F87A8];
          v142[1] = 3221225472LL;
          v142[2] = ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_2;
          v142[3] = &unk_189BC0A98;
          __int16 v146 = v29;
          v147 = v27;
          __int16 v144 = &v152;
          v145 = &v148;
          v143 = v3;
          nw_array_apply(v50, (uint64_t)v142);

LABEL_53:
          if (!*((void *)v3 + 7))
          {
            (*(void (**)(void, uint64_t))(*((void *)v3 + 5) + 16LL))(*((void *)v3 + 5), v153[3]);
            id v61 = (void *)v153[3];
            if (v61 || v149[3])
            {
              if (v27)
              {
                for (i = 0LL; i != v27; ++i)
                {
                  id v63 = v153[3];
                  if (v63)
                  {
                    os_log_type_t v64 = *(void **)(v63 + 8 * i);
                    if (v64)
                    {
                      *(void *)(v63 + 8 * i) = 0LL;
                    }
                  }

                  os_log_type_t v65 = v149[3];
                  if (v65)
                  {
                    char v66 = *(void **)(v65 + 8 * i);
                    if (v66)
                    {
                      *(void *)(v65 + 8 * i) = 0LL;
                    }
                  }
                }

                id v61 = (void *)v153[3];
              }

              if (v61)
              {
                free(v61);
                v153[3] = 0LL;
              }

              id v114 = (void *)v149[3];
              if (v114)
              {
                free(v114);
                v149[3] = 0LL;
              }
            }

            goto LABEL_126;
          }

          __int16 v51 = (void *)*((void *)v3 + 19);
          if (!v51)
          {
LABEL_120:
            unint64_t v107 = *((id *)v3 + 19);
            unint64_t v108 = *((_DWORD *)v3 + 22);
            os_log_type_t v109 = _Block_copy(*((const void **)v3 + 5));
            BOOL v110 = (void *)*((void *)v3 + 7);
            BOOL v111 = *((_DWORD *)v3 + 16);
            v135[0] = MEMORY[0x1895F87A8];
            v135[1] = 3221225472LL;
            v135[2] = ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_102;
            v135[3] = &unk_189BC0AC0;
            v138 = &v152;
            uint64_t v139 = &v148;
            int v141 = v108;
            char v136 = v107;
            nw_endpoint_t v137 = v109;
            __int16 v140 = v27;
            os_log_type_t v112 = v107;
            v113 = v109;
            nw_connection_async_client_if_needed_with_override(v110, v4, v111, v135);

LABEL_126:
            os_log_type_t v115 = (void *)*((void *)v3 + 20);
            *((void *)v3 + 20) = 0LL;

            __int16 v116 = (void *)*((void *)v3 + 21);
            *((void *)v3 + 21) = 0LL;

            _Block_object_dispose(&v148, 8);
            _Block_object_dispose(&v152, 8);
            break;
          }

          uint64_t v52 = v51;
          nw_endpoint_t v53 = v52[2];

          if (v53 == 1 && nw_error_get_error_code(*((nw_error_t *)v3 + 19)) == 89)
          {
            id v54 = *(void *)(*((void *)v3 + 7) + 16LL);
            if (!v54 || nw_path_parameters_get_logging_disabled(*(void *)(v54 + 104))) {
              goto LABEL_120;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v55 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_INFO)) {
              goto LABEL_119;
            }
            __int16 v56 = *(_DWORD *)(*((void *)v3 + 7) + 448LL);
            *(_DWORD *)buf = 136446466;
            v163 = "nw_read_request_report";
            v164 = 1024;
            *(_DWORD *)v165 = v56;
            os_log_type_t v57 = "%{public}s [C%u] Receive cancelled";
            __int16 v58 = v55;
            uint64_t v59 = OS_LOG_TYPE_INFO;
            __int16 v60 = 18;
          }

          else
          {
            BOOL v104 = *(void *)(*((void *)v3 + 7) + 16LL);
            if (!v104 || nw_path_parameters_get_logging_disabled(*(void *)(v104 + 104))) {
              goto LABEL_120;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v55 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
              goto LABEL_119;
            }
            id v105 = *(_DWORD *)(*((void *)v3 + 7) + 448LL);
            os_log_type_t v106 = *((void *)v3 + 19);
            *(_DWORD *)buf = 136446722;
            v163 = "nw_read_request_report";
            v164 = 1024;
            *(_DWORD *)v165 = v105;
            *(_WORD *)&v165[4] = 2114;
            *(void *)&v165[6] = v106;
            os_log_type_t v57 = "%{public}s [C%u] Receive failed with error %{public}@";
            __int16 v58 = v55;
            uint64_t v59 = OS_LOG_TYPE_ERROR;
            __int16 v60 = 28;
          }

          _os_log_impl(&dword_181A5C000, v58, v59, v57, buf, v60);
LABEL_119:

          goto LABEL_120;
        }

    free(v60);
    goto LABEL_101;
  }

  (*(void (**)(uint64_t, char *))(*(void *)(protocol_handler + 24) + 24LL))( protocol_handler,  (char *)a1 + 88);
  *((_BYTE *)a1 + 166) = nw_parameters_get_ip_protocol(v33);
  __int16 v56 = a1[5];
  if (v56) {
    LODWORD(v56) = v56[2];
  }
  *((_DWORD *)a1 + 40) = (_DWORD)v56;
  a1 = a1;
  a1[16] = a1;
LABEL_103:

  return a1;
}

    if (v43) {
      free(v43);
    }
    goto LABEL_58;
  }

  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
  }
  id v4 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (!v4)
  {
    __nwlog_obj();
    BOOL v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_quic_report_application_result_on_queue";
    BOOL v47 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_181A5C000, v48, v49, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v66)
    {
      nw_endpoint_t v53 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v54 = type;
      uint64_t v55 = os_log_type_enabled(v48, type);
      if (v53)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          v69 = "nw_quic_report_application_result_on_queue";
          __int16 v70 = 2082;
          BOOL v71 = v53;
          _os_log_impl( &dword_181A5C000,  v48,  v54,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v53);
LABEL_111:
        if (!v47)
        {
LABEL_57:

LABEL_58:
          return;
        }

  if (v35) {
    free(v35);
  }
LABEL_9:
  os_log_type_t v8 = handle + 736;
  if (a1->output_handler != a2)
  {
    if ((*v8 & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        BOOL v9 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v10 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
          BOOL v11 = (nw_protocol *)*((void *)handle + 30);
          output_handler = a1->output_handler;
          *(_DWORD *)buf = 136447490;
          id v93 = "nw_protocol_http3_stream_connected";
          os_log_type_t v94 = 2082;
          os_log_type_t v95 = handle + 636;
          BOOL v96 = 2080;
          os_log_type_t v97 = " ";
          os_log_type_t v98 = 1024;
          os_log_type_t v99 = v10;
          os_log_type_t v100 = 2048;
          BOOL v101 = v11;
          id v102 = 2048;
          os_log_type_t v103 = output_handler;
          os_log_type_t v13 = "%{public}s %{public}s%s<i%u:s%llu> connected protocol is not our output_handler (%p), ignoring";
          BOOL v14 = v9;
LABEL_14:
          _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, v13, buf, 0x3Au);
          return;
        }
      }
    }

    return;
  }

  if (a2)
  {
    if (!*((void *)handle + 52))
    {
      __int16 v15 = a2->callbacks;
      if (v15)
      {
        copy_info = (uint64_t (*)(nw_protocol *, uint64_t, char *))v15->copy_info;
        if (copy_info)
        {
          os_log_type_t v17 = (unsigned __int8 *)copy_info(a2, 255LL, handle);
          v89[0] = MEMORY[0x1895F87A8];
          v89[1] = 0x40000000LL;
          v89[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke;
          v89[3] = &__block_descriptor_tmp_128_62025;
          v89[4] = handle;
          nw_array_apply(v17, (uint64_t)v89);
          if (v17) {
            os_release(v17);
          }
        }
      }
    }
  }

  if (!a1->default_input_handler)
  {
    if ((*v8 & 0x800) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        BOOL v25 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
        char v26 = (nw_protocol *)*((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        id v93 = "nw_protocol_http3_stream_connected";
        os_log_type_t v94 = 2082;
        os_log_type_t v95 = handle + 636;
        BOOL v96 = 2080;
        os_log_type_t v97 = " ";
        os_log_type_t v98 = 1024;
        os_log_type_t v99 = v25;
        os_log_type_t v100 = 2048;
        BOOL v101 = v26;
        _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%llu> No input handler found, ignoring connected call",  buf,  0x30u);
      }
    }

    return;
  }

  if ((*v8 & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      int v79 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
      {
        __int16 v80 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
        id v81 = (nw_protocol *)*((void *)handle + 30);
        *(_DWORD *)buf = 136447746;
        id v93 = "nw_protocol_http3_stream_connected";
        os_log_type_t v94 = 2082;
        os_log_type_t v95 = handle + 636;
        BOOL v96 = 2080;
        os_log_type_t v97 = " ";
        os_log_type_t v98 = 1024;
        os_log_type_t v99 = v80;
        os_log_type_t v100 = 2048;
        BOOL v101 = v81;
        id v102 = 2048;
        os_log_type_t v103 = a1;
        BOOL v104 = 2048;
        id v105 = a2;
        _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> http3 stream %p connected with output_handler %p",  buf,  0x44u);
      }
    }
  }

  BOOL v18 = *((void *)handle + 42);
  if (!v18)
  {
    id v20 = (unsigned __int16)*v8 | (handle[738] << 16);
    goto LABEL_34;
  }

  os_log_type_t v19 = *(_DWORD *)(v18 + 1272);
  id v20 = (unsigned __int16)*v8 | (handle[738] << 16);
  if (v19)
  {
LABEL_34:
    *os_log_type_t v8 = v20;
    handle[738] = (v20 | 0x80000u) >> 16;
    id v27 = (void *)*((void *)handle + 49);
    v88[0] = MEMORY[0x1895F87A8];
    v88[1] = 0x40000000LL;
    v88[2] = ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_129;
    v88[3] = &__block_descriptor_tmp_137_62029;
    v88[4] = handle;
    nw_http_transaction_metadata_set_event_handler(v27, v88);
    __int16 v28 = *((_WORD *)handle + 368) & 0xFF7F | (handle[738] << 16);
    *os_log_type_t v8 = *v8 & 0xFF3F | 0x40;
    handle[738] = BYTE2(v28);
    nw_http3_signal_output_pending(*((void *)handle + 42), 1);
    BOOL v29 = a1->default_input_handler;
    if (v29)
    {
      char v30 = v29->callbacks;
      if (v30)
      {
        __int16 v31 = (void (*)(nw_protocol *, nw_protocol *))v30->connected;
        if (v31)
        {
          v31(v29, a1);
LABEL_38:
          nw_http3_signal_output_pending(*((void *)handle + 42), 0);
          return;
        }
      }
    }

    __nwlog_obj();
    os_log_type_t v57 = a1->default_input_handler;
    __int16 v58 = "invalid";
    if (v57)
    {
      uint64_t v59 = v57->identifier;
      if (v59) {
        __int16 v58 = (const char *)v59;
      }
    }

    *(_DWORD *)buf = 136446466;
    id v93 = "nw_protocol_http3_stream_connected";
    os_log_type_t v94 = 2082;
    os_log_type_t v95 = (char *)v58;
    __int16 v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v90 = 0;
    if (__nwlog_fault(v60, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v61 = (os_log_s *)__nwlog_obj();
        os_log_type_t v62 = type;
        if (!os_log_type_enabled(v61, type)) {
          goto LABEL_134;
        }
        id v63 = a1->default_input_handler;
        os_log_type_t v64 = "invalid";
        if (v63)
        {
          os_log_type_t v65 = v63->identifier;
          if (v65) {
            os_log_type_t v64 = (const char *)v65;
          }
        }

        *(_DWORD *)buf = 136446466;
        id v93 = "nw_protocol_http3_stream_connected";
        os_log_type_t v94 = 2082;
        os_log_type_t v95 = (char *)v64;
        char v66 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_133;
      }

      if (!v90)
      {
        id v61 = (os_log_s *)__nwlog_obj();
        os_log_type_t v62 = type;
        if (!os_log_type_enabled(v61, type)) {
          goto LABEL_134;
        }
        id v82 = a1->default_input_handler;
        int v83 = "invalid";
        if (v82)
        {
          id v84 = v82->identifier;
          if (v84) {
            int v83 = (const char *)v84;
          }
        }

        *(_DWORD *)buf = 136446466;
        id v93 = "nw_protocol_http3_stream_connected";
        os_log_type_t v94 = 2082;
        os_log_type_t v95 = (char *)v83;
        char v66 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_133;
      }

      __int16 v74 = (char *)__nw_create_backtrace_string();
      id v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      os_log_type_t v75 = os_log_type_enabled(v61, type);
      if (v74)
      {
        if (v75)
        {
          __int16 v76 = a1->default_input_handler;
          BOOL v77 = "invalid";
          if (v76)
          {
            __int16 v78 = v76->identifier;
            if (v78) {
              BOOL v77 = (const char *)v78;
            }
          }

          *(_DWORD *)buf = 136446722;
          id v93 = "nw_protocol_http3_stream_connected";
          os_log_type_t v94 = 2082;
          os_log_type_t v95 = (char *)v77;
          BOOL v96 = 2082;
          os_log_type_t v97 = v74;
          _os_log_impl( &dword_181A5C000,  v61,  v62,  "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v74);
        goto LABEL_134;
      }

      if (v75)
      {
        BOOL v85 = a1->default_input_handler;
        uint64_t v86 = "invalid";
        if (v85)
        {
          BOOL v87 = v85->identifier;
          if (v87) {
            uint64_t v86 = (const char *)v87;
          }
        }

        *(_DWORD *)buf = 136446466;
        id v93 = "nw_protocol_http3_stream_connected";
        os_log_type_t v94 = 2082;
        os_log_type_t v95 = (char *)v86;
        char v66 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_133:
        _os_log_impl(&dword_181A5C000, v61, v62, v66, buf, 0x16u);
      }
    }

        if (!v37) {
          return 0LL;
        }
        BOOL v36 = (char *)v37;
        goto LABEL_50;
      }

      if (!v48)
      {
        v38 = (os_log_s *)__nwlog_obj();
        uint64_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v51 = "nw_protocol_http_messaging_add_input_handler";
        id v40 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_99;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = (os_log_s *)__nwlog_obj();
      uint64_t v39 = type;
      BOOL v47 = os_log_type_enabled(v38, type);
      if (!backtrace_string)
      {
        if (!v47) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v51 = "nw_protocol_http_messaging_add_input_handler";
        id v40 = "%{public}s called with null options, no backtrace";
        goto LABEL_99;
      }

      if (v47)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "nw_protocol_http_messaging_add_input_handler";
        uint64_t v52 = 2082;
        nw_endpoint_t v53 = (nw_protocol *)backtrace_string;
        os_log_type_t v43 = "%{public}s called with null options, dumping backtrace:%{public}s";
        goto LABEL_77;
      }

      if (!v53) {
        return 1LL;
      }
      nw_endpoint_t v50 = (char *)v53;
      goto LABEL_70;
    }
  }

  else
  {
    char v26 = *(void *)(a1 + 32);
    if (!v26 || (*(__int16 *)(v26 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v27 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        __int16 v28 = *(void *)(a1 + 32);
        BOOL v29 = (const char *)(v28 + 390);
        char v30 = "";
        __int16 v31 = v28 == 0;
        nw_endpoint_t v32 = *(_DWORD *)(v28 + 368);
        if (v31) {
          BOOL v29 = "";
        }
        v69 = "nw_http2_deliver_pending_output_available_block_invoke";
        __int16 v70 = 2082;
        *(_DWORD *)buf = 136446978;
        if (!v31) {
          char v30 = " ";
        }
        BOOL v71 = v29;
        id v72 = 2080;
        BOOL v73 = v30;
        __int16 v74 = 1024;
        os_log_type_t v75 = v32;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> input protocol has no stream, not triggering output_available",  buf,  0x26u);
      }
    }
  }

  return 1LL;
}

    LODWORD(v52) = v52 | 0x40;
    if (a13)
    {
LABEL_87:
      LODWORD(v52) = v52 | 0x80;
      if (!a14) {
        goto LABEL_88;
      }
      goto LABEL_102;
    }

      free(backtrace_string);
      goto LABEL_117;
    }

    id v41 = (os_log_s *)__nwlog_obj();
    BOOL v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_117;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v59 = "nw_protocol_ipv6_remove_input_handler";
    os_log_type_t v43 = "%{public}s called with null protocol";
LABEL_116:
    _os_log_impl(&dword_181A5C000, v41, v42, v43, buf, 0xCu);
LABEL_117:
    if (v44) {
      free(v44);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (handle == &nw_protocol_ref_counted_handle) {
    p_output_handler = &a1[1].output_handler;
  }
  else {
    p_output_handler = 0LL;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v59 = "nw_protocol_ipv6_remove_input_handler";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v56 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v41 = (os_log_s *)__nwlog_obj();
      BOOL v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_117;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "nw_protocol_ipv6_remove_input_handler";
      os_log_type_t v43 = "%{public}s called with null ipv6";
      goto LABEL_116;
    }

    if (!v56)
    {
      id v41 = (os_log_s *)__nwlog_obj();
      BOOL v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_117;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "nw_protocol_ipv6_remove_input_handler";
      os_log_type_t v43 = "%{public}s called with null ipv6, backtrace limit exceeded";
      goto LABEL_116;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v41 = (os_log_s *)__nwlog_obj();
    BOOL v42 = type;
    nw_endpoint_t v53 = os_log_type_enabled(v41, type);
    if (backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v59 = "nw_protocol_ipv6_remove_input_handler";
        __int16 v60 = 2082;
        id v61 = backtrace_string;
        uint64_t v52 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
        goto LABEL_99;
      }

      goto LABEL_100;
    }

    if (!v53) {
      goto LABEL_117;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v59 = "nw_protocol_ipv6_remove_input_handler";
    os_log_type_t v43 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_116;
  }

  if (a2)
  {
    if (a2->output_handler == a1)
    {
      callbacks = a1[1].callbacks;
      if (callbacks)
      {
        BOOL v9 = (nw_protocol_callbacks *)((char *)callbacks - 1);
        a1[1].callbacks = v9;
        if (!v9)
        {
          os_log_type_t v10 = *(void (***)(void))a1[1].flow_id;
          if (v10)
          {
            *(void *)a1[1].flow_id = 0LL;
            v10[2](v10);
            _Block_release(v10);
          }

          if ((a1[1].flow_id[8] & 1) != 0)
          {
            BOOL v11 = *(const void **)a1[1].flow_id;
            if (v11) {
              _Block_release(v11);
            }
          }

          free(a1);
        }
      }

      a2->output_handler = 0LL;
    }

    goto LABEL_18;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v59 = "__nw_protocol_get_output_handler";
  BOOL v46 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v56 = 0;
  if (__nwlog_fault(v46, &type, &v56))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v47 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "__nw_protocol_get_output_handler";
      os_log_type_t v49 = "%{public}s called with null protocol";
      goto LABEL_121;
    }

    if (!v56)
    {
      BOOL v47 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "__nw_protocol_get_output_handler";
      os_log_type_t v49 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_121;
    }

    id v54 = (char *)__nw_create_backtrace_string();
    BOOL v47 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v48 = type;
    uint64_t v55 = os_log_type_enabled(v47, type);
    if (v54)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v59 = "__nw_protocol_get_output_handler";
        __int16 v60 = 2082;
        id v61 = v54;
        _os_log_impl( &dword_181A5C000,  v47,  v48,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v54);
      goto LABEL_122;
    }

    if (v55)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v59 = "__nw_protocol_get_output_handler";
      os_log_type_t v49 = "%{public}s called with null protocol, no backtrace";
LABEL_121:
      _os_log_impl(&dword_181A5C000, v47, v48, v49, buf, 0xCu);
    }
  }

void sub_181AED3FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, uint64_t a21, void *a22)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_internal_iterate_protocol_stack(void *a1, int a2, char a3, void *a4)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  __int16 v7 = a1;
  id v8 = a4;
  BOOL v9 = (void (**)(void, void, void, void))v8;
  if (v7)
  {
    if (v8)
    {
      os_log_type_t v10 = v7[19];
      BOOL v11 = v10;
      if (v10)
      {
        switch(a2)
        {
          case 1:
            if (v10[7]) {
              goto LABEL_95;
            }
            if (nw_protocol_copy_ethernet_definition::onceToken == -1)
            {
              os_log_type_t v12 = (void *)nw_protocol_copy_ethernet_definition::ethernet_definition;
              if (nw_protocol_copy_ethernet_definition::ethernet_definition)
              {
LABEL_8:
                os_log_type_t v13 = os_retain(v12);
                goto LABEL_94;
              }
            }

            else
            {
              dispatch_once(&nw_protocol_copy_ethernet_definition::onceToken, &__block_literal_global_5_31717);
              os_log_type_t v12 = (void *)nw_protocol_copy_ethernet_definition::ethernet_definition;
              if (nw_protocol_copy_ethernet_definition::ethernet_definition) {
                goto LABEL_8;
              }
            }

            os_log_type_t v13 = 0LL;
LABEL_94:
            options = nw_protocol_create_options(v13);
            nw_endpoint_t v50 = (void *)v11[7];
            v11[7] = options;

LABEL_95:
            if (nw_protocol_copy_ethernet_definition::onceToken == -1)
            {
              __int16 v51 = (void *)nw_protocol_copy_ethernet_definition::ethernet_definition;
              if (nw_protocol_copy_ethernet_definition::ethernet_definition)
              {
LABEL_97:
                id v17 = os_retain(v51);
                goto LABEL_100;
              }
            }

            else
            {
              dispatch_once(&nw_protocol_copy_ethernet_definition::onceToken, &__block_literal_global_5_31717);
              __int16 v51 = (void *)nw_protocol_copy_ethernet_definition::ethernet_definition;
              if (nw_protocol_copy_ethernet_definition::ethernet_definition) {
                goto LABEL_97;
              }
            }

            id v17 = 0LL;
LABEL_100:
            ((void (**)(void, void, id, void))v9)[2](v9, 0LL, v17, v11[6]);
            goto LABEL_101;
          case 2:
            __int16 v15 = (void *)v10[6];
            if (!v15) {
              goto LABEL_91;
            }
            char v16 = v15;
            id v17 = v16[1];

            ((void (**)(void, void, id, void))v9)[2](v9, 0LL, v17, v11[6]);
            goto LABEL_101;
          case 3:
            BOOL v18 = (void *)v10[3];
            if (!v18) {
              goto LABEL_91;
            }
            id v19 = v18;
            BOOL v20 = nw_protocol_options_matches_definition(v19, (void *)g_tcp_definition);

            if (v20)
            {
              if ((a3 & 1) != 0) {
                goto LABEL_102;
              }
              goto LABEL_28;
            }

            BOOL is_udp = nw_protocol_options_is_udp((void *)v11[3]);
            if ((a3 & 1) != 0)
            {
              if (!is_udp && nw_protocol_options_is_quic((nw_protocol_options_t)v11[3]))
              {
LABEL_28:
                id v17 = nw_protocol_options_copy_definition((nw_protocol_options_t)v11[3]);
                ((void (**)(void, void, id, void))v9)[2](v9, 0LL, v17, v11[3]);
                goto LABEL_101;
              }
            }

            else
            {
              if (is_udp || !nw_protocol_options_is_quic((nw_protocol_options_t)v11[3])) {
                goto LABEL_28;
              }
              if (!v11[4])
              {
                nw_protocol_options_t v26 = nw_udp_create_options();
                id v27 = (void *)v11[4];
                v11[4] = v26;

                nw_udp_options_set_no_metadata((void *)v11[4], 1);
              }

              id v17 = nw_protocol_copy_udp_definition();
              ((void (**)(void, uint64_t, id, void))v9)[2](v9, 1LL, v17, v11[4]);
LABEL_101:
            }

LABEL_62:
      free(v38);
    }
  }
        }
      }

      if (v53) {
        free(v53);
      }
LABEL_37:

      os_log_type_t v31 = nw_content_context_copy_error(v10);
      if (v31)
      {
        nw_endpoint_t v32 = nw_endpoint_handler_get_minimize_logging(v4);
        os_log_type_t v33 = nw_endpoint_handler_get_logging_disabled(v4);
        if (v32)
        {
          if ((v33 & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v34 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              __int16 v56 = nw_endpoint_handler_get_id_string(v4);
              os_log_type_t v57 = nw_endpoint_handler_dry_run_string(v4);
              loga = v34;
              char v58 = nw_endpoint_handler_copy_endpoint(v4);
              os_log_type_t v59 = nw_endpoint_get_logging_description(v58);
              __int16 v60 = nw_endpoint_handler_state_string(v4);
              id v61 = nw_endpoint_handler_mode_string(v4);
              __int16 v62 = nw_endpoint_handler_copy_current_path(v4);
              *(_DWORD *)buf = 136448002;
              BOOL v87 = "nw_flow_copy_write_request";
              nw_endpoint_t v88 = 2082;
              os_log_type_t v89 = (void *)v56;
              os_log_type_t v90 = 2082;
              os_log_type_t v91 = v57;
              BOOL v92 = 2082;
              id v93 = v59;
              os_log_type_t v94 = 2082;
              os_log_type_t v95 = v60;
              BOOL v96 = 2082;
              os_log_type_t v97 = v61;
              os_log_type_t v98 = 2114;
              os_log_type_t v99 = v62;
              os_log_type_t v100 = 2112;
              BOOL v101 = v10;
              os_log_type_t v34 = loga;
              _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ has ant ecedent error, failing request",  buf,  0x52u);
            }

      free(v25);
      goto LABEL_63;
    }

    __nwlog_obj();
    os_log_type_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
    os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();

    v44[0] = 16;
    LOBYTE(location) = 0;
    if (__nwlog_fault(v34, v44, &location))
    {
      if (v44[0] == 17)
      {
        __nwlog_obj();
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v36 = v44[0];
        if (os_log_type_enabled(v35, (os_log_type_t)v44[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
          _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s called with null request->connection", buf, 0xCu);
        }
      }

      else if ((_BYTE)location)
      {
        os_log_type_t v37 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v38 = v44[0];
        os_log_type_t v39 = os_log_type_enabled(v35, (os_log_type_t)v44[0]);
        if (v37)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v37;
            _os_log_impl( &dword_181A5C000,  v35,  v38,  "%{public}s called with null request->connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v37);
          goto LABEL_91;
        }

        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
          _os_log_impl( &dword_181A5C000,  v35,  v38,  "%{public}s called with null request->connection, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v40 = v44[0];
        if (os_log_type_enabled(v35, (os_log_type_t)v44[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
          _os_log_impl( &dword_181A5C000,  v35,  v40,  "%{public}s called with null request->connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
          goto LABEL_63;
        }

        v349 = (void *)v33;
        objc_storeStrong((id *)v6 + 2, (id)v33);
      }

      else
      {
        lock = (os_unfair_lock_s *)((char *)v6 + 880);
        os_unfair_lock_lock((os_unfair_lock_t)v6 + 220);
        v349 = 0LL;
      }

      if (!*((void *)v6 + 90)) {
        goto LABEL_71;
      }
      goto LABEL_36;
    }

    __nwlog_obj();
    id v271 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
    v272 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v359) = 0;
    if (__nwlog_fault(v272, type, &v359))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v273 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v274 = type[0];
        if (os_log_type_enabled(v273, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          _os_log_impl(&dword_181A5C000, v273, v274, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if ((_BYTE)v359)
      {
        v278 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v273 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v279 = type[0];
        v280 = os_log_type_enabled(v273, type[0]);
        if (v278)
        {
          if (v280)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
            v364 = 2082;
            id v365 = v278;
            _os_log_impl( &dword_181A5C000,  v273,  v279,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v278);
          goto LABEL_403;
        }

        if (v280)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          _os_log_impl( &dword_181A5C000,  v273,  v279,  "%{public}s called with null endpoint_flow, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v273 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v299 = type[0];
        if (os_log_type_enabled(v273, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          _os_log_impl( &dword_181A5C000,  v273,  v299,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  result = 0LL;
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0)
  {
    if (g_channel_check_validity)
    {
      uint64_t v35 = g_channel_check_validity(a1, *(void *)(a1 + 88));
      result = 0LL;
      if (a6)
      {
        if ((v35 & 1) == 0)
        {
          result = 0LL;
          *(void *)(a6 + 64) = 0LL;
          *(void *)(a6 + 72) = 0LL;
        }
      }
    }
  }

  return result;
}

LABEL_63:
        if (!v8) {
          goto LABEL_65;
        }
        goto LABEL_64;
      }

      if (!v81)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446466;
          id v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          BOOL v85 = 2082;
          *(void *)uint64_t v86 = v6;
          _os_log_impl( &dword_181A5C000,  v9,  v39,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
        }

        goto LABEL_62;
      }

      nw_protocol_options_t v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)(id)gLogObj;
      id v27 = type;
      __int16 v28 = os_log_type_enabled(v9, type);
      if (!v26)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          id v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          BOOL v85 = 2082;
          *(void *)uint64_t v86 = v6;
          _os_log_impl( &dword_181A5C000,  v9,  v27,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
        }

        goto LABEL_62;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446722;
        id v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        BOOL v85 = 2082;
        *(void *)uint64_t v86 = v6;
        *(_WORD *)&v86[8] = 2082;
        *(void *)&v86[10] = v26;
        _os_log_impl( &dword_181A5C000,  v9,  v27,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v26);
      if (!v8)
      {
LABEL_65:
        if (v6) {
LABEL_66:
        }
          free(v6);
LABEL_78:
        (*(void (**)(void, void))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40), 0LL);
        goto LABEL_138;
      }

      if (v17) {
        free(v17);
      }
      goto LABEL_7;
    }

    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "networkd_privileged_set_constrained";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v34 = 0;
    if (__nwlog_fault(v13, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_constrained";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v34)
      {
        uint64_t v23 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        BOOL v25 = os_log_type_enabled(v14, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v37 = "networkd_privileged_set_constrained";
            v38 = 2082;
            os_log_type_t v39 = v23;
            _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v23);
          goto LABEL_57;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_constrained";
          _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_constrained";
          _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_63:
    if (!v8) {
      goto LABEL_73;
    }
    goto LABEL_64;
  }

  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)(id)gLogObj;
    os_log_type_t v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_constrained_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v37,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  BOOL v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v9 = (os_log_s *)(id)gLogObj;
  nw_protocol_options_t v26 = type;
  id v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_constrained_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    __int16 v80 = "networkd_privileged_set_constrained_block_invoke";
    id v81 = 2082;
    *(void *)id v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(void *)&v82[10] = v25;
    _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v25);
  if (v8) {
    goto LABEL_64;
  }
LABEL_73:
  if (v6) {
LABEL_74:
  }
    free(v6);
LABEL_138:
}

      if (v17) {
        free(v17);
      }
      goto LABEL_7;
    }

    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "networkd_privileged_set_ultra_constrained";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v34 = 0;
    if (__nwlog_fault(v13, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_ultra_constrained";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v34)
      {
        uint64_t v23 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        BOOL v25 = os_log_type_enabled(v14, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v37 = "networkd_privileged_set_ultra_constrained";
            v38 = 2082;
            os_log_type_t v39 = v23;
            _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v23);
          goto LABEL_57;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_ultra_constrained";
          _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_ultra_constrained";
          _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_63:
    if (!v8) {
      goto LABEL_73;
    }
    goto LABEL_64;
  }

  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)(id)gLogObj;
    os_log_type_t v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v37,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  BOOL v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v9 = (os_log_s *)(id)gLogObj;
  nw_protocol_options_t v26 = type;
  id v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    __int16 v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
    id v81 = 2082;
    *(void *)id v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(void *)&v82[10] = v25;
    _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v25);
  if (v8) {
    goto LABEL_64;
  }
LABEL_73:
  if (v6) {
LABEL_74:
  }
    free(v6);
LABEL_138:
}

      if (v17) {
        free(v17);
      }
      goto LABEL_7;
    }

    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "networkd_privileged_set_expensive";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v34 = 0;
    if (__nwlog_fault(v13, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_expensive";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v34)
      {
        uint64_t v23 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        BOOL v25 = os_log_type_enabled(v14, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v37 = "networkd_privileged_set_expensive";
            v38 = 2082;
            os_log_type_t v39 = v23;
            _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v23);
          goto LABEL_57;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_expensive";
          _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "networkd_privileged_set_expensive";
          _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_63:
    if (!v8) {
      goto LABEL_73;
    }
    goto LABEL_64;
  }

  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)(id)gLogObj;
    os_log_type_t v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_expensive_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v37,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  BOOL v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v9 = (os_log_s *)(id)gLogObj;
  nw_protocol_options_t v26 = type;
  id v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_expensive_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    __int16 v80 = "networkd_privileged_set_expensive_block_invoke";
    id v81 = 2082;
    *(void *)id v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(void *)&v82[10] = v25;
    _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v25);
  if (v8) {
    goto LABEL_64;
  }
LABEL_73:
  if (v6) {
LABEL_74:
  }
    free(v6);
LABEL_138:
}

      if (v19) {
        free(v19);
      }
      goto LABEL_7;
    }

    __nwlog_obj();
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v41 = "networkd_privileged_set_throughput_estimates";
    __int16 v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v15, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v41 = "networkd_privileged_set_throughput_estimates";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v38)
      {
        BOOL v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_protocol_options_t v26 = type;
        id v27 = os_log_type_enabled(v16, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v41 = "networkd_privileged_set_throughput_estimates";
            BOOL v42 = 2082;
            os_log_type_t v43 = v25;
            _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v25);
          goto LABEL_57;
        }

        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v41 = "networkd_privileged_set_throughput_estimates";
          _os_log_impl(&dword_181A5C000, v16, v26, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_endpoint_t v32 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v41 = "networkd_privileged_set_throughput_estimates";
          _os_log_impl( &dword_181A5C000,  v16,  v32,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_63:
    if (!v8) {
      goto LABEL_73;
    }
    goto LABEL_64;
  }

  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)(id)gLogObj;
    os_log_type_t v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v37,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  BOOL v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v9 = (os_log_s *)(id)gLogObj;
  nw_protocol_options_t v26 = type;
  id v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
    id v81 = 2082;
    *(void *)id v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(void *)&v82[10] = v25;
    _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v25);
  if (v8) {
    goto LABEL_64;
  }
LABEL_73:
  if (v6) {
LABEL_74:
  }
    free(v6);
LABEL_136:
}

      if (v19) {
        free(v19);
      }
      goto LABEL_7;
    }

    __nwlog_obj();
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v41 = "networkd_privileged_set_radio_type";
    __int16 v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v15, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v41 = "networkd_privileged_set_radio_type";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v38)
      {
        BOOL v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_protocol_options_t v26 = type;
        id v27 = os_log_type_enabled(v16, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v41 = "networkd_privileged_set_radio_type";
            BOOL v42 = 2082;
            os_log_type_t v43 = v25;
            _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v25);
          goto LABEL_57;
        }

        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v41 = "networkd_privileged_set_radio_type";
          _os_log_impl(&dword_181A5C000, v16, v26, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_endpoint_t v32 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v41 = "networkd_privileged_set_radio_type";
          _os_log_impl( &dword_181A5C000,  v16,  v32,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_63:
    if (!v8) {
      goto LABEL_73;
    }
    goto LABEL_64;
  }

  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)(id)gLogObj;
    os_log_type_t v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v37,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  BOOL v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v9 = (os_log_s *)(id)gLogObj;
  nw_protocol_options_t v26 = type;
  id v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
      id v81 = 2082;
      *(void *)id v82 = v6;
      _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
    id v81 = 2082;
    *(void *)id v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(void *)&v82[10] = v25;
    _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v25);
  if (v8) {
    goto LABEL_64;
  }
LABEL_73:
  if (v6) {
LABEL_74:
  }
    free(v6);
LABEL_136:
}

      if (v25) {
        free(v25);
      }
LABEL_6:
      id v3 = (NWConcrete_nw_context *)v7;
      goto LABEL_7;
    }

    __nwlog_obj(0LL, v5);
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v48 = "nw_context_queue_block";
    id v19 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v45 = 0;
    BOOL v20 = __nwlog_fault(v19, &type, &v45);
    if (!(_DWORD)v20) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v20, v21);
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_context_queue_block";
        _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null block", buf, 0xCu);
      }
    }

    else if (v45)
    {
      os_log_type_t v34 = (char *)__nw_create_backtrace_string();
      __nwlog_obj(v34, v35);
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v36 = type;
      os_log_type_t v37 = os_log_type_enabled(v22, type);
      if (v34)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v48 = "nw_context_queue_block";
          os_log_type_t v49 = 2082;
          nw_endpoint_t v50 = v34;
          _os_log_impl( &dword_181A5C000,  v22,  v36,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v34);
        goto LABEL_57;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_context_queue_block";
        _os_log_impl(&dword_181A5C000, v22, v36, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj(v20, v21);
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_context_queue_block";
        _os_log_impl( &dword_181A5C000,  v22,  v43,  "%{public}s called with null block, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_57:
    if (v19) {
      free(v19);
    }
    goto LABEL_7;
  }

  __nwlog_obj(v4, v5);
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v48 = "nw_context_queue_block";
  os_log_type_t v13 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v45 = 0;
  BOOL v14 = __nwlog_fault(v13, &type, &v45);
  if ((_DWORD)v14)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v14, v15);
      char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_context_queue_block";
        _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v45)
    {
      char v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj(v30, v31);
      char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v32 = type;
      os_log_type_t v33 = os_log_type_enabled(v16, type);
      if (v30)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v48 = "nw_context_queue_block";
          os_log_type_t v49 = 2082;
          nw_endpoint_t v50 = v30;
          _os_log_impl( &dword_181A5C000,  v16,  v32,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
        goto LABEL_51;
      }

      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_context_queue_block";
        _os_log_impl(&dword_181A5C000, v16, v32, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj(v14, v15);
      char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v42 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_context_queue_block";
        _os_log_impl( &dword_181A5C000,  v16,  v42,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }
            }

    if (v14) {
      free(v14);
    }
    __int16 v7 = 0LL;
    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v33 = "nw_framer_protocol_get_parameters";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v30 = 0;
  if (__nwlog_fault(v10, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_framer_protocol_get_parameters";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v30)
    {
      id v19 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      uint64_t v21 = os_log_type_enabled(v11, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v33 = "nw_framer_protocol_get_parameters";
          os_log_type_t v34 = 2082;
          uint64_t v35 = v19;
          _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        goto LABEL_53;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_framer_protocol_get_parameters";
        _os_log_impl(&dword_181A5C000, v11, v20, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_framer_protocol_get_parameters";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        free(v12);
        goto LABEL_63;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v13, v25, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v30 = v35;
      if (os_log_type_enabled(v13, v35))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl( &dword_181A5C000,  v13,  v30,  "%{public}s called with null access_block, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      if (v23) {
        goto LABEL_63;
      }
LABEL_64:
      __int16 v15 = 0LL;
LABEL_19:

LABEL_20:
      nw_connection_set_queue((nw_connection_t)v9, (dispatch_queue_t)v15);
      nw_connection_start((nw_connection_t)v9);
      nw_connection_cancel((nw_connection_t)v9);
    }

    __nwlog_obj();
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v57 = "nw_connection_group_copy_workloop";
    uint64_t v22 = (const char *)_os_log_send_and_compose_impl();

    uint64_t v23 = (char *)v22;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = v22;
      __nwlog_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_protocol_options_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "nw_connection_group_copy_workloop";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null context", buf, 0xCu);
      }

      goto LABEL_61;
    }

    if (!v54)
    {
      uint64_t v24 = v22;
      __nwlog_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "nw_connection_group_copy_workloop";
        _os_log_impl( &dword_181A5C000,  v25,  v39,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_61;
    }

    os_log_type_t v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v49 = type;
    uint64_t v35 = os_log_type_enabled(v34, type);
    if (v33)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v57 = "nw_connection_group_copy_workloop";
        char v58 = 2082;
        v59[0] = v33;
        _os_log_impl( &dword_181A5C000,  v34,  v49,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v33);
      if (!v23) {
        goto LABEL_64;
      }
LABEL_63:
      free(v23);
      goto LABEL_64;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v57 = "nw_connection_group_copy_workloop";
      _os_log_impl(&dword_181A5C000, v34, v49, "%{public}s called with null context, no backtrace", buf, 0xCu);
    }

    goto LABEL_73;
  }

  __nwlog_obj();
  os_log_type_t v41 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v57 = "nw_connection_group_prune_connections_locked";
  BOOL v42 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  id v54 = 0;
  if (__nwlog_fault(v42, &type, &v54))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "nw_connection_group_prune_connections_locked";
        _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v54)
    {
      BOOL v45 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      os_log_type_t v47 = os_log_type_enabled(v43, type);
      if (v45)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v57 = "nw_connection_group_prune_connections_locked";
          char v58 = 2082;
          v59[0] = v45;
          _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v45);
        goto LABEL_93;
      }

      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "nw_connection_group_prune_connections_locked";
        _os_log_impl(&dword_181A5C000, v43, v46, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v48 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v57 = "nw_connection_group_prune_connections_locked";
        _os_log_impl( &dword_181A5C000,  v43,  v48,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        free(backtrace_string);
        if (!v21) {
          goto LABEL_139;
        }
        goto LABEL_138;
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      uint64_t v67 = "nw_protocol_implementation_get_parameters";
      uint64_t v21 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v67 = "nw_protocol_implementation_get_parameters";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_136;
      }

      if (v65 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v67 = "nw_protocol_implementation_get_parameters";
          _os_log_impl( &dword_181A5C000,  v22,  v46,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_136;
      }

      os_log_type_t v31 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v32 = type[0];
      os_log_type_t v33 = os_log_type_enabled(v22, type[0]);
      if (!v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v67 = "nw_protocol_implementation_get_parameters";
          _os_log_impl(&dword_181A5C000, v22, v32, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_136;
      }

      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v67 = "nw_protocol_implementation_get_parameters";
        os_log_type_t v68 = 2082;
        v69 = v31;
        _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v31);
    }

        free(v18);
        goto LABEL_10;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_181A5C000, v19, v26, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v43 = "nw_protocol_request_outbound_data";
        _os_log_impl( &dword_181A5C000,  v19,  v33,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

  if (v17) {
    free(v17);
  }
LABEL_9:
  id v8 = *(void *)(a1 + 40);
  if (v8)
  {
    BOOL v9 = *(_OWORD **)(v8 + 48);
    goto LABEL_11;
  }

  __nwlog_obj();
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v52 = "__nw_protocol_get_input_handler";
  uint64_t v21 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v49 = 0;
  if (__nwlog_fault(v21, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v52 = "__nw_protocol_get_input_handler";
        _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v49)
    {
      os_log_type_t v34 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v35 = type;
      BOOL v36 = os_log_type_enabled(v22, type);
      if (v34)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v52 = "__nw_protocol_get_input_handler";
          nw_endpoint_t v53 = 2082;
          id v54 = v34;
          _os_log_impl( &dword_181A5C000,  v22,  v35,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v34);
        goto LABEL_67;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v52 = "__nw_protocol_get_input_handler";
        _os_log_impl(&dword_181A5C000, v22, v35, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v52 = "__nw_protocol_get_input_handler";
        _os_log_impl( &dword_181A5C000,  v22,  v38,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(v35);
    if (!v22) {
      return 0LL;
    }
    goto LABEL_94;
  }

  BOOL v9 = v8;
  objc_opt_class();
  os_log_type_t v10 = _os_object_alloc();
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    __int16 v51 = "nw_nexus_create_with_options";
    os_log_type_t v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v48 = 0;
    if (__nwlog_fault(v31, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        nw_endpoint_t v32 = (os_log_s *)gLogObj;
        os_log_type_t v33 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_nexus_create_with_options";
          os_log_type_t v34 = "%{public}s nw_nexus_obj_alloc failed";
LABEL_77:
          _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
        }
      }

      else if (v48)
      {
        os_log_type_t v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        nw_endpoint_t v32 = (os_log_s *)gLogObj;
        os_log_type_t v33 = type;
        BOOL v40 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v39)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v51 = "nw_nexus_create_with_options";
            uint64_t v52 = 2082;
            *(void *)nw_endpoint_t v53 = v39;
            _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s nw_nexus_obj_alloc failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v39);
          goto LABEL_78;
        }

        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_nexus_create_with_options";
          os_log_type_t v34 = "%{public}s nw_nexus_obj_alloc failed, no backtrace";
          goto LABEL_77;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        nw_endpoint_t v32 = (os_log_s *)gLogObj;
        os_log_type_t v33 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_nexus_create_with_options";
          os_log_type_t v34 = "%{public}s nw_nexus_obj_alloc failed, backtrace limit exceeded";
          goto LABEL_77;
        }
      }
    }

    if (!v27) {
      return 0LL;
    }
    BOOL v36 = (char *)v27;
LABEL_64:
    free(v36);
    return 0LL;
  }

  nw_protocol_http_client_bottom_teardown((uint64_t)a1->handle);
  uint64_t v21 = handle[2].output_handler_context;
  BOOL v20 = *(_BYTE **)handle[3].flow_id;
  uint64_t v22 = v20 - v21;
  if (v20 == v21)
  {
    nw_protocol_set_input_handler((uint64_t)handle, 0LL);
  }

  else
  {
    if ((v22 & 0x8000000000000000LL) != 0) {
      abort();
    }
    uint64_t v23 = operator new(v20 - v21);
    uint64_t v24 = v22 & 0xFFFFFFFFFFFFFFF0LL;
    memcpy(v23, v21, v22 & 0xFFFFFFFFFFFFFFF0LL);
    if ((v22 & 0xFFFFFFFFFFFFFFF0LL) != 0)
    {
      if ((BYTE6(handle[4].output_handler) & 4) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v25 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
          nw_endpoint_t v53 = 2082;
          id v54 = (nw_protocol *)((char *)handle + 208);
          uint64_t v55 = 2080;
          __int16 v56 = (uint64_t)" ";
          os_log_type_t v57 = 2048;
          char v58 = v22 >> 4;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sfirst input handler bailed, restarting %zu input protocols",  buf,  0x2Au);
        }
      }

      nw_protocol_options_t v26 = v23 + 2;
      do
      {
        if (*v26 != 2) {
          nw_protocol_notify(*((void **)v26 - 1), (uint64_t)handle, 22);
        }
        v26 += 4;
        v24 -= 16LL;
      }

      while (v24);
    }

    nw_protocol_set_input_handler((uint64_t)handle, 0LL);
    operator delete(v23);
  }

        goto LABEL_63;
      }

      if ((nw_connection_used_fallback_locked(v2) & 1) == 0)
      {
        __int16 v15 = nw_endpoint_handler_copy_current_path(v2->parent_endpoint_handler);
        char v16 = v15;
        if (v15
          && (id v17 = v15[14]) != 0
          && *(_DWORD *)(v17 + 8)
          && (v18 = v15, id v19 = v18[93], v18, v19 != v2->connected_fallback_generation))
        {
          else {
            BOOL v14 = 3;
          }
        }

        else
        {
          BOOL v14 = 0;
        }
      }

      else
      {
LABEL_21:
        BOOL v14 = 0;
      }
    }

    else
    {
      id v8 = 0LL;
      __int16 v7 = 0LL;
      BOOL v14 = 0;
    }

    alternate_path_uint64_t state = v2->alternate_path_state;
    if (alternate_path_state == v14) {
      goto LABEL_62;
    }
    v2->alternate_path_uint64_t state = v14;
    if (v14 == 3)
    {
      BOOL v25 = v2->parameters;
      if (!v25 || nw_path_parameters_get_logging_disabled(*((void *)v25 + 13))) {
        goto LABEL_52;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v22 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_INFO)) {
        goto LABEL_51;
      }
      nw_protocol_options_t v26 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&void buf[14] = v26;
      uint64_t v24 = "%{public}s [C%u] Alternate path recommended";
    }

    else if (v14 == 2)
    {
      id v27 = v2->parameters;
      if (!v27 || nw_path_parameters_get_logging_disabled(*((void *)v27 + 13))) {
        goto LABEL_52;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v22 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_INFO)) {
        goto LABEL_51;
      }
      __int16 v28 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&void buf[14] = v28;
      uint64_t v24 = "%{public}s [C%u] Alternate path potentially available";
    }

    else
    {
      uint64_t v21 = v2->parameters;
      if (!v21 || nw_path_parameters_get_logging_disabled(*((void *)v21 + 13))) {
        goto LABEL_52;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v22 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
LABEL_51:

LABEL_52:
        if (alternate_path_state != 1)
        {
LABEL_58:
          os_log_type_t v34 = v2;
          nw_context_assert_queue(v2->context);
          alternate_path_state_handler = v34->alternate_path_state_handler;
          if (alternate_path_state_handler && v34->state != 5)
          {
            BOOL v36 = _Block_copy(alternate_path_state_handler);
            client_qos_class = v34->client_qos_class;
            *(void *)buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = ___ZL59nw_connection_send_alternate_path_state_changed_on_nw_queueP24NWConcrete_nw_connection36nw_connection_alternate_path_state_t_block_invoke;
            nw_endpoint_t v50 = &unk_189BC87B8;
            __int16 v51 = v36;
            uint64_t v52 = v14;
            v38 = v36;
            nw_connection_async_client(v34, client_qos_class, buf);
          }

          goto LABEL_62;
        }

        os_log_type_t v13 = 0;
LABEL_54:
        BOOL v29 = v2;
        nw_context_assert_queue(v2->context);
        better_path_available_handler = v29->better_path_available_handler;
        if (better_path_available_handler && v29->state != 5)
        {
          os_log_type_t v31 = _Block_copy(better_path_available_handler);
          nw_endpoint_t v32 = v29->client_qos_class;
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL50nw_connection_send_better_path_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke;
          nw_endpoint_t v50 = &unk_189BC71E8;
          __int16 v51 = v31;
          LOBYTE(v52) = v13;
          os_log_type_t v33 = v31;
          nw_connection_async_client(v29, v32, buf);
        }

        goto LABEL_58;
      }

      uint64_t v23 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&void buf[14] = v23;
      uint64_t v24 = "%{public}s [C%u] Alternate path not available";
    }

    _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_INFO, v24, buf, 0x12u);
    goto LABEL_51;
  }

  __nwlog_obj();
  os_log_type_t v39 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
  BOOL v40 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v47 = 0;
  if (__nwlog_fault(v40, &type, &v47))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      BOOL v45 = os_log_type_enabled(v41, type);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v41,  v44,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_83;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v41,  v46,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      if (v28) {
        free(v28);
      }
      *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
      goto LABEL_65;
    }

    os_log_type_t v10 = (_BYTE *)(v7 + 527);
    if ((*(_DWORD *)(v7 + 527) & 0x9000) != 0x1000)
    {
LABEL_66:
      os_release(v5);
      return 1LL;
    }

    if (nw_protocol_metadata_is_http(v5))
    {
      BOOL v11 = nw_http_metadata_copy_response(v5);
      if (v11)
      {
        os_log_type_t v12 = v11;
        status_code = _nw_http_response_get_status_code();

        if ((status_code - 200) <= 0x63)
        {
          if ((*v10 & 2) != 0 && !uuid_is_null((const unsigned __int8 *)(v7 + 272)))
          {
            BOOL v14 = *(void **)(v7 + 456);
            if (v14) {
              nw_http_connection_metadata_set_cached_token(v14, 0LL, 0LL);
            }
            nw_path_report_error_to_agent(*(void **)(v7 + 336), (const unsigned __int8 *)(v7 + 272), 0);
          }

          __int16 v15 = *(void *)(v7 + 288);
          char v16 = mach_continuous_time();
          if (v16 <= 1) {
            id v17 = 1LL;
          }
          else {
            id v17 = v16;
          }
          BOOL v18 = nw_delta_nanos(v15, v17);
          id v19 = (v18 / 0xF4240);
          if (v18 > 0xF423FFFFFFFFFLL) {
            id v19 = 0xFFFFFFFFLL;
          }
          *(void *)(v7 + 296) = v19;
          if ((*(_BYTE *)(v7 + 529) & 1) != 0) {
            goto LABEL_55;
          }
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          BOOL v20 = gprivacy_proxyLogObj;
          if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
            goto LABEL_55;
          }
          *(_DWORD *)buf = 136446466;
          __int16 v56 = (const char *)(v7 + 531);
          os_log_type_t v57 = 2080;
          char v58 = " ";
          uint64_t v21 = "%{public}s%sReceived 200 OK for proxied message";
          uint64_t v22 = (os_log_s *)v20;
          uint64_t v23 = OS_LOG_TYPE_INFO;
          uint64_t v24 = 22;
          goto LABEL_51;
        }

        os_log_type_t v33 = *(_DWORD *)v10;
        if (!status_code)
        {
          if ((v33 & 0x10000) != 0) {
            goto LABEL_55;
          }
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          os_log_type_t v39 = gprivacy_proxyLogObj;
          if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_55;
          }
          *(_DWORD *)buf = 136446722;
          __int16 v56 = "nw_masque_handle_message_response";
          os_log_type_t v57 = 2082;
          char v58 = (const char *)(v7 + 531);
          os_log_type_t v59 = 2080;
          __int16 v60 = (uint64_t)" ";
          uint64_t v21 = "%{public}s %{public}s%sReceived no response code, ignoring";
          uint64_t v22 = (os_log_s *)v39;
          uint64_t v23 = OS_LOG_TYPE_DEBUG;
          uint64_t v24 = 32;
LABEL_51:
          _os_log_impl(&dword_181A5C000, v22, v23, v21, buf, v24);
LABEL_55:
          *(_DWORD *)v10 |= 0x8000u;
LABEL_56:
          os_release(v12);
          goto LABEL_66;
        }

        if ((v33 & 0x10000) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          os_log_type_t v34 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            __int16 v56 = (const char *)(v7 + 531);
            os_log_type_t v57 = 2080;
            char v58 = " ";
            os_log_type_t v59 = 1024;
            LODWORD(v60) = status_code;
            _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_ERROR,  "%{public}s%sReceived response code %u for proxied message",  buf,  0x1Cu);
          }
        }

        if (status_code == 401)
        {
          if (!uuid_is_null((const unsigned __int8 *)(v7 + 272)))
          {
            uint64_t v35 = *(void **)(v7 + 456);
            if (v35) {
              nw_http_connection_metadata_mark_cached_token_failed(v35);
            }
            nw_path_report_error_to_agent(*(void **)(v7 + 336), (const unsigned __int8 *)(v7 + 272), 80);
            nw_masque_mark_failed_with_error(v7, 80);
            goto LABEL_56;
          }
        }

        else if ((status_code - 400) > 0x63)
        {
          BOOL v40 = v7;
          else {
            os_log_type_t v41 = 1105;
          }
          goto LABEL_54;
        }

        BOOL v40 = v7;
        os_log_type_t v41 = 1104;
LABEL_54:
        nw_masque_report_error_to_proxy_agent(v40, v41);
        goto LABEL_55;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v56 = "nw_masque_handle_message_response";
      BOOL v45 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      nw_endpoint_t v53 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v46 = (os_log_s *)__nwlog_obj();
        os_log_type_t v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_99;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_masque_handle_message_response";
        os_log_type_t v48 = "%{public}s called with null response";
        goto LABEL_98;
      }

      if (!v53)
      {
        os_log_type_t v46 = (os_log_s *)__nwlog_obj();
        os_log_type_t v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_99;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_masque_handle_message_response";
        os_log_type_t v48 = "%{public}s called with null response, backtrace limit exceeded";
        goto LABEL_98;
      }

      __int16 v51 = (char *)__nw_create_backtrace_string();
      os_log_type_t v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = type;
      uint64_t v52 = os_log_type_enabled(v46, type);
      if (v51)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v56 = "nw_masque_handle_message_response";
          os_log_type_t v57 = 2082;
          char v58 = v51;
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s called with null response, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v51);
        if (!v45) {
          goto LABEL_66;
        }
        goto LABEL_100;
      }

      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_masque_handle_message_response";
        os_log_type_t v48 = "%{public}s called with null response, no backtrace";
LABEL_98:
        _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v56 = "nw_masque_handle_message_response";
      BOOL v45 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      nw_endpoint_t v53 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v46 = (os_log_s *)__nwlog_obj();
        os_log_type_t v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_99;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_masque_handle_message_response";
        os_log_type_t v48 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
        goto LABEL_98;
      }

      if (!v53)
      {
        os_log_type_t v46 = (os_log_s *)__nwlog_obj();
        os_log_type_t v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_99;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_masque_handle_message_response";
        os_log_type_t v48 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_98;
      }

      os_log_type_t v49 = (char *)__nw_create_backtrace_string();
      os_log_type_t v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = type;
      nw_endpoint_t v50 = os_log_type_enabled(v46, type);
      if (!v49)
      {
        if (!v50) {
          goto LABEL_99;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_masque_handle_message_response";
        os_log_type_t v48 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
        goto LABEL_98;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v56 = "nw_masque_handle_message_response";
        os_log_type_t v57 = 2082;
        char v58 = v49;
        _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v49);
    }

    if (v18)
    {
      BOOL v42 = (char *)v18;
LABEL_69:
      free(v42);
      return;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v46 = "nw_masque_mark_failed_with_error";
  BOOL v25 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v43 = 0;
  if (__nwlog_fault(v25, &type, &v43))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_protocol_options_t v26 = (os_log_s *)__nwlog_obj();
      id v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v46 = "nw_masque_mark_failed_with_error";
      __int16 v28 = "%{public}s called with null masque";
LABEL_66:
      _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
      goto LABEL_67;
    }

    if (!v43)
    {
      nw_protocol_options_t v26 = (os_log_s *)__nwlog_obj();
      id v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v46 = "nw_masque_mark_failed_with_error";
      __int16 v28 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_66;
    }

    os_log_type_t v34 = (char *)__nw_create_backtrace_string();
    nw_protocol_options_t v26 = (os_log_s *)__nwlog_obj();
    id v27 = type;
    uint64_t v35 = os_log_type_enabled(v26, type);
    if (!v34)
    {
      if (!v35) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v46 = "nw_masque_mark_failed_with_error";
      __int16 v28 = "%{public}s called with null masque, no backtrace";
      goto LABEL_66;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v46 = "nw_masque_mark_failed_with_error";
      os_log_type_t v47 = 2082;
      os_log_type_t v48 = v34;
      _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v34);
  }

  if (v13) {
    free(v13);
  }
  os_log_type_t v10 = 0LL;
LABEL_9:

  return v10;
}

    free(backtrace_string);
    goto LABEL_74;
  }

  char v30 = (os_log_s *)__nwlog_obj();
  os_log_type_t v31 = type;
  if (os_log_type_enabled(v30, type))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
    nw_endpoint_t v32 = "%{public}s called with null protocol";
LABEL_73:
    _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0xCu);
  }

  *(_BYTE *)(v5 + 186) = self->_longOutstandingQueries;
  *(_WORD *)(v5 + 196) |= 0x100u;
  has = (__int16)self->_has;
  if ((has & 0x2000) == 0)
  {
LABEL_11:
    if ((has & 0x4000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_64;
  }

        if (v20) {
          free(v20);
        }
        return 0LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v68 = "nw_http2_transport_remove_input_handler";
      v69 = 2082;
      __int16 v70 = (nw_protocol *)(handle + 205);
      BOOL v11 = "%{public}s %{public}s not closing already closed stream";
      os_log_type_t v12 = (os_log_s *)v14;
      os_log_type_t v13 = OS_LOG_TYPE_DEFAULT;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v68 = "nw_http2_transport_remove_input_handler";
      v69 = 2082;
      __int16 v70 = (nw_protocol *)(handle + 205);
      BOOL v11 = "%{public}s %{public}s stream not found as extra";
      os_log_type_t v12 = (os_log_s *)v10;
      os_log_type_t v13 = OS_LOG_TYPE_ERROR;
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v11, buf, 0x16u);
    goto LABEL_21;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v7 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    os_log_type_t v68 = "nw_http2_transport_remove_input_handler";
    v69 = 2082;
    __int16 v70 = (nw_protocol *)(handle + 205);
    BOOL v71 = 2048;
    *(void *)id v72 = a2;
    _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s output handler context doesn't exist on protocol %p",  buf,  0x20u);
  }

        free(v24);
        goto LABEL_63;
      }

      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v40 = "nw_proxy_config_create";
        _os_log_impl(&dword_181A5C000, v25, v33, "%{public}s called with null proxy_options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v36 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v40 = "nw_proxy_config_create";
        _os_log_impl( &dword_181A5C000,  v25,  v36,  "%{public}s called with null proxy_options, backtrace limit exceeded",  buf,  0xCu);
      }
    }

        os_log_type_t v12 = 0LL;
LABEL_63:

        goto LABEL_124;
      }

      uint64_t v21 = nw_protocol_stack_copy_transport_protocol((nw_protocol_stack_t)v16);
      uint64_t v22 = v21;
      if (v21)
      {
        uint64_t v23 = v21;
        uint64_t v24 = v23[1];
        options = (nw_protocol_options *)v23;

        if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
        }
        BOOL v25 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
        is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v24, (uint64_t)v25);

        if (is_equal_unsafe)
        {
          id v27 = nw_protocol_copy_quic_stream_definition();

          uint64_t v24 = v27;
        }

        identifier = nw_protocol_definition_get_identifier(v24);
        buf[0] = 0;
        nw_proxy_config_should_proxy_transport_at_level((NWConcrete_nw_proxy_config *)v7, identifier, buf);
        if (buf[0]) {
          BOOL v29 = "proxy-wildcard";
        }
        else {
          BOOL v29 = identifier;
        }
        char v30 = nw_dictionary_copy_value(*((void *)v7 + 1), (uint64_t)v29);
        if ((*((_BYTE *)v7 + 172) & 2) != 0
          && nw_protocol_options_is_quic(options)
          && (_os_feature_enabled_impl() & 1) == 0)
        {
        }

        else
        {

          if (v30) {
            goto LABEL_27;
          }
        }

        goto LABEL_62;
      }

        nw_protocol_remove_input_handler(*(void *)(v2 + 32), v2);
        nw_protocol_set_output_handler(v2, 0LL);
        if ((*(_BYTE *)(v2 + 158) & 1) == 0)
        {
          if (gLogDatapath)
          {
            id v102 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
            {
              os_log_type_t v103 = *(void *)(v2 + 488);
              BOOL v104 = *(_DWORD *)(*(void *)(v2 + 480) + 372LL);
              id v105 = *(_DWORD *)(v2 + 860);
              if (v103) {
                LODWORD(v103) = *(_DWORD *)(v103 + 424);
              }
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_destroy";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v2 + 74;
              *(_WORD *)&buf[22] = 2080;
              __int16 v140 = (uint64_t)" ";
              *(_WORD *)int v141 = 1024;
              *(_DWORD *)&v141[2] = v104;
              *(_WORD *)&v141[6] = 1024;
              *(_DWORD *)&v141[8] = v105;
              *(_WORD *)&v141[12] = 1024;
              *(_DWORD *)&v141[14] = v103;
              *(_WORD *)&v141[18] = 2048;
              *(void *)&v141[20] = v2;
              _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> destroying %p",  buf,  0x3Cu);
            }
          }
        }

        os_log_type_t v39 = *(_BYTE *)(v2 + 760);
        if ((v39 & 1) != 0)
        {
          BOOL v40 = *(void **)(v2 + 752);
          if (v40)
          {
            os_release(v40);
            os_log_type_t v39 = *(_BYTE *)(v2 + 760);
          }
        }

        *(void *)(v2 + 752) = 0LL;
        *(_BYTE *)(v2 + 760) = v39 | 1;
        os_log_type_t v41 = *(_BYTE *)(v2 + 744);
        if ((v41 & 1) != 0)
        {
          BOOL v42 = *(void **)(v2 + 736);
          if (v42)
          {
            os_release(v42);
            os_log_type_t v41 = *(_BYTE *)(v2 + 744);
          }
        }

        *(void *)(v2 + 736) = 0LL;
        *(_BYTE *)(v2 + 744) = v41 | 1;
        os_log_type_t v43 = *(void *)(v2 + 488);
        if (!v43 || *(void *)(v43 + 256) != v2)
        {
LABEL_83:
          *(void *)(v2 + 48_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
          if ((*(_BYTE *)(v2 + 158) & 1) == 0)
          {
            if (!gLogDatapath) {
              goto LABEL_85;
            }
            os_log_type_t v106 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
            {
              unint64_t v107 = *(void *)(v2 + 488);
              unint64_t v108 = *(_DWORD *)(*(void *)(v2 + 480) + 372LL);
              os_log_type_t v109 = *(_DWORD *)(v2 + 860);
              if (v107) {
                LODWORD(v107) = *(_DWORD *)(v107 + 424);
              }
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_destroy";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v2 + 74;
              *(_WORD *)&buf[22] = 2080;
              __int16 v140 = (uint64_t)" ";
              *(_WORD *)int v141 = 1024;
              *(_DWORD *)&v141[2] = v108;
              *(_WORD *)&v141[6] = 1024;
              *(_DWORD *)&v141[8] = v109;
              *(_WORD *)&v141[12] = 1024;
              *(_DWORD *)&v141[14] = v107;
              _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> finalizing frame arrays",  buf,  0x32u);
            }
          }

          if (gLogDatapath)
          {
            BOOL v110 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
            {
              __int16 v144 = 136446210;
              v145 = "nw_protocol_finalize_master_frame_array";
              _os_log_impl(&dword_181A5C000, v110, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v144, 0xCu);
            }
          }

    if ((v39 & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v48 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v49 = *(void *)(a1 + 488);
        nw_endpoint_t v50 = *(_DWORD *)(*(void *)(a1 + 480) + 372LL);
        __int16 v51 = *(_DWORD *)(a1 + 860);
        if (v49) {
          LODWORD(v49) = *(_DWORD *)(v49 + 424);
        }
        *(_DWORD *)buf = 136447490;
        os_log_type_t v65 = "nw_http1_connection_execute_parser";
        char v66 = 2082;
        uint64_t v67 = (char *)(a1 + 74);
        os_log_type_t v68 = 2080;
        v69 = " ";
        __int16 v70 = 1024;
        BOOL v71 = v50;
        id v72 = 1024;
        BOOL v73 = v51;
        __int16 v74 = 1024;
        os_log_type_t v75 = v49;
        _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> got informational response",  buf,  0x32u);
      }
    }

    *v13 |= 0x10u;
    return 1LL;
  }

  if ((v36 & 4) != 0) {
    goto LABEL_68;
  }
  if ((*(_WORD *)(*(void *)(a1 + 488) + 428LL) & 1) == 0)
  {
    os_log_type_t v39 = *(_BYTE *)(a1 + 158);
    goto LABEL_62;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v65 = "nw_http1_connection_execute_parser";
  uint64_t v52 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v62 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
    id v54 = type;
    if (os_log_type_enabled(v53, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v65 = "nw_http1_connection_execute_parser";
      uint64_t v55 = "%{public}s paused in the middle of parsing the body";
LABEL_86:
      _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
      goto LABEL_87;
    }

    goto LABEL_87;
  }

  if (v62)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
    id v54 = type;
    os_log_type_t v57 = os_log_type_enabled(v53, type);
    if (!backtrace_string)
    {
      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v65 = "nw_http1_connection_execute_parser";
        uint64_t v55 = "%{public}s paused in the middle of parsing the body, no backtrace";
        goto LABEL_86;
      }

      goto LABEL_87;
    }

    if (!v57)
    {
LABEL_81:
      free(backtrace_string);
      goto LABEL_87;
    }

    *(_DWORD *)buf = 136446466;
    os_log_type_t v65 = "nw_http1_connection_execute_parser";
    char v66 = 2082;
    uint64_t v67 = backtrace_string;
    char v58 = "%{public}s paused in the middle of parsing the body, dumping backtrace:%{public}s";
LABEL_80:
    _os_log_impl(&dword_181A5C000, v53, v54, v58, buf, 0x16u);
    goto LABEL_81;
  }

  nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
  id v54 = type;
  if (os_log_type_enabled(v53, type))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v65 = "nw_http1_connection_execute_parser";
    uint64_t v55 = "%{public}s paused in the middle of parsing the body, backtrace limit exceeded";
    goto LABEL_86;
  }

    posix_error = 0LL;
    goto LABEL_63;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v25 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  os_log_type_t v49 = "nw_service_connector_trigger_request_complete_block_inner";
  nw_endpoint_t v50 = 2114;
  *(void *)__int16 v51 = v9;
  *(_WORD *)&v51[8] = 2114;
  *(void *)&v51[10] = v10;
  BOOL v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v46 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v15 = (os_log_s *)(id)gLogObj;
    nw_protocol_options_t v26 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v49 = "nw_service_connector_trigger_request_complete_block_inner";
      nw_endpoint_t v50 = 2114;
      *(void *)__int16 v51 = v9;
      *(_WORD *)&v51[8] = 2114;
      *(void *)&v51[10] = v10;
      _os_log_impl( &dword_181A5C000,  v15,  v26,  "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@",  buf,  0x20u);
    }
  }

  else if (v46)
  {
    __int16 v28 = __nw_create_backtrace_string();
    if (v28)
    {
      BOOL v29 = (char *)v28;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v30 = (os_log_s *)(id)gLogObj;
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v49 = "nw_service_connector_trigger_request_complete_block_inner";
        nw_endpoint_t v50 = 2114;
        *(void *)__int16 v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        uint64_t v52 = 2082;
        nw_endpoint_t v53 = v29;
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v29);
      if (v14) {
        goto LABEL_53;
      }
      goto LABEL_64;
    }

    __nwlog_obj();
    __int16 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v36 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v49 = "nw_service_connector_trigger_request_complete_block_inner";
      nw_endpoint_t v50 = 2114;
      *(void *)__int16 v51 = v9;
      *(_WORD *)&v51[8] = 2114;
      *(void *)&v51[10] = v10;
      _os_log_impl( &dword_181A5C000,  v15,  v36,  "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@, no backtrace",  buf,  0x20u);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v15 = (os_log_s *)(id)gLogObj;
    uint64_t v35 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v49 = "nw_service_connector_trigger_request_complete_block_inner";
      nw_endpoint_t v50 = 2114;
      *(void *)__int16 v51 = v9;
      *(_WORD *)&v51[8] = 2114;
      *(void *)&v51[10] = v10;
      _os_log_impl( &dword_181A5C000,  v15,  v35,  "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@, backtrace limit exceeded",  buf,  0x20u);
    }
  }

    if (v28) {
      free(v28);
    }
    goto LABEL_26;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v16 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    id v17 = *(unsigned __int8 *)(a1 + 72);
    BOOL v42 = "nwsc_send_feedback_block_invoke";
    *(_DWORD *)buf = 136446722;
    if (v17) {
      BOOL v18 = "accept";
    }
    else {
      BOOL v18 = "deny";
    }
    os_log_type_t v43 = 2082;
    os_log_type_t v44 = v18;
    BOOL v45 = 1024;
    *(_DWORD *)os_log_type_t v46 = v10;
    _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to send %{public}s feedback %{darwin.errno}d",  buf,  0x1Cu);
  }

LABEL_26:
  if (*(_UNKNOWN **)(a1 + 48) == &__block_literal_global_3_41839) {
    nwsc_drain_and_cancel_connection( *(NWConcrete_nw_service_connector **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40),  v4 == 0LL);
  }
  uint64_t v24 = *(void *)(a1 + 56);
  if (v24) {
    (*(void (**)(uint64_t, uint64_t))(v24 + 16))(v24, v10);
  }
LABEL_30:
}

      os_log_type_t v31 = 3LL;
      goto LABEL_63;
    }

    break;
  }

    goto LABEL_63;
  }

  if (!name)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v30 = "nw_ws_options_add_additional_header";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null name", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (!v27)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A5C000, v9, v24, "%{public}s called with null name, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_62;
    }

    BOOL v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        char v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A5C000, v9, v19, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      char v30 = "nw_ws_options_add_additional_header";
      os_log_type_t v31 = 2082;
      nw_endpoint_t v32 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null name, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_43;
  }

  if (!value)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v30 = "nw_ws_options_add_additional_header";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null value", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (!v27)
    {
      __nwlog_obj();
      BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v30 = "nw_ws_options_add_additional_header";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null value, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_62;
    }

    BOOL v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v21 = type;
    uint64_t v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        char v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }

      goto LABEL_62;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      char v30 = "nw_ws_options_add_additional_header";
      os_log_type_t v31 = 2082;
      nw_endpoint_t v32 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null value, dumping backtrace:%{public}s",  buf,  0x16u);
    }

        char v16 = v43 + 1;
        if (v19 == 44)
        {
          check_certs_and_store_entry(v74, v12, v73);
          id v17 = objc_alloc_init(MEMORY[0x189601F50]);

          BOOL v14 = 2;
          os_log_type_t v12 = v17;
        }

        else
        {
          BOOL v14 = 2;
        }

        os_log_type_t v10 = v75;
LABEL_9:
        os_log_type_t v33 = v13++ == v10;
        if (v33) {
          goto LABEL_69;
        }
      }

      os_log_type_t v49 = atoi(v36);
      if (v49 >= 604800) {
        nw_endpoint_t v50 = 604800;
      }
      else {
        nw_endpoint_t v50 = v49;
      }
      [MEMORY[0x189603F50] dateWithTimeIntervalSinceNow:(double)v50];
      os_log_type_t v44 = (id)objc_claimAutoreleasedReturnValue();
      [v12 setExpirationDate:v44];
      os_log_type_t v43 = &a4[v13];
LABEL_61:

      goto LABEL_62;
    }

      free(v16);
      goto LABEL_63;
    }

    __nwlog_obj();
    __int16 v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
    char v16 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null inbox", buf, 0xCu);
      }
    }

    else if (v43)
    {
      uint64_t v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = type[0];
      nw_protocol_options_t v26 = os_log_type_enabled(v17, type[0]);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v24;
          _os_log_impl( &dword_181A5C000,  v17,  v25,  "%{public}s called with null inbox, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v24);
        goto LABEL_61;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl(&dword_181A5C000, v17, v25, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
        _os_log_impl( &dword_181A5C000,  v17,  v31,  "%{public}s called with null inbox, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_26;
  }

  url_scheme = (const char *)nw_endpoint_get_url_scheme(v3);
  __int16 v6 = url_scheme;
  if (!url_scheme || strcasecmp(url_scheme, "https"))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&void buf[14] = v6;
    id v8 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (__nwlog_fault(v8, type, out))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&void buf[14] = v6;
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s Invalid URL scheme: %s", buf, 0x16u);
        }
      }

      else if (out[0])
      {
        BOOL v11 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type[0];
        os_log_type_t v13 = os_log_type_enabled(v9, type[0]);
        if (v11)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&void buf[14] = v6;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&_BYTE buf[24] = v11;
            _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s Invalid URL scheme: %s, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v11);
          if (!v8) {
            goto LABEL_28;
          }
          goto LABEL_27;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&void buf[14] = v6;
          _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s Invalid URL scheme: %s, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&void buf[14] = v6;
          _os_log_impl( &dword_181A5C000,  v9,  v22,  "%{public}s Invalid URL scheme: %s, backtrace limit exceeded",  buf,  0x16u);
        }
      }
    }

    goto LABEL_26;
  }

  BOOL v14 = xpc_dictionary_create(0LL, 0LL, 0LL);
  *(void *)buf = v14;
  buf[8] = -1;
  __int16 v15 = nw_resolver_config_create_with_dictionary(v14);
  if (v14) {

  }
  *(void *)os_log_type_t type = v15;
  v38 = -1;
  memset(out, 0, sizeof(out));
  uuid_generate_random(out);
  nw_resolver_config_set_identifier(v15, out);
  memset(buf, 0, 37);
  uuid_unparse(out, (char *)buf);
  m_obj = v15->dictionary.m_obj;
  id v17 = v15;
  xpc_dictionary_set_string(m_obj, "Identifier", (const char *)buf);

  nw_resolver_config_set_class(v17, 3);
  nw_resolver_config_set_protocol(v17, 2);
  BOOL v18 = v17;
  id v19 = v3;
  BOOL v20 = -[nw_endpoint hostname](v19, "hostname");

  nw_resolver_config_set_provider_name(v18, v20);
  url_path = nw_endpoint_get_url_path(v19);
  if (url_path) {
    nw_resolver_config_set_provider_path(v18, url_path);
  }
LABEL_29:

  return (nw_resolver_config_t)v18;
}

  return 1LL;
}

                  uint64_t v35 = sendmsg(*(_DWORD *)(*(void *)(a1 + 40) + 172LL), &v138, 0);
                  if ((v35 & 0x8000000000000000LL) == 0)
                  {
                    BOOL v36 = *(void *)(a1 + 40);
                    if (((*(unsigned __int16 *)(v36 + 301) | (*(unsigned __int8 *)(v36 + 303) << 16)) & 0x40000) != 0)
                    {
                      nw_socket_internal_error(v36, 0LL);
                      os_log_type_t v37 = *(void *)(a1 + 40);
                      v38 = *(unsigned __int16 *)(v37 + 301);
                      os_log_type_t v39 = (v38 | (*(unsigned __int8 *)(v37 + 303) << 16)) & 0xFFFBFFFF;
                      *(_WORD *)(v37 + 301) = v38;
                      *(_BYTE *)(v37 + 303) = BYTE2(v39);
                    }
                  }

                  if (v15) {
                    free(v15);
                  }
                  if ((v35 & 0x8000000000000000LL) == 0)
                  {
                    BOOL v40 = *(void *)(a1 + 40);
                    os_log_type_t v41 = *(_WORD *)(v40 + 301);
                    if (__size[0] > v35)
                    {
                      if ((*(_WORD *)(v40 + 301) & 0x100) != 0)
                      {
                        v143 = 0uLL;
                        if (v40) {
                          os_log_type_t v49 = (_OWORD *)(v40 - 96);
                        }
                        else {
                          os_log_type_t v49 = 0LL;
                        }
                        nw_protocol_get_flow_id(v49, &v143);
                        nw_endpoint_t v50 = *(void *)(a1 + 40);
                        if (!v50 || (*(_WORD *)(v50 + 301) & 0x80) == 0)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          __int16 v51 = (os_log_s *)gconnectionLogObj;
                          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                          {
                            uint64_t v52 = *(void *)(a1 + 40);
                            nw_endpoint_t v53 = (const char *)(v52 + 308);
                            if (!v52) {
                              nw_endpoint_t v53 = "";
                            }
                            id v54 = *(void *)(v52 + 8);
                            uint64_t v55 = v35 - 1;
                            if (!v35) {
                              uint64_t v55 = 0LL;
                            }
                            *(_DWORD *)applier = 136447490;
                            *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                            *(_WORD *)&applier[12] = 2082;
                            *(void *)&applier[14] = v53;
                            *(_WORD *)&applier[22] = 1024;
                            *(_DWORD *)&applier[24] = v35;
                            *(_WORD *)&applier[28] = 1024;
                            *(_DWORD *)&applier[30] = __size[0];
                            *(_WORD *)&applier[34] = 2048;
                            *(void *)&applier[36] = v54;
                            *(_WORD *)&applier[44] = 2048;
                            *(void *)&applier[46] = v54 + v55;
                            _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Wrote %u/%u bytes, waiting for writable event (overall bytes %llu -> %llu)",  applier,  0x36u);
                          }
                        }

                        pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
                        __int16 v56 = (os_log_s *)gMpklLogObj;
                        if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
                        {
                          os_log_type_t v57 = *(void *)(a1 + 40);
                          char v58 = *(void *)(v57 + 8);
                          os_log_type_t v59 = v35 - 1;
                          if (!v35) {
                            os_log_type_t v59 = 0LL;
                          }
                          __int16 v60 = *(unsigned __int8 *)(v57 + 305);
                          *(_DWORD *)applier = 67110658;
                          *(_DWORD *)&void applier[4] = 150;
                          *(_WORD *)&applier[8] = 1024;
                          *(_DWORD *)&applier[10] = 100;
                          *(_WORD *)&applier[14] = 1042;
                          *(_DWORD *)&applier[16] = 16;
                          *(_WORD *)&applier[20] = 2098;
                          *(void *)&applier[22] = &v143;
                          *(_WORD *)&applier[30] = 2048;
                          *(void *)&applier[32] = v58;
                          *(_WORD *)&applier[40] = 2048;
                          *(void *)&applier[42] = v58 + v59;
                          *(_WORD *)&applier[50] = 1024;
                          *(_DWORD *)&applier[52] = v60;
                          _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEFAULT,  "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: % llu, logSeqn: %hhu}",  applier,  0x38u);
                        }

                        BOOL v40 = *(void *)(a1 + 40);
                        ++*(_BYTE *)(v40 + 305);
                      }

                      else if ((v41 & 0x80) == 0 && gLogDatapath)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        BOOL v42 = (os_log_s *)gconnectionLogObj;
                        os_log_type_t v43 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
                        BOOL v40 = *(void *)(a1 + 40);
                        if (v43)
                        {
                          os_log_type_t v44 = (const char *)(v40 + 308);
                          *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                          *(_DWORD *)applier = 136446978;
                          if (!v40) {
                            os_log_type_t v44 = "";
                          }
                          *(_WORD *)&applier[12] = 2082;
                          *(void *)&applier[14] = v44;
                          *(_WORD *)&applier[22] = 1024;
                          *(_DWORD *)&applier[24] = v35;
                          *(_WORD *)&applier[28] = 1024;
                          *(_DWORD *)&applier[30] = __size[0];
                          _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Wrote %u/%u bytes, waiting for writable event",  applier,  0x22u);
                          BOOL v40 = *(void *)(a1 + 40);
                        }
                      }

                      *(void *)(v40 + 8) += v35;
                      if (*(_DWORD *)(v40 + 176) == 1) {
                        ++*(void *)(v40 + 24);
                      }
                      nw_frame_claim(a2, v34, v35, 0);
                      *(_BYTE *)(*(void *)(a1 + 40) + 303LL) |= 0x20u;
                      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = __size[0] - v35;
                      return 0LL;
                    }

                    if ((*(_WORD *)(v40 + 301) & 0x100) != 0)
                    {
                      v143 = 0uLL;
                      if (v40) {
                        id v61 = (_OWORD *)(v40 - 96);
                      }
                      else {
                        id v61 = 0LL;
                      }
                      nw_protocol_get_flow_id(v61, &v143);
                      __int16 v62 = *(void *)(a1 + 40);
                      if (!v62 || (*(_WORD *)(v62 + 301) & 0x80) == 0)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        id v63 = (os_log_s *)gconnectionLogObj;
                        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v64 = *(void *)(a1 + 40);
                          os_log_type_t v65 = (const char *)(v64 + 308);
                          if (!v64) {
                            os_log_type_t v65 = "";
                          }
                          char v66 = *(void *)(v64 + 8);
                          uint64_t v67 = v35 - 1;
                          if (!v35) {
                            uint64_t v67 = 0LL;
                          }
                          *(_DWORD *)applier = 136447234;
                          *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                          *(_WORD *)&applier[12] = 2082;
                          *(void *)&applier[14] = v65;
                          *(_WORD *)&applier[22] = 1024;
                          *(_DWORD *)&applier[24] = __size[0];
                          *(_WORD *)&applier[28] = 2048;
                          *(void *)&applier[30] = v66;
                          *(_WORD *)&applier[38] = 2048;
                          *(void *)&applier[40] = v66 + v67;
                          _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Wrote %u bytes (overall bytes %llu -> %llu)",  applier,  0x30u);
                        }
                      }

                      pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
                      os_log_type_t v68 = (os_log_s *)gMpklLogObj;
                      if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
                      {
                        v69 = *(void *)(a1 + 40);
                        __int16 v70 = *(void *)(v69 + 8);
                        BOOL v71 = v35 - 1;
                        if (!v35) {
                          BOOL v71 = 0LL;
                        }
                        id v72 = *(unsigned __int8 *)(v69 + 305);
                        *(_DWORD *)applier = 67110658;
                        *(_DWORD *)&void applier[4] = 150;
                        *(_WORD *)&applier[8] = 1024;
                        *(_DWORD *)&applier[10] = 100;
                        *(_WORD *)&applier[14] = 1042;
                        *(_DWORD *)&applier[16] = 16;
                        *(_WORD *)&applier[20] = 2098;
                        *(void *)&applier[22] = &v143;
                        *(_WORD *)&applier[30] = 2048;
                        *(void *)&applier[32] = v70;
                        *(_WORD *)&applier[40] = 2048;
                        *(void *)&applier[42] = v70 + v71;
                        *(_WORD *)&applier[50] = 1024;
                        *(_DWORD *)&applier[52] = v72;
                        _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_DEFAULT,  "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %ll u, logSeqn: %hhu}",  applier,  0x38u);
                      }

                      BOOL v40 = *(void *)(a1 + 40);
                      ++*(_BYTE *)(v40 + 305);
                    }

                    else if ((v41 & 0x80) == 0 && gLogDatapath)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      os_log_type_t v46 = (os_log_s *)gconnectionLogObj;
                      os_log_type_t v47 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
                      BOOL v40 = *(void *)(a1 + 40);
                      if (v47)
                      {
                        os_log_type_t v48 = (const char *)(v40 + 308);
                        *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                        *(_DWORD *)applier = 136446722;
                        if (!v40) {
                          os_log_type_t v48 = "";
                        }
                        *(_WORD *)&applier[12] = 2082;
                        *(void *)&applier[14] = v48;
                        *(_WORD *)&applier[22] = 1024;
                        *(_DWORD *)&applier[24] = __size[0];
                        _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Wrote %u bytes",  applier,  0x1Cu);
                        BOOL v40 = *(void *)(a1 + 40);
                      }
                    }

                    *(void *)(v40 + 8) += v35;
                    if (*(_DWORD *)(v40 + 176) == 1) {
                      ++*(void *)(v40 + 24);
                    }
                    if (((*(unsigned __int16 *)(v40 + 301) | (*(unsigned __int8 *)(v40 + 303) << 16)) & 0x200000) != 0)
                    {
                      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
                      nw_socket_set_send_low_water_mark(v40, 1u);
                      BOOL v73 = *(void *)(a1 + 40);
                      __int16 v74 = *(unsigned __int16 *)(v73 + 301);
                      os_log_type_t v75 = (v74 | (*(unsigned __int8 *)(v73 + 303) << 16)) & 0xFFDFFFFF;
                      *(_WORD *)(v73 + 301) = v74;
                      *(_BYTE *)(v73 + 303) = BYTE2(v75);
                    }

                    if (_nw_signposts_once != -1) {
                      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
                    }
                    if (_nw_signposts_enabled && kdebug_is_enabled())
                    {
                      kdebug_trace();
                      if (v4) {
                        goto LABEL_139;
                      }
                    }

                    else if (v4)
                    {
                      goto LABEL_139;
                    }

                    if (buffer) {
                      free(buffer);
                    }
                    goto LABEL_193;
                  }

                  BOOL v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                  if ((_DWORD)v45 == 32)
                  {
                    id v84 = *(void *)(a1 + 40);
                    if (v84 && (*(_WORD *)(v84 + 301) & 0x80) != 0) {
                      goto LABEL_162;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    BOOL v85 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
                      goto LABEL_162;
                    }
                    uint64_t v86 = *(void *)(a1 + 40);
                    BOOL v87 = (const char *)(v86 + 308);
                    if (!v86) {
                      BOOL v87 = "";
                    }
                    nw_endpoint_t v88 = *(_DWORD *)(v86 + 172);
                    *(_DWORD *)applier = 136446978;
                    *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2082;
                    *(void *)&applier[14] = v87;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = v88;
                    *(_WORD *)&applier[28] = 1024;
                    *(_DWORD *)&applier[30] = __size[0];
                    os_log_type_t v89 = "%{public}s %{public}s sendmsg(fd %d, %u bytes): socket has been closed";
                    os_log_type_t v90 = (os_log_s *)v85;
                    os_log_type_t v91 = OS_LOG_TYPE_INFO;
                    BOOL v92 = 34;
                    goto LABEL_161;
                  }

                  if ((_DWORD)v45 != 35)
                  {
                    if ((_DWORD)v45 == 55)
                    {
                      nw_socket_internal_link_state(*(void *)(a1 + 40), 1);
                      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
                      return 0LL;
                    }

                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    id v93 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                    {
LABEL_162:
                      *(_BYTE *)(*(void *)(a1 + 40) + 303LL) |= 4u;
                      nw_socket_internal_error(*(void *)(a1 + 40), v45);
                      return 0LL;
                    }

                    os_log_type_t v94 = *(void *)(a1 + 40);
                    os_log_type_t v95 = v94 + 308;
                    LODWORD(v94) = *(_DWORD *)(v94 + 172);
                    *(_DWORD *)applier = 136447234;
                    *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2080;
                    *(void *)&applier[14] = v95;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = v94;
                    *(_WORD *)&applier[28] = 1024;
                    *(_DWORD *)&applier[30] = __size[0];
                    *(_WORD *)&applier[34] = 1024;
                    *(_DWORD *)&applier[36] = v45;
                    os_log_type_t v89 = "%{public}s %s sendmsg(fd %d, %u bytes) %{darwin.errno}d";
                    os_log_type_t v90 = (os_log_s *)v93;
                    os_log_type_t v91 = OS_LOG_TYPE_ERROR;
                    BOOL v92 = 40;
LABEL_161:
                    _os_log_impl(&dword_181A5C000, v90, v91, v89, applier, v92);
                    goto LABEL_162;
                  }

                  __int16 v76 = *(_WORD *)(*(void *)(a1 + 40) + 301LL);
                  if ((v76 & 0x100) != 0)
                  {
                    if ((v76 & 0x80) != 0) {
                      goto LABEL_171;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    BOOL v96 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_171;
                    }
                    os_log_type_t v97 = *(void *)(a1 + 40);
                    os_log_type_t v98 = (const char *)(v97 + 308);
                    if (!v97) {
                      os_log_type_t v98 = "";
                    }
                    os_log_type_t v99 = *(void *)(v97 + 8);
                    *(_DWORD *)applier = 136446978;
                    *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2082;
                    *(void *)&applier[14] = v98;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = __size[0];
                    *(_WORD *)&applier[28] = 2048;
                    *(void *)&applier[30] = v99;
                    __int16 v80 = "%{public}s %{public}s Wrote 0/%u bytes, waiting for writable event (overall bytes still %llu)";
                    id v81 = (os_log_s *)v96;
                    id v82 = OS_LOG_TYPE_DEFAULT;
                    int v83 = 38;
                  }

                  else
                  {
                    if ((v76 & 0x80) != 0 || !gLogDatapath) {
                      goto LABEL_171;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    BOOL v77 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
                      goto LABEL_171;
                    }
                    __int16 v78 = *(void *)(a1 + 40);
                    int v79 = (const char *)(v78 + 308);
                    if (!v78) {
                      int v79 = "";
                    }
                    *(_DWORD *)applier = 136446722;
                    *(void *)&void applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2082;
                    *(void *)&applier[14] = v79;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = __size[0];
                    __int16 v80 = "%{public}s %{public}s Wrote 0/%u bytes, waiting for writable event";
                    id v81 = (os_log_s *)v77;
                    id v82 = OS_LOG_TYPE_DEBUG;
                    int v83 = 28;
                  }

                  _os_log_impl(&dword_181A5C000, v81, v82, v80, applier, v83);
LABEL_171:
                  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
                  if (v138.msg_iovlen >= 1)
                  {
                    os_log_type_t v100 = 0LL;
                    p_iov_len = &v138.msg_iov->iov_len;
                    do
                    {
                      id v102 = *(_DWORD *)p_iov_len;
                      p_iov_len += 2;
                      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v102;
                      ++v100;
                    }

                    while (v100 < v138.msg_iovlen);
                  }

                  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
                    *(_BYTE *)(*(void *)(a1 + 40) + 303LL) |= 0x20u;
                  }
                  return 0LL;
                }
              }

              os_log_type_t v33 = 8;
              goto LABEL_61;
            }

            __nwlog_obj();
            *(_DWORD *)applier = 136446210;
            *(void *)&void applier[4] = "__nw_frame_get_network_service_type";
            os_log_type_t v103 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v143) = 16;
            LOBYTE(v137) = 0;
            if (__nwlog_fault(v103, &v143, &v137))
            {
              if (v143 == 17)
              {
                BOOL v104 = (os_log_s *)__nwlog_obj();
                id v105 = v143;
                if (!os_log_type_enabled(v104, (os_log_type_t)v143)) {
                  goto LABEL_229;
                }
                *(_DWORD *)applier = 136446210;
                *(void *)&void applier[4] = "__nw_frame_get_network_service_type";
                os_log_type_t v106 = "%{public}s called with null frame";
                goto LABEL_228;
              }

              if (!(_BYTE)v137)
              {
                BOOL v104 = (os_log_s *)__nwlog_obj();
                id v105 = v143;
                if (!os_log_type_enabled(v104, (os_log_type_t)v143)) {
                  goto LABEL_229;
                }
                *(_DWORD *)applier = 136446210;
                *(void *)&void applier[4] = "__nw_frame_get_network_service_type";
                os_log_type_t v106 = "%{public}s called with null frame, backtrace limit exceeded";
                goto LABEL_228;
              }

              os_log_type_t v109 = (char *)__nw_create_backtrace_string();
              BOOL v104 = (os_log_s *)__nwlog_obj();
              id v105 = v143;
              BOOL v110 = os_log_type_enabled(v104, (os_log_type_t)v143);
              if (v109)
              {
                if (v110)
                {
                  *(_DWORD *)applier = 136446466;
                  *(void *)&void applier[4] = "__nw_frame_get_network_service_type";
                  *(_WORD *)&applier[12] = 2082;
                  *(void *)&applier[14] = v109;
                  _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s called with null frame, dumping backtrace:%{public}s",  applier,  0x16u);
                }

                free(v109);
                goto LABEL_229;
              }

              if (v110)
              {
                *(_DWORD *)applier = 136446210;
                *(void *)&void applier[4] = "__nw_frame_get_network_service_type";
                os_log_type_t v106 = "%{public}s called with null frame, no backtrace";
LABEL_228:
                _os_log_impl(&dword_181A5C000, v104, v105, v106, applier, 0xCu);
              }
            }

  if (v26) {
    free(v26);
  }
  BOOL v14 = 0LL;
LABEL_45:

  return v14;
}

    free(backtrace_string);
    goto LABEL_30;
  }

  __break(1u);
  return result;
}

      goto LABEL_63;
    }

    ++nw_path_report_estimated_throughput_usage(NWConcrete_nw_path *,BOOL)::usage_report_count;
    id v4 = (os_log_s *)xpc_dictionary_create(0LL, 0LL, 0LL);
    if (v4)
    {
      BOOL v5 = nw_path_copy_interface(v3);
      __int16 v6 = v5;
      if (!v5) {
        goto LABEL_41;
      }
      __int16 v7 = (unsigned int *)v5;
      id v8 = v7[24];

      else {
        BOOL v9 = off_189BC9540[v8];
      }
      BOOL v14 = v7;
      __int16 v15 = v14[25];

      if (v15 <= 1001)
      {
        if (!v15)
        {
          char v16 = "other";
          goto LABEL_40;
        }

        if (v15 == 1001)
        {
          char v16 = "wifi_infrastructure";
          goto LABEL_40;
        }
      }

      else
      {
        switch(v15)
        {
          case 1002:
            char v16 = "wifi_awdl";
            goto LABEL_40;
          case 4001:
            char v16 = "coprocessor";
            goto LABEL_40;
          case 5001:
            char v16 = "companion";
LABEL_40:
            uint64_t v21 = v14;
            uint64_t v22 = *((unsigned __int8 *)v21 + 84);

            uint64_t v23 = nw_interface_radio_type_to_string(v22);
            xpc_dictionary_set_string(v4, "interface_type", v9);
            xpc_dictionary_set_string(v4, "interface_subtype", v16);
            xpc_dictionary_set_string(v4, "interface_radio_type", v23);
LABEL_41:
            uint64_t v24 = v3[2];
            BOOL v25 = v24;
            if (v24)
            {
              effective_process_name = (const char *)nw_parameters_get_effective_process_name(v24);
              if (effective_process_name) {
                xpc_dictionary_set_string(v4, "effective_bundle_id", effective_process_name);
              }
            }

            if (nw_utilities_get_self_name::onceToken != -1) {
              dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44151);
            }
            if (nw_utilities_get_self_name::name) {
              xpc_dictionary_set_string(v4, "bundle_id", (const char *)nw_utilities_get_self_name::name);
            }
            id v27 = *((unsigned __int8 *)v3 + 388);
            __int16 v28 = 0x8000LL << v27;
            if (v27 > 0x30) {
              __int16 v28 = -1LL;
            }
            if (*((_BYTE *)v3 + 388)) {
              BOOL v29 = v28;
            }
            else {
              BOOL v29 = 0LL;
            }
            xpc_dictionary_set_uint64(v4, "download_estimate", v29);
            char v30 = *((unsigned __int8 *)v3 + 387);
            os_log_type_t v31 = 0x8000LL << v30;
            if (v30 > 0x30) {
              os_log_type_t v31 = -1LL;
            }
            if (*((_BYTE *)v3 + 387)) {
              nw_endpoint_t v32 = v31;
            }
            else {
              nw_endpoint_t v32 = 0LL;
            }
            xpc_dictionary_set_uint64(v4, "upload_estimate", v32);
            xpc_dictionary_set_string(v4, "direction", "upload");
            os_log_type_t v33 = (char *)xpc_dictionary_copy_basic_description();
            if (gLogDatapath)
            {
              __nwlog_obj();
              os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446466;
                __int16 v51 = "nw_path_report_estimated_throughput_usage";
                uint64_t v52 = 2080;
                nw_endpoint_t v53 = v33;
                _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s Estimated throughput: %s",  buf,  0x16u);
              }
            }

            if (v33) {
              free(v33);
            }
            analytics_send_event_delayInitStub(v34);

            goto LABEL_62;
        }
      }

      char v16 = "unknown";
      goto LABEL_40;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v51 = "nw_path_report_estimated_throughput_usage";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v48 = 0;
    if (__nwlog_fault(v11, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v48)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v18 = type;
        id v19 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v51 = "nw_path_report_estimated_throughput_usage";
            uint64_t v52 = 2082;
            nw_endpoint_t v53 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v18,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v11) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A5C000, v12, v18, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v11)
    {
LABEL_17:
      id v4 = 0LL;
      goto LABEL_62;
    }

      goto LABEL_63;
    }

    ++nw_path_report_estimated_throughput_usage(NWConcrete_nw_path *,BOOL)::usage_report_count;
    id v4 = (os_log_s *)xpc_dictionary_create(0LL, 0LL, 0LL);
    if (v4)
    {
      BOOL v5 = nw_path_copy_interface(v3);
      __int16 v6 = v5;
      if (!v5) {
        goto LABEL_41;
      }
      __int16 v7 = (unsigned int *)v5;
      id v8 = v7[24];

      else {
        BOOL v9 = off_189BC9540[v8];
      }
      BOOL v14 = v7;
      __int16 v15 = v14[25];

      if (v15 <= 1001)
      {
        if (!v15)
        {
          char v16 = "other";
          goto LABEL_40;
        }

        if (v15 == 1001)
        {
          char v16 = "wifi_infrastructure";
          goto LABEL_40;
        }
      }

      else
      {
        switch(v15)
        {
          case 1002:
            char v16 = "wifi_awdl";
            goto LABEL_40;
          case 4001:
            char v16 = "coprocessor";
            goto LABEL_40;
          case 5001:
            char v16 = "companion";
LABEL_40:
            uint64_t v21 = v14;
            uint64_t v22 = *((unsigned __int8 *)v21 + 84);

            uint64_t v23 = nw_interface_radio_type_to_string(v22);
            xpc_dictionary_set_string(v4, "interface_type", v9);
            xpc_dictionary_set_string(v4, "interface_subtype", v16);
            xpc_dictionary_set_string(v4, "interface_radio_type", v23);
LABEL_41:
            uint64_t v24 = v3[2];
            BOOL v25 = v24;
            if (v24)
            {
              effective_process_name = (const char *)nw_parameters_get_effective_process_name(v24);
              if (effective_process_name) {
                xpc_dictionary_set_string(v4, "effective_bundle_id", effective_process_name);
              }
            }

            if (nw_utilities_get_self_name::onceToken != -1) {
              dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44151);
            }
            if (nw_utilities_get_self_name::name) {
              xpc_dictionary_set_string(v4, "bundle_id", (const char *)nw_utilities_get_self_name::name);
            }
            id v27 = *((unsigned __int8 *)v3 + 388);
            __int16 v28 = 0x8000LL << v27;
            if (v27 > 0x30) {
              __int16 v28 = -1LL;
            }
            if (*((_BYTE *)v3 + 388)) {
              BOOL v29 = v28;
            }
            else {
              BOOL v29 = 0LL;
            }
            xpc_dictionary_set_uint64(v4, "download_estimate", v29);
            char v30 = *((unsigned __int8 *)v3 + 387);
            os_log_type_t v31 = 0x8000LL << v30;
            if (v30 > 0x30) {
              os_log_type_t v31 = -1LL;
            }
            if (*((_BYTE *)v3 + 387)) {
              nw_endpoint_t v32 = v31;
            }
            else {
              nw_endpoint_t v32 = 0LL;
            }
            xpc_dictionary_set_uint64(v4, "upload_estimate", v32);
            xpc_dictionary_set_string(v4, "direction", "download");
            os_log_type_t v33 = (char *)xpc_dictionary_copy_basic_description();
            if (gLogDatapath)
            {
              __nwlog_obj();
              os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446466;
                __int16 v51 = "nw_path_report_estimated_throughput_usage";
                uint64_t v52 = 2080;
                nw_endpoint_t v53 = v33;
                _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s Estimated throughput: %s",  buf,  0x16u);
              }
            }

            if (v33) {
              free(v33);
            }
            analytics_send_event_delayInitStub(v34);

            goto LABEL_62;
        }
      }

      char v16 = "unknown";
      goto LABEL_40;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v51 = "nw_path_report_estimated_throughput_usage";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v48 = 0;
    if (__nwlog_fault(v11, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v48)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v18 = type;
        id v19 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v51 = "nw_path_report_estimated_throughput_usage";
            uint64_t v52 = 2082;
            nw_endpoint_t v53 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v18,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v11) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl(&dword_181A5C000, v12, v18, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v51 = "nw_path_report_estimated_throughput_usage";
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v11)
    {
LABEL_17:
      id v4 = 0LL;
      goto LABEL_62;
    }

LABEL_63:
      if (v15) {
        free(v15);
      }
      return 0LL;
    }

    if (!(_BYTE)v31)
    {
      __nwlog_obj();
      char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v17 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        LODWORD(__dst[0]) = 136446210;
        *(void *)((char *)__dst + 4) = "nw_endpoint_create_address_from_string";
        BOOL v18 = "%{public}s called with null out_prefix, backtrace limit exceeded";
        goto LABEL_61;
      }

      goto LABEL_62;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v17 = type[0];
    BOOL v25 = os_log_type_enabled(v16, type[0]);
    if (!backtrace_string)
    {
      if (v25)
      {
        LODWORD(__dst[0]) = 136446210;
        *(void *)((char *)__dst + 4) = "nw_endpoint_create_address_from_string";
        BOOL v18 = "%{public}s called with null out_prefix, no backtrace";
        goto LABEL_61;
      }

      goto LABEL_62;
    }

    if (v25)
    {
      LODWORD(__dst[0]) = 136446466;
      *(void *)((char *)__dst + 4) = "nw_endpoint_create_address_from_string";
      WORD2(__dst[1]) = 2082;
      *(void *)((char *)&__dst[1] + 6) = backtrace_string;
      uint64_t v23 = "%{public}s called with null out_prefix, dumping backtrace:%{public}s";
      goto LABEL_47;
    }

        goto LABEL_63;
      }

      if (!v50)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v53 = "nw_oblivious_http_deserialize_options";
          uint64_t v24 = "%{public}s called with null serialized_bytes, backtrace limit exceeded";
          goto LABEL_61;
        }

        goto LABEL_62;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v23 = type;
      char v30 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v53 = "nw_oblivious_http_deserialize_options";
          uint64_t v24 = "%{public}s called with null serialized_bytes, no backtrace";
          goto LABEL_61;
        }

        goto LABEL_62;
      }

      if (!v30) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446466;
      nw_endpoint_t v53 = "nw_oblivious_http_deserialize_options";
      id v54 = 2082;
      uint64_t v55 = (uint64_t)backtrace_string;
      os_log_type_t v31 = "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s";
      goto LABEL_32;
    }

    if (v28) {
      free(v28);
    }
    return 0LL;
  }

  if (uuid_is_null(uu))
  {
    if (a3 && *(void *)a3 | *((void *)a3 + 1) | *((void *)a3 + 2) | *((void *)a3 + 3))
    {
      os_log_type_t v13 = *a3;
      *(_OWORD *)(v12 + 124) = a3[1];
      *(_OWORD *)(v12 + 10_Block_object_dispose((const void *)(v67 - 152), 8) = v13;
    }

    else
    {
      if (!a4)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v25 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_application_id initWithUUID:auditToken:pid:bundleID:isBundleIDExternal:systemService:]";
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s cannot create application id without application information",  buf,  0xCu);
        }

        return 0LL;
      }

      BOOL v14 = strdup(a4);
      if (!v14)
      {
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "strict_strdup";
        os_log_type_t v39 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v39);
        if (result) {
          goto LABEL_64;
        }
        free(v39);
      }

      *((void *)v12 + 10) = v14;
      v12[104] = a5;
    }
  }

  else
  {
    *((_OWORD *)v12 + 1) = *(_OWORD *)uu;
  }

  if (nw_utilities_get_self_name::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44151);
  }
  __int16 v15 = (const char *)nw_utilities_get_self_name::name;
  if (!nw_utilities_get_self_name::name)
  {
    __nwlog_obj();
    os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_strdup";
    nw_endpoint_t v32 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v32);
    if (result) {
      goto LABEL_64;
    }
    free(v32);
  }

  char v16 = strdup(v15);
  if (v16) {
    goto LABEL_21;
  }
  __nwlog_obj();
  os_log_type_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  os_log_type_t v34 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v34);
  if (!result)
  {
    free(v34);
LABEL_21:
    *((void *)v12 + 9) = v16;
    id v17 = v12;
    BOOL v18 = v17;
    id v19 = *(_OWORD *)(v17 + 124);
    *(_OWORD *)os_log_type_t type = *(_OWORD *)(v17 + 108);
    os_log_type_t v43 = v19;
    if (*(void *)type | *(void *)&type[8] | (unint64_t)v19 | *((void *)&v19 + 1))
    {
      BOOL v20 = v17;
      uint64_t v21 = *((_DWORD *)v20 + 32);
      *((_DWORD *)v20 + 35) = v21;
      os_log_type_t v48 = 0LL;
      os_log_type_t v47 = 0u;
      memset(buf, 0, sizeof(buf));
      if (proc_pidinfo(v21, 17, 1uLL, buf, 56) == 56)
      {
        *((_OWORD *)v20 + 1) = *(_OWORD *)buf;

        return (BOOL)v20;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v23 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_log_type_t v44 = 136446210;
        BOOL v45 = "nw_application_id_validate_audit_token";
        _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to convert from audit token PID to UUID",  v44,  0xCu);
      }

      goto LABEL_30;
    }

    if (*((void *)v17 + 10))
    {
      uint64_t v22 = nw_application_id_validate_bundle_id((NWConcrete_nw_application_id *)v17);

      if ((v22 & 1) == 0)
      {
LABEL_30:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_application_id initWithUUID:auditToken:pid:bundleID:isBundleIDExternal:systemService:]";
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s application id validation failed",  buf,  0xCu);
        }

        return 0LL;
      }
    }

    else
    {
    }

    return (BOOL)v18;
  }

    free(backtrace_string);
    goto LABEL_39;
  }

  id v8 = (unsigned int *)v6;
  BOOL v9 = v8[29];

  if ((_DWORD)v9 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = (id)gLogObj;
    else {
      os_log_type_t v12 = off_189BBBBC0[v9];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
    BOOL v40 = 2082;
    os_log_type_t v41 = (void *)v12;
    BOOL v42 = 2082;
    os_log_type_t v43 = "flow";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v36 = 0;
    if (__nwlog_fault(v13, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)(id)gLogObj;
        __int16 v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          else {
            char v16 = off_189BBBBC0[v9];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
          BOOL v40 = 2082;
          os_log_type_t v41 = (void *)v16;
          BOOL v42 = 2082;
          os_log_type_t v43 = "flow";
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v36)
      {
        id v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)(id)gLogObj;
        BOOL v18 = type;
        id v19 = os_log_type_enabled(v14, type);
        if (v17)
        {
          if (v19)
          {
            else {
              BOOL v20 = off_189BBBBC0[v9];
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
            BOOL v40 = 2082;
            os_log_type_t v41 = (void *)v20;
            BOOL v42 = 2082;
            os_log_type_t v43 = "flow";
            os_log_type_t v44 = 2082;
            BOOL v45 = v17;
            _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v17);
          if (!v13) {
            goto LABEL_41;
          }
          goto LABEL_40;
        }

        if (v19)
        {
          else {
            uint64_t v23 = off_189BBBBC0[v9];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
          BOOL v40 = 2082;
          os_log_type_t v41 = (void *)v23;
          BOOL v42 = 2082;
          os_log_type_t v43 = "flow";
          _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)(id)gLogObj;
        uint64_t v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          else {
            uint64_t v22 = off_189BBBBC0[v9];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
          BOOL v40 = 2082;
          os_log_type_t v41 = (void *)v22;
          BOOL v42 = 2082;
          os_log_type_t v43 = "flow";
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }

      goto LABEL_38;
    }

    os_log_type_t v37 = *(unsigned __int16 *)(a2 + 188);
    v38 = v37 | (*(unsigned __int8 *)(a2 + 190) << 16);
    if ((v37 & 0x40) != 0) {
      return;
    }
    *(_BYTE *)(a2 + 190) = BYTE2(v38);
    *(_WORD *)(a2 + 18_Block_object_dispose((const void *)(v67 - 152), 8) = v38 | 0x40;
    os_log_type_t v39 = *(void *)(a3 + 24);
    if (v39)
    {
      BOOL v40 = *(void (**)(uint64_t, uint64_t))(v39 + 48);
      if (v40)
      {
        v40(a3, a1);
        goto LABEL_66;
      }
    }

    __nwlog_obj();
    __int16 v51 = *(const char **)(a3 + 16);
    if (!v51) {
      __int16 v51 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    id v72 = "nw_http2_protocol_close";
    BOOL v73 = 2082;
    __int16 v74 = (void *)v51;
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v52, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
        id v54 = type;
        if (!os_log_type_enabled(v53, type)) {
          goto LABEL_142;
        }
        uint64_t v55 = *(const char **)(a3 + 16);
        if (!v55) {
          uint64_t v55 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        id v72 = "nw_http2_protocol_close";
        BOOL v73 = 2082;
        __int16 v74 = (void *)v55;
        __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback";
        goto LABEL_141;
      }

      if (!v69)
      {
        nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
        id v54 = type;
        if (!os_log_type_enabled(v53, type)) {
          goto LABEL_142;
        }
        os_log_type_t v65 = *(const char **)(a3 + 16);
        if (!v65) {
          os_log_type_t v65 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        id v72 = "nw_http2_protocol_close";
        BOOL v73 = 2082;
        __int16 v74 = (void *)v65;
        __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_141;
      }

      id v61 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
      id v54 = type;
      __int16 v62 = os_log_type_enabled(v53, type);
      if (v61)
      {
        if (v62)
        {
          id v63 = *(const char **)(a3 + 16);
          if (!v63) {
            id v63 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          id v72 = "nw_http2_protocol_close";
          BOOL v73 = 2082;
          __int16 v74 = (void *)v63;
          os_log_type_t v75 = 2082;
          __int16 v76 = v61;
          _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v61);
        goto LABEL_142;
      }

      if (v62)
      {
        char v66 = *(const char **)(a3 + 16);
        if (!v66) {
          char v66 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        id v72 = "nw_http2_protocol_close";
        BOOL v73 = 2082;
        __int16 v74 = (void *)v66;
        __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
LABEL_141:
        _os_log_impl(&dword_181A5C000, v53, v54, v56, buf, 0x16u);
      }
    }

  id v27 = *((_WORD *)handle + 194);
  *((_WORD *)handle + 194) = v27 & 0xEFFF;
  if ((v27 & 0xC) == 0)
  {
    nw_http2_send_settings((uint64_t)handle);
    BOOL v29 = *((__int16 *)handle + 194);
    *((_WORD *)handle + 194) |= 4u;
    if ((v29 & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v52 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        nw_endpoint_t v53 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        os_log_type_t v57 = " ";
        LOWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v53;
        _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> http2 tunnel is now connected",  buf,  0x26u);
      }
    }

    char v30 = (void *)*((void *)handle + 14);
    if (v30)
    {
      os_log_type_t v31 = v30;
      nw_endpoint_t v32 = (v31[231] & 4) == 0;

      if (v32)
      {
        if ((*((__int16 *)handle + 194) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v33 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v34 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = handle + 390;
            *(_WORD *)&buf[22] = 2080;
            os_log_type_t v57 = " ";
            LOWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 1024;
            *(_DWORD *)((char *)&v58 + 2) = v34;
            _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered",  buf,  0x26u);
          }
        }
      }

      else
      {
        nw_endpoint_add_edges_for_instance(v31, (unsigned __int8 *)handle, 1);
      }

      goto LABEL_111;
    }

    if (*((__int16 *)handle + 194) < 0)
    {
LABEL_111:
      nw_protocol_http2_process_input((uint64_t)handle);
      os_log_type_t v48 = (char *)*((void *)handle + 19);
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL35nw_protocol_http2_process_connectedP17nw_protocol_http2_block_invoke;
      os_log_type_t v57 = (const char *)&__block_descriptor_tmp_46_82685;
      char v58 = handle;
      nw_hash_table_apply(v48, (uint64_t)buf);
      return;
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v37 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = handle + 390;
    *(_WORD *)&buf[22] = 2080;
    os_log_type_t v57 = " ";
    LOWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 1024;
    *(_DWORD *)((char *)&v58 + 2) = v37;
    v38 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v54 = 0;
    if (__nwlog_fault(v38, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v39 = (os_log_s *)gconnectionLogObj;
        BOOL v40 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_109;
        }
        os_log_type_t v41 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        os_log_type_t v57 = " ";
        LOWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v41;
        BOOL v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
        goto LABEL_108;
      }

      if (!v54)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v39 = (os_log_s *)gconnectionLogObj;
        BOOL v40 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_109;
        }
        os_log_type_t v46 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        os_log_type_t v57 = " ";
        LOWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v46;
        BOOL v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
        goto LABEL_108;
      }

      os_log_type_t v43 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v39 = (os_log_s *)gconnectionLogObj;
      BOOL v40 = type;
      os_log_type_t v44 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v43)
      {
        if (v44)
        {
          BOOL v45 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = handle + 390;
          *(_WORD *)&buf[22] = 2080;
          os_log_type_t v57 = " ";
          LOWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 1024;
          *(_DWORD *)((char *)&v58 + 2) = v45;
          HIWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 2082;
          os_log_type_t v59 = v43;
          _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s",  buf,  0x30u);
        }

        free(v43);
        goto LABEL_109;
      }

      if (v44)
      {
        os_log_type_t v47 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        os_log_type_t v57 = " ";
        LOWORD(v5_Block_object_dispose((const void *)(v67 - 152), 8) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v47;
        BOOL v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_108:
        _os_log_impl(&dword_181A5C000, v39, v40, v42, buf, 0x26u);
      }
    }

    free(v25);
    goto LABEL_63;
  }

  __nwlog_obj();
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v44 = "nw_browse_descriptor_create_custom";
  BOOL v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v41 = 0;
  if (__nwlog_fault(v9, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v44 = "nw_browse_descriptor_create_custom";
        _os_log_impl(&dword_181A5C000, v10, v36, "%{public}s called with null custom_data", buf, 0xCu);
      }

      goto LABEL_51;
    }

    if (!v41)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v40 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v44 = "nw_browse_descriptor_create_custom";
        _os_log_impl( &dword_181A5C000,  v10,  v40,  "%{public}s called with null custom_data, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_51;
    }

    os_log_type_t v37 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v38 = type;
    os_log_type_t v39 = os_log_type_enabled(v10, type);
    if (!v37)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v44 = "nw_browse_descriptor_create_custom";
        _os_log_impl(&dword_181A5C000, v10, v38, "%{public}s called with null custom_data, no backtrace", buf, 0xCu);
      }

      goto LABEL_51;
    }

    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v44 = "nw_browse_descriptor_create_custom";
      BOOL v45 = 2082;
      *(void *)os_log_type_t v46 = v37;
      _os_log_impl( &dword_181A5C000,  v10,  v38,  "%{public}s called with null custom_data, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v37);
  }

void sub_181AEDEEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v391 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  v364 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v319 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v376 = "nw_endpoint_handler_get_mode";
    char v320 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v374 = 0;
    if (__nwlog_fault(v320, type, &v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v321 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v322 = type[0];
        if (os_log_type_enabled(v321, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v376 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v321, v322, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v374)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v321 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v324 = type[0];
        BOOL v325 = os_log_type_enabled(v321, type[0]);
        if (backtrace_string)
        {
          if (v325)
          {
            *(_DWORD *)buf = 136446466;
            v376 = "nw_endpoint_handler_get_mode";
            __int16 v377 = 2082;
            v378 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v321,  v324,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_265;
        }

        if (v325)
        {
          *(_DWORD *)buf = 136446210;
          v376 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v321, v324, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v321 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v326 = type[0];
        if (os_log_type_enabled(v321, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v376 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v321,  v326,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_265:
    if (v320) {
      free(v320);
    }
    unsigned int mode = 0;
LABEL_268:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v327 = (id)gLogObj;
    if (mode > 5) {
      id v328 = "unknown-mode";
    }
    else {
      id v328 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    v376 = "nw_endpoint_flow_validate_delegation";
    __int16 v377 = 2082;
    v378 = (char *)v328;
    __int16 v379 = 2082;
    v380 = "flow";
    os_log_type_t v329 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v374 = 0;
    if (__nwlog_fault(v329, type, &v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v330 = (os_log_s *)(id)gLogObj;
        os_log_type_t v331 = type[0];
        if (os_log_type_enabled(v330, type[0]))
        {
          if (mode > 5) {
            v332 = "unknown-mode";
          }
          else {
            v332 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v332;
          __int16 v379 = 2082;
          v380 = "flow";
          _os_log_impl( &dword_181A5C000,  v330,  v331,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v374)
      {
        nw_endpoint_t v333 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v330 = (os_log_s *)(id)gLogObj;
        os_log_type_t v334 = type[0];
        BOOL v335 = os_log_type_enabled(v330, type[0]);
        if (v333)
        {
          if (v335)
          {
            if (mode > 5) {
              v336 = "unknown-mode";
            }
            else {
              v336 = off_189BBBBC0[mode];
            }
            *(_DWORD *)buf = 136446978;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)v336;
            __int16 v379 = 2082;
            v380 = "flow";
            __int16 v381 = 2082;
            nw_endpoint_t v382 = v333;
            _os_log_impl( &dword_181A5C000,  v330,  v334,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v333);
          if (!v329) {
            goto LABEL_302;
          }
          goto LABEL_301;
        }

        if (v335)
        {
          if (mode > 5) {
            v339 = "unknown-mode";
          }
          else {
            v339 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v339;
          __int16 v379 = 2082;
          v380 = "flow";
          _os_log_impl( &dword_181A5C000,  v330,  v334,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v330 = (os_log_s *)(id)gLogObj;
        os_log_type_t v337 = type[0];
        if (os_log_type_enabled(v330, type[0]))
        {
          if (mode > 5) {
            v338 = "unknown-mode";
          }
          else {
            v338 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v338;
          __int16 v379 = 2082;
          v380 = "flow";
          _os_log_impl( &dword_181A5C000,  v330,  v337,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    if (!v329)
    {
LABEL_302:
      uint64_t v9 = 0LL;
      goto LABEL_303;
    }

        if (v167) {
          free(v167);
        }
        goto LABEL_152;
      }

      goto LABEL_126;
    }

        nw_write_request_report_error_with_override(*(void **)(handle + 200), 0LL, *(void **)(handle + 320));
        nw_write_request_report_error_with_override(*(void **)(handle + 192), 0LL, *(void **)(handle + 320));
LABEL_266:
        id v171 = nw_write_request_list_prune(*(void **)(handle + 200));
        int v172 = *(void **)(handle + 200);
        *(void *)(handle + 200) = v171;

        uint64_t v173 = nw_write_request_list_prune(*(void **)(handle + 192));
        nw_endpoint_t v174 = *(void **)(handle + 192);
        *(void *)(handle + 192) = v173;

        v175 = v318;
        if (v318)
        {
          BOOL v325 = 0LL;
          os_log_type_t v326 = &v325;
          id v328 = 0;
          id v327 = 0x2020000000LL;
          v321 = MEMORY[0x1895F87A8];
          os_log_type_t v322 = 3221225472LL;
          nw_endpoint_t v323 = (uint64_t)___ZL29nw_flow_prepare_output_framesP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sjP30nw_protocol_message_properties_block_invoke_87;
          v324[0] = &unk_189BB84D8;
          v324[1] = &v325;
          do
          {
            if (!v175) {
              break;
            }
            v176 = (void *)v175[4];
            nw_endpoint_t v177 = ((uint64_t (*)(uint64_t *))v323)(&v321);
            v175 = v176;
          }

          while ((v177 & 1) != 0);
          if ((nw_endpoint_handler_get_logging_disabled(v294) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v178 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
            {
              v179 = nw_endpoint_handler_get_id_string(v294);
              v180 = nw_endpoint_handler_dry_run_string(v294);
              v305 = v157;
              id v181 = nw_endpoint_handler_copy_endpoint(v294);
              v182 = nw_endpoint_get_logging_description(v181);
              id v183 = nw_endpoint_handler_state_string(v294);
              id v184 = nw_endpoint_handler_mode_string(v294);
              v185 = nw_endpoint_handler_copy_current_path(v294);
              os_log_type_t v186 = *((_DWORD *)v326 + 6);
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_flow_prepare_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v179;
              *(_WORD *)&buf[22] = 2082;
              v338 = v180;
              *(_WORD *)v339 = 2082;
              *(void *)&v339[2] = v182;
              *(_WORD *)&v339[10] = 2082;
              *(void *)&v339[12] = v183;
              *(_WORD *)&v339[20] = 2082;
              *(void *)&v339[22] = v184;
              nw_endpoint_t v340 = 2114;
              v341 = v185;
              nw_endpoint_t v342 = 1024;
              v343 = v186;
              _os_log_impl( &dword_181A5C000,  v178,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to use %u frames , marking as failed",  buf,  0x4Eu);

              v157 = v305;
            }
          }

          _Block_object_dispose(&v325, 8);
        }

        v187 = nw_flow_handle_send_complete(v291, v292, v295);
        if ((v187 & 1) != 0)
        {
LABEL_337:
          *((_WORD *)v295 + 166) &= ~8u;
          id v214 = 1LL;
          goto LABEL_338;
        }
      }
    }

    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v291) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v206 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v206, OS_LOG_TYPE_DEBUG))
      {
        v263 = nw_endpoint_handler_get_id_string(v291);
        id v264 = nw_endpoint_handler_dry_run_string(v291);
        v265 = nw_endpoint_handler_copy_endpoint(v291);
        os_log_type_t v266 = nw_endpoint_get_logging_description(v265);
        v267 = nw_endpoint_handler_state_string(v291);
        v268 = nw_endpoint_handler_mode_string(v291);
        nw_endpoint_t v269 = nw_endpoint_handler_copy_current_path(v291);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v263;
        *(_WORD *)&buf[22] = 2082;
        v338 = v264;
        *(_WORD *)v339 = 2082;
        *(void *)&v339[2] = v266;
        *(_WORD *)&v339[10] = 2082;
        *(void *)&v339[12] = v267;
        *(_WORD *)&v339[20] = 2082;
        *(void *)&v339[22] = v268;
        nw_endpoint_t v340 = 2114;
        v341 = v269;
        _os_log_impl( &dword_181A5C000,  v206,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Already servicing writes, ignoring...",  buf,  0x48u);
      }

                    if (!v6)
                    {
LABEL_267:
                      nw_masque_mark_connected(a1);
                      return;
                    }

                    goto LABEL_266;
                  }

                  if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
                    goto LABEL_265;
                  }
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  uint64_t v83 = gprivacy_proxyLogObj;
                  if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_265;
                  }
                }

                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = a1 + 531;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&void buf[14] = " ";
                *(_WORD *)&buf[22] = 2048;
                id v102 = (const char *)v44;
                __int16 v78 = "%{public}s%sADDRESS_ASSIGN capsule too short: %zu bytes";
                nw_endpoint_t v79 = (os_log_s *)v83;
                goto LABEL_263;
              }

              break;
            }

            if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
              goto LABEL_265;
            }
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            BOOL v77 = gprivacy_proxyLogObj;
            if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_265;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = a1 + 531;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&void buf[14] = " ";
            __int16 v78 = "%{public}s%sADDRESS_ASSIGN capsule failed to decode request ID";
            nw_endpoint_t v79 = (os_log_s *)v77;
            __int16 v80 = 22;
            goto LABEL_264;
          case 2LL:
            if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
              goto LABEL_266;
            }
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            char v16 = (os_log_s *)gprivacy_proxyLogObj;
            if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_266;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = a1 + 531;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&void buf[14] = " ";
            id v17 = "%{public}s%sADDRESS_REQUEST capsules not supported";
            goto LABEL_252;
          case 3LL:
            os_log_type_t v100 = 0;
            __int16 v56 = MEMORY[0x1895F87A8];
            memset(length, 0, sizeof(length));
            id v57 = &qword_18C593000;
            while (2)
            {
              char v62 = dispatch_data_get_size(v6);
              if (v62 <= 9)
              {
                if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
                  goto LABEL_265;
                }
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                id v81 = (os_log_s *)v57[198];
                if (!os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_265;
                }
              }

              else
              {
                address = 0LL;
                *(void *)&address_8.sa_len = &address;
                *(void *)&address_8.sa_data[6] = 0x2000000000LL;
                BOOL v110 = 0LL;
                *(void *)os_log_type_t v106 = 0LL;
                *(void *)&v106[8] = v106;
                *(void *)&v106[16] = 0x2000000000LL;
                unint64_t v107 = length;
                *(void *)buf = v56;
                *(void *)&buf[8] = 0x40000000LL;
                *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
                id v102 = (const char *)&unk_189BBF598;
                *((void *)&v103 + 1) = v106;
                BOOL v104 = 1LL;
                *(void *)&os_log_type_t v103 = &address;
                dispatch_data_apply(v6, buf);
                _Block_object_dispose(v106, 8);
                _Block_object_dispose(&address, 8);
                if (length[0].sa_len != 6)
                {
                  if (length[0].sa_len != 4)
                  {
                    if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
                      goto LABEL_265;
                    }
                    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                    }
                    id v84 = (os_log_s *)v57[198];
                    if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_265;
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = a1 + 531;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&void buf[14] = " ";
                    *(_WORD *)&buf[22] = 1024;
                    LODWORD(v102) = length[0].sa_len;
                    __int16 v78 = "%{public}s%sUnknown ROUTE_ADVERTISEMENT version %u";
                    nw_endpoint_t v79 = v84;
                    __int16 v80 = 28;
LABEL_264:
                    _os_log_impl(&dword_181A5C000, v79, OS_LOG_TYPE_ERROR, v78, buf, v80);
                    goto LABEL_265;
                  }

                  address = 0LL;
                  *(void *)&address_8.sa_len = &address;
                  *(void *)&address_8.sa_data[6] = 0x2000000000LL;
                  BOOL v110 = 0LL;
                  *(void *)os_log_type_t v106 = 0LL;
                  *(void *)&v106[8] = v106;
                  *(void *)&v106[16] = 0x2000000000LL;
                  unint64_t v107 = length;
                  *(void *)buf = v56;
                  *(void *)&buf[8] = 0x40000000LL;
                  *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
                  id v102 = (const char *)&unk_189BBF598;
                  *((void *)&v103 + 1) = v106;
                  BOOL v104 = 10LL;
                  *(void *)&os_log_type_t v103 = &address;
                  dispatch_data_apply(v6, buf);
                  _Block_object_dispose(v106, 8);
                  _Block_object_dispose(&address, 8);
                  LODWORD(address) = 528;
                  HIDWORD(address) = *(_DWORD *)&length[0].sa_family;
                  *(void *)&address_8.sa_len = 0LL;
                  *(_DWORD *)os_log_type_t v106 = 528;
                  *(_DWORD *)&v106[4] = *(_DWORD *)&length[0].sa_family;
                  *(void *)&v106[8] = 0LL;
                  id v63 = nw_endpoint_create_address((const sockaddr *)&address);
                  nw_endpoint_t v64 = nw_endpoint_create_address((const sockaddr *)v106);
                  if ((*(_BYTE *)(a1 + 529) & 1) == 0)
                  {
                    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                    }
                    os_log_type_t v65 = (os_log_s *)v57[198];
                    if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
                    {
                      char v66 = nw_endpoint_get_logging_description(v63);
                      uint64_t v67 = nw_endpoint_get_logging_description(v64);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = a1 + 531;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&void buf[14] = " ";
                      *(_WORD *)&buf[22] = 2082;
                      id v102 = v66;
                      id v57 = &qword_18C593000;
                      LOWORD(v103) = 2082;
                      *(void *)((char *)&v103 + 2) = v67;
                      _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived ROUTE_ADVERTISEMENT capsule for %{public}s-%{public}s",  buf,  0x2Au);
                    }
                  }

                  if (v63)
                  {
                    os_log_type_t v68 = *(void **)(a1 + 368);
                    if (v68) {
                      os_release(v68);
                    }
                    *(void *)(a1 + 36_Block_object_dispose((const void *)(v67 - 152), 8) = v63;
                  }

                  if (v64)
                  {
                    uint64_t v69 = *(void **)(a1 + 376);
                    if (v69) {
                      os_release(v69);
                    }
                    *(void *)(a1 + 376) = v64;
                  }

                  if (v62 < 0xB) {
                    goto LABEL_265;
                  }
                  int v58 = v62 - 10;
                  os_log_type_t v59 = v6;
                  __int16 v60 = 10LL;
LABEL_162:
                  id v61 = dispatch_data_create_subrange(v59, v60, v58);
                  dispatch_release(v6);
                  __int16 v6 = v61;
                  __int16 v56 = MEMORY[0x1895F87A8];
                  if (!v61) {
                    goto LABEL_265;
                  }
                  continue;
                }

                if (v62 > 0x21)
                {
                  address = 0LL;
                  *(void *)&address_8.sa_len = &address;
                  *(void *)&address_8.sa_data[6] = 0x2000000000LL;
                  BOOL v110 = 0LL;
                  *(void *)os_log_type_t v106 = 0LL;
                  *(void *)&v106[8] = v106;
                  *(void *)&v106[16] = 0x2000000000LL;
                  unint64_t v107 = length;
                  *(void *)buf = v56;
                  *(void *)&buf[8] = 0x40000000LL;
                  *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
                  id v102 = (const char *)&unk_189BBF598;
                  *((void *)&v103 + 1) = v106;
                  BOOL v104 = 34LL;
                  *(void *)&os_log_type_t v103 = &address;
                  dispatch_data_apply(v6, buf);
                  _Block_object_dispose(v106, 8);
                  _Block_object_dispose(&address, 8);
                  address = 7708LL;
                  address_8 = *(sockaddr *)&length[0].sa_family;
                  LODWORD(v110) = 0;
                  *(void *)os_log_type_t v106 = 7708LL;
                  *(sockaddr *)&v106[8] = *(sockaddr *)&length[0].sa_family;
                  LODWORD(v107) = 0;
                  __int16 v70 = nw_endpoint_create_address((const sockaddr *)&address);
                  int v71 = nw_endpoint_create_address((const sockaddr *)v106);
                  if ((*(_BYTE *)(a1 + 529) & 1) == 0)
                  {
                    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                    }
                    id v72 = (os_log_s *)v57[198];
                    if (os_log_type_enabled(v72, OS_LOG_TYPE_INFO))
                    {
                      BOOL v73 = nw_endpoint_get_logging_description(v70);
                      id v74 = nw_endpoint_get_logging_description(v71);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = a1 + 531;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&void buf[14] = " ";
                      *(_WORD *)&buf[22] = 2082;
                      id v102 = v73;
                      id v57 = &qword_18C593000;
                      LOWORD(v103) = 2082;
                      *(void *)((char *)&v103 + 2) = v74;
                      _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived ROUTE_ADVERTISEMENT capsule for %{public}s-%{public}s",  buf,  0x2Au);
                    }
                  }

                  if (v70)
                  {
                    os_log_type_t v75 = *(void **)(a1 + 368);
                    if (v75) {
                      os_release(v75);
                    }
                    *(void *)(a1 + 36_Block_object_dispose((const void *)(v67 - 152), 8) = v70;
                  }

                  if (v71)
                  {
                    __int16 v76 = *(void **)(a1 + 376);
                    if (v76) {
                      os_release(v76);
                    }
                    *(void *)(a1 + 376) = v71;
                  }

                  if (v62 < 0x23) {
                    goto LABEL_265;
                  }
                  int v58 = v62 - 34;
                  os_log_type_t v59 = v6;
                  __int16 v60 = 34LL;
                  goto LABEL_162;
                }

                if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
                  goto LABEL_265;
                }
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                id v81 = (os_log_s *)v57[198];
                if (!os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_265;
                }
              }

              break;
            }

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = a1 + 531;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&void buf[14] = " ";
            *(_WORD *)&buf[22] = 2048;
            id v102 = (const char *)v62;
            __int16 v78 = "%{public}s%sROUTE_ADVERTISEMENT capsule too short: %zu bytes";
            nw_endpoint_t v79 = v81;
LABEL_263:
            __int16 v80 = 32;
            goto LABEL_264;
          default:
            goto LABEL_43;
        }
    }
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
  BOOL v85 = (char *)_os_log_send_and_compose_impl();
  length[0].sa_len = 16;
  LOBYTE(address) = 0;
  if (length[0].sa_len == 17)
  {
    uint64_t v86 = (os_log_s *)__nwlog_obj();
    sa_len = length[0].sa_len;
    if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
      goto LABEL_327;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    nw_endpoint_t v88 = "%{public}s called with null capsule_data";
    goto LABEL_326;
  }

  if (!(_BYTE)address)
  {
    uint64_t v86 = (os_log_s *)__nwlog_obj();
    sa_len = length[0].sa_len;
    if (!os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len)) {
      goto LABEL_327;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    nw_endpoint_t v88 = "%{public}s called with null capsule_data, backtrace limit exceeded";
    goto LABEL_326;
  }

  id v91 = (char *)__nw_create_backtrace_string();
  uint64_t v86 = (os_log_s *)__nwlog_obj();
  sa_len = length[0].sa_len;
  os_log_type_t v95 = os_log_type_enabled(v86, (os_log_type_t)length[0].sa_len);
  if (!v91)
  {
    if (!v95) {
      goto LABEL_327;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    nw_endpoint_t v88 = "%{public}s called with null capsule_data, no backtrace";
    goto LABEL_326;
  }

  if (v95)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v91;
    id v93 = "%{public}s called with null capsule_data, dumping backtrace:%{public}s";
    goto LABEL_307;
  }
    }

LABEL_301:
    free(v329);
    goto LABEL_302;
  }

  nw_path_t v2 = v1;
  unsigned int mode = v1->mode;

  if (mode != 2) {
    goto LABEL_268;
  }
  id v4 = v2;
  id v5 = v4[4];

  if (nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::onceToken != -1) {
    dispatch_once( &nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::onceToken,  &__block_literal_global_208);
  }
  int pid_to_uuid_mapping_failed = nw_parameters_get_pid_to_uuid_mapping_failed(v5);
  int bundle_id_to_uuid_mapping_failed = nw_parameters_get_bundle_id_to_uuid_mapping_failed(v5);
  if ((pid_to_uuid_mapping_failed & 1) != 0 || bundle_id_to_uuid_mapping_failed)
  {
    v360 = v5;
    if ((pid_to_uuid_mapping_failed & bundle_id_to_uuid_mapping_failed) == 1)
    {
      int v10 = _os_feature_enabled_impl();
      BOOL v11 = v4;
      char v12 = *((_BYTE *)v11 + 268);

      nw_endpoint_t v361 = v4;
      if (v10)
      {
        if ((v12 & 0x20) != 0) {
          goto LABEL_168;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v13 = (id)gconnectionLogObj;
        BOOL v14 = v11;

        __int16 v15 = v14;
        char v16 = *((_BYTE *)v11 + 268);

        if ((v16 & 1) != 0) {
          id v17 = "dry-run ";
        }
        else {
          id v17 = "";
        }
        nw_endpoint_t v18 = nw_endpoint_handler_copy_endpoint(v15);
        logging_description = nw_endpoint_get_logging_description(v18);
        v353 = (char *)(v14 + 21);
        BOOL v20 = v15;
        uint64_t v21 = v20;
        uint64_t v22 = v20[30];
        else {
          uint64_t v23 = off_189BBBBF0[v22];
        }

        BOOL v92 = v21;
        id v93 = v92;
        os_log_type_t v94 = "path";
        switch(v364->mode)
        {
          case 0:
            break;
          case 1:
            os_log_type_t v94 = "resolver";
            break;
          case 2:
            os_log_type_t v94 = nw_endpoint_flow_mode_string(v92[31]);
            break;
          case 3:
            os_log_type_t v94 = "proxy";
            break;
          case 4:
            os_log_type_t v94 = "fallback";
            break;
          case 5:
            os_log_type_t v94 = "transform";
            break;
          default:
            os_log_type_t v94 = "unknown-mode";
            break;
        }

        __int16 v116 = v93;
        os_unfair_lock_lock((os_unfair_lock_t)v116 + 28);
        id v117 = v116[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v116 + 28);

        id v118 = v117;
        *(_DWORD *)buf = 136448514;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = v353;
        __int16 v379 = 2082;
        v380 = v17;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)logging_description;
        __int16 v383 = 2082;
        v384 = v23;
        __int16 v385 = 2082;
        id v386 = v94;
        __int16 v387 = 2114;
        id v388 = v118;
        __int16 v389 = 1024;
        *(_DWORD *)v390 = nw_parameters_get_pid(v360);
        *(_WORD *)&v390[4] = 2082;
        *(void *)&v390[6] = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[14] = 2082;
        *(void *)&v390[16] = "T";
        v356 = (const char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        char v374 = 0;
        nw_endpoint_t v119 = (char *)v356;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          __int16 v120 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v121 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            id_string = nw_endpoint_handler_get_id_string(v116);
            id v123 = nw_endpoint_handler_dry_run_string(v116);
            logb = v120;
            nw_endpoint_t v124 = nw_endpoint_handler_copy_endpoint(v116);
            dispatch_time_t v125 = nw_endpoint_get_logging_description(v124);
            uint64_t v126 = nw_endpoint_handler_state_string(v116);
            uint64_t v127 = nw_endpoint_handler_mode_string(v116);
            id v128 = nw_endpoint_handler_copy_current_path(v116);
            int pid = nw_parameters_get_pid(v360);
            uint64_t effective_bundle_id = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)id_string;
            __int16 v379 = 2082;
            v380 = v123;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = (void *)v125;
            __int16 v383 = 2082;
            v384 = v126;
            __int16 v385 = 2082;
            id v386 = v127;
            __int16 v387 = 2114;
            id v388 = v128;
            __int16 v389 = 1024;
            *(_DWORD *)v390 = pid;
            *(_WORD *)&v390[4] = 2082;
            *(void *)&v390[6] = effective_bundle_id;
            *(_WORD *)&v390[14] = 2082;
            *(void *)&v390[16] = "T";
            _os_log_impl( &dword_181A5C000,  logb,  v121,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failur e: Invalid PID %d and Invalid Bundle ID %{public}s [%{public}s]",  buf,  0x62u);

            __int16 v120 = logb;
          }
        }

        else if (v374)
        {
          nw_endpoint_t v131 = __nw_create_backtrace_string();
          if (v131)
          {
            nw_endpoint_t v132 = (char *)v131;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v133 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v134 = type[0];
            if (os_log_type_enabled(v133, type[0]))
            {
              v135 = nw_endpoint_handler_get_id_string(v116);
              char v136 = nw_endpoint_handler_dry_run_string(v116);
              nw_endpoint_t v347 = nw_endpoint_handler_copy_endpoint(v116);
              nw_endpoint_t v137 = nw_endpoint_get_logging_description(v347);
              v138 = nw_endpoint_handler_state_string(v116);
              uint64_t v139 = nw_endpoint_handler_mode_string(v116);
              id v140 = nw_endpoint_handler_copy_current_path(v116);
              int v141 = nw_parameters_get_pid(v360);
              uint64_t v142 = nw_parameters_get_effective_bundle_id(v360);
              *(_DWORD *)buf = 136448770;
              v376 = "nw_endpoint_flow_validate_delegation";
              __int16 v377 = 2082;
              v378 = (char *)v135;
              __int16 v379 = 2082;
              v380 = v136;
              __int16 v381 = 2082;
              nw_endpoint_t v382 = (void *)v137;
              __int16 v383 = 2082;
              v384 = v138;
              __int16 v385 = 2082;
              id v386 = v139;
              __int16 v387 = 2114;
              id v388 = v140;
              __int16 v389 = 1024;
              *(_DWORD *)v390 = v141;
              *(_WORD *)&v390[4] = 2082;
              *(void *)&v390[6] = v142;
              *(_WORD *)&v390[14] = 2082;
              *(void *)&v390[16] = "T";
              *(_WORD *)&v390[24] = 2082;
              *(void *)&v390[26] = v132;
              _os_log_impl( &dword_181A5C000,  v133,  v134,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Fail ure: Invalid PID %d and Invalid Bundle ID %{public}s [%{public}s], dumping backtrace:%{public}s",  buf,  0x6Cu);
            }

            free(v132);
            goto LABEL_128;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          __int16 v120 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v164 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            v165 = nw_endpoint_handler_get_id_string(v116);
            id v166 = nw_endpoint_handler_dry_run_string(v116);
            logd = v120;
            nw_endpoint_t v167 = nw_endpoint_handler_copy_endpoint(v116);
            v168 = nw_endpoint_get_logging_description(v167);
            v169 = nw_endpoint_handler_state_string(v116);
            v170 = nw_endpoint_handler_mode_string(v116);
            id v171 = nw_endpoint_handler_copy_current_path(v116);
            int v172 = nw_parameters_get_pid(v360);
            uint64_t v173 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)v165;
            __int16 v379 = 2082;
            v380 = v166;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = (void *)v168;
            __int16 v383 = 2082;
            v384 = v169;
            __int16 v385 = 2082;
            id v386 = v170;
            __int16 v387 = 2114;
            id v388 = v171;
            __int16 v389 = 1024;
            *(_DWORD *)v390 = v172;
            *(_WORD *)&v390[4] = 2082;
            *(void *)&v390[6] = v173;
            *(_WORD *)&v390[14] = 2082;
            *(void *)&v390[16] = "T";
            _os_log_impl( &dword_181A5C000,  logd,  v164,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failur e: Invalid PID %d and Invalid Bundle ID %{public}s [%{public}s], no backtrace",  buf,  0x62u);

            __int16 v120 = logd;
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          __int16 v120 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v143 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            __int16 v144 = nw_endpoint_handler_get_id_string(v116);
            v145 = nw_endpoint_handler_dry_run_string(v116);
            logc = v120;
            nw_endpoint_t v146 = nw_endpoint_handler_copy_endpoint(v116);
            v147 = nw_endpoint_get_logging_description(v146);
            __int16 v148 = nw_endpoint_handler_state_string(v116);
            v149 = nw_endpoint_handler_mode_string(v116);
            id v150 = nw_endpoint_handler_copy_current_path(v116);
            int v151 = nw_parameters_get_pid(v360);
            uint64_t v152 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)v144;
            __int16 v379 = 2082;
            v380 = v145;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = (void *)v147;
            __int16 v383 = 2082;
            v384 = v148;
            __int16 v385 = 2082;
            id v386 = v149;
            __int16 v387 = 2114;
            id v388 = v150;
            __int16 v389 = 1024;
            *(_DWORD *)v390 = v151;
            *(_WORD *)&v390[4] = 2082;
            *(void *)&v390[6] = v152;
            *(_WORD *)&v390[14] = 2082;
            *(void *)&v390[16] = "T";
            _os_log_impl( &dword_181A5C000,  logc,  v143,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failur e: Invalid PID %d and Invalid Bundle ID %{public}s [%{public}s], backtrace limit exceeded",  buf,  0x62u);

            __int16 v120 = logc;
          }
        }

LABEL_128:
        nw_endpoint_t v119 = (char *)v356;
        goto LABEL_129;
      }

      if ((v12 & 0x20) != 0) {
        goto LABEL_168;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v59 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        __int16 v60 = v11;

        id v61 = v60;
        char v62 = *((_BYTE *)v11 + 268);

        if ((v62 & 1) != 0) {
          id v63 = "dry-run ";
        }
        else {
          id v63 = "";
        }
        nw_endpoint_t v64 = nw_endpoint_handler_copy_endpoint(v61);
        os_log_type_t v65 = nw_endpoint_get_logging_description(v64);
        char v66 = (char *)(v60 + 21);
        uint64_t v67 = v61;
        os_log_type_t v68 = v67;
        uint64_t v69 = v67[30];
        else {
          __int16 v70 = off_189BBBBF0[v69];
        }

        id v105 = v68;
        os_log_type_t v106 = v105;
        unint64_t v107 = "path";
        switch(v364->mode)
        {
          case 0:
            break;
          case 1:
            unint64_t v107 = "resolver";
            break;
          case 2:
            unint64_t v107 = nw_endpoint_flow_mode_string(v105[31]);
            break;
          case 3:
            unint64_t v107 = "proxy";
            break;
          case 4:
            unint64_t v107 = "fallback";
            break;
          case 5:
            unint64_t v107 = "transform";
            break;
          default:
            unint64_t v107 = "unknown-mode";
            break;
        }

        nw_endpoint_t v216 = v106;
        os_unfair_lock_lock((os_unfair_lock_t)v216 + 28);
        id v217 = v216[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v216 + 28);

        id v218 = v217;
        *(_DWORD *)buf = 136448514;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = v66;
        __int16 v379 = 2082;
        v380 = v63;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v65;
        __int16 v383 = 2082;
        v384 = v70;
        __int16 v385 = 2082;
        id v386 = v107;
        __int16 v387 = 2114;
        id v388 = v218;
        __int16 v389 = 1024;
        *(_DWORD *)v390 = nw_parameters_get_pid(v360);
        *(_WORD *)&v390[4] = 2082;
        *(void *)&v390[6] = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[14] = 2082;
        *(void *)&v390[16] = "T";
        _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: I nvalid PID %d and Invalid Bundle ID %{public}s [%{public}s]",  buf,  0x62u);
      }

                  uint64_t v9 = v474;
                  BOOL v42 = loga;
                  goto LABEL_302;
                }

                goto LABEL_302;
              }

    if (v131) {
      free(v131);
    }
    *(_DWORD *)(v125 + 36_Block_object_dispose((const void *)(v67 - 152), 8) = -1;
    goto LABEL_304;
  }

LABEL_167:
      id v4 = v361;
      goto LABEL_168;
    }

    if (bundle_id_to_uuid_mapping_failed)
    {
      int v24 = _os_feature_enabled_impl();
      BOOL v25 = v4;
      char v26 = *((_BYTE *)v25 + 268);

      nw_endpoint_t v361 = v4;
      if (v24)
      {
        if ((v26 & 0x20) != 0) {
          goto LABEL_168;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v27 = (id)gconnectionLogObj;
        __int16 v28 = v25;

        BOOL v29 = v28;
        char v30 = *((_BYTE *)v25 + 268);

        if ((v30 & 1) != 0) {
          os_log_type_t v31 = "dry-run ";
        }
        else {
          os_log_type_t v31 = "";
        }
        nw_endpoint_t v32 = nw_endpoint_handler_copy_endpoint(v29);
        os_log_type_t v33 = nw_endpoint_get_logging_description(v32);
        os_log_type_t v34 = (char *)(v28 + 21);
        uint64_t v35 = v29;
        BOOL v36 = v35;
        uint64_t v37 = v35[30];
        else {
          v38 = off_189BBBBF0[v37];
        }

        id v102 = v36;
        os_log_type_t v103 = v102;
        BOOL v104 = "path";
        switch(v364->mode)
        {
          case 0:
            break;
          case 1:
            BOOL v104 = "resolver";
            break;
          case 2:
            BOOL v104 = nw_endpoint_flow_mode_string(v102[31]);
            break;
          case 3:
            BOOL v104 = "proxy";
            break;
          case 4:
            BOOL v104 = "fallback";
            break;
          case 5:
            BOOL v104 = "transform";
            break;
          default:
            BOOL v104 = "unknown-mode";
            break;
        }

        v182 = v103;
        os_unfair_lock_lock((os_unfair_lock_t)v182 + 28);
        id v183 = v182[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v182 + 28);

        id v184 = v183;
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = v34;
        __int16 v379 = 2082;
        v380 = v31;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v33;
        __int16 v383 = 2082;
        v384 = v38;
        __int16 v385 = 2082;
        id v386 = v104;
        __int16 v387 = 2114;
        id v388 = v184;
        __int16 v389 = 2082;
        *(void *)v390 = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[8] = 2082;
        *(void *)&v390[10] = "T";
        nw_endpoint_t v119 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        char v374 = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v185 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v186 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            v187 = nw_endpoint_handler_get_id_string(v182);
            id v188 = nw_endpoint_handler_dry_run_string(v182);
            nw_endpoint_t v189 = nw_endpoint_handler_copy_endpoint(v182);
            v190 = nw_endpoint_get_logging_description(v189);
            v191 = nw_endpoint_handler_state_string(v182);
            v192 = nw_endpoint_handler_mode_string(v182);
            id v193 = nw_endpoint_handler_copy_current_path(v182);
            uint64_t v194 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448258;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)v187;
            __int16 v379 = 2082;
            v380 = v188;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = (void *)v190;
            __int16 v383 = 2082;
            v384 = v191;
            __int16 v385 = 2082;
            id v386 = v192;
            __int16 v387 = 2114;
            id v388 = v193;
            __int16 v389 = 2082;
            *(void *)v390 = v194;
            *(_WORD *)&v390[8] = 2082;
            *(void *)&v390[10] = "T";
            _os_log_impl( &dword_181A5C000,  v185,  v186,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failur e: Invalid Bundle ID %{public}s [%{public}s]",  buf,  0x5Cu);
          }
        }

        else if (v374)
        {
          v195 = __nw_create_backtrace_string();
          if (v195)
          {
            v196 = (char *)v195;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v197 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v198 = type[0];
            if (os_log_type_enabled(v197, type[0]))
            {
              char v199 = nw_endpoint_handler_get_id_string(v182);
              uint64_t v200 = nw_endpoint_handler_dry_run_string(v182);
              uint64_t v201 = v199;
              nw_endpoint_t v358 = nw_endpoint_handler_copy_endpoint(v182);
              id v202 = nw_endpoint_get_logging_description(v358);
              v203 = nw_endpoint_handler_state_string(v182);
              v204 = nw_endpoint_handler_mode_string(v182);
              id v205 = nw_endpoint_handler_copy_current_path(v182);
              uint64_t v206 = nw_parameters_get_effective_bundle_id(v360);
              *(_DWORD *)buf = 136448514;
              v376 = "nw_endpoint_flow_validate_delegation";
              __int16 v377 = 2082;
              v378 = (char *)v201;
              __int16 v379 = 2082;
              v380 = v200;
              __int16 v381 = 2082;
              nw_endpoint_t v382 = (void *)v202;
              __int16 v383 = 2082;
              v384 = v203;
              __int16 v385 = 2082;
              id v386 = v204;
              __int16 v387 = 2114;
              id v388 = v205;
              __int16 v389 = 2082;
              *(void *)v390 = v206;
              *(_WORD *)&v390[8] = 2082;
              *(void *)&v390[10] = "T";
              *(_WORD *)&v390[18] = 2082;
              *(void *)&v390[20] = v196;
              _os_log_impl( &dword_181A5C000,  v197,  v198,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Fail ure: Invalid Bundle ID %{public}s [%{public}s], dumping backtrace:%{public}s",  buf,  0x66u);
            }

            free(v196);
            goto LABEL_129;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v185 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v275 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            int v276 = nw_endpoint_handler_get_id_string(v182);
            char v277 = nw_endpoint_handler_dry_run_string(v182);
            nw_endpoint_t v278 = nw_endpoint_handler_copy_endpoint(v182);
            v279 = nw_endpoint_get_logging_description(v278);
            v280 = nw_endpoint_handler_state_string(v182);
            nw_endpoint_t v281 = nw_endpoint_handler_mode_string(v182);
            id v282 = nw_endpoint_handler_copy_current_path(v182);
            uint64_t v283 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448258;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)v276;
            __int16 v379 = 2082;
            v380 = v277;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = (void *)v279;
            __int16 v383 = 2082;
            v384 = v280;
            __int16 v385 = 2082;
            id v386 = v281;
            __int16 v387 = 2114;
            id v388 = v282;
            __int16 v389 = 2082;
            *(void *)v390 = v283;
            *(_WORD *)&v390[8] = 2082;
            *(void *)&v390[10] = "T";
            _os_log_impl( &dword_181A5C000,  v185,  v275,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failur e: Invalid Bundle ID %{public}s [%{public}s], no backtrace",  buf,  0x5Cu);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v185 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v207 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            v208 = nw_endpoint_handler_get_id_string(v182);
            v209 = nw_endpoint_handler_dry_run_string(v182);
            nw_endpoint_t v210 = nw_endpoint_handler_copy_endpoint(v182);
            int v211 = nw_endpoint_get_logging_description(v210);
            char v212 = nw_endpoint_handler_state_string(v182);
            v213 = nw_endpoint_handler_mode_string(v182);
            id v214 = nw_endpoint_handler_copy_current_path(v182);
            uint64_t v215 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448258;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)v208;
            __int16 v379 = 2082;
            v380 = v209;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = (void *)v211;
            __int16 v383 = 2082;
            v384 = v212;
            __int16 v385 = 2082;
            id v386 = v213;
            __int16 v387 = 2114;
            id v388 = v214;
            __int16 v389 = 2082;
            *(void *)v390 = v215;
            *(_WORD *)&v390[8] = 2082;
            *(void *)&v390[10] = "T";
            _os_log_impl( &dword_181A5C000,  v185,  v207,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failur e: Invalid Bundle ID %{public}s [%{public}s], backtrace limit exceeded",  buf,  0x5Cu);
          }
        }

LABEL_129:
        id v4 = v361;
        if (v119) {
          free(v119);
        }
        goto LABEL_168;
      }

      if ((v26 & 0x20) != 0) {
        goto LABEL_168;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v59 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        BOOL v85 = nw_endpoint_handler_get_id_string(v25);
        uint64_t v86 = nw_endpoint_handler_dry_run_string(v25);
        nw_endpoint_t v87 = nw_endpoint_handler_copy_endpoint(v25);
        nw_endpoint_t v88 = nw_endpoint_get_logging_description(v87);
        os_log_type_t v89 = nw_endpoint_handler_state_string(v25);
        os_log_type_t v90 = nw_endpoint_handler_mode_string(v25);
        id v91 = nw_endpoint_handler_copy_current_path(v25);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = (char *)v85;
        __int16 v379 = 2082;
        v380 = v86;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v88;
        __int16 v383 = 2082;
        v384 = v89;
        __int16 v385 = 2082;
        id v386 = v90;
        __int16 v387 = 2114;
        id v388 = v91;
        __int16 v389 = 2082;
        *(void *)v390 = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[8] = 2082;
        *(void *)&v390[10] = "T";
        _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: I nvalid Bundle ID %{public}s [%{public}s]",  buf,  0x5Cu);
      }

      goto LABEL_167;
    }

    if (!pid_to_uuid_mapping_failed) {
      goto LABEL_168;
    }
    int v39 = _os_feature_enabled_impl();
    char logging_disabled = nw_endpoint_handler_get_logging_disabled(v4);
    nw_endpoint_t v361 = v4;
    if (!v39)
    {
      if ((logging_disabled & 1) != 0) {
        goto LABEL_168;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v59 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v95 = nw_endpoint_handler_get_id_string(v4);
        BOOL v96 = nw_endpoint_handler_dry_run_string(v4);
        nw_endpoint_t v97 = nw_endpoint_handler_copy_endpoint(v4);
        os_log_type_t v98 = nw_endpoint_get_logging_description(v97);
        os_log_type_t v99 = nw_endpoint_handler_state_string(v4);
        os_log_type_t v100 = nw_endpoint_handler_mode_string(v4);
        id v101 = nw_endpoint_handler_copy_current_path(v4);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = (char *)v95;
        __int16 v379 = 2082;
        v380 = v96;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v98;
        __int16 v383 = 2082;
        v384 = v99;
        __int16 v385 = 2082;
        id v386 = v100;
        __int16 v387 = 2114;
        id v388 = v101;
        __int16 v389 = 1024;
        *(_DWORD *)v390 = nw_parameters_get_pid(v5);
        *(_WORD *)&v390[4] = 2082;
        *(void *)&v390[6] = "T";
        _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: I nvalid PID %d [%{public}s]",  buf,  0x58u);
      }

      goto LABEL_167;
    }

    if ((logging_disabled & 1) != 0) {
      goto LABEL_168;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v354 = (id)gconnectionLogObj;
    os_log_type_t v41 = nw_endpoint_handler_get_id_string(v4);
    BOOL v42 = nw_endpoint_handler_dry_run_string(v4);
    nw_endpoint_t v43 = nw_endpoint_handler_copy_endpoint(v4);
    os_log_type_t v44 = nw_endpoint_get_logging_description(v43);
    BOOL v45 = nw_endpoint_handler_state_string(v4);
    os_log_type_t v46 = nw_endpoint_handler_mode_string(v4);
    id v47 = nw_endpoint_handler_copy_current_path(v4);
    *(_DWORD *)buf = 136448258;
    v376 = "nw_endpoint_flow_validate_delegation";
    __int16 v377 = 2082;
    v378 = (char *)v41;
    __int16 v379 = 2082;
    v380 = v42;
    __int16 v381 = 2082;
    nw_endpoint_t v382 = (void *)v44;
    __int16 v383 = 2082;
    v384 = v45;
    __int16 v385 = 2082;
    id v386 = v46;
    __int16 v387 = 2114;
    id v388 = v47;
    __int16 v389 = 1024;
    *(_DWORD *)v390 = nw_parameters_get_pid(v5);
    *(_WORD *)&v390[4] = 2082;
    *(void *)&v390[6] = "T";
    os_log_t log = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v374 = 0;
    os_log_type_t v48 = (char *)log;
    if ((__nwlog_fault(log, type, &v374) & 1) == 0)
    {
LABEL_247:
      id v4 = v361;
      if (v48) {
        free(v48);
      }
LABEL_168:
LABEL_234:
      uint64_t v9 = 1LL;
      id v5 = v360;
      goto LABEL_235;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v49 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v50 = type[0];
      if (os_log_type_enabled(v49, type[0]))
      {
        __int16 v51 = nw_endpoint_handler_get_id_string(v4);
        uint64_t v52 = nw_endpoint_handler_dry_run_string(v361);
        nw_endpoint_t v53 = nw_endpoint_handler_copy_endpoint(v361);
        id v54 = nw_endpoint_get_logging_description(v53);
        uint64_t v55 = nw_endpoint_handler_state_string(v361);
        __int16 v56 = nw_endpoint_handler_mode_string(v361);
        id v57 = nw_endpoint_handler_copy_current_path(v361);
        int v58 = nw_parameters_get_pid(v5);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = (char *)v51;
        __int16 v379 = 2082;
        v380 = v52;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v54;
        __int16 v383 = 2082;
        v384 = v55;
        __int16 v385 = 2082;
        id v386 = v56;
        __int16 v387 = 2114;
        id v388 = v57;
        __int16 v389 = 1024;
        *(_DWORD *)v390 = v58;
        *(_WORD *)&v390[4] = 2082;
        *(void *)&v390[6] = "T";
        _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: I nvalid PID %d [%{public}s]",  buf,  0x58u);
      }
    }

    else if (v374)
    {
      uint64_t v153 = __nw_create_backtrace_string();
      if (v153)
      {
        uint64_t v154 = (char *)v153;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v155 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v156 = type[0];
        if (os_log_type_enabled(v155, type[0]))
        {
          v157 = nw_endpoint_handler_get_id_string(v4);
          v158 = nw_endpoint_handler_dry_run_string(v4);
          nw_endpoint_t v357 = nw_endpoint_handler_copy_endpoint(v361);
          v159 = nw_endpoint_get_logging_description(v357);
          v160 = nw_endpoint_handler_state_string(v361);
          v161 = nw_endpoint_handler_mode_string(v361);
          id v162 = nw_endpoint_handler_copy_current_path(v361);
          int v163 = nw_parameters_get_pid(v5);
          *(_DWORD *)buf = 136448514;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v157;
          __int16 v379 = 2082;
          v380 = v158;
          __int16 v381 = 2082;
          nw_endpoint_t v382 = (void *)v159;
          __int16 v383 = 2082;
          v384 = v160;
          __int16 v385 = 2082;
          id v386 = v161;
          __int16 v387 = 2114;
          id v388 = v162;
          __int16 v389 = 1024;
          *(_DWORD *)v390 = v163;
          *(_WORD *)&v390[4] = 2082;
          *(void *)&v390[6] = "T";
          *(_WORD *)&v390[14] = 2082;
          *(void *)&v390[16] = v154;
          _os_log_impl( &dword_181A5C000,  v155,  v156,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d [%{public}s], dumping backtrace:%{public}s",  buf,  0x62u);
        }

        free(v154);
        goto LABEL_246;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v49 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v310 = type[0];
      if (os_log_type_enabled(v49, type[0]))
      {
        id v311 = nw_endpoint_handler_get_id_string(v4);
        v312 = nw_endpoint_handler_dry_run_string(v361);
        nw_endpoint_t v313 = nw_endpoint_handler_copy_endpoint(v361);
        BOOL v314 = nw_endpoint_get_logging_description(v313);
        v315 = nw_endpoint_handler_state_string(v361);
        os_log_type_t v316 = nw_endpoint_handler_mode_string(v361);
        id v317 = nw_endpoint_handler_copy_current_path(v361);
        int v318 = nw_parameters_get_pid(v5);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = (char *)v311;
        __int16 v379 = 2082;
        v380 = v312;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v314;
        __int16 v383 = 2082;
        v384 = v315;
        __int16 v385 = 2082;
        id v386 = v316;
        __int16 v387 = 2114;
        id v388 = v317;
        __int16 v389 = 1024;
        *(_DWORD *)v390 = v318;
        *(_WORD *)&v390[4] = 2082;
        *(void *)&v390[6] = "T";
        _os_log_impl( &dword_181A5C000,  v49,  v310,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: I nvalid PID %d [%{public}s], no backtrace",  buf,  0x58u);
      }
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v49 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v301 = type[0];
      if (os_log_type_enabled(v49, type[0]))
      {
        v302 = nw_endpoint_handler_get_id_string(v4);
        int v303 = nw_endpoint_handler_dry_run_string(v361);
        nw_endpoint_t v304 = nw_endpoint_handler_copy_endpoint(v361);
        v305 = nw_endpoint_get_logging_description(v304);
        v306 = nw_endpoint_handler_state_string(v361);
        nw_endpoint_t v307 = nw_endpoint_handler_mode_string(v361);
        id v308 = nw_endpoint_handler_copy_current_path(v361);
        int v309 = nw_parameters_get_pid(v5);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = (char *)v302;
        __int16 v379 = 2082;
        v380 = v303;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v305;
        __int16 v383 = 2082;
        v384 = v306;
        __int16 v385 = 2082;
        id v386 = v307;
        __int16 v387 = 2114;
        id v388 = v308;
        __int16 v389 = 1024;
        *(_DWORD *)v390 = v309;
        *(_WORD *)&v390[4] = 2082;
        *(void *)&v390[6] = "T";
        _os_log_impl( &dword_181A5C000,  v49,  v301,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: I nvalid PID %d [%{public}s], backtrace limit exceeded",  buf,  0x58u);
      }
    }

LABEL_246:
    os_log_type_t v48 = (char *)log;
    goto LABEL_247;
  }

  pid_t v8 = getpid();
  if (!nw_parameters_has_delegated_proc_pid(v5, v8) && !nw_parameters_has_delegated_proc_uuid(v5))
  {
    v360 = v5;
    if (!nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist
      || object_getClass((id)nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist) != (Class)MEMORY[0x1895F9220])
    {
      int v71 = 0;
      goto LABEL_54;
    }

    v363 = v4;
    nw_endpoint_t v108 = nw_endpoint_handler_copy_endpoint(v4);
    BOOL domain_for_policy = nw_endpoint_get_domain_for_policy(v108);
    BOOL v110 = domain_for_policy;
    if (domain_for_policy)
    {
      *(void *)os_log_type_t type = 0LL;
      v371 = type;
      uint64_t v372 = 0x2020000000LL;
      char v373 = 0;
      BOOL v111 = (void *)nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist;
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = ___ZL36nw_endpoint_flow_validate_delegationP30NWConcrete_nw_endpoint_handler_block_invoke_214;
      applier[3] = &unk_189BC7A18;
      size_t v368 = strlen((const char *)domain_for_policy);
      BOOL v369 = v110;
      os_log_type_t v112 = v4;
      v366 = v112;
      v367 = type;
      xpc_array_apply(v111, applier);
      if (*((_BYTE *)v371 + 24))
      {

        _Block_object_dispose(type, 8);
        goto LABEL_234;
      }

      if ((nw_endpoint_handler_get_logging_disabled(v112) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v284 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v284, OS_LOG_TYPE_ERROR))
        {
          id v285 = nw_endpoint_handler_get_id_string(v112);
          v286 = nw_endpoint_handler_dry_run_string(v112);
          nw_endpoint_t v287 = nw_endpoint_handler_copy_endpoint(v112);
          v288 = nw_endpoint_get_logging_description(v287);
          uint64_t v289 = nw_endpoint_handler_state_string(v112);
          v290 = nw_endpoint_handler_mode_string(v112);
          id v291 = nw_endpoint_handler_copy_current_path(v112);
          *(_DWORD *)buf = 136448002;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v285;
          __int16 v379 = 2082;
          v380 = v286;
          __int16 v381 = 2082;
          nw_endpoint_t v382 = (void *)v288;
          __int16 v383 = 2082;
          v384 = v289;
          __int16 v385 = 2082;
          id v386 = v290;
          __int16 v387 = 2114;
          id v388 = v291;
          __int16 v389 = 2082;
          *(void *)v390 = v110;
          _os_log_impl( &dword_181A5C000,  v284,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Domain %{public}s was n ot found within allowlist for non-delegated connections",  buf,  0x52u);
        }
      }

      _Block_object_dispose(type, 8);
    }

    else if ((nw_endpoint_handler_get_logging_disabled(v4) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_endpoint_t v174 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
      {
        v175 = nw_endpoint_handler_get_id_string(v4);
        v176 = nw_endpoint_handler_dry_run_string(v4);
        nw_endpoint_t v177 = nw_endpoint_handler_copy_endpoint(v363);
        uint64_t v178 = nw_endpoint_get_logging_description(v177);
        v179 = nw_endpoint_handler_state_string(v363);
        v180 = nw_endpoint_handler_mode_string(v363);
        id v181 = nw_endpoint_handler_copy_current_path(v363);
        *(_DWORD *)buf = 136447746;
        v376 = "nw_endpoint_flow_validate_delegation";
        __int16 v377 = 2082;
        v378 = (char *)v175;
        __int16 v379 = 2082;
        v380 = v176;
        __int16 v381 = 2082;
        nw_endpoint_t v382 = (void *)v178;
        __int16 v383 = 2082;
        v384 = v179;
        __int16 v385 = 2082;
        id v386 = v180;
        __int16 v387 = 2114;
        id v388 = v181;
        _os_log_impl( &dword_181A5C000,  v174,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No domain found for connectio n to allowlist non-delegated connections",  buf,  0x48u);
      }
    }

    int v71 = 1;
    id v4 = v363;
LABEL_54:
    if (!_os_feature_enabled_impl())
    {
      if (!v71) {
        goto LABEL_234;
      }
      goto LABEL_169;
    }

    v362 = v4;
    char v346 = v71;
    nw_endpoint_t v355 = nw_endpoint_handler_copy_endpoint(v4);
    BOOL loga = nw_endpoint_get_domain_for_policy(v355);
    id v72 = v4;
    BOOL v73 = (*((_BYTE *)v72 + 268) & 0x20) == 0;

    if (!v73)
    {
LABEL_233:

      id v4 = v362;
      if ((v346 & 1) == 0) {
        goto LABEL_234;
      }
LABEL_169:
      v219 = v4;
      BOOL v220 = (*((_BYTE *)v219 + 268) & 0x20) == 0;

      if (v220)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v221 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v221, OS_LOG_TYPE_ERROR))
        {
          v222 = v219;

          int v223 = v222;
          BOOL v224 = (*((_BYTE *)v219 + 268) & 1) == 0;

          if (v224) {
            v225 = "";
          }
          else {
            v225 = "dry-run ";
          }
          nw_endpoint_t v226 = nw_endpoint_handler_copy_endpoint(v223);
          v227 = nw_endpoint_get_logging_description(v226);
          nw_endpoint_t v228 = v223;
          v229 = v228;
          uint64_t v230 = v228[30];
          else {
            v231 = off_189BBBBF0[v230];
          }

          id v232 = v229;
          int v233 = "path";
          switch(v364->mode)
          {
            case 0:
              break;
            case 1:
              int v233 = "resolver";
              break;
            case 2:
              int v233 = nw_endpoint_flow_mode_string(v232[31]);
              break;
            case 3:
              int v233 = "proxy";
              break;
            case 4:
              int v233 = "fallback";
              break;
            case 5:
              int v233 = "transform";
              break;
            default:
              int v233 = "unknown-mode";
              break;
          }

          v359 = v233;

          nw_endpoint_t v234 = v226;
          v235 = v231;
          v236 = v227;
          v237 = v232;
          os_unfair_lock_lock((os_unfair_lock_t)v237 + 28);
          id v238 = v237[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v237 + 28);

          *(_DWORD *)buf = 136447746;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)(v222 + 21);
          __int16 v379 = 2082;
          v380 = v225;
          __int16 v381 = 2082;
          nw_endpoint_t v382 = (void *)v236;
          __int16 v383 = 2082;
          v384 = v235;
          __int16 v385 = 2082;
          id v386 = v359;
          __int16 v387 = 2114;
          id v388 = v238;
          _os_log_impl( &dword_181A5C000,  v221,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failing connection due to d elegation errors",  buf,  0x48u);
        }
      }

      id v5 = v360;
      nw_endpoint_flow_failed_with_error(v219, 1, 0LL);
      uint64_t v9 = 0LL;
      goto LABEL_235;
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v74 = (id)gconnectionLogObj;
    os_log_type_t v75 = v72;

    __int16 v76 = v75;
    BOOL v77 = (*((_BYTE *)v72 + 268) & 1) == 0;

    if (v77) {
      __int16 v78 = "";
    }
    else {
      __int16 v78 = "dry-run ";
    }
    nw_endpoint_t v79 = nw_endpoint_handler_copy_endpoint(v76);
    __int16 v80 = nw_endpoint_get_logging_description(v79);
    id v81 = v76;
    id v82 = v81;
    uint64_t v83 = v81[30];
    else {
      id v84 = off_189BBBBF0[v83];
    }

    v113 = v82;
    id v114 = v113;
    os_log_type_t v115 = "path";
    switch(v364->mode)
    {
      case 0:
        break;
      case 1:
        os_log_type_t v115 = "resolver";
        break;
      case 2:
        os_log_type_t v115 = nw_endpoint_flow_mode_string(v113[31]);
        break;
      case 3:
        os_log_type_t v115 = "proxy";
        break;
      case 4:
        os_log_type_t v115 = "fallback";
        break;
      case 5:
        os_log_type_t v115 = "transform";
        break;
      default:
        os_log_type_t v115 = "unknown-mode";
        break;
    }

    v239 = v114;
    os_unfair_lock_lock((os_unfair_lock_t)v239 + 28);
    id v240 = v239[8];
    os_unfair_lock_unlock((os_unfair_lock_t)v239 + 28);

    id v241 = v240;
    description = nw_endpoint_get_description(v355);
    *(_DWORD *)buf = 136448258;
    v376 = "nw_endpoint_flow_validate_delegation";
    __int16 v377 = 2082;
    v378 = (char *)(v75 + 21);
    __int16 v379 = 2082;
    v380 = v78;
    __int16 v381 = 2082;
    nw_endpoint_t v382 = (void *)v80;
    __int16 v383 = 2082;
    v384 = v84;
    __int16 v385 = 2082;
    id v386 = v115;
    __int16 v387 = 2114;
    id v388 = v241;
    __int16 v389 = 2080;
    *(void *)v390 = loga;
    *(_WORD *)&v390[8] = 2080;
    *(void *)&v390[10] = description;
    v243 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v374 = 0;
    if (__nwlog_fault(v243, type, &v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v244 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v245 = type[0];
        if (os_log_type_enabled(v244, type[0]))
        {
          int v246 = nw_endpoint_handler_get_id_string(v239);
          char v247 = nw_endpoint_handler_dry_run_string(v239);
          v343 = v244;
          nw_endpoint_t v248 = nw_endpoint_handler_copy_endpoint(v239);
          char v249 = v246;
          v250 = nw_endpoint_get_logging_description(v248);
          v251 = nw_endpoint_handler_state_string(v239);
          v252 = nw_endpoint_handler_mode_string(v239);
          id v253 = nw_endpoint_handler_copy_current_path(v239);
          v254 = nw_endpoint_get_description(v355);
          *(_DWORD *)buf = 136448258;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v249;
          __int16 v379 = 2082;
          v380 = v247;
          __int16 v381 = 2082;
          nw_endpoint_t v382 = (void *)v250;
          __int16 v383 = 2082;
          v384 = v251;
          __int16 v385 = 2082;
          id v386 = v252;
          __int16 v387 = 2114;
          id v388 = v253;
          __int16 v389 = 2080;
          *(void *)v390 = loga;
          *(_WORD *)&v390[8] = 2080;
          *(void *)&v390[10] = v254;
          _os_log_impl( &dword_181A5C000,  v343,  v245,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traffic : Connection to %s (%s)",  buf,  0x5Cu);

          v244 = v343;
        }
      }

      else if (v374)
      {
        v255 = __nw_create_backtrace_string();
        if (v255)
        {
          v256 = (char *)v255;
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v257 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v258 = type[0];
          if (os_log_type_enabled(v257, type[0]))
          {
            v259 = nw_endpoint_handler_get_id_string(v239);
            v341 = nw_endpoint_handler_dry_run_string(v239);
            nw_endpoint_t v342 = nw_endpoint_handler_copy_endpoint(v239);
            uint64_t v260 = v259;
            int v261 = nw_endpoint_get_logging_description(v342);
            char v262 = nw_endpoint_handler_state_string(v239);
            v263 = nw_endpoint_handler_mode_string(v239);
            id v264 = nw_endpoint_handler_copy_current_path(v239);
            v265 = nw_endpoint_get_description(v355);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            __int16 v377 = 2082;
            v378 = (char *)v260;
            __int16 v379 = 2082;
            v380 = v341;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = (void *)v261;
            __int16 v383 = 2082;
            v384 = v262;
            __int16 v385 = 2082;
            id v386 = v263;
            __int16 v387 = 2114;
            id v388 = v264;
            __int16 v389 = 2080;
            *(void *)v390 = loga;
            *(_WORD *)&v390[8] = 2080;
            *(void *)&v390[10] = v265;
            *(_WORD *)&v390[18] = 2082;
            *(void *)&v390[20] = v256;
            _os_log_impl( &dword_181A5C000,  v257,  v258,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traff ic: Connection to %s (%s), dumping backtrace:%{public}s",  buf,  0x66u);
          }

          free(v256);
          goto LABEL_231;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v244 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v292 = type[0];
        if (os_log_type_enabled(v244, type[0]))
        {
          v293 = nw_endpoint_handler_get_id_string(v239);
          os_log_type_t v294 = nw_endpoint_handler_dry_run_string(v239);
          v345 = v244;
          nw_endpoint_t v295 = nw_endpoint_handler_copy_endpoint(v239);
          os_log_type_t v296 = nw_endpoint_get_logging_description(v295);
          v297 = nw_endpoint_handler_state_string(v239);
          os_log_type_t v298 = nw_endpoint_handler_mode_string(v239);
          id v299 = nw_endpoint_handler_copy_current_path(v239);
          uint64_t v300 = nw_endpoint_get_description(v355);
          *(_DWORD *)buf = 136448258;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v293;
          __int16 v379 = 2082;
          v380 = v294;
          __int16 v381 = 2082;
          nw_endpoint_t v382 = (void *)v296;
          __int16 v383 = 2082;
          v384 = v297;
          __int16 v385 = 2082;
          id v386 = v298;
          __int16 v387 = 2114;
          id v388 = v299;
          __int16 v389 = 2080;
          *(void *)v390 = loga;
          *(_WORD *)&v390[8] = 2080;
          *(void *)&v390[10] = v300;
          _os_log_impl( &dword_181A5C000,  v345,  v292,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traffic : Connection to %s (%s), no backtrace",  buf,  0x5Cu);

          v244 = v345;
        }
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v244 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v266 = type[0];
        if (os_log_type_enabled(v244, type[0]))
        {
          v267 = nw_endpoint_handler_get_id_string(v239);
          v268 = nw_endpoint_handler_dry_run_string(v239);
          id v344 = v244;
          nw_endpoint_t v269 = nw_endpoint_handler_copy_endpoint(v239);
          id v270 = nw_endpoint_get_logging_description(v269);
          id v271 = nw_endpoint_handler_state_string(v239);
          v272 = nw_endpoint_handler_mode_string(v239);
          id v273 = nw_endpoint_handler_copy_current_path(v239);
          v274 = nw_endpoint_get_description(v355);
          *(_DWORD *)buf = 136448258;
          v376 = "nw_endpoint_flow_validate_delegation";
          __int16 v377 = 2082;
          v378 = (char *)v267;
          __int16 v379 = 2082;
          v380 = v268;
          __int16 v381 = 2082;
          nw_endpoint_t v382 = (void *)v270;
          __int16 v383 = 2082;
          v384 = v271;
          __int16 v385 = 2082;
          id v386 = v272;
          __int16 v387 = 2114;
          id v388 = v273;
          __int16 v389 = 2080;
          *(void *)v390 = loga;
          *(_WORD *)&v390[8] = 2080;
          *(void *)&v390[10] = v274;
          _os_log_impl( &dword_181A5C000,  v344,  v266,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traffic : Connection to %s (%s), backtrace limit exceeded",  buf,  0x5Cu);

          v244 = v344;
        }
      }
    }

            goto LABEL_168;
          }

          if (!(_BYTE)v115)
          {
            __nwlog_obj();
            uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v93 = type[0];
            if (os_log_type_enabled(v52, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
              _os_log_impl( &dword_181A5C000,  v52,  v93,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_167;
          }

          uint64_t v69 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v74 = type[0];
          os_log_type_t v75 = os_log_type_enabled(v52, type[0]);
          if (!v69)
          {
            if (v75)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
              _os_log_impl( &dword_181A5C000,  v52,  v74,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
            }

            goto LABEL_167;
          }

          if (v75)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v69;
            _os_log_impl( &dword_181A5C000,  v52,  v74,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          goto LABEL_106;
        }

  __break(1u);
  return result;
}

            _os_log_impl(&dword_181A5C000, v74, v75, v76, buf, 0x2Au);
            goto LABEL_168;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v71 = gLogObj;
          id v72 = v278;
          if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v278))
          {
            BOOL v73 = *(void *)(v17 + 200);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = "ohttp_context->aead_chunk_index";
            *(_WORD *)&buf[22] = 2048;
            id v285 = 1LL;
            *(_WORD *)v286 = 2048;
            *(void *)&v286[2] = v73;
            id v74 = (os_log_s *)v71;
            os_log_type_t v75 = v72;
            __int16 v76 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
            goto LABEL_167;
          }
        }

      _os_log_impl(&dword_181A5C000, v97, v98, v99, v227, 0xCu);
      goto LABEL_168;
    }

      if (v95) {
        free(v95);
      }
      unint64_t v107 = *(void *)(v91 + 112);
      nw_endpoint_t v108 = *(void **)(v91 + 120);
      if (v107)
      {
        *(void *)(v107 + 120) = v108;
        nw_endpoint_t v108 = *(void **)(v91 + 120);
      }

      else
      {
        *(void *)(v171 + 336) = v108;
      }

      *nw_endpoint_t v108 = v107;
      *(void *)(v91 + 112) = 0LL;
      *(void *)(v91 + 120) = 0LL;
      os_log_type_t v109 = v180[3];
      id v5 = &qword_18C45F000;
      if (v109)
      {
        if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v110 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            BOOL v111 = *(void *)(v109 + 88);
            if (v111) {
              os_log_type_t v112 = *(_DWORD *)(v111 + 460);
            }
            else {
              os_log_type_t v112 = -1;
            }
            v113 = *(void *)(v109 + 64);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
            os_log_type_t v186 = 2082;
            v187 = (const char *)(v109 + 192);
            id v188 = 2080;
            nw_endpoint_t v189 = (uint64_t)" ";
            v190 = 1024;
            *(_DWORD *)v191 = v112;
            *(_WORD *)&v191[4] = 2048;
            *(void *)&v191[6] = v113;
            *(_WORD *)&v191[14] = 2048;
            *(void *)&v191[16] = v109;
            _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p",  buf,  0x3Au);
          }
        }

        if (*(void *)(v109 + 72))
        {
          if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v114 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v115 = *(void *)(v109 + 88);
              if (v115) {
                __int16 v116 = *(_DWORD *)(v115 + 460);
              }
              else {
                __int16 v116 = -1;
              }
              id v117 = *(void *)(v109 + 64);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
              os_log_type_t v186 = 2082;
              v187 = (const char *)(v109 + 192);
              id v188 = 2080;
              nw_endpoint_t v189 = (uint64_t)" ";
              v190 = 1024;
              *(_DWORD *)v191 = v116;
              *(_WORD *)&v191[4] = 2048;
              *(void *)&v191[6] = v117;
              _os_log_impl( &dword_181A5C000,  v114,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying",  buf,  0x30u);
            }
          }
        }

        id v118 = *(void *)(v109 + 72);
        if (v118)
        {
          do
          {
            nw_endpoint_t v119 = *(void *)(v118 + 32);
            nw_frame_finalize(v118);
            id v118 = v119;
          }

          while (v119);
        }

        (*(void (**)(void, void))(*(void *)(v109 + 176) + 16LL))(*(void *)(v109 + 176), 0LL);
        __int16 v120 = *(const void **)(v109 + 176);
        if (v120)
        {
          _Block_release(v120);
          *(void *)(v109 + 176) = 0LL;
        }

        if ((*(_BYTE *)(v109 + 168) & 1) != 0)
        {
          os_log_type_t v121 = *(void **)(v109 + 160);
          if (v121) {
            os_release(v121);
          }
        }

        *(void *)(v109 + 160) = 0LL;
        if ((*(_BYTE *)(v109 + 152) & 1) != 0)
        {
          __int16 v122 = *(void **)(v109 + 144);
          if (v122) {
            os_release(v122);
          }
        }

        *(void *)(v109 + 144) = 0LL;
        if ((*(_BYTE *)(v109 + 136) & 1) != 0)
        {
          id v123 = *(void **)(v109 + 128);
          if (v123) {
            os_release(v123);
          }
        }

      if (v95) {
        free(v95);
      }
      unint64_t v107 = *(void *)(v91 + 112);
      nw_endpoint_t v108 = *(void **)(v91 + 120);
      if (v107)
      {
        *(void *)(v107 + 120) = v108;
        nw_endpoint_t v108 = *(void **)(v91 + 120);
      }

      else
      {
        *(void *)(v171 + 336) = v108;
      }

      *nw_endpoint_t v108 = v107;
      *(void *)(v91 + 112) = 0LL;
      *(void *)(v91 + 120) = 0LL;
      os_log_type_t v109 = v180[3];
      id v5 = &qword_18C45F000;
      if (v109)
      {
        if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v110 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            BOOL v111 = *(void *)(v109 + 88);
            if (v111) {
              os_log_type_t v112 = *(_DWORD *)(v111 + 460);
            }
            else {
              os_log_type_t v112 = -1;
            }
            v113 = *(void *)(v109 + 64);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
            os_log_type_t v186 = 2082;
            v187 = (const char *)(v109 + 192);
            id v188 = 2080;
            nw_endpoint_t v189 = (uint64_t)" ";
            v190 = 1024;
            *(_DWORD *)v191 = v112;
            *(_WORD *)&v191[4] = 2048;
            *(void *)&v191[6] = v113;
            *(_WORD *)&v191[14] = 2048;
            *(void *)&v191[16] = v109;
            _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p",  buf,  0x3Au);
          }
        }

        if (*(void *)(v109 + 72))
        {
          if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v114 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v115 = *(void *)(v109 + 88);
              if (v115) {
                __int16 v116 = *(_DWORD *)(v115 + 460);
              }
              else {
                __int16 v116 = -1;
              }
              id v117 = *(void *)(v109 + 64);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
              os_log_type_t v186 = 2082;
              v187 = (const char *)(v109 + 192);
              id v188 = 2080;
              nw_endpoint_t v189 = (uint64_t)" ";
              v190 = 1024;
              *(_DWORD *)v191 = v116;
              *(_WORD *)&v191[4] = 2048;
              *(void *)&v191[6] = v117;
              _os_log_impl( &dword_181A5C000,  v114,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying",  buf,  0x30u);
            }
          }
        }

        id v118 = *(void *)(v109 + 72);
        if (v118)
        {
          do
          {
            nw_endpoint_t v119 = *(void *)(v118 + 32);
            nw_frame_finalize(v118);
            id v118 = v119;
          }

          while (v119);
        }

        (*(void (**)(void, void))(*(void *)(v109 + 176) + 16LL))(*(void *)(v109 + 176), 0LL);
        __int16 v120 = *(const void **)(v109 + 176);
        if (v120)
        {
          _Block_release(v120);
          *(void *)(v109 + 176) = 0LL;
        }

        if ((*(_BYTE *)(v109 + 168) & 1) != 0)
        {
          os_log_type_t v121 = *(void **)(v109 + 160);
          if (v121) {
            os_release(v121);
          }
        }

        *(void *)(v109 + 160) = 0LL;
        if ((*(_BYTE *)(v109 + 152) & 1) != 0)
        {
          __int16 v122 = *(void **)(v109 + 144);
          if (v122) {
            os_release(v122);
          }
        }

        *(void *)(v109 + 144) = 0LL;
        if ((*(_BYTE *)(v109 + 136) & 1) != 0)
        {
          id v123 = *(void **)(v109 + 128);
          if (v123) {
            os_release(v123);
          }
        }

          if (v88) {
            free(v88);
          }
          goto LABEL_60;
        }

        *(_DWORD *)buf = 136446210;
        BOOL v92 = "nw_webtransport_stream_allocate_new_id";
        uint64_t v22 = "%{public}s called with null webtransport_session, no backtrace";
      }

      else
      {
        BOOL v20 = (os_log_s *)__nwlog_obj();
        uint64_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_162;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v92 = "nw_webtransport_stream_allocate_new_id";
        uint64_t v22 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      goto LABEL_162;
    }

    if ((handle[276] & 2) != 0)
    {
      *((_DWORD *)handle + 47) = 3;
      BOOL v14 = *((_DWORD *)handle + 47);
      if (!v14) {
        goto LABEL_33;
      }
    }

    else
    {
      *((_DWORD *)handle + 46) = 3;
      BOOL v14 = *((_DWORD *)handle + 47);
      if (!v14) {
        goto LABEL_33;
      }
    }

  if (v55) {
    free(v55);
  }
LABEL_28:
  if (v14 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    v38 = *(void *)(a1 + 88);
    if (v38)
    {
      int v39 = v38 - 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v39;
      if (!v39)
      {
        BOOL v40 = *(void (***)(void))(a1 + 64);
        if (v40)
        {
          *(void *)(a1 + 64) = 0LL;
          v40[2](v40);
          _Block_release(v40);
        }

        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          os_log_type_t v41 = *(const void **)(a1 + 64);
          if (v41) {
            _Block_release(v41);
          }
        }

        free((void *)a1);
      }
    }
  }

  if (v12 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v11 + 40) == &nw_protocol_ref_counted_handle)
  {
    nw_endpoint_t v18 = *(void *)(v11 + 88);
    if (v18)
    {
      id v19 = v18 - 1;
      *(void *)(v11 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v19;
      if (!v19)
      {
        BOOL v20 = *(void (***)(void))(v11 + 64);
        if (v20)
        {
          *(void *)(v11 + 64) = 0LL;
          v20[2](v20);
          _Block_release(v20);
        }

        if ((*(_BYTE *)(v11 + 72) & 1) != 0)
        {
          uint64_t v21 = *(const void **)(v11 + 64);
          if (v21) {
            _Block_release(v21);
          }
        }

        uint64_t v22 = (char *)v11;
        goto LABEL_74;
      }
    }
  }

        if (v83) {
          free(v83);
        }
        return;
      }

      __int16 v7 = *(id *)(a1 + 32);
      pid_t v8 = v6;
      if (!v7)
      {
        __nwlog_obj();
        uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)nw_endpoint_t v132 = 136446210;
        *(void *)&v132[4] = "nw_connection_add_activity_on_nw_queue";
        nw_endpoint_t v87 = (char *)_os_log_send_and_compose_impl();

        buf[0] = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v87, buf, &type))
        {
          if (buf[0] == 17)
          {
            __nwlog_obj();
            nw_endpoint_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v89 = buf[0];
            if (os_log_type_enabled(v88, (os_log_type_t)buf[0]))
            {
              *(_DWORD *)nw_endpoint_t v132 = 136446210;
              *(void *)&v132[4] = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl(&dword_181A5C000, v88, v89, "%{public}s called with null connection", v132, 0xCu);
            }
          }

          else if (type)
          {
            nw_endpoint_t v97 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            nw_endpoint_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v98 = buf[0];
            os_log_type_t v99 = os_log_type_enabled(v88, (os_log_type_t)buf[0]);
            if (v97)
            {
              if (v99)
              {
                *(_DWORD *)nw_endpoint_t v132 = 136446466;
                *(void *)&v132[4] = "nw_connection_add_activity_on_nw_queue";
                *(_WORD *)&v132[12] = 2082;
                *(void *)&v132[14] = v97;
                _os_log_impl( &dword_181A5C000,  v88,  v98,  "%{public}s called with null connection, dumping backtrace:%{public}s",  v132,  0x16u);
              }

              free(v97);
              goto LABEL_172;
            }

            if (v99)
            {
              *(_DWORD *)nw_endpoint_t v132 = 136446210;
              *(void *)&v132[4] = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v88,  v98,  "%{public}s called with null connection, no backtrace",  v132,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            nw_endpoint_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v110 = buf[0];
            if (os_log_type_enabled(v88, (os_log_type_t)buf[0]))
            {
              *(_DWORD *)nw_endpoint_t v132 = 136446210;
              *(void *)&v132[4] = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v88,  v110,  "%{public}s called with null connection, backtrace limit exceeded",  v132,  0xCu);
            }
          }
        }

            if (v59) {
              free(v59);
            }
            goto LABEL_20;
          }

          __nwlog_obj();
          os_log_type_t v41 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
          BOOL v36 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          id v91 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v42 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl(&dword_181A5C000, v37, v42, "%{public}s called with null create_function", buf, 0xCu);
            }

            goto LABEL_194;
          }

          if (!v91)
          {
            __nwlog_obj();
            uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v90 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl( &dword_181A5C000,  v37,  v90,  "%{public}s called with null create_function, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_194;
          }

          nw_endpoint_t v79 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v82 = type;
          uint64_t v83 = os_log_type_enabled(v37, type);
          if (!v79)
          {
            if (v83)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl( &dword_181A5C000,  v37,  v82,  "%{public}s called with null create_function, no backtrace",  buf,  0xCu);
            }

            goto LABEL_194;
          }

          if (v83)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
            os_log_type_t v95 = 2082;
            *(void *)BOOL v96 = v79;
            _os_log_impl( &dword_181A5C000,  v37,  v82,  "%{public}s called with null create_function, dumping backtrace:%{public}s",  buf,  0x16u);
          }
        }

        else
        {
          __nwlog_obj();
          int v39 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
          BOOL v36 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          id v91 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v40 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl( &dword_181A5C000,  v37,  v40,  "%{public}s called with null nw_protocol_definition_is_framer(framer_definition)",  buf,  0xCu);
            }

            goto LABEL_194;
          }

          if (!v91)
          {
            __nwlog_obj();
            uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v89 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl( &dword_181A5C000,  v37,  v89,  "%{public}s called with null nw_protocol_definition_is_framer(framer_definition), backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_194;
          }

          nw_endpoint_t v79 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v80 = type;
          id v81 = os_log_type_enabled(v37, type);
          if (!v79)
          {
            if (v81)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl( &dword_181A5C000,  v37,  v80,  "%{public}s called with null nw_protocol_definition_is_framer(framer_definition), no backtrace",  buf,  0xCu);
            }

            goto LABEL_194;
          }

          if (v81)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
            os_log_type_t v95 = 2082;
            *(void *)BOOL v96 = v79;
            _os_log_impl( &dword_181A5C000,  v37,  v80,  "%{public}s called with null nw_protocol_definition_is_framer(framer_definition), dumping backtrace:%{public}s",  buf,  0x16u);
          }
        }

        free(v79);
        if (!v36) {
          goto LABEL_21;
        }
        goto LABEL_196;
      }

      __nwlog_obj();
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
      BOOL v36 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      id v91 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
          _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null framer_definition", buf, 0xCu);
        }
      }

      else if (v91)
      {
        __int16 v76 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v77 = type;
        __int16 v78 = os_log_type_enabled(v37, type);
        if (v76)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
            os_log_type_t v95 = 2082;
            *(void *)BOOL v96 = v76;
            _os_log_impl( &dword_181A5C000,  v37,  v77,  "%{public}s called with null framer_definition, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v76);
LABEL_195:
          if (!v36) {
            goto LABEL_21;
          }
LABEL_196:
          free(v36);
          goto LABEL_21;
        }

        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
          _os_log_impl( &dword_181A5C000,  v37,  v77,  "%{public}s called with null framer_definition, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_endpoint_t v88 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v94 = "nw_agent_client_attach_protocol_block_invoke";
          _os_log_impl( &dword_181A5C000,  v37,  v88,  "%{public}s called with null framer_definition, backtrace limit exceeded",  buf,  0xCu);
        }
      }

    if (v114) {
      free(v114);
    }
    goto LABEL_237;
  }

  nw_endpoint_t v108 = v3;
  __nwlog_obj();
  os_log_type_t v109 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v219 = "nw_endpoint_flow_rebuild_stack";
  BOOL v110 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v214) = 0;
  if (__nwlog_fault(v110, type, &v214))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v112 = type[0];
      if (os_log_type_enabled(v111, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v219 = "nw_endpoint_flow_rebuild_stack";
        _os_log_impl(&dword_181A5C000, v111, v112, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)v214)
    {
      os_log_type_t v121 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v122 = type[0];
      id v123 = os_log_type_enabled(v111, type[0]);
      if (v121)
      {
        if (v123)
        {
          *(_DWORD *)buf = 136446466;
          v219 = "nw_endpoint_flow_rebuild_stack";
          BOOL v220 = 2082;
          v221 = v121;
          _os_log_impl( &dword_181A5C000,  v111,  v122,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v121);
        goto LABEL_162;
      }

      if (v123)
      {
        *(_DWORD *)buf = 136446210;
        v219 = "nw_endpoint_flow_rebuild_stack";
        _os_log_impl(&dword_181A5C000, v111, v122, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v136 = type[0];
      if (os_log_type_enabled(v111, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v219 = "nw_endpoint_flow_rebuild_stack";
        _os_log_impl( &dword_181A5C000,  v111,  v136,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(backtrace_string);
    goto LABEL_193;
  }

  id v5 = handle[194];
  if (v5 < 0)
  {
    if ((v5 & 8) == 0) {
      goto LABEL_7;
    }
LABEL_137:
    result = 1LL;
    if ((v5 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v83 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        id v84 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        id v102 = "nw_protocol_http2_connect";
        os_log_type_t v103 = 2082;
        BOOL v104 = (char *)(handle + 195);
        id v105 = 2080;
        os_log_type_t v106 = " ";
        unint64_t v107 = 1024;
        nw_endpoint_t v108 = v84;
        _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> tunnel already closed, ignoring connect with success",  buf,  0x26u);
      }

      return 1LL;
    }

    return result;
  }

  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v66 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v67 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      id v102 = "nw_protocol_http2_connect";
      os_log_type_t v103 = 2082;
      BOOL v104 = (char *)(handle + 195);
      id v105 = 2080;
      os_log_type_t v106 = " ";
      unint64_t v107 = 1024;
      nw_endpoint_t v108 = v67;
      _os_log_impl(&dword_181A5C000, v66, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  LOWORD(v5) = handle[194];
  if ((v5 & 8) != 0) {
    goto LABEL_137;
  }
LABEL_7:
  if (!*((void *)handle + 8))
  {
    __int16 v6 = mach_continuous_time();
    __int16 v7 = v6 <= 1 ? 1LL : v6;
    *((void *)handle + _Block_object_dispose((const void *)(v67 - 152), 8) = v7;
    pid_t v8 = nw_protocol_copy_info(*((void *)handle + 4), 255);
    if (v8)
    {
      uint64_t v9 = (void *)v8;
      int v10 = *(void *)(v8 + 24);
      if (*(void *)(v8 + 16) != v10)
      {
        BOOL v11 = *(void **)(v10 - 8);
        if (v11)
        {
          char v12 = (nw_protocol_metadata *)os_retain(v11);
          if (v12)
          {
            id v13 = v12;
            if (nw_protocol_metadata_is_tls(v12))
            {
              BOOL v14 = v13;
              nw_http_connection_metadata_set_sec_metadata(*((void **)handle + 32), v14);
              os_release(v14);
            }

            os_release(v13);
          }
        }
      }

      os_release(v9);
    }
  }

  output_handler_context = a2->output_handler_context;
  if ((handle[194] & 4) == 0)
  {
    if (!output_handler_context) {
      goto LABEL_24;
    }
    char v16 = output_handler_context[4];
    if (v16)
    {
      id v17 = *(unsigned __int16 *)(v16 + 188);
      nw_endpoint_t v18 = v17 | (*(unsigned __int8 *)(v16 + 190) << 16);
      *(_WORD *)(v16 + 18_Block_object_dispose((const void *)(v67 - 152), 8) = v17 | 8;
      if ((v18 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v93 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v95 = *(_DWORD *)(v16 + 176);
          os_log_type_t v94 = *(_DWORD *)(v16 + 180);
          *(_DWORD *)buf = 136447746;
          id v102 = "nw_protocol_http2_connect";
          os_log_type_t v103 = 2082;
          BOOL v104 = (char *)(v16 + 191);
          id v105 = 2080;
          os_log_type_t v106 = " ";
          unint64_t v107 = 1024;
          nw_endpoint_t v108 = v94;
          os_log_type_t v109 = 1024;
          *(_DWORD *)BOOL v110 = v95;
          *(_WORD *)&v110[4] = 1024;
          *(_DWORD *)&v110[6] = v95;
          v111[0] = 2048;
          *(void *)&v111[1] = v16;
          _os_log_impl( &dword_181A5C000,  v93,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> marked stream id %d (%p) as waiting for connect",  buf,  0x3Cu);
        }
      }

LABEL_231:
    if (v243) {
      free(v243);
    }
    goto LABEL_233;
  }

  uint64_t v9 = 1LL;
LABEL_235:

LABEL_303:
  return v9;
}

              free(v118);
              goto LABEL_279;
            }

            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
            char v30 = (char *)_os_log_send_and_compose_impl();
            type.__r_.__value_.__s.__data_[0] = 16;
            LOBYTE(v151[0]) = 0;
            if (type.__r_.__value_.__s.__data_[0] == 17)
            {
              os_log_type_t v31 = (os_log_s *)__nwlog_obj();
              nw_endpoint_t v32 = type.__r_.__value_.__s.__data_[0];
              if (!os_log_type_enabled(v31, (os_log_type_t)type.__r_.__value_.__s.__data_[0])) {
                goto LABEL_279;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
              os_log_type_t v33 = "%{public}s called with null http_metadata";
              goto LABEL_278;
            }

            if (!LOBYTE(v151[0]))
            {
              os_log_type_t v31 = (os_log_s *)__nwlog_obj();
              nw_endpoint_t v32 = type.__r_.__value_.__s.__data_[0];
              if (os_log_type_enabled(v31, (os_log_type_t)type.__r_.__value_.__s.__data_[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
                os_log_type_t v33 = "%{public}s called with null http_metadata, backtrace limit exceeded";
                goto LABEL_278;
              }

              goto LABEL_279;
            }

            id v118 = (char *)__nw_create_backtrace_string();
            os_log_type_t v31 = (os_log_s *)__nwlog_obj();
            nw_endpoint_t v32 = type.__r_.__value_.__s.__data_[0];
            id v123 = os_log_type_enabled(v31, (os_log_type_t)type.__r_.__value_.__s.__data_[0]);
            if (!v118)
            {
              if (v123)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
                os_log_type_t v33 = "%{public}s called with null http_metadata, no backtrace";
                goto LABEL_278;
              }

              goto LABEL_279;
            }

            if (!v123) {
              goto LABEL_231;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v118;
            __int16 v120 = "%{public}s called with null http_metadata, dumping backtrace:%{public}s";
            goto LABEL_230;
          }

                if (!v135) {
                  goto LABEL_233;
                }
LABEL_232:
                free(v135);
                goto LABEL_233;
              }
            }
          }
}

      if (v104) {
        unint64_t v107 = v106;
      }
      else {
        unint64_t v107 = v105;
      }
      nw_masque_report_error_to_proxy_agent(v36, v107);
LABEL_235:
      id v72 = v36;
      BOOL v73 = 61;
      goto LABEL_236;
    }

        if (v97) {
          free(v97);
        }
        Request = v154;
      }
    }
  }

              id v63 = v57 - v85;
              uint64_t v86 = v57 - v85 - v54;
              if (v57 - v85 < v54)
              {
                char v30 = (os_log_s *)__nwlog_obj();
                if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_27;
                }
                goto LABEL_233;
              }

              if (a3) {
                *a3 = v54;
              }
              if (v63 == v54) {
                goto LABEL_167;
              }
              os_log_type_t v121 = &v56[v85 + v54];
              id v54 = *(unsigned __int8 *)v121;
              if (v54 <= 0x3F)
              {
                __int16 v122 = 1LL;
                goto LABEL_331;
              }

              if (v54 >> 6 == 2)
              {
                if (v86 < 4) {
                  goto LABEL_460;
                }
                id v54 = bswap32(*(_DWORD *)v121 & 0xFFFFFF7F);
                __int16 v122 = 4LL;
LABEL_331:
                id v123 = &v121[v122];
              }

              else
              {
                if (v54 >> 6 == 1)
                {
                  if (v86 >= 2)
                  {
                    id v54 = bswap32(*(_WORD *)v121 & 0xFFBF) >> 16;
                    __int16 v122 = 2LL;
                    goto LABEL_331;
                  }

        if (v41) {
          free(v41);
        }
        *((_DWORD *)v313 + 6) = -1;
LABEL_234:
        if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          nw_endpoint_t v216 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            id v217 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            id v317 = "nw_protocol_http2_get_input_frames";
            int v318 = 2082;
            int v319 = handle + 390;
            char v320 = 2080;
            v321 = (uint64_t)" ";
            os_log_type_t v322 = 1024;
            *(_DWORD *)nw_endpoint_t v323 = v217;
            _os_log_impl( &dword_181A5C000,  v216,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> delivering empty incoming frame",  buf,  0x26u);
          }
        }

        uint64_t v21 = *((unsigned int *)v313 + 6);
        if (!v34) {
          goto LABEL_287;
        }
        goto LABEL_237;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v317 = "nw_protocol_http2_get_input_frames";
      nw_endpoint_t v210 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v300) = 0;
      if (__nwlog_fault(v210, type, &v300))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v211 = (os_log_s *)__nwlog_obj();
          char v212 = type[0];
          if (!os_log_type_enabled(v211, type[0])) {
            goto LABEL_331;
          }
          *(_DWORD *)buf = 136446210;
          id v317 = "nw_protocol_http2_get_input_frames";
          v213 = "%{public}s called with null empty_frame";
LABEL_330:
          _os_log_impl(&dword_181A5C000, v211, v212, v213, buf, 0xCu);
          goto LABEL_331;
        }

        if (!(_BYTE)v300)
        {
          int v211 = (os_log_s *)__nwlog_obj();
          char v212 = type[0];
          if (!os_log_type_enabled(v211, type[0])) {
            goto LABEL_331;
          }
          *(_DWORD *)buf = 136446210;
          id v317 = "nw_protocol_http2_get_input_frames";
          v213 = "%{public}s called with null empty_frame, backtrace limit exceeded";
          goto LABEL_330;
        }

        int v223 = (char *)__nw_create_backtrace_string();
        int v211 = (os_log_s *)__nwlog_obj();
        char v212 = type[0];
        BOOL v224 = os_log_type_enabled(v211, type[0]);
        if (!v223)
        {
          if (!v224) {
            goto LABEL_331;
          }
          *(_DWORD *)buf = 136446210;
          id v317 = "nw_protocol_http2_get_input_frames";
          v213 = "%{public}s called with null empty_frame, no backtrace";
          goto LABEL_330;
        }

        if (v224)
        {
          *(_DWORD *)buf = 136446466;
          id v317 = "nw_protocol_http2_get_input_frames";
          int v318 = 2082;
          int v319 = v223;
          _os_log_impl( &dword_181A5C000,  v211,  v212,  "%{public}s called with null empty_frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v223);
      }

void sub_181AF108C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, void *a25)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_pid_to_uuid_mapping_failed(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[97] >> 5) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
          __int16 v17 = 2082;
          nw_endpoint_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_bundle_id_to_uuid_mapping_failed(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[97] >> 4) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
          __int16 v17 = 2082;
          nw_endpoint_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_parameters_has_delegated_proc_pid(void *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    int v5 = *(_DWORD *)(*((void *)v3 + 13) + 64LL);
    BOOL v7 = v5 > 0 && v5 != a2;
    goto LABEL_8;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v20 = "nw_parameters_has_delegated_proc_pid";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_parameters_has_delegated_proc_pid";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v20 = "nw_parameters_has_delegated_proc_pid";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_parameters_has_delegated_proc_pid";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v20 = "nw_parameters_has_delegated_proc_pid";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_parameters_has_delegated_proc_uuid(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_parameters_has_delegated_proc_uuid";
    __int16 v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v6, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_parameters_has_delegated_proc_uuid";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v16 = "nw_parameters_has_delegated_proc_uuid";
            __int16 v17 = 2082;
            nw_endpoint_t v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_parameters_has_delegated_proc_uuid";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_parameters_has_delegated_proc_uuid";
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_3:
  BOOL v3 = 0LL;
LABEL_5:

  return v3;
}

  BOOL v3 = 0LL;
LABEL_5:

  return v3;
}

  id v4 = 1LL;
LABEL_32:

  return v4;
}
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2) {
    id v4 = (const char *)(a2 + 205);
  }
  else {
    id v4 = "";
  }
  *(_DWORD *)buf = 136446466;
  __int16 v21 = "http2_transport_input_frame_context_reset";
  uint64_t v22 = 2082;
  uint64_t v23 = (void *)v4;
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  nw_endpoint_t v18 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v6 = (os_log_s *)gLogObj;
    BOOL v7 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v21 = "http2_transport_input_frame_context_reset";
      uint64_t v22 = 2082;
      uint64_t v23 = (void *)v4;
      os_log_type_t v8 = "%{public}s %{public}s frame has no metadata";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0x16u);
    }
  }

  else if (v18)
  {
    os_log_type_t v10 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v6 = (os_log_s *)gLogObj;
    BOOL v7 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v10)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446722;
        __int16 v21 = "http2_transport_input_frame_context_reset";
        uint64_t v22 = 2082;
        uint64_t v23 = (void *)v4;
        int v24 = 2082;
        BOOL v25 = v10;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s %{public}s frame has no metadata, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v10);
      goto LABEL_21;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v21 = "http2_transport_input_frame_context_reset";
      uint64_t v22 = 2082;
      uint64_t v23 = (void *)v4;
      os_log_type_t v8 = "%{public}s %{public}s frame has no metadata, no backtrace";
      goto LABEL_20;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v6 = (os_log_s *)gLogObj;
    BOOL v7 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v21 = "http2_transport_input_frame_context_reset";
      uint64_t v22 = 2082;
      uint64_t v23 = (void *)v4;
      os_log_type_t v8 = "%{public}s %{public}s frame has no metadata, backtrace limit exceeded";
      goto LABEL_20;
    }
  }

    BOOL v7 = (NSHTTPCookieStorage *)(id)[objc_alloc(MEMORY[0x189601E98]) _initWithCFHTTPCookieStorage:a3];
    id v4 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_http_cookie_storage);
    int v5 = v4->cookieStorage;
    v4->cookieStorage = v7;

    if (self) {
      objc_storeStrong((id *)&self->_cookieStorage, v4);
    }

    cookieStorage = (OS_nw_http_cookie_storage *)v7;
    goto LABEL_7;
  }

  if (a3) {
    goto LABEL_3;
  }
}

    free(v2);
    *(void *)(a1 + 112) = 0LL;
    goto LABEL_4;
  }

  BOOL v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  id v4 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v4))
  {
    free(v4);
    nw_path_t v2 = *(void **)(a1 + 112);
    if (!v2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  __break(1u);
}

    _Block_object_dispose(v271, 8);
  }

  __int16 v6 = (__CFError *)v270;
  BOOL v7 = *(void *)(a1 + 1176);
  if (v270 != 4)
  {
    if (v7)
    {
      if (v270 <= 4287504052LL)
      {
        if (v270 == 7)
        {
          if ((v5 & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v54 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              uint64_t v55 = *(_DWORD *)(a1 + 1280);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v3;
              *(_WORD *)&buf[22] = 2080;
              id v282 = " ";
              uint64_t v283 = 1024;
              v284 = v55;
              _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> received a GOAWAY, connection will not be reused",  buf,  0x26u);
            }
          }

          nw_http3_async_close_connection_if_no_stream(a1);
          __int16 v56 = *(void *)(a1 + 32);
          if (v56)
          {
            id v57 = *(void *)(v56 + 24);
            if (v57)
            {
              int v58 = *(void (**)(void))(v57 + 240);
              if (v58)
              {
                v58();
LABEL_72:
                nw_http3_notify_do_not_reuse(a1);
                goto LABEL_137;
              }
            }
          }

          __nwlog_obj();
          os_log_type_t v106 = *(void *)(a1 + 32);
          if (v106)
          {
            unint64_t v107 = *(const char **)(v106 + 16);
            if (!v107) {
              unint64_t v107 = "invalid";
            }
          }

          else
          {
            unint64_t v107 = "invalid";
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v107;
          nw_endpoint_t v108 = (char *)_os_log_send_and_compose_impl();
          v279[0] = 16;
          LOBYTE(error) = 0;
          if (__nwlog_fault(v108, v279, &error))
          {
            if (v279[0] == 17)
            {
              os_log_type_t v109 = (os_log_s *)__nwlog_obj();
              BOOL v110 = v279[0];
              if (!os_log_type_enabled(v109, (os_log_type_t)v279[0])) {
                goto LABEL_208;
              }
              BOOL v111 = *(void *)(a1 + 32);
              if (v111)
              {
                os_log_type_t v112 = *(const char **)(v111 + 16);
                if (!v112) {
                  os_log_type_t v112 = "invalid";
                }
              }

              else
              {
                os_log_type_t v112 = "invalid";
              }

              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v112;
              v135 = v109;
              char v136 = v110;
              nw_endpoint_t v137 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback";
              goto LABEL_207;
            }

            if (!(_BYTE)error)
            {
              id v123 = (os_log_s *)__nwlog_obj();
              nw_endpoint_t v124 = v279[0];
              if (!os_log_type_enabled(v123, (os_log_type_t)v279[0])) {
                goto LABEL_208;
              }
              dispatch_time_t v125 = *(void *)(a1 + 32);
              if (v125)
              {
                uint64_t v126 = *(const char **)(v125 + 16);
                if (!v126) {
                  uint64_t v126 = "invalid";
                }
              }

              else
              {
                uint64_t v126 = "invalid";
              }

              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v126;
              v135 = v123;
              char v136 = v124;
              nw_endpoint_t v137 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, backtrace limit exceeded";
              goto LABEL_207;
            }

            v113 = (char *)__nw_create_backtrace_string();
            id v114 = (os_log_s *)__nwlog_obj();
            os_log_type_t v115 = v279[0];
            __int16 v116 = os_log_type_enabled(v114, (os_log_type_t)v279[0]);
            if (v113)
            {
              if (v116)
              {
                id v117 = *(void *)(a1 + 32);
                if (v117)
                {
                  id v118 = *(const char **)(v117 + 16);
                  if (!v118) {
                    id v118 = "invalid";
                  }
                }

                else
                {
                  id v118 = "invalid";
                }

                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v118;
                *(_WORD *)&buf[22] = 2082;
                id v282 = v113;
                _os_log_impl( &dword_181A5C000,  v114,  v115,  "%{public}s protocol %{public}s has invalid remove_listen_handler callback, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v113);
              goto LABEL_208;
            }

            if (v116)
            {
              nw_endpoint_t v131 = *(void *)(a1 + 32);
              if (v131)
              {
                nw_endpoint_t v132 = *(const char **)(v131 + 16);
                if (!v132) {
                  nw_endpoint_t v132 = "invalid";
                }
              }

              else
              {
                nw_endpoint_t v132 = "invalid";
              }

              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v132;
              v135 = v114;
              char v136 = v115;
              nw_endpoint_t v137 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, no backtrace";
LABEL_207:
              _os_log_impl(&dword_181A5C000, v135, v136, v137, buf, 0x16u);
            }
          }

    _Block_object_dispose(v36, 8);
  }

  _Block_object_dispose(v36, 8);
}

    if (v37 == *(void *)(a1 + 944)) {
      return;
    }
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = v4;
  id v81 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v105[0]) = 16;
  os_log_type_t v100 = 0;
  if (LOBYTE(v105[0]) == 17)
  {
    id v82 = (os_log_s *)__nwlog_obj();
    uint64_t v83 = v105[0];
    if (os_log_type_enabled(v82, v105[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v4;
      id v84 = "%{public}s Must finalize output frames from decoder stream immediately";
      goto LABEL_145;
    }

    goto LABEL_146;
  }

  if (!v100)
  {
    id v82 = (os_log_s *)__nwlog_obj();
    uint64_t v83 = v105[0];
    if (!os_log_type_enabled(v82, v105[0])) {
      goto LABEL_146;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = v4;
    id v84 = "%{public}s Must finalize output frames from decoder stream immediately, backtrace limit exceeded";
    goto LABEL_145;
  }

  BOOL v85 = (char *)__nw_create_backtrace_string();
  id v82 = (os_log_s *)__nwlog_obj();
  uint64_t v83 = v105[0];
  uint64_t v86 = os_log_type_enabled(v82, v105[0]);
  if (v85)
  {
    if (v86)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = v4;
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v85;
      _os_log_impl( &dword_181A5C000,  v82,  v83,  "%{public}s Must finalize output frames from decoder stream immediately, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v85);
    goto LABEL_146;
  }

  if (v86)
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = v4;
    id v84 = "%{public}s Must finalize output frames from decoder stream immediately, no backtrace";
LABEL_145:
    _os_log_impl(&dword_181A5C000, v82, v83, v84, buf, 0xCu);
  }

  __int16 v6 = 0LL;
LABEL_5:

  return v6;
}

  int v5 = 0LL;
LABEL_5:

  return v5;
}

  __int16 v6 = 0LL;
LABEL_5:

  return v6;
}

  __int16 v6 = 0LL;
LABEL_5:

  return v6;
}

  __int16 v6 = 0LL;
LABEL_5:

  return v6;
}

  return v6;
}

  if (a2)
  {
    id v4 = " ";
  }

  else
  {
    id v4 = "";
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  if (a2) {
    int v5 = (const char *)(a2 + 390);
  }
  else {
    int v5 = "";
  }
  __int16 v6 = *(_DWORD *)(a2 + 368);
  *(_DWORD *)buf = 136446978;
  char v26 = "http2_output_frame_metadata_reset";
  id v27 = 2082;
  __int16 v28 = (void *)v5;
  BOOL v29 = 2080;
  char v30 = v4;
  os_log_type_t v31 = 1024;
  nw_endpoint_t v32 = v6;
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v23 = 0;
  if (__nwlog_fault(v7, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v8 = (os_log_s *)gconnectionLogObj;
      uint64_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_33;
      }
      os_log_type_t v10 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      char v26 = "http2_output_frame_metadata_reset";
      id v27 = 2082;
      __int16 v28 = (void *)v5;
      BOOL v29 = 2080;
      char v30 = v4;
      os_log_type_t v31 = 1024;
      nw_endpoint_t v32 = v10;
      BOOL v11 = "%{public}s %{public}s%s<i%u> frame has no metadata";
      goto LABEL_32;
    }

    if (!v23)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v8 = (os_log_s *)gconnectionLogObj;
      uint64_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_33;
      }
      BOOL v15 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      char v26 = "http2_output_frame_metadata_reset";
      id v27 = 2082;
      __int16 v28 = (void *)v5;
      BOOL v29 = 2080;
      char v30 = v4;
      os_log_type_t v31 = 1024;
      nw_endpoint_t v32 = v15;
      BOOL v11 = "%{public}s %{public}s%s<i%u> frame has no metadata, backtrace limit exceeded";
      goto LABEL_32;
    }

    os_log_type_t v12 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v8 = (os_log_s *)gconnectionLogObj;
    uint64_t v9 = type;
    char v13 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (v12)
    {
      if (v13)
      {
        os_log_type_t v14 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)buf = 136447234;
        char v26 = "http2_output_frame_metadata_reset";
        id v27 = 2082;
        __int16 v28 = (void *)v5;
        BOOL v29 = 2080;
        char v30 = v4;
        os_log_type_t v31 = 1024;
        nw_endpoint_t v32 = v14;
        os_log_type_t v33 = 2082;
        os_log_type_t v34 = v12;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s %{public}s%s<i%u> frame has no metadata, dumping backtrace:%{public}s",  buf,  0x30u);
      }

      free(v12);
      goto LABEL_33;
    }

    if (v13)
    {
      os_log_type_t v16 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      char v26 = "http2_output_frame_metadata_reset";
      id v27 = 2082;
      __int16 v28 = (void *)v5;
      BOOL v29 = 2080;
      char v30 = v4;
      os_log_type_t v31 = 1024;
      nw_endpoint_t v32 = v16;
      BOOL v11 = "%{public}s %{public}s%s<i%u> frame has no metadata, no backtrace";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v8, v9, v11, buf, 0x26u);
    }
  }

  BOOL v3 = 0LL;
LABEL_5:

  return v3;
}

  BOOL v3 = 0LL;
LABEL_5:

  return v3;
}

void sub_181AF1E04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_attach_protocols( NWConcrete_nw_endpoint_handler *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v379 = *MEMORY[0x1895F89C0];
  id v4 = a1;
  v272 = v4;
  if (!v4)
  {
    __nwlog_obj();
    BOOL v96 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    nw_endpoint_t v97 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v377[0] = 0;
    if (__nwlog_fault(v97, type, v377))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v99 = type[0];
        if (os_log_type_enabled(v98, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v98, v99, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v377[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v101 = type[0];
        BOOL v102 = os_log_type_enabled(v98, type[0]);
        if (backtrace_string)
        {
          if (v102)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v98,  v101,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_171;
        }

        if (v102)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v98, v101, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v124 = type[0];
        if (os_log_type_enabled(v98, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v98,  v124,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_207:
    free(v127);
    goto LABEL_208;
  }

  unsigned int mode = v4->mode;
  __int16 v6 = v4;

  if (mode != 2) {
    goto LABEL_174;
  }
  v252 = a2;
  BOOL v7 = v6;
  char v8 = *((_BYTE *)v7 + 268);

  int v261 = v7;
  if ((v8 & 0x20) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v9 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v10 = v7;

      BOOL v11 = v10;
      char v12 = *((_BYTE *)v7 + 268);

      if ((v12 & 1) != 0) {
        char v13 = "dry-run ";
      }
      else {
        char v13 = "";
      }
      nw_endpoint_t v14 = nw_endpoint_handler_copy_endpoint(v11);
      logging_description = nw_endpoint_get_logging_description(v14);
      os_log_type_t v16 = v10 + 168;
      __int16 v17 = v11;
      nw_endpoint_t v18 = v17;
      uint64_t v19 = v17[30];
      else {
        BOOL v20 = off_189BBBBF0[v19];
      }

      __int16 v21 = v18;
      uint64_t v22 = v21;
      uint64_t v23 = "path";
      switch(v272->mode)
      {
        case 0:
          break;
        case 1:
          uint64_t v23 = "resolver";
          break;
        case 2:
          uint64_t v23 = nw_endpoint_flow_mode_string(v21[31]);
          break;
        case 3:
          uint64_t v23 = "proxy";
          break;
        case 4:
          uint64_t v23 = "fallback";
          break;
        case 5:
          uint64_t v23 = "transform";
          break;
        default:
          uint64_t v23 = "unknown-mode";
          break;
      }

      int v24 = v22;
      os_unfair_lock_lock((os_unfair_lock_t)v24 + 28);
      id v25 = v24[8];
      os_unfair_lock_unlock((os_unfair_lock_t)v24 + 28);

      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v16;
      *(_WORD *)&buf[22] = 2082;
      v367 = v13;
      *(_WORD *)size_t v368 = 2082;
      *(void *)&v368[2] = logging_description;
      __int16 v369 = 2082;
      v370 = v20;
      __int16 v371 = 2082;
      uint64_t v372 = v23;
      __int16 v373 = 2114;
      id v374 = v25;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);
    }

    BOOL v7 = v261;
  }

  id v271 = nw_endpoint_handler_copy_flow(v7);
  char v26 = v7;
  id v27 = v26[3];

  *(void *)os_log_type_t type = 0LL;
  nw_endpoint_t v361 = type;
  uint64_t v362 = 0x3032000000LL;
  v363 = __Block_byref_object_copy__80314;
  v364 = __Block_byref_object_dispose__80315;
  id v249 = v27;
  id v365 = v249;
  __int16 v28 = v26;
  id v250 = v28[4];

  BOOL v29 = v28;
  uint64_t v30 = v272->mode;

  if ((_DWORD)v30 == 2)
  {
    os_log_type_t v31 = nw_endpoint_handler_copy_flow(v29);
    if ((*((_BYTE *)v31 + 33) & 0x40) != 0)
    {
      v38 = v29;
      os_unfair_lock_lock(&v38->lock);
      int v39 = v38->current_path;
      os_unfair_lock_unlock(&v38->lock);

      int nexus_protocol_level = nw_path_get_nexus_protocol_level(v39);
    }

    else
    {
      int nexus_protocol_level = 4;
    }

    goto LABEL_62;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v32 = (id)gLogObj;
  else {
    os_log_type_t v33 = off_189BBBBC0[v30];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_protocol_level";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&void buf[14] = v33;
  *(_WORD *)&buf[22] = 2082;
  v367 = "flow";
  os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();

  v377[0] = 16;
  LOBYTE(v356) = 0;
  if (__nwlog_fault(v34, v377, &v356))
  {
    if (v377[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v35 = (os_log_s *)(id)gLogObj;
      os_log_type_t v36 = v377[0];
      if (os_log_type_enabled(v35, (os_log_type_t)v377[0]))
      {
        else {
          uint64_t v37 = off_189BBBBC0[v30];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_protocol_level";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v37;
        *(_WORD *)&buf[22] = 2082;
        v367 = "flow";
        _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    else if ((_BYTE)v356)
    {
      BOOL v40 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v35 = (os_log_s *)(id)gLogObj;
      os_log_type_t v41 = v377[0];
      BOOL v42 = os_log_type_enabled(v35, (os_log_type_t)v377[0]);
      if (v40)
      {
        if (v42)
        {
          else {
            nw_endpoint_t v43 = off_189BBBBC0[v30];
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_protocol_level";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v43;
          *(_WORD *)&buf[22] = 2082;
          v367 = "flow";
          *(_WORD *)size_t v368 = 2082;
          *(void *)&v368[2] = v40;
          _os_log_impl( &dword_181A5C000,  v35,  v41,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v40);
        if (!v34) {
          goto LABEL_61;
        }
        goto LABEL_60;
      }

      if (v42)
      {
        else {
          os_log_type_t v46 = off_189BBBBC0[v30];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_protocol_level";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v46;
        *(_WORD *)&buf[22] = 2082;
        v367 = "flow";
        _os_log_impl( &dword_181A5C000,  v35,  v41,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v35 = (os_log_s *)(id)gLogObj;
      os_log_type_t v44 = v377[0];
      if (os_log_type_enabled(v35, (os_log_type_t)v377[0]))
      {
        else {
          BOOL v45 = off_189BBBBC0[v30];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_protocol_level";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v45;
        *(_WORD *)&buf[22] = 2082;
        v367 = "flow";
        _os_log_impl( &dword_181A5C000,  v35,  v44,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v34) {
LABEL_60:
  }
    free(v34);
LABEL_61:
  int nexus_protocol_level = 0;
LABEL_62:

  uint64_t v356 = 0LL;
  nw_endpoint_t v357 = &v356;
  uint64_t v358 = 0x2020000000LL;
  v359 = (char *)v271 + 376;
  nw_parameters_get_upper_transport_protocol_options(v250);
  nw_endpoint_t v248 = (void *)objc_claimAutoreleasedReturnValue();
  v251 = (NWConcrete_nw_path *)nw_endpoint_flow_copy_path(v29);
  if (nw_endpoint_flow_should_add_filter(v250, v251))
  {
    double Helper_x8__ne_filter_protocol_identifier = gotLoadHelper_x8__ne_filter_protocol_identifier(v47);
    if (*(void *)(v49 + 648)) {
      inited = (__int128 *)ne_filter_protocol_identifier_delayInitStub(Helper_x8__ne_filter_protocol_identifier);
    }
    else {
      inited = 0LL;
    }
    BOOL v51 = inited != 0LL;
  }

  else
  {
    BOOL v51 = 0;
    inited = 0LL;
  }

  uint64_t v352 = 0LL;
  v353 = &v352;
  uint64_t v354 = 0x2020000000LL;
  char v355 = 0;
  uint64_t v52 = (id *)v250;
  nw_endpoint_t v53 = v52;
  if (v52)
  {
    id v54 = (nw_protocol_stack *)v52[19];
    if (v54)
    {
      uint64_t v55 = v54;
      *(void *)__int16 v377 = 0LL;
      *(void *)&v377[8] = v377;
      *(void *)&v377[16] = 0x2020000000LL;
      LOBYTE(v37_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_parameters_has_proxy_protocol_in_stack_block_invoke;
      v367 = (const char *)&unk_189BBD000;
      *(void *)size_t v368 = v377;
      nw_protocol_stack_iterate_application_protocols(v54, buf);
      BOOL v56 = *(_BYTE *)(*(void *)&v377[8] + 24LL) == 0;
      _Block_object_dispose(v377, 8);

      if (!v56)
      {
        BOOL v57 = nw_endpoint_copy_proxy_original_endpoint(*((void **)v361 + 5));
        if (v57)
        {
          objc_storeStrong((id *)v271 + 121, (id)v57);
          objc_storeStrong((id *)v361 + 5, (id)v57);
        }
      }

      goto LABEL_74;
    }

    __nwlog_obj();
    unint64_t v107 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int16 v377 = 136446210;
    *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
    nw_endpoint_t v108 = (char *)_os_log_send_and_compose_impl();

    v348[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v346[0]) = 0;
    if (v348[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v110 = v348[0];
      if (os_log_type_enabled(v109, v348[0]))
      {
        *(_DWORD *)__int16 v377 = 136446210;
        *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
        _os_log_impl(&dword_181A5C000, v109, v110, "%{public}s called with null stack", v377, 0xCu);
      }
    }

    else if (LOBYTE(v346[0]))
    {
      os_log_type_t v121 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v122 = v348[0];
      BOOL v123 = os_log_type_enabled(v109, v348[0]);
      if (v121)
      {
        if (v123)
        {
          *(_DWORD *)__int16 v377 = 136446466;
          *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
          *(_WORD *)&v377[12] = 2082;
          *(void *)&v377[14] = v121;
          _os_log_impl( &dword_181A5C000,  v109,  v122,  "%{public}s called with null stack, dumping backtrace:%{public}s",  v377,  0x16u);
        }

        free(v121);
        goto LABEL_232;
      }

      if (v123)
      {
        *(_DWORD *)__int16 v377 = 136446210;
        *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
        _os_log_impl(&dword_181A5C000, v109, v122, "%{public}s called with null stack, no backtrace", v377, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v146 = v348[0];
      if (os_log_type_enabled(v109, v348[0]))
      {
        *(_DWORD *)__int16 v377 = 136446210;
        *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
        _os_log_impl( &dword_181A5C000,  v109,  v146,  "%{public}s called with null stack, backtrace limit exceeded",  v377,  0xCu);
      }
    }

LABEL_232:
    if (v108) {
      free(v108);
    }

    goto LABEL_74;
  }

  __nwlog_obj();
  os_log_type_t v103 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int16 v377 = 136446210;
  *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
  BOOL v104 = (char *)_os_log_send_and_compose_impl();

  v348[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v346[0]) = 0;
  if (__nwlog_fault(v104, v348, v346))
  {
    if (v348[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v106 = v348[0];
      if (os_log_type_enabled(v105, v348[0]))
      {
        *(_DWORD *)__int16 v377 = 136446210;
        *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
        _os_log_impl(&dword_181A5C000, v105, v106, "%{public}s called with null parameters", v377, 0xCu);
      }
    }

    else if (LOBYTE(v346[0]))
    {
      id v118 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v119 = v348[0];
      BOOL v120 = os_log_type_enabled(v105, v348[0]);
      if (v118)
      {
        if (v120)
        {
          *(_DWORD *)__int16 v377 = 136446466;
          *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
          *(_WORD *)&v377[12] = 2082;
          *(void *)&v377[14] = v118;
          _os_log_impl( &dword_181A5C000,  v105,  v119,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  v377,  0x16u);
        }

        free(v118);
        goto LABEL_226;
      }

      if (v120)
      {
        *(_DWORD *)__int16 v377 = 136446210;
        *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
        _os_log_impl(&dword_181A5C000, v105, v119, "%{public}s called with null parameters, no backtrace", v377, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v145 = v348[0];
      if (os_log_type_enabled(v105, v348[0]))
      {
        *(_DWORD *)__int16 v377 = 136446210;
        *(void *)&v377[4] = "nw_parameters_has_proxy_protocol_in_stack";
        _os_log_impl( &dword_181A5C000,  v105,  v145,  "%{public}s called with null parameters, backtrace limit exceeded",  v377,  0xCu);
      }
    }
  }

    goto LABEL_208;
  }

  nw_context_assert_queue(*((void **)v5 + 46));
  char v8 = nw_protocol_options_copy(v7);
  uint64_t v9 = v8;
  if (!v8)
  {
    __nwlog_obj();
    BOOL v95 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
    BOOL v96 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v167) = 0;
    if (__nwlog_fault(v96, type, &v167))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_endpoint_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v98 = type[0];
        if (os_log_type_enabled(v97, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
          _os_log_impl(&dword_181A5C000, v97, v98, "%{public}s called with null protocol_options", buf, 0xCu);
        }
      }

      else
      {
        if ((_BYTE)v167)
        {
          os_log_type_t v110 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v112 = type[0];
          id v113 = os_log_type_enabled(v111, type[0]);
          if (v110)
          {
            if (v113)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v110;
              _os_log_impl( &dword_181A5C000,  v111,  v112,  "%{public}s called with null protocol_options, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v110);
          }

          else
          {
            if (v113)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
              _os_log_impl( &dword_181A5C000,  v111,  v112,  "%{public}s called with null protocol_options, no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_214;
        }

        __nwlog_obj();
        nw_endpoint_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_endpoint_t v137 = type[0];
        if (os_log_type_enabled(v97, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
          _os_log_impl( &dword_181A5C000,  v97,  v137,  "%{public}s called with null protocol_options, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v67) {
LABEL_208:
    }
      free(v67);
LABEL_209:
    os_log_type_t v101 = v45;
    goto LABEL_210;
  }

  double v47 = v46;
  Request = CFHTTPMessageCreateRequest(v41, @"CONNECT", v46, @"HTTP/1.1");
  CFRelease(v47);
  if (!Request)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0) {
      goto LABEL_209;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    id v171 = " ";
    uint64_t v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v68 = (os_log_s *)__nwlog_obj();
      uint64_t v69 = type[0];
      if (!os_log_type_enabled(v68, type[0])) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      id v171 = " ";
      __int16 v70 = "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed";
    }

    else if (v161[0])
    {
      id v91 = (char *)__nw_create_backtrace_string();
      os_log_type_t v68 = (os_log_s *)__nwlog_obj();
      uint64_t v69 = type[0];
      BOOL v92 = os_log_type_enabled(v68, type[0]);
      if (v91)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = a1 + 284;
          *(_WORD *)&buf[22] = 2080;
          id v171 = " ";
          LOWORD(v172) = 2082;
          *(void *)((char *)&v172 + 2) = v91;
          _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v91);
        if (!v67) {
          goto LABEL_209;
        }
        goto LABEL_208;
      }

      if (!v92) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      id v171 = " ";
      __int16 v70 = "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed, no backtrace";
    }

    else
    {
      os_log_type_t v68 = (os_log_s *)__nwlog_obj();
      uint64_t v69 = type[0];
      if (!os_log_type_enabled(v68, type[0])) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      id v171 = " ";
      __int16 v70 = "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed, backtrace limit exceeded";
    }

    goto LABEL_206;
  }

  if (strcmp(v40, "443"))
  {
    CFHTTPMessageSetHeaderFieldValue(Request, @"Host", v45);
    goto LABEL_149;
  }

  BOOL v77 = CFStringCreateWithCString(v41, v43, 0x600u);
  if (!v77)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
    {
LABEL_273:
      CFRelease(v45);
      os_log_type_t v101 = Request;
      goto LABEL_210;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    id v171 = " ";
    id v93 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v93, type, v161))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v94 = (os_log_s *)__nwlog_obj();
        BOOL v95 = type[0];
        if (!os_log_type_enabled(v94, type[0])) {
          goto LABEL_271;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        id v171 = " ";
        BOOL v96 = "%{public}s %{public}s%sCFStringCreateWithCString failed";
        goto LABEL_270;
      }

      if (v161[0] == OS_LOG_TYPE_DEFAULT)
      {
        int v94 = (os_log_s *)__nwlog_obj();
        BOOL v95 = type[0];
        if (!os_log_type_enabled(v94, type[0])) {
          goto LABEL_271;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        id v171 = " ";
        BOOL v96 = "%{public}s %{public}s%sCFStringCreateWithCString failed, backtrace limit exceeded";
        goto LABEL_270;
      }

      BOOL v155 = Request;
      os_log_type_t v103 = (char *)__nw_create_backtrace_string();
      int v94 = (os_log_s *)__nwlog_obj();
      BOOL v95 = type[0];
      BOOL v104 = os_log_type_enabled(v94, type[0]);
      if (v103)
      {
        if (v104)
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = a1 + 284;
          *(_WORD *)&buf[22] = 2080;
          id v171 = " ";
          LOWORD(v172) = 2082;
          *(void *)((char *)&v172 + 2) = v103;
          _os_log_impl( &dword_181A5C000,  v94,  v95,  "%{public}s %{public}s%sCFStringCreateWithCString failed, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v103);
        Request = v155;
        goto LABEL_271;
      }

      Request = v155;
      if (v104)
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        id v171 = " ";
        BOOL v96 = "%{public}s %{public}s%sCFStringCreateWithCString failed, no backtrace";
LABEL_270:
        _os_log_impl(&dword_181A5C000, v94, v95, v96, buf, 0x20u);
      }
    }

        goto LABEL_208;
      }

      if (!v139)
      {
        __nwlog_obj();
        os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v132 = type;
        if (os_log_type_enabled(v101, type))
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl( &dword_181A5C000,  v101,  v132,  "%{public}s called with null (fd >= 0), backtrace limit exceeded",  location,  0xCu);
        }

        goto LABEL_207;
      }

      id v118 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v121 = type;
      os_log_type_t v122 = os_log_type_enabled(v101, type);
      if (!v118)
      {
        if (v122)
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl( &dword_181A5C000,  v101,  v121,  "%{public}s called with null (fd >= 0), no backtrace",  location,  0xCu);
        }

        goto LABEL_207;
      }

      if (v122)
      {
        *(_DWORD *)location = 136446466;
        *(void *)&location[4] = "nw_agent_create";
        uint64_t v142 = 2082;
        os_log_type_t v143 = v118;
        _os_log_impl( &dword_181A5C000,  v101,  v121,  "%{public}s called with null (fd >= 0), dumping backtrace:%{public}s",  location,  0x16u);
      }

      goto LABEL_157;
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v99 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    os_log_type_t v100 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v139 = 0;
    if (__nwlog_fault(v100, &type, &v139))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v102 = type;
        if (os_log_type_enabled(v101, type))
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_181A5C000, v101, v102, "%{public}s called with null agent", location, 0xCu);
        }

        goto LABEL_207;
      }

      if (!v139)
      {
        __nwlog_obj();
        os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_endpoint_t v131 = type;
        if (os_log_type_enabled(v101, type))
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl( &dword_181A5C000,  v101,  v131,  "%{public}s called with null agent, backtrace limit exceeded",  location,  0xCu);
        }

        goto LABEL_207;
      }

      id v118 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v119 = type;
      BOOL v120 = os_log_type_enabled(v101, type);
      if (!v118)
      {
        if (v120)
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_181A5C000, v101, v119, "%{public}s called with null agent, no backtrace", location, 0xCu);
        }

        goto LABEL_207;
      }

      if (v120)
      {
        *(_DWORD *)location = 136446466;
        *(void *)&location[4] = "nw_agent_create";
        uint64_t v142 = 2082;
        os_log_type_t v143 = v118;
        _os_log_impl( &dword_181A5C000,  v101,  v119,  "%{public}s called with null agent, dumping backtrace:%{public}s",  location,  0x16u);
      }

      if (!v73) {
        return 0LL;
      }
      id v72 = (char *)v73;
      goto LABEL_119;
    }

    if (!v103)
    {
      id v74 = (os_log_s *)__nwlog_obj();
      os_log_type_t v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v106 = "nw_protocol_http2_remove_input_handler";
        __int16 v76 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_206;
      }

      goto LABEL_207;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v74 = (os_log_s *)__nwlog_obj();
    os_log_type_t v75 = type;
    id v89 = os_log_type_enabled(v74, type);
    if (!backtrace_string)
    {
      if (v89)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v106 = "nw_protocol_http2_remove_input_handler";
        __int16 v76 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_206;
      }

      goto LABEL_207;
    }

    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v106 = "nw_protocol_http2_remove_input_handler";
      unint64_t v107 = 2082;
      nw_endpoint_t v108 = backtrace_string;
      nw_endpoint_t v87 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_162;
    }

                  free(v52);
                  goto LABEL_208;
                }
              }

              else
              {
                BOOL v51 = nw_http_metadata_copy_request(v50);
                if (!v51)
                {
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  BOOL v111 = "nw_http2_save_metadata_from_frame";
                  uint64_t v52 = (char *)_os_log_send_and_compose_impl();
                  LOBYTE(type) = 16;
                  LOBYTE(v10_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
                  if (type == 17)
                  {
                    nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
                    id v54 = type;
                    if (!os_log_type_enabled(v53, (os_log_type_t)type)) {
                      goto LABEL_206;
                    }
                    *(_DWORD *)buf = 136446210;
                    BOOL v111 = "nw_http2_save_metadata_from_frame";
                    uint64_t v55 = "%{public}s did not find request on frame";
                    goto LABEL_205;
                  }

                  if (!(_BYTE)v108)
                  {
                    nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
                    id v54 = type;
                    if (!os_log_type_enabled(v53, (os_log_type_t)type)) {
                      goto LABEL_206;
                    }
                    *(_DWORD *)buf = 136446210;
                    BOOL v111 = "nw_http2_save_metadata_from_frame";
                    uint64_t v55 = "%{public}s did not find request on frame, backtrace limit exceeded";
                    goto LABEL_205;
                  }

                  nw_endpoint_t v87 = (char *)__nw_create_backtrace_string();
                  nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
                  id v54 = type;
                  nw_endpoint_t v88 = os_log_type_enabled(v53, (os_log_type_t)type);
                  if (!v87)
                  {
                    if (!v88) {
                      goto LABEL_206;
                    }
                    *(_DWORD *)buf = 136446210;
                    BOOL v111 = "nw_http2_save_metadata_from_frame";
                    uint64_t v55 = "%{public}s did not find request on frame, no backtrace";
                    goto LABEL_205;
                  }

                  if (v88)
                  {
                    *(_DWORD *)buf = 136446466;
                    BOOL v111 = "nw_http2_save_metadata_from_frame";
                    os_log_type_t v112 = 2082;
                    *(void *)id v113 = v87;
                    id v89 = "%{public}s did not find request on frame, dumping backtrace:%{public}s";
LABEL_188:
                    _os_log_impl(&dword_181A5C000, v53, v54, v89, buf, 0x16u);
                    goto LABEL_189;
                  }

                  goto LABEL_189;
                }
              }

              os_release(v51);
              if (((*(unsigned __int16 *)(v19 + 188) | (*(unsigned __int8 *)(v19 + 190) << 16)) & 0x80000) == 0
                && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                os_log_type_t v101 = (os_log_s *)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  os_log_type_t v103 = *(_DWORD *)(v19 + 176);
                  BOOL v102 = *(_DWORD *)(v19 + 180);
                  BOOL v104 = *(void *)(v19 + 104);
                  *(_DWORD *)buf = 136448002;
                  BOOL v111 = "nw_http2_save_metadata_from_frame";
                  os_log_type_t v112 = 2082;
                  *(void *)id v113 = v19 + 191;
                  *(_WORD *)&v113[8] = 2080;
                  *(void *)&v113[10] = " ";
                  *(_WORD *)&v113[18] = 1024;
                  *(_DWORD *)&v113[20] = v102;
                  *(_WORD *)&v113[24] = 1024;
                  *(_DWORD *)&v113[26] = v103;
                  *(_WORD *)&v113[30] = 2048;
                  *(void *)&v113[32] = v104;
                  *(_WORD *)&v113[40] = 2048;
                  *(void *)&v113[42] = v19;
                  id v114 = 1024;
                  os_log_type_t v115 = v103;
                  _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> saved outbound metadata %p for stream %p (%d)",  buf,  0x46u);
                }
              }

              nw_http_transaction_metadata_set_outbound_message(*(void **)(v19 + 96), *(void **)(v19 + 104));
              nw::http::content_length_manager::set_outbound_message( (nw::http::content_length_manager *)(v19 + 40),  *(nw_protocol_metadata **)(v19 + 104));
              goto LABEL_124;
            }

            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            BOOL v111 = "nw_http2_save_metadata_from_frame";
            uint64_t v52 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(type) = 16;
            LOBYTE(v10_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
            if (__nwlog_fault(v52, &type, &v108))
            {
              if (type == 17)
              {
                nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
                id v54 = type;
                if (os_log_type_enabled(v53, (os_log_type_t)type))
                {
                  *(_DWORD *)buf = 136446210;
                  BOOL v111 = "nw_http2_save_metadata_from_frame";
                  uint64_t v55 = "%{public}s metadata must be http";
LABEL_205:
                  _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
                }
              }

              else if ((_BYTE)v108)
              {
                nw_endpoint_t v87 = (char *)__nw_create_backtrace_string();
                nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
                id v54 = type;
                id v105 = os_log_type_enabled(v53, (os_log_type_t)type);
                if (v87)
                {
                  if (v105)
                  {
                    *(_DWORD *)buf = 136446466;
                    BOOL v111 = "nw_http2_save_metadata_from_frame";
                    os_log_type_t v112 = 2082;
                    *(void *)id v113 = v87;
                    id v89 = "%{public}s metadata must be http, dumping backtrace:%{public}s";
                    goto LABEL_188;
                  }

                  goto LABEL_189;
                }

                if (v105)
                {
                  *(_DWORD *)buf = 136446210;
                  BOOL v111 = "nw_http2_save_metadata_from_frame";
                  uint64_t v55 = "%{public}s metadata must be http, no backtrace";
                  goto LABEL_205;
                }
              }

              else
              {
                nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
                id v54 = type;
                if (os_log_type_enabled(v53, (os_log_type_t)type))
                {
                  *(_DWORD *)buf = 136446210;
                  BOOL v111 = "nw_http2_save_metadata_from_frame";
                  uint64_t v55 = "%{public}s metadata must be http, backtrace limit exceeded";
                  goto LABEL_205;
                }
              }
            }
          }

          else
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            BOOL v111 = "nw_http2_save_metadata_from_frame";
            uint64_t v52 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(type) = 16;
            LOBYTE(v10_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
            if (type == 17)
            {
              nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
              id v54 = type;
              if (!os_log_type_enabled(v53, (os_log_type_t)type)) {
                goto LABEL_206;
              }
              *(_DWORD *)buf = 136446210;
              BOOL v111 = "nw_http2_save_metadata_from_frame";
              uint64_t v55 = "%{public}s cannot send on a new stream without outbound metadata";
              goto LABEL_205;
            }

            if (!(_BYTE)v108)
            {
              nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
              id v54 = type;
              if (!os_log_type_enabled(v53, (os_log_type_t)type)) {
                goto LABEL_206;
              }
              *(_DWORD *)buf = 136446210;
              BOOL v111 = "nw_http2_save_metadata_from_frame";
              uint64_t v55 = "%{public}s cannot send on a new stream without outbound metadata, backtrace limit exceeded";
              goto LABEL_205;
            }

            id v83 = (char *)__nw_create_backtrace_string();
            nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
            id v54 = type;
            uint64_t v84 = os_log_type_enabled(v53, (os_log_type_t)type);
            if (!v83)
            {
              if (!v84) {
                goto LABEL_206;
              }
              *(_DWORD *)buf = 136446210;
              BOOL v111 = "nw_http2_save_metadata_from_frame";
              uint64_t v55 = "%{public}s cannot send on a new stream without outbound metadata, no backtrace";
              goto LABEL_205;
            }

            if (v84)
            {
              *(_DWORD *)buf = 136446466;
              BOOL v111 = "nw_http2_save_metadata_from_frame";
              os_log_type_t v112 = 2082;
              *(void *)id v113 = v83;
              _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s cannot send on a new stream without outbound metadata, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v83);
          }

LABEL_226:
  if (v104) {
    free(v104);
  }
LABEL_74:
  *((_BYTE *)v271 + 33) &= ~1u;
  *(void *)__int16 v377 = 0LL;
  *(void *)&v377[8] = v377;
  *(void *)&v377[16] = 0x2020000000LL;
  if ((nw_protocol *)v357[3] == v252) {
    int v58 = 0LL;
  }
  else {
    int v58 = v252;
  }
  v378 = v58;
  *(void *)v348 = 0LL;
  v349 = v348;
  uint64_t v350 = 0x2020000000LL;
  char v351 = 0;
  v346[0] = 0LL;
  v346[1] = v346;
  v346[2] = 0x2020000000LL;
  char v347 = 0;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke;
  aBlock[3] = &unk_189BC7A40;
  os_log_type_t v59 = v29;
  v332 = v59;
  os_log_type_t v337 = v377;
  v338 = &v356;
  v339 = type;
  BOOL v345 = v51;
  nw_endpoint_t v340 = &v352;
  v343 = inited;
  __int16 v60 = v53;
  nw_endpoint_t v333 = v60;
  v341 = v348;
  id v61 = v249;
  id v334 = v61;
  nw_endpoint_t v342 = v346;
  char v62 = v271;
  BOOL v335 = v62;
  id v344 = a3;
  id v247 = v248;
  id v336 = v247;
  id v63 = _Block_copy(aBlock);
  nw_parameters_internal_iterate_protocol_stack(v60, 5, 0, v63);
  if (*((_BYTE *)v349 + 24)) {
    goto LABEL_78;
  }
  if ((*((_BYTE *)v271 + 33) & 1) != 0) {
    goto LABEL_106;
  }
  if ((*((_BYTE *)v62 + 32) & 2) == 0)
  {
    if (v252
      && (identifier = v252->identifier, identifier->level == 4)
      && (identifier ? (name = v252->identifier->name) : (name = "invalid"), strcmp(name, "endpoint_flow")))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v59) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v67 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v59);
          id v238 = v63;
          id v253 = nw_endpoint_handler_dry_run_string(v59);
          nw_endpoint_t v263 = nw_endpoint_handler_copy_endpoint(v59);
          uint64_t v69 = nw_endpoint_get_logging_description(v263);
          __int16 v70 = nw_endpoint_handler_state_string(v59);
          int v71 = nw_endpoint_handler_mode_string(v59);
          id v72 = nw_endpoint_handler_copy_current_path(v59);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = id_string;
          *(_WORD *)&buf[22] = 2082;
          v367 = v253;
          *(_WORD *)size_t v368 = 2082;
          *(void *)&v368[2] = v69;
          __int16 v369 = 2082;
          v370 = v70;
          __int16 v371 = 2082;
          uint64_t v372 = v71;
          __int16 v373 = 2114;
          id v374 = v72;
          _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] attach protocol is at appli cation level, skip joining the first non-persistent protocol",  buf,  0x48u);

          id v63 = v238;
        }
      }
    }

    else
    {
      v321[0] = MEMORY[0x1895F87A8];
      v321[1] = 3221225472LL;
      v321[2] = ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_218;
      v321[3] = &unk_189BC7A68;
      os_log_type_t v330 = a3;
      BOOL v77 = v59;
      os_log_type_t v322 = v77;
      os_log_type_t v326 = v346;
      id v323 = v61;
      id v327 = type;
      os_log_type_t v324 = v60;
      id v328 = &v356;
      os_log_type_t v329 = v348;
      __int16 v78 = v62;
      BOOL v325 = v78;
      nw_parameters_internal_iterate_protocol_stack(v324, 4, 0, v321);
      if ((*((_BYTE *)v271 + 33) & 1) == 0)
      {
        if ((nw_endpoint_handler_get_logging_disabled(v77) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          nw_endpoint_t v79 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
          {
            __int16 v80 = nw_endpoint_handler_get_id_string(v77);
            v239 = v63;
            v254 = nw_endpoint_handler_dry_run_string(v77);
            nw_endpoint_t v264 = nw_endpoint_handler_copy_endpoint(v77);
            os_log_type_t v245 = nw_endpoint_get_logging_description(v264);
            id v81 = nw_endpoint_handler_state_string(v77);
            id v82 = nw_endpoint_handler_mode_string(v77);
            id v83 = nw_endpoint_handler_copy_current_path(v77);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v80;
            *(_WORD *)&buf[22] = 2082;
            v367 = v254;
            *(_WORD *)size_t v368 = 2082;
            *(void *)&v368[2] = v245;
            __int16 v369 = 2082;
            v370 = v81;
            __int16 v371 = 2082;
            uint64_t v372 = v82;
            __int16 v373 = 2114;
            id v374 = v83;
            _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] stopping after adding per sistent application protocols",  buf,  0x48u);

            id v63 = v239;
          }
        }

        *((void *)v78 + 94) = v357[3];
      }
    }

    goto LABEL_106;
  }

  nw_parameters_internal_iterate_protocol_stack(v60, 4, 0, v63);
  if (!*((_BYTE *)v349 + 24))
  {
    if ((*((_BYTE *)v271 + 33) & 1) == 0)
    {
      uint64_t v317 = 0LL;
      int v318 = &v317;
      uint64_t v319 = 0x2020000000LL;
      char v320 = 0;
      v307[0] = MEMORY[0x1895F87A8];
      v307[1] = 3221225472LL;
      v307[2] = ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_219;
      v307[3] = &unk_189BC7A68;
      os_log_type_t v316 = a3;
      BOOL v73 = v59;
      id v308 = v73;
      v312 = v346;
      id v74 = v61;
      id v309 = v74;
      nw_endpoint_t v313 = type;
      os_log_type_t v75 = v60;
      os_log_type_t v310 = v75;
      BOOL v314 = &v356;
      v315 = &v317;
      __int16 v76 = v62;
      id v311 = v76;
      nw_parameters_internal_iterate_protocol_stack(v75, 3, 1, v307);
      if (*((_BYTE *)v318 + 24))
      {
        LOBYTE(v64) = 0;
LABEL_271:

        _Block_object_dispose(&v317, 8);
        goto LABEL_107;
      }

      if ((*((_BYTE *)v271 + 33) & 1) == 0)
      {
        v255 = (NWConcrete_nw_path_flow_registration **)v76;
        if (v51 && !*((_BYTE *)v353 + 24) && !nw_parameters_has_proxy_protocol_in_effective_config(v75))
        {
          id v240 = v63;
          uint64_t v84 = nw_endpoint_flow_add_one_protocol(v73, inited, 0LL, 0LL, *((void **)v361 + 5), v75, v357[3]);
          if (!v84)
          {
            if ((nw_endpoint_handler_get_logging_disabled(v73) & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v139 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
              {
                v265 = nw_endpoint_handler_get_id_string(v73);
                v256 = nw_endpoint_handler_dry_run_string(v73);
                nw_endpoint_t v140 = nw_endpoint_handler_copy_endpoint(v73);
                int v141 = nw_endpoint_get_logging_description(v140);
                uint64_t v142 = nw_endpoint_handler_state_string(v73);
                os_log_type_t v143 = nw_endpoint_handler_mode_string(v73);
                id v144 = nw_endpoint_handler_copy_current_path(v73);
                *(_DWORD *)buf = 136448002;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v265;
                *(_WORD *)&buf[22] = 2082;
                v367 = v256;
                *(_WORD *)size_t v368 = 2082;
                *(void *)&v368[2] = v141;
                __int16 v369 = 2082;
                v370 = v142;
                __int16 v371 = 2082;
                uint64_t v372 = v143;
                __int16 v373 = 2114;
                id v374 = v144;
                __int16 v375 = 2082;
                v376 = inited;
                _os_log_impl( &dword_181A5C000,  v139,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach filt er protocol %{public}s",  buf,  0x52u);

                id v63 = v240;
LABEL_293:
                LOBYTE(v64) = 0;
                goto LABEL_310;
              }

      objc_storeStrong((id *)location, (id)obj);
      nw_endpoint_t v209 = *location;
      if (*location) {
        nw_endpoint_t v209 = (uint64_t)(*(void *)(v209 + 24) - *(void *)(v209 + 16)) >> 3;
      }
      nw_endpoint_t v210 = v367;
      *((_DWORD *)v363 + 5) = v209;
      if (object)
      {
        int v211 = *((void *)object + 3) - *((void *)object + 2);
        if (v211)
        {
          char v212 = 0LL;
          id v213 = v211 >> 3;
          locka = &v367->lock;
          v349 = v211 >> 3;
          while (1)
          {
            nw_array_get_object_at_index((uint64_t)object, v212);
            id v214 = (void *)objc_claimAutoreleasedReturnValue();
            child_parameters = nw_endpoint_resolver_create_child_parameters(v210);
            inner = nw_endpoint_handler_create_inner( v214,  (void *)child_parameters,  nw_endpoint_resolver_receive_report,  v210,  v210,  0,  0);
            if (!inner) {
              goto LABEL_257;
            }
            id v217 = v210;
            id v218 = (*((_BYTE *)v210 + 268) & 0x20) == 0;

            if (v218)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v219 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT))
              {
                BOOL loga = v219;
                BOOL v220 = v217;

                v221 = v220;
                nw_endpoint_t v222 = (*((_BYTE *)v367 + 268) & 1) == 0;

                if (v222) {
                  int v223 = "";
                }
                else {
                  int v223 = "dry-run ";
                }
                v359 = nw_endpoint_handler_copy_endpoint(v221);
                BOOL v224 = nw_endpoint_get_logging_description(v359);
                char v355 = v223;
                v225 = v221;
                nw_endpoint_t v226 = v225;
                v227 = v351->state;
                nw_endpoint_t v228 = "unknown-state";

                v229 = v226;
                uint64_t v230 = "path";
                switch(v347[29])
                {
                  case 0u:
                    break;
                  case 1u:
                    uint64_t v230 = "resolver";
                    break;
                  case 2u:
                    uint64_t v230 = nw_endpoint_flow_mode_string(v367->mode_handler);
                    break;
                  case 3u:
                    uint64_t v230 = "proxy";
                    break;
                  case 4u:
                    uint64_t v230 = "fallback";
                    break;
                  case 5u:
                    uint64_t v230 = "transform";
                    break;
                  default:
                    uint64_t v230 = "unknown-mode";
                    break;
                }

                v231 = v229;
                os_unfair_lock_lock(locka);
                id v232 = v367->current_path;
                id v213 = v349;
                os_unfair_lock_unlock(locka);

                int v233 = v232;
                nw_endpoint_t v234 = nw_endpoint_get_logging_description(v214);
                is_known_tracker = nw_parameters_get_is_known_tracker((void *)child_parameters);
                *(_DWORD *)buf = 136448258;
                v236 = "";
                if (is_known_tracker) {
                  v236 = ", tracker";
                }
                *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_update";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v367->id_str;
                *(_WORD *)&buf[22] = 2082;
                uint64_t v379 = v355;
                *(_WORD *)v380 = 2082;
                *(void *)&v380[2] = v224;
                *(_WORD *)&v380[10] = 2082;
                *(void *)&v380[12] = v228;
                __int16 v381 = 2082;
                nw_endpoint_t v382 = v230;
                __int16 v383 = 2114;
                v384 = v233;
                __int16 v385 = 2082;
                id v386 = v234;
                __int16 v387 = 2080;
                id v388 = v236;
                _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding endpoint handl er for %{public}s%s",  buf,  0x5Cu);

                goto LABEL_254;
              }

              goto LABEL_255;
            }

    if (v188) {
      free(v188);
    }
    goto LABEL_18;
  }

  char v13 = (unsigned int *)v12;
  nw_endpoint_t v14 = v13[29];

  if ((_DWORD)v14 == 1)
  {
    obj = a1;
    BOOL v15 = v13;
    os_log_type_t v16 = *((_BYTE *)v15 + 268);

    __int16 v17 = &qword_18C45F000;
    nw_endpoint_t v269 = v15;
    os_log_type_t v258 = a4;
    int v261 = a3;
    if ((v16 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_endpoint_t v18 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = v15;

        BOOL v20 = v19;
        __int16 v21 = *((_BYTE *)v15 + 268);

        if ((v21 & 1) != 0) {
          uint64_t v22 = "dry-run ";
        }
        else {
          uint64_t v22 = "";
        }
        os_log_t log = v18;
        v251 = nw_endpoint_handler_copy_endpoint(v20);
        logging_description = nw_endpoint_get_logging_description(v251);
        int v24 = v20;
        id v25 = v24;
        char v26 = v24[30];
        else {
          id v27 = off_189BBBBF0[v26];
        }
        id v249 = v27;

        os_log_type_t v31 = v25;
        id v250 = logging_description;
        id v32 = "path";
        switch(v13[29])
        {
          case 0u:
            break;
          case 1u:
            id v32 = "resolver";
            break;
          case 2u:
            id v32 = nw_endpoint_flow_mode_string(v31[31]);
            break;
          case 3u:
            id v32 = "proxy";
            break;
          case 4u:
            id v32 = "fallback";
            break;
          case 5u:
            id v32 = "transform";
            break;
          default:
            id v32 = "unknown-mode";
            break;
        }

        nw_endpoint_t v248 = v32;

        os_log_type_t v33 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v33 + 28);
        os_log_type_t v34 = v33[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v33 + 28);

        uint64_t v35 = v34;
        id_string = nw_endpoint_handler_get_id_string(object);
        uint64_t v37 = nw_endpoint_handler_dry_run_string(object);
        v38 = nw_endpoint_handler_copy_endpoint(object);
        int v39 = v22;
        id v247 = a2;
        v254 = v13;
        BOOL v40 = nw_endpoint_get_logging_description(v38);
        os_log_type_t v41 = (char *)(v19 + 42);
        BOOL v42 = nw_endpoint_handler_state_string(object);
        nw_endpoint_t v43 = nw_endpoint_handler_mode_string(object);
        os_log_type_t v44 = nw_endpoint_handler_copy_current_path(object);
        *(_DWORD *)buf = 136449282;
        *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v41;
        v290 = 2082;
        id v291 = v39;
        os_log_type_t v292 = 2082;
        v293 = v250;
        os_log_type_t v294 = 2082;
        id v295 = (void *)v249;
        os_log_type_t v296 = 2082;
        v297 = v248;
        os_log_type_t v298 = 2114;
        id v299 = v35;
        uint64_t v300 = 2082;
        os_log_type_t v301 = (uint64_t)id_string;
        v302 = 2082;
        uint64_t v303 = v37;
        nw_endpoint_t v304 = 2082;
        uint64_t v305 = v40;
        char v306 = 2082;
        nw_endpoint_t v307 = v42;
        id v308 = 2082;
        id v309 = v43;
        os_log_type_t v310 = 2114;
        id v311 = v44;
        nw_endpoint_t v18 = log;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received child report: [C%{pu blic}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x84u);

        __int16 v17 = &qword_18C45F000;
        char v13 = v254;
        a2 = v247;
      }

      BOOL v15 = v269;
      a4 = v258;
      a3 = v261;
    }

    nw_endpoint_handler_report(v15, object, a4, v270);
    BOOL v45 = nw_endpoint_handler_copy_resolver((NWConcrete_nw_endpoint_handler *)v15);
    os_log_type_t v46 = *((void *)v45 + 5);
    if (v46 && object)
    {
      os_log_type_t v48 = *(id **)(v46 + 16);
      double v47 = *(id **)(v46 + 24);
      if (v48 != v47)
      {
        while (*v48 != object)
        {
          if (++v48 == v47)
          {
            os_log_type_t v48 = *(id **)(v46 + 24);
            break;
          }
        }
      }

      if (v48 != v47)
      {
        if (a4 && *a4 - 1 <= 1 && a4[1] == 7)
        {
          uint64_t v49 = 1;
LABEL_87:
          uint64_t v86 = networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_no_happy_eyeballs_full_stack);
          nw_endpoint_t v87 = 0;
          if (v261 == 2 && a4) {
            nw_endpoint_t v87 = *a4 == 3 && a4[1] == 5;
          }
          if (v270)
          {
            nw_endpoint_t v88 = v270;
            id v89 = v88[3];

            if (v89 > 0x3D) {
              LODWORD(v90) = 1;
            }
            else {
              os_log_type_t v90 = (0xFFFFFFFFFFFFFFEuLL >> v89) & 1;
            }
          }

          else
          {
            LODWORD(v90) = 0;
          }

          if (v261 != 3)
          {
            unint64_t v107 = *((unsigned __int8 *)v45 + 24);
            nw_endpoint_t v108 = v90 & v107;
            os_log_type_t v109 = v86 ? v87 : v90 & v107;
            if ((v108 & 1) == 0 && !v109)
            {
              if (v261 == 4)
              {
                os_log_type_t v110 = *((void *)v45 + 6);
                if (v110)
                {
                  os_log_type_t v112 = *(id **)(v110 + 16);
                  BOOL v111 = *(id **)(v110 + 24);
                  if (v112 != v111)
                  {
                    while (*v112 != object)
                    {
                      if (++v112 == v111)
                      {
                        os_log_type_t v112 = *(id **)(v110 + 24);
                        break;
                      }
                    }
                  }

                  id v113 = v269;
                  if (v112 != v111)
                  {
LABEL_130:
                    int v116 = v113;
                    uint64_t state = v116->state;

                    if (state != 5)
                    {
                      id v118 = *((void *)v45 + 6);
                      if (v118) {
                        id v118 = (uint64_t)(*(void *)(v118 + 24) - *(void *)(v118 + 16)) >> 3;
                      }
                      os_log_type_t v119 = *((void *)v45 + 5);
                      if (v119) {
                        os_log_type_t v119 = (uint64_t)(*(void *)(v119 + 24) - *(void *)(v119 + 16)) >> 3;
                      }
                      if (v118 == v119)
                      {
                        BOOL v120 = *((_BYTE *)v45 + 24);
                        if ((v120 & 4) == 0)
                        {
                          nw_endpoint_resolver_check_desperate_ivan(v116);
                          BOOL v120 = *((_BYTE *)v45 + 24);
                        }

                        if ((v120 & 8) != 0 && nw_endpoint_resolver_add_desperate_ivan(v116))
                        {
                          os_log_type_t v121 = nw_endpoint_handler_copy_context(v116);
                          v282[0] = MEMORY[0x1895F87A8];
                          v282[1] = 3221225472LL;
                          v282[2] = ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_2;
                          v282[3] = &unk_189BC93A0;
                          uint64_t v283 = v116;
                          nw_queue_context_async(v121, v282);

                          os_log_type_t v50 = (os_log_s *)v283;
                          goto LABEL_159;
                        }

                        v168 = *((_DWORD *)v45 + 4);
                        int minimize_logging = nw_endpoint_handler_get_minimize_logging(v116);
                        char logging_disabled = nw_endpoint_handler_get_logging_disabled(v116);
                        if (v168 == 1)
                        {
                          if (minimize_logging)
                          {
                            if ((logging_disabled & 1) != 0) {
                              goto LABEL_190;
                            }
                            if (v17[79] != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                            }
                            os_log_type_t v50 = (os_log_s *)(id)gconnectionLogObj;
                            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
                            {
                              nw_endpoint_t v234 = nw_endpoint_handler_get_id_string(v116);
                              id v235 = nw_endpoint_handler_dry_run_string(v116);
                              v236 = nw_endpoint_handler_copy_endpoint(v116);
                              v237 = nw_endpoint_get_logging_description(v236);
                              id v238 = nw_endpoint_handler_state_string(v116);
                              v239 = nw_endpoint_handler_mode_string(v116);
                              id v240 = nw_endpoint_handler_copy_current_path(v116);
                              *(_DWORD *)buf = 136447746;
                              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                              *(_WORD *)&buf[12] = 2082;
                              *(void *)&void buf[14] = v234;
                              v290 = 2082;
                              id v291 = v235;
                              os_log_type_t v292 = 2082;
                              v293 = v237;
                              os_log_type_t v294 = 2082;
                              id v295 = (void *)v238;
                              os_log_type_t v296 = 2082;
                              v297 = v239;
                              os_log_type_t v298 = 2114;
                              id v299 = v240;
                              _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all chi ldren failed, but resolver isn't done. Wait.",  buf,  0x48u);
                            }
                          }

                          else
                          {
                            if ((logging_disabled & 1) != 0) {
                              goto LABEL_190;
                            }
                            if (v17[79] != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                            }
                            os_log_type_t v50 = (os_log_s *)(id)gconnectionLogObj;
                            if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
                            {
                              id v171 = nw_endpoint_handler_get_id_string(v116);
                              int v172 = nw_endpoint_handler_dry_run_string(v116);
                              uint64_t v173 = nw_endpoint_handler_copy_endpoint(v116);
                              nw_endpoint_t v174 = nw_endpoint_get_logging_description(v173);
                              id v175 = nw_endpoint_handler_state_string(v116);
                              v176 = nw_endpoint_handler_mode_string(v116);
                              nw_endpoint_t v177 = nw_endpoint_handler_copy_current_path(v116);
                              *(_DWORD *)buf = 136447746;
                              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                              *(_WORD *)&buf[12] = 2082;
                              *(void *)&void buf[14] = v171;
                              v290 = 2082;
                              id v291 = v172;
                              os_log_type_t v292 = 2082;
                              v293 = v174;
                              os_log_type_t v294 = 2082;
                              id v295 = (void *)v175;
                              os_log_type_t v296 = 2082;
                              v297 = v176;
                              os_log_type_t v298 = 2114;
                              id v299 = v177;
                              _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all chi ldren failed, but resolver isn't done. Wait.",  buf,  0x48u);
                            }
                          }

                          goto LABEL_159;
                        }

                        if (minimize_logging)
                        {
                          if ((logging_disabled & 1) != 0) {
                            goto LABEL_206;
                          }
                          if (v17[79] != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          uint64_t v178 = (os_log_s *)(id)gconnectionLogObj;
                          if (os_log_type_enabled(v178, OS_LOG_TYPE_DEBUG))
                          {
                            nw_endpoint_t v268 = nw_endpoint_handler_get_id_string(v116);
                            id v241 = nw_endpoint_handler_dry_run_string(v116);
                            id v242 = nw_endpoint_handler_copy_endpoint(v116);
                            v243 = nw_endpoint_get_logging_description(v242);
                            v244 = nw_endpoint_handler_state_string(v116);
                            os_log_type_t v245 = nw_endpoint_handler_mode_string(v116);
                            int v246 = nw_endpoint_handler_copy_current_path(v116);
                            *(_DWORD *)buf = 136447746;
                            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&void buf[14] = v268;
                            v290 = 2082;
                            id v291 = v241;
                            os_log_type_t v292 = 2082;
                            v293 = v243;
                            os_log_type_t v294 = 2082;
                            id v295 = (void *)v244;
                            os_log_type_t v296 = 2082;
                            v297 = v245;
                            os_log_type_t v298 = 2114;
                            id v299 = v246;
                            _os_log_impl( &dword_181A5C000,  v178,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed",  buf,  0x48u);
                          }
                        }

                        else
                        {
                          if ((logging_disabled & 1) != 0)
                          {
LABEL_206:
                            nw_endpoint_handler_handle_failure(v116);
                            if (v49) {
                              id v186 = 7;
                            }
                            else {
                              id v186 = 5;
                            }
                            v116->event.domain = 2;
                            v116->event.event = v186;
                            nw_endpoint_handler_report(v116, 0LL, &v116->event.domain, 0LL);
                            goto LABEL_190;
                          }

                          if (v17[79] != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          uint64_t v178 = (os_log_s *)(id)gconnectionLogObj;
                          if (os_log_type_enabled(v178, OS_LOG_TYPE_INFO))
                          {
                            v265 = v178;
                            nw_protocol_definition_t v179 = nw_endpoint_handler_get_id_string(v116);
                            v180 = nw_endpoint_handler_dry_run_string(v116);
                            nw_protocol_definition_t v181 = nw_endpoint_handler_copy_endpoint(v116);
                            uint64_t v182 = nw_endpoint_get_logging_description(v181);
                            id v183 = nw_endpoint_handler_state_string(v116);
                            nw_endpoint_t v184 = nw_endpoint_handler_mode_string(v116);
                            v185 = nw_endpoint_handler_copy_current_path(v116);
                            *(_DWORD *)buf = 136447746;
                            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                            *(_WORD *)&buf[12] = 2082;
                            *(void *)&void buf[14] = v179;
                            v290 = 2082;
                            id v291 = v180;
                            os_log_type_t v292 = 2082;
                            v293 = v182;
                            os_log_type_t v294 = 2082;
                            id v295 = (void *)v183;
                            os_log_type_t v296 = 2082;
                            v297 = v184;
                            os_log_type_t v298 = 2114;
                            id v299 = v185;
                            _os_log_impl( &dword_181A5C000,  v265,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed",  buf,  0x48u);

                            uint64_t v178 = v265;
                          }
                        }

                        goto LABEL_206;
                      }

                      if (v118 != *((_DWORD *)v45 + 5)) {
                        goto LABEL_190;
                      }
                      uint64_t v153 = nw_endpoint_handler_get_minimize_logging(v116);
                      int v154 = nw_endpoint_handler_get_logging_disabled(v116);
                      if (v153)
                      {
                        if ((v154 & 1) != 0) {
                          goto LABEL_179;
                        }
                        if (v17[79] != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        v227 = (os_log_s *)(id)gconnectionLogObj;
                        if (os_log_type_enabled(v227, OS_LOG_TYPE_DEBUG))
                        {
                          v267 = nw_endpoint_handler_get_id_string(v116);
                          nw_endpoint_t v228 = nw_endpoint_handler_dry_run_string(v116);
                          v229 = nw_endpoint_handler_copy_endpoint(v116);
                          uint64_t v230 = nw_endpoint_get_logging_description(v229);
                          v231 = nw_endpoint_handler_state_string(v116);
                          id v232 = nw_endpoint_handler_mode_string(v116);
                          int v233 = nw_endpoint_handler_copy_current_path(v116);
                          *(_DWORD *)buf = 136447746;
                          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&void buf[14] = v267;
                          v290 = 2082;
                          id v291 = v228;
                          os_log_type_t v292 = 2082;
                          v293 = v230;
                          os_log_type_t v294 = 2082;
                          id v295 = (void *)v231;
                          os_log_type_t v296 = 2082;
                          v297 = v232;
                          os_log_type_t v298 = 2114;
                          id v299 = v233;
                          _os_log_impl( &dword_181A5C000,  v227,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started children failed, start next child.",  buf,  0x48u);
                        }

                        BOOL v155 = v227;
                      }

                      else
                      {
                        if ((v154 & 1) != 0)
                        {
LABEL_179:
                          if (v49)
                          {
                            int v163 = (void *)*((void *)v45 + 4);
                            *((void *)v45 + 4) = 0LL;
                          }

                          os_log_type_t v164 = nw_endpoint_handler_copy_context(v116);
                          v280[0] = MEMORY[0x1895F87A8];
                          v280[1] = 3221225472LL;
                          v280[2] = ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_111;
                          v280[3] = &unk_189BC93A0;
                          nw_endpoint_t v281 = v116;
                          nw_queue_context_async(v164, v280);

                          os_log_type_t v50 = (os_log_s *)v281;
                          goto LABEL_159;
                        }

                        if (v17[79] != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        BOOL v155 = (os_log_s *)(id)gconnectionLogObj;
                        if (os_log_type_enabled(v155, OS_LOG_TYPE_INFO))
                        {
                          int v156 = nw_endpoint_handler_get_id_string(v116);
                          v157 = nw_endpoint_handler_dry_run_string(v116);
                          nw_endpoint_t v264 = v155;
                          v158 = nw_endpoint_handler_copy_endpoint(v116);
                          nw_endpoint_t v159 = nw_endpoint_get_logging_description(v158);
                          v160 = nw_endpoint_handler_state_string(v116);
                          id v161 = nw_endpoint_handler_mode_string(v116);
                          char v162 = nw_endpoint_handler_copy_current_path(v116);
                          *(_DWORD *)buf = 136447746;
                          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&void buf[14] = v156;
                          v290 = 2082;
                          id v291 = v157;
                          os_log_type_t v292 = 2082;
                          v293 = v159;
                          os_log_type_t v294 = 2082;
                          id v295 = (void *)v160;
                          os_log_type_t v296 = 2082;
                          v297 = v161;
                          os_log_type_t v298 = 2114;
                          id v299 = v162;
                          _os_log_impl( &dword_181A5C000,  v264,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started children failed, start next child.",  buf,  0x48u);

                          BOOL v155 = v264;
                        }
                      }

                      goto LABEL_179;
                    }

            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            v149 = " ";
            nw_endpoint_t v150 = 2048;
            id v151 = a1;
            _os_log_impl( &dword_181A5C000,  v93,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s%p Frame is no longer valid",  buf,  0x2Au);
            goto LABEL_227;
          }

          if ((*(_BYTE *)(a1 + 136) & 1) != 0) {
            return 0LL;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = a1 + 137;
          *(_WORD *)&buf[22] = 2080;
          v149 = " ";
          nw_endpoint_t v150 = 2048;
          id v151 = a1;
          uint64_t v152 = 1024;
          uint64_t v153 = v14;
          int v39 = (const char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          int v147 = 0;
          if (__nwlog_fault(v39, type, &v147))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v40 = (os_log_s *)gLogObj;
              os_log_type_t v41 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              nw_endpoint_t v150 = 2048;
              id v151 = a1;
              uint64_t v152 = 1024;
              uint64_t v153 = v14;
              BOOL v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u";
LABEL_104:
              _os_log_impl(&dword_181A5C000, v40, v41, v42, buf, 0x30u);
              goto LABEL_105;
            }

            if (!v147)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v40 = (os_log_s *)gLogObj;
              os_log_type_t v41 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              nw_endpoint_t v150 = 2048;
              id v151 = a1;
              uint64_t v152 = 1024;
              uint64_t v153 = v14;
              BOOL v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, backtrace limit exceeded";
              goto LABEL_104;
            }

            nw_endpoint_t v43 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v40 = (os_log_s *)gLogObj;
            os_log_type_t v41 = type[0];
            os_log_type_t v44 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
            if (!v43)
            {
              if (!v44) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              nw_endpoint_t v150 = 2048;
              id v151 = a1;
              uint64_t v152 = 1024;
              uint64_t v153 = v14;
              BOOL v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, no backtrace";
              goto LABEL_104;
            }

            if (v44)
            {
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              nw_endpoint_t v150 = 2048;
              id v151 = a1;
              uint64_t v152 = 1024;
              uint64_t v153 = v14;
              int v154 = 2082;
              *(void *)BOOL v155 = v43;
              _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, dumping backtrace:%{public}s",  buf,  0x3Au);
            }

            free(v43);
          }
                  }

    if (v90) {
      free(v90);
    }
    uint64_t v52 = 0LL;
    goto LABEL_181;
  }

  __nwlog_obj();
  BOOL v85 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v105 = "networkd_privileged_set_settings";
  uint64_t v86 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v102 = 0;
  if (__nwlog_fault(v86, &type, &v102))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v88 = type;
      if (os_log_type_enabled(v87, type))
      {
        *(_DWORD *)buf = 136446210;
        id v105 = "networkd_privileged_set_settings";
        _os_log_impl(&dword_181A5C000, v87, v88, "%{public}s called with null key", buf, 0xCu);
      }
    }

    else if (v102)
    {
      id v93 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v94 = type;
      BOOL v95 = os_log_type_enabled(v87, type);
      if (v93)
      {
        if (v95)
        {
          *(_DWORD *)buf = 136446466;
          id v105 = "networkd_privileged_set_settings";
          os_log_type_t v106 = 2082;
          *(void *)unint64_t v107 = v93;
          _os_log_impl( &dword_181A5C000,  v87,  v94,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v93);
        goto LABEL_220;
      }

      if (v95)
      {
        *(_DWORD *)buf = 136446210;
        id v105 = "networkd_privileged_set_settings";
        _os_log_impl(&dword_181A5C000, v87, v94, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v99 = type;
      if (os_log_type_enabled(v87, type))
      {
        *(_DWORD *)buf = 136446210;
        id v105 = "networkd_privileged_set_settings";
        _os_log_impl(&dword_181A5C000, v87, v99, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

      os_release(v14);
      __int16 v21 = v118;
      uint64_t v22 = v119;
      if (!v118) {
        goto LABEL_229;
      }
      goto LABEL_227;
    }

    BOOL v15 = v119;
    os_log_type_t v16 = v15;
    endpoint = (nw_endpoint_t)v14;
    if (v15)
    {
      __int16 v17 = nw_protocol_options_copy_definition(v15);
      if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
      }
      nw_endpoint_t v18 = &unk_182665000;
      is_equal = nw_protocol_definition_is_equal( v17,  (nw_protocol_definition_t)nw_protocol_copy_http_cookie_definition_http_cookie_definition);

      if (is_equal)
      {
        *(void *)os_log_type_t v132 = 0LL;
        *(void *)&v132[8] = v132;
        *(void *)&v132[16] = 0x2020000000LL;
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = __nw_http_cookie_options_get_should_not_save_cookies_block_invoke;
        BOOL v123 = &unk_189BC60A8;
        os_log_type_t v124 = v132;
        nw_protocol_options_access_handle(v16, buf);
        BOOL v20 = *(_BYTE *)(*(void *)&v132[8] + 24LL) == 0;
        _Block_object_dispose(v132, 8);

        nw_endpoint_t v14 = endpoint;
        if (!v20) {
          goto LABEL_19;
        }
LABEL_138:
        if (!v14)
        {
          (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1LL, a3);
          __int16 v21 = v118;
          uint64_t v22 = v119;
          goto LABEL_227;
        }

        uint64_t v52 = nw_endpoint_copy_cfurl(v14);
        cookie_partition_identifier = nw_http_cookie_options_get_cookie_partition_identifier(v16);
        id v54 = v9;
        if (v52)
        {
          uint64_t v55 = objc_alloc_init(MEMORY[0x189603FA8]);
          *(void *)buf = MEMORY[0x1895F87A8];
          BOOL v56 = (const __CFString *)v18[390];
          *(void *)&buf[8] = v56;
          *(void *)&buf[16] = __nw_http_cookie_parse_block_invoke;
          BOOL v123 = &unk_189BC4AB0;
          id v125 = cookie_partition_identifier;
          uint64_t v126 = v52;
          id v114 = v52;
          BOOL v57 = v55;
          os_log_type_t v124 = v57;
          int v58 = v54;
          os_log_type_t v59 = buf;
          _nw_http_fields_enumerate_by_name((uint64_t)v58, (unint64_t)"Set-Cookie", v59);

          if ([v57 count]) {
            cf = (const void *)[v57 copy];
          }
          else {
            cf = 0LL;
          }

          nw_endpoint_t v14 = endpoint;
          if (!cf)
          {
LABEL_224:
            CFRelease(v114);
LABEL_225:
            (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1LL, a3);
            goto LABEL_226;
          }

          __int16 v60 = v16;
          id v61 = v60;
          if (v16)
          {
            char v62 = nw_protocol_options_copy_definition(v60);
            id v63 = v61;
            if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
              dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
            }
            int v64 = nw_protocol_definition_is_equal( v62,  (nw_protocol_definition_t)nw_protocol_copy_http_cookie_definition_http_cookie_definition);

            if (v64)
            {
              *(void *)os_log_type_t v132 = 0LL;
              *(void *)&v132[8] = v132;
              *(void *)&v132[16] = 0x3032000000LL;
              BOOL v133 = __Block_byref_object_copy__72694;
              os_log_type_t v134 = __Block_byref_object_dispose__72695;
              os_log_type_t v135 = 0LL;
              *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
              id v128 = v56;
              os_log_type_t v129 = __nw_http_cookie_options_copy_transform_callback_block_invoke;
              nw_endpoint_t v130 = (const __CFString *)&unk_189BC60A8;
              nw_endpoint_t v131 = v132;
              nw_protocol_options_access_handle(v63, type);
              aBlock = (uint64_t (**)(void *, const void *))_Block_copy(*(const void **)(*(void *)&v132[8]
                                                                                                 + 40LL));
              _Block_object_dispose(v132, 8);

              if (aBlock)
              {
                os_log_type_t v65 = (const void *)aBlock[2](aBlock, cf);
                if (v65) {
                  char v66 = CFRetain(v65);
                }
                else {
                  char v66 = 0LL;
                }
                CFRelease(cf);
                os_log_type_t v110 = 0;
LABEL_211:
                os_log_type_t v112 = nw_parameters_copy_main_document_cfurl(v12);
                id v91 = (const void *)nw_http_cookie_options_copy_site_for_cookies(v63);
                is_top_level_navigation = nw_http_cookie_options_get_is_top_level_navigation(v63);
                id v93 = *(_BYTE *)(v5 + 360);
                BOOL v111 = v118;
                cfa = v66;
                if (v66)
                {
                  if (v91)
                  {
                    *(void *)os_log_type_t v132 = v91;
                    *(void *)os_log_type_t type = @"_kCFHTTPCookiePolicyPropertySiteForCookies";
                    id v128 = @"_kCFHTTPCookiePolicyPropertyIsTopLevelNavigation";
                    [MEMORY[0x189607968] numberWithBool:is_top_level_navigation];
                    int v94 = (void *)objc_claimAutoreleasedReturnValue();
                    *(void *)&v132[8] = v94;
                    os_log_type_t v129 = (uint64_t (*)(uint64_t, uint64_t))@"_kCFHTTPCookiePolicyPropertyIsSafeRequest";
                    [MEMORY[0x189607968] numberWithBool:v93 & 1];
                    BOOL v95 = (void *)objc_claimAutoreleasedReturnValue();
                    nw_endpoint_t v130 = @"_kCFHTTPCookiePolicyPropertyAllowHTTPOnlyOverwrite";
                    *(void *)&v132[16] = v95;
                    BOOL v133 = (void *(*)(uint64_t, uint64_t))MEMORY[0x189604A88];
                    [MEMORY[0x189603F68] dictionaryWithObjects:v132 forKeys:type count:4];
                    BOOL v96 = (void *)objc_claimAutoreleasedReturnValue();

                    os_log_type_t v98 = v111;
                    nw_endpoint_t v97 = v112;
                  }

                  else
                  {
                    BOOL v96 = 0LL;
                    os_log_type_t v98 = v111;
                    nw_endpoint_t v97 = v112;
                  }

                  objc_msgSend( v98[1],  "_setCookies:forURL:mainDocumentURL:policyProperties:",  cfa,  v114,  v97,  v96,  v108,  v109);

LABEL_216:
                  if (v91) {
                    CFRelease(v91);
                  }
                  if (v97) {
                    CFRelease(v97);
                  }
                  nw_endpoint_t v14 = endpoint;
                  if ((v110 & 1) == 0) {
                    _Block_release(aBlock);
                  }
                  if (cfa) {
                    CFRelease(cfa);
                  }
                  goto LABEL_224;
                }

                __nwlog_obj();
                os_log_type_t v99 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)os_log_type_t v132 = 136446210;
                *(void *)&v132[4] = "nw_http_cookie_set";
                os_log_type_t v100 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                os_log_type_t v121 = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v100, type, &v121))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    BOOL v102 = type[0];
                    if (os_log_type_enabled(v101, type[0]))
                    {
                      *(_DWORD *)os_log_type_t v132 = 136446210;
                      *(void *)&v132[4] = "nw_http_cookie_set";
                      _os_log_impl(&dword_181A5C000, v101, v102, "%{public}s called with null cookies", v132, 0xCu);
                    }
                  }

                  else
                  {
                    if (v121)
                    {
                      os_log_type_t v103 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      BOOL v104 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      id v105 = type[0];
                      os_log_type_t v106 = os_log_type_enabled(v104, type[0]);
                      if (v103)
                      {
                        if (v106)
                        {
                          *(_DWORD *)os_log_type_t v132 = 136446466;
                          *(void *)&v132[4] = "nw_http_cookie_set";
                          *(_WORD *)&v132[12] = 2082;
                          *(void *)&v132[14] = v103;
                          _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s called with null cookies, dumping backtrace:%{public}s",  v132,  0x16u);
                        }

                        free(v103);
                      }

                      else
                      {
                        if (v106)
                        {
                          *(_DWORD *)os_log_type_t v132 = 136446210;
                          *(void *)&v132[4] = "nw_http_cookie_set";
                          _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s called with null cookies, no backtrace",  v132,  0xCu);
                        }
                      }

                      goto LABEL_250;
                    }

                    __nwlog_obj();
                    os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    unint64_t v107 = type[0];
                    if (os_log_type_enabled(v101, type[0]))
                    {
                      *(_DWORD *)os_log_type_t v132 = 136446210;
                      *(void *)&v132[4] = "nw_http_cookie_set";
                      _os_log_impl( &dword_181A5C000,  v101,  v107,  "%{public}s called with null cookies, backtrace limit exceeded",  v132,  0xCu);
                    }
                  }
                }

                free(backtrace_string);
                goto LABEL_227;
              }

              if (v122)
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                _os_log_impl( &dword_181A5C000,  v108,  v121,  "%{public}s called with null (configure_tcp_fallback != (_nw_parameters_configure_protocol_disable)), no backtrace",  buf,  0xCu);
              }

              goto LABEL_281;
            }
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v99 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
          BOOL v92 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          int v147 = 0;
          if (__nwlog_fault(v92, &type, &v147))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v100 = type;
              if (os_log_type_enabled(v93, type))
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                _os_log_impl( &dword_181A5C000,  v93,  v100,  "%{public}s called with null configure_quic_connection",  buf,  0xCu);
              }

              goto LABEL_255;
            }

            if (!v147)
            {
              __nwlog_obj();
              id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              nw_endpoint_t v130 = type;
              if (os_log_type_enabled(v93, type))
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                _os_log_impl( &dword_181A5C000,  v93,  v130,  "%{public}s called with null configure_quic_connection, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_255;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            nw_endpoint_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v115 = type;
            int v116 = os_log_type_enabled(v108, type);
            if (backtrace_string)
            {
              if (v116)
              {
                *(_DWORD *)buf = 136446466;
                nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                id v151 = 2082;
                uint64_t v152 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v108,  v115,  "%{public}s called with null configure_quic_connection, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              goto LABEL_226;
            }

            if (v116)
            {
              *(_DWORD *)buf = 136446210;
              nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
              _os_log_impl( &dword_181A5C000,  v108,  v115,  "%{public}s called with null configure_quic_connection, no backtrace",  buf,  0xCu);
            }

            goto LABEL_281;
          }
        }
      }

      else
      {
        __nwlog_obj();
        nw_endpoint_t v97 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
        BOOL v92 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        int v147 = 0;
        if (__nwlog_fault(v92, &type, &v147))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v98 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
              _os_log_impl(&dword_181A5C000, v93, v98, "%{public}s called with null configure_quic_stream", buf, 0xCu);
            }

            goto LABEL_255;
          }

          if (!v147)
          {
            __nwlog_obj();
            id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v129 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
              _os_log_impl( &dword_181A5C000,  v93,  v129,  "%{public}s called with null configure_quic_stream, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_255;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          nw_endpoint_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v113 = type;
          id v114 = os_log_type_enabled(v108, type);
          if (backtrace_string)
          {
            if (v114)
            {
              *(_DWORD *)buf = 136446466;
              nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
              id v151 = 2082;
              uint64_t v152 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v108,  v113,  "%{public}s called with null configure_quic_stream, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            goto LABEL_226;
          }

          if (v114)
          {
            *(_DWORD *)buf = 136446210;
            nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
            _os_log_impl( &dword_181A5C000,  v108,  v113,  "%{public}s called with null configure_quic_stream, no backtrace",  buf,  0xCu);
          }

          goto LABEL_281;
        }
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v95 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
      BOOL v92 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v147 = 0;
      if (__nwlog_fault(v92, &type, &v147))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v96 = type;
          if (os_log_type_enabled(v93, type))
          {
            *(_DWORD *)buf = 136446210;
            nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
            _os_log_impl(&dword_181A5C000, v93, v96, "%{public}s called with null configure_tcp_fallback", buf, 0xCu);
          }

          goto LABEL_255;
        }

        if (!v147)
        {
          __nwlog_obj();
          id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v128 = type;
          if (os_log_type_enabled(v93, type))
          {
            *(_DWORD *)buf = 136446210;
            nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
            _os_log_impl( &dword_181A5C000,  v93,  v128,  "%{public}s called with null configure_tcp_fallback, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_255;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_endpoint_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v111 = type;
        os_log_type_t v112 = os_log_type_enabled(v108, type);
        if (backtrace_string)
        {
          if (v112)
          {
            *(_DWORD *)buf = 136446466;
            nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
            id v151 = 2082;
            uint64_t v152 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v108,  v111,  "%{public}s called with null configure_tcp_fallback, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          goto LABEL_226;
        }

        if (v112)
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
          _os_log_impl( &dword_181A5C000,  v108,  v111,  "%{public}s called with null configure_tcp_fallback, no backtrace",  buf,  0xCu);
        }

        goto LABEL_281;
      }
    }
  }

  else
  {
    __nwlog_obj();
    id v91 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
    BOOL v92 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v147 = 0;
    if (__nwlog_fault(v92, &type, &v147))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v94 = type;
        if (os_log_type_enabled(v93, type))
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
          _os_log_impl(&dword_181A5C000, v93, v94, "%{public}s called with null configure_security", buf, 0xCu);
        }

        goto LABEL_255;
      }

      if (!v147)
      {
        __nwlog_obj();
        id v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v127 = type;
        if (os_log_type_enabled(v93, type))
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
          _os_log_impl( &dword_181A5C000,  v93,  v127,  "%{public}s called with null configure_security, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_255;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v109 = type;
      os_log_type_t v110 = os_log_type_enabled(v108, type);
      if (backtrace_string)
      {
        if (v110)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
          id v151 = 2082;
          uint64_t v152 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v108,  v109,  "%{public}s called with null configure_security, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_226;
      }

      if (v110)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
        _os_log_impl( &dword_181A5C000,  v108,  v109,  "%{public}s called with null configure_security, no backtrace",  buf,  0xCu);
      }

      goto LABEL_281;
    }
  }

          nw_endpoint_t v203 = 0;
          v204 = 0;
LABEL_227:

LABEL_228:
          uint64_t v9 = v474;
          BOOL v42 = loga;
          goto LABEL_230;
        }
      }

                    if (v76) {
                      free(v76);
                    }
                    *(_DWORD *)(v11 + 340) = -1;
                    BOOL v15 = &qword_18C45F000;
LABEL_229:
                    os_log_type_t v143 = (*(unsigned __int16 *)(v16 + 872) | (*(unsigned __int8 *)(v16 + 874) << 16)) & 0xF7FFFA | 0x80000;
                    *v69 &= 0xFFFAu;
                    *(_BYTE *)(v16 + 874) = BYTE2(v143);
                    id v144 = *(void **)(v16 + 800);
                    if (v144)
                    {
                      free(v144);
                      *(void *)(v16 + 800) = 0LL;
                    }

                    *(_DWORD *)(v16 + 840) = 0;
                    os_log_type_t v145 = *(void **)(v16 + 808);
                    if (v145)
                    {
                      free(v145);
                      *(void *)(v16 + 80_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
                    }

                    *(_DWORD *)(v16 + 844) = 0;
                    os_log_type_t v146 = *(void **)(v16 + 816);
                    if (v146)
                    {
                      free(v146);
                      *(void *)(v16 + 816) = 0LL;
                    }

                    *(_DWORD *)(v16 + 84_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
                    int v147 = *(void **)(v16 + 824);
                    if (v147)
                    {
                      free(v147);
                      *(void *)(v16 + 824) = 0LL;
                    }

                    *(_DWORD *)(v16 + 852) = 0;
                    __int16 v148 = *(void **)(v16 + 832);
                    if (v148)
                    {
                      free(v148);
                      *(void *)(v16 + 832) = 0LL;
                    }

                    *(_DWORD *)(v16 + 856) = 0;
                    v149 = (unsigned __int16)*v69;
                    nw_endpoint_t v150 = v149 | (*(unsigned __int8 *)(v16 + 874) << 16);
                    if ((v149 & 0x10) != 0)
                    {
                      if (*(_DWORD *)(v16 + 224) == 21) {
                        *(_DWORD *)(v16 + 224) = 0;
                      }
                      nw_endpoint_t v159 = v150 & 0xFFFFFFEF;
                      const char *v69 = v159;
                      *(_BYTE *)(v16 + 874) = BYTE2(v159);
                      if ((*(_BYTE *)(v16 + 158) & 1) != 0) {
                        goto LABEL_250;
                      }
                      if (!gLogDatapath) {
                        goto LABEL_250;
                      }
                      int v154 = (os_log_s *)__nwlog_obj();
                      if (!os_log_type_enabled(v154, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_250;
                      }
                      v783 = *(void *)(v16 + 488);
                      v784 = *(_DWORD *)(*(void *)(v16 + 480) + 372LL);
                      v785 = *(_DWORD *)(v16 + 860);
                      if (v783) {
                        LODWORD(v783) = *(_DWORD *)(v783 + 424);
                      }
                      *(_DWORD *)buf = 136447490;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_reset_for_new_message";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&void buf[14] = v16 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      v1051 = (uint64_t)" ";
                      *(_WORD *)v1052 = 1024;
                      *(_DWORD *)&v1052[2] = v784;
                      *(_WORD *)&v1052[6] = 1024;
                      *(_DWORD *)&v1052[8] = v785;
                      *(_WORD *)&v1052[12] = 1024;
                      *(_DWORD *)&v1052[14] = v783;
                      v158 = "%{public}s %{public}s%s<i%u:c%u:s%u> Unpausing parser, input for next stream available";
                    }

                    else
                    {
                      *(_OWORD *)(v16 + 200) = 0u;
                      id v151 = *(_BYTE *)(v16 + 272);
                      uint64_t v152 = *(void *)(v16 + 248);
                      uint64_t v153 = *(_WORD *)(v16 + 278);
                      *(_OWORD *)(v16 + 24_Block_object_dispose((const void *)(v67 - 152), 8) = 0u;
                      *(_OWORD *)(v16 + 264) = 0u;
                      *(_OWORD *)(v16 + 216) = 0u;
                      *(_OWORD *)(v16 + 232) = 0u;
                      *(void *)(v16 + 280) = 0LL;
                      *(_BYTE *)(v16 + 272) = v151;
                      *(void *)(v16 + 24_Block_object_dispose((const void *)(v67 - 152), 8) = v152;
                      *(void *)(v16 + 256) = 238LL;
                      *(_WORD *)(v16 + 27_Block_object_dispose((const void *)(v67 - 152), 8) = v153;
                      if ((*(_BYTE *)(v16 + 158) & 1) != 0) {
                        goto LABEL_250;
                      }
                      if (!gLogDatapath) {
                        goto LABEL_250;
                      }
                      int v154 = (os_log_s *)__nwlog_obj();
                      if (!os_log_type_enabled(v154, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_250;
                      }
                      BOOL v155 = *(void *)(v16 + 488);
                      int v156 = *(_DWORD *)(*(void *)(v16 + 480) + 372LL);
                      v157 = *(_DWORD *)(v16 + 860);
                      if (v155) {
                        LODWORD(v155) = *(_DWORD *)(v155 + 424);
                      }
                      *(_DWORD *)buf = 136447490;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_reset_for_new_message";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&void buf[14] = v16 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      v1051 = (uint64_t)" ";
                      *(_WORD *)v1052 = 1024;
                      *(_DWORD *)&v1052[2] = v156;
                      *(_WORD *)&v1052[6] = 1024;
                      *(_DWORD *)&v1052[8] = v157;
                      *(_WORD *)&v1052[12] = 1024;
                      *(_DWORD *)&v1052[14] = v155;
                      v158 = "%{public}s %{public}s%s<i%u:c%u:s%u> Resetting parser, no current available input for next stream";
                    }

                    _os_log_impl(&dword_181A5C000, v154, OS_LOG_TYPE_DEBUG, v158, buf, 0x32u);
                    BOOL v11 = v1042;
LABEL_250:
                    v160 = *(void *)(v16 + 784);
                    if (v160) {
                      nw_queue_cancel_source(v160, v52);
                    }
                    id v161 = *(void **)(v16 + 192);
                    *(void *)v1065 = MEMORY[0x1895F87A8];
                    *(void *)&v1065[8] = 0x40000000LL;
                    *(void *)&v1065[16] = ___ZL28nw_http1_add_idle_connectionP17nw_protocol_http1P19nw_http1_connection_block_invoke;
                    v1066 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_87_40933;
                    v1067 = (void (*)(uint64_t))v16;
                    v1068 = v161;
                    v1069 = v11;
                    source = nw_queue_context_create_source(0LL, 2, 3, 0, v1065, 0LL);
                    *(void *)(v16 + 784) = source;
                    int v163 = dispatch_time(0x8000000000000000LL, 1000000LL * (void)v161);
                    nw_queue_set_timer_values(source, v163, 0xFFFFFFFFFFFFFFFFLL, 1000LL * (void)v161);
                    nw_queue_activate_source(*(void *)(v16 + 784), v164);
                    if ((*(_BYTE *)(v16 + 158) & 1) == 0)
                    {
                      if (gLogDatapath)
                      {
                        v734 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v734, OS_LOG_TYPE_DEBUG))
                        {
                          v735 = *(void *)(v16 + 488);
                          v736 = *(_DWORD *)(*(void *)(v16 + 480) + 372LL);
                          v737 = *(_DWORD *)(v16 + 860);
                          if (v735) {
                            LODWORD(v735) = *(_DWORD *)(v735 + 424);
                          }
                          BOOL v11 = v1042;
                          v738 = *(_DWORD *)(v1042 + 340);
                          *(_DWORD *)buf = 136448258;
                          *(void *)&uint8_t buf[4] = "nw_http1_add_idle_connection";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&void buf[14] = v16 + 74;
                          *(_WORD *)&buf[22] = 2080;
                          v1051 = (uint64_t)" ";
                          *(_WORD *)v1052 = 1024;
                          *(_DWORD *)&v1052[2] = v736;
                          *(_WORD *)&v1052[6] = 1024;
                          *(_DWORD *)&v1052[8] = v737;
                          *(_WORD *)&v1052[12] = 1024;
                          *(_DWORD *)&v1052[14] = v735;
                          *(_WORD *)&v1052[18] = 2048;
                          *(void *)&v1052[20] = v16;
                          *(_WORD *)&v1052[28] = 2048;
                          *(void *)&v1052[30] = v161;
                          *(_WORD *)&v1052[38] = 1024;
                          *(_DWORD *)&v1052[40] = v738;
                          _os_log_impl( &dword_181A5C000,  v734,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> added idle connection %p and started destroy timer for %lldms, now have %u idle connections",  buf,  0x4Cu);
                        }
                      }
                    }

    if (!*(void *)(v9 + 488))
    {
      nw_endpoint_t v140 = *(void *)(v9 + 784);
      if (v140)
      {
        if (*(void *)v140)
        {
          dispatch_source_set_timer( *(dispatch_source_t *)v140,  0x8000000000000000LL,  0xFFFFFFFFFFFFFFFFLL,  0x3B9ACA00uLL);
        }

        else
        {
          *(_OWORD *)(v140 + 32) = xmmword_18272D790;
          if (*(_BYTE *)(v140 + 48) && *(_BYTE *)(v140 + 49)) {
            nw_queue_source_run_timer(v140, v57);
          }
        }
      }

      else
      {
        if ((*(_BYTE *)(v9 + 158) & 1) == 0)
        {
          int v141 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
          {
            uint64_t v142 = *(void *)(v9 + 488);
            os_log_type_t v143 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
            id v144 = *(_DWORD *)(v9 + 860);
            if (v142) {
              LODWORD(v142) = *(_DWORD *)(v142 + 424);
            }
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v9 + 74;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&_BYTE buf[24] = " ";
            *(_WORD *)&_BYTE buf[32] = 1024;
            *(_DWORD *)&buf[34] = v143;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v144;
            LOWORD(v262) = 1024;
            *(_DWORD *)((char *)&v262 + 2) = v142;
            _os_log_impl( &dword_181A5C000,  v141,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> No destroy timer on HTTP/1 connection when closing",  buf,  0x32u);
          }
        }

        os_log_type_t v145 = *(void *)(v9 + 608);
        os_log_type_t v146 = *(void **)(v9 + 496);
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL25nw_http1_connection_closeP19nw_http1_connection_block_invoke;
        *(void *)&_BYTE buf[24] = &unk_189BBD518;
        *(void *)&_BYTE buf[32] = v145;
        nw_queue_context_async(v146, buf);
      }
    }
  }

  if (v114) {
    free(v114);
  }
  nw_endpoint_t v18 = v174;
  if (v174) {
    goto LABEL_216;
  }
}
                                        }

      if (v79) {
        free(v79);
      }
      char v8 = &qword_18C45F000;
LABEL_235:
      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v111 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          id v113 = *(_DWORD *)(a3 + 176);
          os_log_type_t v112 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447490;
          uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
          int v154 = 2082;
          BOOL v155 = a3 + 191;
          int v156 = 2080;
          *(void *)v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v112;
          v158 = 1024;
          nw_endpoint_t v159 = v113;
          v160 = 2048;
          *(void *)id v161 = v11;
          _os_log_impl( &dword_181A5C000,  v111,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> couldn't send frame %p, unknown error, dropping",  buf,  0x36u);
        }
      }

      nw_frame_cache_return_frame(a1 + 200, v11);
      if ((*(_WORD *)(a1 + 388) & 4) != 0)
      {
        BOOL v15 = 0LL;
        goto LABEL_248;
      }

      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v114 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          int v116 = *(_DWORD *)(a3 + 176);
          os_log_type_t v115 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447234;
          uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
          int v154 = 2082;
          BOOL v155 = a3 + 191;
          int v156 = 2080;
          *(void *)v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v115;
          v158 = 1024;
          nw_endpoint_t v159 = v116;
          os_log_type_t v75 = "%{public}s %{public}s%s<i%u:s%d> tunnel is no longer connected";
          __int16 v76 = (os_log_s *)v114;
          BOOL v77 = OS_LOG_TYPE_ERROR;
          __int16 v78 = 44;
          goto LABEL_246;
        }
      }

      return 0LL;
    }

    os_log_type_t v90 = a4;
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v80 = (os_log_s *)__nwlog_obj();
      id v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        id v82 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_225;
      }

      goto LABEL_226;
    }

    id v91 = (char *)__nw_create_backtrace_string();
    __int16 v80 = (os_log_s *)__nwlog_obj();
    id v81 = v149[0];
    BOOL v95 = os_log_type_enabled(v80, v149[0]);
    if (!v91)
    {
      a4 = v90;
      if (v95)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        id v82 = "%{public}s called with null node, no backtrace";
        goto LABEL_225;
      }

      goto LABEL_226;
    }

    if (v95)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v153 = "nw_http2_submit_data";
      int v154 = 2082;
      BOOL v155 = (uint64_t)v91;
      id v93 = "%{public}s called with null node, dumping backtrace:%{public}s";
      goto LABEL_173;
    }

LABEL_311:
            LOBYTE(v64) = 0;
            id v63 = v240;
            goto LABEL_271;
          }

          BOOL v85 = v75;
          v357[3] = v84;
          if ((nw_endpoint_handler_get_logging_disabled(v73) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v86 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
            {
              nw_endpoint_t v87 = nw_endpoint_handler_get_id_string(v73);
              int v233 = nw_endpoint_handler_dry_run_string(v73);
              nw_endpoint_t v88 = nw_endpoint_handler_copy_endpoint(v73);
              nw_endpoint_t v228 = nw_endpoint_get_logging_description(v88);
              BOOL v224 = nw_endpoint_handler_state_string(v73);
              v221 = nw_endpoint_handler_mode_string(v73);
              id v89 = nw_endpoint_handler_copy_current_path(v73);
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v87;
              *(_WORD *)&buf[22] = 2082;
              v367 = v233;
              *(_WORD *)size_t v368 = 2082;
              *(void *)&v368[2] = v228;
              __int16 v369 = 2082;
              v370 = v224;
              __int16 v371 = 2082;
              uint64_t v372 = v221;
              __int16 v373 = 2114;
              os_log_type_t v90 = v89;
              id v374 = v89;
              __int16 v375 = 2082;
              v376 = inited;
              _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached filter protocol: %{public}s",  buf,  0x52u);

              id v63 = v240;
            }
          }

          *((_BYTE *)v353 + 24) = 1;
          os_log_type_t v75 = v85;
        }

        if ((*((_BYTE *)v271 + 33) & 1) == 0)
        {
          if ((nexus_protocol_level - 1) <= 2)
          {
            uint64_t v303 = 0LL;
            nw_endpoint_t v304 = &v303;
            uint64_t v305 = 0x2020000000LL;
            char v306 = 0;
            v293[0] = MEMORY[0x1895F87A8];
            v293[1] = 3221225472LL;
            v293[2] = ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_220;
            v293[3] = &unk_189BC7A68;
            v302 = a3;
            nw_endpoint_t v234 = v73;
            os_log_type_t v294 = v234;
            os_log_type_t v298 = v346;
            id v91 = v74;
            id v295 = v91;
            id v299 = type;
            BOOL v92 = v75;
            os_log_type_t v296 = v92;
            uint64_t v300 = &v356;
            os_log_type_t v301 = &v303;
            id v93 = v255;
            v297 = v93;
            int v94 = nw_parameters_internal_iterate_protocol_stack(v92, 3, 0, v293);
            v225 = v93;
            v229 = v91;
            if (*((_BYTE *)v304 + 24))
            {
              BOOL v95 = 0;
              LOBYTE(v64) = 0;
            }

            else
            {
              int v64 = *((unsigned __int8 *)v271 + 33);
              BOOL v95 = (v64 & 1) == 0;
              if (((v64 | v94) & 1) == 0)
              {
                id v241 = v63;
                if ((nw_endpoint_handler_get_logging_disabled(v234) & 1) != 0)
                {
                  LOBYTE(v64) = 0;
                  BOOL v95 = 1;
                }

                else
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  BOOL v111 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
                  {
                    v219 = nw_endpoint_handler_get_id_string(v234);
                    id v217 = nw_endpoint_handler_dry_run_string(v234);
                    nw_endpoint_t v222 = nw_endpoint_handler_copy_endpoint(v234);
                    uint64_t v215 = nw_endpoint_get_logging_description(v222);
                    id v214 = nw_endpoint_handler_state_string(v234);
                    os_log_type_t v112 = nw_endpoint_handler_mode_string(v234);
                    id v113 = nw_endpoint_handler_copy_current_path(v234);
                    *(_DWORD *)buf = 136447746;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&void buf[14] = v219;
                    *(_WORD *)&buf[22] = 2082;
                    v367 = v217;
                    *(_WORD *)size_t v368 = 2082;
                    *(void *)&v368[2] = v215;
                    __int16 v369 = 2082;
                    v370 = v214;
                    __int16 v371 = 2082;
                    uint64_t v372 = v112;
                    __int16 v373 = 2114;
                    id v374 = v113;
                    _os_log_impl( &dword_181A5C000,  v111,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No transport prot ocols in protocol stack",  buf,  0x48u);
                  }

                  id v63 = v241;
                  LOBYTE(v64) = 0;
                  BOOL v95 = 1;
                }
              }
            }

            _Block_object_dispose(&v303, 8);
            if (!v95) {
              goto LABEL_271;
            }
            if ((nexus_protocol_level - 1) <= 1)
            {
              int v223 = v75;
              id v242 = v63;
              uint64_t v303 = 0LL;
              nw_endpoint_t v304 = &v303;
              uint64_t v305 = 0x2020000000LL;
              char v306 = 0;
              v283[0] = MEMORY[0x1895F87A8];
              v283[1] = 3221225472LL;
              v283[2] = ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_221;
              v283[3] = &unk_189BC7A68;
              os_log_type_t v292 = a3;
              id v114 = v234;
              v284 = v114;
              v288 = v346;
              id v235 = v229;
              id v285 = v235;
              uint64_t v289 = type;
              os_log_type_t v115 = v92;
              v286 = v115;
              v290 = &v356;
              id v291 = &v303;
              uint64_t v230 = v225;
              nw_endpoint_t v287 = v230;
              int v116 = nw_parameters_internal_iterate_protocol_stack(v115, 2, 0, v283);
              if (*((_BYTE *)v304 + 24))
              {
                BOOL v117 = 0;
                LOBYTE(v64) = 0;
              }

              else
              {
                int v147 = *((unsigned __int8 *)v271 + 33);
                BOOL v117 = (v147 & 1) == 0;
                if (((v147 | v116) & 1) != 0)
                {
                  LOBYTE(v64) = v64 | v147;
                }

                else
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v114) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    __int16 v148 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
                    {
                      v149 = nw_endpoint_handler_get_id_string(v114);
                      nw_endpoint_t v226 = nw_endpoint_handler_dry_run_string(v114);
                      nw_endpoint_t v150 = nw_endpoint_handler_copy_endpoint(v114);
                      BOOL v220 = nw_endpoint_get_logging_description(v150);
                      id v218 = nw_endpoint_handler_state_string(v114);
                      nw_endpoint_t v216 = nw_endpoint_handler_mode_string(v114);
                      id v151 = nw_endpoint_handler_copy_current_path(v114);
                      *(_DWORD *)buf = 136447746;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&void buf[14] = v149;
                      *(_WORD *)&buf[22] = 2082;
                      v367 = v226;
                      *(_WORD *)size_t v368 = 2082;
                      *(void *)&v368[2] = v220;
                      __int16 v369 = 2082;
                      v370 = v218;
                      __int16 v371 = 2082;
                      uint64_t v372 = v216;
                      __int16 v373 = 2114;
                      uint64_t v152 = v151;
                      id v374 = v151;
                      _os_log_impl( &dword_181A5C000,  v148,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No internet pro tocols in protocol stack",  buf,  0x48u);
                    }
                  }

                  BOOL v117 = 1;
                }
              }

              id v63 = v242;
              _Block_object_dispose(&v303, 8);
              if (!v117) {
                goto LABEL_271;
              }
              os_log_type_t v75 = v223;
              if (nexus_protocol_level == 1)
              {
                uint64_t v303 = 0LL;
                nw_endpoint_t v304 = &v303;
                uint64_t v305 = 0x2020000000LL;
                char v306 = 0;
                v273[0] = MEMORY[0x1895F87A8];
                v273[1] = 3221225472LL;
                v273[2] = ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_222;
                v273[3] = &unk_189BC7A68;
                id v282 = a3;
                uint64_t v153 = v114;
                v274 = v153;
                nw_endpoint_t v278 = v346;
                id v275 = v235;
                v279 = type;
                int v276 = v115;
                v280 = &v356;
                nw_endpoint_t v281 = &v303;
                char v277 = v230;
                int v154 = nw_parameters_internal_iterate_protocol_stack(v276, 1, 0, v273);
                if (*((_BYTE *)v304 + 24))
                {
                  BOOL v155 = 0;
                  LOBYTE(v64) = 0;
                }

                else
                {
                  int v156 = *((unsigned __int8 *)v271 + 33);
                  BOOL v155 = (v156 & 1) == 0;
                  if (((v156 | v154) & 1) != 0)
                  {
                    LOBYTE(v64) = v64 | v156;
                  }

                  else
                  {
                    if ((nw_endpoint_handler_get_logging_disabled(v153) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v157 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
                      {
                        v158 = nw_endpoint_handler_get_id_string(v153);
                        os_log_type_t v266 = nw_endpoint_handler_dry_run_string(v153);
                        nw_endpoint_t v159 = nw_endpoint_handler_copy_endpoint(v153);
                        v236 = nw_endpoint_get_logging_description(v159);
                        v231 = nw_endpoint_handler_state_string(v153);
                        v160 = nw_endpoint_handler_mode_string(v153);
                        id v161 = nw_endpoint_handler_copy_current_path(v153);
                        *(_DWORD *)buf = 136447746;
                        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&void buf[14] = v158;
                        *(_WORD *)&buf[22] = 2082;
                        v367 = v266;
                        *(_WORD *)size_t v368 = 2082;
                        *(void *)&v368[2] = v236;
                        __int16 v369 = 2082;
                        v370 = v231;
                        __int16 v371 = 2082;
                        uint64_t v372 = v160;
                        __int16 v373 = 2114;
                        id v374 = v161;
                        _os_log_impl( &dword_181A5C000,  v157,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No link proto cols in protocol stack",  buf,  0x48u);
                      }
                    }

                    BOOL v155 = 1;
                  }
                }

                id v63 = v242;
                _Block_object_dispose(&v303, 8);
                os_log_type_t v75 = v223;
                if (!v155) {
                  goto LABEL_271;
                }
              }
            }
          }

          if ((*((_BYTE *)v255 + 34) & 2) == 0)
          {
            id v240 = v63;
            if ((*((_BYTE *)v271 + 33) & 0x40) == 0)
            {
              char v162 = nw_endpoint_flow_attach_socket_protocol(v73, (nw_protocol *)v357[3]);
              char logging_disabled = nw_endpoint_handler_get_logging_disabled(v73);
              if ((v162 & 1) != 0)
              {
                if ((logging_disabled & 1) != 0)
                {
                  LOBYTE(v64) = 1;
                  goto LABEL_271;
                }

                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                uint64_t v139 = (os_log_s *)(id)gconnectionLogObj;
                if (!os_log_type_enabled(v139, OS_LOG_TYPE_DEBUG))
                {
                  LOBYTE(v64) = 1;
                  goto LABEL_310;
                }

                v267 = nw_endpoint_handler_get_id_string(v73);
                os_log_type_t v164 = nw_endpoint_handler_dry_run_string(v73);
                nw_endpoint_t v165 = nw_endpoint_handler_copy_endpoint(v73);
                id v166 = nw_endpoint_get_logging_description(v165);
                nw_endpoint_t v167 = nw_endpoint_handler_state_string(v73);
                v168 = nw_endpoint_handler_mode_string(v73);
                id v169 = nw_endpoint_handler_copy_current_path(v73);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v267;
                *(_WORD *)&buf[22] = 2082;
                v367 = v164;
                *(_WORD *)size_t v368 = 2082;
                *(void *)&v368[2] = v166;
                __int16 v369 = 2082;
                v370 = v167;
                __int16 v371 = 2082;
                uint64_t v372 = v168;
                __int16 v373 = 2114;
                id v374 = v169;
                _os_log_impl( &dword_181A5C000,  v139,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached socket protocol",  buf,  0x48u);

                id v63 = v240;
                goto LABEL_269;
              }

              if ((logging_disabled & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                uint64_t v139 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
                {
                  id v270 = nw_endpoint_handler_get_id_string(v73);
                  v196 = nw_endpoint_handler_dry_run_string(v73);
                  nw_endpoint_t v197 = nw_endpoint_handler_copy_endpoint(v73);
                  os_log_type_t v198 = nw_endpoint_get_logging_description(v197);
                  char v199 = nw_endpoint_handler_state_string(v73);
                  uint64_t v200 = nw_endpoint_handler_mode_string(v73);
                  id v201 = nw_endpoint_handler_copy_current_path(v73);
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&void buf[14] = v270;
                  *(_WORD *)&buf[22] = 2082;
                  v367 = v196;
                  *(_WORD *)size_t v368 = 2082;
                  *(void *)&v368[2] = v198;
                  __int16 v369 = 2082;
                  v370 = v199;
                  __int16 v371 = 2082;
                  uint64_t v372 = v200;
                  __int16 v373 = 2114;
                  id v374 = v201;
                  _os_log_impl( &dword_181A5C000,  v139,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach socket protocol",  buf,  0x48u);

                  id v63 = v240;
                  goto LABEL_293;
                }

                goto LABEL_294;
              }

              goto LABEL_311;
            }

            v176 = v75;
            nw_endpoint_t v177 = (nw_protocol_options *)nw_path_flow_registration_copy_assigned_protocol(v251, v255[104]);
            nw_endpoint_t v269 = v177;
            if (v177)
            {
              uint64_t v178 = v177;
              nw_protocol_definition_t v179 = nw_protocol_options_copy_definition(v177);
              v180 = (__int128 *)nw_protocol_definition_get_identifier(v179);
              nw_protocol_definition_t v181 = v179;
              uint64_t v182 = nw_endpoint_flow_add_one_protocol(v73, v180, v178, v179, *((void **)v361 + 5), v176, v357[3]);
              if (!v182)
              {
                if ((nw_endpoint_handler_get_logging_disabled(v73) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v208 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v208, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v260 = nw_endpoint_handler_get_id_string(v73);
                    int v246 = nw_endpoint_handler_dry_run_string(v73);
                    nw_endpoint_t v209 = nw_endpoint_handler_copy_endpoint(v73);
                    nw_endpoint_t v210 = nw_endpoint_get_logging_description(v209);
                    int v211 = nw_endpoint_handler_state_string(v73);
                    char v212 = nw_endpoint_handler_mode_string(v73);
                    id v213 = nw_endpoint_handler_copy_current_path(v73);
                    *(_DWORD *)buf = 136447746;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&void buf[14] = v260;
                    *(_WORD *)&buf[22] = 2082;
                    v367 = v246;
                    *(_WORD *)size_t v368 = 2082;
                    *(void *)&v368[2] = v210;
                    __int16 v369 = 2082;
                    v370 = v211;
                    __int16 v371 = 2082;
                    uint64_t v372 = v212;
                    __int16 v373 = 2114;
                    id v374 = v213;
                    _os_log_impl( &dword_181A5C000,  v208,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach flow-assigned protocol",  buf,  0x48u);
                  }

                  id v63 = v240;
                  goto LABEL_308;
                }

                goto LABEL_307;
              }

              v357[3] = v182;
              if ((nw_endpoint_handler_get_logging_disabled(v73) & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                id v183 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v183, OS_LOG_TYPE_DEBUG))
                {
                  id v257 = nw_endpoint_handler_get_id_string(v73);
                  v237 = nw_endpoint_handler_dry_run_string(v73);
                  nw_endpoint_t v184 = nw_endpoint_handler_copy_endpoint(v73);
                  id v232 = nw_endpoint_get_logging_description(v184);
                  v227 = nw_endpoint_handler_state_string(v73);
                  v185 = nw_endpoint_handler_mode_string(v73);
                  id v186 = nw_endpoint_handler_copy_current_path(v73);
                  *(_DWORD *)buf = 136448002;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&void buf[14] = v257;
                  *(_WORD *)&buf[22] = 2082;
                  v367 = v237;
                  *(_WORD *)size_t v368 = 2082;
                  *(void *)&v368[2] = v232;
                  __int16 v369 = 2082;
                  v370 = v227;
                  __int16 v371 = 2082;
                  uint64_t v372 = v185;
                  __int16 v373 = 2114;
                  id v374 = v186;
                  __int16 v375 = 2082;
                  v376 = v180;
                  _os_log_impl( &dword_181A5C000,  v183,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached flow-assig ned protocol: %{public}s",  buf,  0x52u);
                }
              }
            }

            BOOL v187 = nw_endpoint_flow_attach_channel_protocol(v73, v357[3], nexus_protocol_level);
            char v188 = nw_endpoint_handler_get_logging_disabled(v73);
            if (v187)
            {
              if ((v188 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                nw_endpoint_t v189 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v189, OS_LOG_TYPE_DEBUG))
                {
                  v190 = nw_endpoint_handler_get_id_string(v73);
                  os_log_type_t v258 = nw_endpoint_handler_dry_run_string(v73);
                  nw_endpoint_t v191 = nw_endpoint_handler_copy_endpoint(v73);
                  v192 = nw_endpoint_get_logging_description(v191);
                  id v193 = nw_endpoint_handler_state_string(v73);
                  uint64_t v194 = nw_endpoint_handler_mode_string(v73);
                  id v195 = nw_endpoint_handler_copy_current_path(v73);
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&void buf[14] = v190;
                  *(_WORD *)&buf[22] = 2082;
                  v367 = v258;
                  *(_WORD *)size_t v368 = 2082;
                  *(void *)&v368[2] = v192;
                  __int16 v369 = 2082;
                  v370 = v193;
                  __int16 v371 = 2082;
                  uint64_t v372 = v194;
                  __int16 v373 = 2114;
                  id v374 = v195;
                  _os_log_impl( &dword_181A5C000,  v189,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached channel protocol",  buf,  0x48u);
                }

                id v63 = v240;
                LOBYTE(v64) = 1;
                goto LABEL_309;
              }

              LOBYTE(v64) = 1;
              goto LABEL_316;
            }

            if ((v188 & 1) != 0)
            {
              LOBYTE(v64) = 0;
LABEL_316:
              id v63 = v240;
              goto LABEL_309;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            nw_protocol_definition_t v181 = (nw_protocol_definition_t)(id)gconnectionLogObj;
            if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
            {
              v259 = nw_endpoint_handler_get_id_string(v73);
              id v202 = nw_endpoint_handler_dry_run_string(v73);
              nw_endpoint_t v203 = nw_endpoint_handler_copy_endpoint(v73);
              v204 = nw_endpoint_get_logging_description(v203);
              id v205 = nw_endpoint_handler_state_string(v73);
              uint64_t v206 = nw_endpoint_handler_mode_string(v73);
              id v207 = nw_endpoint_handler_copy_current_path(v73);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v259;
              *(_WORD *)&buf[22] = 2082;
              v367 = v202;
              *(_WORD *)size_t v368 = 2082;
              *(void *)&v368[2] = v204;
              __int16 v369 = 2082;
              v370 = v205;
              __int16 v371 = 2082;
              uint64_t v372 = v206;
              __int16 v373 = 2114;
              id v374 = v207;
              _os_log_impl( &dword_181A5C000,  v181,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach channel protocol",  buf,  0x48u);

              id v63 = v240;
LABEL_308:

              LOBYTE(v64) = 0;
LABEL_309:
              uint64_t v139 = v269;
              goto LABEL_310;
            }

    goto LABEL_312;
  }

  if (__nwlog_connection_group_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
  }
  uint64_t v30 = (os_log_s *)(id)gconnection_groupLogObj;
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
  {
    os_log_type_t v31 = *(void *)(a1 + 40);
    id v32 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
    if (data) {
      os_log_type_t v33 = (void *)dispatch_data_get_size(data);
    }
    else {
      os_log_type_t v33 = 0LL;
    }
    if (v10) {
      os_log_type_t v46 = nw_content_context_get_identifier(v10);
    }
    else {
      os_log_type_t v46 = "";
    }
    *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection_block_invoke";
    *(_WORD *)&buf[12] = 1024;
    double v47 = "not ";
    *(_DWORD *)buf = 136448258;
    if (a4) {
      double v47 = "";
    }
    *(_DWORD *)&void buf[14] = v32;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = v31;
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = data;
    *(_WORD *)&buf[38] = 2048;
    nw_protocol_definition_t v179 = v33;
    v180 = 2048;
    nw_protocol_definition_t v181 = v10;
    uint64_t v182 = 2080;
    id v183 = v46;
    nw_endpoint_t v184 = 2080;
    v185 = v47;
    id v186 = 2112;
    BOOL v187 = v11;
    _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] connection %@ received message (data %p, length %zu bytes, context %p %s, %scomplete, error %@)",  buf,  0x58u);
  }

  uint64_t v9 = data;
  if (!v11) {
    goto LABEL_67;
  }
LABEL_4:
  char v12 = v11;
  char v13 = v12[2];

  if (v13 != 1 || (v14 = v12, BOOL v15 = v14[3], v14, v15 != 89))
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      uint64_t v19 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        BOOL v20 = *(void *)(a1 + 40);
        __int16 v21 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection_block_invoke";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v21;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v20;
        *(_WORD *)&buf[28] = 2112;
        *(void *)&buf[30] = v12;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] encountered error on connection %@: %@",  buf,  0x26u);
      }
    }

    uint64_t v22 = *(void **)(a1 + 40);
    uint64_t v23 = *(id *)(a1 + 32);
    int v24 = v22;
    id v25 = v24;
    if (v23)
    {
      if (v24)
      {
        if (!nw_parameters_get_logging_disabled(*((void *)v23 + 7)))
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          char v26 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
          {
            id v27 = *((_DWORD *)v23 + 42);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&void buf[14] = v27;
            *(_WORD *)&buf[18] = 2112;
            *(void *)&buf[20] = v25;
            _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] cancelling connection %@",  buf,  0x1Cu);
          }
        }

        nw_connection_cancel(v25);
        if (!nw_parameters_get_logging_disabled(*((void *)v23 + 7)))
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          __int16 v28 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            BOOL v29 = *((_DWORD *)v23 + 42);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&void buf[14] = v29;
            *(_WORD *)&buf[18] = 2112;
            *(void *)&buf[20] = v25;
            _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s [G%u] cancelled %@", buf, 0x1Cu);
          }
        }

        goto LABEL_32;
      }

      __nwlog_obj();
      v38 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
      uint64_t v35 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v164) = 0;
      if (__nwlog_fault(v35, type, &v164))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v39 = type[0];
          if (os_log_type_enabled(v36, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
            _os_log_impl(&dword_181A5C000, v36, v39, "%{public}s called with null connection", buf, 0xCu);
          }
        }

        else if ((_BYTE)v164)
        {
          nw_endpoint_t v43 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v44 = type[0];
          BOOL v45 = os_log_type_enabled(v36, type[0]);
          if (v43)
          {
            if (v45)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v43;
              _os_log_impl( &dword_181A5C000,  v36,  v44,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v43);
            if (!v35) {
              goto LABEL_32;
            }
            goto LABEL_234;
          }

          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
            _os_log_impl(&dword_181A5C000, v36, v44, "%{public}s called with null connection, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v111 = type[0];
          if (os_log_type_enabled(v36, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_cancel_and_remove_connection";
            _os_log_impl( &dword_181A5C000,  v36,  v111,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_232;
      }

            goto LABEL_321;
          }

          if (!(_BYTE)buffer)
          {
            __nwlog_obj();
            nw_endpoint_t v197 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v214 = applier[0];
            if (os_log_type_enabled(v197, (os_log_type_t)applier[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
              _os_log_impl( &dword_181A5C000,  v197,  v214,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_311;
          }

          nw_endpoint_t v209 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v204 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          nw_endpoint_t v210 = applier[0];
          int v211 = os_log_type_enabled(v204, (os_log_type_t)applier[0]);
          if (v209)
          {
            if (v211)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v209;
              _os_log_impl( &dword_181A5C000,  v204,  v210,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v209);
            goto LABEL_321;
          }

          if (v211)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_181A5C000, v204, v210, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
          }

                  os_release(v64);
                  goto LABEL_312;
                }

                __nwlog_obj();
                *(_DWORD *)id v421 = 136446210;
                int v422 = "nw_http3_stream_serialize_fields";
                os_log_type_t v121 = (char *)_os_log_send_and_compose_impl();
                __int16 v389 = OS_LOG_TYPE_ERROR;
                id v388 = 0;
                int v64 = log;
                if (v389 == OS_LOG_TYPE_FAULT)
                {
                  os_log_type_t v122 = (os_log_s *)__nwlog_obj();
                  BOOL v123 = v389;
                  if (os_log_type_enabled(v122, v389))
                  {
                    *(_DWORD *)id v421 = 136446210;
                    int v422 = "nw_http3_stream_serialize_fields";
                    os_log_type_t v124 = "%{public}s lsqpack end header before starting";
LABEL_305:
                    _os_log_impl(&dword_181A5C000, v122, v123, v124, v421, 0xCu);
                  }
                }

                else if (v388)
                {
                  uint64_t v126 = (char *)__nw_create_backtrace_string();
                  os_log_type_t v122 = (os_log_s *)__nwlog_obj();
                  BOOL v123 = v389;
                  uint64_t v127 = os_log_type_enabled(v122, v389);
                  if (v126)
                  {
                    if (v127)
                    {
                      *(_DWORD *)id v421 = 136446466;
                      int v422 = "nw_http3_stream_serialize_fields";
                      v423 = 2082;
                      v424 = v126;
                      _os_log_impl( &dword_181A5C000,  v122,  v123,  "%{public}s lsqpack end header before starting, dumping backtrace:%{public}s",  v421,  0x16u);
                    }

                    free(v126);
                    goto LABEL_306;
                  }

                  if (v127)
                  {
                    *(_DWORD *)id v421 = 136446210;
                    int v422 = "nw_http3_stream_serialize_fields";
                    os_log_type_t v124 = "%{public}s lsqpack end header before starting, no backtrace";
                    goto LABEL_305;
                  }
                }

                else
                {
                  os_log_type_t v122 = (os_log_s *)__nwlog_obj();
                  BOOL v123 = v389;
                  if (os_log_type_enabled(v122, v389))
                  {
                    *(_DWORD *)id v421 = 136446210;
                    int v422 = "nw_http3_stream_serialize_fields";
                    os_log_type_t v124 = "%{public}s lsqpack end header before starting, backtrace limit exceeded";
                    goto LABEL_305;
                  }
                }

    free(v236);
    goto LABEL_312;
  }

  unsigned int mode = v8->mode;

  if (mode != 2) {
    goto LABEL_278;
  }
  nw_endpoint_t v281 = a4;
  BOOL v11 = nw_endpoint_handler_copy_flow(v9);
  v286 = v11;
  if ((*((_BYTE *)v11 + 35) & 1) != 0)
  {
    char v12 = v9;
    char v13 = *((_BYTE *)v12 + 268);

    if (!a2)
    {
      if ((v13 & 0x20) != 0)
      {
        __int16 v60 = 1LL;
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v25 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          char v26 = v12;

          id v27 = v26;
          __int16 v28 = *((_BYTE *)v12 + 268);

          if ((v28 & 1) != 0) {
            BOOL v29 = "dry-run ";
          }
          else {
            BOOL v29 = "";
          }
          uint64_t v30 = nw_endpoint_handler_copy_endpoint(v27);
          logging_description = nw_endpoint_get_logging_description(v30);
          id_str = v26->id_str;
          id v32 = v27;
          os_log_type_t v33 = v32;
          os_log_type_t v34 = v32[30];
          else {
            uint64_t v35 = off_189BBBBF0[v34];
          }

          int v39 = v33;
          BOOL v40 = v39;
          os_log_type_t v41 = "path";
          switch(v9->mode)
          {
            case 0:
              break;
            case 1:
              os_log_type_t v41 = "resolver";
              break;
            case 2:
              os_log_type_t v41 = nw_endpoint_flow_mode_string(v39[31]);
              break;
            case 3:
              os_log_type_t v41 = "proxy";
              break;
            case 4:
              os_log_type_t v41 = "fallback";
              break;
            case 5:
              os_log_type_t v41 = "transform";
              break;
            default:
              os_log_type_t v41 = "unknown-mode";
              break;
          }

          nw_endpoint_t v108 = v40;
          os_unfair_lock_lock((os_unfair_lock_t)v108 + 28);
          os_log_type_t v109 = v108[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v108 + 28);

          *(_DWORD *)buf = 136447746;
          os_log_type_t v292 = "nw_endpoint_flow_setup_protocols";
          v293 = 2082;
          os_log_type_t v294 = id_str;
          id v295 = 2082;
          os_log_type_t v296 = (nw_protocol *)v29;
          v297 = 2082;
          os_log_type_t v298 = (void *)logging_description;
          id v299 = 2082;
          uint64_t v300 = (void *)v35;
          os_log_type_t v301 = 2082;
          v302 = v41;
          uint64_t v303 = 2114;
          nw_endpoint_t v304 = v109;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already in setup protocols, skipping",  buf,  0x48u);
        }

        __int16 v60 = 1LL;
        BOOL v11 = v286;
      }

      goto LABEL_247;
    }

    if ((v13 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_endpoint_t v14 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        BOOL v15 = v12;

        os_log_type_t v16 = v15;
        __int16 v17 = *((_BYTE *)v12 + 268);

        if ((v17 & 1) != 0) {
          nw_endpoint_t v18 = "dry-run ";
        }
        else {
          nw_endpoint_t v18 = "";
        }
        uint64_t v19 = nw_endpoint_handler_copy_endpoint(v16);
        BOOL v20 = nw_endpoint_get_logging_description(v19);
        id v273 = v15->id_str;
        __int16 v21 = v16;
        uint64_t v22 = v21;
        uint64_t v23 = v21[30];
        else {
          int v24 = off_189BBBBF0[v23];
        }
        os_log_t log = (os_log_t)v24;

        os_log_type_t v36 = v22;
        uint64_t v37 = v36;
        char v277 = a3;
        v38 = "path";
        switch(v9->mode)
        {
          case 0:
            break;
          case 1:
            v38 = "resolver";
            break;
          case 2:
            v38 = nw_endpoint_flow_mode_string(v36[31]);
            break;
          case 3:
            v38 = "proxy";
            break;
          case 4:
            v38 = "fallback";
            break;
          case 5:
            v38 = "transform";
            break;
          default:
            v38 = "unknown-mode";
            break;
        }

        BOOL v42 = v37;
        os_unfair_lock_lock((os_unfair_lock_t)v42 + 28);
        nw_endpoint_t v43 = v42[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v42 + 28);

        *(_DWORD *)buf = 136448002;
        os_log_type_t v292 = "nw_endpoint_flow_setup_protocols";
        v293 = 2082;
        os_log_type_t v294 = v273;
        id v295 = 2082;
        os_log_type_t v296 = (nw_protocol *)v18;
        v297 = 2082;
        os_log_type_t v298 = (void *)v20;
        id v299 = 2082;
        uint64_t v300 = log;
        os_log_type_t v301 = 2082;
        v302 = v38;
        uint64_t v303 = 2114;
        nw_endpoint_t v304 = v43;
        uint64_t v305 = 2048;
        v306[0] = a2;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] re-entered with attach_protoc ol %p, continuing",  buf,  0x52u);

        a3 = v277;
      }

      BOOL v11 = v286;
    }
  }

  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_80157);
  }
  *((_BYTE *)v11 + 35) |= 1u;
  if ((*((_BYTE *)v11 + 32) & 0x40) != 0)
  {
    id v61 = v9;
    char v62 = (*((_BYTE *)v61 + 268) & 0x20) == 0;

    BOOL v11 = v286;
    if (v62)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v63 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
      {
        int v64 = v61;

        os_log_type_t v65 = v64;
        char v66 = (*((_BYTE *)v61 + 268) & 1) == 0;

        if (v66) {
          uint64_t v67 = "";
        }
        else {
          uint64_t v67 = "dry-run ";
        }
        os_log_type_t v68 = nw_endpoint_handler_copy_endpoint(v65);
        uint64_t v69 = nw_endpoint_get_logging_description(v68);
        __int16 v70 = v65;
        int v71 = v70;
        id v72 = v70[30];
        else {
          BOOL v73 = off_189BBBBF0[v72];
        }

        id v74 = v71;
        os_log_type_t v75 = "path";
        switch(v9->mode)
        {
          case 0:
            break;
          case 1:
            os_log_type_t v75 = "resolver";
            break;
          case 2:
            os_log_type_t v75 = nw_endpoint_flow_mode_string(v74[31]);
            break;
          case 3:
            os_log_type_t v75 = "proxy";
            break;
          case 4:
            os_log_type_t v75 = "fallback";
            break;
          case 5:
            os_log_type_t v75 = "transform";
            break;
          default:
            os_log_type_t v75 = "unknown-mode";
            break;
        }

        nw_endpoint_t v278 = v75;

        int v94 = v9;
        BOOL v95 = v68;
        BOOL v96 = v73;
        nw_endpoint_t v97 = v69;
        os_log_type_t v98 = (nw_protocol *)v67;
        os_log_type_t v99 = v74;
        os_unfair_lock_lock((os_unfair_lock_t)v99 + 28);
        os_log_type_t v100 = v99[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v99 + 28);

        os_log_type_t v101 = v97;
        BOOL v102 = v95;
        uint64_t v9 = v94;
        *(_DWORD *)buf = 136447746;
        os_log_type_t v292 = "nw_endpoint_flow_setup_protocols";
        v293 = 2082;
        os_log_type_t v294 = v64->id_str;
        id v295 = 2082;
        os_log_type_t v296 = v98;
        v297 = 2082;
        os_log_type_t v298 = (void *)v101;
        id v299 = 2082;
        uint64_t v300 = (void *)v96;
        os_log_type_t v301 = 2082;
        v302 = v278;
        uint64_t v303 = 2114;
        nw_endpoint_t v304 = v100;
        _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already set up",  buf,  0x48u);
      }

      BOOL v11 = v286;
    }

    if (!v281) {
      goto LABEL_241;
    }
    goto LABEL_130;
  }

  if ((*((_BYTE *)v11 + 32) & 4) == 0 && (a5 & 1) == 0 && !*((void *)v11 + 104))
  {
    os_log_type_t v44 = v9;
    BOOL v45 = v44[4];

    upper_transport_protocol = nw_parameters_get_upper_transport_protocol(v45);
    double v47 = v44;
    os_log_type_t v48 = (void **)v47[7];

    LODWORD(v307) = 0;
    if (v48)
    {
      uint64_t v49 = nw_path_evaluator_create_flow_inner(v48[3], upper_transport_protocol == 253, 0, 0, 0, 0LL, 0LL, 0, &v307);
      os_log_type_t v50 = (void *)*((void *)v286 + 104);
      *((void *)v286 + 104) = v49;
    }

    if (!*((void *)v286 + 104) && (*((_BYTE *)v286 + 34) & 2) == 0)
    {
      if ((nw_endpoint_handler_get_logging_disabled(v47) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v51 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          id_string = nw_endpoint_handler_get_id_string(v47);
          nw_endpoint_t v53 = nw_endpoint_handler_dry_run_string(v47);
          v284 = nw_endpoint_handler_copy_endpoint(v47);
          id v54 = nw_endpoint_get_logging_description(v284);
          uint64_t v55 = nw_endpoint_handler_state_string(v47);
          BOOL v56 = nw_endpoint_handler_mode_string(v47);
          BOOL v57 = nw_endpoint_handler_copy_current_path(v47);
          *(_DWORD *)buf = 136447746;
          os_log_type_t v292 = "nw_endpoint_flow_setup_protocols";
          v293 = 2082;
          os_log_type_t v294 = (char *)id_string;
          id v295 = 2082;
          os_log_type_t v296 = (nw_protocol *)v53;
          v297 = 2082;
          os_log_type_t v298 = (void *)v54;
          id v299 = 2082;
          uint64_t v300 = (void *)v55;
          os_log_type_t v301 = 2082;
          v302 = v56;
          uint64_t v303 = 2114;
          nw_endpoint_t v304 = v57;
          _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to request add flow",  buf,  0x48u);
        }
      }

      if ((_DWORD)v307 && !*((void *)v286 + 109))
      {
        posix_error = nw_error_create_posix_error(v307);
        os_log_type_t v59 = (void *)*((void *)v286 + 109);
        *((void *)v286 + 109) = posix_error;
      }

      nw_endpoint_flow_failed_with_error(v47, 1, 0LL);

      __int16 v60 = 0LL;
      BOOL v11 = v286;
      goto LABEL_242;
    }

    BOOL v11 = v286;
  }

  __int16 v76 = (void *)*((void *)v11 + 104);
  if (v76)
  {
    nw_endpoint_t v307 = 0uLL;
    BOOL v77 = v76;
    if (!uuid_is_null(v77 + 32)) {
      nw_endpoint_t v307 = *((_OWORD *)v77 + 2);
    }

    *(_OWORD *)((char *)v286 + 376) = v307;
    if (a2) {
      *(_OWORD *)a2->flow_id = v307;
    }
    if (nw_endpoint_handler_get_minimize_logging(v9))
    {
      nw_endpoint_t v226 = a3;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v80 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
      {
        v227 = nw_endpoint_handler_get_id_string(v9);
        nw_endpoint_t v228 = nw_endpoint_handler_dry_run_string(v9);
        v229 = nw_endpoint_handler_copy_endpoint(v9);
        uint64_t v230 = nw_endpoint_get_logging_description(v229);
        v231 = nw_endpoint_handler_state_string(v9);
        id v232 = nw_endpoint_handler_mode_string(v9);
        int v233 = nw_endpoint_handler_copy_current_path(v9);
        *(_DWORD *)buf = 136448258;
        os_log_type_t v292 = "nw_endpoint_flow_setup_protocols";
        v293 = 2082;
        os_log_type_t v294 = (char *)v227;
        id v295 = 2082;
        os_log_type_t v296 = (nw_protocol *)v228;
        v297 = 2082;
        os_log_type_t v298 = (void *)v230;
        id v299 = 2082;
        uint64_t v300 = (void *)v231;
        os_log_type_t v301 = 2082;
        v302 = v232;
        uint64_t v303 = 2114;
        nw_endpoint_t v304 = v233;
        uint64_t v305 = 1042;
        LODWORD(v306[0]) = 16;
        WORD2(v306[0]) = 2098;
        *(void *)((char *)v306 + 6) = (char *)v286 + 376;
        _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] setup flow id %{public,uuid_t}.16P",  buf,  0x58u);

        a3 = v226;
      }

      goto LABEL_127;
    }

    __int16 v78 = v9;
    nw_endpoint_t v79 = (*((_BYTE *)v78 + 268) & 0x20) == 0;

    if (v79)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v80 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
      {
        id v81 = v78;

        id v82 = v81;
        id v83 = (*((_BYTE *)v78 + 268) & 1) == 0;

        if (v83) {
          uint64_t v84 = "";
        }
        else {
          uint64_t v84 = "dry-run ";
        }
        BOOL v85 = nw_endpoint_handler_copy_endpoint(v82);
        uint64_t v86 = nw_endpoint_get_logging_description(v85);
        nw_endpoint_t v87 = v82;
        nw_endpoint_t v88 = v87;
        id v89 = v87[30];
        else {
          os_log_type_t v90 = off_189BBBBF0[v89];
        }

        id v91 = v88;
        BOOL v92 = v91;
        v274 = "path";
        switch(v9->mode)
        {
          case 0:
            goto LABEL_111;
          case 1:
            id v93 = "resolver";
            goto LABEL_110;
          case 2:
            v274 = nw_endpoint_flow_mode_string(v91[31]);
            goto LABEL_111;
          case 3:
            id v93 = "proxy";
            goto LABEL_110;
          case 4:
            id v93 = "fallback";
            goto LABEL_110;
          case 5:
            id v93 = "transform";
            goto LABEL_110;
          default:
            id v93 = "unknown-mode";
LABEL_110:
            v274 = v93;
LABEL_111:

            BOOL loga = v80;
            os_log_type_t v103 = v86;
            BOOL v104 = a3;
            id v105 = v92;
            os_unfair_lock_lock((os_unfair_lock_t)v105 + 28);
            os_log_type_t v106 = v105[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v105 + 28);

            unint64_t v107 = v103;
            __int16 v80 = loga;
            a3 = v104;
            *(_DWORD *)buf = 136448258;
            os_log_type_t v292 = "nw_endpoint_flow_setup_protocols";
            v293 = 2082;
            os_log_type_t v294 = v81->id_str;
            id v295 = 2082;
            os_log_type_t v296 = (nw_protocol *)v84;
            v297 = 2082;
            os_log_type_t v298 = (void *)v107;
            id v299 = 2082;
            uint64_t v300 = (void *)v90;
            os_log_type_t v301 = 2082;
            v302 = v274;
            uint64_t v303 = 2114;
            nw_endpoint_t v304 = v106;
            uint64_t v305 = 1042;
            LODWORD(v306[0]) = 16;
            WORD2(v306[0]) = 2098;
            *(void *)((char *)v306 + 6) = (char *)v286 + 376;
            _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] setup flow id %{public,uuid_t}.16P",  buf,  0x58u);

            break;
        }
      }

LABEL_106:
    LOBYTE(v64) = 1;
    goto LABEL_107;
  }

  if (v25) {
    free(v25);
  }
LABEL_14:
  if (handle == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v20 = a2[1].callbacks;
    if (v20)
    {
      __int16 v21 = (nw_protocol_callbacks *)((char *)v20 - 1);
      a2[1].callbacks = v21;
      if (!v21)
      {
        uint64_t v22 = *(void (***)(void))a2[1].flow_id;
        if (v22)
        {
          *(void *)a2[1].flow_id = 0LL;
          v22[2](v22);
          _Block_release(v22);
        }

        if ((a2[1].flow_id[8] & 1) != 0)
        {
          uint64_t v23 = *(const void **)a2[1].flow_id;
          if (v23) {
            _Block_release(v23);
          }
        }

        free(a2);
      }
    }
  }

  if (v4 == &nw_protocol_ref_counted_handle
    && *(_UNKNOWN **)(default_input_handler + 40) == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v10 = *(void *)(default_input_handler + 88);
    if (v10)
    {
      BOOL v11 = v10 - 1;
      *(void *)(default_input_handler + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v11;
      if (!v11)
      {
        char v12 = *(void (***)(void))(default_input_handler + 64);
        if (v12)
        {
          *(void *)(default_input_handler + 64) = 0LL;
          v12[2](v12);
          _Block_release(v12);
        }

        if ((*(_BYTE *)(default_input_handler + 72) & 1) != 0)
        {
          char v13 = *(const void **)(default_input_handler + 64);
          if (v13) {
            _Block_release(v13);
          }
        }

  if (!v2)
  {
    __nwlog_obj();
    BOOL v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v117, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v140 = "_strict_strlcat";
    id v118 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v118);
    if (result) {
      goto LABEL_268;
    }
    free(v118);
  }

  uint64_t v49 = 0LL;
  os_log_type_t v50 = 107LL;
  while (1)
  {
    BOOL v51 = &v2[v49];
    if (!v2[v49]) {
      break;
    }
    ++v49;
    if (!--v50) {
      goto LABEL_118;
    }
  }

  if (v50 < 2)
  {
LABEL_117:
    *BOOL v51 = 0;
  }

  else
  {
    uint64_t v52 = v50 - 2;
    nw_endpoint_t v53 = 106 - v49;
    id v54 = 105 - v49;
    if (v54 >= 0xF) {
      id v54 = 15LL;
    }
    memcpy(v51, "interface_added", v54 + 1);
    BOOL v51 = v2 + 106;
    while (v52 <= 0xE)
    {
      if (!--v53) {
        goto LABEL_117;
      }
    }
  }

          goto LABEL_107;
        }

        if (v127 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v61 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            nw_endpoint_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
            nw_endpoint_t v131 = 2112;
            *(void *)os_log_type_t v132 = a1;
            *(_WORD *)&v132[8] = 1024;
            *(_DWORD *)&v132[10] = v35;
            _os_log_impl( &dword_181A5C000,  v38,  v61,  "%{public}s %@: createChannel failed to set key <err %d> , backtrace limit exceeded",  buf,  0x1Cu);
          }

          goto LABEL_106;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type[0];
        double v47 = os_log_type_enabled(v38, type[0]);
        if (!backtrace_string)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446722;
            nw_endpoint_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
            nw_endpoint_t v131 = 2112;
            *(void *)os_log_type_t v132 = a1;
            *(_WORD *)&v132[8] = 1024;
            *(_DWORD *)&v132[10] = v35;
            _os_log_impl( &dword_181A5C000,  v38,  v46,  "%{public}s %@: createChannel failed to set key <err %d> , no backtrace",  buf,  0x1Cu);
          }

          goto LABEL_106;
        }

        if (v47)
        {
          *(_DWORD *)buf = 136446978;
          nw_endpoint_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          nw_endpoint_t v131 = 2112;
          *(void *)os_log_type_t v132 = a1;
          *(_WORD *)&v132[8] = 1024;
          *(_DWORD *)&v132[10] = v35;
          *(_WORD *)&v132[14] = 2082;
          *(void *)&v132[16] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v38,  v46,  "%{public}s %@: createChannel failed to set key <err %d> , dumping backtrace:%{public}s",  buf,  0x26u);
        }

LABEL_107:
  if (v50) {
    free(v50);
  }
  char v26 = 0LL;
LABEL_110:

LABEL_111:
  return (NWMonitor *)v26;
}

    free(v69);
    goto LABEL_168;
  }

  __nwlog_obj();
  os_log_type_t v46 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
  double v47 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v115) = 0;
  if (__nwlog_fault(v47, type, &v115))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v49 = type[0];
      if (os_log_type_enabled(v48, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        _os_log_impl(&dword_181A5C000, v48, v49, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)v115)
    {
      char v66 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v67 = type[0];
      os_log_type_t v68 = os_log_type_enabled(v48, type[0]);
      if (v66)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v66;
          _os_log_impl( &dword_181A5C000,  v48,  v67,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v66);
        goto LABEL_156;
      }

      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        _os_log_impl(&dword_181A5C000, v48, v67, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v90 = type[0];
      if (os_log_type_enabled(v48, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        _os_log_impl( &dword_181A5C000,  v48,  v90,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        if (!v63) {
          goto LABEL_117;
        }
        goto LABEL_107;
      }
    }

    parameters = (void *)nw_protocol_get_parameters(v51);
    uint64_t v55 = nw_parameters_copy_effective_proxy_config(parameters);
    a6 = v119;
    if (!v55) {
      goto LABEL_117;
    }
    BOOL v56 = (id *)v55;
    BOOL v57 = v56[5];

    if (!v57)
    {
LABEL_116:
      os_release(v56);
      goto LABEL_117;
    }

    int v58 = v57;
    os_log_type_t v59 = [v58 type];

    if (v59 == 1)
    {
      char v62 = nw_endpoint_copy_address_string((nw_endpoint_t)v58);
      id v61 = 0LL;
    }

    else
    {
      if (v59 != 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v85 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_set_proxy_url";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v59;
          _os_log_impl(&dword_181A5C000, v85, OS_LOG_TYPE_ERROR, "%{public}s Unsupported endpoint type: %d", buf, 0x12u);
        }

                free(v39);
                goto LABEL_107;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v34 = (id)gLogObj;
              *(_DWORD *)buf = 136446210;
              nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
              uint64_t v35 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              int v147 = 0;
              if (__nwlog_fault(v35, &type, &v147))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v36 = (os_log_s *)(id)gLogObj;
                  uint64_t v37 = type;
                  if (os_log_type_enabled(v36, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    nw_endpoint_t v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                    _os_log_impl(&dword_181A5C000, v36, v37, "%{public}s nw_parameters_create failed", buf, 0xCu);
                  }

      if (v22) {
        free(v22);
      }
LABEL_108:
      char v8 = 0LL;
      goto LABEL_109;
    }

    __nwlog_obj();
    *(_DWORD *)int v64 = 136446210;
    os_log_type_t v65 = "network_config_setup_policy_event_watcher";
    char v12 = (char *)_os_log_send_and_compose_impl();
    int v58 = OS_LOG_TYPE_ERROR;
    BOOL v56 = 0;
    if (v58 == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v43 = (os_log_s *)__nwlog_obj();
      os_log_type_t v44 = v58;
      if (!os_log_type_enabled(v43, v58)) {
        goto LABEL_96;
      }
      *(_DWORD *)int v64 = 136446210;
      os_log_type_t v65 = "network_config_setup_policy_event_watcher";
      BOOL v15 = "%{public}s dispatch_source_create failed";
    }

    else if (v56)
    {
      os_log_type_t v36 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v43 = (os_log_s *)__nwlog_obj();
      os_log_type_t v44 = v58;
      os_log_type_t v48 = os_log_type_enabled(v43, v58);
      if (v36)
      {
        if (v48)
        {
          *(_DWORD *)int v64 = 136446466;
          os_log_type_t v65 = "network_config_setup_policy_event_watcher";
          char v66 = 2082;
          *(void *)uint64_t v67 = v36;
          v38 = "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s";
          int v39 = v43;
          BOOL v40 = v44;
          os_log_type_t v41 = 22;
          goto LABEL_60;
        }

                  os_log_type_t v98 = 0LL;
                  goto LABEL_107;
                }

                if (v99 == 2)
                {
                  os_log_type_t v100 = objc_alloc_init(MEMORY[0x189603FB8]);
                  buf[0] = 4;
                  [v100 appendBytes:buf length:1];
                  [v100 appendBytes:&v98->sa_data[2] length:4];
                  [v100 appendBytes:&v98->sa_data[2] length:4];
                  v130[0] = *(_BYTE *)(a1 + 48);
                  [v100 appendBytes:v130 length:1];
                  if (v100) {
                    goto LABEL_104;
                  }
                  goto LABEL_106;
                }

                os_log_type_t v98 = 0LL;
              }

          goto LABEL_122;
        }

        if (!v80)
        {
          __nwlog_obj();
          os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v75 = type;
          if (os_log_type_enabled(v46, type))
          {
            *(_DWORD *)buf = 136446210;
            id v83 = "nw_pac_resolver_create_with_url";
            _os_log_impl( &dword_181A5C000,  v46,  v75,  "%{public}s called with null result_handler, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_106;
        }

        int v58 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v64 = type;
        os_log_type_t v65 = os_log_type_enabled(v59, type);
        if (v58)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136446466;
            id v83 = "nw_pac_resolver_create_with_url";
            uint64_t v84 = 2082;
            BOOL v85 = v58;
            _os_log_impl( &dword_181A5C000,  v59,  v64,  "%{public}s called with null result_handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

      self->fallback_disposition = 1;
      goto LABEL_107;
    }

    __nwlog_obj();
    id v201 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_traffic_class_is_background";
    id v202 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v257) = 0;
    if (__nwlog_fault(v202, type, &v257))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_endpoint_t v203 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v204 = type[0];
        if (os_log_type_enabled(v203, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_traffic_class_is_background";
          _os_log_impl(&dword_181A5C000, v203, v204, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if ((_BYTE)v257)
      {
        nw_endpoint_t v226 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_endpoint_t v203 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v227 = type[0];
        nw_endpoint_t v228 = os_log_type_enabled(v203, type[0]);
        if (v226)
        {
          if (v228)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_parameters_traffic_class_is_background";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v226;
            _os_log_impl( &dword_181A5C000,  v203,  v227,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v226);
          goto LABEL_284;
        }

        if (v228)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_traffic_class_is_background";
          _os_log_impl(&dword_181A5C000, v203, v227, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        nw_endpoint_t v203 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v229 = type[0];
        if (os_log_type_enabled(v203, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_traffic_class_is_background";
          _os_log_impl( &dword_181A5C000,  v203,  v229,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v62) {
    free(v62);
  }
  *nw_endpoint_t v87 = 0;
}

              uint64_t v49 = log;
              if (v45) {
                free(v45);
              }
LABEL_108:
              nw_frame_claim(a2, v29, v49 + v18 + v41, 0);
              nw_frame_collapse(a2);
              nw_frame_unclaim(a2, v63, v49 + v18 + v41, 0);
LABEL_109:
              BOOL v7 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
              goto LABEL_110;
            }

            if (!v137)
            {
              id v105 = (os_log_s *)__nwlog_obj();
              os_log_type_t v106 = v138;
              if (os_log_type_enabled(v105, v138))
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v140 = "nw_http1_connection_write_chunk_trailer";
                unint64_t v107 = "%{public}s called with null http1_connection, backtrace limit exceeded";
                goto LABEL_267;
              }

              goto LABEL_268;
            }

            BOOL v123 = (char *)__nw_create_backtrace_string();
            id v105 = (os_log_s *)__nwlog_obj();
            os_log_type_t v106 = v138;
            os_log_type_t v124 = os_log_type_enabled(v105, v138);
            if (!v123)
            {
              if (v124)
              {
                *(_DWORD *)buf = 136446210;
                nw_endpoint_t v140 = "nw_http1_connection_write_chunk_trailer";
                unint64_t v107 = "%{public}s called with null http1_connection, no backtrace";
                goto LABEL_267;
              }

              goto LABEL_268;
            }

            if (v124)
            {
              *(_DWORD *)buf = 136446466;
              nw_endpoint_t v140 = "nw_http1_connection_write_chunk_trailer";
              int v141 = 2082;
              uint64_t v142 = v123;
              id v125 = "%{public}s called with null http1_connection, dumping backtrace:%{public}s";
LABEL_207:
              _os_log_impl(&dword_181A5C000, v105, v106, v125, buf, 0x16u);
            }
          }

          free(v123);
          goto LABEL_268;
        }

        BOOL v95 = v18;
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v140 = "nw_http1_connection_write_chunk_header";
        os_log_type_t v100 = (char *)_os_log_send_and_compose_impl();
        v138 = OS_LOG_TYPE_ERROR;
        nw_endpoint_t v137 = 0;
        if (__nwlog_fault(v100, &v138, &v137))
        {
          if (v138 == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v101 = (os_log_s *)__nwlog_obj();
            BOOL v102 = v138;
            if (!os_log_type_enabled(v101, v138)) {
              goto LABEL_246;
            }
            *(_DWORD *)buf = 136446210;
            nw_endpoint_t v140 = "nw_http1_connection_write_chunk_header";
            os_log_type_t v103 = "%{public}s called with null usable_size";
            goto LABEL_244;
          }

          if (!v137)
          {
            os_log_type_t v101 = (os_log_s *)__nwlog_obj();
            BOOL v102 = v138;
            if (!os_log_type_enabled(v101, v138)) {
              goto LABEL_246;
            }
            *(_DWORD *)buf = 136446210;
            nw_endpoint_t v140 = "nw_http1_connection_write_chunk_header";
            os_log_type_t v103 = "%{public}s called with null usable_size, backtrace limit exceeded";
            goto LABEL_244;
          }

          os_log_type_t v115 = (char *)__nw_create_backtrace_string();
          os_log_type_t v121 = (os_log_s *)__nwlog_obj();
          BOOL v102 = v138;
          os_log_type_t v132 = v121;
          os_log_type_t v122 = os_log_type_enabled(v121, v138);
          if (v115)
          {
            if (!v122) {
              goto LABEL_197;
            }
            *(_DWORD *)buf = 136446466;
            nw_endpoint_t v140 = "nw_http1_connection_write_chunk_header";
            int v141 = 2082;
            uint64_t v142 = v115;
            id v118 = "%{public}s called with null usable_size, dumping backtrace:%{public}s";
LABEL_196:
            _os_log_impl(&dword_181A5C000, v132, v102, v118, buf, 0x16u);
LABEL_197:
            free(v115);
            if (!v100) {
              goto LABEL_248;
            }
            goto LABEL_247;
          }

          if (v122)
          {
            *(_DWORD *)buf = 136446210;
            nw_endpoint_t v140 = "nw_http1_connection_write_chunk_header";
            os_log_type_t v103 = "%{public}s called with null usable_size, no backtrace";
            goto LABEL_273;
          }
        }

    if (v32) {
      free(v32);
    }
    nw_endpoint_t v14 = 0LL;
    if (v10 != &nw_protocol_ref_counted_handle) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v48 = "nw_protocol_common_get_input_frames";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v45 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = (os_log_s *)gLogObj;
    __int16 v21 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s get_input_frames requires an output handler";
LABEL_47:
      _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      goto LABEL_48;
    }

    goto LABEL_48;
  }

  if (v45)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = (os_log_s *)gLogObj;
    __int16 v21 = type;
    int v24 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_protocol_common_get_input_frames";
        uint64_t v22 = "%{public}s get_input_frames requires an output handler, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (!v24)
    {
LABEL_34:
      free(backtrace_string);
      goto LABEL_48;
    }

    *(_DWORD *)buf = 136446466;
    os_log_type_t v48 = "nw_protocol_common_get_input_frames";
    uint64_t v49 = 2082;
    os_log_type_t v50 = backtrace_string;
    id v25 = "%{public}s get_input_frames requires an output handler, dumping backtrace:%{public}s";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v20, v21, v25, buf, 0x16u);
    goto LABEL_34;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v20 = (os_log_s *)gLogObj;
  __int16 v21 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v48 = "nw_protocol_common_get_input_frames";
    uint64_t v22 = "%{public}s get_input_frames requires an output handler, backtrace limit exceeded";
    goto LABEL_47;
  }

    if (v32) {
      free(v32);
    }
    nw_endpoint_t v14 = 0LL;
    if (v10 != &nw_protocol_ref_counted_handle) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v48 = "nw_protocol_common_get_output_frames";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v45 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = (os_log_s *)gLogObj;
    __int16 v21 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s get_ouput_frames requires an output handler";
LABEL_47:
      _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      goto LABEL_48;
    }

    goto LABEL_48;
  }

  if (v45)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = (os_log_s *)gLogObj;
    __int16 v21 = type;
    int v24 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v48 = "nw_protocol_common_get_output_frames";
        uint64_t v22 = "%{public}s get_ouput_frames requires an output handler, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (!v24)
    {
LABEL_34:
      free(backtrace_string);
      goto LABEL_48;
    }

    *(_DWORD *)buf = 136446466;
    os_log_type_t v48 = "nw_protocol_common_get_output_frames";
    uint64_t v49 = 2082;
    os_log_type_t v50 = backtrace_string;
    id v25 = "%{public}s get_ouput_frames requires an output handler, dumping backtrace:%{public}s";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v20, v21, v25, buf, 0x16u);
    goto LABEL_34;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v20 = (os_log_s *)gLogObj;
  __int16 v21 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v48 = "nw_protocol_common_get_output_frames";
    uint64_t v22 = "%{public}s get_ouput_frames requires an output handler, backtrace limit exceeded";
    goto LABEL_47;
  }

    if (v29) {
      free(v29);
    }
    BOOL v11 = 0LL;
    if (v7 != &nw_protocol_ref_counted_handle) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  BOOL v45 = "nw_protocol_common_register_notification";
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v42 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)gLogObj;
    nw_endpoint_t v18 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s register_notification requires an output handler";
LABEL_47:
      _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
      goto LABEL_48;
    }

    goto LABEL_48;
  }

  if (v42)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)gLogObj;
    nw_endpoint_t v18 = type;
    __int16 v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v45 = "nw_protocol_common_register_notification";
        uint64_t v19 = "%{public}s register_notification requires an output handler, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (!v21)
    {
LABEL_34:
      free(backtrace_string);
      goto LABEL_48;
    }

    *(_DWORD *)buf = 136446466;
    BOOL v45 = "nw_protocol_common_register_notification";
    os_log_type_t v46 = 2082;
    double v47 = backtrace_string;
    uint64_t v22 = "%{public}s register_notification requires an output handler, dumping backtrace:%{public}s";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v17, v18, v22, buf, 0x16u);
    goto LABEL_34;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v17 = (os_log_s *)gLogObj;
  nw_endpoint_t v18 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v45 = "nw_protocol_common_register_notification";
    uint64_t v19 = "%{public}s register_notification requires an output handler, backtrace limit exceeded";
    goto LABEL_47;
  }

    if (v29) {
      free(v29);
    }
    BOOL v11 = 0LL;
    if (v7 != &nw_protocol_ref_counted_handle) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  BOOL v45 = "nw_protocol_common_unregister_notification";
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v42 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)gLogObj;
    nw_endpoint_t v18 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s unregister_notification requires an output handler";
LABEL_47:
      _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
      goto LABEL_48;
    }

    goto LABEL_48;
  }

  if (v42)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)gLogObj;
    nw_endpoint_t v18 = type;
    __int16 v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v45 = "nw_protocol_common_unregister_notification";
        uint64_t v19 = "%{public}s unregister_notification requires an output handler, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (!v21)
    {
LABEL_34:
      free(backtrace_string);
      goto LABEL_48;
    }

    *(_DWORD *)buf = 136446466;
    BOOL v45 = "nw_protocol_common_unregister_notification";
    os_log_type_t v46 = 2082;
    double v47 = backtrace_string;
    uint64_t v22 = "%{public}s unregister_notification requires an output handler, dumping backtrace:%{public}s";
LABEL_33:
    _os_log_impl(&dword_181A5C000, v17, v18, v22, buf, 0x16u);
    goto LABEL_34;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v17 = (os_log_s *)gLogObj;
  nw_endpoint_t v18 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v45 = "nw_protocol_common_unregister_notification";
    uint64_t v19 = "%{public}s unregister_notification requires an output handler, backtrace limit exceeded";
    goto LABEL_47;
  }

  if (v26) {
    free(v26);
  }
LABEL_14:
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    __int16 v21 = *(void *)(a2 + 88);
    if (v21)
    {
      uint64_t v22 = v21 - 1;
      *(void *)(a2 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v22;
      if (!v22)
      {
        uint64_t v23 = *(void (***)(void))(a2 + 64);
        if (v23)
        {
          *(void *)(a2 + 64) = 0LL;
          v23[2](v23);
          _Block_release(v23);
        }

        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          int v24 = *(const void **)(a2 + 64);
          if (v24) {
            _Block_release(v24);
          }
        }

        free((void *)a2);
      }
    }
  }

  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    BOOL v11 = *(void *)(v4 + 88);
    if (v11)
    {
      char v12 = v11 - 1;
      *(void *)(v4 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v12;
      if (!v12)
      {
        char v13 = *(void (***)(void))(v4 + 64);
        if (v13)
        {
          *(void *)(v4 + 64) = 0LL;
          v13[2](v13);
          _Block_release(v13);
        }

        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          nw_endpoint_t v14 = *(const void **)(v4 + 64);
          if (v14) {
            _Block_release(v14);
          }
        }

    if (!v48) {
      return 4294966394LL;
    }
    int v39 = (char *)v48;
    goto LABEL_68;
  }

  if (!gLogDatapath) {
    return 0LL;
  }
  double v47 = (os_log_s *)__nwlog_obj();
  result = os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    *(_DWORD *)buf = 136446210;
    int v64 = "before_frame_send_callback";
    _os_log_impl(&dword_181A5C000, v47, OS_LOG_TYPE_DEBUG, "%{public}s ignoring frame on stream 0", buf, 0xCu);
    return 0LL;
  }

  return result;
}

  __int16 v60 = size + v51;
  if (v60 < 0x40)
  {
    BOOL v56 = 1;
    uint64_t v55 = size + v51;
LABEL_116:
    int v58 = v60 + (v56 + v50);
    BOOL v57 = (dispatch_object_s *)v162;
    goto LABEL_117;
  }

  if (!(v60 >> 14))
  {
    uint64_t v55 = bswap32(v60 | 0x4000) >> 16;
    BOOL v56 = 2;
    goto LABEL_116;
  }

  if (!(v60 >> 30))
  {
    uint64_t v55 = bswap32(v60 | 0x80000000);
    BOOL v56 = 4;
    goto LABEL_116;
  }

  if (!(v60 >> 62))
  {
    uint64_t v55 = bswap64(v60 | 0xC000000000000000LL);
    BOOL v56 = 8;
    goto LABEL_116;
  }

  int v154 = v50;
  BOOL v155 = v51;
  nw_endpoint_t v159 = v47;
  id v161 = v48;
  os_log_type_t v164 = size;
  id v61 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
  buf = 136446466;
  v231 = "_http_vle_encode";
  id v232 = 2048;
  int v233 = v60;
  v157 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v157);
  if (!(_DWORD)result)
  {
    free(v157);
    uint64_t v55 = 0LL;
    BOOL v56 = 0;
    double v47 = v159;
    os_log_type_t v48 = v161;
    size = v164;
    os_log_type_t v50 = v154;
    LOBYTE(v51) = v155;
    goto LABEL_116;
  }

    LODWORD(v52) = v52 | 0x200;
    if (a19)
    {
LABEL_93:
      LODWORD(v52) = v52 | 0x800;
      if (!a20) {
        return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
      }
      goto LABEL_108;
    }

  if (v16) {
LABEL_107:
  }
    free(v16);
LABEL_108:
}

  if (v25) {
    free(v25);
  }
LABEL_14:
  if (handle == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v20 = a2[1].callbacks;
    if (v20)
    {
      __int16 v21 = (nw_protocol_callbacks *)((char *)v20 - 1);
      a2[1].callbacks = v21;
      if (!v21)
      {
        uint64_t v22 = *(void (***)(void))a2[1].flow_id;
        if (v22)
        {
          *(void *)a2[1].flow_id = 0LL;
          v22[2](v22);
          _Block_release(v22);
        }

        if ((a2[1].flow_id[8] & 1) != 0)
        {
          uint64_t v23 = *(const void **)a2[1].flow_id;
          if (v23) {
            _Block_release(v23);
          }
        }

        free(a2);
      }
    }
  }

  if (v4 == &nw_protocol_ref_counted_handle
    && *(_UNKNOWN **)(default_input_handler + 40) == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v10 = *(void *)(default_input_handler + 88);
    if (v10)
    {
      BOOL v11 = v10 - 1;
      *(void *)(default_input_handler + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v11;
      if (!v11)
      {
        char v12 = *(void (***)(void))(default_input_handler + 64);
        if (v12)
        {
          *(void *)(default_input_handler + 64) = 0LL;
          v12[2](v12);
          _Block_release(v12);
        }

        if ((*(_BYTE *)(default_input_handler + 72) & 1) != 0)
        {
          char v13 = *(const void **)(default_input_handler + 64);
          if (v13) {
            _Block_release(v13);
          }
        }

  if (v25) {
    free(v25);
  }
LABEL_14:
  if (handle == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v20 = a2[1].callbacks;
    if (v20)
    {
      __int16 v21 = (nw_protocol_callbacks *)((char *)v20 - 1);
      a2[1].callbacks = v21;
      if (!v21)
      {
        uint64_t v22 = *(void (***)(void))a2[1].flow_id;
        if (v22)
        {
          *(void *)a2[1].flow_id = 0LL;
          v22[2](v22);
          _Block_release(v22);
        }

        if ((a2[1].flow_id[8] & 1) != 0)
        {
          uint64_t v23 = *(const void **)a2[1].flow_id;
          if (v23) {
            _Block_release(v23);
          }
        }

        free(a2);
      }
    }
  }

  if (v4 == &nw_protocol_ref_counted_handle
    && *(_UNKNOWN **)(default_input_handler + 40) == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v10 = *(void *)(default_input_handler + 88);
    if (v10)
    {
      BOOL v11 = v10 - 1;
      *(void *)(default_input_handler + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v11;
      if (!v11)
      {
        char v12 = *(void (***)(void))(default_input_handler + 64);
        if (v12)
        {
          *(void *)(default_input_handler + 64) = 0LL;
          v12[2](v12);
          _Block_release(v12);
        }

        if ((*(_BYTE *)(default_input_handler + 72) & 1) != 0)
        {
          char v13 = *(const void **)(default_input_handler + 64);
          if (v13) {
            _Block_release(v13);
          }
        }

void sub_181AF4A9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, void *a25, void *a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, void *a40, void *a41, void *a42, void *a43)
{
  _Block_object_dispose(&STACK[0x210], 8);
  _Block_object_dispose(&STACK[0x298], 8);

  _Block_object_dispose(&STACK[0x3B0], 8);
  _Block_object_dispose(&STACK[0x3D0], 8);
  _Block_object_dispose((const void *)(v45 - 160), 8);
  _Block_object_dispose(&STACK[0x3F0], 8);

  _Block_object_dispose(&STACK[0x410], 8);
  _Block_object_dispose(&STACK[0x430], 8);

  _Unwind_Resume(a1);
}

id nw_parameters_get_upper_transport_protocol_options(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_endpoint_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_endpoint_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_31;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        nw_endpoint_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181AF5200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_path(void *a1)
{
  id v1 = a1;
  nw_path_t v2 = nw_endpoint_handler_copy_flow(v1);
  uint64_t v3 = v2;
  id v5 = (id *)((char *)v2 + 16);
  id v4 = (void *)*((void *)v2 + 2);
  if (!v4)
  {
    BOOL v7 = (void *)*((void *)v2 + 104);
    if (v7)
    {
      id v8 = (id)nw_path_flow_registration_copy_path(v7);
      if (v8)
      {
LABEL_5:
        os_unfair_lock_lock((os_unfair_lock_t)v3 + 220);
        objc_storeStrong(v5, v8);
        os_unfair_lock_unlock((os_unfair_lock_t)v3 + 220);
        id v6 = *((id *)v3 + 2);
LABEL_8:

        goto LABEL_9;
      }
    }

    else
    {
      id v8 = nw_endpoint_handler_copy_current_path(v1);
      if (v8) {
        goto LABEL_5;
      }
    }

    id v6 = 0LL;
    goto LABEL_8;
  }

  id v6 = v4;
LABEL_9:

  return v6;
}

void sub_181AF52DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_flow_should_add_filter(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v4) {
    goto LABEL_9;
  }
  int v6 = v4[68];
  if (!v3)
  {
    if (v6 < 1) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  BOOL v7 = v3;
  __int16 v8 = *(_WORD *)(v7[13] + 100LL);

  BOOL v9 = 0LL;
  if ((v8 & 0x10) == 0 && v6 && (v6 & 0x80000000) == 0)
  {
LABEL_8:
    if ((nw_path_uses_interface_subtype(v5, 4001) & 1) == 0)
    {
      BOOL v9 = nw_path_get_nexus_protocol_level(v5) == 2
        || nw_path_get_nexus_protocol_level(v5) == 0;
      goto LABEL_10;
    }

void sub_181AF53B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_parameters_has_proxy_protocol_in_stack_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  nw_protocol_definition_t v3 = nw_protocol_options_copy_definition(options);
  if (nw_protocol_definition_is_proxy(v3)) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
}

BOOL nw_protocol_definition_is_proxy(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    BOOL v3 = v1[184] < 0;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_definition_is_proxy";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_definition_is_proxy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_definition_is_proxy";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_definition_is_proxy";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_definition_is_proxy";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_parameters_internal_iterate_protocol_stack_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_protocol_definition_t v5 = nw_protocol_options_copy_definition(v4);
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();

  return v6;
}

void sub_181AF5714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_connect(void *a1)
{
  uint64_t v82 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = nw_endpoint_handler_copy_flow(v1);
  if (!v2)
  {
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v69 = "nw_endpoint_flow_connect";
    int v39 = (char *)_os_log_send_and_compose_impl();

    v66[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v64) = 0;
    if (__nwlog_fault(v39, v66, &v64))
    {
      if (v66[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v41 = v66[0];
        if (os_log_type_enabled(v40, v66[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v69 = "nw_endpoint_flow_connect";
          _os_log_impl(&dword_181A5C000, v40, v41, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if ((_BYTE)v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = v66[0];
        BOOL v48 = os_log_type_enabled(v40, v66[0]);
        if (backtrace_string)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v69 = "nw_endpoint_flow_connect";
            __int16 v70 = 2082;
            int v71 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v40,  v47,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_98;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v69 = "nw_endpoint_flow_connect";
          _os_log_impl(&dword_181A5C000, v40, v47, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v58 = v66[0];
        if (os_log_type_enabled(v40, v66[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v69 = "nw_endpoint_flow_connect";
          _os_log_impl( &dword_181A5C000,  v40,  v58,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_92:
  nw::release_if_needed<nw_protocol *>(&v64);
  if (v4 == &nw_protocol_ref_counted_handle) {
LABEL_93:
  }
    nw::release_if_needed<nw_protocol *>((uint64_t *)v66);
LABEL_94:

  return v26;
}

  os_unfair_lock_lock((os_unfair_lock_t)v25 + 220);
  int v94 = v60;
  BOOL v95 = (dispatch_data_s *)v94[7];
  BOOL v96 = v94[9];
  if (v95)
  {
    if (!v96)
    {
      nw_endpoint_t v97 = dispatch_data_get_size(v95);
LABEL_97:
      os_log_type_t v98 = v94[14];
      if (v97 <= v98) {
        LODWORD(v9_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
      }
      os_log_type_t v99 = v97 - v98;
      goto LABEL_100;
    }

      free(backtrace_string);
      goto LABEL_130;
    }

    os_log_type_t v33 = (os_log_s *)__nwlog_obj();
    os_log_type_t v34 = type;
    if (!os_log_type_enabled(v33, type)) {
      goto LABEL_130;
    }
    *(_DWORD *)buf = 136446210;
    char v65 = "nw_protocol_udp_remove_input_handler";
    uint64_t v35 = "%{public}s called with null protocol";
LABEL_129:
    _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0xCu);
LABEL_130:
    if (v32) {
      free(v32);
    }
    return 0LL;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v65 = "nw_protocol_udp_remove_input_handler";
    id v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_udp_remove_input_handler";
      uint64_t v35 = "%{public}s called with null udp";
      goto LABEL_129;
    }

    if (!v62)
    {
      os_log_type_t v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "nw_protocol_udp_remove_input_handler";
      uint64_t v35 = "%{public}s called with null udp, backtrace limit exceeded";
      goto LABEL_129;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v33 = (os_log_s *)__nwlog_obj();
    os_log_type_t v34 = type;
    uint64_t v49 = os_log_type_enabled(v33, type);
    if (backtrace_string)
    {
      if (v49)
      {
        *(_DWORD *)buf = 136446466;
        char v65 = "nw_protocol_udp_remove_input_handler";
        char v66 = 2082;
        char v67 = backtrace_string;
        BOOL v48 = "%{public}s called with null udp, dumping backtrace:%{public}s";
        goto LABEL_91;
      }

      goto LABEL_92;
    }

    if (!v49) {
      goto LABEL_130;
    }
    *(_DWORD *)buf = 136446210;
    char v65 = "nw_protocol_udp_remove_input_handler";
    uint64_t v35 = "%{public}s called with null udp, no backtrace";
    goto LABEL_129;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v65 = "__nw_protocol_get_output_handler";
    os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type)) {
        goto LABEL_135;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "__nw_protocol_get_output_handler";
      int v39 = "%{public}s called with null protocol";
    }

    else if (v62)
    {
      os_log_type_t v50 = (char *)__nw_create_backtrace_string();
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      v38 = type;
      nw_endpoint_t v51 = os_log_type_enabled(v37, type);
      if (v50)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          char v65 = "__nw_protocol_get_output_handler";
          char v66 = 2082;
          char v67 = v50;
          _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v50);
LABEL_135:
        if (v36) {
          free(v36);
        }
        if (a1->default_input_handler) {
          return 0LL;
        }
        goto LABEL_18;
      }

      if (!v51) {
        goto LABEL_135;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "__nw_protocol_get_output_handler";
      int v39 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type)) {
        goto LABEL_135;
      }
      *(_DWORD *)buf = 136446210;
      char v65 = "__nw_protocol_get_output_handler";
      int v39 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v37, v38, v39, buf, 0xCu);
    goto LABEL_135;
  }

  if (a2->output_handler == a1)
  {
    callbacks = a1[1].callbacks;
    if (callbacks)
    {
      char v7 = (nw_protocol_callbacks *)((char *)callbacks - 1);
      a1[1].callbacks = v7;
      if (!v7)
      {
        os_log_type_t v8 = *(void (***)(void))a1[1].flow_id;
        if (v8)
        {
          *(void *)a1[1].flow_id = 0LL;
          v8[2](v8);
          _Block_release(v8);
        }

        if ((a1[1].flow_id[8] & 1) != 0)
        {
          BOOL v9 = *(const void **)a1[1].flow_id;
          if (v9) {
            _Block_release(v9);
          }
        }

        free(a1);
      }
    }

    a2->output_handler = 0LL;
  }

  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  if (a2->handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v20 = a2[1].callbacks;
    if (v20)
    {
      __int16 v21 = (nw_protocol_callbacks *)((char *)v20 - 1);
      a2[1].callbacks = v21;
      if (!v21)
      {
        char v22 = *(void (***)(void))a2[1].flow_id;
        if (v22)
        {
          *(void *)a2[1].flow_id = 0LL;
          v22[2](v22);
          _Block_release(v22);
        }

        if ((a2[1].flow_id[8] & 1) != 0)
        {
          uint64_t v23 = *(const void **)a2[1].flow_id;
          if (v23) {
            _Block_release(v23);
          }
        }

        free(a2);
      }
    }
  }

  a1->default_input_handler = 0LL;
LABEL_18:
  output_handler = (uint64_t)a1->output_handler;
  if (output_handler)
  {
    os_log_type_t v12 = *(void **)(output_handler + 40);
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      nw_endpoint_t v13 = *(void *)(output_handler + 88);
      if (v13) {
        *(void *)(output_handler + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v13 + 1;
      }
    }

    handle = a1->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v15 = a1[1].callbacks;
      if (v15) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v15->add_input_handler + 1);
      }
    }

    os_log_type_t v16 = *(void *)(output_handler + 24);
    if (v16)
    {
      __int16 v17 = *(void (**)(uint64_t, nw_protocol *, uint64_t))(v16 + 8);
      if (v17)
      {
        v17(output_handler, a1, a3);
LABEL_28:
        if (handle == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
        {
          uint64_t v24 = a1[1].callbacks;
          if (v24)
          {
            id v25 = (nw_protocol_callbacks *)((char *)v24 - 1);
            a1[1].callbacks = v25;
            if (!v25)
            {
              uint64_t v26 = *(void (***)(void))a1[1].flow_id;
              if (v26)
              {
                *(void *)a1[1].flow_id = 0LL;
                v26[2](v26);
                _Block_release(v26);
              }

              if ((a1[1].flow_id[8] & 1) != 0)
              {
                id v27 = *(const void **)a1[1].flow_id;
                if (v27) {
                  _Block_release(v27);
                }
              }

              free(a1);
            }
          }
        }

        if (v12 != &nw_protocol_ref_counted_handle) {
          goto LABEL_32;
        }
        if (*(_UNKNOWN **)(output_handler + 40) != &nw_protocol_ref_counted_handle) {
          goto LABEL_32;
        }
        uint64_t v28 = *(void *)(output_handler + 88);
        if (!v28) {
          goto LABEL_32;
        }
        BOOL v29 = v28 - 1;
        *(void *)(output_handler + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v29;
        if (v29) {
          goto LABEL_32;
        }
        uint64_t v30 = *(void (***)(void))(output_handler + 64);
        if (v30)
        {
          *(void *)(output_handler + 64) = 0LL;
          v30[2](v30);
          _Block_release(v30);
        }

        if ((*(_BYTE *)(output_handler + 72) & 1) != 0)
        {
          id v31 = *(const void **)(output_handler + 64);
          if (v31) {
            _Block_release(v31);
          }
        }

        goto LABEL_62;
      }
    }

    __nwlog_obj();
    BOOL v40 = *(const char **)(output_handler + 16);
    *(_DWORD *)buf = 136446722;
    char v65 = "__nw_protocol_remove_input_handler";
    if (!v40) {
      BOOL v40 = "invalid";
    }
    char v66 = 2082;
    char v67 = (void *)v40;
    os_log_type_t v68 = 2048;
    uint64_t v69 = output_handler;
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v62 = 0;
    if (__nwlog_fault(v41, &type, &v62))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v42 = (os_log_s *)__nwlog_obj();
        os_log_type_t v43 = type;
        if (!os_log_type_enabled(v42, type)) {
          goto LABEL_144;
        }
        BOOL v44 = *(const char **)(output_handler + 16);
        if (!v44) {
          BOOL v44 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        char v65 = "__nw_protocol_remove_input_handler";
        char v66 = 2082;
        char v67 = (void *)v44;
        os_log_type_t v68 = 2048;
        uint64_t v69 = output_handler;
        uint64_t v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback";
        goto LABEL_143;
      }

      if (!v62)
      {
        BOOL v42 = (os_log_s *)__nwlog_obj();
        os_log_type_t v43 = type;
        if (!os_log_type_enabled(v42, type)) {
          goto LABEL_144;
        }
        __int16 v60 = *(const char **)(output_handler + 16);
        if (!v60) {
          __int16 v60 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        char v65 = "__nw_protocol_remove_input_handler";
        char v66 = 2082;
        char v67 = (void *)v60;
        os_log_type_t v68 = 2048;
        uint64_t v69 = output_handler;
        uint64_t v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_143;
      }

      id v55 = (char *)__nw_create_backtrace_string();
      BOOL v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = type;
      os_log_type_t v56 = os_log_type_enabled(v42, type);
      if (v55)
      {
        if (v56)
        {
          BOOL v57 = *(const char **)(output_handler + 16);
          if (!v57) {
            BOOL v57 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          char v65 = "__nw_protocol_remove_input_handler";
          char v66 = 2082;
          char v67 = (void *)v57;
          os_log_type_t v68 = 2048;
          uint64_t v69 = output_handler;
          __int16 v70 = 2082;
          int v71 = v55;
          _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v55);
        goto LABEL_144;
      }

      if (v56)
      {
        id v61 = *(const char **)(output_handler + 16);
        if (!v61) {
          id v61 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        char v65 = "__nw_protocol_remove_input_handler";
        char v66 = 2082;
        char v67 = (void *)v61;
        os_log_type_t v68 = 2048;
        uint64_t v69 = output_handler;
        uint64_t v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace";
LABEL_143:
        _os_log_impl(&dword_181A5C000, v42, v43, v45, buf, 0x20u);
      }
    }

    if (!v30) {
      goto LABEL_94;
    }
    goto LABEL_93;
  }

  os_log_type_t v8 = v5[10];
  if (v8 == a2 && *((char **)v5 + 6) == v6)
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v5 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      BOOL v9 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        id v25 = v5[42];
        uint64_t v26 = v5[10];
        else {
          id v27 = off_189BB8B98[v26];
        }
        nw_endpoint_t v53 = (char *)*((void *)v5 + 6);
        id v54 = off_189BB8B98[a2];
        *(_DWORD *)buf = 136447490;
        BOOL v77 = "nw_connection_group_set_state_locked";
        __int16 v78 = 1024;
        *(_DWORD *)nw_endpoint_t v79 = v25;
        *(_WORD *)&v79[4] = 2082;
        *(void *)&v79[6] = v27;
        __int16 v80 = 2114;
        id v81 = v53;
        uint64_t v82 = 2082;
        id v83 = v54;
        uint64_t v84 = 2114;
        BOOL v85 = v7;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Ignoring state transition from (%{public}s, error: %{public}@) -> (%{public}s, error: %{public}@)",  buf,  0x3Au);
      }

      goto LABEL_68;
    }

    goto LABEL_94;
  }

  if (v8 == 4)
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v5 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      BOOL v9 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v10 = v5[42];
        char v11 = v5[10];
        else {
          os_log_type_t v12 = off_189BB8B98[v11];
        }
        uint64_t v28 = off_189BB8B98[a2];
        *(_DWORD *)buf = 136447234;
        BOOL v77 = "nw_connection_group_set_state_locked";
        __int16 v78 = 1024;
        *(_DWORD *)nw_endpoint_t v79 = v10;
        *(_WORD *)&v79[4] = 2082;
        *(void *)&v79[6] = v12;
        __int16 v80 = 2082;
        id v81 = v28;
        uint64_t v82 = 2114;
        id v83 = v7;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Ignoring state transition from %{public}s -> %{public}s (error %{public}@) while cancelled",  buf,  0x30u);
      }

    nw::release_if_needed<nw_protocol *>((uint64_t *)&v61);
    if (v8 != &nw_protocol_ref_counted_handle)
    {
LABEL_23:
      if ((v16 & 1) != 0) {
        goto LABEL_114;
      }
LABEL_94:
      if ((v3[405] & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v44 = (id)gLogObj;
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v3 + 407;
        *(_WORD *)&buf[22] = 2080;
        char v66 = " ";
        uint64_t v45 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v61) = 0;
        if (__nwlog_fault(v45, type, &v61))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v46 = (os_log_s *)(id)gLogObj;
            os_log_type_t v47 = type[0];
            if (os_log_type_enabled(v46, type[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v3 + 407;
              *(_WORD *)&buf[22] = 2080;
              char v66 = " ";
              _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s %{public}s%sUnable to remove output handler",  buf,  0x20u);
            }
          }

          else if ((_BYTE)v61)
          {
            BOOL v48 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v46 = (os_log_s *)(id)gLogObj;
            uint64_t v49 = type[0];
            os_log_type_t v50 = os_log_type_enabled(v46, type[0]);
            if (v48)
            {
              if (v50)
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v3 + 407;
                *(_WORD *)&buf[22] = 2080;
                char v66 = " ";
                *(_WORD *)char v67 = 2082;
                *(void *)&v67[2] = v48;
                _os_log_impl( &dword_181A5C000,  v46,  v49,  "%{public}s %{public}s%sUnable to remove output handler, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(v48);
              if (!v45) {
                goto LABEL_114;
              }
              goto LABEL_113;
            }

            if (v50)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v3 + 407;
              *(_WORD *)&buf[22] = 2080;
              char v66 = " ";
              _os_log_impl( &dword_181A5C000,  v46,  v49,  "%{public}s %{public}s%sUnable to remove output handler, no backtrace",  buf,  0x20u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v46 = (os_log_s *)(id)gLogObj;
            nw_endpoint_t v51 = type[0];
            if (os_log_type_enabled(v46, type[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v3 + 407;
              *(_WORD *)&buf[22] = 2080;
              char v66 = " ";
              _os_log_impl( &dword_181A5C000,  v46,  v51,  "%{public}s %{public}s%sUnable to remove output handler, backtrace limit exceeded",  buf,  0x20u);
            }
          }
        }

        if (v45) {
LABEL_113:
        }
          free(v45);
      }

    if (v22) {
      free(v22);
    }
    goto LABEL_7;
  }

  nw_association_set_cached_content_for_protocol(v9, v6[1], a2, a3);
LABEL_7:

LABEL_8:
}

          goto LABEL_93;
        }

        if (!v42)
        {
          __nwlog_obj();
          char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v41 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl( &dword_181A5C000,  v22,  v41,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_92;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        uint64_t v37 = os_log_type_enabled(v22, type);
        if (!backtrace_string)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl( &dword_181A5C000,  v22,  v36,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_92;
        }

        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
          os_log_type_t v46 = 2082;
          os_log_type_t v47 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v36,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
        __int16 v21 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        BOOL v42 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v25 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_92;
        }

        if (!v42)
        {
          __nwlog_obj();
          char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v40 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl( &dword_181A5C000,  v22,  v40,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_92;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        uint64_t v35 = os_log_type_enabled(v22, type);
        if (!backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
            _os_log_impl( &dword_181A5C000,  v22,  v34,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_92;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
          os_log_type_t v46 = 2082;
          os_log_type_t v47 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v34,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
      __int16 v21 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v42 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_92;
      }

      if (!v42)
      {
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v39 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
          _os_log_impl( &dword_181A5C000,  v22,  v39,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_92;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v32 = type;
      os_log_type_t v33 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
          _os_log_impl(&dword_181A5C000, v22, v32, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_92;
      }

      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
        os_log_type_t v46 = 2082;
        os_log_type_t v47 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_93;
  }

  __nwlog_obj();
  os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
  __int16 v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v42 = 0;
  if (__nwlog_fault(v17, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v42)
    {
      uint64_t v28 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v29 = type;
      uint64_t v30 = os_log_type_enabled(v18, type);
      if (v28)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
          os_log_type_t v46 = 2082;
          os_log_type_t v47 = v28;
          _os_log_impl( &dword_181A5C000,  v18,  v29,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v28);
        goto LABEL_81;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
        _os_log_impl(&dword_181A5C000, v18, v29, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_protocol_implementation_add_listen_handler";
        _os_log_impl( &dword_181A5C000,  v18,  v38,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      goto LABEL_93;
    }

    if (!LOBYTE(v95.receiver))
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v50 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v107 = "nw_endpoint_create_bonjour_service";
        nw_endpoint_t v108 = 2082;
        os_log_type_t v109 = "domain";
        _os_log_impl( &dword_181A5C000,  v10,  v50,  "%{public}s invalid empty string %{public}s, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_92;
    }

    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v42 = typea[0];
    os_log_type_t v43 = os_log_type_enabled(v10, typea[0]);
    if (!v41)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v107 = "nw_endpoint_create_bonjour_service";
        nw_endpoint_t v108 = 2082;
        os_log_type_t v109 = "domain";
        _os_log_impl(&dword_181A5C000, v10, v42, "%{public}s invalid empty string %{public}s, no backtrace", buf, 0x16u);
      }

      goto LABEL_92;
    }

    if (v43)
    {
      *(_DWORD *)buf = 136446722;
      unint64_t v107 = "nw_endpoint_create_bonjour_service";
      nw_endpoint_t v108 = 2082;
      os_log_type_t v109 = "domain";
      os_log_type_t v110 = 2082;
      BOOL v111 = v41;
      _os_log_impl( &dword_181A5C000,  v10,  v42,  "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v41);
LABEL_93:
    if (!v9) {
      return 0LL;
    }
LABEL_94:
    free(v9);
    return 0LL;
  }

  if (v18 >= 0x400)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      unint64_t v107 = "nw_endpoint_create_bonjour_service";
      nw_endpoint_t v108 = 2082;
      os_log_type_t v109 = "domain";
      os_log_type_t v110 = 1024;
      LODWORD(v111) = 1024;
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", buf, 0x1Cu);
    }

    goto LABEL_33;
  }

  uint64_t v24 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_bonjour_service_endpoint);
  if (!v24)
  {
LABEL_106:
    __nwlog_obj();
    nw_endpoint_t v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v107 = "nw_endpoint_create_bonjour_service";
    id v54 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (__nwlog_fault(v54, typea, &v95))
    {
      if (typea[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v56 = typea[0];
        if (os_log_type_enabled(v55, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v107 = "nw_endpoint_create_bonjour_service";
          _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s NWOSBonjourEndpoint alloc/init failed", buf, 0xCu);
        }
      }

      else if (LOBYTE(v95.receiver))
      {
        BOOL v57 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v58 = typea[0];
        os_log_type_t v59 = os_log_type_enabled(v55, typea[0]);
        if (v57)
        {
          if (v59)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v107 = "nw_endpoint_create_bonjour_service";
            nw_endpoint_t v108 = 2082;
            os_log_type_t v109 = v57;
            _os_log_impl( &dword_181A5C000,  v55,  v58,  "%{public}s NWOSBonjourEndpoint alloc/init failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v57);
          goto LABEL_122;
        }

        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v107 = "nw_endpoint_create_bonjour_service";
          _os_log_impl( &dword_181A5C000,  v55,  v58,  "%{public}s NWOSBonjourEndpoint alloc/init failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v60 = typea[0];
        if (os_log_type_enabled(v55, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v107 = "nw_endpoint_create_bonjour_service";
          _os_log_impl( &dword_181A5C000,  v55,  v60,  "%{public}s NWOSBonjourEndpoint alloc/init failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

          BOOL v104 = v6;
          id v105 = (*((_BYTE *)v104 + 268) & 0x20) == 0;

          if (v105)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v106 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
            {
              unint64_t v107 = v104;

              nw_endpoint_t v108 = v107;
              os_log_type_t v109 = (*((_BYTE *)v104 + 268) & 1) == 0;

              if (v109) {
                os_log_type_t v110 = "";
              }
              else {
                os_log_type_t v110 = "dry-run ";
              }
              BOOL v111 = nw_endpoint_handler_copy_endpoint(v108);
              os_log_type_t v112 = nw_endpoint_get_logging_description(v111);
              id v113 = v108;
              id v114 = v113;
              os_log_type_t v115 = v113[30];
              else {
                int v116 = off_189BBBBF0[v115];
              }
              v225 = v116;

              BOOL v117 = v114;
              id v118 = "path";
              switch(v6->mode)
              {
                case 0:
                  break;
                case 1:
                  id v118 = "resolver";
                  break;
                case 2:
                  id v118 = nw_endpoint_flow_mode_string(v117[31]);
                  break;
                case 3:
                  id v118 = "proxy";
                  break;
                case 4:
                  id v118 = "fallback";
                  break;
                case 5:
                  id v118 = "transform";
                  break;
                default:
                  id v118 = "unknown-mode";
                  break;
              }

              BOOL v220 = v118;

              os_log_type_t v119 = v106;
              BOOL v120 = v112;
              os_log_type_t v121 = v117;
              os_unfair_lock_lock((os_unfair_lock_t)v121 + 28);
              os_log_type_t v122 = v121[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v121 + 28);

              BOOL v123 = v120;
              os_log_type_t v106 = v119;
              os_log_type_t v124 = (char *)*((void *)v237 + 2);
              id v125 = *(void *)(log + 16);
              *(_DWORD *)buf = 136448258;
              os_log_type_t v245 = "nw_flow_listener_new_flow";
              int v246 = 2082;
              id v247 = (uint64_t)v107->id_str;
              nw_endpoint_t v248 = 2082;
              id v249 = (uint64_t)v110;
              id v250 = 2082;
              v251 = v123;
              v252 = 2082;
              id v253 = v225;
              v254 = 2082;
              v255 = v220;
              v256 = 2114;
              id v257 = v122;
              os_log_type_t v258 = 2082;
              v259 = v124;
              uint64_t v260 = 2082;
              int v261 = v125;
              _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound p rotocol %{public}s to %{public}s",  buf,  0x5Cu);
            }
          }

          nw_endpoint_flow_cleanup_protocol(v104, (uint64_t)v237, 1);
          uint64_t v126 = (void *)*((void *)v237 + 23);
          *((void *)v237 + 23) = 0LL;

          goto LABEL_112;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v52 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
        int v246 = 2048;
        id v247 = (uint64_t)v9;
        nw_endpoint_t v53 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        id v242 = OS_LOG_TYPE_DEFAULT;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v54 = (os_log_s *)(id)gLogObj;
          id v55 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
            int v246 = 2048;
            id v247 = (uint64_t)v237;
            _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
          }
        }

        else if (v242)
        {
          BOOL v57 = __nw_create_backtrace_string();
          if (v57)
          {
            os_log_type_t v58 = (char *)v57;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v59 = (os_log_s *)(id)gLogObj;
            __int16 v60 = type;
            if (os_log_type_enabled(v59, type))
            {
              *(_DWORD *)buf = 136446722;
              os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
              int v246 = 2048;
              id v247 = (uint64_t)v237;
              nw_endpoint_t v248 = 2082;
              id v249 = (uint64_t)v58;
              _os_log_impl( &dword_181A5C000,  v59,  v60,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v58);
            if (!v53) {
              goto LABEL_92;
            }
            goto LABEL_91;
          }

          __nwlog_obj();
          id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v103 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
            int v246 = 2048;
            id v247 = (uint64_t)v237;
            _os_log_impl( &dword_181A5C000,  v54,  v103,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v54 = (os_log_s *)(id)gLogObj;
          id v83 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
            int v246 = 2048;
            id v247 = (uint64_t)v237;
            _os_log_impl( &dword_181A5C000,  v54,  v83,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
          }
        }

        goto LABEL_89;
      }

      __nwlog_obj();
      char v199 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
      nw_endpoint_t v53 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      id v242 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v53, &type, &v242))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v200 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_181A5C000, v54, v200, "%{public}s called with null input_protocol", buf, 0xCu);
          }
        }

        else if (v242)
        {
          id v205 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v206 = type;
          id v207 = os_log_type_enabled(v54, type);
          if (v205)
          {
            if (v207)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
              int v246 = 2082;
              id v247 = (uint64_t)v205;
              _os_log_impl( &dword_181A5C000,  v54,  v206,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v205);
            if (!v53) {
              goto LABEL_92;
            }
            goto LABEL_91;
          }

          if (v207)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl( &dword_181A5C000,  v54,  v206,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          nw_endpoint_t v209 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl( &dword_181A5C000,  v54,  v209,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_89;
      }

    goto LABEL_93;
  }

  if (([v4 isEqualToDictionary:v5] & 1) == 0) {
    goto LABEL_7;
  }
LABEL_22:
  objc_msgSend(NSString, "stringWithUTF8String:", nw_file_path_settings, v84, v85);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  fixFilePermissions(v24);

  id v25 = (void *)[v4 mutableCopy];
  [NSString stringWithUTF8String:nw_settings_managed_settings];
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
  [v25 objectForKeyedSubscript:v26];
  id v27 = (void *)objc_claimAutoreleasedReturnValue();
  [v25 removeObjectForKey:v26];
  BOOL v96 = 0u;
  nw_endpoint_t v97 = 0u;
  *(_OWORD *)os_log_type_t type = 0u;
  BOOL v95 = 0u;
  uint64_t v28 = v27;
  BOOL v29 = [v28 countByEnumeratingWithState:type objects:buf count:16];
  if (v29)
  {
    uint64_t v30 = v29;
    id v31 = *(void *)v95;
    do
    {
      for (i = 0LL; i != v30; ++i)
      {
        if (*(void *)v95 != v31) {
          objc_enumerationMutation(v28);
        }
        os_log_type_t v33 = *(void **)(*(void *)&type[8] + 8 * i);
        if (([v33 isEqualToString:v26] & 1) == 0)
        {
          [v28 objectForKeyedSubscript:v33];
          os_log_type_t v34 = (void *)objc_claimAutoreleasedReturnValue();
          [v25 setObject:v34 forKeyedSubscript:v33];
        }
      }

      uint64_t v30 = [v28 countByEnumeratingWithState:type objects:buf count:16];
    }

    while (v30);
  }

  [v25 description];
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v36 = [v35 stringByReplacingOccurrencesOfString:@"\n" withString:&stru_189BCAF98];

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v37 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "saveAndPostNetworkdSettings";
    *(_WORD *)&buf[12] = 2112;
    *(void *)&void buf[14] = v36;
    _os_log_impl(&dword_181A5C000, v37, OS_LOG_TYPE_DEBUG, "%{public}s Created compoundSettings: %@", buf, 0x16u);
  }

  uint64_t v86 = (void *)v36;

  [NSString stringWithUTF8String:nw_setting_libnetcore_debug];
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  [v25 objectForKeyedSubscript:v38];
  int v39 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v40 = [v39 longLongValue];

  if (v40 == a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v42 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "saveAndPostNetworkdSettings";
      _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEFAULT,  "%{public}s skipping OSLog settings update due to no logging changes",  buf,  0xCu);
    }
  }

  else
  {
    updateOSLogPlistFromLevel(v40, 0, v41);
  }

  os_log_type_t v43 = v4;
  BOOL v44 = v25;
  *(void *)buf = 8LL;
  *(void *)&buf[8] = nw_setting_libnetcore_datapath_debug;
  *(void *)&buf[16] = 16LL;
  *(void *)&os_log_type_t v100 = nw_setting_tcpconn_disable_simulate_crash;
  *((void *)&v100 + 1) = 32LL;
  os_log_type_t v101 = nw_setting_boringssl_log_debug;
  BOOL v102 = 64LL;
  os_log_type_t v103 = nw_setting_tcp_enable_auto_tfo;
  BOOL v104 = 128LL;
  id v105 = nw_setting_disable_dns_xpc;
  os_log_type_t v106 = 256LL;
  unint64_t v107 = nw_setting_tcpconn_enable_tls_tickets;
  nw_endpoint_t v108 = 512LL;
  os_log_type_t v109 = nw_setting_channel_enable_qos_override;
  os_log_type_t v110 = 1024LL;
  BOOL v111 = nw_setting_disable_ddr;
  os_log_type_t v112 = 2048LL;
  id v113 = nw_setting_tcpconn_enable_tls_esni;
  id v114 = 4096LL;
  os_log_type_t v115 = nw_setting_context_timer_disable_qos_override;
  int v116 = 0x2000LL;
  BOOL v117 = nw_setting_tcpconn_enable_tls_experiments;
  id v118 = 0x4000LL;
  os_log_type_t v119 = nw_setting_tcpconn_enable_tls_keylog;
  BOOL v120 = 0x8000LL;
  os_log_type_t v121 = nw_setting_disable_swift_tls_privacy_proxy;
  os_log_type_t v122 = 0x10000LL;
  BOOL v123 = nw_setting_disable_l4s_aqm;
  id v125 = 0LL;
  os_log_type_t v124 = 0LL;
  uint64_t v45 = 0LL;
  if (nw_setting_libnetcore_datapath_debug)
  {
    os_log_type_t v46 = 1;
    os_log_type_t v47 = buf;
    do
    {
      BOOL v48 = *(void *)v47;
      objc_msgSend(NSString, "stringWithUTF8String:");
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue();
      [v44 objectForKeyedSubscript:v49];
      os_log_type_t v50 = (void *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v51 = [v50 BOOLValue];

      if (v51) {
        uint64_t v52 = v48;
      }
      else {
        uint64_t v52 = 0LL;
      }
      v45 |= v52;
      [v44 removeObjectForKey:v49];

      os_log_type_t v47 = &buf[16 * v46++];
    }

    while (*((void *)v47 + 1));
  }

  [NSString stringWithUTF8String:nw_setting_libnetcore_debug];
  nw_endpoint_t v53 = (void *)objc_claimAutoreleasedReturnValue();
  [v44 objectForKeyedSubscript:v53];
  id v54 = (void *)objc_claimAutoreleasedReturnValue();
  id v55 = [v54 longLongValue];

  os_log_type_t v56 = 7LL;
  if (v55 < 7) {
    os_log_type_t v56 = v55;
  }
  BOOL v57 = v56 & ~(v56 >> 63) | v45;
  [v44 removeObjectForKey:v53];
  [v44 removeObjectForKey:@"networkd_log_level"];

  if ([v44 count])
  {
    id v91 = 0u;
    BOOL v92 = 0u;
    id v89 = 0u;
    os_log_type_t v90 = 0u;
    [v44 allKeys];
    os_log_type_t v58 = (void *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v59 = [v58 countByEnumeratingWithState:&v89 objects:v98 count:16];
    __int16 v60 = v43;
    if (v59)
    {
      id v61 = v59;
      char v62 = 0LL;
      id v63 = *(void *)v90;
      do
      {
        for (j = 0LL; j != v61; ++j)
        {
          if (*(void *)v90 != v63) {
            objc_enumerationMutation(v58);
          }
          char v65 = *(void **)(*((void *)&v89 + 1) + 8 * j);
          [v44 objectForKeyedSubscript:v65];
          char v66 = (void *)objc_claimAutoreleasedReturnValue();
          char v67 = [v65 hash];
          v62 ^= v67 ^ [v66 hash];
        }

        id v61 = [v58 countByEnumeratingWithState:&v89 objects:v98 count:16];
      }

      while (v61);
      os_log_type_t v68 = v62 << 16;
    }

    else
    {
      os_log_type_t v68 = 0LL;
    }

    v57 |= v68;
  }

  else
  {
    __int16 v60 = v43;
  }

  if (postSettingsBitmask_sPostedSettingsBitmask != v57)
  {
    uint64_t v69 = postSettingsBitmask_token;
    if (postSettingsBitmask_token == -1)
    {
      BOOL v73 = notify_register_check((const char *)nw_notification_name_settings, &postSettingsBitmask_token);
      if (v73)
      {
        __int16 v74 = v73;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v75 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "postSettingsBitmask";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = nw_notification_name_settings;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v100) = v74;
          _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_ERROR,  "%{public}s notify_register_check(%{public}s) failed: %d",  buf,  0x1Cu);
        }

LABEL_73:
        BOOL v57 = 0LL;
        postSettingsBitmask_token = -1;
LABEL_74:
        postSettingsBitmask_sPostedSettingsBitmask = v57;
        goto LABEL_75;
      }

      uint64_t v69 = postSettingsBitmask_token;
      if (postSettingsBitmask_token == -1)
      {
        BOOL v57 = 0LL;
        goto LABEL_74;
      }
    }

    __int16 v70 = notify_set_state(v69, v57);
    if (v70)
    {
      int v71 = v70;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v72 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "postSettingsBitmask";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = nw_notification_name_settings;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&os_log_type_t v100 = v57;
        WORD4(v100) = 1024;
        *(_DWORD *)((char *)&v100 + 10) = v71;
        _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_ERROR,  "%{public}s notify_set_state for %{public}s %#llx failed: %d",  buf,  0x26u);
      }
    }

    else
    {
      __int16 v76 = notify_post((const char *)nw_notification_name_settings);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v77 = (os_log_s *)(id)gLogObj;
      __int16 v78 = v77;
      if (!v76)
      {
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "postSettingsBitmask";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&void buf[14] = postSettingsBitmask_sPostedSettingsBitmask;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&os_log_type_t v100 = v57;
          _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_DEFAULT,  "%{public}s successfully changed networkd settings state from %#llx to %#llx",  buf,  0x20u);
        }

        goto LABEL_74;
      }

      if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "postSettingsBitmask";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = nw_notification_name_settings;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v100) = v76;
        _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_ERROR,  "%{public}s notify_post for %{public}s failed: %d",  buf,  0x1Cu);
      }
    }

    notify_cancel(postSettingsBitmask_token);
    goto LABEL_73;
  }
  }

  if (v40) {
    free(v40);
  }
  nw_endpoint_t v13 = 0LL;
LABEL_59:

  return v13;
}

  if (v72) {
    free(v72);
  }
LABEL_155:
}

    if (v32) {
      free(v32);
    }
    *(_DWORD *)(*(void *)(a1 + 48) + 24LL) = 0;
  }

  if (!gLogDatapath)
  {
    BOOL v42 = *(_DWORD *)(a1 + 56);
    os_log_type_t v43 = v4 - v42;
    if (v4 == v42) {
      goto LABEL_98;
    }
    goto LABEL_97;
  }

  os_log_type_t v47 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
  {
    BOOL v48 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)buf = 136446722;
    id v55 = "nw_frame_cache_create_frame_block_invoke";
    os_log_type_t v56 = 1024;
    *(_DWORD *)BOOL v57 = v4;
    *(_WORD *)&v57[4] = 1024;
    *(_DWORD *)&v57[6] = v48;
    _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s reusing frame of length %u, adjusting to %u",  buf,  0x18u);
  }

  uint64_t v49 = *(_DWORD *)(a1 + 56);
  os_log_type_t v43 = v4 - v49;
  if (v4 != v49)
  {
    if (gLogDatapath)
    {
      nw_endpoint_t v51 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        id v55 = "nw_frame_cache_create_frame_block_invoke";
        os_log_type_t v56 = 1024;
        *(_DWORD *)BOOL v57 = v43;
        _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s claiming %u bytes off end of frame",  buf,  0x12u);
      }
    }

  if (v43) {
    free(v43);
  }
  uint64_t v20 = 0LL;
LABEL_41:

  return v20;
}

      free(v50);
      if (!v44) {
        goto LABEL_52;
      }
      goto LABEL_108;
    }

    uint64_t v45 = (os_log_s *)__nwlog_obj();
    os_log_type_t v46 = type;
    if (!os_log_type_enabled(v45, type)) {
      goto LABEL_107;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v57 = "nw_http_connect_reattach_protocol";
    os_log_type_t v47 = "%{public}s called with null definition";
LABEL_106:
    _os_log_impl(&dword_181A5C000, v45, v46, v47, buf, 0xCu);
    goto LABEL_107;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v57 = "nw_http_connect_reattach_protocol";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v57 = "nw_http_connect_reattach_protocol";
      os_log_type_t v47 = "%{public}s called with null protocol_parameters";
      goto LABEL_106;
    }

    if (!v54)
    {
      uint64_t v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v57 = "nw_http_connect_reattach_protocol";
      os_log_type_t v47 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_106;
    }

    os_log_type_t v50 = (char *)__nw_create_backtrace_string();
    uint64_t v45 = (os_log_s *)__nwlog_obj();
    os_log_type_t v46 = type;
    nw_endpoint_t v53 = os_log_type_enabled(v45, type);
    if (!v50)
    {
      if (!v53) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v57 = "nw_http_connect_reattach_protocol";
      os_log_type_t v47 = "%{public}s called with null protocol_parameters, no backtrace";
      goto LABEL_106;
    }

    if (v53)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v57 = "nw_http_connect_reattach_protocol";
      os_log_type_t v58 = 2082;
      os_log_type_t v59 = v50;
      uint64_t v52 = "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s";
      goto LABEL_91;
    }

    goto LABEL_92;
  }

  os_log_type_t v15 = a3;

  uint64_t internal = nw_protocol_create_internal((uint64_t)v15 + 8, *(void **)(v14 + 120), *(const char **)(v14 + 112), 1);
  if (internal)
  {
    __int16 v17 = internal;
    uint64_t v18 = a4;
    v18[2] = v17;

    uint64_t v19 = *(uint64_t (***)(uint64_t, uint64_t))(v17 + 24);
    if (v19 && (uint64_t v20 = *v19) != 0LL)
    {
      __int16 v21 = v20(v17, v13);
      char v22 = v21;
      if (*(void *)(v14 + 56))
      {
        if ((v21 & 1) != 0) {
          goto LABEL_20;
        }
      }

      else
      {
        nw_protocol_set_output_handler(v14 + 24, v17);
        if ((v22 & 1) != 0)
        {
LABEL_20:
          **(void **)(a1 + 4_Block_object_dispose((const void *)(v67 - 152), 8) = v17;
          uint64_t v23 = *(void *)(a1 + 40);
          if (!v23 || (*(_WORD *)(v23 + 368) & 0x80) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              id v25 = *(void *)(a1 + 40);
              uint64_t v26 = v25 == 0;
              if (v25) {
                id v27 = (const char *)(v25 + 284);
              }
              else {
                id v27 = "";
              }
              *(_DWORD *)buf = 136446978;
              BOOL v57 = "nw_http_connect_reattach_protocols_block_invoke";
              os_log_type_t v58 = 2082;
              os_log_type_t v59 = (void *)v27;
              if (v26) {
                uint64_t v28 = "";
              }
              else {
                uint64_t v28 = " ";
              }
              __int16 v60 = 2080;
              id v61 = v28;
              char v62 = 2114;
              id v63 = v15;
              _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAttached protocol: %{public}@",  buf,  0x2Au);
            }
          }

          return 1LL;
        }
      }

      if ((*(_WORD *)(v14 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v36 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          BOOL v57 = "nw_http_connect_reattach_protocol";
          os_log_type_t v58 = 2082;
          os_log_type_t v59 = (void *)(v14 + 284);
          __int16 v60 = 2080;
          id v61 = " ";
          char v62 = 2114;
          id v63 = v15;
          uint64_t v37 = "%{public}s %{public}s%sCould not add input handler for %{public}@";
          goto LABEL_51;
        }
      }
    }

    else if ((*(_WORD *)(v14 + 368) & 0x80) == 0)
    {
      os_log_type_t v36 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        BOOL v57 = "nw_http_connect_reattach_protocol";
        os_log_type_t v58 = 2082;
        os_log_type_t v59 = (void *)(v14 + 284);
        __int16 v60 = 2080;
        id v61 = " ";
        char v62 = 2114;
        id v63 = v15;
        uint64_t v37 = "%{public}s %{public}s%sCannot call add input handler for %{public}@ because it is not valid";
        goto LABEL_51;
      }
    }
  }

  else if ((*(_WORD *)(v14 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v36 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      BOOL v57 = "nw_http_connect_reattach_protocol";
      os_log_type_t v58 = 2082;
      os_log_type_t v59 = (void *)(v14 + 284);
      __int16 v60 = 2080;
      id v61 = " ";
      char v62 = 2114;
      id v63 = v15;
      uint64_t v37 = "%{public}s %{public}s%sPath could not create protocol for %{public}@";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v36, OS_LOG_TYPE_ERROR, v37, buf, 0x2Au);
    }
  }

        free(v20);
        goto LABEL_93;
      }

      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "nw_proxy_config_create_oblivious_http";
        _os_log_impl( &dword_181A5C000,  v21,  v41,  "%{public}s called with null gateway_key_config_length, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v49 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        id v54 = "nw_proxy_config_create_oblivious_http";
        _os_log_impl( &dword_181A5C000,  v21,  v49,  "%{public}s called with null gateway_key_config_length, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      free(v53);
      if (!v43) {
        goto LABEL_157;
      }
      goto LABEL_156;
    }

    BOOL v44 = (os_log_s *)__nwlog_obj();
    uint64_t v45 = type;
    if (!os_log_type_enabled(v44, type)) {
      goto LABEL_155;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v95 = "nw_http1_get_http1_protocol";
    os_log_type_t v46 = "%{public}s called with null handle";
LABEL_154:
    _os_log_impl(&dword_181A5C000, v44, v45, v46, buf, 0xCu);
    goto LABEL_155;
  }

  char v5 = *(_DWORD *)(v3 + 24);
  uint64_t v6 = *(void **)(a1 + 40);
  if (v5 == 1) {
    goto LABEL_10;
  }
  if (v5 != 2)
  {
    if (v5 != 3)
    {
LABEL_157:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      BOOL v95 = "nw_protocol_http1_notify";
      os_log_type_t v47 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v92 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v48 = (os_log_s *)gLogObj;
        uint64_t v49 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_274;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v95 = "nw_protocol_http1_notify";
        os_log_type_t v50 = "%{public}s called with null http1";
        goto LABEL_273;
      }

      if (!v92)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v48 = (os_log_s *)gLogObj;
        uint64_t v49 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_274;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v95 = "nw_protocol_http1_notify";
        os_log_type_t v50 = "%{public}s called with null http1, backtrace limit exceeded";
        goto LABEL_273;
      }

      __int16 v74 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v48 = (os_log_s *)gLogObj;
      uint64_t v49 = type;
      os_log_type_t v75 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v74)
      {
        if (!v75) {
          goto LABEL_274;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v95 = "nw_protocol_http1_notify";
        os_log_type_t v50 = "%{public}s called with null http1, no backtrace";
        goto LABEL_273;
      }

      if (v75)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v95 = "nw_protocol_http1_notify";
        BOOL v96 = 2082;
        nw_endpoint_t v97 = v74;
        _os_log_impl( &dword_181A5C000,  v48,  v49,  "%{public}s called with null http1, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v74);
      goto LABEL_274;
    }

    char v7 = *(void *)(v3 + 16);
    if (v7)
    {
      uint64_t v6 = (void *)(v7 + 480);
      goto LABEL_10;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v95 = "nw_http1_get_http1_protocol";
    os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v92 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_155;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v95 = "nw_http1_get_http1_protocol";
      os_log_type_t v46 = "%{public}s called with null handle->http1_connection";
      goto LABEL_154;
    }

    if (!v92)
    {
      BOOL v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_155;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v95 = "nw_http1_get_http1_protocol";
      os_log_type_t v46 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
      goto LABEL_154;
    }

    nw_endpoint_t v53 = (char *)__nw_create_backtrace_string();
    BOOL v44 = (os_log_s *)__nwlog_obj();
    uint64_t v45 = type;
    __int16 v60 = os_log_type_enabled(v44, type);
    if (!v53)
    {
      if (!v60) {
        goto LABEL_155;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v95 = "nw_http1_get_http1_protocol";
      os_log_type_t v46 = "%{public}s called with null handle->http1_connection, no backtrace";
      goto LABEL_154;
    }

    if (v60)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v95 = "nw_http1_get_http1_protocol";
      BOOL v96 = 2082;
      nw_endpoint_t v97 = v53;
      id v55 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
      goto LABEL_91;
    }

    goto LABEL_92;
  }

  os_log_type_t v8 = *(void *)(v3 + 8);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v95 = "nw_http1_get_http1_protocol";
    os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v92 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_155;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v95 = "nw_http1_get_http1_protocol";
      os_log_type_t v46 = "%{public}s called with null handle->http1_stream";
      goto LABEL_154;
    }

    if (!v92)
    {
      BOOL v44 = (os_log_s *)__nwlog_obj();
      uint64_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_155;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v95 = "nw_http1_get_http1_protocol";
      os_log_type_t v46 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_154;
    }

    nw_endpoint_t v53 = (char *)__nw_create_backtrace_string();
    BOOL v44 = (os_log_s *)__nwlog_obj();
    uint64_t v45 = type;
    id v61 = os_log_type_enabled(v44, type);
    if (!v53)
    {
      if (!v61) {
        goto LABEL_155;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v95 = "nw_http1_get_http1_protocol";
      os_log_type_t v46 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_154;
    }

    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v95 = "nw_http1_get_http1_protocol";
      BOOL v96 = 2082;
      nw_endpoint_t v97 = v53;
      id v55 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_91;
    }

    goto LABEL_92;
  }

  uint64_t v6 = (void *)(v8 + 248);
LABEL_10:
  if (!*v6) {
    goto LABEL_157;
  }
  if (a2)
  {
    switch(a3)
    {
      case 0u:
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        BOOL v95 = "nw_protocol_http1_notify";
        os_log_type_t v47 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        BOOL v92 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v48 = (os_log_s *)__nwlog_obj();
          uint64_t v49 = type;
          if (!os_log_type_enabled(v48, type)) {
            goto LABEL_274;
          }
          *(_DWORD *)buf = 136446210;
          BOOL v95 = "nw_protocol_http1_notify";
          os_log_type_t v50 = "%{public}s called with null type";
          goto LABEL_273;
        }

        if (v92)
        {
          os_log_type_t v56 = (char *)__nw_create_backtrace_string();
          BOOL v48 = (os_log_s *)__nwlog_obj();
          uint64_t v49 = type;
          os_log_type_t v59 = os_log_type_enabled(v48, type);
          if (v56)
          {
            if (!v59) {
              goto LABEL_267;
            }
            *(_DWORD *)buf = 136446466;
            BOOL v95 = "nw_protocol_http1_notify";
            BOOL v96 = 2082;
            nw_endpoint_t v97 = v56;
            os_log_type_t v58 = "%{public}s called with null type, dumping backtrace:%{public}s";
            goto LABEL_266;
          }

          if (!v59) {
            goto LABEL_274;
          }
          *(_DWORD *)buf = 136446210;
          BOOL v95 = "nw_protocol_http1_notify";
          os_log_type_t v50 = "%{public}s called with null type, no backtrace";
        }

        else
        {
          BOOL v48 = (os_log_s *)__nwlog_obj();
          uint64_t v49 = type;
          if (!os_log_type_enabled(v48, type)) {
            goto LABEL_274;
          }
          *(_DWORD *)buf = 136446210;
          BOOL v95 = "nw_protocol_http1_notify";
          os_log_type_t v50 = "%{public}s called with null type, backtrace limit exceeded";
        }

        goto LABEL_273;
      case 7u:
      case 0x15u:
        return;
      case 0xDu:
      case 0x10u:
        if (v5 == 2)
        {
          nw_endpoint_t v13 = (uint64_t *)(v3 + 8);
          goto LABEL_42;
        }

        if (v5 != 3) {
          goto LABEL_239;
        }
        os_log_type_t v12 = *(void *)(v3 + 16);
        if (v12)
        {
          nw_endpoint_t v13 = (uint64_t *)(v12 + 488);
LABEL_42:
          uint64_t v28 = *v13;
          if (*v13)
          {
            BOOL v29 = *(void *)(v28 + 256);
            if (v29)
            {
              uint64_t v30 = *(void **)(v29 + 32);
              goto LABEL_55;
            }

            if ((*(_BYTE *)(v28 + 158) & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v31 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                id v32 = *(void *)(v28 + 256);
                os_log_type_t v33 = *(_DWORD *)(*(void *)(v28 + 248) + 372LL);
                if (v32) {
                  LODWORD(v32) = *(_DWORD *)(v32 + 860);
                }
                os_log_type_t v34 = off_189BBE330[a3];
                uint64_t v35 = *(_DWORD *)(v28 + 424);
                *(_DWORD *)buf = 136447746;
                BOOL v95 = "nw_protocol_http1_notify";
                BOOL v96 = 2082;
                nw_endpoint_t v97 = (char *)(v28 + 74);
                os_log_type_t v98 = 2080;
                os_log_type_t v99 = " ";
                os_log_type_t v100 = 1024;
                os_log_type_t v101 = v33;
                BOOL v102 = 1024;
                os_log_type_t v103 = v32;
                BOOL v104 = 1024;
                id v105 = v35;
                os_log_type_t v106 = 2080;
                unint64_t v107 = v34;
                uint64_t v26 = "%{public}s %{public}s%s<i%u:c%u:s%u> dropping notification type %s";
                goto LABEL_64;
              }
            }

            return;
          }

        free(v23);
        goto LABEL_93;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v42 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      char v62 = "nw_nat64_get_interface_state_internal";
      id v63 = 1024;
      *(_DWORD *)uint64_t v64 = v4;
      uint64_t v30 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v59 = 0;
      if (__nwlog_fault(v30, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v43 = (os_log_s *)(id)gLogObj;
          BOOL v44 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)buf = 136446466;
            char v62 = "nw_nat64_get_interface_state_internal";
            id v63 = 1024;
            *(_DWORD *)uint64_t v64 = v4;
            _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed",  buf,  0x12u);
          }

  if (v29) {
    free(v29);
  }
  nw_endpoint_t v14 = 0LL;
LABEL_29:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v14;

  return 1LL;
}

    if (v39) {
      free(v39);
    }
    return 0LL;
  }

  os_log_type_t v8 = 0LL;
  char v7 = 0LL;
  nw_endpoint_t v13 = -1LL;
LABEL_40:
  if ((*(_WORD *)(a1 + 1373) & 0x100) == 0)
  {
    *(void *)(a1 + 992) = v8;
    *(void *)(a1 + 100_Block_object_dispose((const void *)(v67 - 152), 8) = v13;
    *(void *)(a1 + 1000) = v7;
    if (v8 >= 0x10000) {
      uint64_t v24 = 0x10000LL;
    }
    else {
      uint64_t v24 = v8;
    }
    if (v24 > v8)
    {
      id v25 = 22;
LABEL_46:
      *__error() = v25;
      uint64_t v26 = 8LL;
LABEL_73:
      *(void *)(a1 + 1200) = dispatch_data_create(buf, v26, 0LL, 0LL);
      nw_http3_start_encoder_stream_if_needed(a1);
      nw_http3_encoder_stream_process_output(a1);
      return 1LL;
    }

    if ((_DWORD)v24)
    {
      buf[0] = 32;
      if (v24 > 0x1E)
      {
        buf[0] = 63;
        uint64_t v30 = v24 - 31;
        if ((unint64_t)(v24 - 31) < 0x80)
        {
          id v32 = 1LL;
          id v31 = buf;
        }

        else
        {
          buf[1] = v30 | 0x80;
          if (v30 < 0x4000)
          {
            id v31 = &buf[1];
            v30 >>= 7;
            id v32 = 2LL;
          }

          else
          {
            id v31 = &buf[2];
            buf[2] = (v30 >> 7) | 0x80;
            v30 >>= 14;
            id v32 = 3LL;
          }
        }

        id v27 = v31 + 2;
        buf[v32] = v30;
        if (v31 + 2 <= buf)
        {
          id v25 = 55;
          goto LABEL_46;
        }
      }

      else
      {
        id v27 = &buf[1];
        buf[0] = v24 | 0x20;
      }

      uint64_t v28 = v8;
      BOOL v29 = v7;
      os_log_type_t v33 = *(FILE **)(a1 + 456);
      if (v33)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v33);
        uint64_t v26 = v27 - buf;
        fprintf(*(FILE **)(a1 + 456), "generated TSU=%u instruction %zd byte%.*s in size", v24, v26, v26 != 1, "s");
        fputc(10, *(FILE **)(a1 + 456));
      }

      else
      {
        uint64_t v26 = v27 - buf;
      }
    }

    else
    {
      uint64_t v28 = v8;
      BOOL v29 = v7;
      uint64_t v26 = 0LL;
    }

    os_log_type_t v34 = v24 / 0x60;
    *(_DWORD *)(a1 + 484) = v34;
    uint64_t v35 = malloc(8 * v34 + 8);
    *(void *)(a1 + 472) = v35;
    if (v35)
    {
      if (v28 >= 0x20)
      {
        v38 = v35;
        os_log_type_t v36 = malloc(0x80uLL);
        if (!v36)
        {
          free(v38);
          if (v26) {
            goto LABEL_73;
          }
          goto LABEL_77;
        }

        v36[2] = 0LL;
        v36[3] = v36 + 2;
        v36[4] = 0LL;
        v36[5] = v36 + 4;
        v36[6] = 0LL;
        v36[7] = v36 + 6;
        os_log_type_t v36[8] = 0LL;
        v36[9] = v36 + 8;
        v36[10] = 0LL;
        v36[11] = v36 + 10;
        v36[12] = 0LL;
        v36[13] = v36 + 12;
        v36[14] = 0LL;
        v36[15] = v36 + 14;
        uint64_t v37 = 2;
        *os_log_type_t v36 = 0LL;
        v36[1] = v36;
      }

      else
      {
        os_log_type_t v36 = 0LL;
        uint64_t v37 = 0;
      }

      *(_DWORD *)(a1 + 284) = v28 >> 5;
      *(_DWORD *)(a1 + 280) = v28;
      *(_DWORD *)(a1 + 276) = v24;
      *(_DWORD *)(a1 + 292) = v29;
      *(void *)(a1 + 32_Block_object_dispose((const void *)(v67 - 152), 8) = v36;
      *(_DWORD *)(a1 + 30_Block_object_dispose((const void *)(v67 - 152), 8) = v37;
      *(void *)(a1 + 456) = 0LL;
      *(_DWORD *)(a1 + 268) |= 2u;
    }

    if (v26) {
      goto LABEL_73;
    }
LABEL_77:
    *(_WORD *)(a1 + 1373) |= 0x2000u;
    return 1LL;
  }

  if (*(void *)(a1 + 992) > v8 || *(void *)(a1 + 1008) > v13) {
    return 0LL;
  }
  return *(void *)(a1 + 1000) <= v7;
}

    int v39 = self->super._interface;
    BOOL v40 = self->super._local_endpoint;
    if (v40) {
      goto LABEL_71;
    }
    goto LABEL_93;
  }

  return posix_error;
}

      free(v48);
      goto LABEL_93;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v49 = (os_log_s *)(id)gLogObj;
      os_log_type_t v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        else {
          nw_endpoint_t v51 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        BOOL v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        BOOL v96 = 2082;
        nw_endpoint_t v97 = (char *)v51;
        os_log_type_t v98 = 2082;
        os_log_type_t v99 = "flow";
        _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }

    if (v32)
    {
      os_log_type_t v58 = (char *)v32;
LABEL_116:
      free(v58);
      return -902LL;
    }

    return -902LL;
  }

  if (!v13(*(void *)(a5 + 32), a5, 1LL, a3, 0xFFFFFFFFLL, v90) || (nw_endpoint_t v14 = v90[0]) == 0)
  {
    *(_WORD *)(a5 + 388) |= 0x2000u;
    return -504LL;
  }

  *(void *)os_log_type_t type = 0LL;
  nw_endpoint_t v88 = 0;
  uint64_t v86 = type;
  nw_endpoint_t v87 = 0x2000000000LL;
  id v81 = 0LL;
  uint64_t v82 = &v81;
  uint64_t v84 = 0;
  id v83 = 0x2000000000LL;
  os_log_type_t v15 = MEMORY[0x1895F87A8];
  v71[0] = MEMORY[0x1895F87A8];
  v71[1] = 0x40000000LL;
  __int16 v72 = ___ZL13send_callbackP15nghttp2_sessionPKhmiPv_block_invoke_82172;
  BOOL v73 = &unk_189BC8020;
  __int16 v76 = a3;
  BOOL v77 = a2;
  __int16 v78 = a5;
  nw_endpoint_t v79 = v90;
  __int16 v80 = v10;
  __int16 v74 = type;
  os_log_type_t v75 = &v81;
  do
  {
    if (!v14) {
      break;
    }
    os_log_type_t v16 = *(void *)(v14 + 32);
    __int16 v17 = ((uint64_t (*)(void *))v72)(v71);
    nw_endpoint_t v14 = v16;
  }

  while ((v17 & 1) != 0);
  if ((*(_WORD *)(a5 + 388) & 0x100) == 0 && !v8)
  {
    uint64_t v18 = *(void *)(v11 + 24);
    if (v18)
    {
      uint64_t v19 = *(void (**)(uint64_t, void *))(v18 + 96);
      if (v19)
      {
        v19(v11, v10);
        goto LABEL_28;
      }
    }

    __nwlog_obj();
    nw_endpoint_t v51 = *(const char **)(v11 + 16);
    if (!v51) {
      nw_endpoint_t v51 = "invalid";
    }
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = "send_callback";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v51;
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v95) = 16;
    __int16 v70 = 0;
    if (__nwlog_fault(v52, &v95, &v70))
    {
      if (v95 == 17)
      {
        nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
        id v54 = v95;
        if (!os_log_type_enabled(v53, (os_log_type_t)v95)) {
          goto LABEL_127;
        }
        id v55 = *(const char **)(v11 + 16);
        if (!v55) {
          id v55 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v55;
        os_log_type_t v56 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
        goto LABEL_126;
      }

      if (!v70)
      {
        nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
        id v54 = v95;
        char v67 = os_log_type_enabled(v53, (os_log_type_t)v95);
        os_log_type_t v68 = "invalid";
        if (!v67) {
          goto LABEL_127;
        }
        if (*(void *)(v11 + 16)) {
          os_log_type_t v68 = *(const char **)(v11 + 16);
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v68;
        os_log_type_t v56 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_126;
      }

      uint64_t v64 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v53 = (os_log_s *)__nwlog_obj();
      id v54 = v95;
      char v65 = os_log_type_enabled(v53, (os_log_type_t)v95);
      if (v64)
      {
        if (v65)
        {
          char v66 = "invalid";
          if (*(void *)(v11 + 16)) {
            char v66 = *(const char **)(v11 + 16);
          }
          LODWORD(buf[0]) = 136446722;
          *(void *)((char *)buf + 4) = "send_callback";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v66;
          HIWORD(buf[2]) = 2082;
          BOOL v92 = v64;
          _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x20u);
        }

        free(v64);
        goto LABEL_127;
      }

      uint64_t v69 = "invalid";
      if (v65)
      {
        if (*(void *)(v11 + 16)) {
          uint64_t v69 = *(const char **)(v11 + 16);
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v69;
        os_log_type_t v56 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_126:
        _os_log_impl(&dword_181A5C000, v53, v54, v56, (uint8_t *)buf, 0x16u);
      }
    }

    if (v25) {
      free(v25);
    }
    LODWORD(v21) = 0;
    goto LABEL_95;
  }

  if (v7 <= 9)
  {
    v6[v8] = v10 - 1;
    char v11 = *(void *)(a1 + 104);
    if ((!v11 || (*(__int16 *)(v11 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_protocol_definition_t v179 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v180 = *(void *)(a1 + 104);
        nw_protocol_definition_t v181 = (const char *)(v180 + 390);
        uint64_t v182 = "";
        id v183 = v180 == 0;
        nw_endpoint_t v184 = *(_DWORD *)(v180 + 368);
        v256 = "send_data_callback_block_invoke";
        if (v183) {
          nw_protocol_definition_t v181 = "";
        }
        id v257 = 2082;
        *(_DWORD *)buf = 136447234;
        if (!v183) {
          uint64_t v182 = " ";
        }
        os_log_type_t v258 = v181;
        v259 = 2080;
        uint64_t v260 = (size_t)v182;
        int v261 = 1024;
        *(_DWORD *)char v262 = v184;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = 1;
        _os_log_impl( &dword_181A5C000,  v179,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> wrote %u byte of padding length",  buf,  0x2Cu);
      }
    }

    LODWORD(v_Block_object_dispose((const void *)(v67 - 152), 8) = v8 + 1;
    LODWORD(v7) = ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    os_log_type_t v10 = *(void *)(*(void *)(a1 + 112) + 16LL);
  }

  else {
    LODWORD(v12) = *(_DWORD *)(a1 + 120) - *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  }
  if (!*(void *)(a1 + 128))
  {
LABEL_181:
    *(_DWORD *)os_log_type_t type = 0;
    nw_endpoint_t v79 = (const void *)nw_frame_unclaimed_bytes(*(void *)(a1 + 176), type);
    if (v79)
    {
      else {
        __int16 v80 = v12;
      }
      memcpy(&v6[v8], v79, v80);
      uint64_t v82 = *(void *)(a1 + 104);
      if ((!v82 || (*(__int16 *)(v82 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        nw_endpoint_t v197 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v198 = *(void *)(a1 + 104);
          char v199 = "";
          uint64_t v200 = v198 == 0;
          id v201 = *(_DWORD *)(v198 + 368);
          id v202 = (const char *)(v198 + 390);
          v256 = "send_data_callback_block_invoke";
          id v257 = 2082;
          if (v200) {
            id v202 = "";
          }
          *(_DWORD *)buf = 136447234;
          if (!v200) {
            char v199 = " ";
          }
          os_log_type_t v258 = v202;
          v259 = 2080;
          uint64_t v260 = (size_t)v199;
          int v261 = 1024;
          *(_DWORD *)char v262 = v201;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v80;
          _os_log_impl( &dword_181A5C000,  v197,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> wrote %u bytes of body data (padding)",  buf,  0x2Cu);
        }
      }

      nw_frame_claim(*(void *)(a1 + 176), v81, v80, 0);
      LODWORD(v_Block_object_dispose((const void *)(v67 - 152), 8) = v80 + v8;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v80;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v80;
      goto LABEL_190;
    }

    if (*(void *)(a1 + 128))
    {
LABEL_190:
      os_log_type_t v10 = *(void *)(*(void *)(a1 + 112) + 16LL);
LABEL_191:
      if (v10 < 2) {
        goto LABEL_278;
      }
      id v83 = v254 - v8;
      uint64_t v84 = ~*(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) + v10;
      if (v84 >= v83) {
        BOOL v85 = v83;
      }
      else {
        BOOL v85 = v84;
      }
      bzero(&v6[v8], v85);
      uint64_t v86 = *(void *)(a1 + 104);
      if ((!v86 || (*(__int16 *)(v86 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v185 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          id v186 = *(void *)(a1 + 104);
          BOOL v187 = "";
          char v188 = v186 == 0;
          nw_endpoint_t v189 = *(_DWORD *)(v186 + 368);
          v190 = (const char *)(v186 + 390);
          v256 = "send_data_callback_block_invoke";
          id v257 = 2082;
          if (v188) {
            v190 = "";
          }
          *(_DWORD *)buf = 136447234;
          if (!v188) {
            BOOL v187 = " ";
          }
          os_log_type_t v258 = v190;
          v259 = 2080;
          uint64_t v260 = (size_t)v187;
          int v261 = 1024;
          *(_DWORD *)char v262 = v189;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v85;
          _os_log_impl( &dword_181A5C000,  v185,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> wrote %u bytes of padding",  buf,  0x2Cu);
        }
      }

      LODWORD(v_Block_object_dispose((const void *)(v67 - 152), 8) = v85 + v8;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v85;
      nw_endpoint_t v87 = *(void *)(a1 + 80);
      goto LABEL_277;
    }

    nw_endpoint_t v88 = *(void *)(a1 + 104);
    if (!v88 || (*(__int16 *)(v88 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v89 = *(void *)(a1 + 104);
      os_log_type_t v90 = (const char *)(v89 + 390);
      id v91 = v89 == 0;
      BOOL v92 = *(_DWORD *)(v89 + 368);
      *(_DWORD *)buf = 136446978;
      if (v91) {
        os_log_type_t v90 = "";
      }
      v256 = "send_data_callback_block_invoke";
      if (v91) {
        id v93 = "";
      }
      else {
        id v93 = " ";
      }
      id v257 = 2082;
      os_log_type_t v258 = v90;
      v259 = 2080;
      uint64_t v260 = (size_t)v93;
      int v261 = 1024;
      *(_DWORD *)char v262 = v92;
      int v94 = (char *)_os_log_send_and_compose_impl();
      id v253 = OS_LOG_TYPE_ERROR;
      v251 = 0;
      if (v253 == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v95 = (os_log_s *)gconnectionLogObj;
        BOOL v96 = v253;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253)) {
          goto LABEL_343;
        }
        nw_endpoint_t v97 = *(void *)(a1 + 104);
        os_log_type_t v98 = (const char *)(v97 + 390);
        os_log_type_t v99 = v97 == 0;
        if (!v97) {
          os_log_type_t v98 = "";
        }
        os_log_type_t v100 = *(_DWORD *)(v97 + 368);
        if (v99) {
          os_log_type_t v101 = "";
        }
        else {
          os_log_type_t v101 = " ";
        }
        goto LABEL_219;
      }

      if (v251)
      {
        BOOL v111 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v95 = (os_log_s *)gconnectionLogObj;
        BOOL v96 = v253;
        os_log_type_t v112 = os_log_type_enabled((os_log_t)gconnectionLogObj, v253);
        if (v111)
        {
          if (v112)
          {
            id v113 = *(void *)(a1 + 104);
            id v114 = (const char *)(v113 + 390);
            if (v113)
            {
              os_log_type_t v115 = " ";
            }

            else
            {
              id v114 = "";
              os_log_type_t v115 = "";
            }

          free(v50);
          goto LABEL_120;
        }

        if (!v52) {
          goto LABEL_120;
        }
LABEL_118:
        __int16 v60 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        BOOL v102 = "nw_protocol_http2_connect";
        os_log_type_t v103 = 2082;
        BOOL v104 = (char *)(handle + 195);
        id v105 = 2080;
        os_log_type_t v106 = " ";
        unint64_t v107 = 1024;
        nw_endpoint_t v108 = v60;
        os_log_type_t v109 = 2048;
        *(void *)os_log_type_t v110 = a2;
        uint64_t v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, no backtrace";
        goto LABEL_119;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v42 = (os_log_s *)gconnectionLogObj;
      os_log_type_t v43 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_120;
      }
LABEL_100:
      id v55 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      BOOL v102 = "nw_protocol_http2_connect";
      os_log_type_t v103 = 2082;
      BOOL v104 = (char *)(handle + 195);
      id v105 = 2080;
      os_log_type_t v106 = " ";
      unint64_t v107 = 1024;
      nw_endpoint_t v108 = v55;
      os_log_type_t v109 = 2048;
      *(void *)os_log_type_t v110 = a2;
      uint64_t v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, backtrace limit exceeded";
      goto LABEL_119;
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v25 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v28 = *(_DWORD *)(v24 + 176);
      id v27 = *(_DWORD *)(v24 + 180);
      *(_DWORD *)buf = 136447746;
      BOOL v102 = "nw_protocol_http2_connect";
      os_log_type_t v103 = 2082;
      BOOL v104 = (char *)(v24 + 191);
      id v105 = 2080;
      os_log_type_t v106 = " ";
      unint64_t v107 = 1024;
      nw_endpoint_t v108 = v27;
      os_log_type_t v109 = 1024;
      *(_DWORD *)os_log_type_t v110 = v28;
      *(_WORD *)&v110[4] = 1024;
      *(_DWORD *)&v110[6] = v28;
      v111[0] = 2048;
      *(void *)&v111[1] = v24;
      BOOL v29 = "%{public}s %{public}s%s<i%u:s%d> nw_http2_stream_connect failed for stream id %d (%p)";
      uint64_t v30 = (os_log_s *)v25;
      id v31 = 60;
LABEL_44:
      _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      return 0LL;
    }
  }

  else
  {
    if (handle[194] < 0) {
      return 0LL;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v32 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      os_log_type_t v33 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      BOOL v102 = "nw_protocol_http2_connect";
      os_log_type_t v103 = 2082;
      BOOL v104 = (char *)(handle + 195);
      id v105 = 2080;
      os_log_type_t v106 = " ";
      unint64_t v107 = 1024;
      nw_endpoint_t v108 = v33;
      os_log_type_t v109 = 2048;
      *(void *)os_log_type_t v110 = a2;
      BOOL v29 = "%{public}s %{public}s%s<i%u> connect called on protocol %p which is not in protocol hash table";
      uint64_t v30 = (os_log_s *)v32;
      id v31 = 48;
      goto LABEL_44;
    }
  }

  return result;
}

        if (v47) {
          free(v47);
        }
        goto LABEL_94;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0LL);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&void buf[14] = v26;
      id v27 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v134 = OS_LOG_TYPE_ERROR;
      id v128 = 0;
      if (__nwlog_fault(v27, &v134, &v128))
      {
        if (v134 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v28 = (os_log_s *)gLogObj;
          BOOL v29 = v134;
          if (!os_log_type_enabled((os_log_t)gLogObj, v134)) {
            goto LABEL_71;
          }
          uint64_t v30 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0LL);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v30;
          id v31 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames";
          goto LABEL_70;
        }

        if (!v128)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v28 = (os_log_s *)gLogObj;
          BOOL v29 = v134;
          if (!os_log_type_enabled((os_log_t)gLogObj, v134)) {
            goto LABEL_71;
          }
          os_log_type_t v41 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0LL);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v41;
          id v31 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, backtrace limit exceeded";
          goto LABEL_70;
        }

        uint64_t v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v28 = (os_log_s *)gLogObj;
        BOOL v29 = v134;
        os_log_type_t v36 = os_log_type_enabled((os_log_t)gLogObj, v134);
        if (v35)
        {
          if (v36)
          {
            uint64_t v37 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0LL);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&void buf[14] = v37;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v35;
            _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v35);
          uint64_t v20 = MEMORY[0x1895F87A8];
          goto LABEL_71;
        }

        uint64_t v20 = MEMORY[0x1895F87A8];
        if (v36)
        {
          BOOL v42 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0LL);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&void buf[14] = v42;
          id v31 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, no backtrace";
LABEL_70:
          _os_log_impl(&dword_181A5C000, v28, v29, v31, buf, 0x12u);
        }
      }

        if (v25) {
          free(v25);
        }
        goto LABEL_16;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v51 = "__nw_protocol_disconnected";
      char v5 = _os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v36 = (os_log_s *)__nwlog_obj();
        uint64_t v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_106;
        }
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v51 = "__nw_protocol_disconnected";
        v38 = "%{public}s called with null other_protocol";
      }

      else if (v48)
      {
        BOOL v44 = (char *)__nw_create_backtrace_string();
        os_log_type_t v36 = (os_log_s *)__nwlog_obj();
        uint64_t v37 = type;
        uint64_t v45 = os_log_type_enabled(v36, type);
        if (v44)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            nw_endpoint_t v51 = "__nw_protocol_disconnected";
            uint64_t v52 = 2082;
            nw_endpoint_t v53 = v44;
            _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v44);
          if (!v5) {
            goto LABEL_18;
          }
          goto LABEL_37;
        }

        if (!v45)
        {
LABEL_106:
          if (!v5)
          {
LABEL_18:
            if (v6 != &nw_protocol_ref_counted_handle) {
              goto LABEL_20;
            }
            if (*(_UNKNOWN **)(v4 + 40) != &nw_protocol_ref_counted_handle) {
              goto LABEL_20;
            }
            nw_endpoint_t v13 = *(void *)(v4 + 88);
            if (!v13) {
              goto LABEL_20;
            }
            nw_endpoint_t v14 = v13 - 1;
            *(void *)(v4 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v14;
            if (v14) {
              goto LABEL_20;
            }
            os_log_type_t v15 = *(void (***)(void))(v4 + 64);
            if (v15)
            {
              *(void *)(v4 + 64) = 0LL;
              v15[2](v15);
              _Block_release(v15);
            }

            if ((*(_BYTE *)(v4 + 72) & 1) != 0)
            {
              os_log_type_t v16 = *(const void **)(v4 + 64);
              if (v16) {
                _Block_release(v16);
              }
            }

            goto LABEL_29;
          }

void sub_181AF613C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_start_child(void *a1)
{
  uint64_t v144 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_endpoint_handler_get_mode";
    os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v140 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v36, type, &v140))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type[0];
        if (os_log_type_enabled(v37, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null handler", (uint8_t *)buf, 0xCu);
        }
      }

      else if (v140)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type[0];
        BOOL v47 = os_log_type_enabled(v37, type[0]);
        if (backtrace_string)
        {
          if (v47)
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_endpoint_handler_get_mode";
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v37,  v46,  "%{public}s called with null handler, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_65;
        }

        if (v47)
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v37,  v46,  "%{public}s called with null handler, no backtrace",  (uint8_t *)buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v53 = type[0];
        if (os_log_type_enabled(v37, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v37,  v53,  "%{public}s called with null handler, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
        }
      }
    }

LABEL_222:
      if (v122) {
        free(v122);
      }
      os_log_type_t v106 = 0LL;
      goto LABEL_188;
    }

    BOOL v29 = (void *)v28[5];
    if (v29 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v31 = v28[11];
      if (v31) {
        v28[11] = v31 + 1;
      }
      char v30 = -1;
    }

    else
    {
      char v30 = 0;
    }

    *(void *)os_log_type_t type = v28;
    char v139 = v30;
    uint64_t v32 = v28[3];
    if (v32)
    {
      os_log_type_t v33 = *(void (**)(void *))(v32 + 136);
      if (v33)
      {
        v33(v28);
        os_log_type_t v34 = (void *)objc_claimAutoreleasedReturnValue();
        if (v29 != &nw_protocol_ref_counted_handle) {
          goto LABEL_31;
        }
        goto LABEL_116;
      }
    }

    __nwlog_obj();
    int v39 = (void *)objc_claimAutoreleasedReturnValue();
    BOOL v40 = (const char *)v28[2];
    LODWORD(buf[0]) = 136446722;
    *(void *)((char *)buf + 4) = "__nw_protocol_get_remote_endpoint";
    if (!v40) {
      BOOL v40 = "invalid";
    }
    WORD6(buf[0]) = 2082;
    *(void *)((char *)buf + 14) = v40;
    WORD3(buf[1]) = 2048;
    *((void *)&buf[1] + 1) = v28;
    nw_endpoint_t v131 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t v140 = OS_LOG_TYPE_ERROR;
    char v137 = 0;
    os_log_type_t v41 = (char *)v131;
    if (!__nwlog_fault(v131, &v140, &v137))
    {
LABEL_113:
      if (v41) {
        free(v41);
      }
      os_log_type_t v34 = 0LL;
      if (v29 != &nw_protocol_ref_counted_handle)
      {
LABEL_31:
        if (!v34)
        {
LABEL_118:
          __int16 v72 = (void *)*((void *)v23 + 94);
          if (v72)
          {
            BOOL v73 = (void *)v72[5];
            if (v73 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v75 = v72[11];
              if (v75) {
                v72[11] = v75 + 1;
              }
              char v74 = -1;
            }

            else
            {
              char v74 = 0;
            }

            *(void *)os_log_type_t type = v72;
            char v139 = v74;
            uint64_t v76 = v72[3];
            if (v76)
            {
              BOOL v77 = *(void (**)(void *))(v76 + 112);
              if (v77)
              {
                v77(v72);
                __int16 v78 = (void *)objc_claimAutoreleasedReturnValue();
                if (v73 != &nw_protocol_ref_counted_handle) {
                  goto LABEL_127;
                }
                goto LABEL_169;
              }
            }

            __nwlog_obj();
            nw_endpoint_t v79 = (void *)objc_claimAutoreleasedReturnValue();
            __int16 v80 = (const char *)v72[2];
            LODWORD(buf[0]) = 136446722;
            *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
            if (!v80) {
              __int16 v80 = "invalid";
            }
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = v80;
            WORD3(buf[1]) = 2048;
            *((void *)&buf[1] + 1) = v72;
            os_log_type_t v132 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t v140 = OS_LOG_TYPE_ERROR;
            char v137 = 0;
            id v81 = (char *)v132;
            if (!__nwlog_fault(v132, &v140, &v137))
            {
LABEL_166:
              if (v81) {
                free(v81);
              }
              __int16 v78 = 0LL;
              if (v73 != &nw_protocol_ref_counted_handle)
              {
LABEL_127:
                if (!v78) {
                  goto LABEL_182;
                }
                goto LABEL_170;
              }

        if (v202) {
          free(v202);
        }
        object = 0LL;
LABEL_172:

        id v169 = v367;
        v170 = (*((_BYTE *)v367 + 268) & 0x20) == 0;

        if (v170)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v171 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
          {
            int v172 = v169;

            uint64_t v173 = v172;
            nw_endpoint_t v174 = (*((_BYTE *)v367 + 268) & 1) == 0;

            if (v174) {
              id v175 = "";
            }
            else {
              id v175 = "dry-run ";
            }
            v341 = nw_endpoint_handler_copy_endpoint(v173);
            v176 = nw_endpoint_get_logging_description(v341);
            nw_endpoint_t v177 = v173;
            uint64_t v178 = v177;
            nw_protocol_definition_t v179 = v351->state;
            v180 = "unknown-state";

            nw_protocol_definition_t v181 = v178;
            uint64_t v182 = "path";
            switch(v347[29])
            {
              case 0u:
                break;
              case 1u:
                uint64_t v182 = "resolver";
                break;
              case 2u:
                uint64_t v182 = nw_endpoint_flow_mode_string(v367->mode_handler);
                break;
              case 3u:
                uint64_t v182 = "proxy";
                break;
              case 4u:
                uint64_t v182 = "fallback";
                break;
              case 5u:
                uint64_t v182 = "transform";
                break;
              default:
                uint64_t v182 = "unknown-mode";
                break;
            }

            id v183 = v148;
            nw_endpoint_t v184 = v180;
            v185 = v181;
            os_unfair_lock_lock(lock);
            id v186 = v367->current_path;
            os_unfair_lock_unlock(lock);

            BOOL v187 = v184;
            __int16 v148 = v183;
            char v188 = v186;
            nw_endpoint_t v189 = nw_endpoint_get_logging_description(v354);
            *(_DWORD *)buf = 136448002;
            *(void *)&_OWORD buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v367->id_str;
            *(_WORD *)&buf[22] = 2082;
            uint64_t v379 = v175;
            *(_WORD *)v380 = 2082;
            *(void *)&v380[2] = v176;
            *(_WORD *)&v380[10] = 2082;
            *(void *)&v380[12] = v187;
            __int16 v381 = 2082;
            nw_endpoint_t v382 = v182;
            __int16 v383 = 2114;
            v384 = v188;
            __int16 v385 = 2082;
            id v386 = v189;
            _os_log_impl( &dword_181A5C000,  v171,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Keeping started endpoint %{public}s",  buf,  0x52u);
          }
        }

    if (v93) {
      free(v93);
    }
    os_log_type_t v43 = 0;
    goto LABEL_67;
  }

  *((void *)v10 + 3_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
  *((void *)v10 + 39) = v10 + 304;
  *((void *)v10 + 40) = 0LL;
  *((void *)v10 + 41) = v10 + 320;
  *((void *)v10 + 36) = 0LL;
  *((void *)v10 + 37) = v10 + 288;
  *((void *)v10 + 42) = 0LL;
  *((void *)v10 + 43) = v10 + 336;
  os_channel_attr_get();
  os_channel_attr_get();
  *((void *)v10 + 16) = 0LL;
  os_channel_attr_get();
  id v26 = *((void *)v10 + 14) + *((void *)v10 + 13);
  if (*((void *)v10 + 16) < v26) {
    *((void *)v10 + 16) = v26;
  }
  nw_channel_allocate_frames(v10);
  *((void *)v10 + 29) = 0x6C656E6E616863LL;
  *((void *)v10 + 33) = 0x200000000LL;
  *((void *)v10 + 5) = v10 + 232;
  *((void *)v10 + 6) = &g_channel_protocol_callbacks;
  *((void *)v10 + _Block_object_dispose((const void *)(v67 - 152), 8) = v10;
  *((void *)v10 + 4_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
  *((void *)v10 + 49) = v10 + 384;
  *((void *)v10 + 46) = 0LL;
  *((void *)v10 + 47) = v10 + 368;
  *((void *)v10 + 19) = os_retain(a1);
  BOOL v27 = dispatch_group_create();
  *((void *)v10 + 26) = v27;
  if (v27) {
    goto LABEL_48;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&_OWORD buf[4] = "nw_channel_create";
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    BOOL v27 = (dispatch_group_s *)*((void *)v10 + 26);
LABEL_48:
    dispatch_group_enter(v27);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000LL;
    *(void *)&_BYTE buf[24] = os_retain(v10);
    is_inline = nw_context_is_inline(a1);
    if (is_inline)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      uint64_t v31 = (id)nw_context_copy_implicit_context::implicit_context;
    }

    else
    {
      uint64_t v31 = a1;
    }

    BOOL v47 = nw_context_copy_workloop(v31);
    BOOL v48 = *((void *)v10 + 17);
    uint64_t v49 = (dispatch_group_s *)*((void *)v10 + 26);
    os_log_type_t v50 = MEMORY[0x1895F87A8];
    *(void *)block = MEMORY[0x1895F87A8];
    *(void *)&block[8] = 0x40000000LL;
    *(void *)&block[16] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke;
    os_log_type_t v126 = (const char *)&unk_189BC8EF8;
    *(void *)&BOOL v127 = buf;
    *((void *)&v127 + 1) = v48;
    dispatch_group_notify(v49, (dispatch_queue_t)v47, block);
    if (v47) {
      dispatch_release((dispatch_object_t)v47);
    }
    dispatch_group_enter(*((dispatch_group_t *)v10 + 26));
    BOOL v51 = *((_DWORD *)v10 + 108);
    v111[4] = v10;
    os_log_type_t v112 = v50;
    id v113 = 0x40000000LL;
    id v114 = (uint64_t)___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_35;
    os_log_type_t v115 = &__block_descriptor_tmp_36_86879;
    BOOL v117 = is_inline;
    int v116 = v10;
    v111[0] = v50;
    v111[1] = 0x40000000LL;
    v111[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_2;
    v111[3] = &__block_descriptor_tmp_37_86880;
    *((void *)v10 + 21) = nw_queue_context_create_source(a1, v51, 1, 0, &v112, v111);
    else {
      uint64_t v52 = 21LL;
    }
    nw_queue_source_set_qos_class_fallback(*((void **)v10 + 21), v52);
    dispatch_group_enter(*((dispatch_group_t *)v10 + 26));
    os_log_type_t v53 = *((_DWORD *)v10 + 108);
    v104[4] = v10;
    *(void *)id v105 = v50;
    os_log_type_t v106 = 0x40000000LL;
    unint64_t v107 = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_3;
    id v108 = &__block_descriptor_tmp_38_86881;
    os_log_type_t v110 = is_inline;
    os_log_type_t v109 = v10;
    v104[0] = v50;
    v104[1] = 0x40000000LL;
    v104[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_4;
    v104[3] = &__block_descriptor_tmp_39_86882;
    *((void *)v10 + 22) = nw_queue_context_create_source(a1, v53, 2, 0, v105, v104);
    if ((*v22 & 0x200) != 0)
    {
      dispatch_group_enter(*((dispatch_group_t *)v10 + 26));
      id v55 = *((_DWORD *)v10 + 108);
      v102[4] = v10;
      v103[0] = v50;
      v103[1] = 0x40000000LL;
      v103[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_5;
      v103[3] = &__block_descriptor_tmp_40_86883;
      v103[4] = v10;
      v102[0] = v50;
      v102[1] = 0x40000000LL;
      v102[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_6;
      v102[3] = &__block_descriptor_tmp_41_86884;
      source = nw_queue_context_create_source(a1, v55, 5, 1u, v103, v102);
      *((void *)v10 + 23) = source;
      nw_queue_activate_source(source, v57);
    }

    nw_queue_activate_source(*((void *)v10 + 21), v54);
    nw_queue_activate_source(*((void *)v10 + 22), v58);
    if (*((void *)v10 + 17))
    {
      if ((((unsigned __int16)*v22 | (v10[446] << 16)) & 0x80000) == 0)
      {
        if (!os_channel_is_defunct())
        {
          _Block_object_dispose(buf, 8);
          nw_dictionary_set_value(*(void *)globals_for_channel, out, v10);
          *v22 |= 0x2000u;
          if (a1[31] != 4)
          {
            os_log_type_t v62 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
            {
              BOOL v63 = *((_DWORD *)v10 + 108);
              *(_DWORD *)block = 136446722;
              *(void *)&block[4] = "nw_channel_create_with_attributes";
              *(_WORD *)&block[12] = 2082;
              *(void *)&block[14] = out;
              *(_WORD *)&block[22] = 1024;
              LODWORD(v126) = v63;
              _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_INFO,  "%{public}s Channel created with key: %{public}s and fd: %d",  block,  0x1Cu);
            }
          }

          goto LABEL_157;
        }

        nw_channel_handle_defunct((uint64_t)v10);
      }
    }

    else
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
      }
    }

    os_release(v10);
    os_log_type_t v59 = (uint64_t *)buf;
    goto LABEL_155;
  }

    if (!v4) {
      goto LABEL_18;
    }
    goto LABEL_77;
  }

  uint64_t v23 = *(void *)(a1 + 48);
  uint64_t v24 = *(void *)(v23 + 48);
  if (!v24)
  {
    __nwlog_obj();
    buf = 136446210;
    id v113 = "__nw_protocol_notify";
    uint64_t v24 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v110 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v80 = (os_log_s *)__nwlog_obj();
      id v81 = type[0];
      if (!os_log_type_enabled(v80, type[0])) {
        goto LABEL_233;
      }
      buf = 136446210;
      id v113 = "__nw_protocol_notify";
      uint64_t v82 = "%{public}s called with null protocol";
    }

    else if (v110)
    {
      os_log_type_t v98 = (char *)__nw_create_backtrace_string();
      __int16 v80 = (os_log_s *)__nwlog_obj();
      id v81 = type[0];
      id v99 = os_log_type_enabled(v80, type[0]);
      if (v98)
      {
        if (v99)
        {
          buf = 136446466;
          id v113 = "__nw_protocol_notify";
          id v114 = 2082;
          os_log_type_t v115 = v98;
          _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x16u);
        }

        free(v98);
        if (v24) {
          goto LABEL_101;
        }
        return;
      }

      if (!v99)
      {
LABEL_233:
        if (!v24) {
          return;
        }
LABEL_101:
        free((void *)v24);
        return;
      }

      buf = 136446210;
      id v113 = "__nw_protocol_notify";
      uint64_t v82 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      __int16 v80 = (os_log_s *)__nwlog_obj();
      id v81 = type[0];
      if (!os_log_type_enabled(v80, type[0])) {
        goto LABEL_233;
      }
      buf = 136446210;
      id v113 = "__nw_protocol_notify";
      uint64_t v82 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v80, v81, v82, (uint8_t *)&buf, 0xCu);
    goto LABEL_233;
  }

  id v25 = *(void **)(v24 + 40);
  if (v25 == &nw_protocol_ref_counted_handle)
  {
    id v26 = *(void *)(v24 + 88);
    if (v26) {
      *(void *)(v24 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v26 + 1;
    }
  }

  BOOL v27 = *(void **)(v23 + 40);
  if (v27 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v28 = *(void *)(v23 + 88);
    if (v28) {
      *(void *)(v23 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v28 + 1;
    }
  }

  BOOL v29 = *(void *)(v24 + 24);
  if (v29)
  {
    char v30 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(v29 + 160);
    if (v30)
    {
      v30(v24, v23, 19LL, 0LL, 0LL);
      goto LABEL_49;
    }
  }

  __nwlog_obj();
  char v67 = *(const char **)(v24 + 16);
  buf = 136446722;
  id v113 = "__nw_protocol_notify";
  if (!v67) {
    char v67 = "invalid";
  }
  id v114 = 2082;
  os_log_type_t v115 = (void *)v67;
  int v116 = 2048;
  BOOL v117 = v24;
  os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v110 = 0;
  if (__nwlog_fault(v68, type, &v110))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v69 = (os_log_s *)__nwlog_obj();
      __int16 v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_211;
      }
      int v71 = *(const char **)(v24 + 16);
      if (!v71) {
        int v71 = "invalid";
      }
      buf = 136446722;
      id v113 = "__nw_protocol_notify";
      id v114 = 2082;
      os_log_type_t v115 = (void *)v71;
      int v116 = 2048;
      BOOL v117 = v24;
      __int16 v72 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
      goto LABEL_210;
    }

    if (!v110)
    {
      uint64_t v69 = (os_log_s *)__nwlog_obj();
      __int16 v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_211;
      }
      os_log_type_t v104 = *(const char **)(v24 + 16);
      if (!v104) {
        os_log_type_t v104 = "invalid";
      }
      buf = 136446722;
      id v113 = "__nw_protocol_notify";
      id v114 = 2082;
      os_log_type_t v115 = (void *)v104;
      int v116 = 2048;
      BOOL v117 = v24;
      __int16 v72 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
      goto LABEL_210;
    }

    id v91 = (char *)__nw_create_backtrace_string();
    uint64_t v69 = (os_log_s *)__nwlog_obj();
    __int16 v70 = type[0];
    os_log_type_t v92 = os_log_type_enabled(v69, type[0]);
    if (v91)
    {
      if (v92)
      {
        BOOL v93 = *(const char **)(v24 + 16);
        if (!v93) {
          BOOL v93 = "invalid";
        }
        buf = 136446978;
        id v113 = "__nw_protocol_notify";
        id v114 = 2082;
        os_log_type_t v115 = (void *)v93;
        int v116 = 2048;
        BOOL v117 = v24;
        id v118 = 2082;
        os_log_type_t v119 = v91;
        _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x2Au);
      }

      free(v91);
      goto LABEL_211;
    }

    if (v92)
    {
      unint64_t v107 = *(const char **)(v24 + 16);
      if (!v107) {
        unint64_t v107 = "invalid";
      }
      buf = 136446722;
      id v113 = "__nw_protocol_notify";
      id v114 = 2082;
      os_log_type_t v115 = (void *)v107;
      int v116 = 2048;
      BOOL v117 = v24;
      __int16 v72 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
LABEL_210:
      _os_log_impl(&dword_181A5C000, v69, v70, v72, (uint8_t *)&buf, 0x20u);
    }
  }

            if (v90) {
              free(v90);
            }
            goto LABEL_224;
          }

          __nwlog_obj();
          nw_endpoint_t v79 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)os_log_type_t v128 = 136446210;
          *(void *)&v128[4] = "nw_http_security_options_get_skip_hsts_lookup";
          __int16 v80 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t v121 = OS_LOG_TYPE_ERROR;
          BOOL v120 = 0;
          if (__nwlog_fault(v80, &v121, &v120))
          {
            if (v121 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              id v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v82 = v121;
              if (os_log_type_enabled(v81, v121))
              {
                *(_DWORD *)os_log_type_t v128 = 136446210;
                *(void *)&v128[4] = "nw_http_security_options_get_skip_hsts_lookup";
                _os_log_impl( &dword_181A5C000,  v81,  v82,  "%{public}s protocol options are not http security",  v128,  0xCu);
              }
            }

            else
            {
              if (v120)
              {
                BOOL v85 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v87 = v121;
                nw_endpoint_t v88 = os_log_type_enabled(v86, v121);
                if (v85)
                {
                  if (v88)
                  {
                    *(_DWORD *)os_log_type_t v128 = 136446466;
                    *(void *)&v128[4] = "nw_http_security_options_get_skip_hsts_lookup";
                    *(_WORD *)&v128[12] = 2082;
                    *(void *)&v128[14] = v85;
                    _os_log_impl( &dword_181A5C000,  v86,  v87,  "%{public}s protocol options are not http security, dumping backtrace:%{public}s",  v128,  0x16u);
                  }

                  free(v85);
                }

                else
                {
                  if (v88)
                  {
                    *(_DWORD *)os_log_type_t v128 = 136446210;
                    *(void *)&v128[4] = "nw_http_security_options_get_skip_hsts_lookup";
                    _os_log_impl( &dword_181A5C000,  v86,  v87,  "%{public}s protocol options are not http security, no backtrace",  v128,  0xCu);
                  }
                }

                goto LABEL_213;
              }

              __nwlog_obj();
              id v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v93 = v121;
              if (os_log_type_enabled(v81, v121))
              {
                *(_DWORD *)os_log_type_t v128 = 136446210;
                *(void *)&v128[4] = "nw_http_security_options_get_skip_hsts_lookup";
                _os_log_impl( &dword_181A5C000,  v81,  v93,  "%{public}s protocol options are not http security, backtrace limit exceeded",  v128,  0xCu);
              }
            }
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_protocol_http1_notify";
          BOOL v47 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          os_log_type_t v92 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v48 = (os_log_s *)gLogObj;
            uint64_t v49 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_274;
            }
            *(_DWORD *)buf = 136446210;
            os_log_type_t v95 = "nw_protocol_http1_notify";
            os_log_type_t v50 = "%{public}s called with null http1_connection";
            goto LABEL_273;
          }

          if (v92)
          {
            os_log_type_t v56 = (char *)__nw_create_backtrace_string();
            BOOL v48 = (os_log_s *)__nwlog_obj();
            uint64_t v49 = type;
            BOOL v89 = os_log_type_enabled(v48, type);
            if (v56)
            {
              if (!v89) {
                goto LABEL_267;
              }
              goto LABEL_265;
            }

            if (!v89) {
              goto LABEL_274;
            }
            *(_DWORD *)buf = 136446210;
            os_log_type_t v95 = "nw_protocol_http1_notify";
            os_log_type_t v50 = "%{public}s called with null http1_connection, no backtrace";
          }

          else
          {
            BOOL v48 = (os_log_s *)__nwlog_obj();
            uint64_t v49 = type;
            if (!os_log_type_enabled(v48, type)) {
              goto LABEL_274;
            }
            *(_DWORD *)buf = 136446210;
            os_log_type_t v95 = "nw_protocol_http1_notify";
            os_log_type_t v50 = "%{public}s called with null http1_connection, backtrace limit exceeded";
          }

          goto LABEL_273;
        }

        uint64_t v16 = *(void *)(v3 + 8);
        if (v16)
        {
          nw_endpoint_t v11 = (uint64_t *)(v16 + 256);
          goto LABEL_32;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
        char v66 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v92 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v67 = (os_log_s *)__nwlog_obj();
          os_log_type_t v68 = type;
          if (!os_log_type_enabled(v67, type)) {
            goto LABEL_220;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
          uint64_t v69 = "%{public}s called with null handle->http1_stream";
        }

        else if (v92)
        {
          __int16 v78 = (char *)__nw_create_backtrace_string();
          char v67 = (os_log_s *)__nwlog_obj();
          os_log_type_t v68 = type;
          nw_endpoint_t v79 = os_log_type_enabled(v67, type);
          if (v78)
          {
            if (v79)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
              BOOL v96 = 2082;
              nw_endpoint_t v97 = v78;
              _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v78);
            goto LABEL_220;
          }

          if (!v79)
          {
LABEL_220:
            if (v66) {
              free(v66);
            }
            goto LABEL_222;
          }

          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
          uint64_t v69 = "%{public}s called with null handle->http1_stream, no backtrace";
        }

        else
        {
          char v67 = (os_log_s *)__nwlog_obj();
          os_log_type_t v68 = type;
          if (!os_log_type_enabled(v67, type)) {
            goto LABEL_220;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v95 = "nw_http1_get_connection_for_protocol";
          uint64_t v69 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v67, v68, v69, buf, 0xCu);
        goto LABEL_220;
      default:
        if (v5 != 2)
        {
          if (v5 != 3) {
            goto LABEL_258;
          }
          nw_endpoint_t v14 = (uint64_t *)(v3 + 16);
LABEL_52:
          uint64_t v37 = *v14;
          if (*v14)
          {
            os_log_type_t v38 = *(void *)(v37 + 488);
            if (v38)
            {
              char v30 = *(void **)(v38 + 48);
LABEL_55:
              nw_protocol_notify(v30, a2, a3);
            }

            else if ((*(_BYTE *)(v37 + 158) & 1) == 0)
            {
              uint64_t v31 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
              {
                int v39 = *(void *)(v37 + 488);
                if (v39) {
                  LODWORD(v39) = *(_DWORD *)(v39 + 424);
                }
                BOOL v40 = *(_DWORD *)(*(void *)(v37 + 480) + 372LL);
                os_log_type_t v41 = *(_DWORD *)(v37 + 860);
                if (a3 > 0x1A) {
                  BOOL v42 = "unknown";
                }
                else {
                  BOOL v42 = off_189BBE330[a3];
                }
                *(_DWORD *)buf = 136447746;
                os_log_type_t v95 = "nw_protocol_http1_notify";
                BOOL v96 = 2082;
                nw_endpoint_t v97 = (char *)(v37 + 74);
                os_log_type_t v98 = 2080;
                id v99 = " ";
                BOOL v100 = 1024;
                id v101 = v40;
                BOOL v102 = 1024;
                id v103 = v41;
                os_log_type_t v104 = 1024;
                id v105 = v39;
                os_log_type_t v106 = 2080;
                unint64_t v107 = (void *)v42;
                id v26 = "%{public}s %{public}s%s<i%u:c%u:s%u> dropping notification type %s";
LABEL_64:
                BOOL v27 = v31;
LABEL_65:
                _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_DEBUG, v26, buf, 0x3Cu);
              }
            }

            return;
          }

  os_log_type_t v95 = v86;
  BOOL v96 = *(unsigned __int8 *)(*((void *)v67 + 13) + 107LL);

  LODWORD(v556) = v96;
  if (!v96 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4400, &v556, 4u)) {
    goto LABEL_271;
  }
  nw_endpoint_t v97 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v98 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446978;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(void *)v555 = (char *)a1 + 404;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v556;
    *(_WORD *)&v555[14] = 1024;
    *(_DWORD *)&v555[16] = v97;
    _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d",  buf,  0x22u);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v99 = (os_log_s *)gLogObj;
  if (v97 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v556;
      *(_WORD *)&v555[4] = 1024;
      *(_DWORD *)&v555[6] = 22;
      _os_log_impl( &dword_181A5C000,  v99,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d",  buf,  0x18u);
    }

    goto LABEL_271;
  }

  v539 = p_output_handler;
  *(_DWORD *)buf = 136446722;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v556;
  *(_WORD *)&v555[4] = 1024;
  *(_DWORD *)&v555[6] = v97;
  os_log_type_t v109 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v548[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v109, type, v548))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v110 = (os_log_s *)__nwlog_obj();
      BOOL v111 = type[0];
      if (os_log_type_enabled(v110, type[0]))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v556;
        *(_WORD *)&v555[4] = 1024;
        *(_DWORD *)&v555[6] = v97;
        os_log_type_t v112 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d";
LABEL_266:
        id v125 = v110;
        os_log_type_t v126 = v111;
LABEL_267:
        _os_log_impl(&dword_181A5C000, v125, v126, v112, buf, 0x18u);
      }
    }

    else if (v548[0])
    {
      id v114 = v72;
      os_log_type_t v115 = (char *)__nw_create_backtrace_string();
      int v116 = (os_log_s *)__nwlog_obj();
      BOOL v117 = type[0];
      id v118 = os_log_type_enabled(v116, type[0]);
      if (v115)
      {
        if (v118)
        {
          *(_DWORD *)buf = 136446978;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v556;
          *(_WORD *)&v555[4] = 1024;
          *(_DWORD *)&v555[6] = v97;
          *(_WORD *)&v555[10] = 2082;
          *(void *)&v555[12] = v115;
          _os_log_impl( &dword_181A5C000,  v116,  v117,  "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v115);
        __int16 v72 = v114;
        goto LABEL_268;
      }

      __int16 v72 = v114;
      if (v118)
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v556;
        *(_WORD *)&v555[4] = 1024;
        *(_DWORD *)&v555[6] = v97;
        os_log_type_t v112 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, no backtrace";
        id v125 = v116;
        os_log_type_t v126 = v117;
        goto LABEL_267;
      }
    }

    else
    {
      os_log_type_t v110 = (os_log_s *)__nwlog_obj();
      BOOL v111 = type[0];
      if (os_log_type_enabled(v110, type[0]))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v556;
        *(_WORD *)&v555[4] = 1024;
        *(_DWORD *)&v555[6] = v97;
        os_log_type_t v112 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_266;
      }
    }
  }

                    nw::release_if_needed<nw_protocol *>(&v353);
                    goto LABEL_223;
                  }
                }

                else if ((v356 & 1) == 0)
                {
                  goto LABEL_150;
                }

                nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                goto LABEL_150;
              }

LABEL_170:
              id v99 = v78;
              BOOL v100 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v99,  0,  0);

              if (v34)
              {
                id v101 = v34;
                BOOL v102 = (*((_BYTE *)v101 + 231) & 4) == 0;

                if (!v102)
                {
                  id v103 = *((id *)v101 + 1);
                  nw_parameters_set_context((void *)v100, v103);
                }
              }

              BOOL v27 = v100;
              goto LABEL_183;
            }

            if (v140 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v130 = v140;
              if (os_log_type_enabled(v82, v140))
              {
                id v83 = (const char *)v72[2];
                if (!v83) {
                  id v83 = "invalid";
                }
                LODWORD(buf[0]) = 136446722;
                *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                WORD6(buf[0]) = 2082;
                *(void *)((char *)buf + 14) = v83;
                WORD3(buf[1]) = 2048;
                *((void *)&buf[1] + 1) = v72;
                _os_log_impl( &dword_181A5C000,  v82,  v130,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback",  (uint8_t *)buf,  0x20u);
              }
            }

            else
            {
              if (!v137)
              {
                __nwlog_obj();
                int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v95 = v140;
                BOOL v96 = v94;
                if (os_log_type_enabled(v94, v140))
                {
                  nw_endpoint_t v97 = (const char *)v72[2];
                  if (!v97) {
                    nw_endpoint_t v97 = "invalid";
                  }
                  LODWORD(buf[0]) = 136446722;
                  *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                  WORD6(buf[0]) = 2082;
                  *(void *)((char *)buf + 14) = v97;
                  WORD3(buf[1]) = 2048;
                  *((void *)&buf[1] + 1) = v72;
                  _os_log_impl( &dword_181A5C000,  v96,  v95,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded",  (uint8_t *)buf,  0x20u);
                }

                goto LABEL_165;
              }

              nw_endpoint_t v88 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v129 = v140;
              BOOL v89 = os_log_type_enabled(v82, v140);
              if (v88)
              {
                if (v89)
                {
                  os_log_type_t v90 = (const char *)v72[2];
                  if (!v90) {
                    os_log_type_t v90 = "invalid";
                  }
                  LODWORD(buf[0]) = 136446978;
                  *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                  WORD6(buf[0]) = 2082;
                  *(void *)((char *)buf + 14) = v90;
                  WORD3(buf[1]) = 2048;
                  *((void *)&buf[1] + 1) = v72;
                  LOWORD(buf[2]) = 2082;
                  *(void *)((char *)&buf[2] + 2) = v88;
                  _os_log_impl( &dword_181A5C000,  v82,  v129,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x2Au);
                }

                free(v88);
                goto LABEL_165;
              }

              if (v89)
              {
                os_log_type_t v98 = (const char *)v72[2];
                if (!v98) {
                  os_log_type_t v98 = "invalid";
                }
                LODWORD(buf[0]) = 136446722;
                *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                WORD6(buf[0]) = 2082;
                *(void *)((char *)buf + 14) = v98;
                WORD3(buf[1]) = 2048;
                *((void *)&buf[1] + 1) = v72;
                _os_log_impl( &dword_181A5C000,  v82,  v129,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace",  (uint8_t *)buf,  0x20u);
              }
            }

LABEL_165:
            id v81 = (char *)v132;
            goto LABEL_166;
          }

          __nwlog_obj();
          uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
          BOOL v85 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v140 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v85, type, &v140))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v87 = type[0];
              if (os_log_type_enabled(v86, type[0]))
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                _os_log_impl(&dword_181A5C000, v86, v87, "%{public}s called with null protocol", (uint8_t *)buf, 0xCu);
              }
            }

            else if (v140)
            {
              id v91 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v92 = type[0];
              BOOL v93 = os_log_type_enabled(v86, type[0]);
              if (v91)
              {
                if (v93)
                {
                  LODWORD(buf[0]) = 136446466;
                  *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                  WORD6(buf[0]) = 2082;
                  *(void *)((char *)buf + 14) = v91;
                  _os_log_impl( &dword_181A5C000,  v86,  v92,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
                }

                free(v91);
                goto LABEL_180;
              }

              if (v93)
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                _os_log_impl( &dword_181A5C000,  v86,  v92,  "%{public}s called with null protocol, no backtrace",  (uint8_t *)buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v104 = type[0];
              if (os_log_type_enabled(v86, type[0]))
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "__nw_protocol_get_parameters";
                _os_log_impl( &dword_181A5C000,  v86,  v104,  "%{public}s called with null protocol, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
              }
            }
          }

    if (v61) {
      free(v61);
    }
    goto LABEL_37;
  }

  uint64_t v31 = nw_context_copy_registered_endpoint_internal(v30, v27, 0);

  if (gLogDatapath)
  {
    __nwlog_obj();
    BOOL loga = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG))
    {
      int v71 = *(void *)(a3 + 16);
      *(_DWORD *)buf = 136448002;
      id v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      BOOL v102 = 2112;
      id v103 = v95;
      os_log_type_t v104 = 2048;
      id v105 = a3;
      os_log_type_t v106 = 2080;
      unint64_t v107 = v71;
      id v108 = 2112;
      os_log_type_t v109 = (os_log_s *)v27;
      os_log_type_t v110 = 2048;
      BOOL v111 = v27;
      os_log_type_t v112 = 2112;
      id v113 = v31;
      id v114 = 2048;
      os_log_type_t v115 = v31;
      _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s replacing unregistered endpoint %@ (%p) with endpoint %@ (%p)",  buf,  0x52u);
    }
  }

LABEL_29:
  if (!nw_endpoint_is_equal(v31, v23, 31LL))
  {
    os_log_type_t v34 = nw_endpoint_edge_create(v23, *(__int128 **)(a3 + 16), 1);
    nw_endpoint_add_edge(v31, v34);
    if (gLogDatapath)
    {
      __nwlog_obj();
      char v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v75 = *(void *)(a3 + 16);
        *(_DWORD *)buf = 136447490;
        id v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
        BOOL v102 = 2112;
        id v103 = v95;
        os_log_type_t v104 = 2048;
        id v105 = a3;
        os_log_type_t v106 = 2080;
        unint64_t v107 = v75;
        id v108 = 2112;
        os_log_type_t v109 = (os_log_s *)v31;
        os_log_type_t v110 = 2112;
        BOOL v111 = v23;
        _os_log_impl( &dword_181A5C000,  v74,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s added edge from endpoint %@ to endpoint %@",  buf,  0x3Eu);
      }
    }

    goto LABEL_35;
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    os_log_type_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v34, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v35 = *(void *)(a3 + 16);
      *(_DWORD *)buf = 136447490;
      id v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      BOOL v102 = 2112;
      id v103 = v95;
      os_log_type_t v104 = 2048;
      id v105 = a3;
      os_log_type_t v106 = 2080;
      unint64_t v107 = v35;
      id v108 = 2112;
      os_log_type_t v109 = (os_log_s *)v31;
      os_log_type_t v110 = 2112;
      BOOL v111 = v23;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v34,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s source and destination endpoints (%@ -> %@) are the same, skipping",  buf,  0x3Eu);
    }

                char v137 = *((void *)v127 + 22);
                if (!v137)
                {
                  v138 = nw_array_create();
                  os_log_type_t v140 = (void *)*((void *)v127 + 22);
                  char v139 = (uint64_t *)(v127 + 176);
                  *char v139 = v138;

                  char v137 = *v139;
                  BOOL v127 = v274;
                  os_log_type_t v128 = (NWConcrete_nw_resolver_service *)object;
                }

                nw_array_append(v137, v128);
                if ((v127[346] & 0x20) != 0)
                {
LABEL_188:
                  int v147 = *((unsigned __int8 *)v128 + 48);
                  if ((v147 & 2) == 0) {
                    goto LABEL_195;
                  }
                  port = v128->port;
                  v149 = v274;
                  if (port)
                  {
                    nw_endpoint_t v150 = (v147 >> 2) & 1;
                    id v151 = nw_array_create();
                    uint64_t v152 = (unsigned __int8 *)v149[18];
                    *(void *)id v299 = MEMORY[0x1895F87A8];
                    *(void *)&v299[8] = 3221225472LL;
                    *(void *)&v299[16] = ___ZL25nw_resolver_apply_serviceP22NWConcrete_nw_resolvertbt_block_invoke;
                    *(void *)&v299[24] = &unk_189BB6BC8;
                    uint64_t v303 = (v147 & 4) != 0;
                    os_log_type_t v301 = port;
                    uint64_t v153 = (id)v151;
                    *(void *)&v299[32] = v153;
                    v302 = port;
                    uint64_t v300 = v149;
                    nw_array_apply(v152, (uint64_t)v299);
                    if (v153 && v153[3] != v153[2])
                    {
                      *(void *)os_log_type_t v298 = 0LL;
                      *(void *)&v298[8] = v298;
                      *(void *)&v298[16] = 0x2020000000LL;
                      v298[24] = 0;
                      *(void *)os_log_type_t type = 0LL;
                      os_log_type_t v292 = type;
                      v293 = 0x3032000000LL;
                      os_log_type_t v294 = __Block_byref_object_copy__5627;
                      id v295 = __Block_byref_object_dispose__5628;
                      os_log_type_t v296 = nw_array_create();
                      int v154 = (unsigned __int8 *)v149[18];
                      *(void *)&buf[0].sa_len = MEMORY[0x1895F87A8];
                      *(void *)&buf[0].sa_data[6] = 3221225472LL;
                      *(void *)&buf[1].sa_len = ___ZL25nw_resolver_apply_serviceP22NWConcrete_nw_resolvertbt_block_invoke_2;
                      *(void *)&buf[1].sa_data[6] = &unk_189BB6BF0;
                      *(_WORD *)&buf[3].sa_data[6] = port;
                      *(void *)&buf[2].sa_data[6] = v298;
                      *(void *)&buf[3].sa_len = type;
                      *(void *)&buf[2].sa_len = v153;
                      buf[3].sa_data[8] = v150;
                      nw_array_apply(v154, (uint64_t)buf);
                      objc_storeStrong(v149 + 18, *((id *)v292 + 5));

                      _Block_object_dispose(type, 8);
                      _Block_object_dispose(v298, 8);
                    }

LABEL_194:
                    os_log_type_t v128 = (NWConcrete_nw_resolver_service *)object;
LABEL_195:
                    BOOL v155 = v128->alternative_origin;
                    *(void *)id v299 = MEMORY[0x1895F87A8];
                    *(void *)&v299[8] = 3221225472LL;
                    *(void *)&v299[16] = ___ZL34nw_resolver_process_service_resultP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_servicePU38objcproto27OS_dnssd_getaddrinfo_result8NSObject_block_invoke;
                    *(void *)&v299[24] = &unk_189BB6B78;
                    int v156 = v274;
                    *(void *)&v299[32] = v156;
                    v157 = v155;
                    uint64_t v300 = v157;
                    dnssd_getaddrinfo_result_enumerate_alpn_values();
                    if (v157) {
                      nw_resolver_update_client_alternative(v156, v157, 0LL);
                    }
                    *(void *)os_log_type_t type = 0LL;
                    os_log_type_t v292 = type;
                    v293 = 0x2020000000LL;
                    LOBYTE(v294) = 0;
                    *(void *)&buf[0].sa_len = MEMORY[0x1895F87A8];
                    *(void *)&buf[0].sa_data[6] = 3221225472LL;
                    *(void *)&buf[1].sa_len = ___ZL34nw_resolver_process_service_resultP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_servicePU38objcproto27OS_dnssd_getaddrinfo_result8NSObject_block_invoke_216;
                    *(void *)&buf[1].sa_data[6] = &unk_189BB6BA0;
                    v158 = v128;
                    *(void *)&buf[2].sa_len = v158;
                    nw_endpoint_t v159 = v156;
                    *(void *)&buf[2].sa_data[6] = v159;
                    *(void *)&buf[3].sa_len = v271;
                    *(void *)&buf[3].sa_data[6] = type;
                    dnssd_getaddrinfo_result_enumerate_service_address_hints();
                    doh_uri = dnssd_getaddrinfo_result_get_doh_uri();
                    if (!doh_uri)
                    {
LABEL_214:
                      if (*((_BYTE *)v292 + 24) || (*((_BYTE *)v128 + 48) & 2) != 0) {
                        goto LABEL_304;
                      }
                      if ((v274[346] & 0x20) != 0)
                      {
LABEL_303:
                        nw_resolver_create_dns_getaddrinfo_locked(v159, v158);
LABEL_304:

                        _Block_object_dispose(type, 8);
                        os_log_type_t v128 = v158;
                        goto LABEL_308;
                      }

                      if (*((_BYTE *)v159 + 256))
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        nw_endpoint_t v167 = (os_log_s *)(id)gconnectionLogObj;
                        if (!os_log_type_enabled(v167, OS_LOG_TYPE_INFO)) {
                          goto LABEL_302;
                        }
                        *(_DWORD *)os_log_type_t v298 = 136446722;
                        *(void *)&v298[4] = "nw_resolver_process_service_result";
                        *(_WORD *)&v298[12] = 2082;
                        *(void *)&v298[14] = (char *)v159 + 256;
                        *(_WORD *)&v298[22] = 2114;
                        *(void *)&v298[24] = v158;
                        v168 = v167;
                        id v169 = "%{public}s [C%{public}s] Starting new gai query for %{public}@";
                        v170 = 32;
                      }

                      else
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        nw_endpoint_t v167 = (os_log_s *)(id)gLogObj;
                        if (!os_log_type_enabled(v167, OS_LOG_TYPE_INFO))
                        {
LABEL_302:

                          goto LABEL_303;
                        }

                        id v205 = *((_DWORD *)v159 + 85);
                        *(_DWORD *)os_log_type_t v298 = 136446722;
                        *(void *)&v298[4] = "nw_resolver_process_service_result";
                        *(_WORD *)&v298[12] = 1024;
                        *(_DWORD *)&v298[14] = v205;
                        *(_WORD *)&v298[18] = 2114;
                        *(void *)&v298[20] = v158;
                        v168 = v167;
                        id v169 = "%{public}s [R%u] Starting new gai query for %{public}@";
                        v170 = 28;
                      }

                      _os_log_impl(&dword_181A5C000, v168, OS_LOG_TYPE_INFO, v169, v298, v170);
                      goto LABEL_302;
                    }

                    if ((v274[346] & 0x20) != 0)
                    {
LABEL_213:
                      v274[347] |= 8u;
                      goto LABEL_214;
                    }

                    if (*((_BYTE *)v159 + 256))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      id v161 = (os_log_s *)(id)gconnectionLogObj;
                      if (!os_log_type_enabled(v161, OS_LOG_TYPE_INFO)) {
                        goto LABEL_212;
                      }
                      *(_DWORD *)os_log_type_t v298 = 136446723;
                      *(void *)&v298[4] = "nw_resolver_process_service_result";
                      *(_WORD *)&v298[12] = 2082;
                      *(void *)&v298[14] = (char *)v159 + 256;
                      *(_WORD *)&v298[22] = 2085;
                      *(void *)&v298[24] = doh_uri;
                      char v162 = v161;
                      int v163 = "%{public}s [C%{public}s] DoH URI: %{sensitive}s";
                      os_log_type_t v164 = 32;
                    }

                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      id v161 = (os_log_s *)(id)gLogObj;
                      if (!os_log_type_enabled(v161, OS_LOG_TYPE_INFO))
                      {
LABEL_212:

                        os_log_type_t v128 = (NWConcrete_nw_resolver_service *)object;
                        goto LABEL_213;
                      }

                      id v166 = *((_DWORD *)v159 + 85);
                      *(_DWORD *)os_log_type_t v298 = 136446723;
                      *(void *)&v298[4] = "nw_resolver_process_service_result";
                      *(_WORD *)&v298[12] = 1024;
                      *(_DWORD *)&v298[14] = v166;
                      *(_WORD *)&v298[18] = 2085;
                      *(void *)&v298[20] = doh_uri;
                      char v162 = v161;
                      int v163 = "%{public}s [R%u] DoH URI: %{sensitive}s";
                      os_log_type_t v164 = 28;
                    }

                    _os_log_impl(&dword_181A5C000, v162, OS_LOG_TYPE_INFO, v163, v298, v164);
                    goto LABEL_212;
                  }

                  __nwlog_obj();
                  v243 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(void *)&buf[0].sa_data[2] = "nw_resolver_apply_service";
                  v244 = (char *)_os_log_send_and_compose_impl();

                  v299[0] = 16;
                  type[0] = OS_LOG_TYPE_DEFAULT;
                  if (__nwlog_fault(v244, v299, type))
                  {
                    if (v299[0] == 17)
                    {
                      __nwlog_obj();
                      os_log_type_t v245 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      int v246 = v299[0];
                      if (os_log_type_enabled(v245, (os_log_type_t)v299[0]))
                      {
                        *(_DWORD *)&buf[0].sa_len = 136446210;
                        *(void *)&buf[0].sa_data[2] = "nw_resolver_apply_service";
                        _os_log_impl( &dword_181A5C000,  v245,  v246,  "%{public}s called with null (priority != 0)",  &buf[0].sa_len,  0xCu);
                      }
                    }

                    else if (type[0])
                    {
                      uint64_t v260 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      os_log_type_t v245 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      int v261 = v299[0];
                      char v262 = os_log_type_enabled(v245, (os_log_type_t)v299[0]);
                      if (v260)
                      {
                        if (v262)
                        {
                          *(_DWORD *)&buf[0].sa_len = 136446466;
                          *(void *)&buf[0].sa_data[2] = "nw_resolver_apply_service";
                          *(_WORD *)&buf[0].sa_data[10] = 2082;
                          *(void *)&buf[0].sa_data[12] = v260;
                          _os_log_impl( &dword_181A5C000,  v245,  v261,  "%{public}s called with null (priority != 0), dumping backtrace:%{public}s",  &buf[0].sa_len,  0x16u);
                        }

                        free(v260);
                        goto LABEL_451;
                      }

                      if (v262)
                      {
                        *(_DWORD *)&buf[0].sa_len = 136446210;
                        *(void *)&buf[0].sa_data[2] = "nw_resolver_apply_service";
                        _os_log_impl( &dword_181A5C000,  v245,  v261,  "%{public}s called with null (priority != 0), no backtrace",  &buf[0].sa_len,  0xCu);
                      }
                    }

                    else
                    {
                      __nwlog_obj();
                      os_log_type_t v245 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      v265 = v299[0];
                      if (os_log_type_enabled(v245, (os_log_type_t)v299[0]))
                      {
                        *(_DWORD *)&buf[0].sa_len = 136446210;
                        *(void *)&buf[0].sa_data[2] = "nw_resolver_apply_service";
                        _os_log_impl( &dword_181A5C000,  v245,  v265,  "%{public}s called with null (priority != 0), backtrace limit exceeded",  &buf[0].sa_len,  0xCu);
                      }
                    }
                  }

    goto LABEL_171;
  }

  char v7 = (void *)*((void *)v5 + 15);
  if (v7)
  {
    os_log_type_t v8 = v7;
    char v9 = v8;
    if (((_BYTE)v8[17] & 8) == 0) {
      dispatch_assert_queue_V2(v8[1]);
    }
  }

  if ((v5[405] & 0x80000000) == 0 && gLogDatapath)
  {
    __nwlog_obj();
    id v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&_OWORD buf[4] = "nw_protocol_instance_report_done";
      id v108 = 2082;
      os_log_type_t v109 = v5 + 407;
      os_log_type_t v110 = 2080;
      BOOL v111 = " ";
      os_log_type_t v112 = 2048;
      id v113 = a2;
      _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReporting flow %llx done",  buf,  0x2Au);
    }
  }

  if (*(_DWORD *)(*((void *)v5 + 1) + 64LL) != 3)
  {
    if (a2 == -1LL)
    {
      if (!v6) {
        goto LABEL_52;
      }
      nw_endpoint_t v13 = (const char *)*((void *)v5 - 6);
      if (!v13) {
        goto LABEL_52;
      }
      nw_endpoint_t v14 = *((void *)v13 + 3);
      if (!v14 || !*(void *)(v14 + 56)) {
        goto LABEL_52;
      }
      os_log_type_t v15 = (unsigned int *)v6;
      uint64_t v16 = v15[3];

      __int16 v17 = (void *)*((void *)v13 + 5);
      if (v17 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v28 = *((void *)v13 + 11);
        if (v28) {
          *((void *)v13 + 11) = v28 + 1;
        }
        uint64_t v18 = -1;
      }

      else
      {
        uint64_t v18 = 0;
      }

      *(void *)os_log_type_t type = v13;
      os_log_type_t v106 = v18;
      BOOL v29 = (void *)*((void *)v5 - 7);
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v31 = *((void *)v5 - 1);
        if (v31) {
          *((void *)v5 - 1) = v31 + 1;
        }
        char v30 = -1;
      }

      else
      {
        char v30 = 0;
      }

      id v103 = v5 - 96;
      os_log_type_t v104 = v30;
      uint64_t v32 = *((void *)v13 + 3);
      if (v32)
      {
        os_log_type_t v33 = *(void (**)(const char *, char *, uint64_t))(v32 + 56);
        if (v33)
        {
          v33(v13, v5 - 96, v16);
LABEL_50:
          if (v29 != &nw_protocol_ref_counted_handle)
          {
            if (v17 != &nw_protocol_ref_counted_handle) {
              goto LABEL_52;
            }
LABEL_71:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            os_log_type_t v34 = (void *)*((void *)v5 - 6);
            if (!v34) {
              goto LABEL_104;
            }
LABEL_53:
            uint64_t v35 = v34[3];
            if (!v35) {
              goto LABEL_104;
            }
            os_log_type_t v36 = *(void (**)(void *, char *))(v35 + 48);
            if (!v36) {
              goto LABEL_104;
            }
            uint64_t v37 = (void *)v34[5];
            if (v37 == &nw_protocol_ref_counted_handle)
            {
              int v39 = v34[11];
              if (v39) {
                v34[11] = v39 + 1;
              }
              os_log_type_t v38 = -1;
            }

            else
            {
              os_log_type_t v38 = 0;
            }

            *(void *)buf = v34;
            buf[8] = v38;
            BOOL v40 = (void *)*((void *)v5 - 7);
            if (v40 == &nw_protocol_ref_counted_handle)
            {
              BOOL v42 = *((void *)v5 - 1);
              if (v42) {
                *((void *)v5 - 1) = v42 + 1;
              }
              os_log_type_t v41 = -1;
            }

            else
            {
              os_log_type_t v41 = 0;
            }

            *(void *)os_log_type_t type = v5 - 96;
            os_log_type_t v106 = v41;
            v36(v34, v5 - 96);
            if (v40 == &nw_protocol_ref_counted_handle)
            {
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              if (v37 != &nw_protocol_ref_counted_handle) {
                goto LABEL_104;
              }
            }

            else if (v37 != &nw_protocol_ref_counted_handle)
            {
              goto LABEL_104;
            }

    free(v72);
    goto LABEL_171;
  }

  os_log_type_t v8 = nw_endpoint_handler_copy_flow(v6);
  char v9 = v8;
  if (!v8)
  {
    __nwlog_obj();
    __int16 v80 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v127 = "nw_flow_replay_add_candidate_output_handler";
    id v81 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v124 = 0;
    if (__nwlog_fault(v81, &type, &v124))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v83 = type;
        if (os_log_type_enabled(v82, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v127 = "nw_flow_replay_add_candidate_output_handler";
          _os_log_impl(&dword_181A5C000, v82, v83, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v124)
      {
        int v94 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v95 = type;
        BOOL v96 = os_log_type_enabled(v82, type);
        if (v94)
        {
          if (v96)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v127 = "nw_flow_replay_add_candidate_output_handler";
            os_log_type_t v128 = 2082;
            os_log_type_t v129 = v94;
            _os_log_impl( &dword_181A5C000,  v82,  v95,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v94);
          goto LABEL_194;
        }

        if (v96)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v127 = "nw_flow_replay_add_candidate_output_handler";
          _os_log_impl(&dword_181A5C000, v82, v95, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v115 = type;
        if (os_log_type_enabled(v82, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v127 = "nw_flow_replay_add_candidate_output_handler";
          _os_log_impl( &dword_181A5C000,  v82,  v115,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        if (!v43)
        {
LABEL_172:
          uint64_t v69 = 0LL;
LABEL_203:

          goto LABEL_204;
        }

          free(v94);
          goto LABEL_55;
        }

        if (v104)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&_OWORD buf[4] = "nw_http_connection_metadata_set_certificate_added_handler";
          _os_log_impl( &dword_181A5C000,  v95,  v103,  "%{public}s metadata must be http_connection, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v106 = type[0];
        if (os_log_type_enabled(v95, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&_OWORD buf[4] = "nw_http_connection_metadata_set_certificate_added_handler";
          _os_log_impl( &dword_181A5C000,  v95,  v106,  "%{public}s metadata must be http_connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v93 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&_OWORD buf[4] = "nw_http_connection_metadata_set_certificate_added_handler";
      int v94 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      id v114 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v96 = type[0];
        if (os_log_type_enabled(v95, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&_OWORD buf[4] = "nw_http_connection_metadata_set_certificate_added_handler";
          _os_log_impl(&dword_181A5C000, v95, v96, "%{public}s called with null metadata", buf, 0xCu);
        }
      }

      else if (v114)
      {
        id v99 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v100 = type[0];
        id v101 = os_log_type_enabled(v95, type[0]);
        if (v99)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&_OWORD buf[4] = "nw_http_connection_metadata_set_certificate_added_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v99;
            _os_log_impl( &dword_181A5C000,  v95,  v100,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v99);
LABEL_169:
          if (!v94) {
            goto LABEL_55;
          }
          goto LABEL_170;
        }

        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&_OWORD buf[4] = "nw_http_connection_metadata_set_certificate_added_handler";
          _os_log_impl(&dword_181A5C000, v95, v100, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v105 = type[0];
        if (os_log_type_enabled(v95, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&_OWORD buf[4] = "nw_http_connection_metadata_set_certificate_added_handler";
          _os_log_impl( &dword_181A5C000,  v95,  v105,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_169;
  }

  if (v17) {
    goto LABEL_33;
  }
  if ((*(_BYTE *)(v6 + 294) & 4) != 0) {
    return 0LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v19 = gLogObj;
  result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
  if ((_DWORD)result)
  {
    *(_DWORD *)buf = 136446722;
    *(void *)&_OWORD buf[4] = "nw_protocol_http_client_bottom_override_http_messaging";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v6 + 208;
    *(_WORD *)&buf[22] = 2080;
    int v116 = " ";
    os_log_type_t v8 = "%{public}s %{public}s%spassed messaging protocol invalid for overriding";
    char v9 = (os_log_s *)v19;
    os_log_type_t v10 = OS_LOG_TYPE_INFO;
    goto LABEL_29;
  }

  return result;
}

      if (v97) {
        free(v97);
      }
      os_log_type_t v109 = *(void *)(v93 + 112);
      os_log_type_t v110 = *(void **)(v93 + 120);
      if (v109)
      {
        *(void *)(v109 + 120) = v110;
        os_log_type_t v110 = *(void **)(v93 + 120);
      }

      else
      {
        *(void *)(v173 + 336) = v110;
      }

      *os_log_type_t v110 = v109;
      *(void *)(v93 + 112) = 0LL;
      *(void *)(v93 + 120) = 0LL;
      BOOL v111 = v182[3];
      char v5 = &qword_18C45F000;
      if (v111)
      {
        if ((*(_BYTE *)(v111 + 276) & 0x10) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v112 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            id v113 = *(void *)(v111 + 88);
            if (v113) {
              id v114 = *(_DWORD *)(v113 + 460);
            }
            else {
              id v114 = -1;
            }
            os_log_type_t v115 = *(void *)(v111 + 64);
            *(_DWORD *)buf = 136447490;
            *(void *)&_OWORD buf[4] = "nw_webtransport_stream_destroy";
            char v188 = 2082;
            nw_endpoint_t v189 = (const char *)(v111 + 192);
            v190 = 2080;
            nw_endpoint_t v191 = (uint64_t)" ";
            v192 = 1024;
            *(_DWORD *)id v193 = v114;
            *(_WORD *)&v193[4] = 2048;
            *(void *)&v193[6] = v115;
            *(_WORD *)&v193[14] = 2048;
            *(void *)&v193[16] = v111;
            _os_log_impl( &dword_181A5C000,  v112,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p",  buf,  0x3Au);
          }
        }

        if (*(void *)(v111 + 72))
        {
          if ((*(_BYTE *)(v111 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v116 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              BOOL v117 = *(void *)(v111 + 88);
              if (v117) {
                id v118 = *(_DWORD *)(v117 + 460);
              }
              else {
                id v118 = -1;
              }
              os_log_type_t v119 = *(void *)(v111 + 64);
              *(_DWORD *)buf = 136447234;
              *(void *)&_OWORD buf[4] = "nw_webtransport_stream_destroy";
              char v188 = 2082;
              nw_endpoint_t v189 = (const char *)(v111 + 192);
              v190 = 2080;
              nw_endpoint_t v191 = (uint64_t)" ";
              v192 = 1024;
              *(_DWORD *)id v193 = v118;
              *(_WORD *)&v193[4] = 2048;
              *(void *)&v193[6] = v119;
              _os_log_impl( &dword_181A5C000,  v116,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying",  buf,  0x30u);
            }
          }
        }

        BOOL v120 = *(void *)(v111 + 72);
        if (v120)
        {
          do
          {
            os_log_type_t v121 = *(void *)(v120 + 32);
            nw_frame_finalize(v120);
            BOOL v120 = v121;
          }

          while (v121);
        }

        (*(void (**)(void, void))(*(void *)(v111 + 176) + 16LL))(*(void *)(v111 + 176), 0LL);
        os_log_type_t v122 = *(const void **)(v111 + 176);
        if (v122)
        {
          _Block_release(v122);
          *(void *)(v111 + 176) = 0LL;
        }

        if ((*(_BYTE *)(v111 + 168) & 1) != 0)
        {
          BOOL v123 = *(void **)(v111 + 160);
          if (v123) {
            os_release(v123);
          }
        }

        *(void *)(v111 + 160) = 0LL;
        if ((*(_BYTE *)(v111 + 152) & 1) != 0)
        {
          os_log_type_t v124 = *(void **)(v111 + 144);
          if (v124) {
            os_release(v124);
          }
        }

        *(void *)(v111 + 144) = 0LL;
        if ((*(_BYTE *)(v111 + 136) & 1) != 0)
        {
          id v125 = *(void **)(v111 + 128);
          if (v125) {
            os_release(v125);
          }
        }

                    if (nw_endpoint_handler_get_minimize_logging(v88))
                    {
                      if ((nw_endpoint_handler_get_logging_disabled(v88) & 1) != 0)
                      {
LABEL_177:
                        nw_endpoint_handler_handle_failure(v88);
                        if (v20 != v280) {
                          goto LABEL_178;
                        }
LABEL_187:
                        v176 = 3;
                        goto LABEL_188;
                      }

                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v168 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
                      {
                        int v211 = nw_endpoint_handler_get_id_string(v88);
                        char v212 = nw_endpoint_handler_dry_run_string(v88);
                        id v213 = nw_endpoint_handler_copy_endpoint(v88);
                        id v214 = nw_endpoint_get_logging_description(v213);
                        uint64_t v215 = nw_endpoint_handler_state_string(v88);
                        nw_endpoint_t v216 = nw_endpoint_handler_mode_string(v88);
                        id v217 = nw_endpoint_handler_copy_current_path(v88);
                        *(_DWORD *)buf = 136447746;
                        v286 = "nw_endpoint_fallback_receive_report";
                        nw_endpoint_t v287 = 2082;
                        v288 = (void *)v211;
                        uint64_t v289 = 2082;
                        v290 = v212;
                        id v291 = 2082;
                        os_log_type_t v292 = v214;
                        v293 = 2082;
                        os_log_type_t v294 = v215;
                        id v295 = 2082;
                        os_log_type_t v296 = v216;
                        v297 = 2114;
                        os_log_type_t v298 = v217;
                        _os_log_impl( &dword_181A5C000,  v168,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed",  buf,  0x48u);
                      }
                    }

                    else
                    {
                      id v166 = v88;
                      nw_endpoint_t v167 = (*((_BYTE *)v166 + 268) & 0x20) == 0;

                      if (!v167) {
                        goto LABEL_177;
                      }
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v168 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v168, OS_LOG_TYPE_INFO))
                      {
                        id v169 = nw_endpoint_handler_get_id_string(v166);
                        v170 = nw_endpoint_handler_dry_run_string(v166);
                        id v171 = nw_endpoint_handler_copy_endpoint(v166);
                        int v172 = nw_endpoint_get_logging_description(v171);
                        uint64_t v173 = nw_endpoint_handler_state_string(v166);
                        nw_endpoint_t v174 = nw_endpoint_handler_mode_string(v166);
                        id v175 = nw_endpoint_handler_copy_current_path(v166);
                        *(_DWORD *)buf = 136447746;
                        v286 = "nw_endpoint_fallback_receive_report";
                        nw_endpoint_t v287 = 2082;
                        v288 = (void *)v169;
                        uint64_t v289 = 2082;
                        v290 = v170;
                        id v291 = 2082;
                        os_log_type_t v292 = v172;
                        v293 = 2082;
                        os_log_type_t v294 = v173;
                        id v295 = 2082;
                        os_log_type_t v296 = v174;
                        v297 = 2114;
                        os_log_type_t v298 = v175;
                        _os_log_impl( &dword_181A5C000,  v168,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed",  buf,  0x48u);
                      }
                    }

                    goto LABEL_177;
                  }

                  if ((*((_BYTE *)v279 + 109) & 4) != 0) {
                    goto LABEL_170;
                  }
                  if ((*((_BYTE *)v279 + 108) & 1) == 0 || !*((void *)v279 + 5))
                  {
                    nw_endpoint_fallback_start_fallback_child(v88);
                    goto LABEL_187;
                  }

                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v88);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v88);
                  if (minimize_logging)
                  {
                    if ((logging_disabled & 1) != 0) {
                      goto LABEL_169;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v158 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
                    {
                      v236 = nw_endpoint_handler_get_id_string(v88);
                      v237 = nw_endpoint_handler_dry_run_string(v88);
                      id v238 = nw_endpoint_handler_copy_endpoint(v88);
                      v239 = nw_endpoint_get_logging_description(v238);
                      id v240 = nw_endpoint_handler_state_string(v88);
                      id v241 = nw_endpoint_handler_mode_string(v88);
                      id v242 = nw_endpoint_handler_copy_current_path(v88);
                      *(_DWORD *)buf = 136447746;
                      v286 = "nw_endpoint_fallback_receive_report";
                      nw_endpoint_t v287 = 2082;
                      v288 = (void *)v236;
                      uint64_t v289 = 2082;
                      v290 = v237;
                      id v291 = 2082;
                      os_log_type_t v292 = v239;
                      v293 = 2082;
                      os_log_type_t v294 = v240;
                      id v295 = 2082;
                      os_log_type_t v296 = v241;
                      v297 = 2114;
                      os_log_type_t v298 = v242;
                      _os_log_impl( &dword_181A5C000,  v158,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received ECANCE LED from primary child, cancelling race",  buf,  0x48u);
                    }
                  }

                  else
                  {
                    if ((logging_disabled & 1) != 0)
                    {
LABEL_169:
                      nw_endpoint_handler_cancel(*((void **)v279 + 5), 0LL, 1);
                      goto LABEL_187;
                    }

                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v158 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v158, OS_LOG_TYPE_INFO))
                    {
                      nw_endpoint_t v159 = nw_endpoint_handler_get_id_string(v88);
                      v160 = nw_endpoint_handler_dry_run_string(v88);
                      id v161 = nw_endpoint_handler_copy_endpoint(v88);
                      char v162 = nw_endpoint_get_logging_description(v161);
                      int v163 = nw_endpoint_handler_state_string(v88);
                      os_log_type_t v164 = nw_endpoint_handler_mode_string(v88);
                      nw_endpoint_t v165 = nw_endpoint_handler_copy_current_path(v88);
                      *(_DWORD *)buf = 136447746;
                      v286 = "nw_endpoint_fallback_receive_report";
                      nw_endpoint_t v287 = 2082;
                      v288 = (void *)v159;
                      uint64_t v289 = 2082;
                      v290 = v160;
                      id v291 = 2082;
                      os_log_type_t v292 = v162;
                      v293 = 2082;
                      os_log_type_t v294 = v163;
                      id v295 = 2082;
                      os_log_type_t v296 = v164;
                      v297 = 2114;
                      os_log_type_t v298 = v165;
                      _os_log_impl( &dword_181A5C000,  v158,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received ECANCE LED from primary child, cancelling race",  buf,  0x48u);
                    }
                  }

                  goto LABEL_169;
                }

                if (v83 || !v91 || (*((_BYTE *)v279 + 108) & 0x42) != 2 || !*((void *)v279 + 9)) {
                  goto LABEL_189;
                }
                os_log_type_t v98 = nw_endpoint_handler_get_minimize_logging(v88);
                id v99 = nw_endpoint_handler_get_logging_disabled(v88);
                if (v98)
                {
                  if ((v99 & 1) != 0) {
                    goto LABEL_119;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  BOOL v100 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
                  {
                    nw_endpoint_t v228 = nw_endpoint_handler_get_id_string(v88);
                    v229 = nw_endpoint_handler_dry_run_string(v88);
                    uint64_t v230 = nw_endpoint_handler_copy_endpoint(v88);
                    v231 = nw_endpoint_get_logging_description(v230);
                    id v232 = nw_endpoint_handler_state_string(v88);
                    int v233 = nw_endpoint_handler_mode_string(v88);
                    nw_endpoint_t v234 = nw_endpoint_handler_copy_current_path(v88);
                    id v235 = *((void *)v279 + 3) / 0xF4240uLL;
                    *(_DWORD *)buf = 136448002;
                    v286 = "nw_endpoint_fallback_receive_report";
                    nw_endpoint_t v287 = 2082;
                    v288 = (void *)v228;
                    uint64_t v289 = 2082;
                    v290 = v229;
                    id v291 = 2082;
                    os_log_type_t v292 = v231;
                    v293 = 2082;
                    os_log_type_t v294 = v232;
                    id v295 = 2082;
                    os_log_type_t v296 = v233;
                    v297 = 2114;
                    os_log_type_t v298 = v234;
                    id v299 = 2048;
                    uint64_t v300 = v235;
                    _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] pushing out fallb ack endpoint start by %llums",  buf,  0x52u);
                  }
                }

                else
                {
                  if ((v99 & 1) != 0)
                  {
LABEL_119:
                    os_log_type_t v109 = *((void *)v279 + 9);
                    os_log_type_t v110 = dispatch_time(0x8000000000000000LL, *((void *)v279 + 3));
                    nw_queue_set_timer_values(v109, v110, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
LABEL_189:

LABEL_190:
                    id v22 = 1LL;
                    __int16 v21 = v278;
                    goto LABEL_191;
                  }

                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  BOOL v100 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_INFO))
                  {
                    id v101 = nw_endpoint_handler_get_id_string(v88);
                    BOOL v102 = nw_endpoint_handler_dry_run_string(v88);
                    id v103 = nw_endpoint_handler_copy_endpoint(v88);
                    os_log_type_t v104 = nw_endpoint_get_logging_description(v103);
                    id v105 = nw_endpoint_handler_state_string(v88);
                    os_log_type_t v106 = nw_endpoint_handler_mode_string(v88);
                    unint64_t v107 = nw_endpoint_handler_copy_current_path(v88);
                    id v108 = *((void *)v279 + 3) / 0xF4240uLL;
                    *(_DWORD *)buf = 136448002;
                    v286 = "nw_endpoint_fallback_receive_report";
                    nw_endpoint_t v287 = 2082;
                    v288 = (void *)v101;
                    uint64_t v289 = 2082;
                    v290 = v102;
                    id v291 = 2082;
                    os_log_type_t v292 = v104;
                    v293 = 2082;
                    os_log_type_t v294 = v105;
                    id v295 = 2082;
                    os_log_type_t v296 = v106;
                    v297 = 2114;
                    os_log_type_t v298 = v107;
                    id v299 = 2048;
                    uint64_t v300 = v108;
                    _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] pushing out fallb ack endpoint start by %llums",  buf,  0x52u);
                  }
                }

                goto LABEL_119;
              }

              BOOL v96 = *((void *)v279 + 9);
              if (v96)
              {
                nw_queue_cancel_source(v96, v89);
                *((void *)v279 + 9) = 0LL;
              }

              if (!*v82)
              {
                if (v20 == v280)
                {
                  *((_DWORD *)v279 + 12) = 1;
                  BOOL v111 = (void *)*((void *)v279 + 5);
                  if (v111) {
                    nw_endpoint_handler_cancel(v111, 0LL, 0);
                  }
                  if (a3 == 2) {
                    nw_endpoint_fallback_start_post_transport_timer(v88);
                  }
                }

                else
                {
                  *((_DWORD *)v279 + 12) = 2;
                  nw_endpoint_t v97 = (void *)*((void *)v279 + 4);
                  if (v97) {
                    nw_endpoint_handler_cancel(v97, 0LL, 0);
                  }
                  if (*((_DWORD *)v279 + 26) == 2) {
                    nw_endpoint_fallback_start_usage_cap_timer(v88);
                  }
                }

                if (!nw_endpoint_handler_get_minimize_logging(v88))
                {
                  os_log_type_t v112 = v88;
                  id v113 = (*((_BYTE *)v112 + 268) & 0x20) == 0;

                  if (!v113) {
                    goto LABEL_134;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  id v114 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v114, OS_LOG_TYPE_INFO))
                  {
                    int v261 = v114;
                    v272 = a4;
                    os_log_type_t v115 = nw_endpoint_handler_get_id_string(v112);
                    int v116 = nw_endpoint_handler_dry_run_string(v112);
                    BOOL v117 = nw_endpoint_handler_copy_endpoint(v112);
                    id v118 = nw_endpoint_get_logging_description(v117);
                    os_log_type_t v119 = nw_endpoint_handler_state_string(v112);
                    BOOL v120 = nw_endpoint_handler_mode_string(v112);
                    os_log_type_t v121 = nw_endpoint_handler_copy_current_path(v112);
                    os_log_type_t v122 = v121;
                    BOOL v123 = *((void *)v279 + 7);
                    os_log_type_t v124 = (const char *)*((void *)v279 + 8);
                    if (v20 == v280) {
                      id v125 = (const char *)*((void *)v279 + 7);
                    }
                    else {
                      id v125 = (const char *)*((void *)v279 + 8);
                    }
                    *(_DWORD *)buf = 136448514;
                    v286 = "nw_endpoint_fallback_receive_report";
                    nw_endpoint_t v287 = 2082;
                    v288 = (void *)v115;
                    uint64_t v289 = 2082;
                    v290 = v116;
                    id v291 = 2082;
                    os_log_type_t v292 = v118;
                    v293 = 2082;
                    os_log_type_t v294 = v119;
                    id v295 = 2082;
                    os_log_type_t v296 = v120;
                    v297 = 2114;
                    os_log_type_t v298 = v121;
                    id v299 = 2112;
                    uint64_t v300 = v123;
                    os_log_type_t v301 = 2112;
                    v302 = v124;
                    uint64_t v303 = 2112;
                    nw_endpoint_t v304 = v125;
                    _os_log_impl( &dword_181A5C000,  v261,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback complete : primary child (%@), fallback child (%@), %@ connected",  buf,  0x66u);

                    a4 = v272;
                    id v114 = v261;
                  }

                  goto LABEL_133;
                }

                if ((nw_endpoint_handler_get_logging_disabled(v88) & 1) == 0)
                {
                  v274 = a4;
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  id v114 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
                  {
                    nw_endpoint_t v264 = nw_endpoint_handler_get_id_string(v88);
                    id v218 = nw_endpoint_handler_dry_run_string(v88);
                    v219 = nw_endpoint_handler_copy_endpoint(v88);
                    BOOL v220 = nw_endpoint_get_logging_description(v219);
                    v221 = nw_endpoint_handler_state_string(v88);
                    nw_endpoint_t v222 = nw_endpoint_handler_mode_string(v88);
                    int v223 = nw_endpoint_handler_copy_current_path(v88);
                    BOOL v224 = v223;
                    v225 = *((void *)v279 + 7);
                    nw_endpoint_t v226 = (const char *)*((void *)v279 + 8);
                    if (v20 == v280) {
                      v227 = (const char *)*((void *)v279 + 7);
                    }
                    else {
                      v227 = (const char *)*((void *)v279 + 8);
                    }
                    *(_DWORD *)buf = 136448514;
                    v286 = "nw_endpoint_fallback_receive_report";
                    nw_endpoint_t v287 = 2082;
                    v288 = (void *)v264;
                    uint64_t v289 = 2082;
                    v290 = v218;
                    id v291 = 2082;
                    os_log_type_t v292 = v220;
                    v293 = 2082;
                    os_log_type_t v294 = v221;
                    id v295 = 2082;
                    os_log_type_t v296 = v222;
                    v297 = 2114;
                    os_log_type_t v298 = v223;
                    id v299 = 2112;
                    uint64_t v300 = v225;
                    os_log_type_t v301 = 2112;
                    v302 = v226;
                    uint64_t v303 = 2112;
                    nw_endpoint_t v304 = v227;
                    _os_log_impl( &dword_181A5C000,  v114,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback complete : primary child (%@), fallback child (%@), %@ connected",  buf,  0x66u);

                    a4 = v274;
                  }

      free(v43);
      goto LABEL_171;
    }

    __nwlog_obj();
    BOOL v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v95 = "nw_necp_append_tlv";
    os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v90 = OS_LOG_TYPE_ERROR;
    BOOL v89 = 0;
    if (v90 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v45 = v90;
      if (os_log_type_enabled(v44, v90))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v95 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s called with null tlv_start", buf, 0xCu);
      }
    }

    else if (v89)
    {
      __int16 v60 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v61 = v90;
      os_log_type_t v62 = os_log_type_enabled(v44, v90);
      if (v60)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v95 = "nw_necp_append_tlv";
          BOOL v96 = 2082;
          nw_endpoint_t v97 = (size_t)v60;
          _os_log_impl( &dword_181A5C000,  v44,  v61,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v60);
        goto LABEL_169;
      }

      if (v62)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v95 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v44, v61, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v77 = v90;
      if (os_log_type_enabled(v44, v90))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v95 = "nw_necp_append_tlv";
        _os_log_impl( &dword_181A5C000,  v44,  v77,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
      }
    }

        _os_log_impl(&dword_181A5C000, v72, v73, v74, buf, 0x12u);
        goto LABEL_171;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v70 = gLogObj;
      int v71 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v364 = "nw_http1_connection_send_bytes";
        id v365 = 1024;
        *(_DWORD *)v366 = v68;
        __int16 v72 = (os_log_s *)v70;
        BOOL v73 = v71;
        char v74 = "%{public}s output handler reported %u frames to write, but array is empty";
        goto LABEL_170;
      }

  if (*(_DWORD *)(v12 + 864) == 1)
  {
    if (v29)
    {
      os_log_type_t v112 = *(void *)(v12 + 488);
      if (v112) {
        nw_protocol_input_available(*(void **)(v112 + 48), v112);
      }
    }
  }

          goto LABEL_136;
        }

        if (v131 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v121 = type[0];
          if (os_log_type_enabled(v110, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            _os_log_impl( &dword_181A5C000,  v110,  v121,  "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
          }

          goto LABEL_170;
        }

        id v101 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v118 = type[0];
        os_log_type_t v119 = os_log_type_enabled(v115, (os_log_type_t)type[0]);
        if (v101)
        {
          if (v119)
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = v101;
            _os_log_impl( &dword_181A5C000,  v115,  v118,  "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
          }

          goto LABEL_126;
        }

        if (v119)
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
          _os_log_impl( &dword_181A5C000,  v115,  v118,  "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace",  (uint8_t *)buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v109 = (void *)objc_claimAutoreleasedReturnValue();
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
        nw_endpoint_t v97 = (void *)_os_log_send_and_compose_impl();

        type[0] = 16;
        nw_endpoint_t v131 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == 17)
        {
          __nwlog_obj();
          os_log_type_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v111 = type[0];
          if (os_log_type_enabled(v110, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            _os_log_impl( &dword_181A5C000,  v110,  v111,  "%{public}s called with null serviceConnector",  (uint8_t *)buf,  0xCu);
          }

          goto LABEL_170;
        }

        if (v131 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          os_log_type_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v120 = type[0];
          if (os_log_type_enabled(v110, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            _os_log_impl( &dword_181A5C000,  v110,  v120,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
          }

          goto LABEL_170;
        }

        id v114 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v116 = type[0];
        BOOL v117 = os_log_type_enabled(v115, (os_log_type_t)type[0]);
        if (v114)
        {
          if (v117)
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = v114;
            _os_log_impl( &dword_181A5C000,  v115,  v116,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
          }

          free(v114);
          goto LABEL_136;
        }

        if (v117)
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
          _os_log_impl( &dword_181A5C000,  v115,  v116,  "%{public}s called with null serviceConnector, no backtrace",  (uint8_t *)buf,  0xCu);
        }
      }

      goto LABEL_136;
    }
  }

  if (string_ptr)
  {
    if (v54 >= 2) {
      goto LABEL_51;
    }
    goto LABEL_55;
  }

  __nwlog_obj();
  BOOL v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v123, OS_LOG_TYPE_ERROR);
  LODWORD(buf[0]) = 136446210;
  *(void *)((char *)buf + 4) = "_strict_strlcpy";
  os_log_type_t v122 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v122))
  {
    free(v122);
    if (v54 >= 2)
    {
LABEL_51:
      os_log_type_t v62 = 0LL;
      while (1)
      {
        BOOL v63 = string_ptr[v62];
        v55[v62] = v63;
        if (!v63) {
          goto LABEL_56;
        }
        --v54;
        ++v62;
        if (v54 <= 1)
        {
          v55 += v62;
          break;
        }
      }
    }

    if (v46) {
      free(v46);
    }
    return 1LL;
  }

  if ((*v5 & 0x800) != 0) {
    return 0LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v32 = (os_log_s *)gLogObj;
  result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    os_log_type_t v34 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
    uint64_t v35 = *((void *)handle + 30);
    *(_DWORD *)buf = 136447234;
    *(void *)&_OWORD buf[4] = "nw_protocol_http3_stream_connect";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = handle + 636;
    *(_WORD *)&buf[22] = 2080;
    BOOL v96 = " ";
    LOWORD(v97) = 1024;
    *(_DWORD *)((char *)&v97 + 2) = v34;
    HIWORD(v97) = 2048;
    os_log_type_t v98 = v35;
    _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%llu> output_handler is NULL",  buf,  0x30u);
    return 0LL;
  }

  return result;
}

        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v144 = 0LL;
        }
LABEL_172:
        *(_BYTE *)(a1 + 60) = v144 != 0;
        goto LABEL_4;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_4;
    }
  }

              if (v138) {
                free(v138);
              }
              *((_DWORD *)v309 + 6) = -1;
              os_log_type_t v15 = MEMORY[0x1895F87A8];
            }

            BOOL v127 = 0;
            if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              os_log_type_t v164 = (os_log_s *)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                id v166 = *(_DWORD *)(v14 + 176);
                nw_endpoint_t v165 = *(_DWORD *)(v14 + 180);
                *(_DWORD *)buf = 136447234;
                uint64_t v317 = "nw_protocol_http2_get_input_frames";
                int v318 = 2082;
                uint64_t v319 = (const char *)(v14 + 191);
                char v320 = 2080;
                v321 = (uint64_t)" ";
                os_log_type_t v322 = 1024;
                *(_DWORD *)id v323 = v165;
                *(_WORD *)&v323[4] = 1024;
                *(_DWORD *)&v323[6] = v166;
                _os_log_impl( &dword_181A5C000,  v164,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> Receiving datagram capsule",  buf,  0x2Cu);
              }

              BOOL v127 = 0;
            }

            goto LABEL_175;
          }

            if (v70)
            {
              nw_endpoint_t v79 = (char *)v70;
              goto LABEL_141;
            }

LABEL_180:
          if (v85) {
            free(v85);
          }
          goto LABEL_182;
        }

            if (v133)
            {
              free(v133);
              BOOL v27 = v235;
              goto LABEL_86;
            }

            goto LABEL_163;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v120 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
          {
            id v213 = nw_endpoint_handler_get_id_string(v228);
            v160 = nw_endpoint_handler_dry_run_string(v228);
            id v161 = nw_endpoint_handler_copy_endpoint(v228);
            char v162 = nw_endpoint_get_logging_description(v161);
            int v163 = nw_endpoint_handler_state_string(v228);
            os_log_type_t v164 = nw_endpoint_handler_mode_string(v228);
            nw_endpoint_t v165 = nw_endpoint_handler_copy_current_path(v228);
            *(_DWORD *)buf = 136448002;
            v239 = "nw_endpoint_transform_start_next_child";
            id v240 = 2082;
            id_str = (char *)v213;
            id v242 = 2082;
            v243 = v160;
            v244 = 2082;
            os_log_type_t v245 = v162;
            int v246 = 2082;
            id v247 = v163;
            nw_endpoint_t v248 = 2082;
            id v249 = v164;
            id v250 = 2114;
            v251 = v165;
            v252 = 2048;
            id v253 = v224;
            _os_log_impl( &dword_181A5C000,  v120,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums",  buf,  0x52u);
          }
        }

        else
        {
          if ((v118 & 1) != 0) {
            goto LABEL_161;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v120 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v120, OS_LOG_TYPE_INFO))
          {
            os_log_type_t v121 = nw_endpoint_handler_get_id_string(v228);
            os_log_type_t v122 = nw_endpoint_handler_dry_run_string(v228);
            BOOL v123 = nw_endpoint_handler_copy_endpoint(v228);
            os_log_type_t v124 = nw_endpoint_get_logging_description(v123);
            id v125 = nw_endpoint_handler_state_string(v228);
            os_log_type_t v126 = nw_endpoint_handler_mode_string(v228);
            BOOL v127 = nw_endpoint_handler_copy_current_path(v228);
            *(_DWORD *)buf = 136448002;
            v239 = "nw_endpoint_transform_start_next_child";
            id v240 = 2082;
            id_str = (char *)v121;
            id v242 = 2082;
            v243 = v122;
            v244 = 2082;
            os_log_type_t v245 = v124;
            int v246 = 2082;
            id v247 = v125;
            nw_endpoint_t v248 = 2082;
            id v249 = v126;
            id v250 = 2114;
            v251 = v127;
            v252 = 2048;
            id v253 = v224;
            _os_log_impl( &dword_181A5C000,  v120,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums",  buf,  0x52u);
          }
        }

        os_log_type_t v119 = v229;
        int v116 = v228;
        goto LABEL_161;
      }

      char v66 = nw_endpoint_handler_copy_transform(v64);
      char v67 = *((void *)v66 + 1);
      if (v67)
      {
        os_log_type_t v68 = *(void *)(v67 + 24) - *(void *)(v67 + 16);
        if (v68)
        {
          if (v63 < v68 >> 3)
          {
            nw_array_get_object_at_index(v67, v63);
            uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            goto LABEL_118;
          }

          if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v64) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            char v188 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
            {
              BOOL v220 = nw_endpoint_handler_get_id_string(v64);
              id v214 = nw_endpoint_handler_dry_run_string(v64);
              nw_endpoint_t v226 = nw_endpoint_handler_copy_endpoint(v64);
              nw_endpoint_t v209 = nw_endpoint_get_logging_description(v226);
              nw_endpoint_t v189 = nw_endpoint_handler_state_string(v64);
              v190 = nw_endpoint_handler_mode_string(v64);
              nw_endpoint_t v191 = nw_endpoint_handler_copy_current_path(v64);
              *(_DWORD *)buf = 136448002;
              v239 = "nw_endpoint_transform_get_child_at_index";
              id v240 = 2082;
              id_str = (char *)v220;
              id v242 = 2082;
              v243 = v214;
              v244 = 2082;
              os_log_type_t v245 = v209;
              int v246 = 2082;
              id v247 = v189;
              nw_endpoint_t v248 = 2082;
              id v249 = v190;
              id v250 = 2114;
              v192 = v191;
              v251 = v191;
              v252 = 1024;
              LODWORD(v253) = v63;
              _os_log_impl( &dword_181A5C000,  v188,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no child at index %u",  buf,  0x4Eu);
            }
          }
        }
      }

      uint64_t v69 = 0LL;
LABEL_118:

      if (v69)
      {
        os_log_type_t v95 = nw_endpoint_handler_copy_parameters(v230);
        nw_endpoint_t v222 = v95;
        if (v95)
        {
          BOOL v96 = v95;
          nw_endpoint_t v97 = nw_endpoint_handler_copy_parameters(v69);
          if (v97)
          {
            if (nw_parameters_get_upper_transport_protocol(v96) != 253)
            {
LABEL_151:

LABEL_152:
LABEL_153:

              goto LABEL_154;
            }

            nw_parameters_get_upper_transport_protocol_options(v96);
            os_log_type_t v98 = (nw_protocol_options *)objc_claimAutoreleasedReturnValue();
            id v99 = v98;
            if (v98)
            {
              if (nw_protocol_options_is_quic(v98))
              {
                if (nw_protocol_options_is_quic_stream(v99))
                {
                  is_speculative_attempt = nw_quic_get_is_speculative_attempt(v99);
                }

                else
                {
                  if (!nw_protocol_options_is_quic_connection(v99)) {
                    goto LABEL_142;
                  }
                  is_speculative_attempt = nw_quic_connection_get_is_speculative_attempt(v99);
                }

                if (is_speculative_attempt)
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v64) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    id v105 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
                    {
                      os_log_type_t v106 = nw_endpoint_handler_get_id_string(v64);
                      nw_endpoint_t v216 = nw_endpoint_handler_dry_run_string(v64);
                      unint64_t v107 = nw_endpoint_handler_copy_endpoint(v64);
                      int v211 = nw_endpoint_get_logging_description(v107);
                      id v207 = nw_endpoint_handler_state_string(v64);
                      id v205 = nw_endpoint_handler_mode_string(v64);
                      id v108 = nw_endpoint_handler_copy_current_path(v64);
                      os_log_type_t v109 = nw_endpoint_handler_get_id_string(v230);
                      *(_DWORD *)buf = 136448002;
                      v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                      id v240 = 2082;
                      id_str = (char *)v106;
                      id v242 = 2082;
                      v243 = v216;
                      v244 = 2082;
                      os_log_type_t v245 = v211;
                      int v246 = 2082;
                      id v247 = v207;
                      nw_endpoint_t v248 = 2082;
                      id v249 = v205;
                      id v250 = 2114;
                      v251 = v108;
                      v252 = 2080;
                      id v253 = (unint64_t)v109;
                      _os_log_impl( &dword_181A5C000,  v105,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] quic [C%s] is s peculative attempt, using shorter timeout percentage",  buf,  0x52u);
                    }
                  }

                  *(_BYTE *)(v62 + 97) = 1;
                  __int16 v60 = 50LL;
LABEL_150:

                  goto LABEL_151;
                }

    goto LABEL_181;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v104 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v159 = "nw_flow_add_write_request";
    id v105 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v156 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v107 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v159 = "nw_flow_add_write_request";
        _os_log_impl(&dword_181A5C000, v106, v107, "%{public}s called with null flow_protocol", buf, 0xCu);
      }

      goto LABEL_180;
    }

    if (!v156)
    {
      __nwlog_obj();
      os_log_type_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v137 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v159 = "nw_flow_add_write_request";
        _os_log_impl( &dword_181A5C000,  v106,  v137,  "%{public}s called with null flow_protocol, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_180;
    }

    id v113 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v114 = type;
    os_log_type_t v115 = os_log_type_enabled(v106, type);
    if (!v113)
    {
      if (v115)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v159 = "nw_flow_add_write_request";
        _os_log_impl(&dword_181A5C000, v106, v114, "%{public}s called with null flow_protocol, no backtrace", buf, 0xCu);
      }

      goto LABEL_180;
    }

    if (v115)
    {
      *(_DWORD *)buf = 136446466;
      nw_endpoint_t v159 = "nw_flow_add_write_request";
      v160 = 2082;
      id v161 = v113;
      _os_log_impl( &dword_181A5C000,  v106,  v114,  "%{public}s called with null flow_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_132;
  }

  if (!v6)
  {
    __nwlog_obj();
    BOOL v111 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v159 = "nw_flow_add_write_request";
    id v105 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v156 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v112 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v159 = "nw_flow_add_write_request";
        _os_log_impl(&dword_181A5C000, v106, v112, "%{public}s called with null write_request", buf, 0xCu);
      }

      goto LABEL_180;
    }

    if (!v156)
    {
      __nwlog_obj();
      os_log_type_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v138 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v159 = "nw_flow_add_write_request";
        _os_log_impl( &dword_181A5C000,  v106,  v138,  "%{public}s called with null write_request, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_180;
    }

    id v113 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    int v116 = type;
    BOOL v117 = os_log_type_enabled(v106, type);
    if (!v113)
    {
      if (v117)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v159 = "nw_flow_add_write_request";
        _os_log_impl(&dword_181A5C000, v106, v116, "%{public}s called with null write_request, no backtrace", buf, 0xCu);
      }

      goto LABEL_180;
    }

    if (v117)
    {
      *(_DWORD *)buf = 136446466;
      nw_endpoint_t v159 = "nw_flow_add_write_request";
      v160 = 2082;
      id v161 = v113;
      _os_log_impl( &dword_181A5C000,  v106,  v116,  "%{public}s called with null write_request, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_190;
  }

  handle = a1->handle;
  os_log_type_t v8 = handle == &nw_protocol_ref_counted_handle;
  if (handle == &nw_protocol_ref_counted_handle) {
    p_output_handler = &a1[1].output_handler;
  }
  else {
    p_output_handler = 0LL;
  }
  id v113 = p_output_handler;
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v129 = "nw_protocol_udp_get_input_frames";
    BOOL v93 = (char *)_os_log_send_and_compose_impl();
    v121[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v125[0]) = 0;
    if (v121[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v90 = (os_log_s *)__nwlog_obj();
      id v91 = v121[0];
      if (os_log_type_enabled(v90, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v92 = "%{public}s called with null udp";
        goto LABEL_189;
      }

      goto LABEL_190;
    }

    if (!LOBYTE(v125[0]))
    {
      os_log_type_t v90 = (os_log_s *)__nwlog_obj();
      id v91 = v121[0];
      if (os_log_type_enabled(v90, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v92 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_189;
      }

      goto LABEL_190;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v90 = (os_log_s *)__nwlog_obj();
    id v91 = v121[0];
    os_log_type_t v98 = os_log_type_enabled(v90, v121[0]);
    if (!backtrace_string)
    {
      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v92 = "%{public}s called with null udp, no backtrace";
        goto LABEL_189;
      }

      goto LABEL_190;
    }

    if (v98)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v129 = "nw_protocol_udp_get_input_frames";
      os_log_type_t v130 = 2082;
      nw_endpoint_t v131 = backtrace_string;
      nw_endpoint_t v97 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_179;
    }

    goto LABEL_180;
  }

  if (a3 >= 0xFFFFFFF8) {
    os_log_type_t v12 = 0xFFFFFFFFLL;
  }
  else {
    os_log_type_t v12 = a3 + 8;
  }
  if (a4 >= 0xFFFFFFF8) {
    nw_endpoint_t v13 = 0xFFFFFFFFLL;
  }
  else {
    nw_endpoint_t v13 = a4 + 8;
  }
  v125[0] = 0LL;
  v125[1] = v125;
  *(void *)os_log_type_t v121 = 0LL;
  os_log_type_t v122 = v121;
  os_log_type_t v124 = 0;
  os_log_type_t v112 = a1 + 3;
  BOOL v123 = 0x2000000000LL;
  while (1)
  {
    output_handler = a1->output_handler;
    if (output_handler)
    {
      os_log_type_t v15 = output_handler->handle;
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        callbacks = output_handler[1].callbacks;
        if (callbacks) {
          output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
      }

      __int16 v17 = a1->handle;
      if (v17 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v18 = a1[1].callbacks;
        if (v18) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
        }
      }

      uint64_t v19 = output_handler->callbacks;
      if (v19)
      {
        get_input_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, void *))v19->get_input_frames;
        if (get_input_frames)
        {
          __int16 v21 = get_input_frames(output_handler, a1, v12, v13, a5, v125);
          if (v17 != &nw_protocol_ref_counted_handle)
          {
LABEL_25:
            if (v15 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
            {
              int v39 = output_handler[1].callbacks;
              if (v39)
              {
                BOOL v40 = (nw_protocol_callbacks *)((char *)v39 - 1);
                output_handler[1].callbacks = v40;
                if (!v40)
                {
                  os_log_type_t v41 = *(void (***)(void))output_handler[1].flow_id;
                  if (v41)
                  {
                    *(void *)output_handler[1].flow_id = 0LL;
                    v41[2](v41);
                    _Block_release(v41);
                  }

                  if ((output_handler[1].flow_id[8] & 1) != 0)
                  {
                    BOOL v42 = *(const void **)output_handler[1].flow_id;
                    if (v42) {
                      _Block_release(v42);
                    }
                  }

                  free(output_handler);
                }
              }
            }

            goto LABEL_27;
          }

      if (!v56) {
        goto LABEL_135;
      }
      goto LABEL_181;
    }

    __nwlog_obj();
    id v54 = (void *)objc_claimAutoreleasedReturnValue();
    id v55 = networkd_privileged_result_to_string(v34);
    *(_DWORD *)buf = 136446722;
    __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
    id v81 = 2048;
    *(void *)uint64_t v82 = v34;
    *(_WORD *)&v82[8] = 2082;
    *(void *)&v82[10] = v55;
    os_log_type_t v56 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v77 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        id v81 = 2048;
        *(void *)uint64_t v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = v55;
        _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s received internal failure result code: [%lld] %{public}s",  buf,  0x20u);
      }
    }

    else if (v77)
    {
      char v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v68 = type;
      uint64_t v69 = os_log_type_enabled(v57, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          id v81 = 2048;
          *(void *)uint64_t v82 = v34;
          *(_WORD *)&v82[8] = 2082;
          *(void *)&v82[10] = v55;
          *(_WORD *)&v82[18] = 2082;
          id v83 = v67;
          _os_log_impl( &dword_181A5C000,  v57,  v68,  "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v67);
        goto LABEL_180;
      }

      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        id v81 = 2048;
        *(void *)uint64_t v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = v55;
        _os_log_impl( &dword_181A5C000,  v57,  v68,  "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v75 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        id v81 = 2048;
        *(void *)uint64_t v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = v55;
        _os_log_impl( &dword_181A5C000,  v57,  v75,  "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }

    goto LABEL_180;
  }

  if (Class == (Class)MEMORY[0x1895F9268])
  {
    if (v4 == (void *)MEMORY[0x1895F9198])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v77 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_181A5C000, v12, v32, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }

        goto LABEL_72;
      }

      if (!v77)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v63 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl( &dword_181A5C000,  v12,  v63,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_72;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      uint64_t v45 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl( &dword_181A5C000,  v12,  v44,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace",  buf,  0xCu);
        }

        goto LABEL_72;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        id v81 = 2082;
        *(void *)uint64_t v82 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v44,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_25;
    }

    if (v4 != (void *)MEMORY[0x1895F91A0])
    {
      if (v4 != (void *)MEMORY[0x1895F91C8])
      {
        uint64_t v6 = (char *)MEMORY[0x186E12534](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        id v81 = 2082;
        *(void *)uint64_t v82 = v6;
        os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        BOOL v77 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v24 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            id v81 = 2082;
            *(void *)uint64_t v82 = v6;
            _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s received returned unknown XPC error %{public}s",  buf,  0x16u);
          }

          goto LABEL_62;
        }

        if (!v77)
        {
          __nwlog_obj();
          char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v70 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            id v81 = 2082;
            *(void *)uint64_t v82 = v6;
            _os_log_impl( &dword_181A5C000,  v9,  v70,  "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded",  buf,  0x16u);
          }

          goto LABEL_62;
        }

        BOOL v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v52 = type;
        os_log_type_t v53 = os_log_type_enabled(v9, type);
        if (!v51)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            id v81 = 2082;
            *(void *)uint64_t v82 = v6;
            _os_log_impl( &dword_181A5C000,  v9,  v52,  "%{public}s received returned unknown XPC error %{public}s, no backtrace",  buf,  0x16u);
          }

          goto LABEL_62;
        }

        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          id v81 = 2082;
          *(void *)uint64_t v82 = v6;
          *(_WORD *)&v82[8] = 2082;
          *(void *)&v82[10] = v51;
          _os_log_impl( &dword_181A5C000,  v9,  v52,  "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v51);
        if (!v8) {
          goto LABEL_73;
        }
LABEL_64:
        free(v8);
        goto LABEL_73;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v46 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v77 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v47 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_181A5C000, v12, v47, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }

      if (!v56) {
        goto LABEL_135;
      }
      goto LABEL_181;
    }

    __nwlog_obj();
    id v54 = (void *)objc_claimAutoreleasedReturnValue();
    id v55 = networkd_privileged_result_to_string(v34);
    *(_DWORD *)buf = 136446722;
    __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
    id v81 = 2048;
    *(void *)uint64_t v82 = v34;
    *(_WORD *)&v82[8] = 2082;
    *(void *)&v82[10] = v55;
    os_log_type_t v56 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v77 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
        id v81 = 2048;
        *(void *)uint64_t v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = v55;
        _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s received internal failure result code: [%lld] %{public}s",  buf,  0x20u);
      }
    }

    else if (v77)
    {
      char v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v68 = type;
      uint64_t v69 = os_log_type_enabled(v57, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
          id v81 = 2048;
          *(void *)uint64_t v82 = v34;
          *(_WORD *)&v82[8] = 2082;
          *(void *)&v82[10] = v55;
          *(_WORD *)&v82[18] = 2082;
          *(void *)id v83 = v67;
          _os_log_impl( &dword_181A5C000,  v57,  v68,  "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v67);
        goto LABEL_180;
      }

      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
        id v81 = 2048;
        *(void *)uint64_t v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = v55;
        _os_log_impl( &dword_181A5C000,  v57,  v68,  "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v75 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
        id v81 = 2048;
        *(void *)uint64_t v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = v55;
        _os_log_impl( &dword_181A5C000,  v57,  v75,  "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }

    goto LABEL_180;
  }

  if (Class == (Class)MEMORY[0x1895F9268])
  {
    if (v4 == (void *)MEMORY[0x1895F9198])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v77 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_181A5C000, v12, v32, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }

        goto LABEL_72;
      }

      if (!v77)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v63 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl( &dword_181A5C000,  v12,  v63,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_72;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      uint64_t v45 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl( &dword_181A5C000,  v12,  v44,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace",  buf,  0xCu);
        }

        goto LABEL_72;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
        id v81 = 2082;
        *(void *)uint64_t v82 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v44,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_25;
    }

    if (v4 != (void *)MEMORY[0x1895F91A0])
    {
      if (v4 != (void *)MEMORY[0x1895F91C8])
      {
        uint64_t v6 = (char *)MEMORY[0x186E12534](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
        id v81 = 2082;
        *(void *)uint64_t v82 = v6;
        os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        BOOL v77 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v24 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
            id v81 = 2082;
            *(void *)uint64_t v82 = v6;
            _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s received returned unknown XPC error %{public}s",  buf,  0x16u);
          }

          goto LABEL_62;
        }

        if (!v77)
        {
          __nwlog_obj();
          char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v70 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
            id v81 = 2082;
            *(void *)uint64_t v82 = v6;
            _os_log_impl( &dword_181A5C000,  v9,  v70,  "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded",  buf,  0x16u);
          }

          goto LABEL_62;
        }

        BOOL v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v52 = type;
        os_log_type_t v53 = os_log_type_enabled(v9, type);
        if (!v51)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
            id v81 = 2082;
            *(void *)uint64_t v82 = v6;
            _os_log_impl( &dword_181A5C000,  v9,  v52,  "%{public}s received returned unknown XPC error %{public}s, no backtrace",  buf,  0x16u);
          }

          goto LABEL_62;
        }

        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
          id v81 = 2082;
          *(void *)uint64_t v82 = v6;
          *(_WORD *)&v82[8] = 2082;
          *(void *)&v82[10] = v51;
          _os_log_impl( &dword_181A5C000,  v9,  v52,  "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v51);
        if (!v8) {
          goto LABEL_73;
        }
LABEL_64:
        free(v8);
        goto LABEL_73;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v46 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
      uint64_t v6 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v77 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v47 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_181A5C000, v12, v47, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }

LABEL_181:
      if (!v55) {
        goto LABEL_60;
      }
LABEL_182:
      free(v55);
      goto LABEL_60;
    }

    if (!v133)
    {
      __nwlog_obj();
      os_log_type_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v90 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&_OWORD buf[4] = "nw_context_purge_endpoints";
        _os_log_impl( &dword_181A5C000,  v56,  v90,  "%{public}s called with null (context->cache->address_endpoints != NULL && context->cache->host_endpoints != NU LL && context->cache->other_endpoints != NULL), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_180;
    }

    os_log_type_t v58 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v59 = type[0];
    __int16 v60 = os_log_type_enabled(v56, type[0]);
    if (!v58)
    {
      if (v60)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&_OWORD buf[4] = "nw_context_purge_endpoints";
        _os_log_impl( &dword_181A5C000,  v56,  v59,  "%{public}s called with null (context->cache->address_endpoints != NULL && context->cache->host_endpoints != NU LL && context->cache->other_endpoints != NULL), no backtrace",  buf,  0xCu);
      }

      goto LABEL_180;
    }

    if (v60)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&_OWORD buf[4] = "nw_context_purge_endpoints";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v58;
      _os_log_impl( &dword_181A5C000,  v56,  v59,  "%{public}s called with null (context->cache->address_endpoints != NULL && context->cache->host_endpoints != NULL && context->cache->other_endpoints != NULL), dumping backtrace:%{public}s",  buf,  0x16u);
    }

              if (v99) {
                free(v99);
              }
              -[NWConcrete_nw_ethernet_channel closeChannel:](a1, 0);
              return 0LL;
            }

            __nwlog_obj();
            uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
            id v83 = *(void *)(a1 + 176);
            uint64_t v84 = *(void *)(a1 + 184);
            *(_DWORD *)buf = 136446978;
            os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
            nw_endpoint_t v131 = 2112;
            *(void *)os_log_type_t v132 = a1;
            *(_WORD *)&v132[8] = 2048;
            *(void *)&v132[10] = v83;
            *(_WORD *)&v132[18] = 2048;
            *(void *)&v132[20] = v84;
            BOOL v85 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            BOOL v127 = OS_LOG_TYPE_DEFAULT;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v87 = type[0];
              if (os_log_type_enabled(v86, type[0]))
              {
                nw_endpoint_t v88 = *(void *)(a1 + 176);
                BOOL v89 = *(void *)(a1 + 184);
                *(_DWORD *)buf = 136446978;
                os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                nw_endpoint_t v131 = 2112;
                *(void *)os_log_type_t v132 = a1;
                *(_WORD *)&v132[8] = 2048;
                *(void *)&v132[10] = v88;
                *(_WORD *)&v132[18] = 2048;
                *(void *)&v132[20] = v89;
                _os_log_impl( &dword_181A5C000,  v86,  v87,  "%{public}s %@: createChannel failed to get input / output rings (%lX %lX)",  buf,  0x2Au);
              }
            }

            else if (v127)
            {
              BOOL v93 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              int v94 = type[0];
              os_log_type_t v95 = os_log_type_enabled(v86, type[0]);
              if (v93)
              {
                if (v95)
                {
                  BOOL v96 = *(void *)(a1 + 176);
                  nw_endpoint_t v97 = *(void *)(a1 + 184);
                  *(_DWORD *)buf = 136447234;
                  os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                  nw_endpoint_t v131 = 2112;
                  *(void *)os_log_type_t v132 = a1;
                  *(_WORD *)&v132[8] = 2048;
                  *(void *)&v132[10] = v96;
                  *(_WORD *)&v132[18] = 2048;
                  *(void *)&v132[20] = v97;
                  *(_WORD *)&v132[28] = 2082;
                  *(void *)&BOOL v133 = v93;
                  _os_log_impl( &dword_181A5C000,  v86,  v94,  "%{public}s %@: createChannel failed to get input / output rings (%lX %lX), dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v93);
                goto LABEL_171;
              }

              if (v95)
              {
                os_log_type_t v112 = *(void *)(a1 + 176);
                id v113 = *(void *)(a1 + 184);
                *(_DWORD *)buf = 136446978;
                os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                nw_endpoint_t v131 = 2112;
                *(void *)os_log_type_t v132 = a1;
                *(_WORD *)&v132[8] = 2048;
                *(void *)&v132[10] = v112;
                *(_WORD *)&v132[18] = 2048;
                *(void *)&v132[20] = v113;
                _os_log_impl( &dword_181A5C000,  v86,  v94,  "%{public}s %@: createChannel failed to get input / output rings (%lX %lX), no backtrace",  buf,  0x2Au);
              }
            }

            else
            {
              __nwlog_obj();
              uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v106 = type[0];
              if (os_log_type_enabled(v86, type[0]))
              {
                unint64_t v107 = *(void *)(a1 + 176);
                id v108 = *(void *)(a1 + 184);
                *(_DWORD *)buf = 136446978;
                os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                nw_endpoint_t v131 = 2112;
                *(void *)os_log_type_t v132 = a1;
                *(_WORD *)&v132[8] = 2048;
                *(void *)&v132[10] = v107;
                *(_WORD *)&v132[18] = 2048;
                *(void *)&v132[20] = v108;
                _os_log_impl( &dword_181A5C000,  v86,  v106,  "%{public}s %@: createChannel failed to get input / output rings (%lX %lX), backtrace limit exceeded",  buf,  0x2Au);
              }
            }

LABEL_171:
            if (v85) {
              free(v85);
            }
LABEL_173:
            -[NWConcrete_nw_ethernet_channel closeChannel:](a1, 0);
            return 0LL;
          }

          __nwlog_obj();
          __int16 v72 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446466;
          os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          nw_endpoint_t v131 = 2112;
          *(void *)os_log_type_t v132 = a1;
          BOOL v73 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          BOOL v127 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v73, type, &v127))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              char v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v75 = type[0];
              if (os_log_type_enabled(v74, type[0]))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                nw_endpoint_t v131 = 2112;
                *(void *)os_log_type_t v132 = a1;
                _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s %@: createChannel failed to get channel fd",  buf,  0x16u);
              }
            }

            else if (v127)
            {
              os_log_type_t v90 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              char v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              id v91 = type[0];
              os_log_type_t v92 = os_log_type_enabled(v74, type[0]);
              if (v90)
              {
                if (v92)
                {
                  *(_DWORD *)buf = 136446722;
                  os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                  nw_endpoint_t v131 = 2112;
                  *(void *)os_log_type_t v132 = a1;
                  *(_WORD *)&v132[8] = 2082;
                  *(void *)&v132[10] = v90;
                  _os_log_impl( &dword_181A5C000,  v74,  v91,  "%{public}s %@: createChannel failed to get channel fd, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(v90);
                goto LABEL_165;
              }

              if (v92)
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                nw_endpoint_t v131 = 2112;
                *(void *)os_log_type_t v132 = a1;
                _os_log_impl( &dword_181A5C000,  v74,  v91,  "%{public}s %@: createChannel failed to get channel fd, no backtrace",  buf,  0x16u);
              }
            }

            else
            {
              __nwlog_obj();
              char v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              id v105 = type[0];
              if (os_log_type_enabled(v74, type[0]))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                nw_endpoint_t v131 = 2112;
                *(void *)os_log_type_t v132 = a1;
                _os_log_impl( &dword_181A5C000,  v74,  v105,  "%{public}s %@: createChannel failed to get channel fd, backtrace limit exceeded",  buf,  0x16u);
              }
            }
          }

              goto LABEL_181;
            }

            if (!(_BYTE)v163)
            {
              __nwlog_obj();
              char v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v87 = v170[0];
              if (os_log_type_enabled(v66, (os_log_type_t)v170[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "__nw_protocol_get_output_handler";
                _os_log_impl( &dword_181A5C000,  v66,  v87,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_180;
            }

            __int16 v78 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            char v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_t v79 = v170[0];
            __int16 v80 = os_log_type_enabled(v66, (os_log_type_t)v170[0]);
            if (!v78)
            {
              if (v80)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "__nw_protocol_get_output_handler";
                _os_log_impl( &dword_181A5C000,  v66,  v79,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
              }

              goto LABEL_180;
            }

            if (v80)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&_OWORD buf[4] = "__nw_protocol_get_output_handler";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v78;
              _os_log_impl( &dword_181A5C000,  v66,  v79,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v78);
          }

              if (v59) {
                free(v59);
              }
              uint64_t v45 = 0LL;
              goto LABEL_197;
            }

            __nwlog_obj();
            os_log_type_t v62 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
            os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v115) = 0;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v63 = type[0];
              if (os_log_type_enabled(v60, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl( &dword_181A5C000,  v60,  v63,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
              }

              goto LABEL_179;
            }

            if (!(_BYTE)v115)
            {
              __nwlog_obj();
              __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v95 = type[0];
              if (os_log_type_enabled(v60, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl( &dword_181A5C000,  v60,  v95,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_179;
            }

            uint64_t v76 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_t v79 = type[0];
            __int16 v80 = os_log_type_enabled(v60, type[0]);
            if (!v76)
            {
              if (v80)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl( &dword_181A5C000,  v60,  v79,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
              }

              goto LABEL_179;
            }

            if (v80)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v76;
              _os_log_impl( &dword_181A5C000,  v60,  v79,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }
          }

          else
          {
            __nwlog_obj();
            os_log_type_t v58 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
            os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

            uint64_t v24 = (char *)v22;
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v115) = 0;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              id v61 = type[0];
              if (os_log_type_enabled(v60, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl(&dword_181A5C000, v60, v61, "%{public}s called with null instance", buf, 0xCu);
              }

              goto LABEL_179;
            }

            if (!(_BYTE)v115)
            {
              __nwlog_obj();
              __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              int v94 = type[0];
              if (os_log_type_enabled(v60, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl( &dword_181A5C000,  v60,  v94,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_179;
            }

            uint64_t v76 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v77 = type[0];
            __int16 v78 = os_log_type_enabled(v60, type[0]);
            if (!v76)
            {
              if (v78)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl( &dword_181A5C000,  v60,  v77,  "%{public}s called with null instance, no backtrace",  buf,  0xCu);
              }

              goto LABEL_179;
            }

            if (v78)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&_OWORD buf[4] = "nw_protocol_implementation_service_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v76;
              _os_log_impl( &dword_181A5C000,  v60,  v77,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
            }
          }

      free(backtrace_string);
      goto LABEL_198;
    }

    if (!v97) {
      goto LABEL_198;
    }
    *(_DWORD *)buf = 136446210;
    id v114 = "nw_protocol_http2_transport_add_input_handler";
    os_log_type_t v90 = "%{public}s called with null input_protocol, no backtrace";
LABEL_197:
    _os_log_impl(&dword_181A5C000, v88, v89, v90, buf, 0xCu);
LABEL_198:
    if (v87) {
      free(v87);
    }
    return 0LL;
  }

  if (gLogDatapath)
  {
    id v91 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      id v114 = "nw_protocol_http2_transport_add_input_handler";
      os_log_type_t v115 = 2082;
      int v116 = (uint64_t)(handle + 205);
      _os_log_impl(&dword_181A5C000, v91, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }

    if (gLogDatapath)
    {
      os_log_type_t v92 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        id v114 = "nw_protocol_http2_transport_add_input_handler";
        os_log_type_t v115 = 2082;
        int v116 = (uint64_t)(handle + 205);
        BOOL v117 = 2048;
        *(void *)id v118 = a2;
        *(_WORD *)&v118[8] = 1042;
        *(_DWORD *)&v118[10] = 16;
        *(_WORD *)&v118[14] = 2098;
        *(void *)&v118[16] = a2;
        _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s incoming protocol %p has flow id %{public,uuid_t}.16P",  buf,  0x30u);
      }
    }
  }

  if (!*((void *)handle + 12))
  {
    callbacks = a2->callbacks;
    if (!callbacks
      || (get_remote_endpoint = (uint64_t (*)(nw_protocol *))callbacks->get_remote_endpoint) == 0LL
      || (char v7 = (void *)get_remote_endpoint(a2)) == 0LL)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)buf = 136446466;
      id v114 = "nw_protocol_http2_transport_add_input_handler";
      os_log_type_t v115 = 2082;
      int v116 = (uint64_t)(handle + 205);
      __int16 v21 = "%{public}s %{public}s failed to get remote endpoint from input_handler";
      goto LABEL_137;
    }

    *((void *)handle + 12) = os_retain(v7);
  }

  os_log_type_t v8 = a2->callbacks;
  if (!v8
    || (get_parameters = (uint64_t (*)(nw_protocol *))v8->get_parameters) == 0LL
    || (os_log_type_t v10 = (void *)get_parameters(a2)) == 0LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (os_log_s *)gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446466;
    id v114 = "nw_protocol_http2_transport_add_input_handler";
    os_log_type_t v115 = 2082;
    int v116 = (uint64_t)(handle + 205);
    __int16 v21 = "%{public}s %{public}s couldn't get parameters from input_protocol";
LABEL_137:
    _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_ERROR, v21, buf, 0x16u);
    return 0LL;
  }

  nw_endpoint_t v11 = v10;
  os_log_type_t v12 = handle + 205;
  if (!handle[205])
  {
    nw_endpoint_t v13 = nw_parameters_copy_protocol_options_legacy(v10, a1);
    if (v13)
    {
      nw_endpoint_t v14 = v13;
      os_log_type_t v15 = v14;
      uint64_t v16 = 0LL;
      *os_log_type_t v12 = 0;
      __int16 v17 = 84LL;
      while (1)
      {
        uint64_t v18 = v14[v16 + 48];
        v12[v16] = v18;
        if (!v18) {
          break;
        }
        --v17;
        ++v16;
        if (v17 <= 1)
        {
          v12[v16] = 0;
          break;
        }
      }

      os_release(v15);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        id v114 = "nw_protocol_http2_transport_add_input_handler";
        os_log_type_t v115 = 2082;
        int v116 = (uint64_t)(handle + 205);
        _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s no http2_options found, cannot get log id",  buf,  0x16u);
      }
    }
  }

  uint64_t v23 = nw_parameters_copy_protocol_value(v11, (uint64_t)a1, "incomingStreamId");
  if (!v23)
  {
    LODWORD(v26) = -1;
    goto LABEL_32;
  }

  uint64_t v24 = v23;
  value = xpc_int64_get_value(v23);
  id v26 = value;
  if (HIDWORD(value))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    id v114 = "nw_protocol_http2_transport_add_input_handler";
    os_log_type_t v115 = 2082;
    int v116 = (uint64_t)(handle + 205);
    BOOL v117 = 2048;
    *(void *)id v118 = v26;
    BOOL v42 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v111 = OS_LOG_TYPE_DEFAULT;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v43 = (os_log_s *)gLogObj;
      BOOL v44 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)buf = 136446722;
      id v114 = "nw_protocol_http2_transport_add_input_handler";
      os_log_type_t v115 = 2082;
      int v116 = (uint64_t)v12;
      BOOL v117 = 2048;
      *(void *)id v118 = v26;
      uint64_t v45 = "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld";
    }

    else if (v111)
    {
      os_log_type_t v50 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v43 = (os_log_s *)gLogObj;
      BOOL v44 = type;
      BOOL v51 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v50)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446978;
          id v114 = "nw_protocol_http2_transport_add_input_handler";
          os_log_type_t v115 = 2082;
          int v116 = (uint64_t)v12;
          BOOL v117 = 2048;
          *(void *)id v118 = v26;
          *(_WORD *)&v118[8] = 2082;
          *(void *)&v118[10] = v50;
          _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v50);
        goto LABEL_92;
      }

      if (!v51)
      {
LABEL_92:
        if (v42) {
          free(v42);
        }
        goto LABEL_94;
      }

      *(_DWORD *)buf = 136446722;
      id v114 = "nw_protocol_http2_transport_add_input_handler";
      os_log_type_t v115 = 2082;
      int v116 = (uint64_t)v12;
      BOOL v117 = 2048;
      *(void *)id v118 = v26;
      uint64_t v45 = "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v43 = (os_log_s *)gLogObj;
      BOOL v44 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)buf = 136446722;
      id v114 = "nw_protocol_http2_transport_add_input_handler";
      os_log_type_t v115 = 2082;
      int v116 = (uint64_t)v12;
      BOOL v117 = 2048;
      *(void *)id v118 = v26;
      uint64_t v45 = "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v43, v44, v45, buf, 0x20u);
    goto LABEL_92;
  }

  if ((value & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v52 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      id v114 = "nw_protocol_http2_transport_add_input_handler";
      os_log_type_t v115 = 2082;
      int v116 = (uint64_t)(handle + 205);
      BOOL v117 = 1024;
      *(_DWORD *)id v118 = v26;
      _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s invalid incoming stream id detected: %d",  buf,  0x1Cu);
    }

              if (!v32) {
                goto LABEL_12;
              }
LABEL_181:
              free(v32);
              goto LABEL_12;
            }

            if ((*(_WORD *)(v8 + 1373) & 0x2000) == 0 || (char v9 = *(void *)(v8 + 928)) != 0 && v9 != a1)
            {
              *(void *)(a1 + 576) = 0LL;
              os_log_type_t v10 = *(uint64_t **)(v8 + 936);
              *(void *)(a1 + 584) = v10;
              *os_log_type_t v10 = a1;
              *(void *)(v8 + 936) = a1 + 576;
LABEL_12:
              _Block_object_dispose(&v413, 8);
              nw_endpoint_t v11 = buf;
LABEL_290:
              _Block_object_dispose(v11, 8);
              return 0LL;
            }

            if (!v9)
            {
              *(void *)(a1 + 576) = 0LL;
              id v25 = *(uint64_t **)(v8 + 936);
              *(void *)(a1 + 584) = v25;
              *id v25 = a1;
              *(void *)(v8 + 936) = a1 + 576;
            }

            nw_http3_start_encoder_stream_if_needed(v8);
            id v26 = *(void *)(v8 + 1056);
            if (!v26) {
              goto LABEL_12;
            }
            BOOL v27 = *(void *)(v26 + 24);
            if (!v27) {
              goto LABEL_12;
            }
            uint64_t v28 = *(unsigned int (**)(uint64_t, uint64_t))(v27 + 88);
            if (!v28 || !v28(v26, a1)) {
              goto LABEL_12;
            }
            v380[0] = MEMORY[0x1895F87A8];
            v380[1] = 0x40000000LL;
            __int16 v381 = (uint64_t (*)(void *))___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_3;
            nw_endpoint_t v382 = &unk_189BC4438;
            __int16 v383 = &v413;
            v384 = buf;
            __int16 v385 = a1;
            BOOL v29 = *(void *)(*(void *)&buf[8] + 40LL);
            do
            {
              if (!v29) {
                break;
              }
              char v30 = *(void *)(v29 + 32);
              uint64_t v31 = v381(v380);
              BOOL v29 = v30;
            }

            while ((v31 & 1) != 0);
            if (*(void *)(a1 + 528))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)os_log_type_t type = 136446210;
              *(void *)&type[4] = "nw_http3_stream_send_fields";
              uint64_t v32 = (char *)_os_log_send_and_compose_impl();
              v409[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v408[0]) = 0;
              if (v409[0] == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v33 = (os_log_s *)__nwlog_obj();
                os_log_type_t v34 = v409[0];
                if (!os_log_type_enabled(v33, v409[0])) {
                  goto LABEL_180;
                }
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_stream_send_fields";
                uint64_t v35 = "%{public}s Not enough space on encoder stream";
                goto LABEL_179;
              }

              if (!LOBYTE(v408[0]))
              {
                os_log_type_t v33 = (os_log_s *)__nwlog_obj();
                os_log_type_t v34 = v409[0];
                if (!os_log_type_enabled(v33, v409[0])) {
                  goto LABEL_180;
                }
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_stream_send_fields";
                uint64_t v35 = "%{public}s Not enough space on encoder stream, backtrace limit exceeded";
                goto LABEL_179;
              }

              BOOL v85 = (char *)__nw_create_backtrace_string();
              os_log_type_t v33 = (os_log_s *)__nwlog_obj();
              os_log_type_t v34 = v409[0];
              uint64_t v86 = os_log_type_enabled(v33, v409[0]);
              if (v85)
              {
                if (v86)
                {
                  *(_DWORD *)os_log_type_t type = 136446466;
                  *(void *)&type[4] = "nw_http3_stream_send_fields";
                  *(_WORD *)&type[12] = 2082;
                  *(void *)&type[14] = v85;
                  _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s Not enough space on encoder stream, dumping backtrace:%{public}s",  type,  0x16u);
                }

                free(v85);
                if (!v32) {
                  goto LABEL_12;
                }
                goto LABEL_181;
              }

              if (v86)
              {
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_stream_send_fields";
                uint64_t v35 = "%{public}s Not enough space on encoder stream, no backtrace";
LABEL_179:
                _os_log_impl(&dword_181A5C000, v33, v34, v35, type, 0xCu);
                goto LABEL_180;
              }

              goto LABEL_180;
            }

            *((_BYTE *)v6 + 2) |= 4u;
            int v71 = *(void **)(a1 + 336);
            if (v71)
            {
              if (v71[116] != a1)
              {
                __nwlog_obj();
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                __int16 v72 = (const char *)_os_log_send_and_compose_impl();
                v409[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v408[0]) = 0;
                if (v409[0] == OS_LOG_TYPE_FAULT)
                {
                  BOOL v73 = (os_log_s *)__nwlog_obj();
                  char v74 = v409[0];
                  if (!os_log_type_enabled(v73, v409[0])) {
                    goto LABEL_220;
                  }
                  *(_DWORD *)os_log_type_t type = 136446210;
                  *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                  uint64_t v75 = "%{public}s Encoder stream is not being used by current stream";
                  goto LABEL_218;
                }

                if (!LOBYTE(v408[0]))
                {
                  BOOL v73 = (os_log_s *)__nwlog_obj();
                  char v74 = v409[0];
                  if (!os_log_type_enabled(v73, v409[0])) {
                    goto LABEL_220;
                  }
                  *(_DWORD *)os_log_type_t type = 136446210;
                  *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                  uint64_t v75 = "%{public}s Encoder stream is not being used by current stream, backtrace limit exceeded";
                  goto LABEL_218;
                }

                id v113 = (char *)__nw_create_backtrace_string();
                id v114 = (os_log_s *)__nwlog_obj();
                char v74 = v409[0];
                BOOL loga = v114;
                os_log_type_t v115 = os_log_type_enabled(v114, v409[0]);
                if (v113)
                {
                  if (v115)
                  {
                    *(_DWORD *)os_log_type_t type = 136446466;
                    *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                    *(_WORD *)&type[12] = 2082;
                    *(void *)&type[14] = v113;
                    _os_log_impl( &dword_181A5C000,  loga,  v74,  "%{public}s Encoder stream is not being used by current stream, dumping backtrace:%{public}s",  type,  0x16u);
                  }

                  free(v113);
                  if (!v72) {
                    goto LABEL_223;
                  }
                  goto LABEL_221;
                }

                if (!v115) {
                  goto LABEL_220;
                }
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                uint64_t v75 = "%{public}s Encoder stream is not being used by current stream, no backtrace";
LABEL_302:
                __int128 v142 = loga;
                goto LABEL_219;
              }

              BOOL v111 = *(void *)(a1 + 576);
              os_log_type_t v112 = *(void **)(a1 + 584);
              if (v111)
              {
                *(void *)(v111 + 584) = v112;
                os_log_type_t v112 = *(void **)(a1 + 584);
              }

              else
              {
                v71[117] = v112;
              }

              v138 = *(void *)&buf[8];
              *os_log_type_t v112 = v111;
              *(void *)(a1 + 576) = 0LL;
              *(void *)(a1 + 584) = 0LL;
              char v139 = v71[132];
              if (v139)
              {
                os_log_type_t v140 = *(void *)(v139 + 24);
                if (v140)
                {
                  int v141 = *(void (**)(uint64_t, uint64_t))(v140 + 96);
                  if (v141)
                  {
                    v141(v139, v138 + 40);
                    goto LABEL_223;
                  }
                }

                __nwlog_obj();
                id v311 = *(const char **)(v139 + 16);
                if (!v311) {
                  id v311 = "invalid";
                }
              }

              else
              {
                __nwlog_obj();
                id v311 = "invalid";
              }

              *(_DWORD *)os_log_type_t type = 136446466;
              *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
              *(_WORD *)&type[12] = 2082;
              *(void *)&type[14] = v311;
              os_log_type_t v330 = (const char *)_os_log_send_and_compose_impl();
              v409[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v408[0]) = 0;
              __int16 v373 = v330;
              if (__nwlog_fault(v330, v409, v408))
              {
                if (v409[0] == OS_LOG_TYPE_FAULT)
                {
                  os_log_type_t v331 = (os_log_s *)__nwlog_obj();
                  v332 = v409[0];
                  if (os_log_type_enabled(v331, v409[0]))
                  {
                    nw_endpoint_t v333 = "invalid";
                    if (v139 && *(void *)(v139 + 16)) {
                      nw_endpoint_t v333 = *(const char **)(v139 + 16);
                    }
                    *(_DWORD *)os_log_type_t type = 136446466;
                    *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                    *(_WORD *)&type[12] = 2082;
                    *(void *)&type[14] = v333;
                    id v334 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
LABEL_618:
                    v363 = v331;
                    v364 = v332;
LABEL_619:
                    _os_log_impl(&dword_181A5C000, v363, v364, v334, type, 0x16u);
                  }
                }

                else if (LOBYTE(v408[0]))
                {
                  BOOL v335 = (char *)__nw_create_backtrace_string();
                  id v336 = (os_log_s *)__nwlog_obj();
                  v366 = v409[0];
                  os_log_type_t v337 = os_log_type_enabled(v336, v409[0]);
                  if (v335)
                  {
                    if (v337)
                    {
                      v338 = "invalid";
                      if (v139 && *(void *)(v139 + 16)) {
                        v338 = *(const char **)(v139 + 16);
                      }
                      *(_DWORD *)os_log_type_t type = 136446722;
                      *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                      *(_WORD *)&type[12] = 2082;
                      *(void *)&type[14] = v338;
                      *(_WORD *)&type[22] = 2082;
                      v418 = (__n128 (*)(uint64_t, uint64_t))v335;
                      _os_log_impl( &dword_181A5C000,  v336,  v366,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  type,  0x20u);
                    }

                    free(v335);
                    goto LABEL_620;
                  }

                  if (v337)
                  {
                    id v365 = "invalid";
                    if (v139 && *(void *)(v139 + 16)) {
                      id v365 = *(const char **)(v139 + 16);
                    }
                    *(_DWORD *)os_log_type_t type = 136446466;
                    *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                    *(_WORD *)&type[12] = 2082;
                    *(void *)&type[14] = v365;
                    id v334 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
                    v363 = v336;
                    v364 = v366;
                    goto LABEL_619;
                  }
                }

                else
                {
                  os_log_type_t v331 = (os_log_s *)__nwlog_obj();
                  v332 = v409[0];
                  if (os_log_type_enabled(v331, v409[0]))
                  {
                    uint64_t v362 = "invalid";
                    if (v139 && *(void *)(v139 + 16)) {
                      uint64_t v362 = *(const char **)(v139 + 16);
                    }
                    *(_DWORD *)os_log_type_t type = 136446466;
                    *(void *)&type[4] = "nw_http3_encoder_stream_finalize_output_frames";
                    *(_WORD *)&type[12] = 2082;
                    *(void *)&type[14] = v362;
                    id v334 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
                    goto LABEL_618;
                  }
                }
              }

        goto LABEL_181;
      }

      if (!buf[0])
      {
        __nwlog_obj();
        os_log_type_t v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v111 = v132[0];
        if (os_log_type_enabled(v92, (os_log_type_t)v132[0]))
        {
          *(_DWORD *)os_log_type_t v134 = 136446210;
          *(void *)&v134[4] = "nw_endpoint_handler_report_data_stall";
          _os_log_impl( &dword_181A5C000,  v92,  v111,  "%{public}s called with null handler, backtrace limit exceeded",  v134,  0xCu);
        }

        goto LABEL_180;
      }

      os_log_type_t v106 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v107 = v132[0];
      id v108 = os_log_type_enabled(v92, (os_log_type_t)v132[0]);
      if (!v106)
      {
        if (v108)
        {
          *(_DWORD *)os_log_type_t v134 = 136446210;
          *(void *)&v134[4] = "nw_endpoint_handler_report_data_stall";
          _os_log_impl(&dword_181A5C000, v92, v107, "%{public}s called with null handler, no backtrace", v134, 0xCu);
        }

        goto LABEL_180;
      }

      if (v108)
      {
        *(_DWORD *)os_log_type_t v134 = 136446466;
        *(void *)&v134[4] = "nw_endpoint_handler_report_data_stall";
        *(_WORD *)&v134[12] = 2082;
        *(void *)&v134[14] = v106;
        _os_log_impl( &dword_181A5C000,  v92,  v107,  "%{public}s called with null handler, dumping backtrace:%{public}s",  v134,  0x16u);
      }

      free(v106);
LABEL_181:
      if (v91) {
        free(v91);
      }
LABEL_118:

      LOWORD(v23) = -1;
      nw_path_t v2 = v118;
LABEL_119:
      char v5 = &unk_182665000;
LABEL_120:
      __int16 v80 = *(os_unfair_lock_s **)(a1 + 32);
      id v81 = v80 + 34;
      v119[0] = v4;
      v119[1] = v5[390];
      v119[2] = ___ZL39nw_connection_add_client_event_internalP24NWConcrete_nw_connection26nw_endpoint_client_event_tPU24objcproto13OS_xpc_object8NSObjectPU25objcproto14OS_nw_activityS2__block_invoke_119;
      v119[3] = &unk_189BC73F8;
      BOOL v120 = v80;
      os_log_type_t v121 = v2;
      os_log_type_t v122 = 6;
      BOOL v123 = (__int16)logging_description;
      os_log_type_t v124 = v23;
      id v125 = 0;
      os_unfair_lock_lock(v81);
      ___ZL39nw_connection_add_client_event_internalP24NWConcrete_nw_connection26nw_endpoint_client_event_tPU24objcproto13OS_xpc_object8NSObjectPU25objcproto14OS_nw_activityS2__block_invoke_119((uint64_t)v119);
      os_unfair_lock_unlock(v81);

      return;
    case 3:
      uint64_t v19 = *(void **)(*(void *)(a1 + 32) + 144LL);
      uint64_t v20 = 1;
LABEL_17:
      nw_endpoint_handler_report_connection_idle(v19, v20);
      LOWORD(v23) = -1;
      goto LABEL_120;
    case 4:
    case 5:
      uint64_t v6 = *(void **)(a1 + 48);
      if (!v6)
      {
        __nwlog_obj();
        uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)os_log_type_t v134 = 136446210;
        *(void *)&v134[4] = "nw_connection_add_client_event_internal_block_invoke";
        id v83 = (char *)_os_log_send_and_compose_impl();

        v132[0] = 16;
        buf[0] = 0;
        if (__nwlog_fault(v83, v132, buf))
        {
          if (v132[0] == 17)
          {
            __nwlog_obj();
            uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v85 = v132[0];
            if (os_log_type_enabled(v84, (os_log_type_t)v132[0]))
            {
              *(_DWORD *)os_log_type_t v134 = 136446210;
              *(void *)&v134[4] = "nw_connection_add_client_event_internal_block_invoke";
              _os_log_impl(&dword_181A5C000, v84, v85, "%{public}s called with null activity", v134, 0xCu);
            }
          }

          else if (buf[0])
          {
            int v94 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v95 = v132[0];
            BOOL v96 = os_log_type_enabled(v84, (os_log_type_t)v132[0]);
            if (v94)
            {
              if (v96)
              {
                *(_DWORD *)os_log_type_t v134 = 136446466;
                *(void *)&v134[4] = "nw_connection_add_client_event_internal_block_invoke";
                *(_WORD *)&v134[12] = 2082;
                *(void *)&v134[14] = v94;
                _os_log_impl( &dword_181A5C000,  v84,  v95,  "%{public}s called with null activity, dumping backtrace:%{public}s",  v134,  0x16u);
              }

              free(v94);
              goto LABEL_167;
            }

            if (v96)
            {
              *(_DWORD *)os_log_type_t v134 = 136446210;
              *(void *)&v134[4] = "nw_connection_add_client_event_internal_block_invoke";
              _os_log_impl(&dword_181A5C000, v84, v95, "%{public}s called with null activity, no backtrace", v134, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v109 = v132[0];
            if (os_log_type_enabled(v84, (os_log_type_t)v132[0]))
            {
              *(_DWORD *)os_log_type_t v134 = 136446210;
              *(void *)&v134[4] = "nw_connection_add_client_event_internal_block_invoke";
              _os_log_impl( &dword_181A5C000,  v84,  v109,  "%{public}s called with null activity, backtrace limit exceeded",  v134,  0xCu);
            }
          }
        }

    if (!v78) {
      return;
    }
    goto LABEL_181;
  }

  id v4 = (int *)(a2 + 176);
  char v5 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
  if (*(_DWORD *)(a2 + 176) != -1)
  {
    if ((*(_WORD *)(a2 + 188) & 1) == 0)
    {
      if ((v5 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v6 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v8 = *(_DWORD *)(a2 + 176);
          char v7 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447234;
          unint64_t v107 = "nw_http2_stream_close";
          id v108 = 2082;
          os_log_type_t v109 = (const char *)(a2 + 191);
          os_log_type_t v110 = 2080;
          BOOL v111 = (uint64_t)" ";
          os_log_type_t v112 = 1024;
          *(_DWORD *)id v113 = v7;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v8;
          _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> not sending RST_STREAM, since we are already closed from nghttp2's perspective",  buf,  0x2Cu);
        }
      }

      if (!v39) {
        return 1LL;
      }
      goto LABEL_181;
    }

    goto LABEL_85;
  }

  if ((v8 & 0x80000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v9 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
    {
      nw_endpoint_t v11 = *(_DWORD *)(v6 + 176);
      os_log_type_t v10 = *(_DWORD *)(v6 + 180);
      *(_DWORD *)buf = 136447490;
      BOOL v100 = "nw_protocol_http2_input_finished_block_invoke";
      id v101 = 2082;
      BOOL v102 = (const char *)(v6 + 191);
      id v103 = 2080;
      os_log_type_t v104 = " ";
      id v105 = 1024;
      os_log_type_t v106 = v10;
      unint64_t v107 = 1024;
      *(_DWORD *)id v108 = v11;
      *(_WORD *)&v108[4] = 1024;
      *(_DWORD *)&v108[6] = v11;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%d> stream %d not open, masking input_finished with disconnected",  buf,  0x32u);
    }
  }

  os_log_type_t v12 = *(unsigned __int16 *)(v6 + 188);
  nw_endpoint_t v13 = v12 | (*(unsigned __int8 *)(v6 + 190) << 16);
  if ((v12 & 0x40) == 0)
  {
    *(_BYTE *)(v6 + 190) = BYTE2(v13);
    *(_WORD *)(v6 + 18_Block_object_dispose((const void *)(v67 - 152), 8) = v13 | 0x40;
    goto LABEL_41;
  }

  return 1LL;
}

LABEL_99:
    goto LABEL_100;
  }

  if (v140 == OS_LOG_TYPE_DEFAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v58 = (os_log_s *)(id)gLogObj;
    os_log_type_t v65 = type[0];
    if (os_log_type_enabled(v58, type[0]))
    {
      if (v3 > 5) {
        char v66 = "unknown-mode";
      }
      else {
        char v66 = off_189BBBBC0[v3];
      }
      LODWORD(buf[0]) = 136446722;
      *(void *)((char *)buf + 4) = "nw_endpoint_flow_start_child";
      WORD6(buf[0]) = 2082;
      *(void *)((char *)buf + 14) = v66;
      WORD3(buf[1]) = 2082;
      *((void *)&buf[1] + 1) = "flow";
      _os_log_impl( &dword_181A5C000,  v58,  v65,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  (uint8_t *)buf,  0x20u);
    }

    goto LABEL_99;
  }

  id v61 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v58 = (os_log_s *)(id)gLogObj;
  os_log_type_t v62 = type[0];
  BOOL v63 = os_log_type_enabled(v58, type[0]);
  if (!v61)
  {
    if (v63)
    {
      if (v3 > 5) {
        char v67 = "unknown-mode";
      }
      else {
        char v67 = off_189BBBBC0[v3];
      }
      LODWORD(buf[0]) = 136446722;
      *(void *)((char *)buf + 4) = "nw_endpoint_flow_start_child";
      WORD6(buf[0]) = 2082;
      *(void *)((char *)buf + 14) = v67;
      WORD3(buf[1]) = 2082;
      *((void *)&buf[1] + 1) = "flow";
      _os_log_impl( &dword_181A5C000,  v58,  v62,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  (uint8_t *)buf,  0x20u);
    }

    goto LABEL_99;
  }

  if (v63)
  {
    if (v3 > 5) {
      uint64_t v64 = "unknown-mode";
    }
    else {
      uint64_t v64 = off_189BBBBC0[v3];
    }
    LODWORD(buf[0]) = 136446978;
    *(void *)((char *)buf + 4) = "nw_endpoint_flow_start_child";
    WORD6(buf[0]) = 2082;
    *(void *)((char *)buf + 14) = v64;
    WORD3(buf[1]) = 2082;
    *((void *)&buf[1] + 1) = "flow";
    LOWORD(buf[2]) = 2082;
    *(void *)((char *)&buf[2] + 2) = v61;
    _os_log_impl( &dword_181A5C000,  v58,  v62,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x2Au);
  }

  free(v61);
  if (v57) {
    goto LABEL_101;
  }
LABEL_205:
}

    free(v28);
    if (!v22) {
      return;
    }
LABEL_132:
    free(v22);
    return;
  }

  char v9 = *(_BYTE *)(a1 + 232);
  *(_BYTE *)(a1 + 232) = v9 & 0xFB | (4 * *a4);
  if ((v9 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      nw_endpoint_t v11 = (*(unsigned __int8 *)(a1 + 232) >> 2) & 1;
      *(_DWORD *)buf = 136447234;
      uint64_t v49 = "nw_protocol_ipv4_notify";
      os_log_type_t v50 = 2082;
      BOOL v51 = (void *)(a1 + 233);
      uint64_t v52 = 2080;
      os_log_type_t v53 = " ";
      id v54 = 2048;
      id v55 = (char *)(a1 + 96);
      os_log_type_t v56 = 1024;
      BOOL v57 = v11;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s%p segmentation offload notify enable %d",  buf,  0x30u);
    }
  }

  __break(1u);
  return result;
}

                if (v54) {
                  free(v54);
                }
                goto LABEL_74;
              }

              __nwlog_obj();
              id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v93 = type;
              if (os_log_type_enabled(v55, type))
              {
                *(_DWORD *)buf = 136446210;
                uint64_t v153 = "nw_flow_passthrough_notify";
                _os_log_impl( &dword_181A5C000,  v55,  v93,  "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child, backtrace limit exceeded",  buf,  0xCu);
              }
            }

            goto LABEL_99;
          case 0x19u:
LABEL_51:
            v147[0] = MEMORY[0x1895F87A8];
            v147[1] = 3221225472LL;
            v147[2] = ___ZL26nw_flow_passthrough_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke;
            v147[3] = &unk_189BB8610;
            v149 = v9;
            __int16 v148 = v146;
            nw_endpoint_handler_access_parent_flow_handler(v148, v147);

            goto LABEL_74;
          default:
LABEL_70:
            os_log_type_t v38 = *(void *)(v9 + 48);
            if (v38)
            {
LABEL_71:
              uint64_t v76 = *(void *)(v38 + 24);
              if (v76)
              {
                BOOL v77 = *(void (**)(void))(v76 + 160);
                if (v77) {
                  v77();
                }
              }
            }

            goto LABEL_74;
        }
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v20 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
LABEL_33:

        goto LABEL_34;
      }

      v138 = v9;
      os_log_t log = v20;
      os_log_type_t v135 = v14;
      __int16 v21 = v18;

      id v22 = v21;
      uint64_t v23 = *((_BYTE *)v18 + 268);

      if ((v23 & 1) != 0) {
        uint64_t v24 = "dry-run ";
      }
      else {
        uint64_t v24 = "";
      }
      id v25 = nw_endpoint_handler_copy_endpoint(v22);
      os_log_type_t v129 = nw_endpoint_get_logging_description(v25);
      id v26 = v22;
      BOOL v27 = v26;
      uint64_t v28 = v146->state;
      BOOL v127 = v24;
      else {
        BOOL v29 = off_189BBBBF0[v28];
      }
      id v125 = v29;
      BOOL v123 = v21 + 168;

      char v30 = v27;
      uint64_t v31 = v30;
      os_log_type_t v122 = v25;
      uint64_t v32 = "path";
      switch(v12->mode)
      {
        case 0:
          break;
        case 1:
          uint64_t v32 = "resolver";
          break;
        case 2:
          uint64_t v32 = nw_endpoint_flow_mode_string(v30[31]);
          break;
        case 3:
          uint64_t v32 = "proxy";
          break;
        case 4:
          uint64_t v32 = "fallback";
          break;
        case 5:
          uint64_t v32 = "transform";
          break;
        default:
          uint64_t v32 = "unknown-mode";
          break;
      }

      os_log_type_t v33 = v31;
      os_unfair_lock_lock((os_unfair_lock_t)v33 + 28);
      os_log_type_t v34 = v33[8];
      os_unfair_lock_unlock((os_unfair_lock_t)v33 + 28);

      uint64_t v35 = v34;
      os_log_type_t v36 = v35;
      if (a3 > 0x1A) {
        uint64_t v37 = "unknown";
      }
      else {
        uint64_t v37 = off_189BBE330[a3];
      }
      nw_endpoint_t v14 = v135;
      char v9 = v138;
      *(_DWORD *)buf = 136448002;
      uint64_t v153 = "nw_flow_passthrough_notify";
      int v154 = 2082;
      BOOL v155 = v123;
      int v156 = 2082;
      v157 = v127;
      v158 = 2082;
      nw_endpoint_t v159 = v129;
      v160 = 2082;
      id v161 = v125;
      char v162 = 2082;
      int v163 = v32;
      os_log_type_t v164 = 2114;
      nw_endpoint_t v165 = v35;
      id v166 = 2082;
      nw_endpoint_t v167 = v37;
      _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received notification %{public}s",  buf,  0x52u);
    }

    uint64_t v20 = log;
    goto LABEL_33;
  }

          if (v46->handle == &nw_protocol_ref_counted_handle)
          {
            uint64_t v64 = v46[1].callbacks;
            if (v64)
            {
              os_log_type_t v65 = (nw_protocol_callbacks *)((char *)v64 - 1);
              v46[1].callbacks = v65;
              if (!v65)
              {
                char v66 = *(void (***)(void))v46[1].flow_id;
                if (v66)
                {
                  *(void *)v46[1].flow_id = 0LL;
                  v66[2](v66);
                  _Block_release(v66);
                }

                if ((v46[1].flow_id[8] & 1) != 0)
                {
                  char v67 = *(const void **)v46[1].flow_id;
                  if (v67) {
                    _Block_release(v67);
                  }
                }

                free(v46);
              }
            }
          }

          goto LABEL_100;
        }
      }

      __nwlog_obj();
      uint64_t v75 = v46->identifier->name;
      *(_DWORD *)buf = 136446722;
      os_log_type_t v110 = "__nw_protocol_get_parameters";
      if (!v75) {
        uint64_t v75 = "invalid";
      }
      BOOL v111 = 2082;
      os_log_type_t v112 = (nw_protocol *)v75;
      id v113 = 2048;
      id v114 = v46;
      uint64_t v76 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      unint64_t v107 = 0;
      BOOL v77 = (char *)v76;
      if (__nwlog_fault(v76, &type, &v107))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v78 = (os_log_s *)__nwlog_obj();
          nw_endpoint_t v79 = type;
          if (!os_log_type_enabled(v78, type)) {
            goto LABEL_234;
          }
          __int16 v80 = v46->identifier->name;
          if (!v80) {
            __int16 v80 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v110 = "__nw_protocol_get_parameters";
          BOOL v111 = 2082;
          os_log_type_t v112 = (nw_protocol *)v80;
          id v113 = 2048;
          id v114 = v46;
          id v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_233:
          _os_log_impl(&dword_181A5C000, v78, v79, v81, buf, 0x20u);
          goto LABEL_234;
        }

        if (!v107)
        {
          __int16 v78 = (os_log_s *)__nwlog_obj();
          nw_endpoint_t v79 = type;
          if (!os_log_type_enabled(v78, type)) {
            goto LABEL_234;
          }
          os_log_type_t v104 = v46->identifier->name;
          if (!v104) {
            os_log_type_t v104 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v110 = "__nw_protocol_get_parameters";
          BOOL v111 = 2082;
          os_log_type_t v112 = (nw_protocol *)v104;
          id v113 = 2048;
          id v114 = v46;
          id v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
          goto LABEL_233;
        }

        os_log_type_t v95 = (char *)__nw_create_backtrace_string();
        __int16 v78 = (os_log_s *)__nwlog_obj();
        nw_endpoint_t v79 = type;
        BOOL v96 = os_log_type_enabled(v78, type);
        if (!v95)
        {
          if (!v96) {
            goto LABEL_234;
          }
          id v105 = v46->identifier->name;
          if (!v105) {
            id v105 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v110 = "__nw_protocol_get_parameters";
          BOOL v111 = 2082;
          os_log_type_t v112 = (nw_protocol *)v105;
          id v113 = 2048;
          id v114 = v46;
          id v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
          goto LABEL_233;
        }

        if (v96)
        {
          if (v46->identifier) {
            nw_endpoint_t v97 = v46->identifier->name;
          }
          else {
            nw_endpoint_t v97 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          os_log_type_t v110 = "__nw_protocol_get_parameters";
          BOOL v111 = 2082;
          os_log_type_t v112 = (nw_protocol *)v97;
          id v113 = 2048;
          id v114 = v46;
          os_log_type_t v115 = 2082;
          int v116 = v95;
          _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v95);
      }

      free(v44);
      if (!v38) {
        return;
      }
LABEL_119:
      BOOL v29 = (char *)v38;
LABEL_56:
      free(v29);
      return;
    }

    int v39 = (os_log_s *)__nwlog_obj();
    BOOL v40 = type;
    if (!os_log_type_enabled(v39, type)) {
      goto LABEL_118;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_protocol_udp_link_state";
    os_log_type_t v41 = "%{public}s called with null protocol";
LABEL_117:
    _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0xCu);
    goto LABEL_118;
  }

  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_protocol_udp_link_state";
    os_log_type_t v38 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v50 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v39 = (os_log_s *)__nwlog_obj();
      BOOL v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_118;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v53 = "nw_protocol_udp_link_state";
      os_log_type_t v41 = "%{public}s called with null udp";
      goto LABEL_117;
    }

    if (!v50)
    {
      int v39 = (os_log_s *)__nwlog_obj();
      BOOL v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_118;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v53 = "nw_protocol_udp_link_state";
      os_log_type_t v41 = "%{public}s called with null udp, backtrace limit exceeded";
      goto LABEL_117;
    }

    BOOL v44 = (char *)__nw_create_backtrace_string();
    int v39 = (os_log_s *)__nwlog_obj();
    BOOL v40 = type;
    BOOL v47 = os_log_type_enabled(v39, type);
    if (!v44)
    {
      if (!v47) {
        goto LABEL_118;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v53 = "nw_protocol_udp_link_state";
      os_log_type_t v41 = "%{public}s called with null udp, no backtrace";
      goto LABEL_117;
    }

    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v53 = "nw_protocol_udp_link_state";
      id v54 = 2082;
      id v55 = v44;
      os_log_type_t v46 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    goto LABEL_99;
  }

  id v4 = a3;
  char v5 = v4[2];

  if (v5 == 1)
  {
    if (gLogDatapath)
    {
      uint64_t v49 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v53 = "nw_protocol_udp_link_state";
        id v54 = 2082;
        id v55 = (char *)(a1 + 192);
        _os_log_impl(&dword_181A5C000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s udp flow controlled", buf, 0x16u);
      }
    }

    nw_endpoint_t v13 = *(_WORD *)(a1 + 190) | 1;
    goto LABEL_25;
  }

  if (!v5)
  {
    if (gLogDatapath)
    {
      BOOL v48 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v53 = "nw_protocol_udp_link_state";
        id v54 = 2082;
        id v55 = (char *)(a1 + 192);
        _os_log_impl(&dword_181A5C000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s udp flow resumed", buf, 0x16u);
      }
    }

    uint64_t v6 = *(_WORD *)(a1 + 190);
    char v7 = v6 & 0xFFFE;
    *(_WORD *)(a1 + 190) = v6 & 0xFFFE;
    if ((v6 & 2) != 0)
    {
      os_log_type_t v8 = *(void *)(a1 + 48);
      if (v8)
      {
        char v9 = *(void *)(v8 + 24);
        if (v9)
        {
          os_log_type_t v10 = *(void (**)(uint64_t, uint64_t))(v9 + 72);
          if (v10)
          {
            nw_endpoint_t v11 = *(void **)(v8 + 40);
            if (v11 == &nw_protocol_ref_counted_handle)
            {
              os_log_type_t v12 = *(void *)(v8 + 88);
              if (v12) {
                *(void *)(v8 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v12 + 1;
              }
            }

            if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              nw_endpoint_t v14 = *(void *)(a1 + 88);
              if (v14) {
                *(void *)(a1 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v14 + 1;
              }
              v10(v8, a1);
              if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
              {
                char v30 = *(void *)(a1 + 88);
                if (v30)
                {
                  uint64_t v31 = v30 - 1;
                  *(void *)(a1 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v31;
                  if (!v31)
                  {
                    uint64_t v32 = *(void (***)(void))(a1 + 64);
                    if (v32)
                    {
                      *(void *)(a1 + 64) = 0LL;
                      v32[2](v32);
                      _Block_release(v32);
                    }

                    if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                    {
                      os_log_type_t v33 = *(const void **)(a1 + 64);
                      if (v33) {
                        _Block_release(v33);
                      }
                    }

                    free((void *)a1);
                  }
                }
              }
            }

            else
            {
              v10(v8, a1);
            }

            if (v11 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v8 + 40) == &nw_protocol_ref_counted_handle)
            {
              os_log_type_t v34 = *(void *)(v8 + 88);
              if (v34)
              {
                uint64_t v35 = v34 - 1;
                *(void *)(v8 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v35;
                if (!v35)
                {
                  os_log_type_t v36 = *(void (***)(void))(v8 + 64);
                  if (v36)
                  {
                    *(void *)(v8 + 64) = 0LL;
                    v36[2](v36);
                    _Block_release(v36);
                  }

                  if ((*(_BYTE *)(v8 + 72) & 1) != 0)
                  {
                    uint64_t v37 = *(const void **)(v8 + 64);
                    if (v37) {
                      _Block_release(v37);
                    }
                  }

                  free((void *)v8);
                }
              }
            }

            char v7 = *(_WORD *)(a1 + 190);
          }
        }
      }

      nw_endpoint_t v13 = v7 & 0xFFFD;
LABEL_25:
      *(_WORD *)(a1 + 190) = v13;
    }
  }

  os_log_type_t v15 = *(void *)(a1 + 48);
  if (v15)
  {
    uint64_t v16 = *(void *)(v15 + 24);
    if (v16)
    {
      __int16 v17 = *(void (**)(uint64_t, uint64_t, _DWORD *))(v16 + 104);
      if (v17)
      {
        uint64_t v18 = *(void **)(v15 + 40);
        if (v18 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v19 = *(void *)(v15 + 88);
          if (v19) {
            *(void *)(v15 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v19 + 1;
          }
        }

        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v20 = *(void *)(a1 + 88);
          if (v20) {
            *(void *)(a1 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v20 + 1;
          }
          v17(v15, a1, v4);
          if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            __int16 v21 = *(void *)(a1 + 88);
            if (v21)
            {
              id v22 = v21 - 1;
              *(void *)(a1 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v22;
              if (!v22)
              {
                uint64_t v23 = *(void (***)(void))(a1 + 64);
                if (v23)
                {
                  *(void *)(a1 + 64) = 0LL;
                  v23[2](v23);
                  _Block_release(v23);
                }

                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  uint64_t v24 = *(const void **)(a1 + 64);
                  if (v24) {
                    _Block_release(v24);
                  }
                }

                free((void *)a1);
              }
            }
          }
        }

        else
        {
          v17(v15, a1, v4);
        }

        if (v18 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v15 + 40) == &nw_protocol_ref_counted_handle)
        {
          id v25 = *(void *)(v15 + 88);
          if (v25)
          {
            id v26 = v25 - 1;
            *(void *)(v15 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v26;
            if (!v26)
            {
              BOOL v27 = *(void (***)(void))(v15 + 64);
              if (v27)
              {
                *(void *)(v15 + 64) = 0LL;
                v27[2](v27);
                _Block_release(v27);
              }

              if ((*(_BYTE *)(v15 + 72) & 1) != 0)
              {
                uint64_t v28 = *(const void **)(v15 + 64);
                if (v28) {
                  _Block_release(v28);
                }
              }

              BOOL v29 = (char *)v15;
              goto LABEL_56;
            }
          }
        }
      }
    }
  }

      if (a6)
      {
        *(void *)(a6 + 64) = 0LL;
        *(void *)(a6 + 72) = 0LL;
      }

      return 0LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v56 = "__nw_frame_check_validity";
    BOOL v40 = (char *)_os_log_send_and_compose_impl();
    id v54 = OS_LOG_TYPE_ERROR;
    os_log_type_t v53 = 0;
    if (__nwlog_fault(v40, &v54, &v53))
    {
      if (v54 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v41 = (os_log_s *)__nwlog_obj();
        BOOL v42 = v54;
        if (!os_log_type_enabled(v41, v54)) {
          goto LABEL_97;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v56 = "__nw_frame_check_validity";
        os_log_type_t v43 = "%{public}s called with null frame";
        goto LABEL_96;
      }

      if (!v53)
      {
        os_log_type_t v41 = (os_log_s *)__nwlog_obj();
        BOOL v42 = v54;
        if (!os_log_type_enabled(v41, v54)) {
          goto LABEL_97;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v56 = "__nw_frame_check_validity";
        os_log_type_t v43 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_96;
      }

      os_log_type_t v46 = (char *)__nw_create_backtrace_string();
      os_log_type_t v41 = (os_log_s *)__nwlog_obj();
      BOOL v42 = v54;
      BOOL v47 = os_log_type_enabled(v41, v54);
      if (v46)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v56 = "__nw_frame_check_validity";
          BOOL v57 = 2082;
          os_log_type_t v58 = v46;
          _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v46);
        goto LABEL_97;
      }

      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v56 = "__nw_frame_check_validity";
        os_log_type_t v43 = "%{public}s called with null frame, no backtrace";
LABEL_96:
        _os_log_impl(&dword_181A5C000, v41, v42, v43, buf, 0xCu);
      }
    }

            os_release(v2);
            goto LABEL_100;
          }

          goto LABEL_97;
        }

        os_log_type_t v36 = v21;
        if ((*(_BYTE *)(a1 + 235) & 2) != 0) {
          uint64_t v37 = 4;
        }
        else {
          uint64_t v37 = 1;
        }
        *((_BYTE *)v35 + 2) = v37;
        hostname = nw_endpoint_get_hostname(v2);
        if (!hostname)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v58 = (os_log_s *)v3[131];
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            BOOL v100 = "nw_shoes_create_request";
            id v101 = 2082;
            BOOL v102 = a1 + 151;
            os_log_type_t v43 = "%{public}s %{public}s hostname is NULL";
            BOOL v44 = v58;
            os_log_type_t v56 = 22;
            goto LABEL_96;
          }

          goto LABEL_97;
        }

        int v39 = hostname;
        nw_endpoint_t v79 = alternate_port;
        BOOL v40 = strlen(hostname);
        os_log_type_t v41 = v40;
        if (v40 >= 0x100)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v42 = (os_log_s *)v3[131];
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447234;
            BOOL v100 = "nw_shoes_create_request";
            id v101 = 2082;
            BOOL v102 = a1 + 151;
            id v103 = 2082;
            os_log_type_t v104 = v39;
            id v105 = 2048;
            *(void *)os_log_type_t v106 = v41;
            *(_WORD *)&v106[8] = 2048;
            unint64_t v107 = 255LL;
            os_log_type_t v43 = "%{public}s %{public}s Hostname too long: %{public}s %zu > %zu";
            BOOL v44 = v42;
LABEL_82:
            os_log_type_t v56 = 52;
LABEL_96:
            _os_log_impl(&dword_181A5C000, v44, OS_LOG_TYPE_ERROR, v43, buf, v56);
            goto LABEL_97;
          }

          goto LABEL_97;
        }

        *((_BYTE *)v35 + 5) = v40;
        memcpy(v35 + 3, v39, v40);
        BOOL v57 = v41 + 4;
        __int16 v21 = v36;
        os_log_type_t type = nw_endpoint_type_host;
        if (!v26) {
          goto LABEL_121;
        }
        goto LABEL_117;
      }

      nw_endpoint_t v79 = alternate_port;
      if ((*(_BYTE *)(a1 + 235) & 2) != 0) {
        uint64_t v45 = 8;
      }
      else {
        uint64_t v45 = 7;
      }
      *((_BYTE *)v35 + 2) = v45;
      bonjour_service_name = nw_endpoint_get_bonjour_service_name(v2);
      bonjour_service_os_log_type_t type = nw_endpoint_get_bonjour_service_type(v2);
      endpoint = v2;
      bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(v2);
      if (bonjour_service_name)
      {
        uint64_t v49 = strlen(bonjour_service_name) + 1;
        __int16 v80 = v21;
        if (bonjour_service_type) {
          goto LABEL_70;
        }
      }

      else
      {
        uint64_t v49 = 1LL;
        __int16 v80 = v21;
        if (bonjour_service_type)
        {
LABEL_70:
          os_log_type_t v50 = strlen(bonjour_service_type) + 1;
          BOOL v77 = v26;
          __int16 v78 = v22;
          if (bonjour_service_domain)
          {
LABEL_71:
            BOOL v51 = strlen(bonjour_service_domain) + 1;
            goto LABEL_79;
          }

  if (v41) {
LABEL_100:
  }
    free(v41);
LABEL_101:
  uint64_t v24 = 0LL;
LABEL_23:

LABEL_24:
  nw_listener_set_queue(v17, (dispatch_queue_t)v24);

  nw_listener_start(v17);
  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  }
  id v26 = (os_log_s *)(id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    BOOL v27 = (char *)v19[1];
    *(_DWORD *)buf = 136446722;
    char v66 = "nw_candidate_manager_start_advertise";
    char v67 = 2048;
    os_log_type_t v68 = v27;
    uint64_t v69 = 2112;
    __int16 v70 = v17;
    _os_log_impl(&dword_181A5C000, v26, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Created listener %@", buf, 0x20u);
  }

  os_log_type_t v8 = 1LL;
LABEL_16:

  return v8;
}

  if (v47) {
    free(v47);
  }
  v229 = -1;
  id v25 = v225;
LABEL_102:
  uint64_t v230 = v15;
  if (v228) {
    int v233 = 0;
  }
  if (gLogDatapath)
  {
    id v171 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136446722;
      *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = v25;
      WORD1(buf[2]) = 1024;
      HIDWORD(buf[2]) = v15;
      _os_log_impl( &dword_181A5C000,  v171,  OS_LOG_TYPE_DEBUG,  "%{public}s moved (%u bytes, %u frames) from input_frames_pending_delivery",  (uint8_t *)buf,  0x18u);
    }
  }

  if ((_DWORD)v15 && (!v232 || !v231))
  {
    if (!gLogDatapath) {
      goto LABEL_147;
    }
    uint64_t v64 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_147;
    }
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    os_log_type_t v65 = "%{public}s returning frames only from input_frames_pending_delivery";
LABEL_464:
    _os_log_impl(&dword_181A5C000, v64, OS_LOG_TYPE_DEBUG, v65, (uint8_t *)buf, 0xCu);
    goto LABEL_147;
  }

    disconnected(a2, a1);
    goto LABEL_100;
  }

  __int16 v17 = v16->handle;
  if (v17 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v18 = v16[1].callbacks;
    if (v18) {
      v16[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
    }
  }

  uint64_t v19 = a1->handle;
  if (v19 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v20 = a1[1].callbacks;
    if (v20) {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v20->add_input_handler + 1);
    }
  }

  __int16 v21 = v16->callbacks;
  if (v21)
  {
    disconnect = (void (*)(nw_protocol *, nw_protocol *))v21->disconnect;
    if (disconnect)
    {
      disconnect(v16, a1);
      goto LABEL_39;
    }
  }

  __nwlog_obj();
  name = v16->identifier->name;
  *(_DWORD *)buf = 136446722;
  os_log_type_t v129 = "__nw_protocol_disconnect";
  if (!name) {
    name = "invalid";
  }
  os_log_type_t v130 = 2082;
  nw_endpoint_t v131 = (nw_protocol *)name;
  os_log_type_t v132 = 2048;
  BOOL v133 = v16;
  __int16 v78 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v126 = 0;
  if (__nwlog_fault(v78, &type, &v126))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v79 = (os_log_s *)__nwlog_obj();
      __int16 v80 = type;
      if (!os_log_type_enabled(v79, type)) {
        goto LABEL_282;
      }
      id v81 = v16->identifier->name;
      if (!v81) {
        id v81 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v129 = "__nw_protocol_disconnect";
      os_log_type_t v130 = 2082;
      nw_endpoint_t v131 = (nw_protocol *)v81;
      os_log_type_t v132 = 2048;
      BOOL v133 = v16;
      uint64_t v82 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
      goto LABEL_281;
    }

    if (!v126)
    {
      nw_endpoint_t v79 = (os_log_s *)__nwlog_obj();
      __int16 v80 = type;
      if (!os_log_type_enabled(v79, type)) {
        goto LABEL_282;
      }
      BOOL v117 = v16->identifier->name;
      if (!v117) {
        BOOL v117 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v129 = "__nw_protocol_disconnect";
      os_log_type_t v130 = 2082;
      nw_endpoint_t v131 = (nw_protocol *)v117;
      os_log_type_t v132 = 2048;
      BOOL v133 = v16;
      uint64_t v82 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
      goto LABEL_281;
    }

    os_log_type_t v98 = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v79 = (os_log_s *)__nwlog_obj();
    __int16 v80 = type;
    id v99 = os_log_type_enabled(v79, type);
    if (v98)
    {
      if (v99)
      {
        BOOL v100 = v16->identifier->name;
        if (!v100) {
          BOOL v100 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v129 = "__nw_protocol_disconnect";
        os_log_type_t v130 = 2082;
        nw_endpoint_t v131 = (nw_protocol *)v100;
        os_log_type_t v132 = 2048;
        BOOL v133 = v16;
        os_log_type_t v134 = 2082;
        os_log_type_t v135 = v98;
        _os_log_impl( &dword_181A5C000,  v79,  v80,  "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v98);
      goto LABEL_282;
    }

    if (v99)
    {
      os_log_type_t v121 = v16->identifier->name;
      if (!v121) {
        os_log_type_t v121 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v129 = "__nw_protocol_disconnect";
      os_log_type_t v130 = 2082;
      nw_endpoint_t v131 = (nw_protocol *)v121;
      os_log_type_t v132 = 2048;
      BOOL v133 = v16;
      uint64_t v82 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
LABEL_281:
      _os_log_impl(&dword_181A5C000, v79, v80, v82, buf, 0x20u);
    }
  }

      if ((*(_WORD *)(v54 + 273) & 8) != 0 && (*(_DWORD *)(v54 + 232) - 8) >= 3)
      {
        os_log_type_t v68 = *(void **)(v54 + 244);
        *(void *)(v54 + 244) = 0LL;

        id v54 = *(void *)(*(void *)(a1 + 40) + 8LL);
      }

      uint64_t v69 = *(void **)(v54 + 136);
      if (v69)
      {
        free(v69);
        *(void *)(v54 + 136) = 0LL;
      }

      *(void *)(v54 + 4_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
      __int16 v70 = v54 + 48;
      *(_DWORD *)(v70 + 204) = 0;
      *(_DWORD *)(v70 + 216) = 0;
      *(void *)(v70 + 112) = 0LL;
      *(void *)(v70 + 120) = 0LL;
      *(void *)(v70 + 180) = 2LL;
      *(_WORD *)(v70 + 225) &= 0xFDF7u;
      _Block_object_dispose(type, 8);

      id v22 = &qword_18C45F000;
    }
  }

  nw_ws_write_header(v27 + 48, *(void **)(a1 + 32), 8, 0x3EAu, 0LL, 0, 1);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v96 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
  {
    nw_endpoint_t v97 = *(void *)(*(void *)(a1 + 40) + 8LL) + 275LL;
    *(_DWORD *)buf = 136446466;
    *(void *)&_OWORD buf[4] = "nw_protocol_copy_ws_definition_block_invoke_2";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v97;
    _os_log_impl(&dword_181A5C000, v96, OS_LOG_TYPE_ERROR, "%{public}s %{public}s input rsv bits are not 0", buf, 0x16u);
  }

      free(backtrace_string);
    }

    if (v41) {
      free(v41);
    }

    goto LABEL_113;
  }

  if (!v5)
  {
    __nwlog_obj();
    BOOL v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v83 = "nw_interface_use_observer_create";
    uint64_t v45 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v81.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v45, &v81, &type))
    {
      if (LOBYTE(v81.receiver) == 17)
      {
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v47 = (os_log_type_t)v81.receiver;
        if (os_log_type_enabled(v46, (os_log_type_t)v81.receiver))
        {
          *(_DWORD *)buf = 136446210;
          id v83 = "nw_interface_use_observer_create";
          _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s called with null queue", buf, 0xCu);
        }
      }

      else if (type)
      {
        id v61 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v62 = (os_log_type_t)v81.receiver;
        BOOL v63 = os_log_type_enabled(v46, (os_log_type_t)v81.receiver);
        if (v61)
        {
          if (v63)
          {
            *(_DWORD *)buf = 136446466;
            id v83 = "nw_interface_use_observer_create";
            uint64_t v84 = 2082;
            BOOL v85 = v61;
            _os_log_impl( &dword_181A5C000,  v46,  v62,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v61);
          goto LABEL_105;
        }

        if (v63)
        {
          *(_DWORD *)buf = 136446210;
          id v83 = "nw_interface_use_observer_create";
          _os_log_impl(&dword_181A5C000, v46, v62, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v71 = (os_log_type_t)v81.receiver;
        if (os_log_type_enabled(v46, (os_log_type_t)v81.receiver))
        {
          *(_DWORD *)buf = 136446210;
          id v83 = "nw_interface_use_observer_create";
          _os_log_impl( &dword_181A5C000,  v46,  v71,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

            goto LABEL_100;
          }

          if (!(_BYTE)v154)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            nw_endpoint_t v14 = (os_log_s *)(id)gLogObj;
            BOOL v77 = type[0];
            if (os_log_type_enabled(v14, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
              _os_log_impl( &dword_181A5C000,  v14,  v77,  "%{public}s Cannot use nw_connection_group on inline contexts, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_99;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          nw_endpoint_t v14 = (os_log_s *)(id)gLogObj;
          BOOL v29 = type[0];
          char v30 = os_log_type_enabled(v14, type[0]);
          if (!backtrace_string)
          {
            if (v30)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
              _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s Cannot use nw_connection_group on inline contexts, no backtrace",  buf,  0xCu);
            }

            goto LABEL_99;
          }

          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
            nw_endpoint_t v165 = 2082;
            *(void *)id v166 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s Cannot use nw_connection_group on inline contexts, dumping backtrace:%{public}s",  buf,  0x16u);
          }

  if (v17) {
    free(v17);
  }
  return 0LL;
}

    if (v39) {
      free(v39);
    }
    goto LABEL_33;
  }

  __nwlog_obj();
  os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&_OWORD buf[4] = "nw_parameters_inherit_protocol_instances";
  os_log_type_t v33 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v67 = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v37 = type[0];
    if (os_log_type_enabled(v34, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&_OWORD buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_181A5C000, v34, v37, "%{public}s called with null join_parameters", buf, 0xCu);
    }

    goto LABEL_93;
  }

  if (!v67)
  {
    __nwlog_obj();
    os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v59 = type[0];
    if (os_log_type_enabled(v34, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&_OWORD buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl( &dword_181A5C000,  v34,  v59,  "%{public}s called with null join_parameters, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_93;
  }

  uint64_t v49 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v50 = type[0];
  BOOL v51 = os_log_type_enabled(v34, type[0]);
  if (!v49)
  {
    if (v51)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&_OWORD buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_181A5C000, v34, v50, "%{public}s called with null join_parameters, no backtrace", buf, 0xCu);
    }

    goto LABEL_93;
  }

  if (v51)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&_OWORD buf[4] = "nw_parameters_inherit_protocol_instances";
    uint64_t v69 = 2082;
    __int16 v70 = v49;
    _os_log_impl( &dword_181A5C000,  v34,  v50,  "%{public}s called with null join_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v49);
  if (v33) {
    goto LABEL_95;
  }
LABEL_34:
}

    BOOL v27 = v37;
    uint64_t v28 = v38;
    BOOL v29 = 12;
    goto LABEL_52;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
    char v5 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v111) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
      os_log_type_t v8 = "%{public}s called with null masque";
      goto LABEL_99;
    }

    if ((_BYTE)v111)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type[0];
      BOOL v42 = os_log_type_enabled(v37, type[0]);
      if (backtrace_string)
      {
        if (!v42) {
          goto LABEL_85;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = backtrace_string;
        os_log_type_t v41 = "%{public}s called with null masque, dumping backtrace:%{public}s";
LABEL_84:
        _os_log_impl(&dword_181A5C000, v37, v38, v41, buf, 0x16u);
LABEL_85:
        free(backtrace_string);
        if (!v5) {
          return 0LL;
        }
        goto LABEL_54;
      }

      if (!v42) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
      os_log_type_t v8 = "%{public}s called with null masque, no backtrace";
    }

    else
    {
      uint64_t v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
      os_log_type_t v8 = "%{public}s called with null masque, backtrace limit exceeded";
    }

    goto LABEL_99;
  }

  if (a1->default_input_handler)
  {
    if ((handle[529] & 1) != 0) {
      return 0LL;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    id v4 = handle + 531;
    *(_DWORD *)buf = 136446722;
    *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = handle + 531;
    *(_WORD *)&buf[22] = 2080;
    os_log_type_t v124 = " ";
    char v5 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v111) = 0;
    if (__nwlog_fault(v5, type, &v111))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v6 = gprivacy_proxyLogObj;
        char v7 = type[0];
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v4;
          *(_WORD *)&buf[22] = 2080;
          os_log_type_t v124 = " ";
          os_log_type_t v8 = "%{public}s %{public}s%sProtocol instance already has default input handler";
LABEL_50:
          BOOL v27 = (os_log_s *)v6;
          uint64_t v28 = v7;
LABEL_51:
          BOOL v29 = 32;
LABEL_52:
          _os_log_impl(&dword_181A5C000, v27, v28, v8, buf, v29);
        }
      }

      else if ((_BYTE)v111)
      {
        uint64_t v23 = (char *)__nw_create_backtrace_string();
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v24 = (os_log_s *)gprivacy_proxyLogObj;
        id v25 = type[0];
        id v26 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, type[0]);
        if (v23)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v4;
            *(_WORD *)&buf[22] = 2080;
            os_log_type_t v124 = " ";
            LOWORD(v125) = 2082;
            *(void *)((char *)&v125 + 2) = v23;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s %{public}s%sProtocol instance already has default input handler, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v23);
        }

        else if (v26)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v4;
          *(_WORD *)&buf[22] = 2080;
          os_log_type_t v124 = " ";
          os_log_type_t v8 = "%{public}s %{public}s%sProtocol instance already has default input handler, no backtrace";
          BOOL v27 = v24;
          uint64_t v28 = v25;
          goto LABEL_51;
        }
      }

      else
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v6 = gprivacy_proxyLogObj;
        char v7 = type[0];
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&_OWORD buf[4] = "nw_protocol_masque_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = v4;
          *(_WORD *)&buf[22] = 2080;
          os_log_type_t v124 = " ";
          os_log_type_t v8 = "%{public}s %{public}s%sProtocol instance already has default input handler, backtrace limit exceeded";
          goto LABEL_50;
        }
      }
    }

    if (!v45) {
      goto LABEL_66;
    }
LABEL_100:
    free(v45);
    goto LABEL_66;
  }

  return 1LL;
}

      uint64_t v20 = 0LL;
      goto LABEL_100;
    }
  }

  uint64_t v20 = 0LL;
LABEL_101:

  return v20;
}

  [MEMORY[0x189607968] numberWithBool:self->_reduceBuffering];
  char v66 = (void *)objc_claimAutoreleasedReturnValue();
  [v4 setObject:v66 forKey:@"reduceBuffering"];

  has = (__int16)self->_has;
  if ((has & 0x100) == 0)
  {
LABEL_20:
    if ((has & 0x2000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_101;
  }

        _os_log_impl(&dword_181A5C000, v57, v58, v60, buf, 0x12u);
        goto LABEL_100;
      }

      os_log_type_t v10 = *(void *)(v9 + 16);
      nw_endpoint_t v11 = *(nw_frame ***)(v9 + 24);
      if (v10)
      {
        *(void *)(v10 + 24) = v11;
        nw_endpoint_t v11 = *(nw_frame ***)(v9 + 24);
      }

      else
      {
        a1->tqh_last = v11;
      }

      *nw_endpoint_t v11 = (nw_frame *)v10;
      *(void *)(v9 + 16) = 0LL;
      *(void *)(v9 + 24) = 0LL;
      if (!*v3) {
        break;
      }
      --*v3;
LABEL_31:
      if ((*(_WORD *)(v9 + 204) & 0x100) == 0
        || !g_channel_check_validity
        || ((uint64_t (*)(uint64_t, void, unsigned int *))g_channel_check_validity)( v9,  *(void *)(v9 + 88),  a3))
      {
        uint64_t v28 = *(void **)(v9 + 112);
        if (v28) {
          free(v28);
        }
      }

      nw_frame_reset(v9, 0LL, 0, 0LL, 0LL);
      os_release((void *)v9);
      if (*v3 <= 0x14u) {
        goto LABEL_38;
      }
    }

    pthread_once(v6, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    id v91 = v8;
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    nw_endpoint_t v88 = 0;
    if (__nwlog_fault(v12, &type, &v88))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(v6, nwlog_legacy_init_once);
        networkd_settings_init();
        nw_endpoint_t v13 = (os_log_s *)v7[131];
        nw_endpoint_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          id v91 = v8;
          os_log_type_t v15 = v13;
          uint64_t v16 = v14;
          __int16 v17 = "%{public}s http2_transport count attempted to decrement below zero";
LABEL_27:
          _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
        }
      }

      else if (v88)
      {
        uint64_t v18 = v7;
        uint64_t v19 = v6;
        uint64_t v20 = v8;
        __int16 v21 = (char *)__nw_create_backtrace_string();
        id v22 = v19;
        pthread_once(v19, nwlog_legacy_init_once);
        networkd_settings_init();
        char v7 = v18;
        uint64_t v23 = (os_log_s *)v18[131];
        uint64_t v24 = type;
        id v25 = os_log_type_enabled(v23, type);
        if (v21)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            id v91 = v20;
            os_log_type_t v92 = 2082;
            *(void *)BOOL v93 = v21;
            _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v21);
          os_log_type_t v8 = v20;
          uint64_t v6 = v22;
          char v5 = &qword_18C45F000;
          goto LABEL_28;
        }

        os_log_type_t v8 = v20;
        uint64_t v6 = v22;
        char v5 = &qword_18C45F000;
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          id v91 = v8;
          os_log_type_t v15 = v23;
          uint64_t v16 = v24;
          __int16 v17 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
          goto LABEL_27;
        }
      }

      else
      {
        pthread_once(v6, nwlog_legacy_init_once);
        networkd_settings_init();
        id v26 = (os_log_s *)v7[131];
        BOOL v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          id v91 = v8;
          os_log_type_t v15 = v26;
          uint64_t v16 = v27;
          __int16 v17 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
          goto LABEL_27;
        }
      }
    }

        free(v28);
        goto LABEL_100;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v63 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v29, v39, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v52 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v63 = "nw_necp_append_tlv";
        _os_log_impl( &dword_181A5C000,  v29,  v52,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      free(backtrace_string);
      goto LABEL_122;
    }

    if (!v48) {
      goto LABEL_122;
    }
    *(_DWORD *)buf = 136446210;
    id v55 = "nw_http1_on_headers_complete";
    BOOL v42 = "%{public}s called with null parsed_fields, no backtrace";
LABEL_121:
    _os_log_impl(&dword_181A5C000, v40, v41, v42, buf, 0xCu);
LABEL_122:
    if (v39) {
      free(v39);
    }
    return 0xFFFFFFFFLL;
  }

  if (*(_BYTE *)(a1 + 74) && *(_BYTE *)(a1 + 75))
  {
    id v4 = *(_WORD *)(a1 + 82);
    if ((v4 & 2) == 0) {
      goto LABEL_16;
    }
LABEL_10:
    if ((*(_BYTE *)(v1 + 158) & 1) != 0) {
      goto LABEL_27;
    }
    goto LABEL_11;
  }

  id v4 = *(_WORD *)(a1 + 82);
  if ((v4 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_16:
  if (*(_BYTE *)(a1 + 72) == 1
    || (os_log_type_t v10 = *(unsigned __int16 *)(a1 + 84), (v10 - 100) < 0x64)
    || v10 == 204
    || v10 == 304
    || (v4 & 0x40) != 0)
  {
    if ((*(_BYTE *)(v1 + 158) & 1) != 0) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  if ((v4 & 0x208) == 0x200) {
    goto LABEL_10;
  }
  if ((v4 & 0x28) != 0)
  {
    if ((*(_BYTE *)(v1 + 158) & 1) != 0) {
      goto LABEL_27;
    }
LABEL_26:
    if (gLogDatapath)
    {
      char v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v49 = *(void *)(v1 + 488);
        os_log_type_t v50 = *(_DWORD *)(*(void *)(v1 + 480) + 372LL);
        BOOL v51 = *(_DWORD *)(v1 + 860);
        if (v49) {
          LODWORD(v49) = *(_DWORD *)(v49 + 424);
        }
        *(_DWORD *)buf = 136447490;
        id v55 = "nw_http1_on_headers_complete";
        os_log_type_t v56 = 2082;
        BOOL v57 = (char *)(v1 + 74);
        os_log_type_t v58 = 2080;
        os_log_type_t v59 = " ";
        __int16 v60 = 1024;
        id v61 = v50;
        os_log_type_t v62 = 1024;
        BOOL v63 = v51;
        uint64_t v64 = 1024;
        os_log_type_t v65 = v49;
        char v9 = "%{public}s %{public}s%s<i%u:c%u:s%u> http (headers) should keep alive";
LABEL_104:
        _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_DEBUG, v9, buf, 0x32u);
        goto LABEL_27;
      }
    }

    goto LABEL_27;
  }

  if ((*(_BYTE *)(v1 + 158) & 1) != 0) {
    goto LABEL_27;
  }
LABEL_11:
  if (gLogDatapath)
  {
    char v5 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(v1 + 488);
      char v7 = *(_DWORD *)(*(void *)(v1 + 480) + 372LL);
      os_log_type_t v8 = *(_DWORD *)(v1 + 860);
      if (v6) {
        LODWORD(v6) = *(_DWORD *)(v6 + 424);
      }
      *(_DWORD *)buf = 136447490;
      id v55 = "nw_http1_on_headers_complete";
      os_log_type_t v56 = 2082;
      BOOL v57 = (char *)(v1 + 74);
      os_log_type_t v58 = 2080;
      os_log_type_t v59 = " ";
      __int16 v60 = 1024;
      id v61 = v7;
      os_log_type_t v62 = 1024;
      BOOL v63 = v8;
      uint64_t v64 = 1024;
      os_log_type_t v65 = v6;
      char v9 = "%{public}s %{public}s%s<i%u:c%u:s%u> http (headers) should not keep alive";
      goto LABEL_104;
    }
  }

    if (*((_BYTE *)v12 + 1537))
    {
      os_log_type_t v140 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v140, OS_LOG_TYPE_DEBUG))
      {
        int v141 = *(_DWORD *)(v45 + 372);
        __int128 v142 = *(_DWORD *)(v45 + 336);
        *(_DWORD *)buf = 136447490;
        *(void *)&_OWORD buf[4] = "nw_http1_remove_connection";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v45 + 74;
        *(_WORD *)&buf[22] = 2080;
        nw_endpoint_t v209 = (uint64_t)" ";
        *(_WORD *)nw_endpoint_t v210 = 1024;
        *(_DWORD *)&v210[2] = v141;
        *(_WORD *)&v210[6] = 2048;
        *(void *)&v210[8] = v46;
        *(_WORD *)&v210[16] = 1024;
        *(_DWORD *)&v210[18] = v142;
        _os_log_impl( &dword_181A5C000,  v140,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> removed connection %p, now have %u connections",  buf,  0x36u);
      }
    }

    goto LABEL_100;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&_OWORD buf[4] = "nw_http1_tear_down_connection";
  id v114 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(type) = 16;
  LOBYTE(v213) = 0;
  if (type == 17)
  {
    os_log_type_t v115 = (os_log_s *)__nwlog_obj();
    int v116 = type;
    if (!os_log_type_enabled(v115, (os_log_type_t)type)) {
      goto LABEL_338;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&_OWORD buf[4] = "nw_http1_tear_down_connection";
    BOOL v117 = "%{public}s called with null http1_connection";
    goto LABEL_337;
  }

  if (!(_BYTE)v213)
  {
    os_log_type_t v115 = (os_log_s *)__nwlog_obj();
    int v116 = type;
    if (!os_log_type_enabled(v115, (os_log_type_t)type)) {
      goto LABEL_338;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&_OWORD buf[4] = "nw_http1_tear_down_connection";
    BOOL v117 = "%{public}s called with null http1_connection, backtrace limit exceeded";
    goto LABEL_337;
  }

  id v169 = (char *)__nw_create_backtrace_string();
  os_log_type_t v115 = (os_log_s *)__nwlog_obj();
  int v116 = type;
  v170 = os_log_type_enabled(v115, (os_log_type_t)type);
  if (!v169)
  {
    if (!v170) {
      goto LABEL_338;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&_OWORD buf[4] = "nw_http1_tear_down_connection";
    BOOL v117 = "%{public}s called with null http1_connection, no backtrace";
    goto LABEL_337;
  }

  if (v170)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&_OWORD buf[4] = "nw_http1_tear_down_connection";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&void buf[14] = v169;
    _os_log_impl( &dword_181A5C000,  v115,  v116,  "%{public}s called with null http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v169);
  if (v114) {
    goto LABEL_339;
  }
}

  if (v39) {
    free(v39);
  }
LABEL_29:
  id v26 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  BOOL v27 = *(_DWORD *)(a2 + 176);
  if (!v26) {
    goto LABEL_78;
  }
LABEL_30:
  *(_DWORD *)(v26 + 176) = v27;
LABEL_31:
  uint64_t v28 = *(void *)(a1[4] + 8LL);
  BOOL v29 = *(void *)(v28 + 24);
  char v30 = *(void *)(v29 + 32);
  if (!v30 && !*(void *)(v29 + 40)) {
    char v30 = 0LL;
  }
  *(void *)(v28 + 24) = v30;
  return 1LL;
}

  if (v56) {
    free(v56);
  }
  os_log_type_t v15 = 0;
LABEL_22:

  return v15;
}

  __break(1u);
  return result;
}

    if (v74) {
      free(v74);
    }
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), 0LL, *(void **)(a1 + 64), 0LL, 36);
    id v83 = 0LL;
    goto LABEL_139;
  }

          if (v45) {
            free(v45);
          }
          dispatch_async(v7[4], v10);
          goto LABEL_102;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        BOOL v77 = "nw_service_connector_cancel_active_connection";
        __int16 v78 = 2114;
        nw_endpoint_t v79 = (size_t)v11;
        uint64_t v19 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v74 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v25 = (os_log_s *)(id)gLogObj;
          id v26 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)buf = 136446466;
            BOOL v77 = "nw_service_connector_cancel_active_connection";
            __int16 v78 = 2114;
            nw_endpoint_t v79 = (size_t)v11;
            _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Specified endpoint %{public}@ is not an address endpoint",  buf,  0x16u);
          }

            if (!v54) {
              goto LABEL_102;
            }
            goto LABEL_100;
          }

          __nwlog_obj();
          BOOL v96 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          id v171 = "nw_necp_append_tlv";
          BOOL v93 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          nw_endpoint_t v165 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_t v97 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              id v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_181A5C000, v94, v97, "%{public}s called with null beyond", buf, 0xCu);
            }
          }

          else if (v165)
          {
            os_log_type_t v126 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v127 = type;
            os_log_type_t v128 = os_log_type_enabled(v94, type);
            if (v126)
            {
              if (v128)
              {
                *(_DWORD *)buf = 136446466;
                id v171 = "nw_necp_append_tlv";
                int v172 = 2082;
                *(void *)uint64_t v173 = v126;
                _os_log_impl( &dword_181A5C000,  v94,  v127,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v126);
              if (!v93) {
                goto LABEL_102;
              }
LABEL_313:
              os_log_type_t v65 = (char *)v93;
              goto LABEL_101;
            }

            if (v128)
            {
              *(_DWORD *)buf = 136446210;
              id v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_181A5C000, v94, v127, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v152 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              id v171 = "nw_necp_append_tlv";
              _os_log_impl( &dword_181A5C000,  v94,  v152,  "%{public}s called with null beyond, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v92 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          id v171 = "nw_necp_append_tlv";
          BOOL v93 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          nw_endpoint_t v165 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v95 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              id v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_181A5C000, v94, v95, "%{public}s called with null tlv_start", buf, 0xCu);
            }
          }

          else if (v165)
          {
            BOOL v123 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v124 = type;
            id v125 = os_log_type_enabled(v94, type);
            if (v123)
            {
              if (v125)
              {
                *(_DWORD *)buf = 136446466;
                id v171 = "nw_necp_append_tlv";
                int v172 = 2082;
                *(void *)uint64_t v173 = v123;
                _os_log_impl( &dword_181A5C000,  v94,  v124,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v123);
LABEL_312:
              if (!v93) {
                goto LABEL_102;
              }
              goto LABEL_313;
            }

            if (v125)
            {
              *(_DWORD *)buf = 136446210;
              id v171 = "nw_necp_append_tlv";
              _os_log_impl( &dword_181A5C000,  v94,  v124,  "%{public}s called with null tlv_start, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            int v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v151 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              id v171 = "nw_necp_append_tlv";
              _os_log_impl( &dword_181A5C000,  v94,  v151,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        goto LABEL_312;
      }

      free(v57);
      if (!v41) {
        return;
      }
LABEL_153:
      os_log_type_t v87 = (char *)v41;
LABEL_167:
      free(v87);
      return;
    }

    BOOL v42 = (os_log_s *)__nwlog_obj();
    os_log_type_t v43 = type;
    if (!os_log_type_enabled(v42, type)) {
      goto LABEL_152;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
    BOOL v44 = "%{public}s called with null http3_stream";
LABEL_151:
    _os_log_impl(&dword_181A5C000, v42, v43, v44, buf, 0xCu);
    goto LABEL_152;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
    os_log_type_t v41 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v92 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = type;
      if (!os_log_type_enabled(v42, type)) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
      BOOL v44 = "%{public}s called with null other_protocol";
      goto LABEL_151;
    }

    if (!v92)
    {
      BOOL v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = type;
      if (!os_log_type_enabled(v42, type)) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
      BOOL v44 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_151;
    }

    BOOL v57 = (char *)__nw_create_backtrace_string();
    BOOL v42 = (os_log_s *)__nwlog_obj();
    os_log_type_t v43 = type;
    __int16 v60 = os_log_type_enabled(v42, type);
    if (!v57)
    {
      if (!v60) {
        goto LABEL_152;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
      BOOL v44 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_151;
    }

    if (v60)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
      BOOL v96 = 2082;
      nw_endpoint_t v97 = v57;
      os_log_type_t v59 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    goto LABEL_99;
  }

  id v4 = *((_DWORD *)handle + 93);
  if (v4 > 8) {
    return;
  }
  if (((1 << v4) & 0x67) != 0)
  {
    char v5 = handle + 736;
    if ((*((_WORD *)handle + 368) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        id v61 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v62 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
          BOOL v63 = *((void *)handle + 30);
          *(_DWORD *)buf = 136447234;
          os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
          BOOL v96 = 2082;
          nw_endpoint_t v97 = handle + 636;
          os_log_type_t v98 = 2080;
          id v99 = " ";
          BOOL v100 = 1024;
          id v101 = v62;
          BOOL v102 = 2048;
          id v103 = v63;
          _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> deferring input finished",  buf,  0x30u);
        }
      }
    }

    *v5 |= 0x100u;
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_available = (void (*)(void))callbacks->input_available;
        if (input_available)
        {
          input_available();
          goto LABEL_12;
        }
      }
    }

    __nwlog_obj();
    id v26 = a1->default_input_handler;
    BOOL v27 = "invalid";
    if (v26)
    {
      identifier = v26->identifier;
      if (identifier) {
        BOOL v27 = (const char *)identifier;
      }
    }

    *(_DWORD *)buf = 136446466;
    os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
    BOOL v96 = 2082;
    nw_endpoint_t v97 = (char *)v27;
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v92 = 0;
    if (__nwlog_fault(v29, &type, &v92))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v30 = (os_log_s *)__nwlog_obj();
        uint64_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_138;
        }
        uint64_t v32 = a1->default_input_handler;
        os_log_type_t v33 = "invalid";
        if (v32)
        {
          os_log_type_t v34 = v32->identifier;
          if (v34) {
            os_log_type_t v33 = (const char *)v34;
          }
        }

        *(_DWORD *)buf = 136446466;
        os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
        BOOL v96 = 2082;
        nw_endpoint_t v97 = (char *)v33;
        uint64_t v35 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_137;
      }

      if (!v92)
      {
        char v30 = (os_log_s *)__nwlog_obj();
        uint64_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_138;
        }
        __int16 v72 = a1->default_input_handler;
        BOOL v73 = "invalid";
        if (v72)
        {
          char v74 = v72->identifier;
          if (v74) {
            BOOL v73 = (const char *)v74;
          }
        }

        *(_DWORD *)buf = 136446466;
        os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
        BOOL v96 = 2082;
        nw_endpoint_t v97 = (char *)v73;
        uint64_t v35 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_137;
      }

      uint64_t v45 = (char *)__nw_create_backtrace_string();
      char v30 = (os_log_s *)__nwlog_obj();
      uint64_t v31 = type;
      os_log_type_t v46 = os_log_type_enabled(v30, type);
      if (v45)
      {
        if (v46)
        {
          BOOL v47 = a1->default_input_handler;
          BOOL v48 = "invalid";
          if (v47)
          {
            uint64_t v49 = v47->identifier;
            if (v49) {
              BOOL v48 = (const char *)v49;
            }
          }

          *(_DWORD *)buf = 136446722;
          os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
          BOOL v96 = 2082;
          nw_endpoint_t v97 = (char *)v48;
          os_log_type_t v98 = 2082;
          id v99 = v45;
          _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v45);
        goto LABEL_138;
      }

      if (v46)
      {
        id v81 = a1->default_input_handler;
        uint64_t v82 = "invalid";
        if (v81)
        {
          id v83 = v81->identifier;
          if (v83) {
            uint64_t v82 = (const char *)v83;
          }
        }

        *(_DWORD *)buf = 136446466;
        os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
        BOOL v96 = 2082;
        nw_endpoint_t v97 = (char *)v82;
        uint64_t v35 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_137:
        _os_log_impl(&dword_181A5C000, v30, v31, v35, buf, 0x16u);
      }
    }

    if (v34) {
      free(v34);
    }
    if (!v13)
    {
      __nwlog_obj();
      uint64_t v31 = "invalid";
      goto LABEL_103;
    }

    free(backtrace_string);
    goto LABEL_137;
  }

  nw_endpoint_t v14 = (char *)calloc(1uLL, a8);
  if (!v14)
  {
    uint64_t v24 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v46 = "strict_calloc";
    BOOL v47 = 2048;
    BOOL v48 = 1LL;
    uint64_t v49 = 2048;
    os_log_type_t v50 = a8;
    os_log_type_t v41 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v41);
    if (result) {
      goto LABEL_140;
    }
    free(v41);
  }

  memcpy(v14, a7, a8);
  *(void *)&v14[a8 - 8] ^= bswap64(a3);
  os_log_type_t v15 = v42 + a2;
  if (!(v42 + a2))
  {
    id v25 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v46 = "strict_calloc";
    id v26 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v26);
    if (result) {
      goto LABEL_140;
    }
    free(v26);
    os_log_type_t v15 = 0LL;
  }

  BOOL v40 = v15;
  uint64_t v16 = calloc(1uLL, v15);
  if (v16) {
    goto LABEL_13;
  }
  BOOL v27 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v46 = "strict_calloc";
  BOOL v47 = 2048;
  BOOL v48 = 1LL;
  uint64_t v49 = 2048;
  os_log_type_t v50 = v40;
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
LABEL_13:
    ccaes_gcm_encrypt_mode();
    __int16 v17 = ccgcm_one_shot();
    free(v14);
    if (v17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v46 = "nw_http_encrypt_standalone_aead_chunk";
        BOOL v47 = 1024;
        LODWORD(v4_Block_object_dispose((const void *)(v67 - 152), 8) = v17;
        _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_ERROR, "%{public}s Encrypt error: %u", buf, 0x12u);
      }

      if (v16)
      {
        free(v16);
        return 0LL;
      }
    }

    else
    {
      *a9 = v40;
    }

    return (BOOL)v16;
  }

    free(v5);
    goto LABEL_100;
  }

  __nwlog_obj();
  os_log_type_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
  {
    BOOL v63 = 136446466;
    uint64_t v64 = "nw_path_copy_path_for_client_with_context";
    os_log_type_t v65 = 1024;
    *(_DWORD *)char v66 = 48;
    _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s Trying to copy result again for %u flows",  (uint8_t *)&v63,  0x12u);
  }

  char v5 = (char *)calloc(1uLL, 0x6400uLL);
  if (v5)
  {
LABEL_62:
    char v9 = necp_client_action();
    if (v9 > 0)
    {
      os_log_type_t v10 = v5;
LABEL_11:
      char v5 = (char *)nw_path_copy_path_for_tlv(v1, v3, (uint64_t)v62, v8, (uint64_t)v5, v9);
      if (v10) {
        free(v10);
      }
      goto LABEL_101;
    }

    BOOL v42 = **(_DWORD **)(StatusReg + 8);
    __nwlog_obj();
    os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v44 = v43;
    if (v42 == 2)
    {
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        BOOL v63 = 136446466;
        uint64_t v64 = "nw_path_copy_path_for_client_with_context";
        os_log_type_t v65 = 1024;
        *(_DWORD *)char v66 = 2;
        _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d",  (uint8_t *)&v63,  0x12u);
      }

      goto LABEL_115;
    }

    BOOL v63 = 136446466;
    uint64_t v64 = "nw_path_copy_path_for_client_with_context";
    os_log_type_t v65 = 1024;
    *(_DWORD *)char v66 = v42;
    uint64_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v56 = 0;
    if (__nwlog_fault(v45, &type, &v56))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          BOOL v63 = 136446466;
          uint64_t v64 = "nw_path_copy_path_for_client_with_context";
          os_log_type_t v65 = 1024;
          *(_DWORD *)char v66 = v42;
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d",  (uint8_t *)&v63,  0x12u);
        }
      }

      else if (v56)
      {
        os_log_type_t v50 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v51 = type;
        uint64_t v52 = os_log_type_enabled(v46, type);
        if (v50)
        {
          if (v52)
          {
            BOOL v63 = 136446722;
            uint64_t v64 = "nw_path_copy_path_for_client_with_context";
            os_log_type_t v65 = 1024;
            *(_DWORD *)char v66 = v42;
            *(_WORD *)&v66[4] = 2082;
            *(void *)&v66[6] = v50;
            _os_log_impl( &dword_181A5C000,  v46,  v51,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)&v63,  0x1Cu);
          }

          free(v50);
          goto LABEL_113;
        }

        if (v52)
        {
          BOOL v63 = 136446466;
          uint64_t v64 = "nw_path_copy_path_for_client_with_context";
          os_log_type_t v65 = 1024;
          *(_DWORD *)char v66 = v42;
          _os_log_impl( &dword_181A5C000,  v46,  v51,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, no backtrace",  (uint8_t *)&v63,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v53 = type;
        if (os_log_type_enabled(v46, type))
        {
          BOOL v63 = 136446466;
          uint64_t v64 = "nw_path_copy_path_for_client_with_context";
          os_log_type_t v65 = 1024;
          *(_DWORD *)char v66 = v42;
          _os_log_impl( &dword_181A5C000,  v46,  v53,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)&v63,  0x12u);
        }
      }
    }

    if (v39) {
      free(v39);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v56 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v64 = "nw_path_agent_action";
    char v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v61 = 0;
    if (!__nwlog_fault(v7, &type, &v61))
    {
LABEL_30:
      if (v7) {
LABEL_31:
      }
        free(v7);
LABEL_32:
      os_log_type_t v15 = 0LL;
LABEL_52:

      return v15;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      BOOL v57 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v64 = "nw_path_agent_action";
        _os_log_impl(&dword_181A5C000, v8, v57, "%{public}s nw_path_create_necp_agent_action failed", buf, 0xCu);
      }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v70 = (id)gLogObj;
  if (mode > 5) {
    int v71 = "unknown-mode";
  }
  else {
    int v71 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&_OWORD buf[4] = "nw_endpoint_handler_register_keepalive_handler";
  os_log_type_t v90 = 2082;
  id_str = (void *)v71;
  os_log_type_t v92 = 2082;
  BOOL v93 = "flow";
  __int16 v72 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  nw_endpoint_t v88 = 0;
  if (!__nwlog_fault((const char *)v72, type, &v88))
  {
LABEL_118:
    if (!v72) {
      goto LABEL_120;
    }
LABEL_119:
    free(v72);
    goto LABEL_120;
  }

  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v73 = (os_log_s *)(id)gLogObj;
    char v74 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        uint64_t v75 = "unknown-mode";
      }
      else {
        uint64_t v75 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&_OWORD buf[4] = "nw_endpoint_handler_register_keepalive_handler";
      os_log_type_t v90 = 2082;
      id_str = (void *)v75;
      os_log_type_t v92 = 2082;
      BOOL v93 = "flow";
      _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v70 = (id)gLogObj;
  if (mode > 5) {
    int v71 = "unknown-mode";
  }
  else {
    int v71 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&_OWORD buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
  os_log_type_t v90 = 2082;
  id_str = (void *)v71;
  os_log_type_t v92 = 2082;
  BOOL v93 = "flow";
  __int16 v72 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  nw_endpoint_t v88 = 0;
  if (!__nwlog_fault((const char *)v72, type, &v88))
  {
LABEL_118:
    if (!v72) {
      goto LABEL_120;
    }
LABEL_119:
    free(v72);
    goto LABEL_120;
  }

  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v73 = (os_log_s *)(id)gLogObj;
    char v74 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        uint64_t v75 = "unknown-mode";
      }
      else {
        uint64_t v75 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&_OWORD buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
      os_log_type_t v90 = 2082;
      id_str = (void *)v75;
      os_log_type_t v92 = 2082;
      BOOL v93 = "flow";
      _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

    goto LABEL_100;
  }

  if (!v76)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v60 = (os_log_s *)(id)gLogObj;
    char v67 = type;
    if (os_log_type_enabled(v60, type))
    {
      if (mode > 5) {
        os_log_type_t v68 = "unknown-mode";
      }
      else {
        os_log_type_t v68 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      nw_endpoint_t v79 = "nw_endpoint_flow_reset_expected_progress_target";
      __int16 v80 = 2082;
      id v81 = (void *)v68;
      uint64_t v82 = 2082;
      id v83 = "flow";
      _os_log_impl( &dword_181A5C000,  v60,  v67,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_99;
  }

  BOOL v63 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v60 = (os_log_s *)(id)gLogObj;
  uint64_t v64 = type;
  os_log_type_t v65 = os_log_type_enabled(v60, type);
  if (!v63)
  {
    if (v65)
    {
      if (mode > 5) {
        uint64_t v69 = "unknown-mode";
      }
      else {
        uint64_t v69 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      nw_endpoint_t v79 = "nw_endpoint_flow_reset_expected_progress_target";
      __int16 v80 = 2082;
      id v81 = (void *)v69;
      uint64_t v82 = 2082;
      id v83 = "flow";
      _os_log_impl( &dword_181A5C000,  v60,  v64,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_99;
  }

  if (v65)
  {
    if (mode > 5) {
      char v66 = "unknown-mode";
    }
    else {
      char v66 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    nw_endpoint_t v79 = "nw_endpoint_flow_reset_expected_progress_target";
    __int16 v80 = 2082;
    id v81 = (void *)v66;
    uint64_t v82 = 2082;
    id v83 = "flow";
    uint64_t v84 = 2082;
    BOOL v85 = v63;
    _os_log_impl( &dword_181A5C000,  v60,  v64,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v63);
  if (v59) {
    goto LABEL_101;
  }
LABEL_102:
}

    if (gLogDatapath)
    {
      BOOL v63 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v95 = 136446210;
        BOOL v96 = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v63, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v95, 0xCu);
      }
    }

    goto LABEL_37;
  }

  if ((*(_WORD *)(a5 + 388) & 0x8000) != 0) {
    goto LABEL_99;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v59 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_99;
    }
    __int16 v60 = *(_DWORD *)(a5 + 368);
    id v61 = *((_DWORD *)v86 + 6);
    os_log_type_t v62 = *((_DWORD *)v82 + 6);
    LODWORD(buf[0]) = 136447490;
    *(void *)((char *)buf + 4) = "send_callback";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = a5 + 390;
    HIWORD(buf[2]) = 2080;
    os_log_type_t v92 = " ";
    LOWORD(v93) = 1024;
    *(_DWORD *)((char *)&v93 + 2) = v60;
    HIWORD(v93) = 1024;
    LODWORD(v94[0]) = v61;
    WORD2(v94[0]) = 1024;
    *(_DWORD *)((char *)v94 + 6) = v62;
    uint64_t v23 = "%{public}s %{public}s%s<i%u> wrote %u bytes (pending %u frames)";
    uint64_t v24 = (os_log_s *)v59;
    id v25 = 50;
LABEL_98:
    _os_log_impl(&dword_181A5C000, v24, OS_LOG_TYPE_DEBUG, v23, (uint8_t *)buf, v25);
    goto LABEL_99;
  }

    if (!a12)
    {
LABEL_86:
      if (a13) {
        goto LABEL_87;
      }
      goto LABEL_101;
    }

    free(v28);
    if (!v22) {
      return;
    }
LABEL_132:
    free(v22);
    return;
  }

  char v9 = *(_BYTE *)(a1 + 254);
  *(_BYTE *)(a1 + 254) = v9 & 0xF7 | (8 * *a4);
  if ((v9 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      nw_endpoint_t v11 = (*(unsigned __int8 *)(a1 + 254) >> 3) & 1;
      *(_DWORD *)buf = 136447234;
      uint64_t v49 = "nw_protocol_ipv6_notify";
      os_log_type_t v50 = 2082;
      BOOL v51 = (void *)(a1 + 255);
      uint64_t v52 = 2080;
      os_log_type_t v53 = " ";
      id v54 = 2048;
      id v55 = (char *)(a1 + 96);
      os_log_type_t v56 = 1024;
      BOOL v57 = v11;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s%p segmentation offload notify enable %d",  buf,  0x30u);
    }
  }

void sub_181AF789C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_get_remote_endpoint(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "__nw_protocol_get_remote_endpoint";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "__nw_protocol_get_remote_endpoint";
          __int16 v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v32 = "__nw_protocol_get_remote_endpoint";
            __int16 v33 = 2082;
            os_log_type_t v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "__nw_protocol_get_remote_endpoint";
          __int16 v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "__nw_protocol_get_remote_endpoint";
          __int16 v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

nw_endpoint_t nw_flow_get_remote(nw_protocol *a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v1 = *((id *)a1->handle + 20);
  nw_path_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    nw_endpoint_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_flow_get_remote";
    nw_endpoint_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v14, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v24 = "nw_flow_get_remote";
            __int16 v25 = 2082;
            BOOL v26 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "nw_flow_get_remote";
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181AF82A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_path_copy_effective_remote_endpoint(nw_path_t path)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  nw_path_t v1 = path;
  nw_path_t v2 = (id *)v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 9);
    if (v3 && *(void *)(v3 + 24) != *(void *)(v3 + 16))
    {
      nw_array_get_object_at_index(v3, 0LL);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
      char v5 = v4;
      if (v4)
      {
        uint64_t v6 = (void *)v4[5];
        if (v6)
        {
          char v7 = v6;

          goto LABEL_9;
        }
      }
    }

    char v7 = (nw_endpoint *)v2[3];
    goto LABEL_9;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v20 = "nw_path_copy_effective_remote_endpoint";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v20 = "nw_path_copy_effective_remote_endpoint";
          __int16 v21 = 2082;
          id v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_get_parameters(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "__nw_protocol_get_parameters";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "__nw_protocol_get_parameters";
          __int16 v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v32 = "__nw_protocol_get_parameters";
            __int16 v33 = 2082;
            os_log_type_t v34 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "__nw_protocol_get_parameters";
          __int16 v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }

      else
      {
        BOOL v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "__nw_protocol_get_parameters";
          __int16 v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }

id nw_flow_get_parameters(nw_protocol *a1)
{
  return *((id *)a1->handle + 22);
}

void sub_181AF8CE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_url_endpoint;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_181AF8F28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, objc_super a11)
{
  a11.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_endpoint;
  -[_Unwind_Exception dealloc](&a11, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_endpoint_clear_alternatives(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = __nw_endpoint_clear_alternatives_block_invoke;
    v11[3] = &unk_189BC93A0;
    id v12 = v1;
    nw_endpoint_locked(v12, v11);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_clear_alternatives";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v4, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_clear_alternatives";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181AF9244( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_clear_alternatives_block_invoke(uint64_t a1)
{
  id v1 = *(void **)(*(void *)(a1 + 32) + 160LL);
  if (v1)
  {
    do
    {
      uint64_t v3 = (void *)*v1;
      uint64_t v4 = (void *)v1[2];
      v1[2] = 0LL;

      char v5 = (void *)v1[3];
      v1[3] = 0LL;

      os_log_type_t v6 = (void *)*v1;
      char v7 = (void *)v1[1];
      if (*v1)
      {
        v6[1] = v7;
        char v7 = (void *)v1[1];
      }

      else
      {
        *(void *)(*(void *)(a1 + 32) + 168LL) = v7;
      }

      void *v7 = v6;
      void *v1 = 0LL;
      v1[1] = 0LL;
      if (v1 != (void *)(*(void *)(a1 + 32) + 128LL)) {
        free(v1);
      }
      id v1 = v3;
    }

    while (v3);
  }

uint64_t nw_parameters_clear_protocol_stack(void *a1, int a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    char v5 = v3[19];
    os_log_type_t v6 = v5;
    if (v5)
    {
      switch(a2)
      {
        case 2:
          char v7 = (void *)v5[6];
          v5[6] = 0LL;
          break;
        case 3:
          os_log_type_t v10 = (void *)v5[3];
          v5[3] = 0LL;

          char v7 = (void *)v6[4];
          v6[4] = 0LL;
          break;
        case 4:
          char v7 = (void *)v5[2];
          v5[2] = 0LL;
          break;
        case 5:
          char v7 = (void *)v5[1];
          v5[1] = 0LL;
          break;
        default:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v8 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v31 = "nw_parameters_clear_protocol_stack";
            __int16 v32 = 1024;
            LODWORD(v33) = a2;
            _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s Unsupported protocol level %u",  buf,  0x12u);
          }

          goto LABEL_8;
      }

      uint64_t v9 = 1LL;
LABEL_13:

      goto LABEL_14;
    }

    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_parameters_clear_protocol_stack";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v17, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v31 = "nw_parameters_clear_protocol_stack";
          _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null stack", buf, 0xCu);
        }
      }

      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v31 = "nw_parameters_clear_protocol_stack";
            __int16 v32 = 2082;
            __int16 v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v18,  v24,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v31 = "nw_parameters_clear_protocol_stack";
          _os_log_impl(&dword_181A5C000, v18, v24, "%{public}s called with null stack, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v31 = "nw_parameters_clear_protocol_stack";
          _os_log_impl( &dword_181A5C000,  v18,  v27,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

BOOL nw_endpoint_proxy_handler_should_use_proxy(void *a1, void *a2, BOOL a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = nw_endpoint_handler_copy_parameters(v5);
  if (v7)
  {
    id v8 = nw_path_copy_endpoint(v6);
    if (nw_path_should_use_proxy(v6, a3))
    {
      uint64_t v9 = (unsigned __int8 *)nw_parameters_copy_custom_proxy_configs(v7);
      if (!v9) {
        uint64_t v9 = (unsigned __int8 *)nw_path_copy_proxy_configs(v6);
      }
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000LL;
      char v37 = 0;
      v29[0] = MEMORY[0x1895F87A8];
      v29[1] = 3221225472LL;
      v29[2] = __nw_endpoint_proxy_handler_should_use_proxy_block_invoke;
      v29[3] = &unk_189BB9EC8;
      id v30 = v8;
      id v31 = v7;
      id v32 = v6;
      __int16 v33 = buf;
      nw_array_apply(v9, (uint64_t)v29);
      BOOL v10 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

      _Block_object_dispose(buf, 8);
      goto LABEL_17;
    }

    nw_endpoint_t v11 = v7;
    __int16 v12 = *(_WORD *)(v11[13] + 108LL);

    if ((v12 & 0x1000) == 0)
    {
      char v13 = v11;
      __int16 v14 = *(_WORD *)(v11[13] + 100LL);

      BOOL v10 = 0LL;
      if ((v14 & 0x40) == 0 || !v8) {
        goto LABEL_17;
      }
      if (nw_path_can_support_endpoint(v6, v8))
      {
        id v15 = nw_path_copy_interface(v6);
        os_log_type_t v16 = v15;
        if (v15)
        {
          __int16 v17 = v15;
          unsigned int v18 = v17[24] & 0xFFFFFFFB;

          if (v18)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v19 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
              _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s Proxies not present, but required to fail closed",  buf,  0xCu);
            }

            BOOL v10 = 1LL;
            goto LABEL_17;
          }
        }
      }
    }

    BOOL v10 = 0LL;
LABEL_17:

    goto LABEL_18;
  }

  __nwlog_obj();
  os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
  BOOL v22 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v34 = 0;
  if (__nwlog_fault(v22, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
        _os_log_impl(&dword_181A5C000, v23, v26, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
        _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181AFA184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_parameters(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    id v3 = v1[4];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_handler_copy_parameters";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_handler_copy_parameters";
          __int16 v17 = 2082;
          unsigned int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_parameters";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_path_copy_endpoint(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    id v3 = v1[3];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_copy_endpoint";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_copy_endpoint";
          __int16 v17 = 2082;
          unsigned int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

BOOL nw_path_should_use_proxy(void *a1, BOOL a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = (nw_endpoint_t *)v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_path_should_use_proxy";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v23 = "nw_path_should_use_proxy";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v23 = "nw_path_should_use_proxy";
            __int16 v24 = 2082;
            BOOL v25 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v23 = "nw_path_should_use_proxy";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v23 = "nw_path_should_use_proxy";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181AFAABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_next_id(unsigned int *a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  do
  {
    unsigned int v2 = __ldaxr(a1);
    unsigned int v3 = v2 + 1;
  }

  while (__stlxr(v2 + 1, a1));
  if (v3 >= 0x100 && (_BYTE)v2 == 0xFF)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136446466;
      id v7 = "nw_endpoint_handler_get_next_id";
      __int16 v8 = 1024;
      unsigned int v9 = v3;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s reached %u child endpoint handlers, wrapping",  (uint8_t *)&v6,  0x12u);
    }

    LOBYTE(v3) = nw_endpoint_handler_get_next_id(a1);
  }

  return v3;
}

uint64_t nw_endpoint_flow_receive_report(void *a1, int a2, int a3, unsigned __int16 *a4, void *a5, void *a6)
{
  unsigned int v9 = a1;
  uint64_t v404 = *MEMORY[0x1895F89C0];
  uint64_t v10 = a1;
  id v363 = a5;
  id v11 = a6;
  v364 = v11;
  id v365 = v10;
  if (!v11)
  {
    __nwlog_obj();
    v284 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v379 = "nw_endpoint_flow_receive_report";
    id v285 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v373[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v285, type, v373))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v286 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v287 = type[0];
        if (os_log_type_enabled(v286, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v379 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_181A5C000, v286, v287, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v373[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v286 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v289 = type[0];
        BOOL v290 = os_log_type_enabled(v286, type[0]);
        if (backtrace_string)
        {
          if (v290)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v379 = "nw_endpoint_flow_receive_report";
            __int16 v380 = 2082;
            __int16 v381 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v286,  v289,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_403;
        }

        if (v290)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v379 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_181A5C000, v286, v289, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v286 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v295 = type[0];
        if (os_log_type_enabled(v286, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v379 = "nw_endpoint_flow_receive_report";
          _os_log_impl( &dword_181A5C000,  v286,  v295,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_403:
    if (v285) {
      free(v285);
    }
    goto LABEL_18;
  }

  os_log_type_t v12 = (unsigned int *)v11;
  uint64_t v13 = v12[29];

  if ((_DWORD)v13 == 2)
  {
    v349 = v12;
    __int16 v14 = v12;
    char v15 = *((_BYTE *)v14 + 268);

    v359 = v14;
    if ((v15 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v17 = v14;

        BOOL v18 = v17;
        char v19 = *((_BYTE *)v14 + 268);

        if ((v19 & 1) != 0) {
          char v20 = "dry-run ";
        }
        else {
          char v20 = "";
        }
        os_log_t log = v16;
        nw_endpoint_t v354 = nw_endpoint_handler_copy_endpoint(v18);
        logging_description = nw_endpoint_get_logging_description(v354);
        BOOL v22 = v18;
        BOOL v23 = v22;
        uint64_t v24 = v22[30];
        else {
          BOOL v25 = off_189BBBBF0[v24];
        }
        char v347 = v25;

        char v29 = v23;
        int v352 = a2;
        id v30 = "path";
        switch(v349[29])
        {
          case 0u:
            break;
          case 1u:
            id v30 = "resolver";
            break;
          case 2u:
            id v30 = nw_endpoint_flow_mode_string(v29[31]);
            break;
          case 3u:
            id v30 = "proxy";
            break;
          case 4u:
            id v30 = "fallback";
            break;
          case 5u:
            id v30 = "transform";
            break;
          default:
            id v30 = "unknown-mode";
            break;
        }

        id v344 = v30;

        id v31 = v29;
        os_unfair_lock_lock((os_unfair_lock_t)v31 + 28);
        id v32 = v31[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v31 + 28);

        id v33 = v32;
        id_string = nw_endpoint_handler_get_id_string(v365);
        char v34 = nw_endpoint_handler_dry_run_string(v365);
        nw_endpoint_t v35 = nw_endpoint_handler_copy_endpoint(v365);
        v338 = v9;
        uint64_t v36 = nw_endpoint_get_logging_description(v35);
        char v37 = (char *)(v17 + 42);
        uint64_t v38 = nw_endpoint_handler_state_string(v365);
        uint64_t v39 = nw_endpoint_handler_mode_string(v365);
        id v40 = nw_endpoint_handler_copy_current_path(v365);
        *(_DWORD *)buf = 136449282;
        uint64_t v379 = "nw_endpoint_flow_receive_report";
        __int16 v380 = 2082;
        __int16 v381 = v37;
        __int16 v382 = 2082;
        __int16 v383 = v20;
        __int16 v384 = 2082;
        __int16 v385 = (void *)logging_description;
        __int16 v386 = 2082;
        __int16 v387 = (void *)v347;
        __int16 v388 = 2082;
        __int16 v389 = (void *)v344;
        __int16 v390 = 2114;
        id v391 = v33;
        __int16 v392 = 2082;
        id v393 = id_string;
        __int16 v394 = 2082;
        v395 = v34;
        __int16 v396 = 2082;
        v397 = v36;
        __int16 v398 = 2082;
        v399 = v38;
        __int16 v400 = 2082;
        v401 = v39;
        __int16 v402 = 2114;
        id v403 = v40;
        os_log_type_t v16 = log;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received child report: [C%{pu blic}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x84u);

        a2 = v352;
        unsigned int v9 = v338;
      }

      uint64_t v10 = v365;
      __int16 v14 = v359;
    }

    os_log_type_t v41 = a4;
    if (a4 && *a4 == 3)
    {
      int v42 = a4[1];
      if (v42 == 6)
      {
        __int16 v43 = 13;
        goto LABEL_36;
      }

      if (v42 == 9)
      {
        __int16 v43 = 15;
LABEL_36:
        *((_WORD *)v14 + 40) = 3;
        *((_WORD *)v14 + 41) = v43;
        nw_endpoint_handler_report(v14, v10, (_WORD *)v14 + 40, v363);
LABEL_37:
        BOOL v44 = nw_endpoint_handler_copy_flow((NWConcrete_nw_endpoint_handler *)v14);
        uint64_t v45 = (os_unfair_lock_s *)((char *)v44 + 880);
        os_unfair_lock_lock((os_unfair_lock_t)v44 + 220);
        int v348 = 0;
        id v46 = 0LL;
        char v355 = v44;
        if (a2 == 2)
        {
          BOOL loga = 0LL;
          if (a3 != 3) {
            goto LABEL_70;
          }
          int v348 = 0;
          id v46 = 0LL;
          if (a4 && v10)
          {
            BOOL loga = 0LL;
            if (!*((void *)v44 + 117))
            {
              if (*a4 == 3 && a4[1] == 6)
              {
                id v345 = *((id *)v44 + 118);
                BOOL v47 = (void *)*((void *)v44 + 118);
                *((void *)v44 + 11_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;

                objc_storeStrong((id *)v44 + 117, v9);
                BOOL v48 = nw_endpoint_handler_copy_flow(v365);
                uint64_t v49 = v48;
                if (!*((void *)v44 + 96) && v48 && *((void *)v48 + 96))
                {
                  *((_BYTE *)v44 + 35) |= 2u;
                  nw_endpoint_flow_reinitialize_protocol_for_handling_requests(v365);
                }

                BOOL loga = v365;
                if ((*((_BYTE *)v44 + 32) & 2) == 0) {
                  goto LABEL_69;
                }
                __nwlog_obj();
                os_log_type_t v50 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136446210;
                uint64_t v379 = "nw_endpoint_flow_receive_report";
                BOOL v51 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                v373[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v51, type, v373))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v53 = type[0];
                    if (os_log_type_enabled(v52, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v379 = "nw_endpoint_flow_receive_report";
                      _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s leaf flow had child flow become ready",  buf,  0xCu);
                    }
                  }

                  else if (v373[0])
                  {
                    id v54 = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v55 = type[0];
                    BOOL v56 = os_log_type_enabled(v52, type[0]);
                    if (v54)
                    {
                      if (v56)
                      {
                        *(_DWORD *)buf = 136446466;
                        uint64_t v379 = "nw_endpoint_flow_receive_report";
                        __int16 v380 = 2082;
                        __int16 v381 = v54;
                        _os_log_impl( &dword_181A5C000,  v52,  v55,  "%{public}s leaf flow had child flow become ready, dumping backtrace:%{public}s",  buf,  0x16u);
                      }

                      free(v54);
                      goto LABEL_67;
                    }

                    if (v56)
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v379 = "nw_endpoint_flow_receive_report";
                      _os_log_impl( &dword_181A5C000,  v52,  v55,  "%{public}s leaf flow had child flow become ready, no backtrace",  buf,  0xCu);
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v57 = type[0];
                    if (os_log_type_enabled(v52, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      uint64_t v379 = "nw_endpoint_flow_receive_report";
                      _os_log_impl( &dword_181A5C000,  v52,  v57,  "%{public}s leaf flow had child flow become ready, backtrace limit exceeded",  buf,  0xCu);
                    }
                  }
                }

    if (v272) {
      free(v272);
    }
    goto LABEL_337;
  }

  __nwlog_obj();
  id v267 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
  nw_endpoint_t v268 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v359) = 0;
  if (__nwlog_fault(v268, type, &v359))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v269 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v270 = type[0];
      if (os_log_type_enabled(v269, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
        _os_log_impl(&dword_181A5C000, v269, v270, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if ((_BYTE)v359)
    {
      id v275 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v269 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v276 = type[0];
      char v277 = os_log_type_enabled(v269, type[0]);
      if (v275)
      {
        if (v277)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          v364 = 2082;
          id v365 = v275;
          _os_log_impl( &dword_181A5C000,  v269,  v276,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v275);
        goto LABEL_398;
      }

      if (v277)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
        _os_log_impl(&dword_181A5C000, v269, v276, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v269 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v298 = type[0];
      if (os_log_type_enabled(v269, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
        _os_log_impl( &dword_181A5C000,  v269,  v298,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      goto LABEL_162;
    }

    goto LABEL_163;
  }

  if (v60 != 14)
  {
    if (v60 != 13) {
      goto LABEL_163;
    }
    goto LABEL_52;
  }

  *((_BYTE *)v42 + 97) |= 8u;
  os_log_type_t v106 = *((void *)v42 + 11);
  uint64_t v107 = nw_endpoint_handler_get_minimize_logging(v471);
  id v108 = nw_endpoint_handler_get_logging_disabled(v471);
  if (v106)
  {
    if (v107)
    {
      if ((v108 & 1) != 0)
      {
LABEL_132:
        id v118 = *((void *)v42 + 11);
        if (v118)
        {
          nw_queue_cancel_source(v118, v109);
          *((void *)v42 + 11) = 0LL;
        }

        goto LABEL_163;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v110 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v331 = nw_endpoint_handler_get_id_string(v471);
        nw_endpoint_t v332 = nw_endpoint_handler_dry_run_string(v471);
        nw_endpoint_t v333 = nw_endpoint_handler_copy_endpoint(v471);
        id v334 = nw_endpoint_get_logging_description(v333);
        BOOL v335 = nw_endpoint_handler_state_string(v471);
        id v336 = nw_endpoint_handler_mode_string(v471);
        os_log_type_t v337 = nw_endpoint_handler_copy_current_path(v471);
        *(_DWORD *)buf = 136447746;
        v481 = "nw_endpoint_proxy_receive_report";
        v482 = 2082;
        v483 = (uint64_t)v331;
        v484 = 2082;
        v485 = (uint64_t)v332;
        v486 = 2082;
        v487 = v334;
        v488 = 2082;
        v489 = v335;
        v490 = 2082;
        v491 = v336;
        v492 = 2114;
        v493 = v337;
        _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] proxy flow finished, cancelli ng timer for fallback attempt",  buf,  0x48u);
      }
    }

    else
    {
      if ((v108 & 1) != 0) {
        goto LABEL_132;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v110 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v110, OS_LOG_TYPE_INFO))
      {
        BOOL v111 = nw_endpoint_handler_get_id_string(v471);
        os_log_type_t v112 = nw_endpoint_handler_dry_run_string(v471);
        id v113 = nw_endpoint_handler_copy_endpoint(v471);
        id v114 = nw_endpoint_get_logging_description(v113);
        os_log_type_t v115 = nw_endpoint_handler_state_string(v471);
        int v116 = nw_endpoint_handler_mode_string(v471);
        BOOL v117 = nw_endpoint_handler_copy_current_path(v471);
        *(_DWORD *)buf = 136447746;
        v481 = "nw_endpoint_proxy_receive_report";
        v482 = 2082;
        v483 = (uint64_t)v111;
        v484 = 2082;
        v485 = (uint64_t)v112;
        v486 = 2082;
        v487 = v114;
        v488 = 2082;
        v489 = v115;
        v490 = 2082;
        v491 = v116;
        v492 = 2114;
        v493 = v117;
        _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] proxy flow finished, cancelli ng timer for fallback attempt",  buf,  0x48u);
      }
    }

    unsigned int v9 = v474;
    int v42 = loga;
    a3 = v464;
    goto LABEL_132;
  }

  if (!v107)
  {
    if ((v108 & 1) != 0) {
      goto LABEL_163;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v121 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v121, OS_LOG_TYPE_INFO))
    {
      os_log_type_t v129 = nw_endpoint_handler_get_id_string(v471);
      os_log_type_t v130 = nw_endpoint_handler_dry_run_string(v471);
      nw_endpoint_t v131 = nw_endpoint_handler_copy_endpoint(v471);
      BOOL v132 = nw_endpoint_get_logging_description(v131);
      BOOL v133 = nw_endpoint_handler_state_string(v471);
      os_log_type_t v134 = nw_endpoint_handler_mode_string(v471);
      os_log_type_t v135 = nw_endpoint_handler_copy_current_path(v471);
      *(_DWORD *)buf = 136447746;
      v481 = "nw_endpoint_proxy_receive_report";
      v482 = 2082;
      v483 = (uint64_t)v129;
      v484 = 2082;
      v485 = (uint64_t)v130;
      v486 = 2082;
      v487 = v132;
      v488 = 2082;
      v489 = v133;
      v490 = 2082;
      v491 = v134;
      v492 = 2114;
      v493 = v135;
      _os_log_impl( &dword_181A5C000,  v121,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] proxy flow finished",  buf,  0x48u);
    }

    goto LABEL_403;
  }

  if ((v108 & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v121 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v372 = nw_endpoint_handler_get_id_string(v471);
      __int16 v373 = nw_endpoint_handler_dry_run_string(v471);
      id v374 = nw_endpoint_handler_copy_endpoint(v471);
      uint64_t v375 = nw_endpoint_get_logging_description(v374);
      char v376 = nw_endpoint_handler_state_string(v471);
      char v377 = nw_endpoint_handler_mode_string(v471);
      v378 = nw_endpoint_handler_copy_current_path(v471);
      *(_DWORD *)buf = 136447746;
      v481 = "nw_endpoint_proxy_receive_report";
      v482 = 2082;
      v483 = (uint64_t)v372;
      v484 = 2082;
      v485 = (uint64_t)v373;
      v486 = 2082;
      v487 = v375;
      v488 = 2082;
      v489 = v376;
      v490 = 2082;
      v491 = v377;
      v492 = 2114;
      v493 = v378;
      _os_log_impl( &dword_181A5C000,  v121,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] proxy flow finished",  buf,  0x48u);
    }

    goto LABEL_403;
  }

    if (v161) {
      free(v161);
    }
    BOOL v44 = 0LL;
    goto LABEL_139;
  }

  uint64_t v28 = strcasecmp(a2, "Sec-CH-Geohash");
  char v29 = strcasecmp(a2, "Priority");
  id v30 = strcasecmp(a2, "Require-Interface");
  id v31 = strcasecmp(a2, "Prohibit-Interface");
  id v32 = strcasecmp(a2, "Client-Application");
  id v33 = strcasecmp(a2, "Multipath");
  char v34 = strcasecmp(a2, "Listener-Association");
  if (!v28)
  {
    os_log_type_t v55 = *(void **)(*(void *)(a1 + 40) + 320LL);
    if (v55
      && ((nw_parameters_get_is_known_tracker(v55) & 1) != 0
       || (nw_parameters_get_parent_is_known_tracker(*(void **)(*(void *)(a1 + 40) + 320LL)) & 1) != 0
       || (nw_parameters_get_use_enhanced_privacy_mode(*(void **)(*(void *)(a1 + 40) + 320LL)) & 1) != 0))
    {
      return 1LL;
    }

    if (v3)
    {
      BOOL v56 = *(void *)(a1 + 40);
      if (*v3)
      {
        if ((!v56 || (*(_BYTE *)(v56 + 529) & 1) == 0) && gLogDatapath)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          os_log_type_t v57 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v58 = *(void *)(a1 + 40);
            os_log_type_t v59 = v58 == 0;
            if (v58) {
              int v60 = (const char *)(v58 + 531);
            }
            else {
              int v60 = "";
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_masque_add_extra_headers_to_request_block_invoke";
            *(void *)&void buf[14] = v60;
            unsigned int v61 = " ";
            *(_WORD *)&buf[12] = 2082;
            if (v59) {
              unsigned int v61 = "";
            }
            *(_WORD *)&buf[22] = 2080;
            *(void *)&_BYTE buf[24] = v61;
            *(_WORD *)&_BYTE buf[32] = 2082;
            *(void *)&buf[34] = v3;
            _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived geohash hint %{public}s",  buf,  0x2Au);
          }
        }

        free(v199);
        goto LABEL_449;
      }

      if (!v200) {
        goto LABEL_449;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      char v188 = "%{public}s called with null http1, no backtrace";
    }

    else
    {
      BOOL v186 = (os_log_s *)__nwlog_obj();
      BOOL v187 = v268[0];
      if (!os_log_type_enabled(v186, (os_log_type_t)v268[0])) {
        goto LABEL_449;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      char v188 = "%{public}s called with null http1, backtrace limit exceeded";
    }

    id v218 = buf;
LABEL_448:
    _os_log_impl(&dword_181A5C000, v186, v187, v188, v218, 0xCu);
    goto LABEL_449;
  }

  __int16 v70 = *v13;
  BOOL v71 = v70 | (*((unsigned __int8 *)v13 + 2) << 16);
  if ((v70 & 0x800) == 0)
  {
    *((_BYTE *)v13 + 2) = BYTE2(v71);
    char *v13 = v71 | 0x800;
    __int16 v72 = *(unsigned int *)(v69 + 368) + 1LL;
    char v73 = v72 << 31 >> 31;
    *(_DWORD *)(v69 + 36_Block_object_dispose((const void *)(v67 - 152), 8) = v72;
    if (v73 != v72 || v73 < 0)
    {
      char v74 = v13;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v75 = *(unsigned int *)(v69 + 368);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = "http1->nonresuable_connections";
      *(_WORD *)&buf[22] = 2048;
      *(void *)&_BYTE buf[24] = 1LL;
      *(_WORD *)&_BYTE buf[32] = 2048;
      *(void *)&buf[34] = v75;
      uint64_t v76 = (char *)_os_log_send_and_compose_impl();
      v268[0] = 16;
      v260[0] = OS_LOG_TYPE_DEFAULT;
      if (v268[0] != 17)
      {
        if (v260[0])
        {
          id v114 = (char *)__nw_create_backtrace_string();
          BOOL v77 = (os_log_s *)__nwlog_obj();
          __int16 v78 = v268[0];
          os_log_type_t v115 = os_log_type_enabled(v77, (os_log_type_t)v268[0]);
          if (v114)
          {
            if (v115)
            {
              int v116 = *(unsigned int *)(v69 + 368);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = "http1->nonresuable_connections";
              *(_WORD *)&buf[22] = 2048;
              *(void *)&_BYTE buf[24] = 1LL;
              *(_WORD *)&_BYTE buf[32] = 2048;
              *(void *)&buf[34] = v116;
              *(_WORD *)&buf[42] = 2082;
              *(void *)&v265 = v114;
              _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v114);
            goto LABEL_228;
          }

          if (!v115) {
            goto LABEL_228;
          }
          os_log_type_t v140 = *(unsigned int *)(v69 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&_BYTE buf[24] = 1LL;
          *(_WORD *)&_BYTE buf[32] = 2048;
          *(void *)&buf[34] = v140;
          __int16 v80 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        }

        else
        {
          BOOL v77 = (os_log_s *)__nwlog_obj();
          __int16 v78 = v268[0];
          if (!os_log_type_enabled(v77, (os_log_type_t)v268[0])) {
            goto LABEL_228;
          }
          os_log_type_t v121 = *(unsigned int *)(v69 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&void buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          *(void *)&_BYTE buf[24] = 1LL;
          *(_WORD *)&_BYTE buf[32] = 2048;
          *(void *)&buf[34] = v121;
          __int16 v80 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        }

    if (v191) {
      free(v191);
    }
LABEL_405:

    _Block_object_dispose(out, 8);
LABEL_406:
    int v116 = lock;
  }

LABEL_97:
                if (v41 && v59 == v10 && (*((_BYTE *)v44 + 32) & 1) != 0 && *v41 == 1)
                {
                  int v67 = v41[1];
                  if (a2 != 2 || v67 == 7)
                  {
                    os_unfair_lock_unlock(v45);
                    if (v67 == 7)
                    {
                      nw_endpoint_flow_cleanup_protocol(v14, (uint64_t)v44 + 376, 1);
                      *((_WORD *)v44 + 354) &= ~1u;
                      nw_endpoint_flow_initialize_protocol(v14, (char *)v44 + 376, *((_BYTE *)v44 + 32) & 1);
                      BOOL v117 = (void *)*((void *)v44 + 117);
                      *((void *)v44 + 117) = 0LL;

                      id v118 = v359;
                      v118[30] = 2;

                      uint64_t v10 = v365;
                      __int16 v14 = v359;
                      nw_endpoint_handler_report(v118, 0LL, a4, 0LL);
                      if (!loga)
                      {
                        v353 = 0LL;
                        goto LABEL_346;
                      }

                      v353 = 0LL;
                      goto LABEL_123;
                    }

                    v353 = 0LL;
                    os_log_type_t v41 = a4;
                    if (!v58)
                    {
LABEL_122:
                      if (!loga)
                      {
                        if (!v353)
                        {
                          v353 = 0LL;
                          if (!v348)
                          {
LABEL_348:
                            if (*((NWConcrete_nw_endpoint_handler **)v44 + 116) != v10)
                            {
LABEL_349:
                              uint64_t v28 = 1LL;
                              goto LABEL_350;
                            }

                            if (a3 == 4)
                            {
                              *((_BYTE *)v44 + 35) |= 4u;
                              v256 = v14;
                              int state = v256->state;

                              if (state != 5
                                && (*((_BYTE *)v355 + 32) & 1) != 0
                                && nw_endpoint_handler_get_has_better_path(v256, 0))
                              {
                                int minimize_logging = nw_endpoint_handler_get_minimize_logging(v256);
                                char logging_disabled = nw_endpoint_handler_get_logging_disabled(v256);
                                if (minimize_logging)
                                {
                                  if ((logging_disabled & 1) != 0) {
                                    goto LABEL_363;
                                  }
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  uint64_t v260 = (os_log_s *)(id)gconnectionLogObj;
                                  if (os_log_type_enabled(v260, OS_LOG_TYPE_DEBUG))
                                  {
                                    os_log_type_t v330 = nw_endpoint_handler_get_id_string(v256);
                                    os_log_type_t v331 = nw_endpoint_handler_dry_run_string(v256);
                                    nw_endpoint_t v332 = nw_endpoint_handler_copy_endpoint(v256);
                                    nw_endpoint_t v333 = nw_endpoint_get_logging_description(v332);
                                    id v334 = nw_endpoint_handler_state_string(v256);
                                    BOOL v335 = nw_endpoint_handler_mode_string(v256);
                                    id v336 = nw_endpoint_handler_copy_current_path(v256);
                                    *(_DWORD *)buf = 136447746;
                                    uint64_t v379 = "nw_endpoint_flow_receive_report";
                                    __int16 v380 = 2082;
                                    __int16 v381 = (char *)v330;
                                    __int16 v382 = 2082;
                                    __int16 v383 = v331;
                                    __int16 v384 = 2082;
                                    __int16 v385 = (void *)v333;
                                    __int16 v386 = 2082;
                                    __int16 v387 = (void *)v334;
                                    __int16 v388 = 2082;
                                    __int16 v389 = (void *)v335;
                                    __int16 v390 = 2114;
                                    id v391 = v336;
                                    _os_log_impl( &dword_181A5C000,  v260,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] c onnected child failed when a better path is available",  buf,  0x48u);
                                  }
                                }

                                else
                                {
                                  if ((logging_disabled & 1) != 0)
                                  {
LABEL_363:
                                    nw_endpoint_handler_handle_failure(v256);
                                    goto LABEL_349;
                                  }

                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  uint64_t v260 = (os_log_s *)(id)gconnectionLogObj;
                                  if (os_log_type_enabled(v260, OS_LOG_TYPE_INFO))
                                  {
                                    int v261 = nw_endpoint_handler_get_id_string(v256);
                                    char v262 = nw_endpoint_handler_dry_run_string(v256);
                                    nw_endpoint_t v263 = nw_endpoint_handler_copy_endpoint(v256);
                                    nw_endpoint_t v264 = nw_endpoint_get_logging_description(v263);
                                    v265 = nw_endpoint_handler_state_string(v256);
                                    os_log_type_t v266 = nw_endpoint_handler_mode_string(v256);
                                    id v267 = nw_endpoint_handler_copy_current_path(v256);
                                    *(_DWORD *)buf = 136447746;
                                    uint64_t v379 = "nw_endpoint_flow_receive_report";
                                    __int16 v380 = 2082;
                                    __int16 v381 = (char *)v261;
                                    __int16 v382 = 2082;
                                    __int16 v383 = v262;
                                    __int16 v384 = 2082;
                                    __int16 v385 = (void *)v264;
                                    __int16 v386 = 2082;
                                    __int16 v387 = (void *)v265;
                                    __int16 v388 = 2082;
                                    __int16 v389 = (void *)v266;
                                    __int16 v390 = 2114;
                                    id v391 = v267;
                                    _os_log_impl( &dword_181A5C000,  v260,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] c onnected child failed when a better path is available",  buf,  0x48u);
                                  }
                                }

                                goto LABEL_363;
                              }

                              if ((*((_BYTE *)v355 + 33) & 4) == 0)
                              {
                                nw_endpoint_t v268 = v256;
                                int v269 = v256->state;

                                if (v269 == 5) {
                                  goto LABEL_349;
                                }
                                int v270 = nw_endpoint_handler_get_minimize_logging(v268);
                                char v271 = nw_endpoint_handler_get_logging_disabled(v268);
                                if (v270)
                                {
                                  v272 = v355;
                                  if ((v271 & 1) != 0) {
                                    goto LABEL_377;
                                  }
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  id v273 = (os_log_s *)(id)gconnectionLogObj;
                                  if (os_log_type_enabled(v273, OS_LOG_TYPE_DEBUG))
                                  {
                                    id v323 = nw_endpoint_handler_get_id_string(v268);
                                    os_log_type_t v324 = nw_endpoint_handler_dry_run_string(v268);
                                    nw_endpoint_t v325 = nw_endpoint_handler_copy_endpoint(v268);
                                    os_log_type_t v326 = nw_endpoint_get_logging_description(v325);
                                    id v327 = nw_endpoint_handler_state_string(v268);
                                    id v328 = nw_endpoint_handler_mode_string(v268);
                                    id v329 = nw_endpoint_handler_copy_current_path(v268);
                                    *(_DWORD *)buf = 136447746;
                                    uint64_t v379 = "nw_endpoint_flow_receive_report";
                                    __int16 v380 = 2082;
                                    __int16 v381 = (char *)v323;
                                    __int16 v382 = 2082;
                                    __int16 v383 = v324;
                                    __int16 v384 = 2082;
                                    __int16 v385 = (void *)v326;
                                    __int16 v386 = 2082;
                                    __int16 v387 = (void *)v327;
                                    __int16 v388 = 2082;
                                    __int16 v389 = (void *)v328;
                                    __int16 v390 = 2114;
                                    id v391 = v329;
                                    _os_log_impl( &dword_181A5C000,  v273,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed",  buf,  0x48u);
                                  }
                                }

                                else
                                {
                                  v272 = v355;
                                  if ((v271 & 1) != 0)
                                  {
LABEL_377:
                                    if ((*((_BYTE *)v272 + 33) & 8) == 0) {
                                      nw_endpoint_handler_handle_failure(v268);
                                    }
                                    v268->event = (nw_endpoint_handler_event_s)720899;
                                    nw_endpoint_handler_report(v268, 0LL, &v268->event.domain, 0LL);
                                    goto LABEL_349;
                                  }

                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                                  }
                                  id v273 = (os_log_s *)(id)gconnectionLogObj;
                                  if (os_log_type_enabled(v273, OS_LOG_TYPE_INFO))
                                  {
                                    v274 = nw_endpoint_handler_get_id_string(v268);
                                    id v275 = nw_endpoint_handler_dry_run_string(v268);
                                    nw_endpoint_t v276 = nw_endpoint_handler_copy_endpoint(v268);
                                    char v277 = nw_endpoint_get_logging_description(v276);
                                    nw_endpoint_t v278 = nw_endpoint_handler_state_string(v268);
                                    v279 = nw_endpoint_handler_mode_string(v268);
                                    id v280 = nw_endpoint_handler_copy_current_path(v268);
                                    *(_DWORD *)buf = 136447746;
                                    uint64_t v379 = "nw_endpoint_flow_receive_report";
                                    __int16 v380 = 2082;
                                    __int16 v381 = (char *)v274;
                                    __int16 v382 = 2082;
                                    __int16 v383 = v275;
                                    __int16 v384 = 2082;
                                    __int16 v385 = (void *)v277;
                                    __int16 v386 = 2082;
                                    __int16 v387 = (void *)v278;
                                    __int16 v388 = 2082;
                                    __int16 v389 = (void *)v279;
                                    __int16 v390 = 2114;
                                    id v391 = v280;
                                    _os_log_impl( &dword_181A5C000,  v273,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed",  buf,  0x48u);
                                  }
                                }

                                v272 = v355;
                                goto LABEL_377;
                              }
                            }

                            else if ((*((_BYTE *)v44 + 33) & 4) == 0 || a3 <= 3 && (*((_BYTE *)v44 + 32) & 0x20) != 0)
                            {
                              goto LABEL_349;
                            }

                            nw_endpoint_t v281 = v359;
                            unsigned int v282 = v281[30];

                            if (v282 != 5)
                            {
                              uint64_t v283 = v281;
                              v281[30] = a3;

                              nw_endpoint_handler_report(v283, 0LL, a4, 0LL);
                            }

                            goto LABEL_349;
                          }

          __int16 v70 = v50;
          id v46 = v70[8];

          if (!v46) {
            goto LABEL_110;
          }
          __int16 v72 = (os_unfair_lock_s *)v46;
          char v73 = v72;
          if (v72 == (os_unfair_lock_s *)&__block_literal_global_5_41854
            || v72 == (os_unfair_lock_s *)&__block_literal_global_4
            || v72 == (os_unfair_lock_s *)&__block_literal_global_3_41839
            || v72 == (os_unfair_lock_s *)&__block_literal_global_41831)
          {

LABEL_108:
            uint64_t v76 = *(nw_protocol_stack **)(handle + 232);
            *(void *)(handle + 232) = 0LL;
            goto LABEL_109;
          }

          os_unfair_lock_lock(v72 + 28);
          char v74 = *(void *)&v73[22]._os_unfair_lock_opaque;
          if (v74) {
            char v74 = (uint64_t)(*(void *)(v74 + 24) - *(void *)(v74 + 16)) >> 3;
          }
          uint64_t v75 = v74 == 0;
          os_unfair_lock_unlock(v73 + 28);

          if (v75) {
            goto LABEL_108;
          }
          uint64_t v76 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(handle + 176));
          BOOL v77 = nw_protocol_stack_copy_transport_protocol(v76);
          __int16 v78 = nw_protocol_options_copy_definition(v77);
          nw_endpoint_t v79 = nw_content_context_copy_protocol_metadata((nw_content_context_t)v73, v78);
          __int16 v80 = *(void **)(handle + 232);
          *(void *)(handle + 232) = v79;

LABEL_109:
          *(_WORD *)(handle + 332) |= 2u;
LABEL_110:
          os_log_type_t v321 = 0LL;
          os_log_type_t v322 = (uint64_t)&v321;
          LODWORD(v324[0]) = 0;
          id v323 = 0x2020000000LL;
          if ((*(_WORD *)(v45 + 204) & 2) != 0) {
            break;
          }
          if (!*(void *)(v45 + 112)
            || (*(_WORD *)(v45 + 204) & 0x100) != 0
            && g_channel_check_validity
            && !g_channel_check_validity(v45, *(void *)(v45 + 88)))
          {
            uint64_t v83 = 0;
            BOOL v86 = 0LL;
            if ((v320 & 0x100000000LL) == 0) {
              goto LABEL_129;
            }
          }

          else
          {
            uint64_t v82 = *(_DWORD *)(v45 + 52);
            id v81 = *(unsigned int *)(v45 + 56);
            if (v82) {
              uint64_t v83 = v82 - (v81 + *(_DWORD *)(v45 + 60));
            }
            else {
              uint64_t v83 = 0;
            }
            BOOL v86 = *(void *)(v45 + 112) + v81;
            if ((v320 & 0x100000000LL) == 0) {
              goto LABEL_129;
            }
          }

          if (v301 > v83)
          {
            if ((nw_endpoint_handler_get_logging_disabled(v294) & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              id v144 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
              {
                os_log_type_t v311 = v144;
                os_log_type_t v145 = nw_endpoint_handler_get_id_string(v294);
                os_log_type_t v146 = nw_endpoint_handler_dry_run_string(v294);
                int v147 = nw_endpoint_handler_copy_endpoint(v294);
                os_log_type_t v148 = nw_endpoint_get_logging_description(v147);
                os_log_type_t v298 = nw_endpoint_handler_state_string(v294);
                v286 = nw_endpoint_handler_mode_string(v294);
                v149 = nw_endpoint_handler_copy_current_path(v294);
                *(_DWORD *)buf = 136448258;
                *(void *)&uint8_t buf[4] = "nw_flow_prepare_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v145;
                *(_WORD *)&buf[22] = 2082;
                v338 = v146;
                *(_WORD *)v339 = 2082;
                *(void *)&v339[2] = v148;
                *(_WORD *)&v339[10] = 2082;
                *(void *)&v339[12] = v298;
                *(_WORD *)&v339[20] = 2082;
                *(void *)&v339[22] = v286;
                nw_endpoint_t v340 = 2114;
                v341 = v149;
                os_log_t v342 = 1024;
                os_log_t v343 = v83;
                id v344 = 2048;
                id v144 = v311;
                id v345 = v301;
                _os_log_impl( &dword_181A5C000,  v311,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Data won't fit in frame (%u < %zu)",  buf,  0x58u);
              }
            }

            nw_write_request_fail(v70, 40);
            goto LABEL_245;
          }

  if (v25) {
LABEL_98:
  }
    free(v25);
LABEL_99:
  uint64_t v45 = *((void *)self + 8);
  id v46 = (void *)*((void *)self + 4);
  v52[0] = MEMORY[0x1895F87A8];
  v52[1] = 3221225472LL;
  v52[2] = __33__NWConcrete_nw_resolver_dealloc__block_invoke;
  v52[3] = &__block_descriptor_40_e5_v8__0l;
  void v52[4] = v45;
  nw_queue_context_async_if_needed(v46, v52);
LABEL_100:
  BOOL v47 = *((void *)self + 20);
  if (v47)
  {
    nw_queue_cancel_source(v47, (uint64_t)a2);
    *((void *)self + 20) = 0LL;
  }

  BOOL v48 = (void *)*((void *)self + 28);
  if (v48)
  {
    free(v48);
    *((void *)self + 2_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
  }

  v51.receiver = self;
  v51.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_resolver;
  -[NWConcrete_nw_resolver dealloc](&v51, sel_dealloc, v49, v50);
}

    if (v40) {
      free(v40);
    }
    goto LABEL_99;
  }

  if ((v16 & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a1, *(void *)(a1 + 88))
    || (os_log_type_t v17 = *(void *)(a1 + 112)) == 0
    || (BOOL v18 = *(_DWORD *)(a1 + 48)) == 0)
  {
    id v32 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_INFO)) {
      goto LABEL_62;
    }
    BOOL v48 = "";
    if (a6) {
      BOOL v48 = (const char *)(a6 + 96);
    }
    *(_DWORD *)buf = 136446466;
    BOOL v56 = "udp_validate_cksum_internal";
    os_log_type_t v57 = 2082;
    unsigned int v58 = (void *)v48;
    char v34 = "%{public}s %{public}s Frame buffer no longer valid";
    goto LABEL_61;
  }

  char v19 = *(void *)(a1 + 112);
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0
    || (char v19 = *(void *)(a1 + 112), !g_channel_check_validity)
    || g_channel_check_validity(a1, *(void *)(a1 + 88)) && (char v19 = *(void *)(a1 + 112)) != 0)
  {
    char v20 = (unsigned __int16)(v19 + *(_DWORD *)(a1 + 56) - v17);
    os_log_type_t v21 = v20 + a2;
    if ((a5 & 1) != 0 || !v51 || v51 == v20)
    {
      if (a5)
      {
        if (v51 == v20 && v18 == v21)
        {
          os_log_type_t v12 = 0;
          goto LABEL_12;
        }
      }

      else if (v18 == v21)
      {
        os_log_type_t v12 = 0;
        goto LABEL_40;
      }
    }

    BOOL v22 = v18 - v21;
    os_log_type_t v50 = in_adjust_cksum(v17, v18, v51, v20, a2, v50);
    if (v20 <= v51) {
      os_log_type_t v12 = v22 - v20 + v51;
    }
    else {
      os_log_type_t v12 = v22 + v20 - v51;
    }
LABEL_11:
    if (a5)
    {
LABEL_12:
      uint64_t v13 = in6_pseudo(a3, a4, bswap32(a2 + 17) + v50);
      if (a6)
      {
        if (v12)
        {
          __int16 v14 = *(void *)(a6 + 64);
          if (v14)
          {
            char v15 = *(void *)(v14 + 64) + v12;
            ++*(void *)(v14 + 56);
            *(void *)(v14 + 64) = v15;
          }
        }
      }

      goto LABEL_44;
    }

            free(v35);
            nw_endpoint_t v35 = 0LL;
            goto LABEL_98;
          }

          *((_BYTE *)v35 + 5) = v53;
          if (bonjour_service_name && v49) {
            memcpy(v35 + 3, bonjour_service_name, v49);
          }
          if (bonjour_service_type && v50) {
            memcpy((char *)v35 + v49 + 6, bonjour_service_type, v50);
          }
          if (bonjour_service_domain && v51) {
            memcpy((char *)v35 + v49 + v50 + 6, bonjour_service_domain, v51);
          }
          os_log_type_t v57 = v53 + 4;
          unsigned int v2 = endpoint;
          os_log_type_t type = v90;
          unsigned int v3 = &qword_18C45F000;
          uint64_t v26 = v77;
          BOOL v22 = v78;
          os_log_type_t v21 = v80;
          if (!v77)
          {
LABEL_121:
            if (*((_BYTE *)v96 + 24) && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              uint64_t v84 = v21;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v68 = (os_log_s *)v3[131];
              if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v69 = *((unsigned __int8 *)v96 + 24);
                *(_DWORD *)buf = 136446978;
                BOOL v100 = "nw_shoes_create_request";
                BOOL v101 = 2082;
                BOOL v102 = a1 + 151;
                nw_endpoint_t v103 = 2082;
                os_log_type_t v104 = "flags";
                id v105 = 1024;
                *(_DWORD *)os_log_type_t v106 = v69;
                _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s sending tlv: %{public}s(%#x)",  buf,  0x26u);
              }

              v57 += nw_shoes_add_tlv( (uint64_t)v35 + (unsigned __int16)(v57 + 2),  (unsigned __int16)(v25 - (v57 + 2)),  2u,  1uLL,  v96 + 3);
              os_log_type_t v21 = v84;
            }

            if (v21 && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              __int16 v70 = v21;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v71 = (os_log_s *)v3[131];
              if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                BOOL v100 = "nw_shoes_create_request";
                BOOL v101 = 2082;
                BOOL v102 = a1 + 151;
                nw_endpoint_t v103 = 2082;
                os_log_type_t v104 = "extended_flags";
                id v105 = 1024;
                *(_DWORD *)os_log_type_t v106 = v70;
                _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s sending tlv: %{public}s(%#x)",  buf,  0x26u);
              }

              v57 += nw_shoes_add_tlv( (uint64_t)v35 + (unsigned __int16)(v57 + 2),  (unsigned __int16)(v25 - (v57 + 2)),  9u,  4uLL,  &v94);
              os_log_type_t type = v90;
            }

            if ((v88 & 1) == 0 && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v72 = (os_log_s *)v3[131];
              if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                BOOL v100 = "nw_shoes_create_request";
                BOOL v101 = 2082;
                BOOL v102 = a1 + 151;
                nw_endpoint_t v103 = 2082;
                os_log_type_t v104 = "bundle_id";
                id v105 = 2080;
                *(void *)os_log_type_t v106 = __s;
                _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s sending tlv: %{public}s(%s)",  buf,  0x2Au);
              }

              char v73 = strlen(__s);
              v57 += nw_shoes_add_tlv( (uint64_t)v35 + (unsigned __int16)(v57 + 2),  (unsigned __int16)(v25 - (v57 + 2)),  3u,  v73,  __s);
            }

            if ((v89 & 1) == 0)
            {
              LOBYTE(__src) = v86;
              *(_WORD *)((char *)&__src + 1) = v79;
              if ((unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                char v74 = (os_log_s *)v3[131];
                if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136447234;
                  BOOL v100 = "nw_shoes_create_request";
                  BOOL v101 = 2082;
                  BOOL v102 = a1 + 151;
                  nw_endpoint_t v103 = 2082;
                  os_log_type_t v104 = "multipath";
                  id v105 = 1024;
                  *(_DWORD *)os_log_type_t v106 = v86;
                  *(_WORD *)&v106[4] = 1024;
                  *(_DWORD *)&v106[6] = __rev16(v79);
                  _os_log_impl( &dword_181A5C000,  v74,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s sending tlv: %{public}s(%u/%u)",  buf,  0x2Cu);
                }

                v57 += nw_shoes_add_tlv( (uint64_t)v35 + (unsigned __int16)(v57 + 2),  (unsigned __int16)(v25 - (v57 + 2)),  5u,  3uLL,  &__src);
              }
            }

            if (v22 && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v75 = (os_log_s *)v3[131];
              if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                BOOL v100 = "nw_shoes_create_request";
                BOOL v101 = 2082;
                BOOL v102 = a1 + 151;
                nw_endpoint_t v103 = 2082;
                os_log_type_t v104 = "udp_associate";
                id v105 = 1024;
                *(_DWORD *)os_log_type_t v106 = __rev16(v22);
                _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s sending tlv: %{public}s(%u)",  buf,  0x26u);
              }

              v57 += nw_shoes_add_tlv( (uint64_t)v35 + (unsigned __int16)(v57 + 2),  (unsigned __int16)(v25 - (v57 + 2)),  6u,  2uLL,  &v93);
            }

            void *v35 = bswap32(v57) >> 16;
            else {
              uint64_t v76 = __rev16(nw_endpoint_get_port(v2));
            }
            *(_WORD *)((char *)v35 + 3) = v76;
            if (!v2) {
              goto LABEL_100;
            }
            goto LABEL_99;
          }

  if (v63) {
    free(v63);
  }
LABEL_26:
  instance_to_join = 0LL;
LABEL_34:

  return instance_to_join;
}

  if (v4) {
LABEL_25:
  }
    free((void *)v4);
}

  if (v4) {
LABEL_25:
  }
    free((void *)v4);
}

  if (v4) {
LABEL_25:
  }
    free((void *)v4);
}

      nw_endpoint_flow_cleanup_protocol(v5, (uint64_t)v6, 1);
      os_log_type_t v124 = v6[23];
      v6[23] = 0LL;

      free(v6);
      int v6 = 0LL;
LABEL_123:

      return (BOOL)v6;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
    os_log_type_t v148 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v212 = 0;
    if (__nwlog_fault(v148, type, &v212))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v149 = (os_log_s *)__nwlog_obj();
        nw_endpoint_t v150 = type[0];
        if (!os_log_type_enabled(v149, type[0])) {
          goto LABEL_144;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
        os_log_type_t v151 = "%{public}s called with null protocol";
LABEL_142:
        v158 = v149;
        id v159 = v150;
LABEL_143:
        _os_log_impl(&dword_181A5C000, v158, v159, v151, buf, 0xCu);
        goto LABEL_144;
      }

      if (!v212)
      {
        v149 = (os_log_s *)__nwlog_obj();
        nw_endpoint_t v150 = type[0];
        if (!os_log_type_enabled(v149, type[0])) {
          goto LABEL_144;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
        os_log_type_t v151 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_142;
      }

      BOOL v152 = (char *)__nw_create_backtrace_string();
      uint64_t v153 = (os_log_s *)__nwlog_obj();
      os_log_type_t v154 = type[0];
      BOOL v155 = os_log_type_enabled(v153, type[0]);
      if (v152)
      {
        if (v155)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
          uint64_t v215 = 2082;
          nw_endpoint_t v216 = (uint64_t)v152;
          _os_log_impl( &dword_181A5C000,  v153,  v154,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v152);
        goto LABEL_144;
      }

      if (v155)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_is_zombie";
        os_log_type_t v151 = "%{public}s called with null protocol, no backtrace";
        v158 = v153;
        id v159 = v154;
        goto LABEL_143;
      }
    }
      }
    }

    goto LABEL_98;
  }

  if (v1 != (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_18956)
  {
    if (networkd_settings_get_BOOL((const char *)nw_setting_disable_quic))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v3 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_parameters_create_quic_connection";
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s QUIC is disabled, cannot create QUIC connection",  buf,  0xCu);
      }

      goto LABEL_7;
    }

    id v5 = nw_parameters_create();
    if (v5)
    {
      if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
      }
      options = nw_protocol_create_options((void *)nw_protocol_copy_quic_connection_definition::quic_definition);
      nw_protocol_options_set_prohibit_joining(options);
      if (options)
      {
        id v7 = (id *)*((id *)v5 + 19);
        __int16 v8 = v7;
        if (v7)
        {
          objc_storeStrong(v7 + 3, options);
          *((_BYTE *)v5 + 92) = 2;
          uint64_t v4 = v5;
LABEL_16:

LABEL_57:
          goto LABEL_58;
        }

        __nwlog_obj();
        id v40 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_parameters_create_quic_connection";
        os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v50 = 0;
        if (__nwlog_fault(v41, &type, &v50))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            __int16 v43 = type;
            if (os_log_type_enabled(v42, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v53 = "nw_parameters_create_quic_connection";
              _os_log_impl(&dword_181A5C000, v42, v43, "%{public}s called with null stack", buf, 0xCu);
            }
          }

          else if (v50)
          {
            id v46 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            int v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v47 = type;
            BOOL v48 = os_log_type_enabled(v42, type);
            if (v46)
            {
              if (v48)
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v53 = "nw_parameters_create_quic_connection";
                id v54 = 2082;
                os_log_type_t v55 = v46;
                _os_log_impl( &dword_181A5C000,  v42,  v47,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v46);
              goto LABEL_111;
            }

            if (v48)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v53 = "nw_parameters_create_quic_connection";
              _os_log_impl(&dword_181A5C000, v42, v47, "%{public}s called with null stack, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            int v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v49 = type;
            if (os_log_type_enabled(v42, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v53 = "nw_parameters_create_quic_connection";
              _os_log_impl( &dword_181A5C000,  v42,  v49,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        free(v28);
        goto LABEL_98;
      }

      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v52 = "nw_parameters_create_custom_ip";
        _os_log_impl( &dword_181A5C000,  v29,  v37,  "%{public}s called with null (configure_ip != (_nw_parameters_configure_protocol_disable)), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v47 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v52 = "nw_parameters_create_custom_ip";
        _os_log_impl( &dword_181A5C000,  v29,  v47,  "%{public}s called with null (configure_ip != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded",  buf,  0xCu);
      }
    }

      free(v12);
      goto LABEL_98;
    }

    *(_DWORD *)os_log_type_t type = 1;
    if (ioctl(v10, 0x8004667EuLL, type))
    {
      uint64_t v26 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)uint64_t v64 = 136446466;
      os_log_type_t v65 = "network_config_setup_policy_event_watcher";
      char v66 = 1024;
      *(_DWORD *)int v67 = v26;
      os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
      unsigned int v58 = OS_LOG_TYPE_ERROR;
      BOOL v56 = 0;
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (os_log_s *)gLogObj;
        __int16 v14 = v58;
        if (!os_log_type_enabled((os_log_t)gLogObj, v58)) {
          goto LABEL_96;
        }
        *(_DWORD *)uint64_t v64 = 136446466;
        os_log_type_t v65 = "network_config_setup_policy_event_watcher";
        char v66 = 1024;
        *(_DWORD *)int v67 = v26;
        char v15 = "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d";
        goto LABEL_94;
      }

      if (!v56)
      {
        uint64_t v13 = (os_log_s *)__nwlog_obj();
        __int16 v14 = v58;
        if (!os_log_type_enabled(v13, v58)) {
          goto LABEL_96;
        }
        *(_DWORD *)uint64_t v64 = 136446466;
        os_log_type_t v65 = "network_config_setup_policy_event_watcher";
        char v66 = 1024;
        *(_DWORD *)int v67 = v26;
        char v15 = "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_94;
      }

      uint64_t v36 = (char *)__nw_create_backtrace_string();
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      __int16 v14 = v58;
      char v37 = os_log_type_enabled(v13, v58);
      if (!v36)
      {
        if (!v37) {
          goto LABEL_96;
        }
        *(_DWORD *)uint64_t v64 = 136446466;
        os_log_type_t v65 = "network_config_setup_policy_event_watcher";
        char v66 = 1024;
        *(_DWORD *)int v67 = v26;
        char v15 = "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, no backtrace";
        goto LABEL_94;
      }

      if (v37)
      {
        *(_DWORD *)uint64_t v64 = 136446722;
        os_log_type_t v65 = "network_config_setup_policy_event_watcher";
        char v66 = 1024;
        *(_DWORD *)int v67 = v26;
        v67[2] = 2082;
        *(void *)&v67[3] = v36;
        uint64_t v38 = "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, dumping backtrace:%{public}s";
        uint64_t v39 = v13;
        id v40 = v14;
        os_log_type_t v41 = 28;
LABEL_60:
        _os_log_impl(&dword_181A5C000, v39, v40, v38, v64, v41);
        goto LABEL_61;
      }

      goto LABEL_61;
    }

    char v34 = dispatch_source_create(MEMORY[0x1895F8B60], v10, 0LL, (dispatch_queue_t)nw_policy_event_queue(void)::queue);
    network_config_setup_policy_event_watcher(void)::kevsrc = (uint64_t)v34;
    if (v34)
    {
      nw_endpoint_t v35 = MEMORY[0x1895F87A8];
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL41network_config_setup_policy_event_watcherv_block_invoke;
      uint64_t v62 = &__block_descriptor_tmp_10_23903;
      BOOL v63 = v10;
      dispatch_source_set_cancel_handler(v34, buf);
      *(void *)handler = v35;
      uint64_t v52 = 0x40000000LL;
      os_log_type_t v53 = ___ZL41network_config_setup_policy_event_watcherv_block_invoke_2;
      id v54 = &__block_descriptor_tmp_12_23904;
      os_log_type_t v55 = v10;
      dispatch_source_set_event_handler( (dispatch_source_t)network_config_setup_policy_event_watcher(void)::kevsrc,  handler);
      dispatch_activate((dispatch_object_t)network_config_setup_policy_event_watcher(void)::kevsrc);
      unsigned int v2 = *(dispatch_object_s **)(a1 + 48);
      if (v2)
      {
LABEL_3:
        unsigned int v3 = *(const void **)(a1 + 32);
        if (v3)
        {
          uint64_t v4 = *(_DWORD *)(a1 + 56);
          if ((v4 - 1) >= 4)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v16 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&void buf[14] = v4;
              _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s Invalid policy event type %u",  buf,  0x12u);
            }

            goto LABEL_108;
          }

          id v5 = (xpc_object_t *)off_189BB9770[v4 - 1];
          if (*v5 || (v6 = xpc_array_create(0LL, 0LL), (*id v5 = v6) != 0LL))
          {
            id v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
            if (v7)
            {
              __int16 v8 = v7;
              _Block_copy(v3);
              dispatch_retain(v2);
              xpc_dictionary_set_pointer();
              xpc_dictionary_set_pointer();
              xpc_array_append_value(*v5, v8);
LABEL_109:
              *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v8;
              return;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
            BOOL v22 = (char *)_os_log_send_and_compose_impl();
            handler[0] = OS_LOG_TYPE_ERROR;
            v64[0] = 0;
            if (handler[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v23 = (os_log_s *)gLogObj;
              uint64_t v24 = handler[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, handler[0])) {
                goto LABEL_106;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              BOOL v25 = "%{public}s xpc_dictionary_create failed";
              goto LABEL_105;
            }

            if (!v64[0])
            {
              BOOL v23 = (os_log_s *)__nwlog_obj();
              uint64_t v24 = handler[0];
              if (!os_log_type_enabled(v23, handler[0])) {
                goto LABEL_106;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              BOOL v25 = "%{public}s xpc_dictionary_create failed, backtrace limit exceeded";
              goto LABEL_105;
            }

            id v31 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v23 = (os_log_s *)gLogObj;
            uint64_t v24 = handler[0];
            id v32 = os_log_type_enabled((os_log_t)gLogObj, handler[0]);
            if (!v31)
            {
              if (!v32) {
                goto LABEL_106;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              BOOL v25 = "%{public}s xpc_dictionary_create failed, no backtrace";
              goto LABEL_105;
            }

            if (v32)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v31;
              id v33 = "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s";
LABEL_71:
              _os_log_impl(&dword_181A5C000, v23, v24, v33, buf, 0x16u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
            BOOL v22 = (char *)_os_log_send_and_compose_impl();
            handler[0] = OS_LOG_TYPE_ERROR;
            v64[0] = 0;
            if (handler[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v23 = (os_log_s *)gLogObj;
              uint64_t v24 = handler[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, handler[0])) {
                goto LABEL_106;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              BOOL v25 = "%{public}s xpc_array_create failed";
              goto LABEL_105;
            }

            if (!v64[0])
            {
              BOOL v23 = (os_log_s *)__nwlog_obj();
              uint64_t v24 = handler[0];
              if (!os_log_type_enabled(v23, handler[0])) {
                goto LABEL_106;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              BOOL v25 = "%{public}s xpc_array_create failed, backtrace limit exceeded";
              goto LABEL_105;
            }

            id v31 = (char *)__nw_create_backtrace_string();
            BOOL v23 = (os_log_s *)__nwlog_obj();
            uint64_t v24 = handler[0];
            int v42 = os_log_type_enabled(v23, handler[0]);
            if (!v31)
            {
              if (!v42) {
                goto LABEL_106;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              BOOL v25 = "%{public}s xpc_array_create failed, no backtrace";
              goto LABEL_105;
            }

            if (v42)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "network_config_add_policy_event_handler";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v31;
              id v33 = "%{public}s xpc_array_create failed, dumping backtrace:%{public}s";
              goto LABEL_71;
            }
          }

    if (v76) {
      free(v76);
    }
    goto LABEL_154;
  }

  __nwlog_obj();
  BOOL v71 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v173 = "nw_endpoint_proxy_add_config_if_applicable";
  __int16 v72 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v163[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v72, type, v163))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v74 = type[0];
      if (os_log_type_enabled(v73, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v173 = "nw_endpoint_proxy_add_config_if_applicable";
        _os_log_impl(&dword_181A5C000, v73, v74, "%{public}s called with null original_config", buf, 0xCu);
      }
    }

    else
    {
      if (v163[0])
      {
        nw_endpoint_t v79 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v81 = type[0];
        uint64_t v82 = os_log_type_enabled(v80, type[0]);
        if (v79)
        {
          if (v82)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v173 = "nw_endpoint_proxy_add_config_if_applicable";
            nw_endpoint_t v174 = 2082;
            os_log_type_t v175 = v79;
            _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s called with null original_config, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v79);
        }

        else
        {
          if (v82)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v173 = "nw_endpoint_proxy_add_config_if_applicable";
            _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s called with null original_config, no backtrace",  buf,  0xCu);
          }
        }

        goto LABEL_92;
      }

      __nwlog_obj();
      char v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v88 = type[0];
      if (os_log_type_enabled(v73, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v173 = "nw_endpoint_proxy_add_config_if_applicable";
        _os_log_impl( &dword_181A5C000,  v73,  v88,  "%{public}s called with null original_config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    nw_frame_claim(a2, a2, 0, v43);
    goto LABEL_98;
  }

  if (gLogDatapath)
  {
    os_log_type_t v50 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v55 = "nw_frame_cache_create_frame_block_invoke";
      _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s frame was exact match, not modifying",  buf,  0xCu);
    }
  }

        if (v55) {
          free(v55);
        }
        goto LABEL_64;
      }

      uint64_t v36 = *(void *)(a1 + 40);
      if (v36 && (*(_BYTE *)(v36 + 348) & 1) != 0
        || (pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once),
            networkd_settings_init(),
            id v30 = (os_log_s *)gLogObj,
            !os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)))
      {
LABEL_60:
        nw_frame_finalize(a2);
        return 1LL;
      }

      char v37 = *(void *)(a1 + 40);
      uint64_t v38 = "";
      uint64_t v39 = v37 == 0;
      if (v37) {
        id v40 = (const char *)(v37 + 349);
      }
      else {
        id v40 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_read_response_block_invoke";
      if (!v39) {
        uint64_t v38 = " ";
      }
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v40;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v64 = v38;
      nw_endpoint_t v35 = "%{public}s %{public}s%sNo HTTP response in metadata";
    }

    else
    {
      char v29 = *(void *)(a1 + 40);
      if (v29 && (*(_BYTE *)(v29 + 348) & 1) != 0) {
        goto LABEL_60;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v30 = (os_log_s *)gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_60;
      }
      id v31 = *(void *)(a1 + 40);
      id v32 = "";
      id v33 = v31 == 0;
      if (v31) {
        char v34 = (const char *)(v31 + 349);
      }
      else {
        char v34 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_read_response_block_invoke";
      if (!v33) {
        id v32 = " ";
      }
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v34;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v64 = v32;
      nw_endpoint_t v35 = "%{public}s %{public}s%sNo HTTP metadata in input frame";
    }

    _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_ERROR, v35, buf, 0x20u);
    goto LABEL_60;
  }

  nw_frame_finalize(a2);
  BOOL v18 = *(void *)(a1 + 40);
  if (!v18 || (*(_BYTE *)(v18 + 348) & 1) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        char v19 = *(void *)(a1 + 40);
        char v20 = "";
        os_log_type_t v21 = v19 == 0;
        if (v19) {
          BOOL v22 = (const char *)(v19 + 349);
        }
        else {
          BOOL v22 = "";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_read_response_block_invoke";
        if (!v21) {
          char v20 = " ";
        }
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = v22;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v64 = v20;
        os_log_type_t v17 = "%{public}s %{public}s%sDropping unneeded input frame";
        goto LABEL_19;
      }
    }
  }

  return 1LL;
}

  [MEMORY[0x189607968] numberWithBool:self->_prohibitExpensive];
  uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
  [v4 setObject:v64 forKey:@"prohibitExpensive"];

  has = (__int16)self->_has;
  if ((has & 0x40) == 0)
  {
LABEL_18:
    if ((has & 0x800) == 0) {
      goto LABEL_19;
    }
    goto LABEL_99;
  }

    goto LABEL_98;
  }

  os_log_type_t v12 = *(void *)(a1 + 64);
  if (!v12)
  {
    uint64_t v26 = v5;
    __nwlog_obj();
    id v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v63 = "nw_necp_append_tlv";
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v60 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v32 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v63 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null beyond", buf, 0xCu);
      }
    }

    else if (v60)
    {
      os_log_type_t v41 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v42 = type;
      __int16 v43 = os_log_type_enabled(v29, type);
      if (v41)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v63 = "nw_necp_append_tlv";
          uint64_t v64 = 2082;
          *(void *)os_log_type_t v65 = v41;
          _os_log_impl( &dword_181A5C000,  v29,  v42,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v41);
        if (!v28) {
          goto LABEL_100;
        }
        goto LABEL_99;
      }

      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v63 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v29, v42, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v53 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v63 = "nw_necp_append_tlv";
        _os_log_impl( &dword_181A5C000,  v29,  v53,  "%{public}s called with null beyond, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_97;
  }

  uint64_t v13 = (v7 + 1);
  if (v11 >= v12)
  {
    __nwlog_obj();
    id v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    char v34 = v10;
    BOOL v63 = "nw_necp_append_tlv";
    uint64_t v64 = 2048;
    *(void *)os_log_type_t v65 = v11;
    *(_WORD *)&v65[8] = 2048;
    *(void *)char v66 = v12;
    *(_WORD *)&os_log_type_t v66[8] = 1024;
    *(_DWORD *)int v67 = v10;
    *(_WORD *)&v67[4] = 1024;
    *(_DWORD *)&v67[6] = v13;
    nw_endpoint_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v60 = 0;
    if (__nwlog_fault(v35, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136447234;
          BOOL v63 = "nw_necp_append_tlv";
          uint64_t v64 = 2048;
          *(void *)os_log_type_t v65 = v11;
          *(_WORD *)&v65[8] = 2048;
          *(void *)char v66 = v12;
          *(_WORD *)&os_log_type_t v66[8] = 1024;
          *(_DWORD *)int v67 = v34;
          *(_WORD *)&v67[4] = 1024;
          *(_DWORD *)&v67[6] = v13;
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  buf,  0x2Cu);
        }
      }

      else if (v60)
      {
        BOOL v44 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v45 = type;
        id v46 = os_log_type_enabled(v36, type);
        if (v44)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136447490;
            BOOL v63 = "nw_necp_append_tlv";
            uint64_t v64 = 2048;
            *(void *)os_log_type_t v65 = v11;
            *(_WORD *)&v65[8] = 2048;
            *(void *)char v66 = v12;
            *(_WORD *)&os_log_type_t v66[8] = 1024;
            *(_DWORD *)int v67 = v34;
            *(_WORD *)&v67[4] = 1024;
            *(_DWORD *)&v67[6] = v13;
            *(_WORD *)uint64_t v68 = 2082;
            *(void *)&v68[2] = v44;
            _os_log_impl( &dword_181A5C000,  v36,  v45,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
          }

          free(v44);
          goto LABEL_104;
        }

        if (v46)
        {
          *(_DWORD *)buf = 136447234;
          BOOL v63 = "nw_necp_append_tlv";
          uint64_t v64 = 2048;
          *(void *)os_log_type_t v65 = v11;
          *(_WORD *)&v65[8] = 2048;
          *(void *)char v66 = v12;
          *(_WORD *)&os_log_type_t v66[8] = 1024;
          *(_DWORD *)int v67 = v34;
          *(_WORD *)&v67[4] = 1024;
          *(_DWORD *)&v67[6] = v13;
          _os_log_impl( &dword_181A5C000,  v36,  v45,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  buf,  0x2Cu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v54 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136447234;
          BOOL v63 = "nw_necp_append_tlv";
          uint64_t v64 = 2048;
          *(void *)os_log_type_t v65 = v11;
          *(_WORD *)&v65[8] = 2048;
          *(void *)char v66 = v12;
          *(_WORD *)&os_log_type_t v66[8] = 1024;
          *(_DWORD *)int v67 = v34;
          *(_WORD *)&v67[4] = 1024;
          *(_DWORD *)&v67[6] = v13;
          _os_log_impl( &dword_181A5C000,  v36,  v54,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  buf,  0x2Cu);
        }
      }
    }

    if (v30) {
      free(v30);
    }
    fallback_privacy_proxy = 0LL;
    goto LABEL_11;
  }

  unsigned int v9 = v7;
  uint64_t v10 = *((_BYTE *)v9 + 80);

  id v11 = nw_array_create();
  nw_array_append(v11, v9);
  nw_array_append(v11, oblivious_http);
  if ((v10 & 0x20) != 0)
  {
    fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy((void *)v11);
    nw_proxy_config_set_is_privacy_proxy(fallback_privacy_proxy, 0, 0);
    *((_BYTE *)fallback_privacy_proxy + 170) |= 0xCu;
    *((_BYTE *)fallback_privacy_proxy + 171) |= 0x80u;
    *((_BYTE *)fallback_privacy_proxy + 172) |= 1u;
  }

  else
  {
    fallback_privacy_proxy = nw_proxy_config_create_privacy_proxy_internal((void *)v11);
    nw_proxy_config_set_is_privacy_proxy(fallback_privacy_proxy, 0, 0);
    *((_BYTE *)fallback_privacy_proxy + 170) |= 0xCu;
    *((_BYTE *)fallback_privacy_proxy + 171) |= 0x80u;
    *((_BYTE *)fallback_privacy_proxy + 172) |= 1u;
    uint64_t v13 = v9;
    __int16 v14 = v13[4];

    if (v14)
    {
      char v15 = nw_proxy_config_create_fallback_privacy_proxy((void *)v11);
      nw_proxy_config_set_is_privacy_proxy(v15, 0, 0);
      *((_BYTE *)v15 + 170) |= 0xCu;
      *((_BYTE *)v15 + 171) |= 0x80u;
      *((_BYTE *)v15 + 172) |= 1u;
      os_log_type_t v16 = fallback_privacy_proxy;
      os_log_type_t v17 = v15;
      objc_storeStrong(v16 + 11, v15);
    }
  }

LABEL_11:
LABEL_12:

  return (nw_proxy_config_t)fallback_privacy_proxy;
}

  if (v23) {
    free(v23);
  }
}

  if (v23) {
    free(v23);
  }
}

                      *(_BYTE *)(a1 + 72) = 2;
                    }

  if (v10 == 65087) {
    id v11 = 1;
  }
  else {
    id v11 = 40;
  }
  if (v5 > v11) {
    goto LABEL_53;
  }
LABEL_35:
  if (v11 > v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      BOOL v47 = "sa_dst_compare_no_dependencies";
      BOOL v48 = 1024;
      *(_DWORD *)uint64_t v49 = v11;
      v49[2] = 1024;
      *(_DWORD *)&v49[3] = v5;
      uint64_t v13 = "%{public}s ND Rule 6, prefer d2, d2 precedence %d > d1 precedence %d";
LABEL_90:
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, v13, buf, 0x18u);
      return 0xFFFFFFFFLL;
    }

    return 0xFFFFFFFFLL;
  }

  if (v2 == 2)
  {
    BOOL v23 = bswap32(*(_DWORD *)(a1 + 4));
    BOOL v18 = HIWORD(v23) == 43518 || HIBYTE(v23) == 127;
    os_log_type_t v17 = 14;
    goto LABEL_62;
  }

  if (v2 != 30)
  {
    uint64_t v24 = 0;
    goto LABEL_66;
  }

  __int16 v14 = *(unsigned __int8 *)(a1 + 8);
  if (v14 == 255)
  {
    char v34 = (*(_BYTE *)(a1 + 9) & 0xF) - 1;
    if (v34 >= 5) {
      uint64_t v24 = 14;
    }
    else {
      uint64_t v24 = dword_18272C8C8[v34];
    }
  }

  else
  {
    if (v14 == 254)
    {
      char v15 = *(unsigned __int8 *)(a1 + 9);
      os_log_type_t v16 = v15 & 0xC0;
      if (v15 <= 0xBF) {
        os_log_type_t v17 = 14;
      }
      else {
        os_log_type_t v17 = 5;
      }
      BOOL v18 = v16 == 128;
LABEL_62:
      if (v18) {
        uint64_t v24 = 2;
      }
      else {
        uint64_t v24 = v17;
      }
      goto LABEL_66;
    }

    uint64_t v24 = 14;
    if (!(*(void *)(a1 + 8) | *(void *)(a1 + 15)))
    {
      if (*(_BYTE *)(a1 + 23) == 1) {
        uint64_t v24 = 2;
      }
      else {
        uint64_t v24 = 14;
      }
    }
  }

      free(backtrace_string);
      goto LABEL_148;
    }

    if (!v55) {
      goto LABEL_148;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
    os_log_type_t v41 = "%{public}s called with null other_protocol, no backtrace";
LABEL_147:
    _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0xCu);
LABEL_148:
    if (v38) {
      free(v38);
    }
    return 0LL;
  }

  id v5 = handle + 736;
  int v6 = &qword_18C45F000;
  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      int v42 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        __int16 v43 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
        BOOL v44 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = handle + 636;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v96 = " ";
        LOWORD(v97) = 1024;
        *(_DWORD *)((char *)&v97 + 2) = v43;
        HIWORD(v97) = 2048;
        os_log_type_t v98 = v44;
        _os_log_impl(&dword_181A5C000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }

  id v7 = *((void *)handle + 4);
  if (v7)
  {
    if ((*v5 & 0x40) == 0)
    {
      if (!*((void *)handle + 29))
      {
        __int16 v8 = mach_continuous_approximate_time();
        if (v8 <= 1) {
          unsigned int v9 = 1LL;
        }
        else {
          unsigned int v9 = v8;
        }
        *((void *)handle + 29) = v9;
        id v7 = *((void *)handle + 4);
      }

      *((void *)handle + 20) = v7;
      *((void *)handle + 21) = v7;
      uint64_t v10 = *((void *)handle + 42);
      if (v10)
      {
        if (v7)
        {
          if (*(void *)(v10 + 32)) {
            goto LABEL_42;
          }
          nw_protocol_set_output_handler(*((void *)handle + 42), v7);
          id v11 = (unsigned __int16 *)(v10 + 1373);
          if (((*(unsigned __int16 *)(v10 + 1373) | (*(unsigned __int8 *)(v10 + 1375) << 16)) & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              id v81 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v82 = *(_DWORD *)(v10 + 1280);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&void buf[14] = v10 + 1289;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v96 = " ";
                LOWORD(v97) = 1024;
                *(_DWORD *)((char *)&v97 + 2) = v82;
                _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called",  buf,  0x26u);
              }
            }
          }

          os_log_type_t v12 = *(void **)(v10 + 1096);
          if (v12)
          {
            uint64_t v13 = v12;
            __int16 v14 = (v13[231] & 4) == 0;

            if (!v14)
            {
              nw_endpoint_add_edges_for_instance(*(void **)(v10 + 1096), (unsigned __int8 *)v10, 0);
LABEL_21:
              char v15 = nw_parameters_copy_protocol_options_legacy(*(void **)(v10 + 1120), *(nw_protocol **)(v10 + 32));
              if (v15)
              {
                os_log_type_t v16 = v15;
                if (nw_protocol_options_is_quic_stream(v15))
                {
                  os_log_type_t v17 = nw_quic_stream_copy_shared_connection_options(v16);
                  BOOL v18 = nw_quic_connection_get_max_datagram_frame_size(v17) != 0;
                  char v19 = *v11;
                  char v20 = v19 & 0xFFFFFFFD | (*((unsigned __int8 *)v11 + 2) << 16);
                  *id v11 = v19 & 0xFFFD | (2 * v18);
                  *((_BYTE *)v11 + 2) = BYTE2(v20);
                  os_log_type_t v21 = nw_quic_connection_get_datagram_quarter_stream_id(v17) ? 0 : 4;
                  BOOL v22 = *v11 & 0xFFFB | (*((unsigned __int8 *)v11 + 2) << 16);
                  *id v11 = *v11 & 0xFFFB | v21;
                  *((_BYTE *)v11 + 2) = BYTE2(v22);
                  if (v17) {
                    os_release(v17);
                  }
                }

                os_release(v16);
              }

              if (!*(void *)(v10 + 1240))
              {
                BOOL v23 = *(void *)(v7 + 24);
                if (v23)
                {
                  uint64_t v24 = *(uint64_t (**)(uint64_t, uint64_t, void))(v23 + 224);
                  if (v24)
                  {
                    BOOL v25 = (unsigned __int8 *)v24(v7, 255LL, 0LL);
                    id v91 = 0LL;
                    nw_endpoint_t v92 = &v91;
                    BOOL v93 = 0x2000000000LL;
                    int v94 = 0LL;
                    *(void *)buf = MEMORY[0x1895F87A8];
                    *(void *)&buf[8] = 0x40000000LL;
                    *(void *)&buf[16] = ___ZL28nw_http3_save_output_handlerP17nw_protocol_http3P11nw_protocol_block_invoke;
                    uint64_t v96 = (const char *)&unk_189BC45F8;
                    nw_endpoint_t v97 = &v91;
                    nw_array_apply(v25, (uint64_t)buf);
                    uint64_t v26 = (void *)v92[3];
                    if (v26)
                    {
                      BOOL v27 = os_retain(v26);
                      *(void *)(v10 + 1240) = v27;
                      if (*(_DWORD *)(v10 + 1276))
                      {
                        if (((*v11 | (*((unsigned __int8 *)v11 + 2) << 16)) & 0x400000) == 0)
                        {
                          if (*((_BYTE *)v6 + 1537))
                          {
                            nw_endpoint_t v88 = (os_log_s *)__nwlog_obj();
                            if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
                            {
                              BOOL v89 = *(_DWORD *)(v10 + 1280);
                              *(_DWORD *)BOOL v101 = 136446978;
                              BOOL v102 = "nw_http3_save_output_handler";
                              nw_endpoint_t v103 = 2082;
                              os_log_type_t v104 = v10 + 1289;
                              id v105 = 2080;
                              os_log_type_t v106 = " ";
                              uint64_t v107 = 1024;
                              id v108 = v89;
                              _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> enabling QUIC keepalives",  v101,  0x26u);
                            }
                          }
                        }

                        nw_quic_connection_set_keepalive(*(void **)(v10 + 1240), 0xFFFF);
                        BOOL v27 = *(void **)(v10 + 1240);
                      }

                      uint64_t v28 = nw_quic_connection_copy_sec_protocol_metadata(v27);
                      nw_http_connection_metadata_set_sec_metadata(*(void **)(v10 + 1248), v28);
                      if (v28) {
                        os_release(v28);
                      }
                    }

                    if (v25) {
                      os_release(v25);
                    }
                    _Block_object_dispose(&v91, 8);
                  }
                }
              }

              goto LABEL_42;
            }

            BOOL v90 = (unsigned __int16 *)(v10 + 1373);
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
            BOOL v77 = (char *)_os_log_send_and_compose_impl();
            v101[0] = 16;
            LOBYTE(v91) = 0;
            if (__nwlog_fault(v77, v101, &v91))
            {
              if (v101[0] == 17)
              {
                __int16 v78 = (os_log_s *)__nwlog_obj();
                nw_endpoint_t v79 = v101[0];
                if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                  goto LABEL_212;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                __int16 v80 = "%{public}s http3->remote_endpoint is not registered when connected";
                goto LABEL_211;
              }

              if (!(_BYTE)v91)
              {
                __int16 v78 = (os_log_s *)__nwlog_obj();
                nw_endpoint_t v79 = v101[0];
                if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                  goto LABEL_212;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                __int16 v80 = "%{public}s http3->remote_endpoint is not registered when connected, backtrace limit exceeded";
                goto LABEL_211;
              }

              BOOL v86 = (char *)__nw_create_backtrace_string();
              __int16 v78 = (os_log_s *)__nwlog_obj();
              nw_endpoint_t v79 = v101[0];
              os_log_type_t v87 = os_log_type_enabled(v78, (os_log_type_t)v101[0]);
              if (v86)
              {
                if (v87)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&void buf[14] = v86;
                  _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s http3->remote_endpoint is not registered when connected, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v86);
                if (!v77) {
                  goto LABEL_214;
                }
                goto LABEL_213;
              }

              if (v87)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
                __int16 v80 = "%{public}s http3->remote_endpoint is not registered when connected, no backtrace";
LABEL_211:
                _os_log_impl(&dword_181A5C000, v78, v79, v80, buf, 0xCu);
              }
            }
          }

          else
          {
            BOOL v90 = (unsigned __int16 *)(v10 + 1373);
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
            BOOL v77 = (char *)_os_log_send_and_compose_impl();
            v101[0] = 16;
            LOBYTE(v91) = 0;
            if (v101[0] == 17)
            {
              __int16 v78 = (os_log_s *)__nwlog_obj();
              nw_endpoint_t v79 = v101[0];
              if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                goto LABEL_212;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              __int16 v80 = "%{public}s http3->remote_endpoint is NULL when connected";
              goto LABEL_211;
            }

            if (!(_BYTE)v91)
            {
              __int16 v78 = (os_log_s *)__nwlog_obj();
              nw_endpoint_t v79 = v101[0];
              if (!os_log_type_enabled(v78, (os_log_type_t)v101[0])) {
                goto LABEL_212;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              __int16 v80 = "%{public}s http3->remote_endpoint is NULL when connected, backtrace limit exceeded";
              goto LABEL_211;
            }

            uint64_t v84 = (char *)__nw_create_backtrace_string();
            __int16 v78 = (os_log_s *)__nwlog_obj();
            nw_endpoint_t v79 = v101[0];
            BOOL v85 = os_log_type_enabled(v78, (os_log_type_t)v101[0]);
            if (!v84)
            {
              if (!v85) {
                goto LABEL_212;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              __int16 v80 = "%{public}s http3->remote_endpoint is NULL when connected, no backtrace";
              goto LABEL_211;
            }

            if (v85)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_add_edges";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v84;
              _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s http3->remote_endpoint is NULL when connected, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v84);
          }

    *(_DWORD *)(328 - v4_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
    BOOL v63 = &unk_18C45E8B8;
    do
    {
      uint64_t v64 = v63[12];
      v63 += 11;
    }

    while (v64 >= v54);
    *(void *)(336 - v4_Block_object_dispose((const void *)(v67 - 152), 8) = v63;
    *(_DWORD *)(512 - v4_Block_object_dispose((const void *)(v67 - 152), 8) = 0;
    *(void *)(552 - v4_Block_object_dispose((const void *)(v67 - 152), 8) = -1LL;
    os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_cache_lock);
    *(void *)(80 - v4_Block_object_dispose((const void *)(v67 - 152), 8) = 0LL;
    os_log_type_t v65 = (uint64_t *)qword_18C45F238;
    *(void *)(88 - v4_Block_object_dispose((const void *)(v67 - 152), 8) = qword_18C45F238;
    id *v65 = v51;
    qword_18C45F238 = 80 - v48;
    os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_cache_lock);
    if (gLogDatapath)
    {
      BOOL v127 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v128 = *(_DWORD *)(176 - v48);
        *(_DWORD *)buf = 136446978;
        int v156 = "nw_mem_cache_create";
        v157 = 2082;
        *(void *)v158 = 96 - v48;
        *(_WORD *)&v158[8] = 2048;
        *(void *)id v159 = -(uint64_t)v48;
        *(_WORD *)&v159[8] = 1024;
        *(_DWORD *)&v159[10] = v128;
        _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s: nwm %p mode 0x%X",  buf,  0x26u);
      }

      if (gLogDatapath)
      {
        os_log_type_t v129 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v130 = *(void *)(160 - v48);
          nw_endpoint_t v131 = *(void *)(168 - v48);
          BOOL v132 = *(void *)(232 - v48);
          BOOL v133 = *(void *)(240 - v48);
          os_log_type_t v134 = *(void *)(248 - v48);
          *(_DWORD *)buf = 136447490;
          int v156 = "nw_mem_cache_create";
          v157 = 1024;
          *(_DWORD *)v158 = v130;
          *(_WORD *)&v158[4] = 1024;
          *(_DWORD *)&v158[6] = v131;
          *(_WORD *)id v159 = 1024;
          *(_DWORD *)&v159[2] = v132;
          *(_WORD *)&v159[6] = 1024;
          *(_DWORD *)&v159[8] = v133;
          *(_WORD *)&v159[12] = 1024;
          *(_DWORD *)&v159[14] = v134;
          _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_DEBUG,  "%{public}s   bufsz %u align %u chunksz %u objsz %u slabsz %u",  buf,  0x2Au);
        }
      }
    }

    if (nw_mem_cache_ready == 1 && (*(_BYTE *)(176 - v48) & 1) == 0)
    {
      *(_DWORD *)(560 - v4_Block_object_dispose((const void *)(v67 - 152), 8) = **(_DWORD **)(336 - v48);
      if (gLogDatapath)
      {
        int v141 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v142 = *(void *)(232 - v48);
          uint64_t v143 = *(_DWORD *)(560 - v48);
          *(_DWORD *)buf = 136446978;
          int v156 = "nw_mem_cache_magazine_enable";
          v157 = 2048;
          *(void *)v158 = -(uint64_t)v48;
          *(_WORD *)&v158[8] = 1024;
          *(_DWORD *)id v159 = v142;
          *(_WORD *)&v159[4] = 1024;
          *(_DWORD *)&v159[6] = v143;
          _os_log_impl( &dword_181A5C000,  v141,  OS_LOG_TYPE_DEBUG,  "%{public}s nwm %p chunksize %u magsize %d",  buf,  0x22u);
        }
      }
    }

    v8[11] = v51;
    if (v48)
    {
      char v66 = 0LL;
      int v67 = v8 + 12;
      uint64_t v68 = 64LL;
      while (1)
      {
        uint64_t v69 = a2[v66];
        *((_BYTE *)v67 + v66) = v69;
        if (!v69) {
          break;
        }
        --v68;
        ++v66;
        if (v68 <= 1)
        {
          *((_BYTE *)v67 + v66) = 0;
          return (BOOL)v8;
        }
      }

      return (BOOL)v8;
    }

    nw_mem_buffer_manager_close(v8);
    return 0LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446978;
  int v156 = "nw_mem_cache_create";
  v157 = 2048;
  *(void *)v158 = v45;
  *(_WORD *)&v158[8] = 2048;
  *(void *)id v159 = -(uint64_t)(-v45 & 0xFFFFFFFFFFFFFFF8LL);
  *(_WORD *)&v159[8] = 2048;
  *(void *)&v159[10] = v53;
  os_log_type_t v55 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v55);
  if (!result)
  {
    free(v55);
    goto LABEL_92;
  }

      if (v221) {
        free(v221);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v9 = (os_log_s *)__nwlog_obj();
    uint64_t v10 = uu[0];
    int v223 = os_log_type_enabled(v9, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (v223)
      {
        *(_DWORD *)buf = 136446210;
        v553 = "nw_socket_set_common_sockopts";
        id v11 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_96;
      }

      goto LABEL_97;
    }

    if (v223)
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2082;
      *(void *)v555 = backtrace_string;
      char v19 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_69;
    }

    free(backtrace_string);
    goto LABEL_139;
  }

  *(void *)os_log_type_t type = 0LL;
  __int16 v14 = nw_http_oblivious_config_select(a2, a3, type);
  if (!v14 || *(void *)type <= 0x28uLL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      BOOL v18 = "%{public}s Config parsing failed";
      goto LABEL_16;
    }

    return 0LL;
  }

  char v15 = v14;
  os_log_type_t v16 = strlen(a1);
  if (v16 >= 0x101)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      BOOL v18 = "%{public}s Media type exceeds max length";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
      return 0LL;
    }

    return 0LL;
  }

  char v19 = v16;
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  char v20 = cchpke_params_sizeof_kem_enc();
  unsigned int v61 = (char *)calloc(1uLL, 0x60uLL);
  if (!v61)
  {
    BOOL v47 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v65 = "strict_calloc";
    char v66 = 2048;
    int v67 = 1LL;
    uint64_t v68 = 2048;
    uint64_t v69 = 96LL;
    BOOL v48 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v48);
    if (result) {
      goto LABEL_145;
    }
    free(v48);
  }

  os_log_type_t v21 = v20 + 7;
  if (v20 == -7)
  {
    uint64_t v49 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v65 = "strict_calloc";
    os_log_type_t v50 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v50);
    if (result) {
      goto LABEL_145;
    }
    free(v50);
    os_log_type_t v21 = v20 + 7;
  }

  os_log_type_t v59 = a7;
  int v60 = a8;
  BOOL v22 = (char *)calloc(1uLL, v21);
  if (!v22)
  {
    BOOL v51 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v65 = "strict_calloc";
    char v66 = 2048;
    int v67 = 1LL;
    uint64_t v68 = 2048;
    uint64_t v69 = v20 + 7;
    uint64_t v52 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v52);
    if (result) {
      goto LABEL_145;
    }
    free(v52);
  }

  *BOOL v22 = *(_BYTE *)v15;
  *(_WORD *)(v22 + 1) = *(unsigned __int16 *)((char *)v15 + 1);
  *(_DWORD *)(v22 + 3) = 16777472;
  uint64_t v62 = 0;
  ccrng();
  BOOL v23 = (char *)calloc(1uLL, v19 + 24);
  if (!v23)
  {
    os_log_type_t v53 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v65 = "strict_calloc";
    char v66 = 2048;
    int v67 = 1LL;
    uint64_t v68 = 2048;
    uint64_t v69 = v19 + 24;
    unsigned int v58 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v58);
    if (result) {
      goto LABEL_145;
    }
    free(v58);
  }

  uint64_t v24 = v19 + 17;
  snprintf(v23, v24, "%s chunked request", a1);
  BOOL v25 = &v23[v24];
  uint64_t v26 = *(_DWORD *)(v22 + 3);
  *(_DWORD *)BOOL v25 = *(_DWORD *)v22;
  *(_DWORD *)(v25 + 3) = v26;
  BOOL v27 = v20;
  uint64_t v28 = cchpke_initiator_setup();
  free(v23);
  if (v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v29 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v65 = "nw_http_encrypt_chunked_oblivious_request_header";
      char v66 = 1024;
      LODWORD(v67) = v28;
      _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_ERROR, "%{public}s Setup error: %d", buf, 0x12u);
    }

    free(v22);
    if (!v61) {
      return 0LL;
    }
    id v30 = v61;
LABEL_26:
    free(v30);
    return 0LL;
  }

  *a4 = v61;
  *a5 = 96LL;
  if (!v20)
  {
    id v54 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v65 = "strict_calloc";
    os_log_type_t v55 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v55);
    if (result) {
      goto LABEL_145;
    }
    free(v55);
    BOOL v27 = v20;
  }

  id v32 = calloc(1uLL, v27);
  if (v32)
  {
LABEL_31:
    *a6 = v32;
    memcpy(v32, v22 + 7, v27);
    *os_log_type_t v59 = v27;
    const char *v60 = v20 + 7;
    return (BOOL)v22;
  }

  BOOL v56 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v65 = "strict_calloc";
  char v66 = 2048;
  int v67 = 1LL;
  uint64_t v68 = 2048;
  uint64_t v69 = v27;
  os_log_type_t v57 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v57);
  if (!result)
  {
    free(v57);
    BOOL v27 = v20;
    goto LABEL_31;
  }

        goto LABEL_98;
      }

      if (!v56)
      {
        __nwlog_obj();
        nw_endpoint_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v48 = type;
        if (os_log_type_enabled(v35, type))
        {
          BOOL v63 = 136446466;
          uint64_t v64 = "nw_path_copy_path_for_client_with_context";
          os_log_type_t v65 = 1024;
          *(_DWORD *)char v66 = v25;
          _os_log_impl( &dword_181A5C000,  v35,  v48,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)&v63,  0x12u);
        }

        goto LABEL_97;
      }

      uint64_t v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v39 = type;
      id v40 = os_log_type_enabled(v35, type);
      if (!v38)
      {
        if (v40)
        {
          BOOL v63 = 136446466;
          uint64_t v64 = "nw_path_copy_path_for_client_with_context";
          os_log_type_t v65 = 1024;
          *(_DWORD *)char v66 = v25;
          _os_log_impl( &dword_181A5C000,  v35,  v39,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, no backtrace",  (uint8_t *)&v63,  0x12u);
        }

        goto LABEL_97;
      }

      if (v40)
      {
        BOOL v63 = 136446722;
        uint64_t v64 = "nw_path_copy_path_for_client_with_context";
        os_log_type_t v65 = 1024;
        *(_DWORD *)char v66 = v25;
        *(_WORD *)&v66[4] = 2082;
        *(void *)&v66[6] = v38;
        _os_log_impl( &dword_181A5C000,  v35,  v39,  "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)&v63,  0x1Cu);
      }

      free(v38);
    }

      if (v52) {
        free(v52);
      }
      goto LABEL_99;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v44 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    id v113 = "nw_path_group_member_action";
    uint64_t v45 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v101[0]) = 0;
    if (__nwlog_fault(v45, type, v101))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v46 = (os_log_s *)(id)gLogObj;
        BOOL v47 = type[0];
        if (os_log_type_enabled(v46, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v113 = "nw_path_group_member_action";
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s nw_path_create_necp_agent_group_action failed",  buf,  0xCu);
        }
      }

      else if (LOBYTE(v101[0]))
      {
        BOOL v48 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v49 = type[0];
        os_log_type_t v50 = os_log_type_enabled(v46, type[0]);
        if (v48)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            id v113 = "nw_path_group_member_action";
            id v114 = 2082;
            *(void *)os_log_type_t v115 = v48;
            _os_log_impl( &dword_181A5C000,  v46,  v49,  "%{public}s nw_path_create_necp_agent_group_action failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v48);
          if (!v45) {
            goto LABEL_90;
          }
          goto LABEL_89;
        }

        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          id v113 = "nw_path_group_member_action";
          _os_log_impl( &dword_181A5C000,  v46,  v49,  "%{public}s nw_path_create_necp_agent_group_action failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v55 = type[0];
        if (os_log_type_enabled(v46, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v113 = "nw_path_group_member_action";
          _os_log_impl( &dword_181A5C000,  v46,  v55,  "%{public}s nw_path_create_necp_agent_group_action failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v45)
    {
LABEL_90:
      id v33 = 0LL;
      unsigned int v9 = v92;
      goto LABEL_38;
    }

        goto LABEL_98;
      }

      if (!LOBYTE(v58[0]))
      {
        __nwlog_obj();
        id v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v51 = type[0];
        if (os_log_type_enabled(v31, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&void applier[4] = "nw_necp_append_tlv";
          _os_log_impl( &dword_181A5C000,  v31,  v51,  "%{public}s called with null beyond, backtrace limit exceeded",  applier,  0xCu);
        }

        goto LABEL_97;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v40 = type[0];
      os_log_type_t v41 = os_log_type_enabled(v31, type[0]);
      if (!backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&void applier[4] = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v31, v40, "%{public}s called with null beyond, no backtrace", applier, 0xCu);
        }

        goto LABEL_97;
      }

      if (v41)
      {
        *(_DWORD *)applier = 136446466;
        *(void *)&void applier[4] = "nw_necp_append_tlv";
        *(_WORD *)&applier[12] = 2082;
        *(void *)&applier[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v31,  v40,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  applier,  0x16u);
      }

      goto LABEL_67;
    }

    goto LABEL_98;
  }

  uint64_t v10 = v9 + *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  if (v8 >= v10)
  {
    os_log_type_t v57 = a1;
    __nwlog_obj();
    nw_endpoint_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136447234;
    *(void *)&void applier[4] = "nw_necp_append_tlv";
    *(_WORD *)&applier[12] = 2048;
    *(void *)&applier[14] = v8;
    *(_WORD *)&applier[22] = 2048;
    *(void *)uint64_t v64 = v10;
    *(_WORD *)&v64[8] = 1024;
    *(_DWORD *)&v64[10] = 2;
    *(_WORD *)&v64[14] = 1024;
    *(_DWORD *)&v64[16] = size;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (__nwlog_fault(v13, type, v58))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v36 = type[0];
        if (os_log_type_enabled(v14, type[0]))
        {
          *(_DWORD *)applier = 136447234;
          *(void *)&void applier[4] = "nw_necp_append_tlv";
          *(_WORD *)&applier[12] = 2048;
          *(void *)&applier[14] = v8;
          *(_WORD *)&applier[22] = 2048;
          *(void *)uint64_t v64 = v10;
          *(_WORD *)&v64[8] = 1024;
          *(_DWORD *)&v64[10] = 2;
          *(_WORD *)&v64[14] = 1024;
          *(_DWORD *)&v64[16] = size;
          _os_log_impl( &dword_181A5C000,  v14,  v36,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  applier,  0x2Cu);
        }

LABEL_122:
  if (!registered_endpoint)
  {
LABEL_129:
    unsigned int v9 = v293;
    protocol_for_definition = nw_endpoint_handler_create_protocol_for_definition( (uint64_t)identifier,  v294,  *(void **)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL),  *(void **)(a1 + 40));
    BOOL v93 = *(void **)(a1 + 32);
    if (!protocol_for_definition)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v100 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
      {
        BOOL v101 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        BOOL v102 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v103 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        os_log_type_t v104 = nw_endpoint_get_logging_description(v103);
        id v105 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        os_log_type_t v106 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        uint64_t v107 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
        uint64_t v300 = 2082;
        os_log_type_t v301 = (uint64_t)v101;
        v302 = 2082;
        os_log_type_t v303 = v102;
        BOOL v304 = 2082;
        uint64_t v305 = (void *)v104;
        os_log_type_t v306 = 2082;
        BOOL v307 = v105;
        id v308 = 2082;
        os_log_type_t v309 = v106;
        BOOL v310 = 2114;
        os_log_type_t v311 = v107;
        BOOL v312 = 2082;
        os_log_type_t v313 = identifier;
        _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create application protocol handler: %{public}s",  buf,  0x52u);
      }

      goto LABEL_190;
    }

    nw_endpoint_handler_set_protocol_instance(v93, v293, v294, protocol_for_definition);
    int v94 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL);
    if (v94)
    {
      if (protocol_for_definition != v94)
      {
        os_log_type_t v95 = *(void **)(protocol_for_definition + 24);
        if (v95 && *v95)
        {
          if ((nw_protocol_add_input_handler(protocol_for_definition, v94) & 1) != 0)
          {
            if (nw_protocol_definition_get_message_is_stream(v294))
            {
              uint64_t v96 = *(void *)(a1 + 56);
              if (!*(void *)(v96 + 768))
              {
                objc_storeStrong((id *)(v96 + 768), a3);
                if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
                {
                  BOOL v176 = *(void *)(protocol_for_definition + 88);
                  unsigned int v9 = v293;
                  if (v176) {
                    *(void *)(protocol_for_definition + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v176 + 1;
                  }
                  *(void *)buf = protocol_for_definition;
                  buf[8] |= 1u;
                }

                else
                {
                  *(void *)buf = protocol_for_definition;
                  buf[8] &= ~1u;
                  unsigned int v9 = v293;
                }

                nw::retained_ptr<nw_protocol *>::operator=(*(void *)(a1 + 56) + 776LL, (uint64_t)buf);
                if ((buf[8] & 1) != 0) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
                os_log_type_t v177 = *(void *)(protocol_for_definition + 24);
                if (v177)
                {
                  nw_endpoint_t v178 = *(uint64_t (**)(uint64_t, uint64_t, void))(v177 + 232);
                  if (v178)
                  {
                    nw_protocol_definition_t v179 = *(void *)(a1 + 56) + 440LL;
                    v180 = *(void **)(protocol_for_definition + 40);
                    if (v180 == &nw_protocol_ref_counted_handle)
                    {
                      BOOL v190 = *(void *)(protocol_for_definition + 88);
                      if (v190) {
                        *(void *)(protocol_for_definition + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v190 + 1;
                      }
                      *(void *)buf = protocol_for_definition;
                      nw_protocol_definition_t v181 = buf[8] | 1;
                    }

                    else
                    {
                      *(void *)buf = protocol_for_definition;
                      nw_protocol_definition_t v181 = buf[8] & 0xFE;
                    }

                    buf[8] = v181;
                    nw_endpoint_t v191 = v178(protocol_for_definition, v179, 0LL);
                    if (v180 == &nw_protocol_ref_counted_handle) {
                      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    }
                    if ((v191 & 1) == 0 && (nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      nw_endpoint_t v192 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
                      {
                        id v193 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                        uint64_t v194 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                        os_log_type_t v292 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                        id v195 = nw_endpoint_get_logging_description(v292);
                        uint64_t v196 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                        nw_endpoint_t v197 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                        os_log_type_t v198 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                        char v199 = v198;
                        uint64_t v200 = "invalid";
                        id v201 = *(const char **)(*(void *)(a1 + 56) + 392LL);
                        if (!v201) {
                          id v201 = "invalid";
                        }
                        if (*(void *)(protocol_for_definition + 16)) {
                          uint64_t v200 = *(const char **)(protocol_for_definition + 16);
                        }
                        *(_DWORD *)buf = 136448258;
                        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                        uint64_t v300 = 2082;
                        os_log_type_t v301 = (uint64_t)v193;
                        v302 = 2082;
                        os_log_type_t v303 = v194;
                        BOOL v304 = 2082;
                        uint64_t v305 = (void *)v195;
                        os_log_type_t v306 = 2082;
                        BOOL v307 = v196;
                        id v308 = 2082;
                        os_log_type_t v309 = v197;
                        BOOL v310 = 2114;
                        os_log_type_t v311 = v198;
                        BOOL v312 = 2082;
                        os_log_type_t v313 = (char *)v201;
                        BOOL v314 = 2082;
                        nw_endpoint_t v315 = (uint64_t)v200;
                        _os_log_impl( &dword_181A5C000,  v192,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s as a listener to %{public}s",  buf,  0x5Cu);
                      }

                      unsigned int v9 = v293;
                    }
                  }
                }
              }
            }

            if (*((_DWORD *)identifier + 9) == 2
              && nw_protocol_registrar_get_accept_function_for_identifier(identifier))
            {
              *(void *)(*(void *)(a1 + 56) + 736LL) = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL)
                                                                                + 24LL)
                                                                    + 32LL);
            }

            nw_endpoint_t v97 = *(void *)(a1 + 56);
            if (!*(void *)(v97 + 744) && *(_BYTE *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 24LL)) {
              *(void *)(v97 + 744) = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) + 32LL);
            }
            os_log_type_t v98 = *(id *)(a1 + 64);
            if (v98 && v98 == v9)
            {
              os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 880LL));
              id v99 = *(void *)(a1 + 56);
              if (*(void *)(v99 + 720))
              {
                os_unfair_lock_unlock((os_unfair_lock_t)(v99 + 880));
              }

              else
              {
                if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
                {
                  os_log_type_t v129 = *(void *)(protocol_for_definition + 88);
                  if (v129)
                  {
                    *(void *)(protocol_for_definition + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v129 + 1;
                    id v99 = *(void *)(a1 + 56);
                  }

                  *(void *)buf = protocol_for_definition;
                  uint64_t v128 = buf[8] | 1;
                }

                else
                {
                  *(void *)buf = protocol_for_definition;
                  uint64_t v128 = buf[8] & 0xFE;
                }

                buf[8] = v128;
                nw::retained_ptr<nw_protocol *>::operator=(v99 + 720, (uint64_t)buf);
                if ((buf[8] & 1) != 0) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
                os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 56) + 880LL));
                if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  os_log_type_t v130 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
                  {
                    nw_endpoint_t v131 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                    BOOL v132 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                    BOOL v133 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                    os_log_type_t v134 = nw_endpoint_get_logging_description(v133);
                    os_log_type_t v135 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                    BOOL v136 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                    char v137 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                    *(_DWORD *)buf = 136448002;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                    uint64_t v300 = 2082;
                    os_log_type_t v301 = (uint64_t)v131;
                    v302 = 2082;
                    os_log_type_t v303 = v132;
                    BOOL v304 = 2082;
                    uint64_t v305 = (void *)v134;
                    os_log_type_t v306 = 2082;
                    BOOL v307 = v135;
                    id v308 = 2082;
                    os_log_type_t v309 = v136;
                    BOOL v310 = 2114;
                    os_log_type_t v311 = v137;
                    BOOL v312 = 2082;
                    os_log_type_t v313 = identifier;
                    _os_log_impl( &dword_181A5C000,  v130,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Saved effective t ransport protocol: %{public}s",  buf,  0x52u);
                  }

                  unsigned int v9 = v293;
                }
              }
            }

            *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL)
                                                                                                + 24LL)
                                                                                    + 32LL);
            nw_endpoint_t v138 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL);
            char v139 = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
            if (v138)
            {
              if ((v139 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                os_log_type_t v140 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v140, OS_LOG_TYPE_DEBUG))
                {
                  int v141 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  uint64_t v142 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  uint64_t v143 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  id v144 = nw_endpoint_get_logging_description(v143);
                  os_log_type_t v145 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  os_log_type_t v146 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  int v147 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136448002;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  uint64_t v300 = 2082;
                  os_log_type_t v301 = (uint64_t)v141;
                  v302 = 2082;
                  os_log_type_t v303 = v142;
                  BOOL v304 = 2082;
                  uint64_t v305 = (void *)v144;
                  os_log_type_t v306 = 2082;
                  BOOL v307 = v145;
                  id v308 = 2082;
                  os_log_type_t v309 = v146;
                  BOOL v310 = 2114;
                  os_log_type_t v311 = v147;
                  BOOL v312 = 2082;
                  os_log_type_t v313 = identifier;
                  _os_log_impl( &dword_181A5C000,  v140,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached applicatio n protocol: %{public}s",  buf,  0x52u);
                }

                goto LABEL_9;
              }

              goto LABEL_12;
            }

            if ((v139 & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              os_log_type_t v148 = (id)gconnectionLogObj;
              v149 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
              nw_endpoint_t v150 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
              os_log_type_t v151 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
              BOOL v152 = nw_endpoint_get_logging_description(v151);
              uint64_t v153 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
              os_log_type_t v154 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
              BOOL v155 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
              uint64_t v300 = 2082;
              os_log_type_t v301 = (uint64_t)v149;
              v302 = 2082;
              os_log_type_t v303 = v150;
              BOOL v304 = 2082;
              uint64_t v305 = (void *)v152;
              os_log_type_t v306 = 2082;
              BOOL v307 = v153;
              id v308 = 2082;
              os_log_type_t v309 = v154;
              BOOL v310 = 2114;
              os_log_type_t v311 = v155;
              id v291 = (const char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              os_log_type_t v298 = OS_LOG_TYPE_DEFAULT;
              int v156 = (char *)v291;
              if ((__nwlog_fault(v291, type, &v298) & 1) == 0) {
                goto LABEL_269;
              }
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v157 = (os_log_s *)(id)gconnectionLogObj;
                v158 = type[0];
                if (os_log_type_enabled(v157, type[0]))
                {
                  id v159 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  v160 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  id v161 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  char v162 = nw_endpoint_get_logging_description(v161);
                  int v163 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  os_log_type_t v164 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  uint64_t v165 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  uint64_t v300 = 2082;
                  os_log_type_t v301 = (uint64_t)v159;
                  v302 = 2082;
                  os_log_type_t v303 = v160;
                  BOOL v304 = 2082;
                  uint64_t v305 = (void *)v162;
                  os_log_type_t v306 = 2082;
                  BOOL v307 = v163;
                  id v308 = 2082;
                  os_log_type_t v309 = v164;
                  BOOL v310 = 2114;
                  os_log_type_t v311 = v165;
                  _os_log_impl( &dword_181A5C000,  v157,  v158,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NULL",  buf,  0x48u);
                }
              }

              else if (v298)
              {
                id v166 = __nw_create_backtrace_string();
                if (v166)
                {
                  nw_endpoint_t v167 = (char *)v166;
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v168 = (os_log_s *)(id)gconnectionLogObj;
                  id v169 = type[0];
                  if (os_log_type_enabled(v168, type[0]))
                  {
                    v170 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                    id v171 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                    v288 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                    os_log_type_t v172 = nw_endpoint_get_logging_description(v288);
                    uint64_t v173 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                    nw_endpoint_t v174 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                    os_log_type_t v175 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                    *(_DWORD *)buf = 136448002;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                    uint64_t v300 = 2082;
                    os_log_type_t v301 = (uint64_t)v170;
                    v302 = 2082;
                    os_log_type_t v303 = v171;
                    BOOL v304 = 2082;
                    uint64_t v305 = (void *)v172;
                    os_log_type_t v306 = 2082;
                    BOOL v307 = v173;
                    id v308 = 2082;
                    os_log_type_t v309 = v174;
                    BOOL v310 = 2114;
                    os_log_type_t v311 = v175;
                    BOOL v312 = 2082;
                    os_log_type_t v313 = v167;
                    _os_log_impl( &dword_181A5C000,  v168,  v169,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NULL, dumping backtrace:%{public}s",  buf,  0x52u);
                  }

                  free(v167);
                  goto LABEL_268;
                }

                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v157 = (os_log_s *)(id)gconnectionLogObj;
                id v202 = type[0];
                if (os_log_type_enabled(v157, type[0]))
                {
                  nw_endpoint_t v203 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  v204 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  BOOL v205 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  uint64_t v206 = nw_endpoint_get_logging_description(v205);
                  id v207 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  BOOL v208 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  nw_endpoint_t v209 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  uint64_t v300 = 2082;
                  os_log_type_t v301 = (uint64_t)v203;
                  v302 = 2082;
                  os_log_type_t v303 = v204;
                  BOOL v304 = 2082;
                  uint64_t v305 = (void *)v206;
                  os_log_type_t v306 = 2082;
                  BOOL v307 = v207;
                  id v308 = 2082;
                  os_log_type_t v309 = v208;
                  BOOL v310 = 2114;
                  os_log_type_t v311 = v209;
                  _os_log_impl( &dword_181A5C000,  v157,  v202,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NU LL, no backtrace",  buf,  0x48u);
                }
              }

              else
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v157 = (os_log_s *)(id)gconnectionLogObj;
                uint64_t v182 = type[0];
                if (os_log_type_enabled(v157, type[0]))
                {
                  id v183 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  nw_endpoint_t v184 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  v185 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  BOOL v186 = nw_endpoint_get_logging_description(v185);
                  BOOL v187 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  char v188 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  nw_endpoint_t v189 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  uint64_t v300 = 2082;
                  os_log_type_t v301 = (uint64_t)v183;
                  v302 = 2082;
                  os_log_type_t v303 = v184;
                  BOOL v304 = 2082;
                  uint64_t v305 = (void *)v186;
                  os_log_type_t v306 = 2082;
                  BOOL v307 = v187;
                  id v308 = 2082;
                  os_log_type_t v309 = v188;
                  BOOL v310 = 2114;
                  os_log_type_t v311 = v189;
                  _os_log_impl( &dword_181A5C000,  v157,  v182,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NU LL, backtrace limit exceeded",  buf,  0x48u);
                }
              }

LABEL_268:
              int v156 = (char *)v291;
LABEL_269:
              unsigned int v9 = v293;
              if (v156) {
                free(v156);
              }
            }

    if (v26) {
      free(v26);
    }
    return 0LL;
  }

  if ((v9 & 0x100) != 0)
  {
    if (a4)
    {
      id v32 = *(_DWORD *)(a4 + 52);
      if (v32 && v32 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60)
        || (id v33 = *(void *)(a4 + 64)) != 0 && (*(_BYTE *)(v33 + 66) & 0x40) != 0)
      {
LABEL_185:
        if (*(void *)(a3 + 16))
        {
          if ((v10 & 0x80000) != 0 || !*((_BYTE *)v8 + 1537)) {
            goto LABEL_195;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v128 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_195;
          }
          os_log_type_t v130 = *(_DWORD *)(a3 + 176);
          os_log_type_t v129 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(void *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(void *)&v370 = " ";
          WORD4(v370) = 1024;
          *(_DWORD *)((char *)&v370 + 10) = v129;
          HIWORD(v370) = 1024;
          LODWORD(v371[0]) = v130;
          WORD2(v371[0]) = 2048;
          *(void **)((char *)v371 + 6) = (void *)a4;
          nw_endpoint_t v131 = "%{public}s %{public}s%s<i%u:s%d> stream already has pending data, pending frame %p for future send";
          goto LABEL_465;
        }

        if ((v10 & 2) == 0)
        {
          if ((v10 & 0x80000) != 0 || !*((_BYTE *)v8 + 1537)) {
            goto LABEL_195;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v128 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_195;
          }
          os_log_type_t v296 = *(_DWORD *)(a3 + 176);
          os_log_type_t v295 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(void *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(void *)&v370 = " ";
          WORD4(v370) = 1024;
          *(_DWORD *)((char *)&v370 + 10) = v295;
          HIWORD(v370) = 1024;
          LODWORD(v371[0]) = v296;
          WORD2(v371[0]) = 2048;
          *(void **)((char *)v371 + 6) = (void *)a4;
          nw_endpoint_t v131 = "%{public}s %{public}s%s<i%u:s%d> stream is not open yet, cannot submit frame %p, pending for future send";
LABEL_465:
          int v223 = (os_log_s *)v128;
          BOOL v224 = 54;
LABEL_466:
          _os_log_impl(&dword_181A5C000, v223, OS_LOG_TYPE_DEBUG, v131, (uint8_t *)buf, v224);
LABEL_195:
          nw_http2_enqueue_frame_for_stream(a3, a4);
          return 1LL;
        }

        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_25_81808);
        }
        if (_nw_signposts_enabled && kdebug_is_enabled())
        {
          kdebug_trace();
          BOOL v132 = *(_DWORD *)(a4 + 52);
          if (v132)
          {
LABEL_203:
            if (v132 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60)) {
              goto LABEL_212;
            }
          }
        }

        else
        {
          BOOL v132 = *(_DWORD *)(a4 + 52);
          if (v132) {
            goto LABEL_203;
          }
        }

        BOOL v133 = *(void *)(a4 + 64);
        if (!v133 || (*(_BYTE *)(v133 + 66) & 0x40) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v134 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_37;
          }
          os_log_type_t v135 = *(_DWORD *)(a1 + 368);
          LODWORD(buf[0]) = 136446978;
          *(void *)((char *)buf + 4) = "nw_http2_submit_data";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = a1 + 390;
          HIWORD(buf[2]) = 2080;
          *(void *)&v370 = " ";
          WORD4(v370) = 1024;
          *(_DWORD *)((char *)&v370 + 10) = v135;
          BOOL v136 = "%{public}s %{public}s%s<i%u> skipping empty frame body";
          char v137 = (os_log_s *)v134;
          nw_endpoint_t v138 = OS_LOG_TYPE_DEBUG;
          char v139 = 38;
          goto LABEL_643;
        }

    if (!a10)
    {
LABEL_84:
      if (a11) {
        goto LABEL_85;
      }
      goto LABEL_99;
    }

LABEL_347:
                          nw_endpoint_flow_setup_protocols((NWConcrete_nw_endpoint_handler *)v14, 0LL, 0LL, 1, 0);
                          goto LABEL_348;
                        }

                        BOOL v85 = v14;
                        BOOL v86 = (v14[67] & 0x20) == 0;

                        if (v86)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          os_log_type_t v87 = (os_log_s *)(id)gconnectionLogObj;
                          if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
                          {
                            nw_endpoint_t v88 = v85;

                            BOOL v89 = v88;
                            BOOL v90 = (v359[67] & 1) == 0;

                            if (v90) {
                              id v91 = "";
                            }
                            else {
                              id v91 = "dry-run ";
                            }
                            nw_endpoint_t v92 = nw_endpoint_handler_copy_endpoint(v89);
                            BOOL v93 = nw_endpoint_get_logging_description(v92);
                            int v94 = v89;
                            os_log_type_t v95 = v94;
                            uint64_t v96 = v94[30];
                            else {
                              nw_endpoint_t v97 = off_189BBBBF0[v96];
                            }

                            os_log_type_t v115 = v95;
                            int v116 = "path";
                            switch(v349[29])
                            {
                              case 0u:
                                break;
                              case 1u:
                                int v116 = "resolver";
                                break;
                              case 2u:
                                int v116 = nw_endpoint_flow_mode_string(v115[31]);
                                break;
                              case 3u:
                                int v116 = "proxy";
                                break;
                              case 4u:
                                int v116 = "fallback";
                                break;
                              case 5u:
                                int v116 = "transform";
                                break;
                              default:
                                int v116 = "unknown-mode";
                                break;
                            }

                            os_log_t v343 = (os_log_t)v116;

                            nw_endpoint_t v178 = v92;
                            nw_protocol_definition_t v179 = v97;
                            v180 = v93;
                            nw_protocol_definition_t v181 = v91;
                            uint64_t v182 = v115;
                            os_unfair_lock_lock((os_unfair_lock_t)v182 + 28);
                            id v183 = v182[8];
                            os_unfair_lock_unlock((os_unfair_lock_t)v182 + 28);

                            *(_DWORD *)buf = 136447746;
                            uint64_t v379 = "nw_endpoint_flow_receive_report";
                            __int16 v380 = 2082;
                            __int16 v381 = v88 + 168;
                            __int16 v382 = 2082;
                            __int16 v383 = v181;
                            __int16 v384 = 2082;
                            __int16 v385 = (void *)v180;
                            __int16 v386 = 2082;
                            __int16 v387 = (void *)v179;
                            __int16 v388 = 2082;
                            __int16 v389 = v343;
                            __int16 v390 = 2114;
                            id v391 = v183;
                            _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] adding ca ndidate child protocol",  buf,  0x48u);
                          }
                        }

                        nw_endpoint_t v184 = nw_endpoint_handler_copy_flow(v353);
                        os_log_type_t v126 = v184;
                        if (v184)
                        {
                          if ((nw_flow_replay_add_candidate_output_handler( v85,  (uint64_t)v355 + 376,  (uint64_t)v184 + 376) & 1) == 0)
                          {
                            v185 = v85;
                            BOOL v186 = (v359[67] & 0x20) == 0;

                            if (v186)
                            {
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                              }
                              BOOL v187 = (os_log_s *)(id)gconnectionLogObj;
                              if (os_log_type_enabled(v187, OS_LOG_TYPE_ERROR))
                              {
                                char v188 = v185;

                                nw_endpoint_t v189 = v188;
                                BOOL v190 = (v359[67] & 1) == 0;

                                if (v190) {
                                  nw_endpoint_t v191 = "";
                                }
                                else {
                                  nw_endpoint_t v191 = "dry-run ";
                                }
                                nw_endpoint_t v192 = nw_endpoint_handler_copy_endpoint(v189);
                                id v193 = nw_endpoint_get_logging_description(v192);
                                uint64_t v194 = v189;
                                id v195 = v194;
                                uint64_t v196 = v194[30];
                                else {
                                  nw_endpoint_t v197 = off_189BBBBF0[v196];
                                }
                                v360 = v197;

                                os_log_type_t v198 = v195;
                                char v199 = v198;
                                uint64_t v200 = "path";
                                switch(v349[29])
                                {
                                  case 0u:
                                    break;
                                  case 1u:
                                    uint64_t v200 = "resolver";
                                    break;
                                  case 2u:
                                    uint64_t v200 = nw_endpoint_flow_mode_string(v198[31]);
                                    break;
                                  case 3u:
                                    uint64_t v200 = "proxy";
                                    break;
                                  case 4u:
                                    uint64_t v200 = "fallback";
                                    break;
                                  case 5u:
                                    uint64_t v200 = "transform";
                                    break;
                                  default:
                                    uint64_t v200 = "unknown-mode";
                                    break;
                                }

                                v225 = v199;
                                os_unfair_lock_lock((os_unfair_lock_t)v225 + 28);
                                id v226 = v225[8];
                                os_unfair_lock_unlock((os_unfair_lock_t)v225 + 28);

                                *(_DWORD *)buf = 136447746;
                                uint64_t v379 = "nw_endpoint_flow_receive_report";
                                __int16 v380 = 2082;
                                __int16 v381 = v188 + 168;
                                __int16 v382 = 2082;
                                __int16 v383 = v191;
                                __int16 v384 = 2082;
                                __int16 v385 = (void *)v193;
                                __int16 v386 = 2082;
                                __int16 v387 = (void *)v360;
                                __int16 v388 = 2082;
                                __int16 v389 = (void *)v200;
                                __int16 v390 = 2114;
                                id v391 = v226;
                                _os_log_impl( &dword_181A5C000,  v187,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Faile d to attach to candidate child flow",  buf,  0x48u);
                              }

                              goto LABEL_333;
                            }

                            goto LABEL_334;
                          }

LABEL_345:
                          uint64_t v10 = v365;
                          BOOL v44 = v355;
                          __int16 v14 = v359;
LABEL_346:
                          if ((v348 & 1) == 0) {
                            goto LABEL_348;
                          }
                          goto LABEL_347;
                        }

                        __nwlog_obj();
                        uint64_t v300 = (void *)objc_claimAutoreleasedReturnValue();
                        *(_DWORD *)buf = 136446210;
                        uint64_t v379 = "nw_endpoint_flow_receive_report";
                        os_log_type_t v292 = (char *)_os_log_send_and_compose_impl();

                        type[0] = OS_LOG_TYPE_ERROR;
                        v373[0] = OS_LOG_TYPE_DEFAULT;
                        if (type[0] == OS_LOG_TYPE_FAULT)
                        {
                          __nwlog_obj();
                          v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          os_log_type_t v301 = type[0];
                          if (os_log_type_enabled(v293, type[0]))
                          {
                            *(_DWORD *)buf = 136446210;
                            uint64_t v379 = "nw_endpoint_flow_receive_report";
                            _os_log_impl( &dword_181A5C000,  v293,  v301,  "%{public}s called with null candidate_child_flow",  buf,  0xCu);
                          }

                          goto LABEL_469;
                        }

                        if (v373[0] == OS_LOG_TYPE_DEFAULT)
                        {
                          __nwlog_obj();
                          v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          os_log_type_t v322 = type[0];
                          if (os_log_type_enabled(v293, type[0]))
                          {
                            *(_DWORD *)buf = 136446210;
                            uint64_t v379 = "nw_endpoint_flow_receive_report";
                            _os_log_impl( &dword_181A5C000,  v293,  v322,  "%{public}s called with null candidate_child_flow, backtrace limit exceeded",  buf,  0xCu);
                          }

                          goto LABEL_469;
                        }

                        uint64_t v305 = (char *)__nw_create_backtrace_string();
                        __nwlog_obj();
                        v293 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v311 = type[0];
                        BOOL v312 = os_log_type_enabled(v293, type[0]);
                        if (!v305)
                        {
                          if (v312)
                          {
                            *(_DWORD *)buf = 136446210;
                            uint64_t v379 = "nw_endpoint_flow_receive_report";
                            _os_log_impl( &dword_181A5C000,  v293,  v311,  "%{public}s called with null candidate_child_flow, no backtrace",  buf,  0xCu);
                          }

                          goto LABEL_469;
                        }

                        if (v312)
                        {
                          *(_DWORD *)buf = 136446466;
                          uint64_t v379 = "nw_endpoint_flow_receive_report";
                          __int16 v380 = 2082;
                          __int16 v381 = v305;
                          _os_log_impl( &dword_181A5C000,  v293,  v311,  "%{public}s called with null candidate_child_flow, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        goto LABEL_439;
                      }

        if ((*(_BYTE *)(v9 + 158) & 1) == 0)
        {
          if (gLogDatapath)
          {
            BOOL v224 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v224, OS_LOG_TYPE_DEBUG))
            {
              v225 = *(void *)(v9 + 488);
              id v226 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
              v227 = *(_DWORD *)(v9 + 860);
              if (v225) {
                LODWORD(v225) = *(_DWORD *)(v225 + 424);
              }
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_http1_parser_signal_eof_if_needed";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v9 + 74;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&_BYTE buf[24] = " ";
              *(_WORD *)&_BYTE buf[32] = 1024;
              *(_DWORD *)&buf[34] = v226;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v227;
              LOWORD(v262) = 1024;
              *(_DWORD *)((char *)&v262 + 2) = v225;
              _os_log_impl( &dword_181A5C000,  v224,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> signaled eof and terminated message successfully",  buf,  0x32u);
              uint64_t v10 = (unsigned __int16 *)(v9 + 872);
            }
          }
        }

        *((_BYTE *)v10 + 2) = (*v10 | (*((unsigned __int8 *)v10 + 2) << 16) | 0x10000u) >> 16;
        goto LABEL_117;
      }

      id v113 = llhttp_finish(v9 + 200);
      if ((*v256 & 4) != 0) {
        goto LABEL_347;
      }
      os_log_type_t v106 = v113;
      if (!v113) {
        goto LABEL_347;
      }
      if (v113 != 14) {
        goto LABEL_190;
      }
      id v114 = *(void *)(v9 + 488);
      if (v114)
      {
        os_log_type_t v106 = 14;
        if ((*v256 & 1) != 0
          && (*(_WORD *)(v114 + 428) & 1) == 0
          && !*(_DWORD *)(v9 + 848)
          && !*(_DWORD *)(v9 + 852)
          && !*(_DWORD *)(v9 + 856))
        {
          if ((*v256 & 2) != 0 && *(void *)(v9 + 800))
          {
            if (!*(void *)(v9 + 808))
            {
              uint64_t v200 = strdup("");
              if (!v200)
              {
                id v254 = (os_log_s *)__nwlog_obj();
                os_log_type_enabled(v254, OS_LOG_TYPE_ERROR);
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "strict_strdup";
                v255 = (void *)_os_log_send_and_compose_impl();
                if (__nwlog_abort((uint64_t)v255))
                {
                  __break(1u);
                  return;
                }

                free(v255);
              }

              *(void *)(v9 + 80_Block_object_dispose((const void *)(v67 - 152), 8) = v200;
            }

            nw_http1_on_header_value_complete(v9 + 200);
          }

          nw_http1_on_headers_complete(v9 + 200);
          nw_http1_on_message_complete(v9 + 200);
          uint64_t v10 = (unsigned __int16 *)(v9 + 872);
          goto LABEL_347;
        }

  uint64_t v143 = 0LL;
LABEL_348:
  (*(void (**)(uint64_t, NWConcrete_nw_agent_client *, uint64_t))(v141 + 16))(v141, v296, v143);
LABEL_349:

  _Block_object_dispose(out, 8);
  int v116 = lock;
LABEL_350:
  if (!v296->browse_descriptor && !v296->advertise_descriptor)
  {
    if ((v298[214]._os_unfair_lock_opaque & 0x20) == 0)
    {
      nw_endpoint_t v174 = *v114;
      if (v174 != 14) {
        goto LABEL_528;
      }
      *(void *)out = 0LL;
      *(void *)&out[8] = out;
      *(void *)&out[16] = 0x3032000000LL;
      *(void *)&out[24] = __Block_byref_object_copy__79337;
      *(void *)&out[32] = __Block_byref_object_dispose__79338;
      *(void *)&out[40] = 0LL;
      v340[0] = MEMORY[0x1895F87A8];
      v340[1] = 3221225472LL;
      v341 = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_170;
      os_log_t v342 = &unk_189BC9210;
      id v344 = out;
      os_log_t v343 = v298;
      os_log_type_t v175 = v343;
      BOOL v176 = v340;
      os_unfair_lock_lock(v116);
      v341((uint64_t)v176);
      os_unfair_lock_unlock(v116);

      os_log_type_t v177 = *(void *)(*(void *)&out[8] + 40LL);
      if (v177)
      {
        v338[0] = MEMORY[0x1895F87A8];
        v338[1] = 3221225472LL;
        v338[2] = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_171;
        v338[3] = &unk_189BC7758;
        v339 = v175;
        (*(void (**)(uint64_t, NWConcrete_nw_agent_client *, void *))(v177 + 16))(v177, v296, v338);

LABEL_527:
        _Block_object_dispose(out, 8);

        nw_endpoint_t v174 = *v114;
        int v116 = lock;
LABEL_528:
        if (v174 != 15) {
          goto LABEL_407;
        }
        *(void *)out = 0LL;
        *(void *)&out[8] = out;
        *(void *)&out[16] = 0x3032000000LL;
        *(void *)&out[24] = __Block_byref_object_copy__79337;
        *(void *)&out[32] = __Block_byref_object_dispose__79338;
        *(void *)&out[40] = 0LL;
        v333[0] = MEMORY[0x1895F87A8];
        v333[1] = 3221225472LL;
        id v334 = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_172;
        BOOL v335 = &unk_189BC9210;
        os_log_type_t v337 = out;
        id v336 = v298;
        nw_endpoint_t v264 = v336;
        v265 = v333;
        os_unfair_lock_lock(v116);
        v334((uint64_t)v265);
        os_unfair_lock_unlock(v116);

        os_log_type_t v266 = *(void *)(*(void *)&out[8] + 40LL);
        if (v266)
        {
          (*(void (**)(uint64_t, NWConcrete_nw_agent_client *))(v266 + 16))(v266, v296);
LABEL_549:

          _Block_object_dispose(out, 8);
          goto LABEL_406;
        }

        __nwlog_obj();
        id v267 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)v413 = 136446210;
        id v414 = "nw_agent_read_message_on_queue";
        nw_endpoint_t v268 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v405 = 0;
        if (__nwlog_fault(v268, &type, &v405))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v269 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            int v270 = type;
            if (os_log_type_enabled(v269, type))
            {
              *(_DWORD *)v413 = 136446210;
              id v414 = "nw_agent_read_message_on_queue";
              _os_log_impl(&dword_181A5C000, v269, v270, "%{public}s No handler for CLIENT_UNASSERT", v413, 0xCu);
            }
          }

          else if (v405)
          {
            char v271 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            int v269 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v272 = type;
            id v273 = os_log_type_enabled(v269, type);
            if (v271)
            {
              if (v273)
              {
                *(_DWORD *)v413 = 136446466;
                id v414 = "nw_agent_read_message_on_queue";
                v415 = 2082;
                v416 = v271;
                _os_log_impl( &dword_181A5C000,  v269,  v272,  "%{public}s No handler for CLIENT_UNASSERT, dumping backtrace:%{public}s",  v413,  0x16u);
              }

              free(v271);
              goto LABEL_547;
            }

            if (v273)
            {
              *(_DWORD *)v413 = 136446210;
              id v414 = "nw_agent_read_message_on_queue";
              _os_log_impl( &dword_181A5C000,  v269,  v272,  "%{public}s No handler for CLIENT_UNASSERT, no backtrace",  v413,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            int v269 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v274 = type;
            if (os_log_type_enabled(v269, type))
            {
              *(_DWORD *)v413 = 136446210;
              id v414 = "nw_agent_read_message_on_queue";
              _os_log_impl( &dword_181A5C000,  v269,  v274,  "%{public}s No handler for CLIENT_UNASSERT, backtrace limit exceeded",  v413,  0xCu);
            }
          }
        }

LABEL_123:
                      BOOL v71 = *((void *)v44 + 83) == 0LL;
                      __int16 v72 = v14;
                      char v73 = *((_BYTE *)v14 + 268);

                      if (!v71)
                      {
                        if ((v73 & 0x20) == 0)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                          }
                          char v74 = (os_log_s *)(id)gconnectionLogObj;
                          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                          {
                            v341 = v74;
                            uint64_t v75 = v72;

                            uint64_t v76 = v75;
                            BOOL v77 = (v359[67] & 1) == 0;

                            if (v77) {
                              __int16 v78 = "";
                            }
                            else {
                              __int16 v78 = "dry-run ";
                            }
                            nw_endpoint_t v79 = nw_endpoint_handler_copy_endpoint(v76);
                            __int16 v80 = nw_endpoint_get_logging_description(v79);
                            id v81 = v76;
                            uint64_t v82 = v81;
                            uint64_t v83 = v81[30];
                            else {
                              uint64_t v84 = off_189BBBBF0[v83];
                            }

                            os_log_type_t v109 = v82;
                            os_log_type_t v110 = v109;
                            BOOL v111 = "path";
                            switch(v349[29])
                            {
                              case 0u:
                                break;
                              case 1u:
                                BOOL v111 = "resolver";
                                break;
                              case 2u:
                                BOOL v111 = nw_endpoint_flow_mode_string(v109[31]);
                                break;
                              case 3u:
                                BOOL v111 = "proxy";
                                break;
                              case 4u:
                                BOOL v111 = "fallback";
                                break;
                              case 5u:
                                BOOL v111 = "transform";
                                break;
                              default:
                                BOOL v111 = "unknown-mode";
                                break;
                            }

                            nw_endpoint_t v119 = v79;
                            BOOL v120 = v84;
                            os_log_type_t v121 = v80;
                            os_log_type_t v122 = v78;
                            BOOL v123 = v72;
                            os_log_type_t v124 = v110;
                            os_unfair_lock_lock((os_unfair_lock_t)v124 + 28);
                            id v125 = v124[8];
                            os_unfair_lock_unlock((os_unfair_lock_t)v124 + 28);

                            __int16 v72 = v123;
                            *(_DWORD *)buf = 136447746;
                            uint64_t v379 = "nw_endpoint_flow_receive_report";
                            __int16 v380 = 2082;
                            __int16 v381 = v75 + 168;
                            __int16 v382 = 2082;
                            __int16 v383 = v122;
                            __int16 v384 = 2082;
                            __int16 v385 = (void *)v121;
                            __int16 v386 = 2082;
                            __int16 v387 = (void *)v120;
                            __int16 v388 = 2082;
                            __int16 v389 = (void *)v111;
                            __int16 v390 = 2114;
                            id v391 = v125;
                            _os_log_impl( &dword_181A5C000,  v341,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] selecting connected child protocol from candidates",  buf,  0x48u);

                            char v74 = v341;
                          }
                        }

                        os_log_type_t v126 = nw_endpoint_handler_copy_flow(loga);
                        if (v126)
                        {
                          BOOL v127 = v72;
                          uint64_t v128 = v349[29];

                          if ((_DWORD)v128 == 2)
                          {
                            os_log_type_t v129 = v355;
                            os_log_type_t v130 = (char *)*((void *)v355 + 83);
                            if (!v130)
                            {
LABEL_344:
                              *((_WORD *)v129 + 354) &= ~0x800u;
                              nw_protocol_set_output_handler((uint64_t)v129 + 472, (uint64_t)v126 + 376);

                              goto LABEL_345;
                            }

                            *(void *)__int16 v373 = 0LL;
                            id v374 = v373;
                            uint64_t v375 = 0x2020000000LL;
                            char v376 = 0;
                            *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
                            uint64_t v367 = 3221225472LL;
                            size_t v368 = __nw_flow_replay_select_output_handler_block_invoke;
                            __int16 v369 = &unk_189BB83B0;
                            v370 = v373;
                            __int16 v371 = (char *)v126 + 376;
                            uint64_t v372 = (char *)v355 + 376;
                            nw_hash_table_apply(v130, (uint64_t)type);
                            if (*((_BYTE *)v374 + 24))
                            {
LABEL_343:
                              _Block_object_dispose(v373, 8);
                              goto LABEL_344;
                            }

                            if (nw_endpoint_handler_get_minimize_logging(v127))
                            {
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                              }
                              BOOL v133 = (os_log_s *)(id)gconnectionLogObj;
                              if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
                              {
                                uint64_t v350 = nw_endpoint_handler_get_id_string(v127);
                                BOOL v314 = nw_endpoint_handler_dry_run_string(v127);
                                nw_endpoint_t v315 = nw_endpoint_handler_copy_endpoint(v127);
                                os_log_type_t v316 = nw_endpoint_get_logging_description(v315);
                                uint64_t v317 = nw_endpoint_handler_state_string(v127);
                                int v318 = nw_endpoint_handler_mode_string(v127);
                                id v319 = nw_endpoint_handler_copy_current_path(v127);
                                *(_DWORD *)buf = 136447746;
                                uint64_t v379 = "nw_flow_replay_select_output_handler";
                                __int16 v380 = 2082;
                                __int16 v381 = (char *)v350;
                                __int16 v382 = 2082;
                                __int16 v383 = v314;
                                __int16 v384 = 2082;
                                __int16 v385 = (void *)v316;
                                __int16 v386 = 2082;
                                __int16 v387 = (void *)v317;
                                __int16 v388 = 2082;
                                __int16 v389 = (void *)v318;
                                __int16 v390 = 2114;
                                id v391 = v319;
                                _os_log_impl( &dword_181A5C000,  v133,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Did n ot find selected output handler, adding to the candidate list",  buf,  0x48u);
                              }
                            }

                            else
                            {
                              nw_endpoint_t v131 = v127;
                              BOOL v132 = (v359[67] & 0x20) == 0;

                              if (!v132)
                              {
LABEL_342:
                                os_log_type_t v129 = v355;
                                nw_flow_replay_add_candidate_output_handler( v127,  (uint64_t)v355 + 376,  (uint64_t)v126 + 376);
                                goto LABEL_343;
                              }

                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                              }
                              BOOL v133 = (os_log_s *)(id)gconnectionLogObj;
                              if (os_log_type_enabled(v133, OS_LOG_TYPE_INFO))
                              {
                                v339 = v133;
                                os_log_type_t v134 = v131;

                                os_log_type_t v135 = v134;
                                BOOL v136 = (v359[67] & 1) == 0;

                                if (v136) {
                                  char v137 = "";
                                }
                                else {
                                  char v137 = "dry-run ";
                                }
                                nw_endpoint_t v138 = nw_endpoint_handler_copy_endpoint(v135);
                                char v139 = nw_endpoint_get_logging_description(v138);
                                os_log_type_t v140 = v135;
                                int v141 = v140;
                                uint64_t v142 = v140[30];
                                else {
                                  uint64_t v143 = off_189BBBBF0[v142];
                                }
                                os_log_type_t v337 = v143;

                                id v201 = v141;
                                id v202 = v201;
                                nw_endpoint_t v203 = "path";
                                switch(v349[29])
                                {
                                  case 0u:
                                    break;
                                  case 1u:
                                    nw_endpoint_t v203 = "resolver";
                                    break;
                                  case 2u:
                                    nw_endpoint_t v203 = nw_endpoint_flow_mode_string(v201[31]);
                                    break;
                                  case 3u:
                                    nw_endpoint_t v203 = "proxy";
                                    break;
                                  case 4u:
                                    nw_endpoint_t v203 = "fallback";
                                    break;
                                  case 5u:
                                    nw_endpoint_t v203 = "transform";
                                    break;
                                  default:
                                    nw_endpoint_t v203 = "unknown-mode";
                                    break;
                                }

                                id v253 = v202;
                                os_unfair_lock_lock((os_unfair_lock_t)v253 + 28);
                                id v254 = v253[8];
                                os_unfair_lock_unlock((os_unfair_lock_t)v253 + 28);

                                *(_DWORD *)buf = 136447746;
                                uint64_t v379 = "nw_flow_replay_select_output_handler";
                                __int16 v380 = 2082;
                                __int16 v381 = v134 + 168;
                                __int16 v382 = 2082;
                                __int16 v383 = v137;
                                __int16 v384 = 2082;
                                __int16 v385 = (void *)v139;
                                __int16 v386 = 2082;
                                __int16 v387 = (void *)v337;
                                __int16 v388 = 2082;
                                __int16 v389 = (void *)v203;
                                __int16 v390 = 2114;
                                id v391 = v254;
                                _os_log_impl( &dword_181A5C000,  v339,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Did n ot find selected output handler, adding to the candidate list",  buf,  0x48u);

                                BOOL v133 = v339;
                              }
                            }

                            goto LABEL_342;
                          }

                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          id v144 = (id)gLogObj;
                          else {
                            os_log_type_t v145 = off_189BBBBC0[v128];
                          }
                          *(_DWORD *)buf = 136446722;
                          uint64_t v379 = "nw_flow_replay_select_output_handler";
                          __int16 v380 = 2082;
                          __int16 v381 = (char *)v145;
                          __int16 v382 = 2082;
                          __int16 v383 = "flow";
                          os_log_type_t v146 = (void *)_os_log_send_and_compose_impl();

                          v373[0] = OS_LOG_TYPE_ERROR;
                          char v377 = 0;
                          if (__nwlog_fault((const char *)v146, v373, &v377))
                          {
                            if (v373[0] == OS_LOG_TYPE_FAULT)
                            {
                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                              networkd_settings_init();
                              int v147 = (os_log_s *)(id)gLogObj;
                              os_log_type_t v148 = v373[0];
                              if (os_log_type_enabled(v147, v373[0]))
                              {
                                else {
                                  v149 = off_189BBBBC0[v128];
                                }
                                *(_DWORD *)buf = 136446722;
                                uint64_t v379 = "nw_flow_replay_select_output_handler";
                                __int16 v380 = 2082;
                                __int16 v381 = (char *)v149;
                                __int16 v382 = 2082;
                                __int16 v383 = "flow";
                                _os_log_impl( &dword_181A5C000,  v147,  v148,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
                              }
                            }

                            else if (v377)
                            {
                              nw_endpoint_t v150 = (char *)__nw_create_backtrace_string();
                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                              networkd_settings_init();
                              int v147 = (os_log_s *)(id)gLogObj;
                              os_log_type_t v151 = v373[0];
                              BOOL v152 = os_log_type_enabled(v147, v373[0]);
                              if (v150)
                              {
                                if (v152)
                                {
                                  else {
                                    uint64_t v153 = off_189BBBBC0[v128];
                                  }
                                  *(_DWORD *)buf = 136446978;
                                  uint64_t v379 = "nw_flow_replay_select_output_handler";
                                  __int16 v380 = 2082;
                                  __int16 v381 = (char *)v153;
                                  __int16 v382 = 2082;
                                  __int16 v383 = "flow";
                                  __int16 v384 = 2082;
                                  __int16 v385 = v150;
                                  _os_log_impl( &dword_181A5C000,  v147,  v151,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
                                }

                                free(v150);
                                if (!v146)
                                {
LABEL_315:

                                  v227 = v127;
                                  BOOL v228 = (v359[67] & 0x20) == 0;

                                  if (v228)
                                  {
                                    if (__nwlog_connection_log::onceToken != -1) {
                                      dispatch_once( &__nwlog_connection_log::onceToken,  &__block_literal_global_24_44325);
                                    }
                                    BOOL v187 = (os_log_s *)(id)gconnectionLogObj;
                                    if (os_log_type_enabled(v187, OS_LOG_TYPE_ERROR))
                                    {
                                      v229 = v227;

                                      uint64_t v230 = v229;
                                      BOOL v231 = (v359[67] & 1) == 0;

                                      if (v231) {
                                        id v232 = "";
                                      }
                                      else {
                                        id v232 = "dry-run ";
                                      }
                                      nw_endpoint_t v233 = nw_endpoint_handler_copy_endpoint(v230);
                                      nw_endpoint_t v234 = nw_endpoint_get_logging_description(v233);
                                      id v235 = v230;
                                      v236 = v235;
                                      uint64_t v237 = v235[30];
                                      else {
                                        id v238 = off_189BBBBF0[v237];
                                      }

                                      v239 = v236;
                                      id v240 = "path";
                                      switch(v349[29])
                                      {
                                        case 0u:
                                          break;
                                        case 1u:
                                          id v240 = "resolver";
                                          break;
                                        case 2u:
                                          id v240 = nw_endpoint_flow_mode_string(v239[31]);
                                          break;
                                        case 3u:
                                          id v240 = "proxy";
                                          break;
                                        case 4u:
                                          id v240 = "fallback";
                                          break;
                                        case 5u:
                                          id v240 = "transform";
                                          break;
                                        default:
                                          id v240 = "unknown-mode";
                                          break;
                                      }

                                      uint64_t v362 = v240;

                                      id v241 = v229;
                                      id v242 = v187;
                                      nw_endpoint_t v243 = v233;
                                      v244 = v238;
                                      os_log_type_t v245 = v126;
                                      int v246 = v234;
                                      id v247 = v232;
                                      nw_endpoint_t v248 = v239;
                                      os_unfair_lock_lock((os_unfair_lock_t)v248 + 28);
                                      id v249 = v248[8];
                                      os_unfair_lock_unlock((os_unfair_lock_t)v248 + 28);

                                      id v250 = v247;
                                      v251 = v246;
                                      os_log_type_t v126 = v245;
                                      nw_endpoint_t v252 = v243;
                                      BOOL v187 = v242;
                                      *(_DWORD *)buf = 136447746;
                                      uint64_t v379 = "nw_endpoint_flow_receive_report";
                                      __int16 v380 = 2082;
                                      __int16 v381 = v241 + 168;
                                      __int16 v382 = 2082;
                                      __int16 v383 = v250;
                                      __int16 v384 = 2082;
                                      __int16 v385 = (void *)v251;
                                      __int16 v386 = 2082;
                                      __int16 v387 = (void *)v244;
                                      __int16 v388 = 2082;
                                      __int16 v389 = (void *)v362;
                                      __int16 v390 = 2114;
                                      id v391 = v249;
                                      _os_log_impl( &dword_181A5C000,  v242,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to select the connected candidate child flow",  buf,  0x48u);
                                    }

    if (!v36)
    {
LABEL_125:
      os_release(v10);
      goto LABEL_126;
    }

        goto LABEL_5;
      }

      goto LABEL_5;
    }

    free(v58);
    if (!v55) {
      goto LABEL_60;
    }
    goto LABEL_182;
  }

  os_log_type_t v126 = v4;
  if (a2)
  {
    __int16 v8 = *(_DWORD *)(v7 + 68);
    if (v8)
    {
      unsigned int v9 = 0;
      uint64_t v10 = 0;
LABEL_13:
      if (v10 >= v9) {
        id v11 = v9;
      }
      else {
        id v11 = v10;
      }
      if (*((_DWORD *)v6 + 31) != 4)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
        {
          uint64_t v13 = *(_DWORD *)(*((void *)v6 + 3) + 68LL);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_context_purge_endpoints";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&void buf[14] = v6;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v135) = v9;
          WORD2(v135) = 1024;
          *(_DWORD *)((char *)&v135 + 6) = v8 - v11;
          WORD5(v135) = 1024;
          HIDWORD(v135) = v13;
          LOWORD(v136) = 1024;
          *(_DWORD *)((char *)&v136 + 2) = v10;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_INFO,  "%{public}s Context %{public}@ has more than %u cache entries, purging %u from %u down to %u",  buf,  0x2Eu);
        }

        id v7 = *((void *)v6 + 3);
      }

      __int16 v14 = **(void **)(*(void *)(v7 + 8) + 8LL);
      if (v14)
      {
        char v15 = ~v8 + v11;
        do
        {
          *(void *)(v14 + 32) = 0LL;
          os_log_type_t v16 = __CFADD__(v15++, 1);
          if (v16) {
            break;
          }
          __int16 v14 = **(void **)(*(void *)(v14 + 8) + 8LL);
        }

        while (v14);
      }

      goto LABEL_34;
    }
  }

  else
  {
    unsigned int v9 = *((_DWORD *)v6 + 21);
    __int16 v8 = *(_DWORD *)(v7 + 68);
    if (v8 > v9)
    {
      uint64_t v10 = *((_DWORD *)v6 + 22);
      goto LABEL_13;
    }
  }

  os_log_type_t v17 = *(_DWORD *)(v7 + 64);
  BOOL v18 = *((_DWORD *)v6 + 23);
  if (v17 > v18)
  {
    if (*((_DWORD *)v6 + 31) != 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v19 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        char v20 = *((_DWORD *)v6 + 23);
        os_log_type_t v21 = *(_DWORD *)(*((void *)v6 + 3) + 64LL);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_context_purge_endpoints";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&void buf[14] = v6;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v135) = v20;
        WORD2(v135) = 1024;
        *(_DWORD *)((char *)&v135 + 6) = v17 - v18;
        WORD5(v135) = 1024;
        HIDWORD(v135) = v21;
        LOWORD(v136) = 1024;
        *(_DWORD *)((char *)&v136 + 2) = v20;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s Context %{public}@ has more than %u idle cache entries, purging %u from %u down to %u",  buf,  0x2Eu);
      }

      id v7 = *((void *)v6 + 3);
    }

    BOOL v22 = **(void **)(*(void *)(v7 + 24) + 8LL);
    if (v22)
    {
      BOOL v23 = ~v17 + v18;
      do
      {
        *(void *)(v22 + 32) = 0LL;
        os_log_type_t v16 = __CFADD__(v23++, 1);
        if (v16) {
          break;
        }
        BOOL v22 = **(void **)(*(void *)(v22 + 24) + 8LL);
      }

      while (v22);
    }
  }

      free(v79);
      if (!v67) {
        return;
      }
LABEL_164:
      free(v67);
      return;
    }

    uint64_t v68 = (os_log_s *)__nwlog_obj();
    uint64_t v69 = type[0];
    if (!os_log_type_enabled(v68, type[0])) {
      goto LABEL_163;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
    __int16 v70 = "%{public}s called with null processor";
LABEL_162:
    _os_log_impl(&dword_181A5C000, v68, v69, v70, buf, 0xCu);
    goto LABEL_163;
  }

  if (!a11)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
    int v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v117) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v68 = (os_log_s *)__nwlog_obj();
      uint64_t v69 = type[0];
      if (!os_log_type_enabled(v68, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      __int16 v70 = "%{public}s called with null destination_array";
      goto LABEL_162;
    }

    if (!(_BYTE)v117)
    {
      uint64_t v68 = (os_log_s *)__nwlog_obj();
      uint64_t v69 = type[0];
      if (!os_log_type_enabled(v68, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      __int16 v70 = "%{public}s called with null destination_array, backtrace limit exceeded";
      goto LABEL_162;
    }

    nw_endpoint_t v79 = (char *)__nw_create_backtrace_string();
    uint64_t v68 = (os_log_s *)__nwlog_obj();
    uint64_t v69 = type[0];
    os_log_type_t v95 = os_log_type_enabled(v68, type[0]);
    if (!v79)
    {
      if (!v95) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      __int16 v70 = "%{public}s called with null destination_array, no backtrace";
      goto LABEL_162;
    }

    if (v95)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v79;
      id v81 = "%{public}s called with null destination_array, dumping backtrace:%{public}s";
      goto LABEL_122;
    }

    goto LABEL_123;
  }

  if ((*(_BYTE *)(a1 + 142) & 0x10) == 0)
  {
    if (*(_BYTE *)(a1 + 140) == 3)
    {
      *a5 = 0;
      *a6 = -1;
      *a7 = -1;
    }

    if (gLogDatapath)
    {
      uint64_t v82 = a2;
      uint64_t v83 = a7;
      uint64_t v84 = (os_log_s *)__nwlog_obj();
      BOOL v85 = os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG);
      a7 = v83;
      a2 = v82;
      if (v85)
      {
        BOOL v86 = *a5;
        os_log_type_t v87 = *a6;
        nw_endpoint_t v88 = *v83;
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&void buf[14] = v86;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v87;
        LOWORD(v125) = 1024;
        *(_DWORD *)((char *)&v125 + 2) = v88;
        _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEBUG,  "%{public}s Getting new frames from below with minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u",  buf,  0x1Eu);
        a7 = v83;
        a2 = v82;
      }
    }

    BOOL v117 = 0LL;
    id v118 = &v117;
    os_log_type_t v16 = a2[4];
    if (v16)
    {
      int v116 = a8;
      os_log_type_t v115 = a5;
      os_log_type_t v17 = *(void **)(v16 + 40);
      if (v17 == &nw_protocol_ref_counted_handle)
      {
        BOOL v18 = *(void *)(v16 + 88);
        if (v18) {
          *(void *)(v16 + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v18 + 1;
        }
      }

      char v19 = (void *)a2[5];
      if (v19 == &nw_protocol_ref_counted_handle)
      {
        char v20 = a2[11];
        if (v20) {
          a2[11] = v20 + 1;
        }
      }

      id v114 = a7;
      os_log_type_t v21 = *(void *)(v16 + 24);
      if (v21)
      {
        BOOL v22 = *(uint64_t (**)(uint64_t))(v21 + 80);
        if (v22)
        {
          BOOL v23 = a2;
          uint64_t v24 = v22(v16);
          goto LABEL_18;
        }
      }

      BOOL v23 = a2;
      __nwlog_obj();
      BOOL v71 = *(const char **)(v16 + 16);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      if (!v71) {
        BOOL v71 = "invalid";
      }
      *(_WORD *)&buf[12] = 2082;
      *(void *)&void buf[14] = v71;
      *(_WORD *)&buf[22] = 2048;
      id v125 = (const char *)v16;
      __int16 v72 = (const char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      nw_endpoint_t v119 = 0;
      os_log_type_t v112 = (char *)v72;
      if (__nwlog_fault(v72, type, &v119))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          char v73 = (os_log_s *)__nwlog_obj();
          char v74 = type[0];
          os_log_t log = v73;
          if (os_log_type_enabled(v73, type[0]))
          {
            uint64_t v75 = *(const char **)(v16 + 16);
            if (!v75) {
              uint64_t v75 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v75;
            *(_WORD *)&buf[22] = 2048;
            id v125 = (const char *)v16;
            uint64_t v76 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_151:
            id v105 = log;
            os_log_type_t v106 = v74;
LABEL_152:
            _os_log_impl(&dword_181A5C000, v105, v106, v76, buf, 0x20u);
          }
        }

        else if (v119)
        {
          uint64_t v96 = (char *)__nw_create_backtrace_string();
          BOOL loga = (os_log_s *)__nwlog_obj();
          id v108 = type[0];
          nw_endpoint_t v97 = os_log_type_enabled(loga, type[0]);
          if (v96)
          {
            if (v97)
            {
              os_log_type_t v98 = *(const char **)(v16 + 16);
              if (!v98) {
                os_log_type_t v98 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = v98;
              *(_WORD *)&buf[22] = 2048;
              id v125 = (const char *)v16;
              *(_WORD *)os_log_type_t v126 = 2082;
              *(void *)&v126[2] = v96;
              _os_log_impl( &dword_181A5C000,  loga,  v108,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v96);
            goto LABEL_153;
          }

          if (v97)
          {
            uint64_t v107 = *(const char **)(v16 + 16);
            if (!v107) {
              uint64_t v107 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v107;
            *(_WORD *)&buf[22] = 2048;
            id v125 = (const char *)v16;
            uint64_t v76 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            id v105 = loga;
            os_log_type_t v106 = v108;
            goto LABEL_152;
          }
        }

        else
        {
          nw_endpoint_t v103 = (os_log_s *)__nwlog_obj();
          char v74 = type[0];
          os_log_t log = v103;
          if (os_log_type_enabled(v103, type[0]))
          {
            os_log_type_t v104 = *(const char **)(v16 + 16);
            if (!v104) {
              os_log_type_t v104 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v104;
            *(_WORD *)&buf[22] = 2048;
            id v125 = (const char *)v16;
            uint64_t v76 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            goto LABEL_151;
          }
        }
      }

        goto LABEL_124;
      }

      if (!buf[0])
      {
        __nwlog_obj();
        nw_endpoint_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v55 = v77[0];
        if (os_log_type_enabled(v35, v77[0]))
        {
          *(_DWORD *)os_log_type_t v87 = 136446210;
          *(void *)&v87[4] = "nw_framer_flush_output";
          _os_log_impl( &dword_181A5C000,  v35,  v55,  "%{public}s called with null output_handler, backtrace limit exceeded",  v87,  0xCu);
        }

        goto LABEL_123;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v48 = v77[0];
      uint64_t v49 = os_log_type_enabled(v35, v77[0]);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)os_log_type_t v87 = 136446210;
          *(void *)&v87[4] = "nw_framer_flush_output";
          _os_log_impl( &dword_181A5C000,  v35,  v48,  "%{public}s called with null output_handler, no backtrace",  v87,  0xCu);
        }

        goto LABEL_123;
      }

      if (v49)
      {
        *(_DWORD *)os_log_type_t v87 = 136446466;
        *(void *)&v87[4] = "nw_framer_flush_output";
        *(_WORD *)&v87[12] = 2082;
        *(void *)&v87[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v35,  v48,  "%{public}s called with null output_handler, dumping backtrace:%{public}s",  v87,  0x16u);
      }

      goto LABEL_99;
    }

    goto LABEL_124;
  }

  while (1)
  {
    id v5 = *((void *)v3 + 69);
    if (!v5) {
      break;
    }
    if (*(void *)(v5 + 24) == *(void *)(v5 + 16)) {
      goto LABEL_61;
    }
    *(void *)os_log_type_t v87 = 0LL;
    *(void *)&v87[8] = v87;
    *(void *)&v87[16] = 0x3032000000LL;
    nw_endpoint_t v88 = __Block_byref_object_copy__4444;
    BOOL v89 = __Block_byref_object_dispose__4445;
    BOOL v90 = nw_array_remove_object_at_index(v5, 0LL);
    *(void *)BOOL v77 = 0LL;
    __int16 v78 = v77;
    nw_endpoint_t v79 = 0x2020000000LL;
    size = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)&v87[8] + 40LL));
    __int16 v80 = size;
    v76[0] = 0LL;
    v76[1] = v76;
    if ((v3[606] & 2) != 0) {
      id v7 = size;
    }
    else {
      id v7 = 1LL;
    }
    __int16 v8 = *(void *)(v4 + 24);
    if (v8 && (unsigned int v9 = *(uint64_t (**)(uint64_t, char *, uint64_t, size_t, uint64_t, void *))(v8 + 88)) != 0LL)
    {
      uint64_t v10 = v9(v4, v3 + 288, v7, size, 1LL, v76);
      if (!gLogDatapath) {
        goto LABEL_11;
      }
    }

    else
    {
      uint64_t v10 = 0;
      if (!gLogDatapath) {
        goto LABEL_11;
      }
    }

    __nwlog_obj();
    os_log_t log = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v82 = "nw_framer_flush_output";
      uint64_t v83 = 2080;
      uint64_t v84 = v3 + 609;
      BOOL v85 = 1024;
      LODWORD(v86) = v10;
      _os_log_impl(&dword_181A5C000, log, OS_LOG_TYPE_DEBUG, "%{public}s %s Got %u output frames", buf, 0x1Cu);
    }

LABEL_11:
    v3[608] = v3[608] & 0xBF | ((v10 == 0) << 6);
    if (v10)
    {
      v68[0] = MEMORY[0x1895F87A8];
      v68[1] = 3221225472LL;
      uint64_t v69 = (uint64_t (*)(void *))___ZL22nw_framer_flush_outputP20NWConcrete_nw_framerPU22objcproto11OS_nw_frame8NSObject_block_invoke;
      __int16 v70 = &unk_189BB86C8;
      char v73 = v87;
      uint64_t v75 = v76;
      BOOL v71 = v3;
      char v74 = v77;
      __int16 v72 = v65;
      id v11 = v76[0];
      do
      {
        if (!v11) {
          break;
        }
        os_log_type_t v12 = *(void *)(v11 + 32);
        uint64_t v13 = v69(v68);
        id v11 = v12;
      }

      while ((v13 & 1) != 0);
      __int16 v14 = *(void **)(*(void *)&v87[8] + 40LL);
      if (v14) {
        nw_array_prepend(*((void *)v3 + 69), v14);
      }
      if (v76[0])
      {
        char v15 = *(void *)(v4 + 24);
        if (v15)
        {
          os_log_type_t v16 = *(void (**)(uint64_t, void *))(v15 + 96);
          if (v16)
          {
            v16(v4, v76);
            goto LABEL_21;
          }
        }

        __nwlog_obj();
        BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
        char v19 = *(const char **)(v4 + 16);
        if (!v19) {
          char v19 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v82 = "nw_framer_flush_output";
        uint64_t v83 = 2082;
        uint64_t v84 = v19;
        BOOL loga = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v66 = 0;
        char v20 = (char *)loga;
        if (__nwlog_fault(loga, &type, &v66))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            int v60 = type;
            if (os_log_type_enabled(v21, type))
            {
              BOOL v22 = *(const char **)(v4 + 16);
              if (!v22) {
                BOOL v22 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              uint64_t v82 = "nw_framer_flush_output";
              uint64_t v83 = 2082;
              uint64_t v84 = v22;
              _os_log_impl( &dword_181A5C000,  v21,  v60,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback",  buf,  0x16u);
            }

            goto LABEL_39;
          }

          if (v66)
          {
            BOOL v23 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            unsigned int v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v59 = type;
            uint64_t v24 = os_log_type_enabled(v61, type);
            if (v23)
            {
              if (v24)
              {
                BOOL v25 = *(const char **)(v4 + 16);
                if (!v25) {
                  BOOL v25 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                uint64_t v82 = "nw_framer_flush_output";
                uint64_t v83 = 2082;
                uint64_t v84 = v25;
                BOOL v85 = 2082;
                BOOL v86 = v23;
                _os_log_impl( &dword_181A5C000,  v61,  v59,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v23);
            }

            else
            {
              if (v24)
              {
                BOOL v27 = *(const char **)(v4 + 16);
                if (!v27) {
                  BOOL v27 = "invalid";
                }
                *(_DWORD *)buf = 136446466;
                uint64_t v82 = "nw_framer_flush_output";
                uint64_t v83 = 2082;
                uint64_t v84 = v27;
                _os_log_impl( &dword_181A5C000,  v61,  v59,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace",  buf,  0x16u);
              }
            }
          }

          else
          {
            __nwlog_obj();
            os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v62 = type;
            if (os_log_type_enabled(v21, type))
            {
              uint64_t v26 = *(const char **)(v4 + 16);
              if (!v26) {
                uint64_t v26 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              uint64_t v82 = "nw_framer_flush_output";
              uint64_t v83 = 2082;
              uint64_t v84 = v26;
              _os_log_impl( &dword_181A5C000,  v21,  v62,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded",  buf,  0x16u);
            }

      if (v42) {
        free(v42);
      }
      __int16 v14 = 0LL;
      goto LABEL_17;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v63 = "__nw_protocol_replace_input_handler";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v60 = 0;
    if (__nwlog_fault(v38, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v39 = (os_log_s *)__nwlog_obj();
        id v40 = type;
        if (os_log_type_enabled(v39, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v63 = "__nw_protocol_replace_input_handler";
          os_log_type_t v41 = "%{public}s called with null old_input_protocol";
LABEL_116:
          _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0xCu);
        }
      }

      else if (v60)
      {
        uint64_t v52 = (char *)__nw_create_backtrace_string();
        uint64_t v39 = (os_log_s *)__nwlog_obj();
        id v40 = type;
        os_log_type_t v53 = os_log_type_enabled(v39, type);
        if (v52)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v63 = "__nw_protocol_replace_input_handler";
            uint64_t v64 = 2082;
            os_log_type_t v65 = v52;
            _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s called with null old_input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v52);
          goto LABEL_117;
        }

        if (v53)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v63 = "__nw_protocol_replace_input_handler";
          os_log_type_t v41 = "%{public}s called with null old_input_protocol, no backtrace";
          goto LABEL_116;
        }
      }

      else
      {
        uint64_t v39 = (os_log_s *)__nwlog_obj();
        id v40 = type;
        if (os_log_type_enabled(v39, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v63 = "__nw_protocol_replace_input_handler";
          os_log_type_t v41 = "%{public}s called with null old_input_protocol, backtrace limit exceeded";
          goto LABEL_116;
        }
      }
    }

    if (v34) {
      free(v34);
    }
    goto LABEL_41;
  }

  __nwlog_obj();
  id v46 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v77 = "__nw_protocol_input_finished";
  BOOL v47 = (char *)_os_log_send_and_compose_impl();

  v74[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(p_paths_log_id_num) = 0;
  if (__nwlog_fault(v47, v74, &p_paths_log_id_num))
  {
    if (v74[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v49 = v74[0];
      if (os_log_type_enabled(v48, v74[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v77 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_181A5C000, v48, v49, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)p_paths_log_id_num)
    {
      os_log_type_t v57 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unsigned int v58 = v74[0];
      os_log_type_t v59 = os_log_type_enabled(v48, v74[0]);
      if (v57)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v77 = "__nw_protocol_input_finished";
          __int16 v78 = 2082;
          nw_endpoint_t v79 = v57;
          _os_log_impl( &dword_181A5C000,  v48,  v58,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v57);
        goto LABEL_136;
      }

      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v77 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_181A5C000, v48, v58, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v67 = v74[0];
      if (os_log_type_enabled(v48, v74[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v77 = "__nw_protocol_input_finished";
        _os_log_impl( &dword_181A5C000,  v48,  v67,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

                xpc_dictionary_set_BOOL(v2, "https_proxy_over_tls", 1);
                nw_endpoint_t v35 = *((void *)v1 + 12);
                if ((v35 & 0x400000) == 0)
                {
LABEL_88:
                  if ((v35 & 0x800000) == 0) {
                    goto LABEL_89;
                  }
                  goto LABEL_125;
                }

    if (v27) {
      free(v27);
    }
    return 1LL;
  }

  output_handler = a1->output_handler;
  if (!output_handler) {
    return 1LL;
  }
  __int16 v14 = output_handler->callbacks;
  if (v14 && v14->connect)
  {
    *(_DWORD *)(handle + 527) |= 1u;
    result = ((uint64_t (*)(void))a1->output_handler->callbacks->connect)();
    *(_DWORD *)(handle + 527) &= ~1u;
    return result;
  }

  return 0LL;
}

  if (v52)
  {
    uint64_t v75 = (char *)v52;
    goto LABEL_125;
  }

    if (v51) {
      free(v51);
    }
    goto LABEL_22;
  }

    os_log_type_t v12 = 0LL;
    goto LABEL_124;
  }

  os_log_type_t v12 = 1LL;
LABEL_124:

  return v12;
}

  if (v74) {
    free(v74);
  }
  LODWORD(v71) = -1;
  *(_DWORD *)(v9 + 360) = -1;
  uint64_t v13 = v257;
LABEL_126:
  *((_DWORD *)v16 + 215) = v71;
  if ((*((_BYTE *)v16 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      nw_endpoint_t v216 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v216, OS_LOG_TYPE_DEBUG))
      {
        id v217 = *((void *)v16 + 61);
        id v218 = *(_DWORD *)(*((void *)v16 + 60) + 372LL);
        v219 = *((_DWORD *)v16 + 215);
        if (v217) {
          LODWORD(v217) = *(_DWORD *)(v217 + 424);
        }
        id v220 = *(_DWORD *)(v9 + 336);
        *(_DWORD *)buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = (char *)v16 + 74;
        *(_WORD *)&buf[22] = 2080;
        nw_endpoint_t v268 = (uint64_t)" ";
        int v269 = 1024;
        *(_DWORD *)int v270 = v218;
        *(_WORD *)&v270[4] = 1024;
        *(_DWORD *)&v270[6] = v219;
        LOWORD(v271) = 1024;
        *(_DWORD *)((char *)&v271 + 2) = v217;
        HIWORD(v271) = 2048;
        *(void *)v272 = v16;
        *(_WORD *)&v272[8] = 1024;
        *(_DWORD *)id v273 = v220;
        _os_log_impl( &dword_181A5C000,  v216,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> added connection %p, now have %u connections",  buf,  0x42u);
        uint64_t v13 = v257;
      }
    }
  }

  if (!*(void *)(v11 + 248))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
    BOOL v208 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(aBlock[0]) = 0;
    if (__nwlog_fault(v208, type, aBlock))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v209 = (os_log_s *)__nwlog_obj();
        nw_endpoint_t v210 = type[0];
        if (os_log_type_enabled(v209, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
          int v211 = "%{public}s called with null http1_stream->protocol_http1";
LABEL_519:
          _os_log_impl(&dword_181A5C000, v209, v210, v211, buf, 0xCu);
        }
      }

      else if (LOBYTE(aBlock[0]))
      {
        v236 = (char *)__nw_create_backtrace_string();
        nw_endpoint_t v209 = (os_log_s *)__nwlog_obj();
        nw_endpoint_t v210 = type[0];
        uint64_t v237 = os_log_type_enabled(v209, type[0]);
        if (v236)
        {
          if (v237)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v236;
            _os_log_impl( &dword_181A5C000,  v209,  v210,  "%{public}s called with null http1_stream->protocol_http1, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v236);
          goto LABEL_520;
        }

        if (v237)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
          int v211 = "%{public}s called with null http1_stream->protocol_http1, no backtrace";
          goto LABEL_519;
        }
      }

      else
      {
        nw_endpoint_t v209 = (os_log_s *)__nwlog_obj();
        nw_endpoint_t v210 = type[0];
        if (os_log_type_enabled(v209, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
          int v211 = "%{public}s called with null http1_stream->protocol_http1, backtrace limit exceeded";
          goto LABEL_519;
        }
      }
    }

        BOOL v71 = *(_DWORD *)(v8 + 352);
        *(_DWORD *)(v8 + 352) = v71 - 1;
        if (v71) {
          goto LABEL_140;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v72 = *(unsigned int *)(v8 + 352);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&void buf[14] = "http1->pending_output_handler_count";
        *(_WORD *)&buf[22] = 2048;
        *(void *)&_BYTE buf[24] = 1LL;
        *(_WORD *)&_BYTE buf[32] = 2048;
        *(void *)&buf[34] = v72;
        char v73 = (char *)_os_log_send_and_compose_impl();
        aBlock[0] = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (aBlock[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v74 = (os_log_s *)gLogObj;
          uint64_t v75 = aBlock[0];
          if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock[0]))
          {
            uint64_t v76 = *(unsigned int *)(v8 + 352);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = "http1->pending_output_handler_count";
            *(_WORD *)&buf[22] = 2048;
            *(void *)&_BYTE buf[24] = 1LL;
            *(_WORD *)&_BYTE buf[32] = 2048;
            *(void *)&buf[34] = v76;
            BOOL v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_135:
            uint64_t v84 = v74;
            BOOL v85 = v75;
LABEL_136:
            _os_log_impl(&dword_181A5C000, v84, v85, v77, buf, 0x2Au);
          }
        }

        else if (type)
        {
          __int16 v78 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          nw_endpoint_t v79 = (os_log_s *)gLogObj;
          __int16 v80 = aBlock[0];
          id v81 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock[0]);
          if (v78)
          {
            if (v81)
            {
              uint64_t v82 = *(unsigned int *)(v8 + 352);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&void buf[14] = "http1->pending_output_handler_count";
              *(_WORD *)&buf[22] = 2048;
              *(void *)&_BYTE buf[24] = 1LL;
              *(_WORD *)&_BYTE buf[32] = 2048;
              *(void *)&buf[34] = v82;
              *(_WORD *)&buf[42] = 2082;
              *(void *)&buf[44] = v78;
              _os_log_impl( &dword_181A5C000,  v79,  v80,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v78);
            goto LABEL_137;
          }

          if (v81)
          {
            id v202 = *(unsigned int *)(v8 + 352);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = "http1->pending_output_handler_count";
            *(_WORD *)&buf[22] = 2048;
            *(void *)&_BYTE buf[24] = 1LL;
            *(_WORD *)&_BYTE buf[32] = 2048;
            *(void *)&buf[34] = v202;
            BOOL v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            uint64_t v84 = v79;
            BOOL v85 = v80;
            goto LABEL_136;
          }
        }

        else
        {
          char v74 = (os_log_s *)__nwlog_obj();
          uint64_t v75 = aBlock[0];
          if (os_log_type_enabled(v74, (os_log_type_t)aBlock[0]))
          {
            uint64_t v83 = *(unsigned int *)(v8 + 352);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = "http1->pending_output_handler_count";
            *(_WORD *)&buf[22] = 2048;
            *(void *)&_BYTE buf[24] = 1LL;
            *(_WORD *)&_BYTE buf[32] = 2048;
            *(void *)&buf[34] = v83;
            BOOL v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_135;
          }
        }

        free(v52);
        goto LABEL_124;
      }

      *((void *)v17 + 5_Block_object_dispose((const void *)(v67 - 152), 8) = v18;
      char v20 = strnlen(v17 + 24, 0x100uLL);
      os_log_type_t v21 = v20;
      if (v20 < 0x100)
      {
        BOOL v22 = v20 + 91;
        BOOL v23 = v20;
        goto LABEL_47;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v45 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      id v125 = "nw_service_connector_create_initial_payload_for_request";
      LOWORD(v126[0]) = 2048;
      *(void *)((char *)v126 + 2) = v21;
      id v30 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(error) = 0;
      if (__nwlog_fault(v30, type, &error))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v31 = (os_log_s *)(id)gLogObj;
          id v46 = type[0];
          if (os_log_type_enabled(v31, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            id v125 = "nw_service_connector_create_initial_payload_for_request";
            LOWORD(v126[0]) = 2048;
            *(void *)((char *)v126 + 2) = v21;
            _os_log_impl(&dword_181A5C000, v31, v46, "%{public}s Service name too long %zu", buf, 0x16u);
          }
        }

        else
        {
          if ((_BYTE)error)
          {
            os_log_type_t v55 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v57 = type[0];
            unsigned int v58 = os_log_type_enabled(v56, type[0]);
            if (v55)
            {
              if (v58)
              {
                *(_DWORD *)buf = 136446722;
                id v125 = "nw_service_connector_create_initial_payload_for_request";
                LOWORD(v126[0]) = 2048;
                *(void *)((char *)v126 + 2) = v21;
                WORD5(v126[0]) = 2082;
                *(void *)((char *)v126 + 12) = v55;
                _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s Service name too long %zu, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v55);
              if (!v30) {
                goto LABEL_118;
              }
              goto LABEL_117;
            }

            if (v58)
            {
              *(_DWORD *)buf = 136446466;
              id v125 = "nw_service_connector_create_initial_payload_for_request";
              LOWORD(v126[0]) = 2048;
              *(void *)((char *)v126 + 2) = v21;
              _os_log_impl(&dword_181A5C000, v56, v57, "%{public}s Service name too long %zu, no backtrace", buf, 0x16u);
            }

            goto LABEL_116;
          }

          __nwlog_obj();
          id v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v66 = type[0];
          if (os_log_type_enabled(v31, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            id v125 = "nw_service_connector_create_initial_payload_for_request";
            LOWORD(v126[0]) = 2048;
            *(void *)((char *)v126 + 2) = v21;
            _os_log_impl( &dword_181A5C000,  v31,  v66,  "%{public}s Service name too long %zu, backtrace limit exceeded",  buf,  0x16u);
          }
        }

        goto LABEL_214;
      }

        goto LABEL_124;
      }

      if (!(_BYTE)v67)
      {
        __nwlog_obj();
        char v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v38 = buf[0];
        if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)uint64_t v76 = 136446210;
          *(void *)&v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          uint64_t v39 = "%{public}s called with null out_prefixes, backtrace limit exceeded";
          goto LABEL_122;
        }

        goto LABEL_123;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v38 = buf[0];
      unsigned int v58 = os_log_type_enabled(v37, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)uint64_t v76 = 136446210;
          *(void *)&v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          uint64_t v39 = "%{public}s called with null out_prefixes, no backtrace";
          goto LABEL_122;
        }

        goto LABEL_123;
      }

      if (!v58) {
        goto LABEL_109;
      }
      *(_DWORD *)uint64_t v76 = 136446466;
      *(void *)&v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      *(_WORD *)&v76[12] = 2082;
      *(void *)&v76[14] = backtrace_string;
      uint64_t v52 = "%{public}s called with null out_prefixes, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

          _os_log_impl(&dword_181A5C000, v55, v56, v57, (uint8_t *)buf, 0xCu);
          goto LABEL_124;
        }

        os_log_type_t v55 = (os_log_s *)__nwlog_obj();
        BOOL v56 = type[0];
        if (os_log_type_enabled(v55, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
          os_log_type_t v57 = "%{public}s called with null http3->authenticator_data";
          goto LABEL_123;
        }

            goto LABEL_124;
          }

          if (!v51)
          {
            __nwlog_obj();
            id v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null context, backtrace limit exceeded";
              goto LABEL_122;
            }

            goto LABEL_123;
          }

          BOOL v47 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v41 = type;
          os_log_type_t v50 = os_log_type_enabled(v40, type);
          if (!v47)
          {
            if (v50)
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null context, no backtrace";
              goto LABEL_122;
            }

            goto LABEL_123;
          }

          if (v50)
          {
            *(_DWORD *)block = 136446466;
            *(void *)&block[4] = "nw_storage_remove_items";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = v47;
            uint64_t v49 = "%{public}s called with null context, dumping backtrace:%{public}s";
            goto LABEL_107;
          }

          goto LABEL_108;
        }

        __nwlog_obj();
        __int16 v43 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_storage_remove_items";
        uint64_t v39 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        BOOL v51 = 0;
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v51)
          {
            __nwlog_obj();
            id v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null endpoint, backtrace limit exceeded";
              goto LABEL_122;
            }

            goto LABEL_123;
          }

          BOOL v47 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v41 = type;
          BOOL v48 = os_log_type_enabled(v40, type);
          if (!v47)
          {
            if (v48)
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              int v42 = "%{public}s called with null endpoint, no backtrace";
              goto LABEL_122;
            }

            goto LABEL_123;
          }

          if (v48)
          {
            *(_DWORD *)block = 136446466;
            *(void *)&block[4] = "nw_storage_remove_items";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = v47;
            uint64_t v49 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
LABEL_107:
            _os_log_impl(&dword_181A5C000, v40, v41, v49, block, 0x16u);
          }

      *(_DWORD *)buf = 136446466;
      os_log_type_t v95 = "nw_protocol_http3_stream_input_finished";
      uint64_t v96 = 2082;
      nw_endpoint_t v97 = (char *)v76;
      uint64_t v24 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      goto LABEL_164;
    }

    free(v90);
    goto LABEL_135;
  }

  uint64_t v84 = (os_log_s *)__nwlog_obj();
  BOOL v85 = v167[0];
  if (os_log_type_enabled(v84, v167[0]))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v175 = "nw_protocol_http3_stream_get_input_frames";
    BOOL v86 = "%{public}s called with null protocol";
LABEL_134:
    _os_log_impl(&dword_181A5C000, v84, v85, v86, buf, 0xCu);
  }

          _Block_object_dispose(&v116, 8);

          goto LABEL_124;
        }
      }

      else
      {
      }

      required_interface_os_log_type_t type = nw_parameters_get_required_interface_type((nw_parameters_t)v14[2]);
      if ((required_interface_type & 0xFFFFFFFB) != 0
        && required_interface_type != v17
        && required_interface_type != v20)
      {
        if (a2)
        {
          else {
            uint64_t v49 = off_189BC9540[required_interface_type];
          }
          nw_path_set_reason(v41, 7, "Interface type %s is required by parameters", v44, v45, v46, v47, v48, (char)v49);
          goto LABEL_122;
        }

        goto LABEL_123;
      }

      required_interface_subos_log_type_t type = nw_parameters_get_required_interface_subtype(v14[2]);
      BOOL v56 = required_interface_subtype;
      os_log_type_t v57 = v14[12];
      if (v57) {
        subos_log_type_t type = nw_interface_get_subtype(v57);
      }
      else {
        subos_log_type_t type = 0;
      }
      os_log_type_t v59 = v14[13];
      if (v59) {
        LODWORD(v59) = nw_interface_get_subtype(v59);
      }
      if (v56 == subtype || v56 == (_DWORD)v59)
      {
LABEL_89:
        unsigned int v61 = nw_parameters_copy_required_interface((nw_parameters_t)v14[2]);
        if (v61)
        {
          if (!nw_interface_shallow_compare(v14[12], v61) && !nw_interface_shallow_compare(v14[13], v61))
          {
            *((_BYTE *)v117 + 24) = 0;
            if (a2) {
              nw_path_set_reason( v41,  9,  "Interface %s[%u] is required by parameters",  v62,  v63,  v64,  v65,  v66,  (_BYTE)v61 + 104);
            }
          }
        }

        int v67 = *((_BYTE *)v117 + 24) == 0;

        if (v67) {
          goto LABEL_122;
        }
        goto LABEL_95;
      }

      if (!a2) {
        goto LABEL_123;
      }
      if (v56 <= 1001)
      {
        if (v56 == 1001)
        {
          int v60 = "wifi_infrastructure";
          goto LABEL_121;
        }
      }

      else
      {
        switch(v56)
        {
          case 1002:
            int v60 = "wifi_awdl";
            goto LABEL_121;
          case 4001:
            int v60 = "coprocessor";
            goto LABEL_121;
          case 5001:
            int v60 = "companion";
LABEL_121:
            nw_path_set_reason( v41,  7,  "Interface subtype %s is required by parameters",  v51,  v52,  v53,  v54,  v55,  (char)v60);
            goto LABEL_122;
        }
      }

      int v60 = "unknown";
      goto LABEL_121;
    }

    id v33 = nw_parameters_copy_prohibited_interface_subtypes(v14[2]);
    if (!v33)
    {
LABEL_53:

      goto LABEL_54;
    }

    char v34 = v14[12];
    if (v34)
    {
      nw_endpoint_t v35 = v34;
      uint64_t v36 = v35[25];

      char v37 = v14[13];
      if (v37)
      {
LABEL_43:
        uint64_t v38 = v37;
        uint64_t v39 = v38[25];

LABEL_52:
        *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
        id v108 = 3221225472LL;
        os_log_type_t v109 = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_2;
        os_log_type_t v110 = &unk_189BC53D0;
        id v113 = v36;
        id v114 = v39;
        os_log_type_t v112 = &v116;
        os_log_type_t v115 = a2;
        BOOL v111 = v14;
        xpc_array_apply(v33, type);

        goto LABEL_53;
      }
    }

    else
    {
      uint64_t v36 = 0;
      char v37 = v14[13];
      if (v37) {
        goto LABEL_43;
      }
    }

    uint64_t v39 = 0;
    goto LABEL_52;
  }

  if (a2)
  {
    id v11 = "Path was denied by NECP policy";
    os_log_type_t v12 = 2;
LABEL_6:
    nw_path_set_reason(v9, v12, v11, v4, v5, v6, v7, v8, v84);
  }

            goto LABEL_124;
          }

          if (!v72)
          {
            __nwlog_obj();
            id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v64 = v73;
            if (os_log_type_enabled(v32, v73))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              uint64_t v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v32,  v64,  "%{public}s nw_path_parse_necp_parameters failed, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
            }

            goto LABEL_123;
          }

          BOOL v47 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v50 = v73;
          BOOL v51 = os_log_type_enabled(v32, v73);
          if (!v47)
          {
            if (v51)
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              uint64_t v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v32,  v50,  "%{public}s nw_path_parse_necp_parameters failed, no backtrace",  (uint8_t *)type,  0xCu);
            }

            goto LABEL_123;
          }

          if (v51)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            uint64_t v82 = "nw_path_observer_update_block_invoke";
            uint64_t v83 = 2082;
            uint64_t v84 = v47;
            _os_log_impl( &dword_181A5C000,  v32,  v50,  "%{public}s nw_path_parse_necp_parameters failed, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
          }

LABEL_85:
          free(v47);
          goto LABEL_124;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v27 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446210;
        uint64_t v82 = "nw_path_observer_update_block_invoke";
        uint64_t v28 = (void *)_os_log_send_and_compose_impl();

        v75[0] = OS_LOG_TYPE_ERROR;
        uint64_t v76 = 0;
        if (v75[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v29 = (os_log_s *)(id)gLogObj;
          id v30 = v75[0];
          if (os_log_type_enabled(v29, v75[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            uint64_t v82 = "nw_path_observer_update_block_invoke";
            _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s nw_parameters_create failed", (uint8_t *)type, 0xCu);
          }
        }

        else if (v76)
        {
          BOOL v47 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v48 = v75[0];
          uint64_t v49 = os_log_type_enabled(v29, v75[0]);
          if (v47)
          {
            if (v49)
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              uint64_t v82 = "nw_path_observer_update_block_invoke";
              uint64_t v83 = 2082;
              uint64_t v84 = v47;
              _os_log_impl( &dword_181A5C000,  v29,  v48,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
            }

            goto LABEL_85;
          }

          if (v49)
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            uint64_t v82 = "nw_path_observer_update_block_invoke";
            _os_log_impl( &dword_181A5C000,  v29,  v48,  "%{public}s nw_parameters_create failed, no backtrace",  (uint8_t *)type,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v63 = v75[0];
          if (os_log_type_enabled(v29, v75[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            uint64_t v82 = "nw_path_observer_update_block_invoke";
            _os_log_impl( &dword_181A5C000,  v29,  v63,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
          }
        }

        goto LABEL_124;
      }

      return 0LL;
    }

    char v19 = (id *)nw_dictionary_copy_value(*(void *)(a1[4] + 24LL), (uint64_t)out);
    os_log_type_t v17 = v19;
    if (v19)
    {
      char v20 = v19[3];
      os_log_type_t v21 = v17[5];
      BOOL v22 = v17[2];
      if (v21) {
        BOOL v23 = nw_path_create_browse(v21, v22);
      }
      else {
        BOOL v23 = nw_path_create(v20, v22);
      }
      nw_endpoint_t v35 = *(void *)(a1[5] + 8LL);
      uint64_t v36 = *(void **)(v35 + 40);
      *(void *)(v35 + 40) = v23;

      char v37 = *(void *)(*(void *)(a1[5] + 8LL) + 40LL);
      if (v37)
      {
        objc_storeStrong((id *)(v37 + 32), v17[4]);
        uint64_t v38 = a1 + 5;
        objc_storeStrong((id *)(*(void *)(*(void *)(a1[5] + 8LL) + 40LL) + 48LL), v17[6]);
        uint64_t v39 = *(void *)(*(void *)(a1[5] + 8LL) + 40LL);
        *(_BYTE *)(v39 + 475) = *(_BYTE *)(v39 + 475) & 0xFE | *((_BYTE *)v17 + 475) & 1;
        *(_WORD *)(*(void *)(*(void *)(*v38 + 8LL) + 40LL) + 384LL) = *((_WORD *)v17 + 192);
        *(_BYTE *)(*(void *)(*(void *)(*v38 + 8LL) + 40LL) + 386LL) = *((_BYTE *)v17 + 386);
        id v40 = *(void *)(*(void *)(a1[5] + 8LL) + 40LL);
        *(_BYTE *)(v40 + 475) = *(_BYTE *)(v40 + 475) & 0xFD | *((_BYTE *)v17 + 475) & 2;
        *(_OWORD *)(*(void *)(*(void *)(*v38 + 8LL) + 40LL) + 120LL) = *(_OWORD *)uu;
        if (nw_path_parse_necp_result(*(void **)(*(void *)(a1[5] + 8LL) + 40LL), (uint64_t)v87, v3 - 4LL))
        {
          nw_path_snapshot_path(*(NWConcrete_nw_path **)(*(void *)(a1[5] + 8LL) + 40LL));
          *(_OWORD *)*(void *)(*(void *)(a1[6] + 8LL) + 24LL) = *(_OWORD *)uu;
          BOOL v18 = 1LL;
LABEL_139:

          goto LABEL_140;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v45 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446210;
        uint64_t v82 = "nw_path_observer_update_block_invoke";
        int v42 = (char *)_os_log_send_and_compose_impl();

        v80[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(obj) = 0;
        if (__nwlog_fault(v42, v80, &obj))
        {
          if (v80[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            __int16 v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v46 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              uint64_t v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s nw_path_parse_necp_result failed",  (uint8_t *)type,  0xCu);
            }

    if (v40) {
      free(v40);
    }
    LOBYTE(v13) = 0;
    goto LABEL_35;
  }

  nw_context_assert_queue(v3[3]);
  nw_context_assert_queue(v4[3]);
  if (*((_DWORD *)v3 + 20) == 5)
  {
    id v5 = v3[2];
    if (v5 && !nw_path_parameters_get_logging_disabled(v5[13]))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v6 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_25;
      }
      goto LABEL_15;
    }

    goto LABEL_95;
  }

  if (*((_DWORD *)v4 + 20) != 5)
  {
    int v6 = v3[18];
    if (!v6 || (*((_BYTE *)v3 + 109) & 0x40) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v9 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();

      uint64_t v69 = OS_LOG_TYPE_ERROR;
      uint64_t v68 = 0;
      if (__nwlog_fault(v10, &v69, &v68))
      {
        if (v69 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v11 = (os_log_s *)(id)gLogObj;
          os_log_type_t v12 = v69;
          if (os_log_type_enabled(v11, v69))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s Cannot check shares protocol stack without connected endpoint handler",  buf,  0xCu);
          }
        }

        else if (v68)
        {
          os_log_type_t v21 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v11 = (os_log_s *)(id)gLogObj;
          BOOL v22 = v69;
          BOOL v23 = os_log_type_enabled(v11, v69);
          if (v21)
          {
            if (v23)
            {
              *(_DWORD *)buf = 136446466;
              BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
              __int16 v72 = 2082;
              *(void *)char v73 = v21;
              _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s Cannot check shares protocol stack without connected endpoint handler, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v21);
            if (!v10) {
              goto LABEL_25;
            }
            goto LABEL_24;
          }

          if (v23)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s Cannot check shares protocol stack without connected endpoint handler, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v11 = (os_log_s *)(id)gLogObj;
          char v29 = v69;
          if (os_log_type_enabled(v11, v69))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            _os_log_impl( &dword_181A5C000,  v11,  v29,  "%{public}s Cannot check shares protocol stack without connected endpoint handler, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v10) {
        goto LABEL_25;
      }
LABEL_24:
      free(v10);
      goto LABEL_25;
    }

    uint64_t v24 = v4[18];
    uint64_t v64 = v24;
    if (v24 && (*((_BYTE *)v4 + 109) & 0x40) != 0)
    {
      id v33 = v24;
      os_log_type_t v59 = v6;
      int v60 = v33;
      os_log_type_t type = nw_endpoint_handler_copy_flow(v59);
      unsigned int v61 = nw_endpoint_handler_copy_flow(v60);
      LODWORD(v13) = 0;
      if (!type) {
        goto LABEL_86;
      }
      char v34 = v61;
      if (v61)
      {
        os_log_type_t v57 = type;
        unsigned int v58 = v61;
        uint64_t v13 = (char *)v57 + 376;
        while (*(_DWORD *)(*((void *)v13 + 2) + 32LL) == 2)
        {
LABEL_64:
          uint64_t v13 = (char *)*((void *)v13 + 4);
          if (!v13) {
            goto LABEL_85;
          }
        }

        nw_endpoint_t v35 = (char *)v58 + 376;
        while (1)
        {
          if (*(_DWORD *)(*((void *)v35 + 2) + 32LL) != 2)
          {
            if (v13 == v35)
            {
              if (gLogDatapath)
              {
                __nwlog_obj();
                id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
                {
                  os_log_type_t v55 = "invalid";
                  if (v13 && *((void *)v13 + 2)) {
                    os_log_type_t v55 = (const char *)*((void *)v13 + 2);
                  }
                  *(_DWORD *)buf = 136447234;
                  BOOL v71 = "nw_endpoint_flow_shares_protocol_stack";
                  __int16 v72 = 2080;
                  *(void *)char v73 = v55;
                  *(_WORD *)&v73[8] = 2048;
                  *(void *)&v73[10] = v13;
                  *(_WORD *)&v73[18] = 2080;
                  char v74 = v55;
                  uint64_t v75 = 2048;
                  uint64_t v76 = v13;
                  _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s protocol %s (%p) matches protocol %s (%p)",  buf,  0x34u);
                }
              }

              LODWORD(v13) = 1;
LABEL_85:

LABEL_86:
              char v34 = v61;
              break;
            }

            if (gLogDatapath)
            {
              __nwlog_obj();
              os_log_t log = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
              {
                if (v13)
                {
                  uint64_t v36 = (const char *)*((void *)v13 + 2);
                  if (!v36) {
                    uint64_t v36 = "invalid";
                  }
                }

                else
                {
                  uint64_t v36 = "invalid";
                }

                char v37 = (const char *)*((void *)v35 + 2);
                if (!v37) {
                  char v37 = "invalid";
                }
                *(_DWORD *)buf = 136447234;
                BOOL v71 = "nw_endpoint_flow_shares_protocol_stack";
                __int16 v72 = 2080;
                *(void *)char v73 = v36;
                *(_WORD *)&v73[8] = 2048;
                *(void *)&v73[10] = v13;
                *(_WORD *)&v73[18] = 2080;
                char v74 = v37;
                uint64_t v75 = 2048;
                uint64_t v76 = v35;
                _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s protocol %s (%p) does not match protocol %s (%p)",  buf,  0x34u);
              }
            }
          }

          nw_endpoint_t v35 = (char *)*((void *)v35 + 4);
          if (!v35) {
            goto LABEL_64;
          }
        }
      }

      goto LABEL_88;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v25 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();

    uint64_t v69 = OS_LOG_TYPE_ERROR;
    uint64_t v68 = 0;
    if (__nwlog_fault(v26, &v69, &v68))
    {
      if (v69 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v27 = (os_log_s *)(id)gLogObj;
        uint64_t v28 = v69;
        if (os_log_type_enabled(v27, v69))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s Cannot check shares protocol stack without connected endpoint handler",  buf,  0xCu);
        }
      }

      else if (v68)
      {
        id v30 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v31 = v69;
        id v32 = os_log_type_enabled(v27, v69);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            __int16 v72 = 2082;
            *(void *)char v73 = v30;
            _os_log_impl( &dword_181A5C000,  v27,  v31,  "%{public}s Cannot check shares protocol stack without connected endpoint handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v30);
          if (!v26) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }

        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v27,  v31,  "%{public}s Cannot check shares protocol stack without connected endpoint handler, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v38 = v69;
        if (os_log_type_enabled(v27, v69))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v27,  v38,  "%{public}s Cannot check shares protocol stack without connected endpoint handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v26)
    {
LABEL_51:
      LODWORD(v13) = 0;
LABEL_88:

LABEL_26:
      __int16 v14 = v3[2];
      if (!v14) {
        goto LABEL_35;
      }
      goto LABEL_27;
    }

  if (!nw_endpoint_flow_join_protocol( *(void **)(a1 + 32),  *(void **)(a1 + 40),  v293,  v294,  identifier,  a2,  registered_endpoint,  *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL),  *(_BYTE *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 24LL),  (_BYTE *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL))) {
    goto LABEL_129;
  }
  *(void *)(*(void *)(a1 + 56) + 736LL) = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL)
                                                        + 32LL);
  *(_BYTE *)(*(void *)(a1 + 56) + 33LL) |= 1u;
  do
  {
    registered_endpoint = *(void *)(registered_endpoint + 32);
    if (!registered_endpoint)
    {
      char v20 = 0LL;
      unsigned int v9 = v293;
      goto LABEL_193;
    }
  }

  while (*(_DWORD *)(*(void *)(registered_endpoint + 16) + 32LL) != 3);
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 880LL));
  id v91 = *(void *)(a1 + 56);
  if (*(void *)(v91 + 720))
  {
    unsigned int v9 = v293;
  }

  else
  {
    if (*(_UNKNOWN **)(registered_endpoint + 40) == &nw_protocol_ref_counted_handle)
    {
      id v118 = *(void *)(registered_endpoint + 88);
      if (v118)
      {
        *(void *)(registered_endpoint + 8_Block_object_dispose((const void *)(v67 - 152), 8) = v118 + 1;
        id v91 = *(void *)(a1 + 56);
      }

      *(void *)buf = registered_endpoint;
      id v113 = buf[8] | 1;
    }

    else
    {
      *(void *)buf = registered_endpoint;
      id v113 = buf[8] & 0xFE;
    }

    buf[8] = v113;
    unsigned int v9 = v293;
    nw::retained_ptr<nw_protocol *>::operator=(v91 + 720, (uint64_t)buf);
    if ((buf[8] & 1) != 0) {
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    }
    id v91 = *(void *)(a1 + 56);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v91 + 880));
  char v20 = 0LL;
LABEL_193:

  return v20;
}

    if (v75) {
      free(v75);
    }
    char v15 = 0LL;
LABEL_32:

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v38 = (os_log_s *)(id)gLogObj;
    uint64_t v39 = v38;
    if (v15)
    {
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        id v40 = (id *)v106;
        os_log_type_t v41 = v40[1];

        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_masque_inner_connection_start";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&void buf[14] = v107;
        *(_WORD *)&buf[22] = 2112;
        os_log_type_t v121 = v15;
        LOWORD(v122) = 2112;
        *(void *)((char *)&v122 + 2) = v41;
        _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ received new connection %@ from %@",  buf,  0x2Au);
      }

      int v42 = MEMORY[0x1895F87A8];
      aBlock.receiver = (id)MEMORY[0x1895F87A8];
      aBlock.super_class = (Class)3221225472LL;
      os_log_type_t v115 = ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke;
      int v116 = &unk_189BC9238;
      __int16 v43 = v107;
      BOOL v117 = v43;
      BOOL v44 = v15;
      id v118 = v44;
      uint64_t v45 = (void (**)(void))_Block_copy(&aBlock);
      os_unfair_lock_lock(v107 + 4);
      v45[2](v45);
      os_unfair_lock_unlock(v107 + 4);

      *(void *)os_log_type_t type = v42;
      os_log_type_t v109 = 3221225472LL;
      os_log_type_t v110 = ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke_2;
      BOOL v111 = &unk_189BC9238;
      os_log_type_t v112 = v43;
      id v113 = v44;
      id v46 = v113;
      BOOL v47 = type;
      BOOL v48 = (dispatch_queue_s *)*((void *)v46 + 4);
      *(void *)buf = v42;
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_masque_connection_set_cancel_handler_block_invoke;
      os_log_type_t v121 = (NWConcrete_nw_masque_connection *)&unk_189BC91E8;
      uint64_t v49 = v46;
      *(void *)&os_log_type_t v122 = v49;
      os_log_type_t v50 = v47;
      *((void *)&v122 + 1) = v50;
      dispatch_async(v48, buf);

      id = nw_connection_group_get_id(v99);
      uint64_t v52 = v49;
      *(void *)buf = v42;
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_masque_connection_set_group_identifier_block_invoke;
      os_log_type_t v121 = (NWConcrete_nw_masque_connection *)&unk_189BC66E8;
      os_log_type_t v53 = v52;
      *(void *)&os_log_type_t v122 = v53;
      *((void *)&v122 + 1) = id;
      id v54 = (void (**)(void))_Block_copy(buf);
      v52 += 6;
      os_unfair_lock_lock(v52);
      v54[2](v54);
      os_unfair_lock_unlock(v52);

      os_log_type_t v55 = v53;
      BOOL v56 = (dispatch_queue_s *)*((void *)v46 + 4);
      *(void *)buf = v42;
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_masque_connection_start_block_invoke;
      os_log_type_t v121 = (NWConcrete_nw_masque_connection *)&unk_189BC93A0;
      os_log_type_t v57 = v55;
      *(void *)&os_log_type_t v122 = v57;
      dispatch_async(v56, buf);

      goto LABEL_57;
    }

    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      unsigned int v58 = (id *)v106;
      os_log_type_t v59 = (NWConcrete_nw_masque_connection *)v58[1];

      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_inner_connection_start";
      *(_WORD *)&buf[12] = 2112;
      *(void *)&void buf[14] = v107;
      *(_WORD *)&buf[22] = 2112;
      os_log_type_t v121 = v59;
      _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s %@ failed to create new connection from %@",  buf,  0x20u);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v60 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_inner_connection_start";
    unsigned int v61 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock.receiver) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v61, &aBlock, type))
    {
      if (LOBYTE(aBlock.receiver) == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v62 = (os_log_s *)(id)gLogObj;
        BOOL v63 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v62, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_inner_connection_start";
          _os_log_impl(&dword_181A5C000, v62, v63, "%{public}s nw_masque_connection_create failed", buf, 0xCu);
        }
      }

      else if (type[0])
      {
        uint64_t v64 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v62 = (os_log_s *)(id)gLogObj;
        os_log_type_t v65 = (os_log_type_t)aBlock.receiver;
        char v66 = os_log_type_enabled(v62, (os_log_type_t)aBlock.receiver);
        if (v64)
        {
          if (v66)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_inner_connection_start";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&void buf[14] = v64;
            _os_log_impl( &dword_181A5C000,  v62,  v65,  "%{public}s nw_masque_connection_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v64);
          if (!v61) {
            goto LABEL_57;
          }
          goto LABEL_56;
        }

        if (v66)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_inner_connection_start";
          _os_log_impl( &dword_181A5C000,  v62,  v65,  "%{public}s nw_masque_connection_create failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v62 = (os_log_s *)(id)gLogObj;
        int v67 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v62, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_inner_connection_start";
          _os_log_impl( &dword_181A5C000,  v62,  v67,  "%{public}s nw_masque_connection_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v61)
    {
LABEL_57:

      goto LABEL_58;
    }