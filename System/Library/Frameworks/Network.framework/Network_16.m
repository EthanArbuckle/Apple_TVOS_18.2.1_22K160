void sub_182067848(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_endpoint_handler_path_changeP30NWConcrete_nw_endpoint_handler_block_invoke_138(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  int minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 32));
  char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
  if (minimize_logging)
  {
    if ((logging_disabled & 1) != 0) {
      return nw_endpoint_handler_reset_mode(*(void *)(a1 + 32), 1LL);
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
      v14 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
      nw_endpoint_t v15 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
      logging_description = nw_endpoint_get_logging_description(v15);
      v17 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
      v18 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
      id v19 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
      int v20 = 136447746;
      v21 = "nw_endpoint_handler_path_change_block_invoke";
      __int16 v22 = 2082;
      v23 = id_string;
      __int16 v24 = 2082;
      v25 = v14;
      __int16 v26 = 2082;
      v27 = logging_description;
      __int16 v28 = 2082;
      v29 = v17;
      __int16 v30 = 2082;
      v31 = v18;
      __int16 v32 = 2114;
      id v33 = v19;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback timer fired, resetting",  (uint8_t *)&v20,  0x48u);
    }

    goto LABEL_7;
  }

  if ((logging_disabled & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      v5 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
      v6 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
      nw_endpoint_t v7 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
      v8 = nw_endpoint_get_logging_description(v7);
      v9 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
      v10 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
      id v11 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
      int v20 = 136447746;
      v21 = "nw_endpoint_handler_path_change_block_invoke";
      __int16 v22 = 2082;
      v23 = v5;
      __int16 v24 = 2082;
      v25 = v6;
      __int16 v26 = 2082;
      v27 = v8;
      __int16 v28 = 2082;
      v29 = v9;
      __int16 v30 = 2082;
      v31 = v10;
      __int16 v32 = 2114;
      id v33 = v11;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback timer fired, resetting",  (uint8_t *)&v20,  0x48u);
    }

void sub_182067B94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_should_perform_CrazyIvan46(NWConcrete_nw_endpoint_handler *a1)
{
  v1 = a1;
  v2 = (nw_endpoint_t *)v1;
  BOOL v4 = v1->state == 1
    && !v1->mode
    && ((parent_handler = v1->parent_handler) == 0LL
     || parent_handler->mode != 1
     || nw_endpoint_get_type(parent_handler->endpoint) != nw_endpoint_type_address)
    && nw_endpoint_get_type(v2[3]) == nw_endpoint_type_address
    && nw_endpoint_get_address_family(v2[3]) == 2;

  return v4;
}

void sub_182067C44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_should_do_local_only_resolution(NWConcrete_nw_endpoint_handler *a1)
{
  v1 = a1;
  v2 = v1;
  BOOL v4 = v1->state == 1
    && !v1->mode
    && nw_path_has_unsatisfied_route(v1->current_path)
    && ((parent_handler = v2->parent_handler) == 0LL || parent_handler->mode != 1)
    && nw_endpoint_get_type(v2->endpoint) == nw_endpoint_type_host;

  return v4;
}

void sub_182067CC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_has_persistent_application_protocols_block_invoke(uint64_t a1)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  return 0LL;
}

uint64_t ___ZL44nw_endpoint_handler_triggered_agents_updatedP30NWConcrete_nw_endpoint_handler_block_invoke( xpc_object_t *a1, uint64_t a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  v5 = v4;
  if (v4 && object_getClass(v4) == (Class)MEMORY[0x1895F92F8])
  {
    bytes = xpc_uuid_get_bytes(v5);
    uuid_unparse(bytes, out);
    xpc_dictionary_get_value(a1[4], out);
    nw_endpoint_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v8 = xpc_dictionary_get_value(a1[5], out);
    v9 = (void *)v8;
    if (v7)
    {
      if (v8)
      {
        int uint64 = xpc_dictionary_get_uint64(v7, "generation");
      }
    }
  }

  return 1LL;
}

void sub_182067DFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_has_matching_handler(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if ((nw_endpoint_is_equal(*((void **)v3 + 3), v4[3], 31LL) & 1) != 0)
  {
    BOOL v5 = 1LL;
  }

  else
  {
    uint64_t v11 = 0LL;
    v12 = &v11;
    uint64_t v13 = 0x2020000000LL;
    char v14 = 0;
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v6 = (void *)*((void *)v3 + 31);
      v8[0] = MEMORY[0x1895F87A8];
      v8[1] = 3221225472LL;
      v8[2] = __nw_endpoint_handler_has_matching_handler_block_invoke;
      v8[3] = &unk_189BBBAD0;
      v9 = v4;
      v10 = &v11;
      [v6 applyWithHandler:v3 toChildren:v8];
    }

    BOOL v5 = *((_BYTE *)v12 + 24) != 0;
    _Block_object_dispose(&v11, 8);
  }

  return v5;
}

void sub_182067F50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_has_matching_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  int has_matching_handler = nw_endpoint_handler_has_matching_handler(a2, *(void *)(a1 + 32));
  if (has_matching_handler) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  return has_matching_handler ^ 1u;
}

uint64_t __Block_byref_object_copy__31072(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__31073(uint64_t a1)
{
}

uint64_t __nw_endpoint_handler_copy_metadata_block_invoke(uint64_t a1)
{
  uint64_t v2 = ne_session_copy_app_data_from_flow_divert_socket();
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return 1LL;
}

uint64_t nw_endpoint_handler_uses_sleep_proxy(void *a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    if (v2[29]._os_unfair_lock_opaque != 2)
    {
      uint64_t v5 = 0LL;
LABEL_12:
      os_unfair_lock_unlock(v2 + 28);
      goto LABEL_13;
    }

    uint64_t v3 = (os_unfair_lock_s *)*(id *)&v2[62]._os_unfair_lock_opaque;
    id v4 = v3;
    if (v3)
    {
      os_unfair_lock_lock(v3 + 220);
      if ((v4[8]._os_unfair_lock_opaque & 2) != 0 || (v4[8]._os_unfair_lock_opaque & 0x100) != 0)
      {
        uint64_t v5 = *(void *)&v4[230]._os_unfair_lock_opaque != 0LL;
      }

      else if (*(void *)&v4[234]._os_unfair_lock_opaque)
      {
        uint64_t v5 = nw_endpoint_handler_uses_sleep_proxy();
      }

      else
      {
        uint64_t v5 = 0LL;
      }

      os_unfair_lock_unlock(v4 + 220);
LABEL_11:

      goto LABEL_12;
    }

    __nwlog_obj();
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v26 = "nw_endpoint_flow_uses_sleep_proxy";
    v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v12, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v26 = "nw_endpoint_flow_uses_sleep_proxy";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v26 = "nw_endpoint_flow_uses_sleep_proxy";
            __int16 v27 = 2082;
            __int16 v28 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }

        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v26 = "nw_endpoint_flow_uses_sleep_proxy";
          _os_log_impl(&dword_181A5C000, v13, v19, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v26 = "nw_endpoint_flow_uses_sleep_proxy";
          _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182068550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_is_multipath(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    if (v2[29]._os_unfair_lock_opaque == 2) {
      uint64_t is_multipath = nw_endpoint_flow_is_multipath(*(void **)&v2[62]._os_unfair_lock_opaque);
    }
    else {
      uint64_t is_multipath = 0LL;
    }
    os_unfair_lock_unlock(v2 + 28);
    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_handler_is_multipath";
  v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_is_multipath";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_handler_is_multipath";
          __int16 v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_is_multipath";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_is_multipath";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182068828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_multipath_tcp_info(void *a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    if (v2[29]._os_unfair_lock_opaque != 2)
    {
      id v6 = 0LL;
LABEL_23:
      os_unfair_lock_unlock(v2 + 28);
      goto LABEL_24;
    }

    id v3 = *(id *)&v2[62]._os_unfair_lock_opaque;
    if (v3)
    {
      xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
      if (v4)
      {
        if ((nw_endpoint_flow_is_multipath(v3) & 1) != 0)
        {
          id v5 = nw_endpoint_flow_copy_connected_socket_wrapper(v3);
          if (v5)
          {
            *(void *)buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = ___Z40nw_endpoint_flow_copy_multipath_tcp_infoP27NWConcrete_nw_endpoint_flow_block_invoke;
            v36 = &unk_189BC7898;
            id v37 = v4;
            nw_fd_wrapper_get_fd(v5, buf);
          }

          id v6 = v4;

          goto LABEL_21;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s Called on non-Multipath connection",  buf,  0xCu);
        }

LABEL_20:
        id v6 = 0LL;
LABEL_21:

LABEL_22:
        goto LABEL_23;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
      os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v33 = 0;
      if ((__nwlog_fault(v8, &type, &v33) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v9 = (os_log_s *)(id)gLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
            _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
          }
        }

        else if (v33)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v9 = (os_log_s *)(id)gLogObj;
          os_log_type_t v14 = type;
          BOOL v15 = os_log_type_enabled(v9, type);
          if (backtrace_string)
          {
            if (v15)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v8) {
              goto LABEL_20;
            }
            goto LABEL_16;
          }

          if (v15)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
            _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v9 = (os_log_s *)(id)gLogObj;
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
            _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v8) {
        goto LABEL_20;
      }
LABEL_16:
      free(v8);
      goto LABEL_20;
    }

    __nwlog_obj();
    os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v22, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
          _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v33)
      {
        __int16 v28 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v23, type);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v28;
            _os_log_impl( &dword_181A5C000,  v23,  v29,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v28);
          goto LABEL_72;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
          _os_log_impl(&dword_181A5C000, v23, v29, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_multipath_tcp_info";
          _os_log_impl( &dword_181A5C000,  v23,  v32,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182069088( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_migration_callback(void *a1, void *a2)
{
  id v6 = a1;
  id v3 = a2;
  *((_DWORD *)v6 + 20) = 655361;
  nw_endpoint_handler_report(v6, 0LL, (_WORD *)v6 + 40, 0LL);
  xpc_object_t v4 = _Block_copy(*((const void **)v6 + 6));
  id v5 = v4;
  if (v4) {
    (*((void (**)(void *, id))v4 + 2))(v4, v3);
  }
}

void sub_182069154( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_mode(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[29];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_handler_get_mode";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_handler_get_mode";
          __int16 v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_get_mode";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_endpoint_handler_copy_parent(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[9];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_handler_copy_parent";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_parent";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_handler_copy_parent";
          __int16 v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_parent";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_copy_parent";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_endpoint_handler_get_flow_id(void *a1, _OWORD *a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  xpc_object_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_endpoint_handler_get_flow_id";
    v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v25, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_handler_get_flow_id";
          _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v42)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        BOOL v34 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v45 = "nw_endpoint_handler_get_flow_id";
            __int16 v46 = 2082;
            v47 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v26,  v33,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_handler_get_flow_id";
          _os_log_impl(&dword_181A5C000, v26, v33, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_handler_get_flow_id";
          _os_log_impl( &dword_181A5C000,  v26,  v38,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182069E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_association(void *a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  xpc_object_t v4 = v3;
  if (v3)
  {
    if (a2) {
      nw_endpoint_handler_initialize_association(v3);
    }
    id v5 = v4[7];
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_endpoint_handler_copy_association";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_handler_copy_association";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_endpoint_handler_copy_association";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_handler_copy_association";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_handler_copy_association";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18206A10C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_used_prefer_fallback(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v32 = "nw_endpoint_handler_used_prefer_fallback";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v7, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v32 = "nw_endpoint_handler_used_prefer_fallback";
          _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null handler", buf, 0xCu);
        }

void nw_endpoint_handler_reset_expected_progress_target(void *a1, uint64_t a2, const unsigned __int8 *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = v5;
  if (v5)
  {
    int v7 = v5[29];
    if (v7 == 4)
    {
      nw_endpoint_fallback_reset_expected_progress_target(v5, a2);
    }

    else if (v7 == 2)
    {
      nw_endpoint_flow_reset_expected_progress_target(v5, a2, a3);
    }

    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "nw_endpoint_handler_reset_expected_progress_target";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_endpoint_handler_reset_expected_progress_target";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v19 = "nw_endpoint_handler_reset_expected_progress_target";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_endpoint_handler_reset_expected_progress_target";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_endpoint_handler_reset_expected_progress_target";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18206AB28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_mode_handler *nw_endpoint_handler_copy_proxy(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v34 = "nw_endpoint_handler_copy_proxy";
    BOOL v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_endpoint_handler_copy_proxy";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v34 = "nw_endpoint_handler_copy_proxy";
            __int16 v35 = 2082;
            id_str = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_endpoint_handler_copy_proxy";
          _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_endpoint_handler_copy_proxy";
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_18206B080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_mode_handler *nw_endpoint_handler_copy_fallback(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v34 = "nw_endpoint_handler_copy_fallback";
    BOOL v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_endpoint_handler_copy_fallback";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v34 = "nw_endpoint_handler_copy_fallback";
            __int16 v35 = 2082;
            id_str = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_endpoint_handler_copy_fallback";
          _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_endpoint_handler_copy_fallback";
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_18206B5E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_apply_to_leaf_children(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000LL;
      char v27 = 1;
      *(void *)os_log_type_t type = 0LL;
      uint64_t v22 = type;
      uint64_t v23 = 0x2020000000LL;
      char v24 = 0;
      uint64_t v5 = (void *)v3[31];
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 3221225472LL;
      v17[2] = __nw_endpoint_handler_apply_to_leaf_children_block_invoke;
      v17[3] = &unk_189BBBB20;
      __int16 v19 = type;
      __int16 v20 = buf;
      id v6 = v4;
      id v18 = v6;
      [v5 applyWithHandler:v3 toChildren:v17];
      if (*((_BYTE *)v22 + 24)) {
        uint64_t v7 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
      }
      else {
        uint64_t v7 = (*((uint64_t (**)(id, void *))v6 + 2))(v6, v3);
      }

      _Block_object_dispose(type, 8);
      _Block_object_dispose(buf, 8);
    }

    else
    {
      uint64_t v7 = (*((uint64_t (**)(id, void *))v4 + 2))(v4, v3);
    }

    goto LABEL_8;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_apply_to_leaf_children";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v10, type, &v25))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_apply_to_leaf_children";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type[0];
      BOOL v15 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_apply_to_leaf_children";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_apply_to_leaf_children";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_apply_to_leaf_children";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18206BA04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, ...)
{
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 96), 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_apply_to_leaf_children_block_invoke(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
    *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = nw_endpoint_handler_apply_to_leaf_children(v3, a1[4]);
  }

  uint64_t v5 = *(unsigned __int8 *)(*(void *)(a1[6] + 8LL) + 24LL);

  return v5;
}

void sub_18206BAB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_has_better_path(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_endpoint_handler_get_has_better_path";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v22 = "nw_endpoint_handler_get_has_better_path";
            __int16 v23 = 2082;
            char v24 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_endpoint_handler_get_proxy_privacy_stance(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[66];
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_handler_get_proxy_privacy_stance";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_get_proxy_privacy_stance";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_handler_get_proxy_privacy_stance";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_get_proxy_privacy_stance";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_handler_get_proxy_privacy_stance";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18206C354( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.receiver = v9;
  a9.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_pac_resolver;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

CFMutableArrayRef ___ZL27nw_get_outstanding_pac_urlsv_block_invoke()
{
  CFMutableArrayRef result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  nw_get_outstanding_pac_urls(void)::gPACURLs = (uint64_t)result;
  return result;
}

NWConcrete_nw_pac_resolver *nw_pac_resolver_create_with_script( const void *a1, const void *a2, void *a3, char a4, int a5, int a6, int a7, uint64_t a8, void *a9)
{
  uint64_t v78 = *MEMORY[0x1895F89C0];
  id v17 = a3;
  id v18 = a9;
  uint64_t v19 = v18;
  v71 = v17;
  if (a1)
  {
    if (a2)
    {
      if (v18)
      {
        if (v17)
        {
          if (a8)
          {
            __int16 v20 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_pac_resolver);
            if (v20)
            {
              *((void *)v20 + 3) = CFRetain(a2);
              *((void *)v20 + 5) = CFRetain(a1);
              uint64_t v21 = _Block_copy(v19);
              uint64_t v22 = (void *)*((void *)v20 + 1);
              *((void *)v20 + 1) = v21;

              objc_storeStrong((id *)v20 + 2, a3);
              uint64_t v23 = 0LL;
              if (a5) {
                char v24 = 2;
              }
              else {
                char v24 = 0;
              }
              if (a6) {
                char v25 = 4;
              }
              else {
                char v25 = 0;
              }
              char v26 = v24 | a4;
              if (a7) {
                char v27 = 8;
              }
              else {
                char v27 = 0;
              }
              *((_BYTE *)v20 + 159) = v26 | v25 | v27 | *((_BYTE *)v20 + 159) & 0xF0;
              uint64_t v28 = (char *)v20 + 84;
              unint64_t v29 = 75LL;
              while (1)
              {
                int v30 = *(unsigned __int8 *)(a8 + v23);
                v28[v23] = v30;
                if (!v30) {
                  break;
                }
                --v29;
                ++v23;
                if (v29 <= 1)
                {
                  v28[v23] = 0;
                  break;
                }
              }

              char v31 = v20;
              goto LABEL_40;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v32 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v75 = "nw_pac_resolver_create_with_script";
            __int16 v33 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v72 = 0;
            if (__nwlog_fault(v33, &type, &v72))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v34 = (os_log_s *)(id)gLogObj;
                os_log_type_t v35 = type;
                if (os_log_type_enabled(v34, type))
                {
                  *(_DWORD *)buf = 136446210;
                  v75 = "nw_pac_resolver_create_with_script";
                  _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s nw_pac_resolver_obj_alloc failed", buf, 0xCu);
                }

void sub_18206D1C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_pac_resolver *nw_pac_resolver_create_with_url( const void *a1, const void *a2, const void *a3, const void *a4, void *a5, char a6, int a7, int a8, char a9, uint64_t a10, void *a11)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  id v19 = a5;
  id v20 = a11;
  uint64_t v78 = v19;
  if (a1)
  {
    if (a2)
    {
      if (v20)
      {
        aBlock = v20;
        if (v19)
        {
          if (a10)
          {
            uint64_t v21 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_pac_resolver);
            if (v21)
            {
              *((void *)v21 + 3) = CFRetain(a2);
              *((void *)v21 + 4) = CFRetain(a1);
              if (a3) {
                *((void *)v21 + 6) = CFRetain(a3);
              }
              if (a4) {
                *((void *)v21 + 7) = CFRetain(a4);
              }
              uint64_t v22 = _Block_copy(aBlock);
              uint64_t v23 = (void *)*((void *)v21 + 1);
              *((void *)v21 + 1) = v22;

              objc_storeStrong((id *)v21 + 2, a5);
              uint64_t v24 = 0LL;
              if (a7) {
                char v25 = 2;
              }
              else {
                char v25 = 0;
              }
              if (a8) {
                char v26 = 4;
              }
              else {
                char v26 = 0;
              }
              char v27 = v25 | a6;
              if (a9) {
                char v28 = 8;
              }
              else {
                char v28 = 0;
              }
              *((_BYTE *)v21 + 159) = v27 | v26 | v28 | *((_BYTE *)v21 + 159) & 0xF0;
              unint64_t v29 = (char *)v21 + 84;
              unint64_t v30 = 75LL;
              while (1)
              {
                int v31 = *(unsigned __int8 *)(a10 + v24);
                v29[v24] = v31;
                if (!v31) {
                  break;
                }
                --v30;
                ++v24;
                if (v30 <= 1)
                {
                  v29[v24] = 0;
                  break;
                }
              }

              id v32 = v21;
              goto LABEL_44;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v33 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v83 = "nw_pac_resolver_create_with_url";
            BOOL v34 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v80 = 0;
            if (__nwlog_fault(v34, &type, &v80))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v35 = (os_log_s *)(id)gLogObj;
                os_log_type_t v36 = type;
                if (os_log_type_enabled(v35, type))
                {
                  *(_DWORD *)buf = 136446210;
                  v83 = "nw_pac_resolver_create_with_url";
                  _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s nw_pac_resolver_obj_alloc failed", buf, 0xCu);
                }

void sub_18206E01C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
}

void nw_pac_resolver_start(void *a1)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(clientContext.version) = 136446210;
    *(CFIndex *)((char *)&clientContext.version + 4) = (CFIndex)"nw_pac_resolver_start";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v9, buf, &type))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        __int16 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = buf[0];
        if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
        {
          LODWORD(clientContext.version) = 136446210;
          *(CFIndex *)((char *)&clientContext.version + 4) = (CFIndex)"nw_pac_resolver_start";
          _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null pac", (uint8_t *)&clientContext, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v39 = buf[0];
        BOOL v40 = os_log_type_enabled(v37, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v40)
          {
            LODWORD(clientContext.version) = 136446466;
            *(CFIndex *)((char *)&clientContext.version + 4) = (CFIndex)"nw_pac_resolver_start";
            WORD2(clientContext.info) = 2082;
            *(void **)((char *)&clientContext.info + 6) = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v37,  v39,  "%{public}s called with null pac, dumping backtrace:%{public}s",  (uint8_t *)&clientContext,  0x16u);
          }

LABEL_56:
          free(backtrace_string);
          if (!v9) {
            goto LABEL_82;
          }
          goto LABEL_81;
        }

        if (v40)
        {
          LODWORD(clientContext.version) = 136446210;
          *(CFIndex *)((char *)&clientContext.version + 4) = (CFIndex)"nw_pac_resolver_start";
          _os_log_impl( &dword_181A5C000,  v37,  v39,  "%{public}s called with null pac, no backtrace",  (uint8_t *)&clientContext,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v41 = buf[0];
        if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
        {
          LODWORD(clientContext.version) = 136446210;
          *(CFIndex *)((char *)&clientContext.version + 4) = (CFIndex)"nw_pac_resolver_start";
          _os_log_impl( &dword_181A5C000,  v37,  v41,  "%{public}s called with null pac, backtrace limit exceeded",  (uint8_t *)&clientContext,  0xCu);
        }
      }
    }

void sub_18206EC98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void nw_pac_resolver_callback(void *a1, const __CFArray *a2, __CFError *a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  CFRunLoopSourceRef v5 = a1;
  if (v5)
  {
    uint64_t v6 = a2;
    CFRunLoopSourceRef v7 = a3;
    uint64_t v8 = MEMORY[0x1895F87A8];
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL24nw_pac_resolver_callbackPvPK9__CFArrayP9__CFError_block_invoke;
    aBlock[3] = &unk_189BC93A0;
    os_log_type_t v9 = v5;
    os_log_type_t v39 = v9;
    os_log_type_t v10 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v5 + 20);
    v10[2](v10);
    os_unfair_lock_unlock(v5 + 20);

    os_log_type_t v11 = *(void **)&v9[8]._os_unfair_lock_opaque;
    if (!v11)
    {
LABEL_18:
      os_log_type_t v19 = *(void **)&v9[4]._os_unfair_lock_opaque;
      v34[0] = v8;
      v34[1] = 3221225472LL;
      v34[2] = ___ZL24nw_pac_resolver_callbackPvPK9__CFArrayP9__CFError_block_invoke_2;
      v34[3] = &unk_189BC6E60;
      os_log_type_t v35 = v9;
      uint64_t v20 = v6;
      os_log_type_t v36 = v20;
      uint64_t v21 = v7;
      __int16 v37 = v21;
      nw_queue_context_async(v19, v34);

      goto LABEL_19;
    }

    pthread_mutex_lock(&sOutstandingPacURLMutex);
    os_log_type_t v12 = (const __CFArray *)nw_get_outstanding_pac_urls(void)::gPACURLs;
    if (nw_get_outstanding_pac_urls(void)::gPACURLs)
    {
      v47.length = CFArrayGetCount((CFArrayRef)nw_get_outstanding_pac_urls(void)::gPACURLs);
      v47.location = 0LL;
      CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v12, v47, v11);
      if (FirstIndexOfValue != -1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v14 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          __int16 v43 = "nw_remove_outstanding_pac_url";
          __int16 v44 = 2114;
          char v45 = (char *)v11;
          _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s Removing outstanding PAC URL: %{public}@",  buf,  0x16u);
        }

        CFArrayRemoveValueAtIndex(v12, FirstIndexOfValue);
      }

      goto LABEL_17;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v43 = "nw_remove_outstanding_pac_url";
    id v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (__nwlog_fault(v16, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v43 = "nw_remove_outstanding_pac_url";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s nw_get_outstanding_pac_urls failed", buf, 0xCu);
        }
      }

      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v43 = "nw_remove_outstanding_pac_url";
            __int16 v44 = 2082;
            char v45 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s nw_get_outstanding_pac_urls failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v16) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v43 = "nw_remove_outstanding_pac_url";
          _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s nw_get_outstanding_pac_urls failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v43 = "nw_remove_outstanding_pac_url";
          _os_log_impl( &dword_181A5C000,  v17,  v25,  "%{public}s nw_get_outstanding_pac_urls failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v16)
    {
LABEL_17:
      pthread_mutex_unlock(&sOutstandingPacURLMutex);
      goto LABEL_18;
    }

void sub_18206F3C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25)
{
  _Unwind_Resume(a1);
}

void __nw_pac_resolver_start_block_invoke(uint64_t a1)
{
  uint64_t v2 = (__CFRunLoop *)[MEMORY[0x189601EC0] resourceLoaderRunLoop];
  uint64_t v3 = (const __CFString *)*MEMORY[0x1896051B0];
  CFRunLoopAddSource(v2, *(CFRunLoopSourceRef *)(a1 + 40), (CFRunLoopMode)*MEMORY[0x1896051B0]);
  *(void *)(*(void *)(a1 + 32) + 64LL) = *(void *)(a1 + 40);
  id v4 = *(void **)(a1 + 32);
  context.version = 0LL;
  context.info = v4;
  context.retain = (const void *(__cdecl *)(const void *))nw_pac_resolver_const_retain;
  context.release = (void (__cdecl *)(const void *))nw_pac_resolver_const_release;
  context.copyDescription = 0LL;
  CFRunLoopSourceRef v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(void *)(*(void *)(a1 + 32) + 72LL) = CFRunLoopTimerCreate( v5,  Current + 60.0,  0.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)nw_pac_timeout_callback,  &context);
  CFRunLoopAddTimer( (CFRunLoopRef)[MEMORY[0x189601EC0] resourceLoaderRunLoop],  *(CFRunLoopTimerRef *)(*(void *)(a1 + 32) + 72),  v3);
}

void nw_pac_timeout_callback(__CFRunLoopTimer *a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v3 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"kCFErrorDomainCFNetwork", -1001LL, 0LL);
  id v4 = a2;
  uint64_t v5 = *((void *)v4 + 2);
  if (!v5 || *(_DWORD *)(v5 + 124) != 4)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v6 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if ((v4[159] & 8) != 0) {
        CFRunLoopSourceRef v7 = " dry-run";
      }
      else {
        CFRunLoopSourceRef v7 = "";
      }
      int v8 = 136447234;
      os_log_type_t v9 = "nw_pac_timeout_callback";
      __int16 v10 = 2082;
      os_log_type_t v11 = v4 + 84;
      __int16 v12 = 2082;
      char v13 = v7;
      __int16 v14 = 2114;
      CFErrorDomain Domain = CFErrorGetDomain(v3);
      __int16 v16 = 2048;
      CFIndex Code = CFErrorGetCode(v3);
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s%{public}s proxy pac] Timed out waiting for PAC query: %{public}@: %ld",  (uint8_t *)&v8,  0x34u);
    }
  }

  nw_pac_resolver_callback(v4, 0LL, v3);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_18206F698(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL24nw_pac_resolver_callbackPvPK9__CFArrayP9__CFError_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(__CFRunLoopSource **)(v2 + 64);
  if (v3)
  {
    CFRunLoopSourceInvalidate(v3);
    uint64_t v2 = *(void *)(a1 + 32);
    id v4 = *(const void **)(v2 + 64);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(*(void *)(a1 + 32) + 64LL) = 0LL;
      uint64_t v2 = *(void *)(a1 + 32);
    }
  }

  uint64_t v5 = *(__CFRunLoopTimer **)(v2 + 72);
  if (v5)
  {
    CFRunLoopTimerInvalidate(v5);
    uint64_t v6 = *(const void **)(*(void *)(a1 + 32) + 72LL);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(*(void *)(a1 + 32) + 72LL) = 0LL;
    }
  }

void ___ZL24nw_pac_resolver_callbackPvPK9__CFArrayP9__CFError_block_invoke_2(uint64_t a1)
{
  uint64_t v92 = *MEMORY[0x1895F89C0];
  v1 = *(void **)(a1 + 32);
  if (v1[1])
  {
    id v4 = *(const __CFArray **)(a1 + 40);
    uint64_t v3 = *(__CFError **)(a1 + 48);
    uint64_t v5 = v1;
    uint64_t v6 = v5[2];
    if (v3)
    {
      if (!v6 || *(_DWORD *)(v6 + 124) != 4)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        CFRunLoopSourceRef v7 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          if ((*((_BYTE *)v5 + 159) & 8) != 0) {
            int v8 = " dry-run";
          }
          else {
            int v8 = "";
          }
          *(_DWORD *)buf = 136447234;
          v83 = "nw_proxy_resolver_create_parsed_array";
          __int16 v84 = 2082;
          v85 = (char *)v5 + 84;
          __int16 v86 = 2082;
          v87 = (void *)v8;
          __int16 v88 = 2114;
          CFErrorDomain Domain = CFErrorGetDomain(v3);
          __int16 v90 = 2048;
          CFIndex Code = CFErrorGetCode(v3);
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s%{public}s proxy pac] Evaluation error: %{public}@: %ld",  buf,  0x34u);
        }
      }

      if (CFErrorGetCode(v3) == -1001)
      {
        os_log_type_t v9 = CFErrorGetDomain(v3);
        CFStringCompare(v9, @"kCFErrorDomainCFNetwork", 0LL);
      }
    }

    else if (!v6 || *(_DWORD *)(v6 + 124) != 4)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v10 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        char v11 = *((_BYTE *)v5 + 159);
        CFIndex Count = CFArrayGetCount(v4);
        char v13 = " dry-run";
        *(_DWORD *)buf = 136446978;
        v83 = "nw_proxy_resolver_create_parsed_array";
        __int16 v84 = 2082;
        v85 = (char *)v5 + 84;
        if ((v11 & 8) == 0) {
          char v13 = "";
        }
        __int16 v86 = 2082;
        v87 = (void *)v13;
        __int16 v88 = 2048;
        CFErrorDomain Domain = (CFErrorDomain)Count;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s%{public}s proxy pac] Resolver returned %ld proxies",  buf,  0x2Au);
      }
    }

    if (v4)
    {
      BOOL v79 = nw_array_create();
      CFIndex v14 = CFArrayGetCount(v4);
      if (v14 >= 1)
      {
        CFIndex v15 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v15);
          id v17 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v18 = CFGetTypeID(ValueAtIndex);
            if (v18 == CFDictionaryGetTypeID()) {
              break;
            }
          }

          uint64_t v32 = v5[2];
          if (v32 && *(_DWORD *)(v32 + 124) == 4) {
            goto LABEL_71;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          direct = (NWConcrete_nw_proxy_config *)(id)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)direct, OS_LOG_TYPE_ERROR))
          {
            os_log_type_t v33 = " dry-run";
            if ((*((_BYTE *)v5 + 159) & 8) == 0) {
              os_log_type_t v33 = "";
            }
            *(_DWORD *)buf = 136446978;
            v83 = "nw_proxy_resolver_create_parsed_array";
            __int16 v84 = 2082;
            v85 = (char *)v5 + 84;
            __int16 v86 = 2082;
            v87 = (void *)v33;
            __int16 v88 = 2114;
            CFErrorDomain Domain = (CFErrorDomain)v17;
            _os_log_impl( &dword_181A5C000,  (os_log_t)direct,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s%{public}s proxy pac] Unknown item in pac proxy list %{public}@",  buf,  0x2Au);
          }

void sub_182070508( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

BOOL __nw_protocol_ethernet_identifier_block_invoke()
{
  unk_18C5A35B1 = 0LL;
  unk_18C5A35A9 = 0LL;
  qword_18C5A35B8 = 0LL;
  strcpy((char *)&g_ethernet_protocol_identifier, "ethernet");
  qword_18C5A3608 = (uint64_t)nw_protocol_default_input_available;
  unk_18C5A3610 = nw_protocol_default_output_available;
  qword_18C5A3648 = (uint64_t)nw_protocol_default_get_local;
  unk_18C5A3650 = nw_protocol_default_get_remote;
  qword_18C5A3638 = (uint64_t)nw_protocol_default_get_parameters;
  unk_18C5A3640 = nw_protocol_default_get_path;
  qword_18C5A3688 = (uint64_t)nw_protocol_default_output_finished;
  unk_18C5A3690 = nw_protocol_default_get_output_local;
  qword_18C5A35D8 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_18C5A35E0 = nw_protocol_default_connect;
  qword_18C5A35E8 = (uint64_t)nw_protocol_default_disconnect;
  unk_18C5A35F0 = nw_protocol_default_connected;
  qword_18C5A35F8 = (uint64_t)nw_protocol_default_disconnected;
  unk_18C5A3600 = nw_protocol_default_error;
  qword_18C5A36C8 = (uint64_t)nw_protocol_default_reset;
  unk_18C5A36D0 = nw_protocol_default_input_flush;
  qword_18C5A3678 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_18C5A3680 = nw_protocol_default_input_finished;
  qword_18C5A3698 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C5A36A0 = nw_protocol_default_waiting_for_output;
  qword_18C5A3658 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C5A3660 = nw_protocol_default_unregister_notification;
  qword_18C5A3668 = (uint64_t)nw_protocol_default_notify;
  unk_18C5A3670 = nw_protocol_default_updated_path;
  qword_18C5A36A8 = (uint64_t)nw_protocol_default_copy_info;
  unk_18C5A36B0 = nw_protocol_default_add_listen_handler;
  g_ethernet_protocol_callbacks = (uint64_t)nw_protocol_ethernet_add_input_handler;
  unk_18C5A35D0 = nw_protocol_ethernet_remove_input_handler;
  qword_18C5A3618 = (uint64_t)nw_protocol_ethernet_get_input_frames;
  unk_18C5A3620 = nw_protocol_ethernet_get_output_frames;
  qword_18C5A3628 = (uint64_t)nw_protocol_ethernet_finalize_output_frames;
  unk_18C5A3630 = nw_protocol_default_link_state;
  qword_18C5A36B8 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_18C5A36C0 = nw_protocol_ethernet_get_message_properties;
  qword_18C5A35C0 = 0x200000001LL;
  return nw_protocol_register_extended(&g_ethernet_protocol_identifier, (uint64_t)nw_protocol_ethernet_create);
}

uint64_t nw_protocol_ethernet_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
      uuid_clear((unsigned __int8 *)handle);
      if (!a2->output_handler) {
        nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)handle);
      }
      id v4 = (void *)((uint64_t (*)(nw_protocol *))a2->callbacks->get_path)(a2);
      if (v4)
      {
        uint64_t v5 = v4;
        __int16 v6 = v5[192];

        *((_WORD *)handle + 38) = v6;
      }

      CFRunLoopSourceRef v7 = (nw_endpoint *)((uint64_t (*)(nw_protocol *))a2->callbacks->get_local_endpoint)(a2);
      if (v7)
      {
        int v8 = v7;
        ethernet_address = nw_endpoint_get_ethernet_address(v7);
        if (ethernet_address)
        {
          int v10 = *(_DWORD *)ethernet_address;
          *((_WORD *)handle + 34) = *((_WORD *)ethernet_address + 2);
          *((_DWORD *)handle + 16) = v10;
        }

        if (!*((_WORD *)handle + 38))
        {
          int sa_family = nw_endpoint_get_address(v8)->sa_family;
          if (sa_family == 2)
          {
            __int16 v12 = 2048;
            goto LABEL_15;
          }

          if (sa_family == 30)
          {
            __int16 v12 = -31011;
LABEL_15:
            *((_WORD *)handle + 38) = v12;
          }
        }
      }

      char v13 = (nw_endpoint *)((uint64_t (*)(nw_protocol *))a2->callbacks->get_remote_endpoint)(a2);
      if (!v13) {
        return 1LL;
      }
      CFIndex v14 = v13;
      CFIndex v15 = nw_endpoint_get_ethernet_address(v13);
      if (v15)
      {
        int v16 = *(_DWORD *)v15;
        *((_WORD *)handle + 37) = *((_WORD *)v15 + 2);
        *(_DWORD *)(handle + 70) = v16;
      }

      if (*((_WORD *)handle + 38)) {
        return 1LL;
      }
      int v17 = nw_endpoint_get_address(v14)->sa_family;
      if (v17 == 30)
      {
        __int16 v18 = -31011;
      }

      else
      {
        if (v17 != 2) {
          return 1LL;
        }
        __int16 v18 = 2048;
      }

      *((_WORD *)handle + 38) = v18;
      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      CFTypeID v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
        os_log_type_t v23 = "%{public}s called with null ethernet";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      CFTypeID v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
        os_log_type_t v23 = "%{public}s called with null ethernet, backtrace limit exceeded";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    CFTypeID v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v27 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
        os_log_type_t v23 = "%{public}s called with null ethernet, no backtrace";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
      __int16 v32 = 2082;
      os_log_type_t v33 = backtrace_string;
      BOOL v26 = "%{public}s called with null ethernet, dumping backtrace:%{public}s";
      goto LABEL_43;
    }

    goto LABEL_44;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v28)
    {
      CFTypeID v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
        os_log_type_t v23 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    CFTypeID v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v25 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
        os_log_type_t v23 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_protocol_ethernet_add_input_handler";
      __int16 v32 = 2082;
      os_log_type_t v33 = backtrace_string;
      BOOL v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_181A5C000, v21, v22, v26, buf, 0x16u);
    }

uint64_t nw_protocol_ethernet_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_ethernet_remove_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        int v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_ethernet_remove_input_handler";
        __int16 v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_39;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v14) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_ethernet_remove_input_handler";
        __int16 v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_39;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v20 = "nw_protocol_ethernet_remove_input_handler";
        __int16 v21 = 2082;
        os_log_type_t v22 = backtrace_string;
        CFIndex v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_29:
        _os_log_impl(&dword_181A5C000, v10, v11, v15, buf, 0x16u);
      }

uint64_t nw_protocol_ethernet_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      uint64_t v9 = handle[4];
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      int v37 = (*(uint64_t (**)(void))(*(void *)(v9 + 24) + 80LL))();
      if (*(_DWORD *)(*(void *)&buf[8] + 24LL))
      {
        v24[0] = MEMORY[0x1895F87A8];
        v24[1] = 0x40000000LL;
        BOOL v25 = (uint64_t (*)(void *))___ZL37nw_protocol_ethernet_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
        BOOL v26 = &unk_189BBBCC8;
        BOOL v27 = buf;
        char v28 = handle;
        os_log_type_t v29 = a1;
        os_log_type_t v30 = a6;
        tqh_first = a6->tqh_first;
        do
        {
          if (!tqh_first) {
            break;
          }
          os_log_type_t v11 = (nw_frame *)*((void *)tqh_first + 4);
          char v12 = v25(v24);
          tqh_first = v11;
        }

        while ((v12 & 1) != 0);
      }

      else if (gLogDatapath)
      {
        uint64_t v23 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          os_log_type_t v33 = "nw_protocol_ethernet_get_input_frames";
          __int16 v34 = 2082;
          os_log_type_t v35 = (char *)handle + 78;
          _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s No ethernet input frame",  (uint8_t *)type,  0x16u);
        }
      }

      uint64_t v13 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
      _Block_object_dispose(buf, 8);
      return v13;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
    CFIndex v15 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
        __int16 v18 = "%{public}s called with null ethernet";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (!v31)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
        __int16 v18 = "%{public}s called with null ethernet, backtrace limit exceeded";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type[0];
    BOOL v22 = os_log_type_enabled(v16, type[0]);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
        __int16 v18 = "%{public}s called with null ethernet, no backtrace";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      __int16 v21 = "%{public}s called with null ethernet, dumping backtrace:%{public}s";
      goto LABEL_27;
    }

    goto LABEL_28;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
  CFIndex v15 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!v31)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
        __int16 v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type[0];
    BOOL v20 = os_log_type_enabled(v16, type[0]);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
        __int16 v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      __int16 v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_27:
      _os_log_impl(&dword_181A5C000, v16, v17, v21, buf, 0x16u);
    }

uint64_t nw_protocol_ethernet_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      uint64_t v9 = (*(uint64_t (**)(void))(*(void *)(handle[4] + 24LL) + 88LL))();
      v22[0] = MEMORY[0x1895F87A8];
      v22[1] = 0x40000000LL;
      uint64_t v23 = ___ZL38nw_protocol_ethernet_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
      CFTypeID v24 = &__block_descriptor_tmp_15_31677;
      BOOL v25 = a1;
      tqh_first = a6->tqh_first;
      do
      {
        if (!tqh_first) {
          break;
        }
        os_log_type_t v11 = (nw_frame *)*((void *)tqh_first + 4);
        char v12 = ((uint64_t (*)(void *))v23)(v22);
        tqh_first = v11;
      }

      while ((v12 & 1) != 0);
      return v9;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v27 = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (v27 == OS_LOG_TYPE_FAULT)
    {
      CFIndex v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = v27;
      if (os_log_type_enabled(v15, v27))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
        os_log_type_t v17 = "%{public}s called with null ethernet";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v26)
    {
      CFIndex v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = v27;
      if (os_log_type_enabled(v15, v27))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
        os_log_type_t v17 = "%{public}s called with null ethernet, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    CFIndex v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = v27;
    BOOL v21 = os_log_type_enabled(v15, v27);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
        os_log_type_t v17 = "%{public}s called with null ethernet, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
      __int16 v30 = 2082;
      char v31 = backtrace_string;
      BOOL v20 = "%{public}s called with null ethernet, dumping backtrace:%{public}s";
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
  BOOL v14 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v27 = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (v27 != OS_LOG_TYPE_FAULT)
  {
    if (!v26)
    {
      CFIndex v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = v27;
      if (os_log_type_enabled(v15, v27))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
        os_log_type_t v17 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    CFIndex v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = v27;
    BOOL v19 = os_log_type_enabled(v15, v27);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
        os_log_type_t v17 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_ethernet_get_output_frames";
      __int16 v30 = 2082;
      char v31 = backtrace_string;
      BOOL v20 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_23:
      _os_log_impl(&dword_181A5C000, v15, v16, v20, buf, 0x16u);
    }

uint64_t nw_protocol_ethernet_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
    CFRunLoopSourceRef v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v21;
      if (!os_log_type_enabled(v8, v21)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
      int v10 = "%{public}s called with null protocol";
      goto LABEL_34;
    }

    if (!v20)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v21;
      if (!os_log_type_enabled(v8, v21)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
      int v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = v21;
    BOOL v12 = os_log_type_enabled(v8, v21);
    if (!backtrace_string)
    {
      if (!v12) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
      int v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_34;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
      __int16 v24 = 2082;
      BOOL v25 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_35:
    if (!v7) {
      return 0LL;
    }
LABEL_36:
    free(v7);
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
    CFRunLoopSourceRef v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v21;
      if (!os_log_type_enabled(v8, v21)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
      int v10 = "%{public}s called with null ethernet";
      goto LABEL_34;
    }

    if (!v20)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v21;
      if (!os_log_type_enabled(v8, v21)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
      int v10 = "%{public}s called with null ethernet, backtrace limit exceeded";
      goto LABEL_34;
    }

    uint64_t v13 = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = v21;
    BOOL v14 = os_log_type_enabled(v8, v21);
    if (v13)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
        __int16 v24 = 2082;
        BOOL v25 = v13;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null ethernet, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v13);
      if (!v7) {
        return 0LL;
      }
      goto LABEL_36;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_protocol_ethernet_finalize_output_frames";
      int v10 = "%{public}s called with null ethernet, no backtrace";
LABEL_34:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      goto LABEL_35;
    }

    goto LABEL_35;
  }

  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 0x40000000LL;
  os_log_type_t v16 = ___ZL43nw_protocol_ethernet_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  os_log_type_t v17 = &__block_descriptor_tmp_16_31663;
  __int16 v18 = a1;
  BOOL v19 = handle;
  tqh_first = a2->tqh_first;
  do
  {
    if (!tqh_first) {
      break;
    }
    id v4 = (nw_frame *)*((void *)tqh_first + 4);
    char v5 = ((uint64_t (*)(void *))v16)(v15);
    tqh_first = v4;
  }

  while ((v5 & 1) != 0);
  return (*(uint64_t (**)(void))(*(void *)(handle[4] + 24LL) + 96LL))();
}

void nw_protocol_ethernet_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    CFIndex v15 = "nw_protocol_ethernet_get_message_properties";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      CFIndex v15 = "nw_protocol_ethernet_get_message_properties";
      CFRunLoopSourceRef v7 = "%{public}s called with null protocol";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          CFIndex v15 = "nw_protocol_ethernet_get_message_properties";
          __int16 v16 = 2082;
          os_log_type_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v4) {
          return;
        }
LABEL_35:
        free(v4);
        return;
      }

      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      CFIndex v15 = "nw_protocol_ethernet_get_message_properties";
      CFRunLoopSourceRef v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      char v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      CFIndex v15 = "nw_protocol_ethernet_get_message_properties";
      CFRunLoopSourceRef v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_ethernet_create(const nw_protocol_identifier *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  __memptr = 0LL;
  if (!posix_memalign(&__memptr, 8uLL, 0xA8uLL))
  {
    uint64_t result = (uint64_t)__memptr;
    if (__memptr) {
      goto LABEL_3;
    }
  }

  id v4 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  int v7 = 136446722;
  int v8 = "strict_memalign";
  __int16 v9 = 2048;
  uint64_t v10 = 8LL;
  __int16 v11 = 2048;
  uint64_t v12 = 168LL;
  char v5 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v5);
  if (!(_DWORD)result)
  {
    free(v5);
    uint64_t result = (uint64_t)__memptr;
LABEL_3:
    *(void *)(result + 160) = 0LL;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(void *)(result + 16) = &g_ethernet_protocol_identifier;
    *(void *)(result + 24) = &g_ethernet_protocol_callbacks;
    *(void *)(result + 40) = result;
    return result;
  }

  __break(1u);
  return result;
}

uint64_t ___ZL43nw_protocol_ethernet_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  nw_frame_unclaim(a2, a2, 0xEu, 0);
  int v13 = 0;
  uint64_t v4 = nw_frame_unclaimed_bytes(a2, &v13);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v6 = *(_DWORD *)(v5 + 70);
    *(_WORD *)(v4 + 4) = *(_WORD *)(v5 + 74);
    *(_DWORD *)uint64_t v4 = v6;
    uint64_t v7 = *(void *)(a1 + 40);
    int v8 = *(_DWORD *)(v7 + 64);
    *(_WORD *)(v4 + 10) = *(_WORD *)(v7 + 68);
    *(_DWORD *)(v4 + 6) = v8;
    *(_WORD *)(v4 + 12) = bswap32(*(unsigned __int16 *)(*(void *)(a1 + 40) + 76LL)) >> 16;
  }

  else
  {
    uint64_t v10 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      if (v11) {
        uint64_t v12 = (const char *)(v11 + 78);
      }
      else {
        uint64_t v12 = "";
      }
      *(_DWORD *)buf = 136446466;
      CFIndex v15 = "nw_protocol_ethernet_finalize_output_frames_block_invoke";
      __int16 v16 = 2082;
      os_log_type_t v17 = v12;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s Frame is no longer valid",  buf,  0x16u);
    }
  }

  return 1LL;
}

uint64_t ___ZL38nw_protocol_ethernet_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t ___ZL37nw_protocol_ethernet_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  unsigned int v35 = 0;
  uint64_t v4 = nw_frame_unclaimed_bytes(a2, &v35);
  if (v4)
  {
    if (v35 <= 0xD)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = a1[5];
        BOOL v19 = (const char *)(v18 + 78);
        if (!v18) {
          BOOL v19 = "";
        }
        *(_DWORD *)buf = 136446722;
        int v37 = "nw_protocol_ethernet_get_input_frames_block_invoke";
        __int16 v38 = 2082;
        id v39 = v19;
        __int16 v40 = 1024;
        unsigned int v41 = v35;
        BOOL v14 = "%{public}s %{public}s Received ethernet frame with incorrect length %u";
        CFIndex v15 = v17;
        os_log_type_t v16 = OS_LOG_TYPE_ERROR;
        uint32_t v20 = 28;
        goto LABEL_46;
      }
    }

    else
    {
      uint64_t v6 = v4;
      uint64_t v7 = a1[5];
      BOOL v8 = *(_DWORD *)v4 == *(_DWORD *)(v7 + 64) && *(unsigned __int16 *)(v4 + 4) == *(unsigned __int16 *)(v7 + 68);
      if (v8 || (*(_DWORD *)v4 == -1 ? (BOOL v21 = *(__int16 *)(v4 + 4) == -1) : (BOOL v21 = 0), v21))
      {
        if (!*(_BYTE *)(v7 + 162)
          || (*(_DWORD *)(v4 + 6) == *(_DWORD *)(v7 + 70)
            ? (BOOL v9 = *(unsigned __int16 *)(v4 + 10) == *(unsigned __int16 *)(v7 + 74))
            : (BOOL v9 = 0),
              v9))
        {
          if (*(unsigned __int16 *)(v7 + 76) == bswap32(*(unsigned __int16 *)(v4 + 12)) >> 16)
          {
            nw_frame_claim(a2, v5, 14, 0);
            return 1LL;
          }

          __int16 v24 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            uint64_t v25 = a1[5];
            uint64_t v26 = (const char *)(v25 + 78);
            if (!v25) {
              uint64_t v26 = "";
            }
            unsigned int v27 = bswap32(*(unsigned __int16 *)(v6 + 12));
            int v28 = *(unsigned __int16 *)(v25 + 76);
            *(_DWORD *)buf = 136446978;
            int v37 = "nw_protocol_ethernet_get_input_frames_block_invoke";
            __int16 v38 = 2082;
            id v39 = v26;
            __int16 v40 = 1024;
            unsigned int v41 = HIWORD(v27);
            __int16 v42 = 1024;
            int v43 = v28;
            BOOL v14 = "%{public}s %{public}s Mismatched ether type %u != %u";
            CFIndex v15 = v24;
            os_log_type_t v16 = OS_LOG_TYPE_ERROR;
            uint32_t v20 = 34;
            goto LABEL_46;
          }
        }

        else
        {
          os_log_type_t v29 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            uint64_t v31 = a1[5];
            if (v31) {
              uint64_t v32 = (const char *)(v31 + 78);
            }
            else {
              uint64_t v32 = "";
            }
            *(_DWORD *)buf = 136446466;
            int v37 = "nw_protocol_ethernet_get_input_frames_block_invoke";
            __int16 v38 = 2082;
            id v39 = v32;
            BOOL v14 = "%{public}s %{public}s Received mismatched remote ether address";
            goto LABEL_44;
          }
        }
      }

      else
      {
        os_log_type_t v29 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          uint64_t v22 = a1[5];
          if (v22) {
            uint64_t v23 = (const char *)(v22 + 78);
          }
          else {
            uint64_t v23 = "";
          }
          *(_DWORD *)buf = 136446466;
          int v37 = "nw_protocol_ethernet_get_input_frames_block_invoke";
          __int16 v38 = 2082;
          id v39 = v23;
          BOOL v14 = "%{public}s %{public}s Received mismatched local ether address";
LABEL_44:
          CFIndex v15 = v29;
          os_log_type_t v16 = OS_LOG_TYPE_ERROR;
LABEL_45:
          uint32_t v20 = 22;
LABEL_46:
          _os_log_impl(&dword_181A5C000, v15, v16, v14, buf, v20);
        }
      }
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = a1[5];
      if (v12) {
        int v13 = (const char *)(v12 + 78);
      }
      else {
        int v13 = "";
      }
      *(_DWORD *)buf = 136446466;
      int v37 = "nw_protocol_ethernet_get_input_frames_block_invoke";
      __int16 v38 = 2082;
      id v39 = v13;
      BOOL v14 = "%{public}s %{public}s Frame is no longer valid";
      CFIndex v15 = v11;
      os_log_type_t v16 = OS_LOG_TYPE_INFO;
      goto LABEL_45;
    }
  }

  --*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
  uint64_t v33 = *(void *)(a2 + 32);
  __int16 v34 = *(void **)(a2 + 40);
  if (v33)
  {
    *(void *)(v33 + 40) = v34;
    __int16 v34 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(a1[7] + 8LL) = v34;
  }

  *__int16 v34 = v33;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

unint64_t nw_printf_write(unint64_t result, uint64_t a2, _BYTE *a3, unint64_t a4)
{
  if (!a4) {
    return result;
  }
  unint64_t v20 = a4;
  BOOL v21 = a3;
  char v19 = 0;
  int v4 = *(_DWORD *)(a2 + 32);
  if ((v4 & 9) != 0)
  {
LABEL_3:
    unint64_t v5 = a4;
    unint64_t v18 = 0LL;
    if ((v4 & 2) == 0) {
      goto LABEL_4;
    }
LABEL_13:
    int v8 = *(unsigned __int8 *)(a2 + 24);
    if (*(_BYTE *)(a2 + 24))
    {
      unint64_t v9 = *(void *)(a2 + 16);
      if (!v9 && v5 == 1)
      {
        if (*a3 == 48)
        {
          unint64_t v5 = 0LL;
          a4 = 0LL;
          unint64_t v9 = 0LL;
          unint64_t v20 = 0LL;
        }

        else
        {
          unint64_t v9 = 0LL;
          unint64_t v5 = 1LL;
        }
      }
    }

    else
    {
      unint64_t v9 = 0LL;
    }

    BOOL v11 = v9 >= v5;
    unint64_t v6 = v9 - v5;
    if (!v11) {
      unint64_t v6 = 0LL;
    }
    unint64_t v18 = v6;
    if ((v4 & 0x10000) == 0 || v8) {
      goto LABEL_37;
    }
    goto LABEL_32;
  }

  if (*a3 == 45)
  {
    char v19 = 45;
    unint64_t v5 = a4 - 1;
    ++a3;
    unint64_t v20 = a4 - 1;
    BOOL v21 = a3;
    unint64_t v18 = 0LL;
    if ((v4 & 2) != 0) {
      goto LABEL_13;
    }
  }

  else
  {
    if ((v4 & 0x4000) != 0)
    {
      char v10 = 43;
    }

    else
    {
      if ((v4 & 0x8000) == 0) {
        goto LABEL_3;
      }
      char v10 = 32;
    }

    char v19 = v10;
    unint64_t v5 = a4++;
    unint64_t v18 = 0LL;
    if ((v4 & 2) != 0) {
      goto LABEL_13;
    }
  }

unint64_t nw_printf_write::$_0::operator()(unint64_t result)
{
  unint64_t v1 = result;
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (**(_BYTE **)result) {
    uint64_t result = std::ostream::put();
  }
  if (**(void **)(v1 + 16))
  {
    unint64_t v2 = 0LL;
    do
    {
      uint64_t result = std::ostream::put();
      ++v2;
    }

    while (v2 < **(void **)(v1 + 16));
  }

  int v3 = *(_DWORD *)(*(void *)(v1 + 24) + 32LL);
  if ((v3 & 0x40) != 0 && **(void **)(v1 + 32))
  {
    unint64_t v4 = 0LL;
    do
    {
      uint64_t result = __toupper(*(char *)(**(void **)(v1 + 40) + v4));
      *(_BYTE *)(**(void **)(v1 + 40) + v4++) = result;
    }

    while (v4 < **(void **)(v1 + 32));
    int v3 = *(_DWORD *)(*(void *)(v1 + 24) + 32LL);
  }

  if ((v3 & 0x600000) == 0) {
    return std::ostream::write();
  }
  unint64_t v5 = **(unsigned __int8 ***)(v1 + 40);
  uint64_t v6 = **(void **)(v1 + 32);
  unint64_t v7 = &v5[v6];
  if (v6) {
    unsigned int v8 = *v5 == 45;
  }
  else {
    unsigned int v8 = 0;
  }
  unint64_t v9 = &v5[v8];
  if (v6 == v8) {
    goto LABEL_29;
  }
  uint64_t v10 = ~(unint64_t)v8 + v6;
  BOOL v11 = v9;
  while (*v11 == 48)
  {
    ++v11;
    --v10;
    if (v11 == v7) {
      goto LABEL_29;
    }
  }

  if (v11 == v7)
  {
LABEL_29:
    if (v7 == v9) {
      return result;
    }
    unsigned int v18 = 0;
    if ((v8 & 1) == 0) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  if (*v11 - 48 >= 0xA)
  {
    unint64_t v7 = v11;
    goto LABEL_29;
  }

  uint64_t v12 = -9LL;
  uint64_t v13 = 9LL;
  while (1)
  {
    int v14 = v11[v12 + 9];
    v37[v13--] = v14 - 48;
    uint64_t v15 = v12 + 1;
    if (v12)
    {
      uint64_t v16 = v10--;
      ++v12;
      if (v16) {
        continue;
      }
    }

    uint64_t result = v13 + 1;
    uint64_t v17 = (uint64_t)&v11[v15 + 9];
    goto LABEL_34;
  }

  uint64_t result = v13 + 1;
  uint64_t v17 = (uint64_t)&v11[v12 + 9];
LABEL_34:
  unint64_t v22 = result << 32;
  int v23 = v37[(int)result];
  if ((int)result <= 7)
  {
    unint64_t v24 = (int)result;
    unint64_t v25 = 8 - result;
    if (result <= 8)
    {
      uint64_t v26 = "\n";
      goto LABEL_41;
    }

    unint64_t v27 = v25 & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v26 = (char *)&std::__itoa::__pow10_32 + 4 * (v25 & 0xFFFFFFFFFFFFFFF8LL) + 4;
    int32x4_t v28 = (int32x4_t)v37[(int)result];
    int32x4_t v29 = 0uLL;
    __int16 v30 = (int32x4_t *)&v37[result + 5];
    uint64_t result = (unint64_t)&unk_182667370;
    unint64_t v31 = v25 & 0xFFFFFFFFFFFFFFF8LL;
    do
    {
      int32x4_t v28 = vmlaq_s32(v28, *(int32x4_t *)(result - 16), v30[-1]);
      int32x4_t v29 = vmlaq_s32(v29, *(int32x4_t *)result, *v30);
      v30 += 2;
      result += 32LL;
      v31 -= 8LL;
    }

    while (v31);
    int v23 = vaddvq_s32(vaddq_s32(v29, v28));
    if (v25 != v27)
    {
      v24 += v27;
      do
      {
LABEL_41:
        uint64_t result = v24 + 1;
        int v32 = *(_DWORD *)v26;
        v26 += 4;
        v23 += v32 * v37[v24 + 1];
        unint64_t v24 = result;
      }

      while (result != 8);
    }
  }

  unint64_t v33 = v37[9]
      * (unint64_t)*(unsigned int *)((char *)&std::__itoa::__pow10_32 + ((uint64_t)(0x900000000LL - v22) >> 30));
  __int16 v34 = (unsigned __int8 *)(v17 - ((v33 & 0xFFFFFFFF00000000LL) != 0));
  if (v34 == v7)
  {
    if (__CFADD__(v23, (_DWORD)v33)) {
      return result;
    }
    goto LABEL_50;
  }

  unsigned int v35 = *v34 - 48;
  BOOL v36 = __CFADD__(v23, (_DWORD)v33);
  if (v35 >= 0xA && !v36)
  {
LABEL_50:
    unsigned int v18 = v33 + v23;
    if ((v8 & 1) == 0)
    {
      if ((v18 & 0x80000000) != 0) {
        return result;
      }
LABEL_32:
      std::ostream::put();
      std::ostream::write();
      std::ostream::put();
      std::ostream::put();
      char v19 = *(void **)(v1 + 8);
      unint64_t v20 = strerror(v18);
      size_t v21 = strlen(v20);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)v20, v21);
      return std::ostream::put();
    }

    if (v18 > 0x80000000) {
      return result;
    }
LABEL_31:
    unsigned int v18 = -v18;
    goto LABEL_32;
  }

  return result;
}

void *nw_printf_write_sockaddr(void *result, uint64_t a2, sockaddr *a3)
{
  int v3 = result;
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    unint64_t v7 = "<NULL>";
    uint64_t v8 = 6LL;
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(result, (uint64_t)v7, v8);
  }

  if (!*(_BYTE *)(a2 + 24))
  {
    unint64_t v7 = "<fail decode - size not specified>";
    uint64_t v8 = 34LL;
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(result, (uint64_t)v7, v8);
  }

  unint64_t v5 = *(void *)(a2 + 16);
  if (v5 <= 1)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( result,  (uint64_t)"<fail decode - size> ",  21LL);
    if (*(_BYTE *)(a2 + 24))
    {
      uint64_t v6 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)" < ", 3LL);
      return (void *)std::ostream::operator<<();
    }

void *nw_printf_write_data(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a3) {
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)"<NULL>", 6LL);
  }
  unint64_t v4 = *(void *)(a2 + 16);
  if (!*(_BYTE *)(a2 + 24) || v4 == 0) {
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)"<NULL>", 6LL);
  }
  unint64_t v7 = 0LL;
  *(void *)unint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  char v26 = 0;
  *(void *)&__int128 v8 = 0x2020202020202020LL;
  *((void *)&v8 + 1) = 0x2020202020202020LL;
  *(_OWORD *)__s = v8;
  *(_OWORD *)int32x4_t v28 = v8;
  *(_OWORD *)&v28[15] = v8;
  char v29 = 0;
  do
  {
    if (v7)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)));
      unint64_t v9 = std::locale::use_facet(&v23, MEMORY[0x189614558]);
      ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10LL);
      std::locale::~locale(&v23);
      std::ostream::put();
      std::ostream::flush();
    }

    if (v4 - v7 >= 0x10) {
      uint64_t v10 = 16LL;
    }
    else {
      uint64_t v10 = v4 - v7;
    }
    if (v10)
    {
      BOOL v11 = &__s[1];
      uint64_t v12 = (unsigned __int8 *)(a3 + v7);
      uint64_t v13 = v24;
      uint64_t v14 = v10;
      do
      {
        unsigned int v16 = *v12++;
        unint64_t v15 = v16;
        if (v16 - 32 >= 0x5F) {
          char v17 = 46;
        }
        else {
          char v17 = v15;
        }
        *uint64_t v13 = v17;
        *(v11 - 1) = nw_printf_write_data::hex_chars[v15 >> 4];
        *BOOL v11 = nw_printf_write_data::hex_chars[v15 & 0xF];
        if (v14 == 1) {
          v24[v10] = 0;
        }
        v11 += 3;
        ++v13;
        --v14;
      }

      while (v14);
    }

    if (v4 - v7 < 0x10) {
      memset(&__s[3 * v10], 32, 3 * (16 - v10) - 1);
    }
    *(void *)((char *)a1 + *(void *)(*a1 - 24LL) + 24) = 4LL;
    unsigned int v18 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"   ", 3LL);
    size_t v19 = strlen(__s);
    size_t v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)__s, v19);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"   ", 3LL);
    size_t v21 = strlen(v24);
    uint64_t result = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)v24, v21);
    v7 += v10;
  }

  while (v7 < v4);
  return result;
}

void sub_182073718( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11)
{
}

void nw_printf_write_foundation(void *a1, uint64_t a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  unint64_t v5 = v4;
  if (v4)
  {
    [v4 description];
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v7 = v6;
    if (v6)
    {
      unint64_t v8 = [v6 lengthOfBytesUsingEncoding:4];
      memset(v23, 0, sizeof(v23));
      if (v8)
      {
        uint64_t v9 = 0LL;
        do
        {
          if (v8 >= 0x200) {
            uint64_t v10 = 512LL;
          }
          else {
            uint64_t v10 = v8;
          }
          unint64_t v14 = 0LL;
          objc_msgSend( v7,  "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:",  v23,  512,  &v14,  4,  0,  v9,  v10,  0);
          std::ostream::write();
          BOOL v11 = v8 >= v14;
          v8 -= v14;
          if (!v11)
          {
            if (gLogDatapath)
            {
              __nwlog_obj();
              loga = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446978;
                unsigned int v16 = "nw_printf_write_foundation";
                __int16 v17 = 2082;
                unsigned int v18 = "bytes_to_write";
                __int16 v19 = 2048;
                unint64_t v20 = v14;
                __int16 v21 = 2048;
                unint64_t v22 = v8;
                _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
              }

              unint64_t v8 = 0LL;
              BOOL v11 = __CFADD__(v9, v14);
              v9 += v14;
              if (!v11) {
                continue;
              }
LABEL_20:
              if (gLogDatapath)
              {
                __nwlog_obj();
                log = (os_log_s *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446978;
                  unsigned int v16 = "nw_printf_write_foundation";
                  __int16 v17 = 2082;
                  unsigned int v18 = "range.location";
                  __int16 v19 = 2048;
                  unint64_t v20 = v14;
                  __int16 v21 = 2048;
                  unint64_t v22 = v9;
                  _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
                }
              }

              uint64_t v9 = 0xFFFFFFFFLL;
              continue;
            }

            unint64_t v8 = 0LL;
          }

          BOOL v11 = __CFADD__(v9, v14);
          v9 += v14;
          if (v11) {
            goto LABEL_20;
          }
        }

        while (v8);
      }
    }

    else
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)"(null)", 6LL);
    }
  }

  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)"(null)", 6LL);
  }
}

void sub_182073A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_printf_write_uuid()
{
  for (uint64_t i = 0LL; i != 16; ++i)
  {
    std::ostream::put();
    uint64_t result = std::ostream::put();
  }

  return result;
}

void nw_printf_internal_error(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  __int16 v17 = "nw_printf_internal_error";
  __int16 v18 = 2080;
  uint64_t v19 = a1;
  __int16 v20 = 2080;
  uint64_t v21 = a2;
  unint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446722;
    __int16 v17 = "nw_printf_internal_error";
    __int16 v18 = 2080;
    uint64_t v19 = a1;
    __int16 v20 = 2080;
    uint64_t v21 = a2;
    unint64_t v8 = "%{public}s %s %s";
LABEL_15:
    uint64_t v12 = v6;
    os_log_type_t v13 = v7;
LABEL_16:
    _os_log_impl(&dword_181A5C000, v12, v13, v8, buf, 0x20u);
    goto LABEL_17;
  }

  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446722;
    __int16 v17 = "nw_printf_internal_error";
    __int16 v18 = 2080;
    uint64_t v19 = a1;
    __int16 v20 = 2080;
    uint64_t v21 = a2;
    unint64_t v8 = "%{public}s %s %s, backtrace limit exceeded";
    goto LABEL_15;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  BOOL v11 = os_log_type_enabled(v6, type);
  if (backtrace_string)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446978;
      __int16 v17 = "nw_printf_internal_error";
      __int16 v18 = 2080;
      uint64_t v19 = a1;
      __int16 v20 = 2080;
      uint64_t v21 = a2;
      __int16 v22 = 2082;
      std::locale v23 = backtrace_string;
      _os_log_impl(&dword_181A5C000, v6, v10, "%{public}s %s %s, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(backtrace_string);
LABEL_10:
    if (!v5) {
      return;
    }
    goto LABEL_11;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446722;
    __int16 v17 = "nw_printf_internal_error";
    __int16 v18 = 2080;
    uint64_t v19 = a1;
    __int16 v20 = 2080;
    uint64_t v21 = a2;
    unint64_t v8 = "%{public}s %s %s, no backtrace";
    uint64_t v12 = v6;
    os_log_type_t v13 = v10;
    goto LABEL_16;
  }

void sub_182074A20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *tcp_connection_event_to_string(int a1)
{
  switch(a1)
  {
    case 1073741825:
      uint64_t result = "TCP_CONNECTION_EVENT_KEEPALIVE";
      break;
    case 1073741826:
      uint64_t result = "TCP_CONNECTION_EVENT_CONDITIONS_CHANGED";
      break;
    case 1073741827:
      uint64_t result = "TCP_CONNECTION_EVENT_DNSSEC";
      break;
    case 1073741828:
      uint64_t result = "TCP_CONNECTION_EVENT_ADAPTIVE_READ_TIMEOUT";
      break;
    case 1073741829:
      uint64_t result = "TCP_CONNECTION_EVENT_ADAPTIVE_WRITE_TIMEOUT";
      break;
    case 1073741830:
      uint64_t result = "TCP_CONNECTION_EVENT_LOW_THROUGHPUT";
      break;
    case 1073741831:
      uint64_t result = "TCP_CONNECTION_EVENT_BETTER_ROUTE_CHANGED";
      break;
    case 1073741832:
      uint64_t result = "TCP_CONNECTION_EVENT_CONNECTION_ATTEMPT_TIMEOUT";
      break;
    case 1073741833:
      uint64_t result = "TCP_CONNECTION_EVENT_CONNECTION_QUALITY_CHANGED";
      break;
    default:
      int v1 = a1 - 1;
      uint64_t result = "TCP_CONNECTION_EVENT_CONNECTED";
      switch(v1)
      {
        case 0:
          return result;
        case 1:
          uint64_t result = "TCP_CONNECTION_EVENT_READ_CLOSE";
          break;
        case 2:
          uint64_t result = "TCP_CONNECTION_EVENT_DISCONNECTED";
          break;
        case 3:
          uint64_t result = "TCP_CONNECTION_EVENT_WRITE_CLOSE";
          break;
        case 4:
          uint64_t result = "TCP_CONNECTION_EVENT_BETTER_ROUTE";
          break;
        case 5:
          uint64_t result = "TCP_CONNECTION_EVENT_VIABILITY_CHANGED";
          break;
        case 6:
          uint64_t result = "TCP_CONNECTION_EVENT_WAITING";
          break;
        case 7:
          uint64_t result = "TCP_CONNECTION_EVENT_TLS_HANDSHAKE_COMPLETE";
          break;
        default:
          uint64_t result = "UNKNOWN";
          break;
      }

      break;
  }

  return result;
}

char *tcp_connection_create_with_endpoint_and_parameters(void *a1, void *a2, void *a3)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  id v6 = a1;
  id v7 = a2;
  id v8 = a3;
  nw_allow_use_of_dispatch_internal();
  if (v6)
  {
    if (v8)
    {
      uint64_t v9 = -[NWConcrete_tcp_connection initWithParameters:]( (char *)objc_alloc(&OBJC_CLASS___NWConcrete_tcp_connection),  v7);
      os_log_type_t v10 = v9;
      if (v9)
      {
        objc_storeStrong((id *)v9 + 7, a3);
        *((void *)v10 + 12) = nw_endpoint_handler_get_next_top_id();
        objc_storeStrong((id *)v10 + 5, a1);
        else {
          char v11 = 0;
        }
        v10[158] = v11 & 0x80 | v10[158] & 0x7F;
        id v12 = v6;
        int v13 = [v12 type];

        switch(v13)
        {
          case 1:
            v10[157] = 3;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v14 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              unint64_t v27 = (char *)*((void *)v10 + 12);
              *(_DWORD *)buf = 136446722;
              int v50 = "tcp_connection_create_with_endpoint_and_parameters";
              __int16 v51 = 2048;
              id v52 = v27;
              __int16 v53 = 2082;
              logging_description = nw_endpoint_get_logging_description(v12);
              _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %llu %{public}s", buf, 0x20u);
            }

            break;
          case 3:
            v10[157] = 1;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v14 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              int32x4_t v28 = (char *)*((void *)v10 + 12);
              *(_DWORD *)buf = 136447234;
              int v50 = "tcp_connection_create_with_endpoint_and_parameters";
              __int16 v51 = 2048;
              id v52 = v28;
              __int16 v53 = 2082;
              logging_description = nw_endpoint_get_bonjour_service_name((nw_endpoint_t)v12);
              __int16 v55 = 2082;
              bonjour_service_os_log_type_t type = nw_endpoint_get_bonjour_service_type((nw_endpoint_t)v12);
              __int16 v57 = 2082;
              bonjour_service_domain = nw_endpoint_get_bonjour_service_domain((nw_endpoint_t)v12);
              _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %llu %{public}s %{public}s %{public}s",  buf,  0x34u);
            }

            break;
          case 2:
            v10[157] = 2;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v14 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              unint64_t v15 = (char *)*((void *)v10 + 12);
              id v16 = v12;
              uint64_t v17 = [v16 hostname];

              id v18 = v16;
              unsigned int v19 = __rev16([v18 port]);

              *(_DWORD *)buf = 136446978;
              int v50 = "tcp_connection_create_with_endpoint_and_parameters";
              __int16 v51 = 2048;
              id v52 = v15;
              __int16 v53 = 2082;
              logging_description = (const char *)v17;
              __int16 v55 = 1024;
              LODWORD(bonjour_service_type) = v19;
              _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %llu %{public}s %d", buf, 0x26u);
            }

            break;
          default:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v29 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v30 = (char *)*((void *)v10 + 12);
              *(_DWORD *)buf = 136446722;
              int v50 = "tcp_connection_create_with_endpoint_and_parameters";
              __int16 v51 = 2048;
              id v52 = v30;
              __int16 v53 = 1024;
              LODWORD(logging_description) = v13;
              _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s %llu Custom endpoint type: %u",  buf,  0x1Cu);
            }

            v10[157] = 0;
            goto LABEL_33;
        }

LABEL_33:
        unint64_t v31 = v10;
LABEL_42:

        goto LABEL_43;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      int v50 = "tcp_connection_create_with_endpoint_and_parameters";
      uint64_t v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (__nwlog_fault(v21, &type, &v47))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v22 = (os_log_s *)(id)gLogObj;
          os_log_type_t v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            int v50 = "tcp_connection_create_with_endpoint_and_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s [tcp_connection initWithParameters:] failed",  buf,  0xCu);
          }
        }

        else if (v47)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v22 = (os_log_s *)(id)gLogObj;
          os_log_type_t v25 = type;
          BOOL v26 = os_log_type_enabled(v22, type);
          if (backtrace_string)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446466;
              int v50 = "tcp_connection_create_with_endpoint_and_parameters";
              __int16 v51 = 2082;
              id v52 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s [tcp_connection initWithParameters:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v21) {
              goto LABEL_42;
            }
            goto LABEL_41;
          }

          if (v26)
          {
            *(_DWORD *)buf = 136446210;
            int v50 = "tcp_connection_create_with_endpoint_and_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s [tcp_connection initWithParameters:] failed, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v22 = (os_log_s *)(id)gLogObj;
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            int v50 = "tcp_connection_create_with_endpoint_and_parameters";
            _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s [tcp_connection initWithParameters:] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v21) {
        goto LABEL_42;
      }
LABEL_41:
      free(v21);
      goto LABEL_42;
    }

    __nwlog_obj();
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v50 = "tcp_connection_create_with_endpoint_and_parameters";
    int v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (__nwlog_fault(v35, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          int v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_181A5C000, v36, v39, "%{public}s called with null queue", buf, 0xCu);
        }

void sub_1820755DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id tcp_connection_copy_endpoint(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  unint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    id v18 = "tcp_connection_copy_endpoint";
    unint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_20;
        }
        *(_DWORD *)buf = 136446210;
        id v18 = "tcp_connection_copy_endpoint";
        id v8 = "%{public}s called with null connection";
LABEL_18:
        int v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_19;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_20;
        }
        *(_DWORD *)buf = 136446210;
        id v18 = "tcp_connection_copy_endpoint";
        id v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_18;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_20:

          if (!v5) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)buf = 136446210;
        id v18 = "tcp_connection_copy_endpoint";
        id v8 = "%{public}s called with null connection, no backtrace";
        int v13 = v6;
        os_log_type_t v14 = v10;
LABEL_19:
        _os_log_impl(&dword_181A5C000, v13, v14, v8, buf, 0xCu);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        id v18 = "tcp_connection_copy_endpoint";
        __int16 v19 = 2082;
        id v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5)
    {
LABEL_14:
      id v3 = 0LL;
      goto LABEL_15;
    }

id tcp_connection_copy_parameters(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  unint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    id v18 = "tcp_connection_copy_parameters";
    unint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_20;
        }
        *(_DWORD *)buf = 136446210;
        id v18 = "tcp_connection_copy_parameters";
        id v8 = "%{public}s called with null connection";
LABEL_18:
        int v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_19;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_20;
        }
        *(_DWORD *)buf = 136446210;
        id v18 = "tcp_connection_copy_parameters";
        id v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_18;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_20:

          if (!v5) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)buf = 136446210;
        id v18 = "tcp_connection_copy_parameters";
        id v8 = "%{public}s called with null connection, no backtrace";
        int v13 = v6;
        os_log_type_t v14 = v10;
LABEL_19:
        _os_log_impl(&dword_181A5C000, v13, v14, v8, buf, 0xCu);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        id v18 = "tcp_connection_copy_parameters";
        __int16 v19 = 2082;
        id v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5)
    {
LABEL_14:
      id v3 = 0LL;
      goto LABEL_15;
    }

uint64_t tcp_connection_are_proxies_supported()
{
  return 1LL;
}

char *tcp_connection_create_with_sockaddr(const sockaddr *a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  nw_allow_use_of_dispatch_internal();
  if (v3)
  {
    if (a1)
    {
      nw_endpoint_t address = nw_endpoint_create_address(a1);
      nw_endpoint_t v5 = address;
      if (address) {
        id v6 = tcp_connection_create_with_endpoint_and_parameters(address, 0LL, v3);
      }
      else {
        id v6 = 0LL;
      }

      goto LABEL_7;
    }

    __nwlog_obj();
    int v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "tcp_connection_create_with_sockaddr";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "tcp_connection_create_with_sockaddr";
          id v12 = "%{public}s called with null sa";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v18)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "tcp_connection_create_with_sockaddr";
          id v12 = "%{public}s called with null sa, backtrace limit exceeded";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v17 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "tcp_connection_create_with_sockaddr";
          id v12 = "%{public}s called with null sa, no backtrace";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v17) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v21 = "tcp_connection_create_with_sockaddr";
      __int16 v22 = 2082;
      os_log_type_t v23 = backtrace_string;
      id v16 = "%{public}s called with null sa, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v10, v11, v16, buf, 0x16u);
LABEL_25:

      free(backtrace_string);
    }
  }

  else
  {
    __nwlog_obj();
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "tcp_connection_create_with_sockaddr";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "tcp_connection_create_with_sockaddr";
          id v12 = "%{public}s called with null queue";
LABEL_34:
          _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
        }

char *tcp_connection_create_with_connected_fd(int a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v4 = a2;
  nw_allow_use_of_dispatch_internal();
  if (!v4)
  {
    __nwlog_obj();
    id v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v29 = "tcp_connection_create_with_connected_fd";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "tcp_connection_create_with_connected_fd";
        os_log_type_t v23 = "%{public}s called with null queue";
LABEL_41:
        _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
      }
    }

    else
    {
      if (v26)
      {
        backtrace_string = __nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            char v29 = "tcp_connection_create_with_connected_fd";
            __int16 v30 = 2082;
            unint64_t v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          id v16 = (char *)backtrace_string;
LABEL_15:
          free(v16);
          goto LABEL_16;
        }

        if (!v25) {
          goto LABEL_42;
        }
        *(_DWORD *)buf = 136446210;
        char v29 = "tcp_connection_create_with_connected_fd";
        os_log_type_t v23 = "%{public}s called with null queue, no backtrace";
        goto LABEL_41;
      }

      __nwlog_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "tcp_connection_create_with_connected_fd";
        os_log_type_t v23 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_41;
      }
    }

char *tcp_connection_create_with_connected_fd_inner(int a1, char a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v4 = -[NWConcrete_tcp_connection initWithParameters:]( (char *)objc_alloc(&OBJC_CLASS___NWConcrete_tcp_connection),  0LL);
  nw_endpoint_t v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unint64_t v27 = "tcp_connection_create_with_connected_fd_inner";
    id v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v16, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v27 = "tcp_connection_create_with_connected_fd_inner";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s [tcp_connection initWithParameters:] failed", buf, 0xCu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v27 = "tcp_connection_create_with_connected_fd_inner";
            __int16 v28 = 2082;
            char v29 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v17,  v21,  "%{public}s [tcp_connection initWithParameters:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v16) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }

        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v27 = "tcp_connection_create_with_connected_fd_inner";
          _os_log_impl( &dword_181A5C000,  v17,  v21,  "%{public}s [tcp_connection initWithParameters:] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v27 = "tcp_connection_create_with_connected_fd_inner";
          _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s [tcp_connection initWithParameters:] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v16)
    {
LABEL_11:
      os_log_type_t v14 = 0LL;
      goto LABEL_14;
    }

char *tcp_connection_create_inbound(int a1)
{
  return tcp_connection_create_with_connected_fd_inner(a1, 1);
}

void tcp_connection_set_cellular_service(void *a1, const char *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unint64_t v33 = "tcp_connection_set_cellular_service";
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t v31 = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault((const char *)v9, &v31, &v30))
    {
      if (v31 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = v31;
        if (!os_log_type_enabled(v10, v31)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v33 = "tcp_connection_set_cellular_service";
        nw_endpoint_t v12 = "%{public}s called with null connection";
LABEL_34:
        char v24 = v10;
        os_log_type_t v25 = v11;
        goto LABEL_35;
      }

      if (!v30)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = v31;
        if (!os_log_type_enabled(v10, v31)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v33 = "tcp_connection_set_cellular_service";
        nw_endpoint_t v12 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_34;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v20 = v31;
      BOOL v21 = os_log_type_enabled(v10, v31);
      if (!backtrace_string)
      {
        if (!v21)
        {
LABEL_36:

          if (!v9) {
            goto LABEL_38;
          }
LABEL_37:
          free(v9);
          goto LABEL_38;
        }

        *(_DWORD *)buf = 136446210;
        unint64_t v33 = "tcp_connection_set_cellular_service";
        nw_endpoint_t v12 = "%{public}s called with null connection, no backtrace";
        char v24 = v10;
        os_log_type_t v25 = v20;
LABEL_35:
        _os_log_impl(&dword_181A5C000, v24, v25, v12, buf, 0xCu);
        goto LABEL_36;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v33 = "tcp_connection_set_cellular_service";
        __int16 v34 = 2082;
        int v35 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v9) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

  id v5 = nw_parameters_copy_required_netagent_domains(v3[6]);
  id v6 = nw_parameters_copy_required_netagent_types(v4[6]);
  xpc_object_t v7 = v6;
  if (!a2)
  {
    if (v5) {
      BOOL v13 = v6 == 0LL;
    }
    else {
      BOOL v13 = 1;
    }
    if (!v13 && xpc_array_get_count(v5))
    {
      xpc_object_t v14 = xpc_array_create(0LL, 0LL);
      xpc_object_t v15 = xpc_array_create(0LL, 0LL);
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __tcp_connection_set_cellular_service_block_invoke;
      applier[3] = &unk_189BC5628;
      id v16 = v14;
      id v27 = v16;
      id v28 = v7;
      id v17 = v15;
      id v29 = v17;
      xpc_array_apply(v5, applier);
      id v18 = v16;

      xpc_object_t v7 = v17;
      id v5 = v18;
    }

    goto LABEL_31;
  }

  if (v5)
  {
    if (v6) {
      goto LABEL_5;
    }
  }

  else
  {
    id v5 = xpc_array_create(0LL, 0LL);
    if (v7)
    {
LABEL_5:
      if (!v5) {
        goto LABEL_31;
      }
LABEL_26:
      if (v7)
      {
        xpc_array_set_string(v5, 0xFFFFFFFFFFFFFFFFLL, "Cellular");
        if (strstr(a2, "kCTDataConnectionServiceType"))
        {
          BOOL v22 = a2 + 28;
          os_log_type_t v23 = v7;
        }

        else
        {
          os_log_type_t v23 = v7;
          BOOL v22 = a2;
        }

        xpc_array_set_string(v23, 0xFFFFFFFFFFFFFFFFLL, v22);
      }

      goto LABEL_31;
    }
  }

  xpc_object_t v7 = xpc_array_create(0LL, 0LL);
  if (v5) {
    goto LABEL_26;
  }
LABEL_31:
  nw_parameters_set_required_netagent_classes(v4[6], v5, v7);

LABEL_38:
}

uint64_t __tcp_connection_set_cellular_service_block_invoke(xpc_object_t *a1, size_t a2, void *a3)
{
  id v5 = a3;
  if (object_getClass(v5) == (Class)MEMORY[0x1895F92E8])
  {
    string_ptr = xpc_string_get_string_ptr(v5);
    if (strncmp(string_ptr, "Cellular", 0x20uLL))
    {
      xpc_array_append_value(a1[4], v5);
      xpc_array_get_value(a1[5], a2);
      xpc_object_t v7 = (void *)objc_claimAutoreleasedReturnValue();
      if (v7) {
        xpc_array_append_value(a1[6], v7);
      }
    }
  }

  return 1LL;
}

void tcp_connection_set_no_cellular(void *a1, int a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v24 = "tcp_connection_set_no_cellular";
    id v8 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault((const char *)v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_26;
        }
        *(_DWORD *)buf = 136446210;
        char v24 = "tcp_connection_set_no_cellular";
        os_log_type_t v11 = "%{public}s called with null connection";
LABEL_24:
        id v17 = v9;
        os_log_type_t v18 = v10;
        goto LABEL_25;
      }

      if (!v21)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_26;
        }
        *(_DWORD *)buf = 136446210;
        char v24 = "tcp_connection_set_no_cellular";
        os_log_type_t v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_24;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
LABEL_26:

          if (!v8) {
            goto LABEL_28;
          }
LABEL_27:
          free(v8);
          goto LABEL_28;
        }

        *(_DWORD *)buf = 136446210;
        char v24 = "tcp_connection_set_no_cellular";
        os_log_type_t v11 = "%{public}s called with null connection, no backtrace";
        id v17 = v9;
        os_log_type_t v18 = v13;
LABEL_25:
        _os_log_impl(&dword_181A5C000, v17, v18, v11, buf, 0xCu);
        goto LABEL_26;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        char v24 = "tcp_connection_set_no_cellular";
        __int16 v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  if (nw_parameters_get_prohibit_cellular(v3[6]) != a2)
  {
    id v5 = nw_parameters_copy_prohibited_interface_types(v4[6]);
    xpc_object_t v6 = v5;
    if (!a2)
    {
      if (v5)
      {
        xpc_object_t v15 = xpc_array_create(0LL, 0LL);
        if (v15)
        {
          applier[0] = MEMORY[0x1895F87A8];
          applier[1] = 3221225472LL;
          applier[2] = __tcp_connection_set_no_cellular_block_invoke;
          applier[3] = &unk_189BC8CB8;
          id v20 = v15;
          id v16 = v15;
          xpc_array_apply(v6, applier);

          nw_parameters_set_prohibited_interface_types(v4[6], v16);
        }
      }

      goto LABEL_21;
    }

    if (v5 || (xpc_object_t v6 = xpc_array_create(0LL, 0LL)) != 0LL)
    {
      xpc_array_set_uint64(v6, 0xFFFFFFFFFFFFFFFFLL, 2uLL);
      nw_parameters_set_prohibited_interface_types(v4[6], v6);
LABEL_21:
    }
  }

uint64_t __tcp_connection_set_no_cellular_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;

  return 1LL;
}

void tcp_connection_set_no_expensive(uint64_t a1, BOOL a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_prohibit_expensive(*(nw_parameters_t *)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  xpc_object_t v15 = "tcp_connection_set_no_expensive";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    xpc_object_t v15 = "tcp_connection_set_no_expensive";
    xpc_object_t v6 = "%{public}s called with null connection";
LABEL_17:
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    xpc_object_t v15 = "tcp_connection_set_no_expensive";
    xpc_object_t v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      xpc_object_t v15 = "tcp_connection_set_no_expensive";
      __int16 v16 = 2082;
      id v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    xpc_object_t v15 = "tcp_connection_set_no_expensive";
    xpc_object_t v6 = "%{public}s called with null connection, no backtrace";
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_url(uint64_t a1, const char *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_url(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  xpc_object_t v15 = "tcp_connection_set_url";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    xpc_object_t v15 = "tcp_connection_set_url";
    xpc_object_t v6 = "%{public}s called with null connection";
LABEL_17:
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    xpc_object_t v15 = "tcp_connection_set_url";
    xpc_object_t v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      xpc_object_t v15 = "tcp_connection_set_url";
      __int16 v16 = 2082;
      id v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    xpc_object_t v15 = "tcp_connection_set_url";
    xpc_object_t v6 = "%{public}s called with null connection, no backtrace";
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_proxies(void *a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  os_log_type_t v5 = v4;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v21 = "tcp_connection_set_proxies";
    BOOL v9 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault((const char *)v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v21 = "tcp_connection_set_proxies";
        char v12 = "%{public}s called with null connection";
LABEL_21:
        __int16 v16 = v10;
        os_log_type_t v17 = v11;
        goto LABEL_22;
      }

      if (!v18)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v21 = "tcp_connection_set_proxies";
        char v12 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_23:

          if (!v9) {
            goto LABEL_25;
          }
LABEL_24:
          free(v9);
          goto LABEL_25;
        }

        *(_DWORD *)buf = 136446210;
        char v21 = "tcp_connection_set_proxies";
        char v12 = "%{public}s called with null connection, no backtrace";
        __int16 v16 = v10;
        os_log_type_t v17 = v14;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v16, v17, v12, buf, 0xCu);
        goto LABEL_23;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        char v21 = "tcp_connection_set_proxies";
        __int16 v22 = 2082;
        os_log_type_t v23 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v9) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  if (v4)
  {
    if (object_getClass(v4) == (Class)MEMORY[0x1895F9250] && !xpc_dictionary_get_count(v5))
    {
      nw_parameters_set_no_proxy(v3[6], 1);
      goto LABEL_25;
    }

    xpc_object_t v6 = v3[6];
    id v7 = v5;
  }

  else
  {
    nw_parameters_set_no_proxy(v3[6], 0);
    xpc_object_t v6 = v3[6];
    id v7 = 0LL;
  }

  nw_parameters_set_proxy_configuration(v6, v7);
LABEL_25:
}

void tcp_connection_set_persistent(void *a1, int a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    xpc_object_t v5 = nw_parameters_copy_preferred_netagent_domains(v3[6]);
    xpc_object_t v6 = nw_parameters_copy_preferred_netagent_types(v4[6]);
    xpc_object_t v7 = v6;
    if (!a2)
    {
      if (v5) {
        BOOL v13 = v6 == 0LL;
      }
      else {
        BOOL v13 = 1;
      }
      if (!v13 && xpc_array_get_count(v5))
      {
        xpc_object_t v14 = xpc_array_create(0LL, 0LL);
        xpc_object_t v15 = xpc_array_create(0LL, 0LL);
        applier[0] = MEMORY[0x1895F87A8];
        applier[1] = 3221225472LL;
        applier[2] = __tcp_connection_set_persistent_block_invoke;
        applier[3] = &unk_189BC5628;
        id v35 = v7;
        id v16 = v14;
        id v36 = v16;
        id v17 = v15;
        id v37 = v17;
        xpc_array_apply(v5, applier);
        id v18 = v16;

        xpc_object_t v7 = v17;
        xpc_object_t v5 = v18;
      }

      goto LABEL_52;
    }

    if (v5)
    {
      if (v6) {
        goto LABEL_5;
      }
    }

    else
    {
      xpc_object_t v5 = xpc_array_create(0LL, 0LL);
      if (v7)
      {
LABEL_5:
        if (!v5) {
          goto LABEL_28;
        }
        goto LABEL_26;
      }
    }

    xpc_object_t v7 = xpc_array_create(0LL, 0LL);
    if (!v5) {
      goto LABEL_28;
    }
LABEL_26:
    if (v7)
    {
      xpc_array_set_string(v5, 0xFFFFFFFFFFFFFFFFLL, "Persistent");
      xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "Persistent");
LABEL_52:
      nw_parameters_set_preferred_netagent_classes(v4[6], v5, v7);

      goto LABEL_53;
    }

uint64_t __tcp_connection_set_persistent_block_invoke(xpc_object_t *a1, size_t a2, void *a3)
{
  id v5 = a3;
  xpc_array_get_value(a1[4], a2);
  xpc_object_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  Class Class = object_getClass(v5);
  id v8 = (objc_class *)MEMORY[0x1895F92E8];
  if (Class == (Class)MEMORY[0x1895F92E8] && object_getClass(v6) == v8)
  {
    string_ptr = xpc_string_get_string_ptr(v5);
    if (strncmp(string_ptr, "Persistent", 0x20uLL)
      || (os_log_type_t v10 = xpc_string_get_string_ptr(v5), strncmp(v10, "Persistent", 0x20uLL)))
    {
      xpc_array_append_value(a1[5], v5);
      xpc_array_append_value(a1[6], v6);
    }
  }

  return 1LL;
}

void tcp_connection_set_opportunistic(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    id v16 = "tcp_connection_set_opportunistic";
    id v4 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v5 = (os_log_s *)(id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        id v16 = "tcp_connection_set_opportunistic";
        xpc_object_t v7 = "%{public}s called with null connection";
LABEL_20:
        os_log_type_t v11 = v5;
        os_log_type_t v12 = v6;
        goto LABEL_21;
      }

      if (!v13)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v5 = (os_log_s *)(id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        id v16 = "tcp_connection_set_opportunistic";
        xpc_object_t v7 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (!v10)
        {
LABEL_22:

          if (!v4) {
            return;
          }
LABEL_16:
          free(v4);
          return;
        }

        *(_DWORD *)buf = 136446210;
        id v16 = "tcp_connection_set_opportunistic";
        xpc_object_t v7 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v11 = v5;
        os_log_type_t v12 = v9;
LABEL_21:
        _os_log_impl(&dword_181A5C000, v11, v12, v7, buf, 0xCu);
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        id v16 = "tcp_connection_set_opportunistic";
        __int16 v17 = 2082;
        id v18 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v4) {
      return;
    }
    goto LABEL_16;
  }

  if (a2) {
    int v2 = 100;
  }
  else {
    int v2 = 0;
  }
  tcp_connection_set_traffic_class(a1, v2);
}

void tcp_connection_set_traffic_class(void *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "tcp_connection_set_traffic_class";
    xpc_object_t v7 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault((const char *)v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "tcp_connection_set_traffic_class";
        BOOL v10 = "%{public}s called with null connection";
LABEL_21:
        xpc_object_t v14 = v8;
        os_log_type_t v15 = v9;
        goto LABEL_22;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "tcp_connection_set_traffic_class";
        BOOL v10 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_23:

          if (!v7) {
            goto LABEL_25;
          }
LABEL_24:
          free(v7);
          goto LABEL_25;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "tcp_connection_set_traffic_class";
        BOOL v10 = "%{public}s called with null connection, no backtrace";
        xpc_object_t v14 = v8;
        os_log_type_t v15 = v12;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v14, v15, v10, buf, 0xCu);
        goto LABEL_23;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = "tcp_connection_set_traffic_class";
        __int16 v20 = 2082;
        BOOL v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v7) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  os_unfair_lock_lock(v3 + 30);
  if (nw_parameters_get_traffic_class(*(void **)&v4[12]._os_unfair_lock_opaque) != a2)
  {
    id v5 = *(void **)&v4[4]._os_unfair_lock_opaque;
    if (v5)
    {
      nw_connection_reset_traffic_class(v5, a2);
    }

    else if (LOBYTE(v4[39]._os_unfair_lock_opaque) - 1 >= 2)
    {
      nw_parameters_set_traffic_class(*(void **)&v4[12]._os_unfair_lock_opaque, a2);
    }
  }

  os_unfair_lock_unlock(v4 + 30);
LABEL_25:
}

void tcp_connection_set_no_fallback(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_no_fallback(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "tcp_connection_set_no_fallback";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "tcp_connection_set_no_fallback";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    BOOL v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "tcp_connection_set_no_fallback";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v15 = "tcp_connection_set_no_fallback";
      __int16 v16 = 2082;
      __int16 v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "tcp_connection_set_no_fallback";
    id v6 = "%{public}s called with null connection, no backtrace";
    BOOL v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_fallback_fast()
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v0 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    int v1 = 136446210;
    id v2 = "tcp_connection_set_fallback_fast";
    _os_log_impl( &dword_181A5C000,  v0,  OS_LOG_TYPE_ERROR,  "%{public}s tcp_connection_set_fallback_fast is deprecated",  (uint8_t *)&v1,  0xCu);
  }
}

void tcp_connection_set_usage_model(void *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "tcp_connection_set_usage_model";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_set_usage_model";
        os_log_type_t v11 = "%{public}s called with null connection";
LABEL_23:
        os_log_type_t v15 = v9;
        os_log_type_t v16 = v10;
        goto LABEL_24;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_set_usage_model";
        os_log_type_t v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
LABEL_25:

          if (!v8) {
            goto LABEL_20;
          }
          goto LABEL_19;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_set_usage_model";
        os_log_type_t v11 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v15 = v9;
        os_log_type_t v16 = v13;
LABEL_24:
        _os_log_impl(&dword_181A5C000, v15, v16, v11, buf, 0xCu);
        goto LABEL_25;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v20 = "tcp_connection_set_usage_model";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8) {
      goto LABEL_20;
    }
LABEL_19:
    free(v8);
    goto LABEL_20;
  }

  v3[31] = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v5 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    id v6 = (char *)*((void *)v4 + 12);
    *(_DWORD *)buf = 136446722;
    __int16 v20 = "tcp_connection_set_usage_model";
    __int16 v21 = 2048;
    uint64_t v22 = v6;
    __int16 v23 = 1024;
    int v24 = a2;
    _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %llu setting usage model to %d", buf, 0x1Cu);
  }

  if (*((_DWORD *)v4 + 31) == 1)
  {
    if (tcp_connection_is_first_party_onceToken != -1) {
      dispatch_once(&tcp_connection_is_first_party_onceToken, &__block_literal_global_32016);
    }
    if ((tcp_connection_is_first_party_is_first_party & 1) == 0) {
      nw_parameters_set_no_fallback(*((void **)v4 + 6), 1);
    }
  }

__CFBundle *__tcp_connection_is_first_party_block_invoke()
{
  uint64_t result = CFBundleGetMainBundle();
  if (!result
    || (uint64_t result = (__CFBundle *)CFBundleGetValueForInfoDictionaryKey(result, (CFStringRef)*MEMORY[0x189604E00])) == 0LL
    || (uint64_t result = (__CFBundle *)CFStringHasPrefix((CFStringRef)result, @"com.apple."), (_DWORD)result))
  {
    tcp_connection_is_first_party_is_first_party = 1;
  }

  return result;
}

void tcp_connection_add_event_excessive_keepalives(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "tcp_connection_add_event_excessive_keepalives";
    id v6 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault((const char *)v6, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "tcp_connection_add_event_excessive_keepalives";
        BOOL v9 = "%{public}s called with null connection";
LABEL_20:
        os_log_type_t v13 = v7;
        os_log_type_t v14 = v8;
        goto LABEL_21;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "tcp_connection_add_event_excessive_keepalives";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_22:

          if (!v6) {
            return;
          }
LABEL_16:
          free(v6);
          return;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "tcp_connection_add_event_excessive_keepalives";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v13 = v7;
        os_log_type_t v14 = v11;
LABEL_21:
        _os_log_impl(&dword_181A5C000, v13, v14, v9, buf, 0xCu);
        goto LABEL_22;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v18 = "tcp_connection_add_event_excessive_keepalives";
        __int16 v19 = 2082;
        __int16 v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6) {
      return;
    }
    goto LABEL_16;
  }

  if (a2) {
    char v4 = 32;
  }
  else {
    char v4 = 0;
  }
  *(_BYTE *)(a1 + 159) = *(_BYTE *)(a1 + 159) & 0xDF | v4;
  *(_DWORD *)(a1 + 136) = a4;
  *(_DWORD *)(a1 + 140) = a3;
  tcp_connection_set_keepalive_handler_on_nw_connection((void *)a1);
}

void tcp_connection_set_keepalive_handler_on_nw_connection(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  uint64_t v3 = (void *)*((void *)v1 + 2);
  if (v3)
  {
    int v5 = *((_DWORD *)v1 + 34);
    int v4 = *((_DWORD *)v1 + 35);
    if ((*((_BYTE *)v1 + 159) & 0x20) != 0)
    {
      v6[0] = MEMORY[0x1895F87A8];
      v6[1] = 3221225472LL;
      v6[2] = __tcp_connection_set_keepalive_handler_on_nw_connection_block_invoke;
      v6[3] = &unk_189BC93A0;
      id v7 = v1;
      nw_connection_set_excessive_keepalive_handler(v3, v4, v5, v6);
    }

    else
    {
      nw_connection_set_excessive_keepalive_handler(*((void **)v1 + 2), *((_DWORD *)v1 + 35), *((_DWORD *)v1 + 34), 0LL);
    }
  }
}

void __tcp_connection_set_keepalive_handler_on_nw_connection_block_invoke(uint64_t a1)
{
}

void tcp_connection_send_event_unlocked(void *a1, int a2, const void *a3, size_t a4, uint64_t a5)
{
  char v15 = a1;
  os_log_type_t v16 = 0LL;
  uint64_t v17 = 0LL;
  BOOL v9 = (os_unfair_lock_s *)(v15 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)v15 + 30);
  if (tcp_connection_fillout_event_locked(v15, (uint64_t)&v16, a2, a3, a4, a5))
  {
    os_log_type_t v10 = _Block_copy(*((const void **)v15 + 8));
    os_unfair_lock_unlock(v9);
    os_log_type_t v11 = v15;
    id v12 = v10;
    os_log_type_t v13 = v12;
    if (!v12 || v11[156] == 255)
    {
      os_log_type_t v14 = v16;
      if (!v16)
      {
LABEL_9:

        goto LABEL_10;
      }
    }

    else
    {
      os_log_type_t v14 = v16;
      (*((void (**)(id, void, void *))v12 + 2))(v12, v17, v16);
      if (!v14) {
        goto LABEL_9;
      }
    }

    free(v14);
    goto LABEL_9;
  }

  os_unfair_lock_unlock(v9);
LABEL_10:
}

BOOL tcp_connection_fillout_event_locked( void *a1, uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  os_log_type_t v11 = a1;
  id v12 = v11;
  if (*((unsigned __int8 *)v11 + 156) == 255)
  {
LABEL_50:
    uint64_t v22 = 0LL;
LABEL_53:

    return v22;
  }

  if (a3 == 3)
  {
    *((_BYTE *)v11 + 156) = 3;
    *((_BYTE *)v11 + 158) |= 0x30u;
  }

  if (v11[8])
  {
    os_log_type_t v13 = v11;
    switch(a3)
    {
      case 1:
        if ((v13[158] & 4) != 0) {
          goto LABEL_18;
        }
        char v14 = v13[158] | 4;
        goto LABEL_16;
      case 2:
        if ((v13[158] & 1) != 0) {
          goto LABEL_18;
        }
        char v14 = v13[158] | 1;
        goto LABEL_16;
      case 3:
        if ((v13[158] & 8) != 0) {
          goto LABEL_18;
        }
        char v14 = v13[158] | 8;
        goto LABEL_16;
      case 4:
        if ((v13[158] & 2) != 0)
        {
LABEL_18:
          int v15 = 0;
        }

        else
        {
          char v14 = v13[158] | 2;
LABEL_16:
          v13[158] = v14;
LABEL_17:
          int v15 = 1;
        }

        if (a3 != 7) {
          goto LABEL_20;
        }
        goto LABEL_21;
      default:
        goto LABEL_17;
    }
  }

  int v15 = 0;
  if (a3 != 7)
  {
LABEL_20:
    if (a3 != 1) {
      goto LABEL_23;
    }
  }

void tcp_connection_add_event_adaptive_read_timeout(uint64_t a1, int a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "tcp_connection_add_event_adaptive_read_timeout";
    int v5 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault((const char *)v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "tcp_connection_add_event_adaptive_read_timeout";
        os_log_type_t v8 = "%{public}s called with null connection";
LABEL_20:
        id v12 = v6;
        os_log_type_t v13 = v7;
        goto LABEL_21;
      }

      if (!v14)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "tcp_connection_add_event_adaptive_read_timeout";
        os_log_type_t v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_22:

          if (!v5) {
            return;
          }
LABEL_16:
          free(v5);
          return;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "tcp_connection_add_event_adaptive_read_timeout";
        os_log_type_t v8 = "%{public}s called with null connection, no backtrace";
        id v12 = v6;
        os_log_type_t v13 = v10;
LABEL_21:
        _os_log_impl(&dword_181A5C000, v12, v13, v8, buf, 0xCu);
        goto LABEL_22;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v17 = "tcp_connection_add_event_adaptive_read_timeout";
        __int16 v18 = 2082;
        size_t v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5) {
      return;
    }
    goto LABEL_16;
  }

  if (a2) {
    char v3 = 64;
  }
  else {
    char v3 = 0;
  }
  *(_BYTE *)(a1 + 159) = *(_BYTE *)(a1 + 159) & 0xBF | v3;
  *(_DWORD *)(a1 + 144) = a3;
  tcp_connection_set_adaptive_read_handler_on_nw_connection((void *)a1);
}

void tcp_connection_set_adaptive_read_handler_on_nw_connection(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  char v3 = (void *)*((void *)v1 + 2);
  if (v3)
  {
    int v4 = *((_DWORD *)v1 + 36);
    if ((*((_BYTE *)v1 + 159) & 0x40) != 0)
    {
      v5[0] = MEMORY[0x1895F87A8];
      v5[1] = 3221225472LL;
      v5[2] = __tcp_connection_set_adaptive_read_handler_on_nw_connection_block_invoke;
      v5[3] = &unk_189BC93A0;
      id v6 = v1;
      nw_connection_set_adaptive_read_handler(v3, v4, v5);
    }

    else
    {
      nw_connection_set_adaptive_read_handler(*((void **)v1 + 2), *((_DWORD *)v1 + 36), 0LL);
    }
  }
}

void __tcp_connection_set_adaptive_read_handler_on_nw_connection_block_invoke(uint64_t a1)
{
}

void tcp_connection_add_event_adaptive_write_timeout(uint64_t a1, int a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "tcp_connection_add_event_adaptive_write_timeout";
    int v5 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault((const char *)v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "tcp_connection_add_event_adaptive_write_timeout";
        os_log_type_t v8 = "%{public}s called with null connection";
LABEL_20:
        id v12 = v6;
        os_log_type_t v13 = v7;
        goto LABEL_21;
      }

      if (!v14)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "tcp_connection_add_event_adaptive_write_timeout";
        os_log_type_t v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_22:

          if (!v5) {
            return;
          }
LABEL_16:
          free(v5);
          return;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "tcp_connection_add_event_adaptive_write_timeout";
        os_log_type_t v8 = "%{public}s called with null connection, no backtrace";
        id v12 = v6;
        os_log_type_t v13 = v10;
LABEL_21:
        _os_log_impl(&dword_181A5C000, v12, v13, v8, buf, 0xCu);
        goto LABEL_22;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v17 = "tcp_connection_add_event_adaptive_write_timeout";
        __int16 v18 = 2082;
        size_t v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5) {
      return;
    }
    goto LABEL_16;
  }

  if (a2) {
    char v3 = 0x80;
  }
  else {
    char v3 = 0;
  }
  *(_BYTE *)(a1 + 159) = v3 & 0x80 | *(_BYTE *)(a1 + 159) & 0x7F;
  *(_DWORD *)(a1 + 148) = a3;
  tcp_connection_set_adaptive_write_handler_on_nw_connection((void *)a1);
}

void tcp_connection_set_adaptive_write_handler_on_nw_connection(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  char v3 = (void *)*((void *)v1 + 2);
  if (v3)
  {
    int v4 = *((_DWORD *)v1 + 37);
    if (v1[159] < 0)
    {
      v5[0] = MEMORY[0x1895F87A8];
      v5[1] = 3221225472LL;
      v5[2] = __tcp_connection_set_adaptive_write_handler_on_nw_connection_block_invoke;
      v5[3] = &unk_189BC93A0;
      id v6 = v1;
      nw_connection_set_adaptive_write_handler(v3, v4, v5);
    }

    else
    {
      nw_connection_set_adaptive_write_handler(*((void **)v1 + 2), *((_DWORD *)v1 + 37), 0LL);
    }
  }
}

void __tcp_connection_set_adaptive_write_handler_on_nw_connection_block_invoke(uint64_t a1)
{
}

BOOL tcp_connection_did_fallback(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "tcp_connection_did_fallback";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "tcp_connection_did_fallback";
        BOOL v9 = "%{public}s called with null connection";
LABEL_22:
        int v15 = v7;
        os_log_type_t v16 = v8;
        goto LABEL_23;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "tcp_connection_did_fallback";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "tcp_connection_did_fallback";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        int v15 = v7;
        os_log_type_t v16 = v12;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v20 = "tcp_connection_did_fallback";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_18:
      BOOL v4 = 0LL;
      goto LABEL_19;
    }

void tcp_connection_set_source_application(uint64_t a1, _OWORD *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v2 = *(void **)(a1 + 48);
    __int128 v3 = a2[1];
    *(_OWORD *)buf = *a2;
    *(_OWORD *)&buf[16] = v3;
    nw_parameters_set_source_application(v2, (__int128 *)buf);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "tcp_connection_set_source_application";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (!__nwlog_fault(v5, &type, &v14))
  {
LABEL_12:
    if (!v5) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (os_log_s *)(id)gLogObj;
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_set_source_application";
    os_log_type_t v8 = "%{public}s called with null connection";
LABEL_17:
    os_log_type_t v12 = v6;
    os_log_type_t v13 = v7;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v12, v13, v8, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (os_log_s *)(id)gLogObj;
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_set_source_application";
    os_log_type_t v8 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  BOOL v11 = os_log_type_enabled(v6, type);
  if (backtrace_string)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_connection_set_source_application";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_set_source_application";
    os_log_type_t v8 = "%{public}s called with null connection, no backtrace";
    os_log_type_t v12 = v6;
    os_log_type_t v13 = v10;
    goto LABEL_18;
  }

void tcp_connection_set_source_application_by_bundle(uint64_t a1, const char *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_source_application_by_bundle_id_internal(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v13 = "tcp_connection_set_source_application_by_bundle";
  __int128 v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (!__nwlog_fault(v3, &type, &v10))
  {
LABEL_8:
    if (!v3) {
      return;
    }
    goto LABEL_9;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (os_log_type_enabled(v4, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v13 = "tcp_connection_set_source_application_by_bundle";
      _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s called with null connection", buf, 0xCu);
    }

void tcp_connection_set_account_identifier(uint64_t a1, const char *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_account_id(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v15 = "tcp_connection_set_account_identifier";
  __int128 v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_account_identifier";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    char v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_account_identifier";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      int v15 = "tcp_connection_set_account_identifier";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_account_identifier";
    id v6 = "%{public}s called with null connection, no backtrace";
    char v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_no_delay(uint64_t a1, BOOL a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_no_delay(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v15 = "tcp_connection_set_no_delay";
  __int128 v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_no_delay";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    char v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_no_delay";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      int v15 = "tcp_connection_set_no_delay";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_no_delay";
    id v6 = "%{public}s called with null connection, no backtrace";
    char v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

BOOL tcp_connection_is_sleep_proxied(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "tcp_connection_is_sleep_proxied";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "tcp_connection_is_sleep_proxied";
        BOOL v9 = "%{public}s called with null connection";
LABEL_22:
        int v15 = v7;
        os_log_type_t v16 = v8;
        goto LABEL_23;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "tcp_connection_is_sleep_proxied";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "tcp_connection_is_sleep_proxied";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        int v15 = v7;
        os_log_type_t v16 = v12;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v20 = "tcp_connection_is_sleep_proxied";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_18:
      BOOL v4 = 0LL;
      goto LABEL_19;
    }

void tcp_connection_set_sleep_idle_interval(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_sleep_keepalive_interval(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v15 = "tcp_connection_set_sleep_idle_interval";
  __int128 v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_sleep_idle_interval";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    char v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_sleep_idle_interval";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      int v15 = "tcp_connection_set_sleep_idle_interval";
      __int16 v16 = 2082;
      char v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    int v15 = "tcp_connection_set_sleep_idle_interval";
    id v6 = "%{public}s called with null connection, no backtrace";
    char v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_keepalive(void *a1, BOOL a2, uint32_t a3, uint32_t a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  os_log_type_t v7 = a1;
  os_log_type_t v8 = v7;
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "tcp_connection_set_keepalive";
    char v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_keepalive";
        BOOL v13 = "%{public}s called with null connection";
LABEL_17:
        char v17 = v11;
        os_log_type_t v18 = v12;
        goto LABEL_18;
      }

      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_keepalive";
        BOOL v13 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
LABEL_19:

          if (!v10) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_keepalive";
        BOOL v13 = "%{public}s called with null connection, no backtrace";
        char v17 = v11;
        os_log_type_t v18 = v15;
LABEL_18:
        _os_log_impl(&dword_181A5C000, v17, v18, v13, buf, 0xCu);
        goto LABEL_19;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "tcp_connection_set_keepalive";
        __int16 v23 = 2082;
        int v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v10) {
      goto LABEL_14;
    }
LABEL_13:
    free(v10);
    goto LABEL_14;
  }

  nw_parameters_set_keepalive_enabled(v7[6], a2);
  nw_parameters_set_keepalive_idle_time(v8[6], a3);
  nw_parameters_set_keepalive_interval(v8[6], a4);
LABEL_14:
}

void tcp_connection_set_keepalive_offload(uint64_t a1, char a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_keepalive_offload(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "tcp_connection_set_keepalive_offload";
  __int128 v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "tcp_connection_set_keepalive_offload";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    char v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "tcp_connection_set_keepalive_offload";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v15 = "tcp_connection_set_keepalive_offload";
      __int16 v16 = 2082;
      char v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "tcp_connection_set_keepalive_offload";
    id v6 = "%{public}s called with null connection, no backtrace";
    char v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

BOOL tcp_connection_conditions_met(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "tcp_connection_conditions_met";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "tcp_connection_conditions_met";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v18 = "tcp_connection_conditions_met";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v7) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "tcp_connection_conditions_met";
          _os_log_impl(&dword_181A5C000, v8, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "tcp_connection_conditions_met";
          _os_log_impl( &dword_181A5C000,  v8,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v7)
    {
LABEL_11:
      BOOL v5 = 0LL;
      goto LABEL_14;
    }

uint64_t tcp_connection_conditions_get_unmet_reason(void *a1)
{
  *(void *)&v32[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 30);
    unsigned int reason = nw_path_get_reason(*(void **)&v2[8]._os_unfair_lock_opaque);
    unsigned int v4 = reason;
    if (reason < 0x20 && ((0xFFBFFFFF >> reason) & 1) != 0)
    {
      uint64_t v18 = qword_182667388[reason];
      goto LABEL_29;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    __int16 v30 = "tcp_connection_reason_code_from_path";
    __int16 v31 = 1024;
    *(_DWORD *)__int16 v32 = v4;
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v6, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_35;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v30 = "tcp_connection_reason_code_from_path";
        __int16 v31 = 1024;
        *(_DWORD *)__int16 v32 = v4;
        os_log_type_t v9 = "%{public}s Unknown nw_path_reason_t %u";
LABEL_33:
        __int16 v23 = v7;
        os_log_type_t v24 = v8;
        goto LABEL_34;
      }

      if (!v27)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_35;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v30 = "tcp_connection_reason_code_from_path";
        __int16 v31 = 1024;
        *(_DWORD *)__int16 v32 = v4;
        os_log_type_t v9 = "%{public}s Unknown nw_path_reason_t %u, backtrace limit exceeded";
        goto LABEL_33;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v17)
        {
LABEL_35:

          if (!v6) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446466;
        __int16 v30 = "tcp_connection_reason_code_from_path";
        __int16 v31 = 1024;
        *(_DWORD *)__int16 v32 = v4;
        os_log_type_t v9 = "%{public}s Unknown nw_path_reason_t %u, no backtrace";
        __int16 v23 = v7;
        os_log_type_t v24 = v16;
LABEL_34:
        _os_log_impl(&dword_181A5C000, v23, v24, v9, buf, 0x12u);
        goto LABEL_35;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446722;
        __int16 v30 = "tcp_connection_reason_code_from_path";
        __int16 v31 = 1024;
        *(_DWORD *)__int16 v32 = v4;
        v32[2] = 2082;
        *(void *)&v32[3] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v16,  "%{public}s Unknown nw_path_reason_t %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_19:
      uint64_t v18 = 10000LL;
LABEL_29:
      os_unfair_lock_unlock(v2 + 30);
      goto LABEL_30;
    }

void tcp_connection_set_queue(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "tcp_connection_set_queue";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v8, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_queue";
        os_log_type_t v11 = "%{public}s called with null connection";
LABEL_23:
        BOOL v17 = v9;
        os_log_type_t v18 = v10;
        goto LABEL_24;
      }

      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_queue";
        os_log_type_t v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
LABEL_25:

          if (!v8) {
            goto LABEL_20;
          }
          goto LABEL_19;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_queue";
        os_log_type_t v11 = "%{public}s called with null connection, no backtrace";
        BOOL v17 = v9;
        os_log_type_t v18 = v15;
LABEL_24:
        _os_log_impl(&dword_181A5C000, v17, v18, v11, buf, 0xCu);
        goto LABEL_25;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "tcp_connection_set_queue";
        __int16 v23 = 2082;
        os_log_type_t v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8) {
      goto LABEL_20;
    }
LABEL_19:
    free(v8);
    goto LABEL_20;
  }

  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 30);
    objc_storeStrong((id *)v3 + 7, a2);
    id v6 = (nw_connection *)*((void *)v3 + 2);
    if (v6) {
      nw_connection_set_queue(v6, *((dispatch_queue_t *)v3 + 7));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 30);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v13 = (char *)*((void *)v3 + 12);
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "tcp_connection_set_queue";
      __int16 v23 = 2048;
      os_log_type_t v24 = v13;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s %llu client specified nil dispatch queue - not supported",  buf,  0x16u);
    }
  }

uint64_t tcp_connection_id(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "tcp_connection_id";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "tcp_connection_id";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v18 = "tcp_connection_id";
            __int16 v19 = 2082;
            os_log_type_t v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v7) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "tcp_connection_id";
          _os_log_impl(&dword_181A5C000, v8, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "tcp_connection_id";
          _os_log_impl( &dword_181A5C000,  v8,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v7)
    {
LABEL_11:
      uint64_t v5 = 0LL;
      goto LABEL_13;
    }

void tcp_connection_set_minimum_throughput(void *a1, int a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_set_minimum_throughput";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "tcp_connection_set_minimum_throughput";
        BOOL v13 = "%{public}s called with null connection";
LABEL_19:
        BOOL v17 = v11;
        os_log_type_t v18 = v12;
        goto LABEL_20;
      }

      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "tcp_connection_set_minimum_throughput";
        BOOL v13 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_19;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
LABEL_21:

          if (!v10) {
            goto LABEL_16;
          }
          goto LABEL_15;
        }

        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "tcp_connection_set_minimum_throughput";
        BOOL v13 = "%{public}s called with null connection, no backtrace";
        BOOL v17 = v11;
        os_log_type_t v18 = v15;
LABEL_20:
        _os_log_impl(&dword_181A5C000, v17, v18, v13, buf, 0xCu);
        goto LABEL_21;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_connection_set_minimum_throughput";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v10) {
      goto LABEL_16;
    }
LABEL_15:
    free(v10);
    goto LABEL_16;
  }

  v3[38] = a2;
  uint64_t v5 = v3;
  id v6 = v5;
  id v7 = (void *)v5[2];
  if (v7)
  {
    int v8 = v4[38];
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __tcp_connection_set_minimum_throughput_on_nw_connection_block_invoke;
    uint64_t v22 = &unk_189BBBDC0;
    __int16 v23 = v5;
    nw_connection_set_low_throughput_handler(v7, v8, buf);
  }

LABEL_16:
}

void __tcp_connection_set_minimum_throughput_on_nw_connection_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  tcp_connection_send_event_unlocked(*(void **)(a1 + 32), 1073741830, &v2, 8uLL, (uint64_t)"low throughput");
}

void tcp_connection_override_obscure(void *a1, int a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "tcp_connection_override_obscure";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_override_obscure";
        os_log_type_t v11 = "%{public}s called with null connection";
LABEL_17:
        os_log_type_t v15 = v9;
        os_log_type_t v16 = v10;
        goto LABEL_18;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_override_obscure";
        os_log_type_t v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
LABEL_19:

          if (!v8) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_override_obscure";
        os_log_type_t v11 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v15 = v9;
        os_log_type_t v16 = v13;
LABEL_18:
        _os_log_impl(&dword_181A5C000, v15, v16, v11, buf, 0xCu);
        goto LABEL_19;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "tcp_connection_override_obscure";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8) {
      goto LABEL_14;
    }
LABEL_13:
    free(v8);
    goto LABEL_14;
  }

  nw_parameters_set_use_awdl(v5[6], a2);
  nw_parameters_set_use_p2p(v6[6], a3);
LABEL_14:
}

BOOL tcp_connection_is_viable(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "tcp_connection_is_viable";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_is_viable";
        int v8 = "%{public}s called with null connection";
LABEL_21:
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_22;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_is_viable";
        int v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_23:

          if (!v5) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_is_viable";
        int v8 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v10;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v18 = "tcp_connection_is_viable";
        __int16 v19 = 2082;
        os_log_type_t v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5)
    {
LABEL_17:
      BOOL v3 = 0LL;
      goto LABEL_18;
    }

BOOL tcp_connection_has_better_route(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "tcp_connection_has_better_route";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_has_better_route";
        int v8 = "%{public}s called with null connection";
LABEL_21:
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_22;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_has_better_route";
        int v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_23:

          if (!v5) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_has_better_route";
        int v8 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v10;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v18 = "tcp_connection_has_better_route";
        __int16 v19 = 2082;
        os_log_type_t v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5)
    {
LABEL_17:
      BOOL v3 = 0LL;
      goto LABEL_18;
    }

uint64_t tcp_connection_get_connection_quality(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "tcp_connection_get_connection_quality";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_get_connection_quality";
        int v8 = "%{public}s called with null connection";
LABEL_21:
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_22;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_get_connection_quality";
        int v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_23:

          if (!v5) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "tcp_connection_get_connection_quality";
        int v8 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v10;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v18 = "tcp_connection_get_connection_quality";
        __int16 v19 = 2082;
        os_log_type_t v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5)
    {
LABEL_17:
      uint64_t v3 = 0LL;
      goto LABEL_18;
    }

id tcp_connection_copy_proxy(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "tcp_connection_copy_proxy";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v8, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_copy_proxy";
        BOOL v11 = "%{public}s called with null connection";
LABEL_26:
        char v17 = v9;
        os_log_type_t v18 = v10;
        goto LABEL_27;
      }

      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_copy_proxy";
        BOOL v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_26;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_28:

          if (!v8) {
            goto LABEL_22;
          }
          goto LABEL_21;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_copy_proxy";
        BOOL v11 = "%{public}s called with null connection, no backtrace";
        char v17 = v9;
        os_log_type_t v18 = v14;
LABEL_27:
        _os_log_impl(&dword_181A5C000, v17, v18, v11, buf, 0xCu);
        goto LABEL_28;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "tcp_connection_copy_proxy";
        __int16 v23 = 2082;
        uint64_t v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8)
    {
LABEL_22:
      id v6 = 0LL;
      goto LABEL_23;
    }

void tcp_connection_set_connection_pool()
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v0 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    int v1 = 136446210;
    uint64_t v2 = "tcp_connection_set_connection_pool";
    _os_log_impl( &dword_181A5C000,  v0,  OS_LOG_TYPE_ERROR,  "%{public}s tcp_connection_set_connection_pool is deprecated",  (uint8_t *)&v1,  0xCu);
  }
}

void tcp_connection_set_multipath_service(uint64_t a1, nw_multipath_service_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_multipath_service(*(nw_parameters_t *)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  BOOL v15 = "tcp_connection_set_multipath_service";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_multipath_service";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_multipath_service";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v15 = "tcp_connection_set_multipath_service";
      __int16 v16 = 2082;
      char v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_multipath_service";
    id v6 = "%{public}s called with null connection, no backtrace";
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

BOOL tcp_connection_is_multipath(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "tcp_connection_is_multipath";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_is_multipath";
        BOOL v9 = "%{public}s called with null connection";
LABEL_22:
        BOOL v15 = v7;
        os_log_type_t v16 = v8;
        goto LABEL_23;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_is_multipath";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_is_multipath";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        BOOL v15 = v7;
        os_log_type_t v16 = v12;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "tcp_connection_is_multipath";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_18:
      BOOL v4 = 0LL;
      goto LABEL_19;
    }

uint64_t tcp_connection_multipath_get_subflow_count(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_multipath_get_subflow_count";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, type, &v18))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_multipath_get_subflow_count";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type[0];
        BOOL v15 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_connection_multipath_get_subflow_count";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v9) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_multipath_get_subflow_count";
          _os_log_impl(&dword_181A5C000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v16 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_multipath_get_subflow_count";
          _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9)
    {
LABEL_26:
      uint64_t v7 = 0LL;
      goto LABEL_27;
    }

uint64_t tcp_connection_multipath_get_primary_subflow_ifindex(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v5, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        id v8 = "%{public}s called with null connection";
LABEL_22:
        os_log_type_t v14 = v6;
        os_log_type_t v15 = v7;
        goto LABEL_23;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        id v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_24:

          if (!v5) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        char v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        id v8 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v14 = v6;
        os_log_type_t v15 = v11;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v14, v15, v8, buf, 0xCu);
        goto LABEL_24;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        char v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        __int16 v20 = 2082;
        uint64_t v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5)
    {
LABEL_18:
      uint64_t interface = 0LL;
      goto LABEL_19;
    }

uint64_t tcp_connection_get_interface(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "tcp_connection_get_interface";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v9, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "tcp_connection_get_interface";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v22 = "tcp_connection_get_interface";
            __int16 v23 = 2082;
            uint64_t v24 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v9) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "tcp_connection_get_interface";
          _os_log_impl(&dword_181A5C000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "tcp_connection_get_interface";
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9)
    {
LABEL_34:
      uint64_t routed_interface_index = 0LL;
      goto LABEL_35;
    }

void sub_18207EE2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id tcp_connection_multipath_copy_subflow_switch_counts(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        BOOL v9 = "%{public}s called with null connection";
LABEL_22:
        BOOL v15 = v7;
        os_log_type_t v16 = v8;
        goto LABEL_23;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        BOOL v15 = v7;
        os_log_type_t v16 = v12;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_18:
      id v4 = 0LL;
      goto LABEL_19;
    }

id tcp_connection_copy_tcp_info(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "tcp_connection_copy_tcp_info";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_copy_tcp_info";
        BOOL v9 = "%{public}s called with null connection";
LABEL_22:
        BOOL v15 = v7;
        os_log_type_t v16 = v8;
        goto LABEL_23;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_copy_tcp_info";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_copy_tcp_info";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        BOOL v15 = v7;
        os_log_type_t v16 = v12;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v20 = "tcp_connection_copy_tcp_info";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_18:
      id v4 = 0LL;
      goto LABEL_19;
    }

void tcp_connection_set_tls(void *a1, int a2, size_t *a3)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = v5;
  if (v5)
  {
    nw_parameters_set_tls(v5[6], a2);
    if (!a2) {
      goto LABEL_48;
    }
    if (!a3) {
      goto LABEL_45;
    }
    os_log_type_t v7 = (const void *)a3[1];
    if (!v7 || !*a3) {
      goto LABEL_44;
    }
    a3 = (size_t *)xpc_data_create(v7, *a3);
    if (a3)
    {
LABEL_45:
      nw_parameters_set_tls_session_id(v6[6], a3);
      uint64_t v24 = v6[2];
      if (v24)
      {
        id v25 = v24;
        os_log_type_t v26 = a3;
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = __nw_connection_start_tls_block_invoke;
        __int16 v32 = &unk_189BC9238;
        id v27 = v25;
        id v33 = v27;
        os_log_type_t v28 = v26;
        __int16 v34 = v28;
        nw_connection_async_if_needed(v27, buf);
      }

      goto LABEL_48;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v9, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s xpc_data_create failed", buf, 0xCu);
        }
      }

      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s xpc_data_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
          _os_log_impl(&dword_181A5C000, v10, v21, "%{public}s xpc_data_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
          _os_log_impl( &dword_181A5C000,  v10,  v23,  "%{public}s xpc_data_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_18207FA98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void tcp_connection_set_tls_prepare()
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v0 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  BOOL v13 = "tcp_connection_set_tls_prepare";
  id v1 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)(id)gLogObj;
    os_log_type_t v3 = type;
    if (!os_log_type_enabled(v2, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "tcp_connection_set_tls_prepare";
    id v4 = "%{public}s tcp_connection_set_tls_prepare is deprecated";
LABEL_15:
    id v8 = v2;
    os_log_type_t v9 = v3;
LABEL_16:
    _os_log_impl(&dword_181A5C000, v8, v9, v4, buf, 0xCu);
    goto LABEL_17;
  }

  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)(id)gLogObj;
    os_log_type_t v3 = type;
    if (!os_log_type_enabled(v2, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "tcp_connection_set_tls_prepare";
    id v4 = "%{public}s tcp_connection_set_tls_prepare is deprecated, backtrace limit exceeded";
    goto LABEL_15;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (os_log_s *)(id)gLogObj;
  os_log_type_t v6 = type;
  BOOL v7 = os_log_type_enabled(v2, type);
  if (backtrace_string)
  {
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v13 = "tcp_connection_set_tls_prepare";
      __int16 v14 = 2082;
      os_log_type_t v15 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v2,  v6,  "%{public}s tcp_connection_set_tls_prepare is deprecated, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_10:
    if (!v1) {
      return;
    }
    goto LABEL_11;
  }

  if (v7)
  {
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "tcp_connection_set_tls_prepare";
    id v4 = "%{public}s tcp_connection_set_tls_prepare is deprecated, no backtrace";
    id v8 = v2;
    os_log_type_t v9 = v6;
    goto LABEL_16;
  }

void tcp_connection_set_tls_handshake_message_handler()
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v0 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  BOOL v13 = "tcp_connection_set_tls_handshake_message_handler";
  id v1 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)(id)gLogObj;
    os_log_type_t v3 = type;
    if (!os_log_type_enabled(v2, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "tcp_connection_set_tls_handshake_message_handler";
    id v4 = "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated";
LABEL_15:
    id v8 = v2;
    os_log_type_t v9 = v3;
LABEL_16:
    _os_log_impl(&dword_181A5C000, v8, v9, v4, buf, 0xCu);
    goto LABEL_17;
  }

  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (os_log_s *)(id)gLogObj;
    os_log_type_t v3 = type;
    if (!os_log_type_enabled(v2, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "tcp_connection_set_tls_handshake_message_handler";
    id v4 = "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated, backtrace limit exceeded";
    goto LABEL_15;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (os_log_s *)(id)gLogObj;
  os_log_type_t v6 = type;
  BOOL v7 = os_log_type_enabled(v2, type);
  if (backtrace_string)
  {
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v13 = "tcp_connection_set_tls_handshake_message_handler";
      __int16 v14 = 2082;
      os_log_type_t v15 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v2,  v6,  "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_10:
    if (!v1) {
      return;
    }
    goto LABEL_11;
  }

  if (v7)
  {
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "tcp_connection_set_tls_handshake_message_handler";
    id v4 = "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated, no backtrace";
    id v8 = v2;
    os_log_type_t v9 = v6;
    goto LABEL_16;
  }

char *tcp_connection_create(const char *a1, unsigned int a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  os_log_type_t v6 = v5;
  if (a1)
  {
    if (v5)
    {
      BOOL host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(a1, __rev16(a2));
      id v8 = (void *)host_with_numeric_port;
      if (host_with_numeric_port) {
        os_log_type_t v9 = tcp_connection_create_with_endpoint_and_parameters((void *)host_with_numeric_port, 0LL, v6);
      }
      else {
        os_log_type_t v9 = 0LL;
      }

      goto LABEL_7;
    }

    __nwlog_obj();
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "tcp_connection_create";
    id v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v12, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "tcp_connection_create";
          os_log_type_t v15 = "%{public}s called with null queue";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v21)
      {
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "tcp_connection_create";
          os_log_type_t v15 = "%{public}s called with null queue, backtrace limit exceeded";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v20 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "tcp_connection_create";
          os_log_type_t v15 = "%{public}s called with null queue, no backtrace";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v20) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = "tcp_connection_create";
      __int16 v25 = 2082;
      os_log_type_t v26 = backtrace_string;
      os_log_type_t v19 = "%{public}s called with null queue, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v13, v14, v19, buf, 0x16u);
LABEL_25:

      free(backtrace_string);
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "tcp_connection_create";
    id v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v12, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "tcp_connection_create";
          os_log_type_t v15 = "%{public}s called with null hostname";
LABEL_34:
          _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
        }

char *tcp_connection_create_with_service(const char *a1, const char *a2, const char *a3, void *a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v7 = a4;
  nw_allow_use_of_dispatch_internal();
  if (!a1)
  {
    __nwlog_obj();
    id v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v29 = "tcp_connection_create_with_service";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          char v29 = "tcp_connection_create_with_service";
          uint64_t v16 = "%{public}s called with null name, backtrace limit exceeded";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v21 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          char v29 = "tcp_connection_create_with_service";
          uint64_t v16 = "%{public}s called with null name, no backtrace";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      if (!v21) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446466;
      char v29 = "tcp_connection_create_with_service";
      __int16 v30 = 2082;
      __int16 v31 = backtrace_string;
      BOOL v22 = "%{public}s called with null name, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_61;
    }
    *(_DWORD *)buf = 136446210;
    char v29 = "tcp_connection_create_with_service";
    uint64_t v16 = "%{public}s called with null name";
LABEL_60:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_61;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v29 = "tcp_connection_create_with_service";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          char v29 = "tcp_connection_create_with_service";
          uint64_t v16 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v23 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          char v29 = "tcp_connection_create_with_service";
          uint64_t v16 = "%{public}s called with null type, no backtrace";
          goto LABEL_60;
        }

        goto LABEL_61;
      }

      if (!v23) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446466;
      char v29 = "tcp_connection_create_with_service";
      __int16 v30 = 2082;
      __int16 v31 = backtrace_string;
      BOOL v22 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_42;
    }

    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_61;
    }
    *(_DWORD *)buf = 136446210;
    char v29 = "tcp_connection_create_with_service";
    uint64_t v16 = "%{public}s called with null type";
    goto LABEL_60;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v29 = "tcp_connection_create_with_service";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      char v29 = "tcp_connection_create_with_service";
      uint64_t v16 = "%{public}s called with null domain";
      goto LABEL_60;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "tcp_connection_create_with_service";
        uint64_t v16 = "%{public}s called with null domain, backtrace limit exceeded";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    BOOL v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "tcp_connection_create_with_service";
        uint64_t v16 = "%{public}s called with null domain, no backtrace";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    if (!v24) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446466;
    char v29 = "tcp_connection_create_with_service";
    __int16 v30 = 2082;
    __int16 v31 = backtrace_string;
    BOOL v22 = "%{public}s called with null domain, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_181A5C000, v14, v15, v22, buf, 0x16u);
LABEL_43:

    free(backtrace_string);
    goto LABEL_62;
  }

  if (v7)
  {
    nw_endpoint_t bonjour_service = nw_endpoint_create_bonjour_service(a1, a2, a3);
    nw_endpoint_t v9 = bonjour_service;
    if (bonjour_service) {
      char v10 = tcp_connection_create_with_endpoint_and_parameters(bonjour_service, 0LL, v7);
    }
    else {
      char v10 = 0LL;
    }

    goto LABEL_9;
  }

  __nwlog_obj();
  os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v29 = "tcp_connection_create_with_service";
  BOOL v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v13, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        char v29 = "tcp_connection_create_with_service";
        uint64_t v16 = "%{public}s called with null queue";
        goto LABEL_60;
      }

void tcp_connection_set_event_handler(void *a1, const void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "tcp_connection_set_event_handler";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "tcp_connection_set_event_handler";
        char v10 = "%{public}s called with null connection";
LABEL_17:
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v9;
        goto LABEL_18;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "tcp_connection_set_event_handler";
        char v10 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_19:

          if (!v7) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "tcp_connection_set_event_handler";
        char v10 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v12;
LABEL_18:
        _os_log_impl(&dword_181A5C000, v14, v15, v10, buf, 0xCu);
        goto LABEL_19;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v19 = "tcp_connection_set_event_handler";
        __int16 v20 = 2082;
        BOOL v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v7) {
      goto LABEL_14;
    }
LABEL_13:
    free(v7);
    goto LABEL_14;
  }

  id v4 = _Block_copy(a2);
  id v5 = (void *)v3[8];
  v3[8] = v4;

LABEL_14:
}

void tcp_connection_set_cancel_handler(void *a1, const void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "tcp_connection_set_cancel_handler";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "tcp_connection_set_cancel_handler";
        char v10 = "%{public}s called with null connection";
LABEL_17:
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v9;
        goto LABEL_18;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "tcp_connection_set_cancel_handler";
        char v10 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_19:

          if (!v7) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "tcp_connection_set_cancel_handler";
        char v10 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v12;
LABEL_18:
        _os_log_impl(&dword_181A5C000, v14, v15, v10, buf, 0xCu);
        goto LABEL_19;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v19 = "tcp_connection_set_cancel_handler";
        __int16 v20 = 2082;
        BOOL v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v7) {
      goto LABEL_14;
    }
LABEL_13:
    free(v7);
    goto LABEL_14;
  }

  id v4 = _Block_copy(a2);
  id v5 = (void *)v3[9];
  v3[9] = v4;

LABEL_14:
}

void tcp_connection_set_event_handler_f(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "tcp_connection_set_event_handler_f";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v9, &v20, &v19))
    {
      if (v20 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = v20;
        if (!os_log_type_enabled(v10, v20)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_event_handler_f";
        os_log_type_t v12 = "%{public}s called with null connection";
LABEL_17:
        char v16 = v10;
        os_log_type_t v17 = v11;
        goto LABEL_18;
      }

      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = v20;
        if (!os_log_type_enabled(v10, v20)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_event_handler_f";
        os_log_type_t v12 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = v20;
      BOOL v15 = os_log_type_enabled(v10, v20);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_19:

          if (!v9) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_event_handler_f";
        os_log_type_t v12 = "%{public}s called with null connection, no backtrace";
        char v16 = v10;
        os_log_type_t v17 = v14;
LABEL_18:
        _os_log_impl(&dword_181A5C000, v16, v17, v12, buf, 0xCu);
        goto LABEL_19;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "tcp_connection_set_event_handler_f";
        __int16 v23 = 2082;
        BOOL v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v9) {
      goto LABEL_14;
    }
LABEL_13:
    free(v9);
    goto LABEL_14;
  }

  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = __tcp_connection_set_event_handler_f_block_invoke;
  aBlock[3] = &__block_descriptor_48_e13_v20__0I8r_v12l;
  void aBlock[4] = a3;
  aBlock[5] = a2;
  id v6 = _Block_copy(aBlock);
  id v7 = (void *)v5[8];
  v5[8] = v6;

LABEL_14:
}

uint64_t __tcp_connection_set_event_handler_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void tcp_connection_set_interface_by_index(void *a1, unsigned int a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "tcp_connection_set_interface_by_index";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_set_interface_by_index";
        os_log_type_t v9 = "%{public}s called with null connection";
LABEL_23:
        BOOL v15 = v7;
        os_log_type_t v16 = v8;
        goto LABEL_24;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_set_interface_by_index";
        os_log_type_t v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
LABEL_25:

          if (!v6) {
            goto LABEL_20;
          }
          goto LABEL_19;
        }

        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "tcp_connection_set_interface_by_index";
        os_log_type_t v9 = "%{public}s called with null connection, no backtrace";
        BOOL v15 = v7;
        os_log_type_t v16 = v13;
LABEL_24:
        _os_log_impl(&dword_181A5C000, v15, v16, v9, buf, 0xCu);
        goto LABEL_25;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "tcp_connection_set_interface_by_index";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6) {
      goto LABEL_20;
    }
LABEL_19:
    free(v6);
    goto LABEL_20;
  }

  id v4 = nw_interface_create_with_index(a2);
  if (v4)
  {
    nw_parameters_require_interface(v3[6], (nw_interface_t)v4);
    if (!strcasecmp("awdl0", v4->name)) {
      nw_parameters_set_use_awdl(v3[6], 1);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v11 = (char *)v3[12];
      *(_DWORD *)buf = 136446722;
      os_log_type_t v20 = "tcp_connection_set_interface_by_index";
      __int16 v21 = 2048;
      uint64_t v22 = v11;
      __int16 v23 = 1024;
      unsigned int v24 = a2;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %llu could not set interface with index %d",  buf,  0x1Cu);
    }
  }

LABEL_20:
}

BOOL tcp_connection_set_interface_by_name(void *a1, char *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "tcp_connection_set_interface_by_name";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_interface_by_name";
        char v10 = "%{public}s called with null connection";
LABEL_23:
        char v17 = v8;
        os_log_type_t v18 = v9;
        goto LABEL_24;
      }

      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_interface_by_name";
        char v10 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_25:

          if (!v7) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "tcp_connection_set_interface_by_name";
        char v10 = "%{public}s called with null connection, no backtrace";
        char v17 = v8;
        os_log_type_t v18 = v14;
LABEL_24:
        _os_log_impl(&dword_181A5C000, v17, v18, v10, buf, 0xCu);
        goto LABEL_25;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v22 = "tcp_connection_set_interface_by_name";
        __int16 v23 = 2082;
        unsigned int v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v7)
    {
LABEL_19:
      BOOL v5 = 0LL;
      goto LABEL_20;
    }

void tcp_connection_set_indefinite(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_indefinite(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  BOOL v15 = "tcp_connection_set_indefinite";
  os_log_type_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_indefinite";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    char v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_indefinite";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v15 = "tcp_connection_set_indefinite";
      __int16 v16 = 2082;
      char v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_indefinite";
    id v6 = "%{public}s called with null connection, no backtrace";
    char v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

uint64_t tcp_connection_set_context(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  id v4 = a2;
  os_log_type_t v5 = v4;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "tcp_connection_set_context";
    char v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v10, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v24 = "tcp_connection_set_context";
        os_log_type_t v13 = "%{public}s called with null connection";
LABEL_22:
        char v19 = v11;
        os_log_type_t v20 = v12;
        goto LABEL_23;
      }

      if (!v21)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v24 = "tcp_connection_set_context";
        os_log_type_t v13 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v17)
        {
LABEL_24:

          if (!v10) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        unsigned int v24 = "tcp_connection_set_context";
        os_log_type_t v13 = "%{public}s called with null connection, no backtrace";
        char v19 = v11;
        os_log_type_t v20 = v16;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v19, v20, v13, buf, 0xCu);
        goto LABEL_24;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v24 = "tcp_connection_set_context";
        __int16 v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v10)
    {
LABEL_18:
      uint64_t v6 = 0LL;
      goto LABEL_19;
    }

void tcp_connection_set_low_latency(uint64_t a1, char a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_reduce_buffering(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  BOOL v15 = "tcp_connection_set_low_latency";
  os_log_type_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_low_latency";
    uint64_t v6 = "%{public}s called with null connection";
LABEL_17:
    char v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_low_latency";
    uint64_t v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v15 = "tcp_connection_set_low_latency";
      __int16 v16 = 2082;
      BOOL v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "tcp_connection_set_low_latency";
    uint64_t v6 = "%{public}s called with null connection, no backtrace";
    char v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

xpc_object_t tcp_connection_copy_context(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v19 = "tcp_connection_copy_context";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v6, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "tcp_connection_copy_context";
        BOOL v9 = "%{public}s called with null connection";
LABEL_21:
        os_log_type_t v14 = v7;
        os_log_type_t v15 = v8;
        goto LABEL_22;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "tcp_connection_copy_context";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v6) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        *(_DWORD *)buf = 136446210;
        char v19 = "tcp_connection_copy_context";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v14 = v7;
        os_log_type_t v15 = v11;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v14, v15, v9, buf, 0xCu);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        char v19 = "tcp_connection_copy_context";
        __int16 v20 = 2082;
        char v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_17:
      xpc_object_t v4 = 0LL;
      goto LABEL_18;
    }

uint64_t tcp_connection_get_error(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(unsigned int *)(a1 + 112);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "tcp_connection_get_error";
  os_log_type_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v3, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      xpc_object_t v4 = (os_log_s *)(id)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "tcp_connection_get_error";
      uint64_t v6 = "%{public}s called with null connection";
LABEL_17:
      char v10 = v4;
      os_log_type_t v11 = v5;
      goto LABEL_18;
    }

    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      xpc_object_t v4 = (os_log_s *)(id)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "tcp_connection_get_error";
      uint64_t v6 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    xpc_object_t v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v8 = type;
    BOOL v9 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (!v9)
      {
LABEL_19:

        if (!v3) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_13;
      }

      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "tcp_connection_get_error";
      uint64_t v6 = "%{public}s called with null connection, no backtrace";
      char v10 = v4;
      os_log_type_t v11 = v8;
LABEL_18:
      _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
      goto LABEL_19;
    }

    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v15 = "tcp_connection_get_error";
      __int16 v16 = 2082;
      BOOL v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
  }

  if (v3) {
LABEL_13:
  }
    free(v3);
  return 0xFFFFFFFFLL;
}

CFErrorRef nw_tcp_connection_copy_error(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_tcp_connection_copy_error";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v6, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_tcp_connection_copy_error";
        BOOL v9 = "%{public}s called with null connection";
LABEL_21:
        os_log_type_t v14 = v7;
        os_log_type_t v15 = v8;
        goto LABEL_22;
      }

      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_tcp_connection_copy_error";
        BOOL v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v6) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        *(_DWORD *)buf = 136446210;
        char v19 = "nw_tcp_connection_copy_error";
        BOOL v9 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v14 = v7;
        os_log_type_t v15 = v11;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v14, v15, v9, buf, 0xCu);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        char v19 = "nw_tcp_connection_copy_error";
        __int16 v20 = 2082;
        char v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v6)
    {
LABEL_17:
      CFErrorRef v4 = 0LL;
      goto LABEL_18;
    }

uint64_t tcp_connection_get_socket(void *a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  CFErrorRef v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v26 = "tcp_connection_get_socket";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v8, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446210;
        char v26 = "tcp_connection_get_socket";
        os_log_type_t v11 = "%{public}s called with null connection";
LABEL_25:
        char v16 = v9;
        os_log_type_t v17 = v10;
        goto LABEL_26;
      }

      if (!v23)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446210;
        char v26 = "tcp_connection_get_socket";
        os_log_type_t v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_25;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_27:

          if (!v8) {
            goto LABEL_22;
          }
          goto LABEL_21;
        }

        *(_DWORD *)buf = 136446210;
        char v26 = "tcp_connection_get_socket";
        os_log_type_t v11 = "%{public}s called with null connection, no backtrace";
        char v16 = v9;
        os_log_type_t v17 = v14;
LABEL_26:
        _os_log_impl(&dword_181A5C000, v16, v17, v11, buf, 0xCu);
        goto LABEL_27;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        char v26 = "tcp_connection_get_socket";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8)
    {
LABEL_22:
      uint64_t os_unfair_lock_opaque = 0xFFFFFFFFLL;
      goto LABEL_37;
    }

void tcp_connection_allow_client_socket_access(void *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  os_log_type_t v3 = a1;
  CFErrorRef v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "tcp_connection_allow_client_socket_access";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v7, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_26;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_allow_client_socket_access";
        os_log_type_t v10 = "%{public}s called with null connection";
LABEL_24:
        BOOL v15 = v8;
        os_log_type_t v16 = v9;
        goto LABEL_25;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_26;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_allow_client_socket_access";
        os_log_type_t v10 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_24;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
LABEL_26:

          if (!v7) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_connection_allow_client_socket_access";
        os_log_type_t v10 = "%{public}s called with null connection, no backtrace";
        BOOL v15 = v8;
        os_log_type_t v16 = v13;
LABEL_25:
        _os_log_impl(&dword_181A5C000, v15, v16, v10, buf, 0xCu);
        goto LABEL_26;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v20 = "tcp_connection_allow_client_socket_access";
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v7) {
      goto LABEL_21;
    }
LABEL_20:
    free(v7);
    goto LABEL_21;
  }

  if ((v3[39]._os_unfair_lock_opaque & 0x10000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v20 = "tcp_connection_allow_client_socket_access";
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called before tcp_connection_start",  buf,  0xCu);
    }
  }

  else
  {
    os_unfair_lock_lock(v3 + 30);
    if (a2) {
      char v5 = 0x80;
    }
    else {
      char v5 = 0;
    }
    BYTE2(v4[39]._os_unfair_lock_opaque) = v5 & 0x80 | BYTE2(v4[39]._os_unfair_lock_opaque) & 0x7F;
    nw_parameters_set_allow_socket_access(*(void **)&v4[12]._os_unfair_lock_opaque, a2);
    os_unfair_lock_unlock(v4 + 30);
  }

uint64_t tcp_connection_copy_socket(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_copy_socket";
    id v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v6, type, &v19))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_copy_socket";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type[0];
        BOOL v13 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_connection_copy_socket";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v6) {
            goto LABEL_17;
          }
          goto LABEL_13;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_copy_socket";
          _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_copy_socket";
          _os_log_impl( &dword_181A5C000,  v7,  v18,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v6) {
      goto LABEL_17;
    }
LABEL_13:
    free(v6);
    goto LABEL_17;
  }

  os_log_type_t v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFErrorRef v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_connection_copy_socket";
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_16;
  }

  if ((v1[158] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFErrorRef v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_connection_copy_socket";
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot get socket on a connection for which client socket access is disallowed.",  buf,  0xCu);
    }

BOOL tcp_connection_get_hostname(void *a1, _BYTE *a2, unint64_t a3)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v16 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v33 = "tcp_connection_get_hostname";
    int v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v17, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "tcp_connection_get_hostname";
          _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v33 = "tcp_connection_get_hostname";
            __int16 v34 = 2082;
            uint64_t v35 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v18,  v24,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v17) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "tcp_connection_get_hostname";
          _os_log_impl(&dword_181A5C000, v18, v24, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "tcp_connection_get_hostname";
          _os_log_impl( &dword_181A5C000,  v18,  v26,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v17)
    {
LABEL_25:
      unint64_t v10 = 0LL;
LABEL_49:

      return v10;
    }

void sub_182083E44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void tcp_connection_start(void *a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v2 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v3 = (os_log_s *)(id)gLogObj;
  CFErrorRef v4 = v3;
  if (!v2)
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_start";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v19, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v20 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "tcp_connection_start";
        int v22 = "%{public}s called with null connection";
LABEL_38:
        char v30 = v20;
        os_log_type_t v31 = v21;
        goto LABEL_39;
      }

      if (!v36)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v20 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "tcp_connection_start";
        int v22 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (os_log_s *)(id)gLogObj;
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (!v29)
        {
LABEL_40:

          if (!v19) {
            goto LABEL_35;
          }
          goto LABEL_34;
        }

        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "tcp_connection_start";
        int v22 = "%{public}s called with null connection, no backtrace";
        char v30 = v20;
        os_log_type_t v31 = v28;
LABEL_39:
        _os_log_impl(&dword_181A5C000, v30, v31, v22, buf, 0xCu);
        goto LABEL_40;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_connection_start";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v20,  v28,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v19) {
      goto LABEL_35;
    }
LABEL_34:
    free(v19);
    goto LABEL_35;
  }

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *((void *)v2 + 12);
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_connection_start";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v5;
    _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %llu starting", buf, 0x16u);
  }

  if (!*((void *)v2 + 2))
  {
    id v6 = nw_connection_create_with_id(*((void **)v2 + 5), *((void **)v2 + 6), *((void *)v2 + 12));
    id v7 = (void *)*((void *)v2 + 2);
    *((void *)v2 + 2) = v6;

    nw_connection_set_queue(*((nw_connection_t *)v2 + 2), *((dispatch_queue_t *)v2 + 7));
    *((void *)v2 + 12) = nw_connection_get_id(*((void **)v2 + 2));
  }

  *((_BYTE *)v2 + 159) |= 0x10u;
  objc_storeStrong((id *)v2 + 11, a1);
  id v8 = (nw_connection *)*((void *)v2 + 2);
  uint64_t v9 = MEMORY[0x1895F87A8];
  handler[0] = MEMORY[0x1895F87A8];
  handler[1] = 3221225472LL;
  handler[2] = __tcp_connection_start_block_invoke;
  handler[3] = &unk_189BC9318;
  id v10 = v2;
  id v35 = v10;
  nw_connection_set_state_changed_handler(v8, handler);
  os_log_type_t v11 = (nw_connection *)*((void *)v2 + 2);
  v32[0] = v9;
  v32[1] = 3221225472LL;
  v32[2] = __tcp_connection_start_block_invoke_29;
  v32[3] = &unk_189BC8678;
  size_t v12 = (int *)v10;
  uint64_t v33 = v12;
  nw_connection_set_path_changed_handler(v11, v32);
  char v13 = *((_BYTE *)v2 + 159);
  if ((v13 & 0x20) != 0)
  {
    tcp_connection_set_keepalive_handler_on_nw_connection(v12);
    char v13 = *((_BYTE *)v2 + 159);
    if ((v13 & 0x40) == 0)
    {
LABEL_8:
      if ((v13 & 0x80) == 0) {
        goto LABEL_9;
      }
      goto LABEL_23;
    }
  }

  else if ((*((_BYTE *)v2 + 159) & 0x40) == 0)
  {
    goto LABEL_8;
  }

  tcp_connection_set_adaptive_read_handler_on_nw_connection(v12);
  if ((*((_BYTE *)v2 + 159) & 0x80) == 0)
  {
LABEL_9:
    if (!v12[38]) {
      goto LABEL_10;
    }
LABEL_24:
    int v23 = v12;
    os_log_type_t v24 = v23;
    BOOL v25 = (void *)*((void *)v2 + 2);
    if (v25)
    {
      int v26 = v12[38];
      *(void *)buf = v9;
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __tcp_connection_set_minimum_throughput_on_nw_connection_block_invoke;
      os_log_type_t v39 = &unk_189BBBDC0;
      int v40 = v23;
      nw_connection_set_low_throughput_handler(v25, v26, buf);
    }

    unint64_t v14 = (void *)*((void *)v12 + 9);
    if (!v14) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

void __tcp_connection_start_block_invoke(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v82 = *MEMORY[0x1895F89C0];
  id v6 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 120LL));
  uint64_t v7 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v7 + 156) != 255)
  {
    unsigned int v66 = a2;
    switch(a2)
    {
      case 1u:
        int v8 = 0;
        int v9 = (*(unsigned __int8 *)(v7 + 159) << 29 >> 31) & 7;
        if (v6) {
          goto LABEL_29;
        }
        goto LABEL_30;
      case 2u:
        id v10 = (id)v7;
        os_log_type_t v11 = (dispatch_source_s *)*((void *)v10 + 10);
        if (v11)
        {
          dispatch_source_cancel(v11);
          size_t v12 = (void *)*((void *)v10 + 10);
          *((void *)v10 + 10) = 0LL;
        }

        if ((*((_BYTE *)v10 + 158) & 0x40) == 0) {
          goto LABEL_84;
        }
        dispatch_source_t v13 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *((dispatch_queue_t *)v10 + 7));
        unint64_t v14 = (void *)*((void *)v10 + 10);
        *((void *)v10 + 10) = v13;

        int v15 = (dispatch_source_s *)*((void *)v10 + 10);
        if (v15)
        {
          *(void *)handler = MEMORY[0x1895F87A8];
          *(void *)&handler[8] = 3221225472LL;
          *(void *)&handler[16] = __tcp_connection_start_attempt_timer_locked_block_invoke;
          os_log_type_t v75 = (char *)&unk_189BC93A0;
          id v16 = v10;
          *(void *)os_log_type_t v76 = v16;
          dispatch_source_set_event_handler(v15, handler);
          if (v16[13]) {
            unint64_t v17 = v16[13];
          }
          else {
            unint64_t v17 = 180000000000LL;
          }
          os_log_type_t v18 = (dispatch_source_s *)*((void *)v10 + 10);
          dispatch_time_t v19 = dispatch_time(0LL, v17);
          dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          dispatch_resume(*((dispatch_object_t *)v10 + 10));
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v20 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v21 = v16[12];
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_connection_start_attempt_timer_locked";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v21;
            *(_WORD *)&buf[22] = 2048;
            unint64_t v80 = v17 / 0x3B9ACA00;
            _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %llu scheduling connection attempt timer for %llus",  buf,  0x20u);
          }

          goto LABEL_84;
        }

        __nwlog_obj();
        os_log_type_t v58 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)handler = 136446210;
        *(void *)&void handler[4] = "tcp_connection_start_attempt_timer_locked";
        uint64_t v59 = (char *)_os_log_send_and_compose_impl();

        buf[0] = 16;
        LOBYTE(v69) = 0;
        if (buf[0] == 17)
        {
          __nwlog_obj();
          os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v61 = buf[0];
          if (os_log_type_enabled(v60, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&void handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl(&dword_181A5C000, v60, v61, "%{public}s dispatch_source_create failed", handler, 0xCu);
          }
        }

        else if ((_BYTE)v69)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v63 = buf[0];
          BOOL v64 = os_log_type_enabled(v60, (os_log_type_t)buf[0]);
          if (backtrace_string)
          {
            if (v64)
            {
              *(_DWORD *)handler = 136446466;
              *(void *)&void handler[4] = "tcp_connection_start_attempt_timer_locked";
              *(_WORD *)&handler[12] = 2082;
              *(void *)&handler[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v60,  v63,  "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s",  handler,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_82;
          }

          if (v64)
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&void handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl( &dword_181A5C000,  v60,  v63,  "%{public}s dispatch_source_create failed, no backtrace",  handler,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v65 = buf[0];
          if (os_log_type_enabled(v60, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&void handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl( &dword_181A5C000,  v60,  v65,  "%{public}s dispatch_source_create failed, backtrace limit exceeded",  handler,  0xCu);
          }
        }

LABEL_82:
        if (v59) {
          free(v59);
        }
LABEL_84:

        int v8 = 0;
        int v9 = 0;
        *(_BYTE *)(*(void *)(a1 + 32) + 159LL) |= 4u;
        if (v6) {
          goto LABEL_29;
        }
        goto LABEL_30;
      case 3u:
        BOOL v22 = nw_connection_used_tls(*(void **)(v7 + 16));
        uint64_t v23 = *(void *)(a1 + 32);
        BOOL v25 = (_BYTE *)(v23 + 159);
        int v24 = *(unsigned __int8 *)(v23 + 159);
        if ((~v24 & 3) == 0)
        {
          int v8 = 0;
          int v9 = 0;
          goto LABEL_28;
        }

        int v8 = 0;
        if ((v24 & v22 & 1) != 0)
        {
          int v9 = 8;
        }

        else
        {
          _BYTE *v25 = v24 | 1;
          uint64_t v23 = *(void *)(a1 + 32);
          int v9 = 1;
          if ((v24 & 1) != 0 || !v22)
          {
LABEL_28:
            *(_DWORD *)(v23 + 112) = 0;
            objc_storeStrong((id *)(*(void *)(a1 + 32) + 24LL), a3);
            *(void *)(*(void *)(a1 + 32) + 128LL) = tcp_connection_quality_from_path( *(void **)(a1 + 32),  *(void **)(*(void *)(a1 + 32) + 32LL));
            int v26 = (void **)*(id *)(a1 + 32);
            os_log_type_t v28 = v26 + 2;
            __int16 v27 = v26[2];
            BOOL v29 = (void *)MEMORY[0x1895F87A8];
            *(void *)handler = MEMORY[0x1895F87A8];
            *(void *)&handler[8] = 3221225472LL;
            *(void *)&handler[16] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke;
            os_log_type_t v75 = (char *)&unk_189BC93A0;
            char v30 = v26;
            *(void *)os_log_type_t v76 = v30;
            nw_connection_set_read_close_handler(v27, handler);
            os_log_type_t v31 = *v28;
            *(void *)buf = v29;
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_2;
            unint64_t v80 = (unint64_t)&unk_189BC93A0;
            int v32 = v30;
            char v81 = v32;
            nw_connection_set_write_close_handler(v31, buf);
            uint64_t v33 = (nw_connection *)*v28;
            BOOL v69 = v29;
            uint64_t v70 = 3221225472LL;
            os_log_type_t v71 = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_3;
            BOOL v72 = &unk_189BBBDE8;
            __int16 v34 = v32;
            int v73 = v34;
            nw_connection_set_viability_changed_handler(v33, &v69);
            id v35 = (nw_connection *)*v28;
            v67[0] = v29;
            v67[1] = 3221225472LL;
            v67[2] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_4;
            v67[3] = &unk_189BBBDE8;
            os_log_type_t v68 = v34;
            char v36 = v34;
            nw_connection_set_better_path_available_handler(v35, v67);

            if (v6) {
              goto LABEL_29;
            }
LABEL_30:
            *(void *)buf = 0LL;
            *(void *)&buf[8] = 0LL;
            BOOL v69 = 0LL;
            uint64_t v70 = 0LL;
            if (v9)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v39 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v40 = *(void *)(*(void *)(a1 + 32) + 96LL);
                uint64_t v41 = off_189BBBE08[v9 - 1];
                if (v66 > 5) {
                  __int16 v42 = "unknown";
                }
                else {
                  __int16 v42 = off_189BB9C00[v66];
                }
                *(_DWORD *)handler = 136447234;
                *(void *)&void handler[4] = "tcp_connection_start_block_invoke";
                *(_WORD *)&handler[12] = 2048;
                *(void *)&handler[14] = v40;
                *(_WORD *)&handler[22] = 2082;
                os_log_type_t v75 = v41;
                *(_WORD *)os_log_type_t v76 = 2082;
                *(void *)&v76[2] = v42;
                __int16 v77 = 2114;
                id v78 = v6;
                _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s %llu sending event %{public}s in response to state %{public}s and error %{public}@",  handler,  0x34u);
              }

              BOOL v43 = tcp_connection_fillout_event_locked( *(void **)(a1 + 32),  (uint64_t)buf,  v9,  0LL,  0LL,  (uint64_t)"nw_connection event");
              if (!v8)
              {
LABEL_45:
                uint64_t v48 = *(void *)(a1 + 32);
                if ((v43 | v8) == 1)
                {
                  int v49 = _Block_copy(*(const void **)(v48 + 64));
                  uint64_t v48 = *(void *)(a1 + 32);
                }

                else
                {
                  int v49 = 0LL;
                }

                os_unfair_lock_unlock((os_unfair_lock_t)(v48 + 120));
                if (!v43)
                {
LABEL_54:
                  if (!v8)
                  {
LABEL_60:

                    goto LABEL_61;
                  }

                  nw_protocol_definition_t v54 = (unsigned __int8 *)*(id *)(a1 + 32);
                  id v55 = v49;
                  os_log_type_t v56 = v55;
                  if (!v55 || v54[156] == 255)
                  {
                    __int16 v57 = v69;
                    if (!v69) {
                      goto LABEL_59;
                    }
                  }

                  else
                  {
                    __int16 v57 = v69;
                    (*((void (**)(id, void, void *))v55 + 2))(v55, v70, v69);
                    if (!v57)
                    {
LABEL_59:

                      goto LABEL_60;
                    }
                  }

                  free(v57);
                  goto LABEL_59;
                }

                int v50 = (unsigned __int8 *)*(id *)(a1 + 32);
                id v51 = v49;
                id v52 = v51;
                if (!v51 || v50[156] == 255)
                {
                  __int16 v53 = *(void **)buf;
                  if (!*(void *)buf) {
                    goto LABEL_53;
                  }
                }

                else
                {
                  __int16 v53 = *(void **)buf;
                  (*((void (**)(id, void, void))v51 + 2))(v51, *(unsigned int *)&buf[8], *(void *)buf);
                  if (!v53)
                  {
LABEL_53:

                    goto LABEL_54;
                  }
                }

                free(v53);
                goto LABEL_53;
              }
            }

            else
            {
              BOOL v43 = 0;
              if (!v8) {
                goto LABEL_45;
              }
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v44 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v45 = *(void *)(*(void *)(a1 + 32) + 96LL);
              os_log_type_t v46 = off_189BBBE08[v8 - 1];
              if (v66 > 5) {
                char v47 = "unknown";
              }
              else {
                char v47 = off_189BB9C00[v66];
              }
              *(_DWORD *)handler = 136447234;
              *(void *)&void handler[4] = "tcp_connection_start_block_invoke";
              *(_WORD *)&handler[12] = 2048;
              *(void *)&handler[14] = v45;
              *(_WORD *)&handler[22] = 2082;
              os_log_type_t v75 = v46;
              *(_WORD *)os_log_type_t v76 = 2082;
              *(void *)&v76[2] = v47;
              __int16 v77 = 2114;
              id v78 = v6;
              _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %llu sending secondary event %{public}s in response to state %{public}s and error %{public}@",  handler,  0x34u);
            }

            int v8 = tcp_connection_fillout_event_locked( *(void **)(a1 + 32),  (uint64_t)&v69,  v8,  0LL,  0LL,  (uint64_t)"nw_connection secondary event");
            goto LABEL_45;
          }

          LOBYTE(v24) = *(_BYTE *)(v23 + 159);
          int v8 = 8;
          BOOL v25 = (_BYTE *)(v23 + 159);
        }

        _BYTE *v25 = v24 | 2;
        uint64_t v23 = *(void *)(a1 + 32);
        goto LABEL_28;
      case 4u:
      case 5u:
        int v8 = 0;
        int v9 = 3;
        if (v6) {
          goto LABEL_29;
        }
        goto LABEL_30;
      default:
        int v8 = 0;
        int v9 = 0;
        if (v6)
        {
LABEL_29:
          objc_storeStrong((id *)(*(void *)(a1 + 32) + 24LL), a3);
          int v37 = v6;
          int v38 = v37[3];

          *(_DWORD *)(*(void *)(a1 + 32) + 112LL) = v38;
        }

        goto LABEL_30;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 120));
LABEL_61:
}

void __tcp_connection_start_block_invoke_29(uint64_t a1, void *a2)
{
  id v26 = a2;
  __int16 v27 = 0LL;
  BOOL v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v28 = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 120LL));
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v4 + 156) == 255)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 120));
    size_t v12 = 0LL;
    goto LABEL_42;
  }

  uint64_t v5 = *(void **)(v4 + 32);
  if (v5)
  {
    id v6 = v5;
    int v7 = v6[94];

    int v8 = v7 == 1;
    int v9 = v26;
    if (v26)
    {
LABEL_4:
      id v10 = v9;
      int v11 = v10[94] == 1;

      goto LABEL_8;
    }
  }

  else
  {
    int v8 = 0;
    int v9 = v26;
    if (v26) {
      goto LABEL_4;
    }
  }

  int v11 = 0;
LABEL_8:
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 32LL), a2);
  uint64_t v13 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v13 + 159) & 1) != 0)
  {
    uint64_t v16 = tcp_connection_quality_from_path(*(void **)(a1 + 32), v26);
    if (*(void *)(v13 + 128) == v16)
    {
      BOOL v15 = 0;
    }

    else
    {
      unint64_t v17 = "connection quality changed";
      if (v16 == 2) {
        unint64_t v17 = "connection quality changed to normal";
      }
      if (v16 == 1) {
        os_log_type_t v18 = "connection quality changed to bad";
      }
      else {
        os_log_type_t v18 = v17;
      }
      *(void *)(v13 + 128) = v16;
      BOOL v15 = tcp_connection_fillout_event_locked((void *)v13, (uint64_t)&v29, 1073741833, 0LL, 0LL, (uint64_t)v18);
    }

    uint64_t v13 = *(void *)(a1 + 32);
    if (v8 == v11)
    {
      BOOL v14 = 0;
      if (v15) {
        goto LABEL_27;
      }
    }

    else
    {
      if (v11) {
        dispatch_time_t v19 = "conditions satisfied";
      }
      else {
        dispatch_time_t v19 = "conditions not satisfied";
      }
      BOOL v14 = tcp_connection_fillout_event_locked(*(void **)(a1 + 32), (uint64_t)&v27, 1073741826, 0LL, 0LL, (uint64_t)v19);
      uint64_t v13 = *(void *)(a1 + 32);
      if (v15) {
        goto LABEL_27;
      }
    }
  }

  else
  {
    BOOL v14 = 0;
    BOOL v15 = 0;
  }

  if (!v14)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v13 + 120));
    size_t v12 = 0LL;
    goto LABEL_35;
  }

uint64_t tcp_connection_quality_from_path(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = a2;
  if (v4)
  {
    uint64_t v5 = (void **)v3;
    id v6 = v5;
    uint64_t v7 = v4[14];
    if (v7
      && *(_DWORD *)(v7 + 8)
      && (nw_parameters_get_pid(v5[6]),
          nw_parameters_get_effective_bundle_id(v6[6]),
          (_symptoms_is_daemon_fallback_blacklisted() & 1) == 0))
    {
      if (*((_DWORD *)v6 + 31) != 1) {
        goto LABEL_12;
      }
      if (tcp_connection_is_first_party_onceToken != -1) {
        dispatch_once(&tcp_connection_is_first_party_onceToken, &__block_literal_global_32016);
      }
      if (tcp_connection_is_first_party_is_first_party == 1)
      {
LABEL_12:

        uint64_t v8 = 1LL;
        goto LABEL_7;
      }

      BOOL v10 = nw_parameters_multipath_fallback_allowed(v6[6]);

      if (v10)
      {
        uint64_t v8 = 1LL;
        goto LABEL_7;
      }
    }

    else
    {
    }
  }

  uint64_t v8 = 2LL;
LABEL_7:

  return v8;
}

void __tcp_connection_start_attempt_timer_locked_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = *(id *)(a1 + 32);
  BOOL v14 = 0LL;
  uint64_t v15 = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)v1 + 30);
  uint64_t v2 = *((void *)v1 + 6);
  if (!v2 || !nw_path_parameters_get_logging_disabled(*(void *)(v2 + 104)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *((void *)v1 + 12);
      *(_DWORD *)buf = 136446466;
      unint64_t v17 = "tcp_connection_attempt_timer_fired_on_client_queue";
      __int16 v18 = 2048;
      uint64_t v19 = v4;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s %llu connection took too long to connect, cleaning up current attempt",  buf,  0x16u);
    }
  }

  *((_DWORD *)v1 + 28) = 60;
  if ((*((_BYTE *)v1 + 158) & 0x40) != 0
    && tcp_connection_fillout_event_locked( v1,  (uint64_t)&v14,  1073741832,  0LL,  0LL,  (uint64_t)"connection attempt timed out"))
  {
    uint64_t v5 = _Block_copy(*((const void **)v1 + 8));
    int v6 = 1;
    uint64_t v7 = (nw_connection *)*((void *)v1 + 2);
    if (!v7) {
      goto LABEL_9;
    }
LABEL_12:
    nw_connection_cancel(v7);
    goto LABEL_13;
  }

  uint64_t v5 = 0LL;
  int v6 = 0;
  uint64_t v7 = (nw_connection *)*((void *)v1 + 2);
  if (v7) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v8 = (dispatch_source_s *)*((void *)v1 + 10);
  if (v8)
  {
    dispatch_source_cancel(v8);
    int v9 = (void *)*((void *)v1 + 10);
    *((void *)v1 + 10) = 0LL;
  }

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke(uint64_t a1)
{
}

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_2(uint64_t a1)
{
}

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_3(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = (char *)*(id *)(a1 + 32);
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v4 = (os_unfair_lock_s *)(v3 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 30);
  char v5 = v3[158];
  if ((v5 & 0x20) != 0 || (a2 & 1) == 0)
  {
    if (a2) {
      char v6 = 0;
    }
    else {
      char v6 = 32;
    }
    v3[158] = v5 & 0xDF | v6;
    if (((((v5 & 0x20) == 0) ^ a2) & 1) == 0 && v3[156] != 255)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *((void *)v3 + 12);
        *(_DWORD *)buf = 136446466;
        __int16 v18 = "tcp_connection_send_viability_event_unlocked";
        __int16 v19 = 2048;
        uint64_t v20 = v8;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %llu notifying of connection non-viability event again",  buf,  0x16u);
      }
    }

    int v9 = a2 ? "viable" : "no longer viable";
    if (tcp_connection_fillout_event_locked(v3, (uint64_t)&v15, 6, 0LL, 0LL, (uint64_t)v9))
    {
      BOOL v10 = _Block_copy(*((const void **)v3 + 8));
      os_unfair_lock_unlock(v4);
      id v11 = v3;
      id v12 = v10;
      uint64_t v13 = v12;
      if (!v12 || v11[156] == 255)
      {
        BOOL v14 = v15;
        if (!v15)
        {
LABEL_22:

          goto LABEL_23;
        }
      }

      else
      {
        BOOL v14 = v15;
        (*((void (**)(id, void, void *))v12 + 2))(v12, v16, v15);
        if (!v14) {
          goto LABEL_22;
        }
      }

      free(v14);
      goto LABEL_22;
    }
  }

  os_unfair_lock_unlock(v4);
LABEL_23:
}

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_4(uint64_t a1, int a2)
{
  __int16 v18 = (char *)*(id *)(a1 + 32);
  __int16 v19 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v20 = 0LL;
  id v3 = (os_unfair_lock_s *)(v18 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)v18 + 30);
  uint64_t v4 = v18;
  char v5 = v18[158];
  if (((v5 & 0x10) == 0) != a2)
  {
    os_unfair_lock_unlock(v3);
    char v6 = 0LL;
    goto LABEL_27;
  }

  if (a2) {
    char v7 = 16;
  }
  else {
    char v7 = 0;
  }
  v18[158] = v5 & 0xEF | v7;
  if (a2)
  {
    uint64_t v8 = "better route";
    BOOL v9 = tcp_connection_fillout_event_locked(v18, (uint64_t)&v21, 5, 0LL, 0LL, (uint64_t)"better route");
    uint64_t v4 = v18;
  }

  else
  {
    BOOL v9 = 0;
    uint64_t v8 = "no better route";
  }

  BOOL v10 = tcp_connection_fillout_event_locked(v4, (uint64_t)&v19, 1073741831, 0LL, 0LL, (uint64_t)v8);
  BOOL v11 = v10;
  if (!v9 && !v10)
  {
    os_unfair_lock_unlock(v3);
    char v6 = 0LL;
    goto LABEL_20;
  }

  char v6 = _Block_copy(*((const void **)v18 + 8));
  os_unfair_lock_unlock(v3);
  if (!v9)
  {
LABEL_20:
    if (!v11) {
      goto LABEL_27;
    }
    goto LABEL_21;
  }

  id v12 = v18;
  id v13 = v6;
  char v6 = v13;
  BOOL v14 = v21;
  if (v13 && v12[156] != 255) {
    (*((void (**)(id, void, void *))v13 + 2))(v13, v22, v21);
  }
  if (v14) {
    free(v14);
  }

  if (v11)
  {
LABEL_21:
    uint64_t v15 = v18;
    id v16 = v6;
    char v6 = v16;
    unint64_t v17 = v19;
    if (v16 && v15[156] != 255) {
      (*((void (**)(id, void, void *))v16 + 2))(v16, v20, v19);
    }
    if (v17) {
      free(v17);
    }
  }

void tcp_connection_cancel(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  id v3 = v2;
  if (!v1)
  {
    *(_DWORD *)buf = 136446210;
    int v32 = "tcp_connection_cancel";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v9, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        int v32 = "tcp_connection_cancel";
        id v12 = "%{public}s called with null connection";
LABEL_35:
        BOOL v25 = v10;
        os_log_type_t v26 = v11;
        goto LABEL_36;
      }

      if (!v29)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        int v32 = "tcp_connection_cancel";
        id v12 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v24)
        {
LABEL_37:

          if (!v9) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }

        *(_DWORD *)buf = 136446210;
        int v32 = "tcp_connection_cancel";
        id v12 = "%{public}s called with null connection, no backtrace";
        BOOL v25 = v10;
        os_log_type_t v26 = v23;
LABEL_36:
        _os_log_impl(&dword_181A5C000, v25, v26, v12, buf, 0xCu);
        goto LABEL_37;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        int v32 = "tcp_connection_cancel";
        __int16 v33 = 2082;
        __int16 v34 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v23,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v9) {
      goto LABEL_32;
    }
LABEL_31:
    free(v9);
    goto LABEL_32;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = (char *)*((void *)v1 + 12);
    *(_DWORD *)buf = 136446466;
    int v32 = "tcp_connection_cancel";
    __int16 v33 = 2048;
    __int16 v34 = v4;
    _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %llu", buf, 0x16u);
  }

  os_unfair_lock_lock((os_unfair_lock_t)v1 + 30);
  if (v1[156] == 255) {
    goto LABEL_24;
  }
  v1[156] = -1;
  char v5 = (const void *)*((void *)v1 + 9);
  if (v5 && *((void *)v1 + 7))
  {
    char v6 = _Block_copy(v5);
    char v7 = (dispatch_queue_s *)*((id *)v1 + 7);
    uint64_t v8 = (nw_connection *)*((void *)v1 + 2);
    if (!v8) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  char v6 = 0LL;
  char v7 = 0LL;
  uint64_t v8 = (nw_connection *)*((void *)v1 + 2);
  if (v8) {
LABEL_14:
  }
    nw_connection_cancel(v8);
LABEL_15:
  id v13 = v1;
  v13[158] |= 0x30u;
  BOOL v14 = (dispatch_source_s *)*((void *)v13 + 10);
  if (v14)
  {
    dispatch_source_cancel(v14);
    uint64_t v15 = (void *)*((void *)v13 + 10);
    *((void *)v13 + 10) = 0LL;
  }

  id v16 = (void *)*((void *)v13 + 11);
  *((void *)v13 + 11) = 0LL;

  int v17 = *((_DWORD *)v13 + 29);
  if (v17 != -1)
  {
    unsigned __int8 v18 = v13[159];
    if ((v18 & 8) == 0)
    {
      close(v17);
      unsigned __int8 v18 = v13[159];
    }

    *((_DWORD *)v13 + 29) = -1;
    v13[159] = v18 & 0xF7;
  }

  __int16 v19 = (void *)*((void *)v13 + 7);
  *((void *)v13 + 7) = 0LL;

  uint64_t v20 = (void *)*((void *)v13 + 8);
  *((void *)v13 + 8) = 0LL;

  uint64_t v21 = (void *)*((void *)v1 + 9);
  *((void *)v1 + 9) = 0LL;

  if (v6)
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __tcp_connection_cancel_block_invoke;
    block[3] = &unk_189BC8740;
    id v28 = v6;
    dispatch_async(v7, block);
  }

LABEL_24:
  os_unfair_lock_unlock((os_unfair_lock_t)v1 + 30);
LABEL_32:
}

uint64_t __tcp_connection_cancel_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t tcp_connection_get_local(void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "tcp_connection_get_local";
    id v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "tcp_connection_get_local";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v34 = "tcp_connection_get_local";
          __int16 v35 = 2082;
          char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v21,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v16) {
          goto LABEL_35;
        }
        goto LABEL_34;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "tcp_connection_get_local";
        _os_log_impl(&dword_181A5C000, v17, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "tcp_connection_get_local";
        _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_32;
  }

  if (!v3[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "tcp_connection_get_local";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_35;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "tcp_connection_get_local";
    id v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v16, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "tcp_connection_get_local";
          _os_log_impl(&dword_181A5C000, v17, v26, "%{public}s called with null outlocal", buf, 0xCu);
        }

void sub_1820861E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t tcp_connection_get_remote(void *a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "tcp_connection_get_remote";
    id v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v34 = "tcp_connection_get_remote";
          __int16 v35 = 2082;
          char v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v21,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v16) {
          goto LABEL_35;
        }
        goto LABEL_34;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_181A5C000, v17, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "tcp_connection_get_remote";
        _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_32;
  }

  if (!v3[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v34 = "tcp_connection_get_remote";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_35;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "tcp_connection_get_remote";
    id v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v16, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_181A5C000, v17, v26, "%{public}s called with null outremote", buf, 0xCu);
        }

void sub_182086858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void tcp_connection_read(void *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a4;
  BOOL v9 = v8;
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v31 = "tcp_connection_read";
    id v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "tcp_connection_read";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null connection", buf, 0xCu);
      }

      goto LABEL_24;
    }

    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "tcp_connection_read";
        _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_24;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v13 = (os_log_s *)(id)gLogObj;
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "tcp_connection_read";
        _os_log_impl(&dword_181A5C000, v13, v17, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }

      goto LABEL_24;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      char v31 = "tcp_connection_read";
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v17,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_17;
  }

  BOOL v10 = (void *)v7[2];
  if (v10)
  {
    if (v8)
    {
      v25[0] = MEMORY[0x1895F87A8];
      v25[1] = 3221225472LL;
      v25[2] = __tcp_connection_read_block_invoke;
      v25[3] = &unk_189BC5F58;
      os_log_type_t v26 = v7;
      id v27 = v9;
      nw_connection_receive_internal(v10, 0LL, a2, a3, v25);

      goto LABEL_27;
    }

    __nwlog_obj();
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v31 = "tcp_connection_read";
    id v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "tcp_connection_read";
        _os_log_impl(&dword_181A5C000, v13, v21, "%{public}s called with null handler", buf, 0xCu);
      }

void __tcp_connection_read_block_invoke(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v11 = a2;
  id v8 = a3;
  id v9 = a5;
  BOOL v10 = v9;
  if (*(unsigned __int8 *)(*(void *)(a1 + 32) + 156LL) != 255)
  {
    if (v9) {

    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  }
}

void tcp_connection_read_buffer(void *a1, char *a2, unint64_t a3, unint64_t a4, void *a5)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v9 = a1;
  id v10 = a5;
  id v11 = v10;
  if (!v9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v13 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v36 = "tcp_connection_read_buffer";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v36 = "tcp_connection_read_buffer";
      os_log_type_t v17 = "%{public}s called with null connection";
    }

    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (os_log_s *)(id)gLogObj;
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            char v36 = "tcp_connection_read_buffer";
            __int16 v37 = 2082;
            int v38 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v14) {
            goto LABEL_19;
          }
LABEL_18:
          free(v14);
          goto LABEL_19;
        }

        if (!v21)
        {
LABEL_24:

          if (!v14) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446210;
        char v36 = "tcp_connection_read_buffer";
        os_log_type_t v17 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v22 = v15;
        os_log_type_t v23 = v20;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v22, v23, v17, buf, 0xCu);
        goto LABEL_24;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v36 = "tcp_connection_read_buffer";
      os_log_type_t v17 = "%{public}s called with null connection, backtrace limit exceeded";
    }

    os_log_type_t v22 = v15;
    os_log_type_t v23 = v16;
    goto LABEL_23;
  }

  id v12 = (void *)v9[2];
  if (v12)
  {
    if (v10)
    {
      v30[0] = MEMORY[0x1895F87A8];
      v30[1] = 3221225472LL;
      v30[2] = __tcp_connection_read_buffer_block_invoke;
      v30[3] = &unk_189BBBD50;
      char v31 = v9;
      id v32 = v11;
      nw_connection_read_buffer(v12, a2, a3, a4, v30);

      goto LABEL_19;
    }

    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v36 = "tcp_connection_read_buffer";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        char v36 = "tcp_connection_read_buffer";
        id v27 = "%{public}s called with null handler";
LABEL_42:
        _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
        goto LABEL_43;
      }

      goto LABEL_43;
    }

    if (!v33)
    {
      __nwlog_obj();
      BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        char v36 = "tcp_connection_read_buffer";
        id v27 = "%{public}s called with null handler, backtrace limit exceeded";
        goto LABEL_42;
      }

uint64_t __tcp_connection_read_buffer_block_invoke(uint64_t result)
{
  return result;
}

void tcp_connection_write(void *a1, void *a2, void *a3)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  char v6 = a2;
  id v7 = a3;
  id v8 = v7;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v33 = "tcp_connection_write";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v33 = "tcp_connection_write";
      os_log_type_t v14 = "%{public}s called with null connection";
    }

    else
    {
      if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            char v33 = "tcp_connection_write";
            __int16 v34 = 2082;
            __int16 v35 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v11) {
            goto LABEL_19;
          }
LABEL_18:
          free(v11);
          goto LABEL_19;
        }

        if (!v18)
        {
LABEL_24:

          if (!v11) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446210;
        char v33 = "tcp_connection_write";
        os_log_type_t v14 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v19 = v12;
        os_log_type_t v20 = v17;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v19, v20, v14, buf, 0xCu);
        goto LABEL_24;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      char v33 = "tcp_connection_write";
      os_log_type_t v14 = "%{public}s called with null connection, backtrace limit exceeded";
    }

    os_log_type_t v19 = v12;
    os_log_type_t v20 = v13;
    goto LABEL_23;
  }

  id v9 = (nw_connection *)v5[2];
  if (v9)
  {
    if (v7)
    {
      completion[0] = MEMORY[0x1895F87A8];
      completion[1] = 3221225472LL;
      completion[2] = __tcp_connection_write_block_invoke;
      completion[3] = &unk_189BBF170;
      char v28 = v5;
      id v29 = v8;
      nw_connection_send(v9, v6, (nw_content_context_t)&__block_literal_global_41831, 1, completion);

      goto LABEL_19;
    }

    __nwlog_obj();
    BOOL v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v33 = "tcp_connection_write";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        char v33 = "tcp_connection_write";
        os_log_type_t v24 = "%{public}s called with null handler";
LABEL_42:
        _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
        goto LABEL_43;
      }

      goto LABEL_43;
    }

    if (!v30)
    {
      __nwlog_obj();
      os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        char v33 = "tcp_connection_write";
        os_log_type_t v24 = "%{public}s called with null handler, backtrace limit exceeded";
        goto LABEL_42;
      }

void __tcp_connection_write_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned __int8 *)(*(void *)(a1 + 32) + 156LL) != 255)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    id v7 = v3;
    if (v3)
    {
      id v5 = (unsigned int *)v3;
      uint64_t v6 = v5[3];
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    (*(void (**)(uint64_t, uint64_t))(v4 + 16))(v4, v6);
    id v3 = v7;
  }
}

void tcp_connection_write_buffer(void *a1, const void *a2, size_t a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a4;
  id v9 = (void (**)(void, void))v8;
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v30 = "tcp_connection_write_buffer";
    id v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      char v30 = "tcp_connection_write_buffer";
      id v15 = "%{public}s called with null connection";
    }

    else
    {
      if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            char v30 = "tcp_connection_write_buffer";
            __int16 v31 = 2082;
            id v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v17,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v12) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }

        if (!v18) {
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        char v30 = "tcp_connection_write_buffer";
        id v15 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v19 = v13;
        os_log_type_t v20 = v17;
        goto LABEL_24;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      char v30 = "tcp_connection_write_buffer";
      id v15 = "%{public}s called with null connection, backtrace limit exceeded";
    }

    os_log_type_t v19 = v13;
    os_log_type_t v20 = v14;
LABEL_24:
    _os_log_impl(&dword_181A5C000, v19, v20, v15, buf, 0xCu);
LABEL_25:

    if (!v12) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  if (!v7[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      char v30 = "tcp_connection_write_buffer";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  if (v8)
  {
    id v10 = (os_log_s *)dispatch_data_create(a2, a3, 0LL, 0LL);
    if (v10) {
      tcp_connection_write(v7, v10, v9);
    }
    else {
      v9[2](v9, 12LL);
    }
LABEL_20:

    goto LABEL_27;
  }

  __nwlog_obj();
  BOOL v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v30 = "tcp_connection_write_buffer";
  id v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v22, type))
    {
      *(_DWORD *)buf = 136446210;
      char v30 = "tcp_connection_write_buffer";
      os_log_type_t v24 = "%{public}s called with null handler";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
      goto LABEL_45;
    }

    goto LABEL_45;
  }

  if (!v27)
  {
    __nwlog_obj();
    os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v22, type))
    {
      *(_DWORD *)buf = 136446210;
      char v30 = "tcp_connection_write_buffer";
      os_log_type_t v24 = "%{public}s called with null handler, backtrace limit exceeded";
      goto LABEL_44;
    }

void tcp_connection_write_eof(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    BOOL v18 = "tcp_connection_write_eof";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "tcp_connection_write_eof";
        id v8 = "%{public}s called with null connection";
LABEL_21:
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_22;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "tcp_connection_write_eof";
        id v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v5) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        BOOL v18 = "tcp_connection_write_eof";
        id v8 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v13 = v6;
        os_log_type_t v14 = v11;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v18 = "tcp_connection_write_eof";
        __int16 v19 = 2082;
        os_log_type_t v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5) {
      goto LABEL_18;
    }
LABEL_17:
    free(v5);
    goto LABEL_18;
  }

  id v3 = v1[2];
  if (v3)
  {
    nw_connection_send(v3, 0LL, (nw_content_context_t)&__block_literal_global_3_41839, 1, &__block_literal_global_24170);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "tcp_connection_write_eof";
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }
  }

uint64_t tcp_connection_get_unsent_length(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_get_unsent_length";
    id v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, type, &v18))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_get_unsent_length";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type[0];
        BOOL v15 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_connection_get_unsent_length";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v9) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_get_unsent_length";
          _os_log_impl(&dword_181A5C000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v16 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_get_unsent_length";
          _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9)
    {
LABEL_26:
      uint64_t v7 = 0LL;
      goto LABEL_27;
    }

void tcp_connection_accept(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "tcp_connection_accept";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v26 = "tcp_connection_accept";
      id v10 = "%{public}s called with null connection";
    }

    else
    {
      if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v26 = "tcp_connection_accept";
            __int16 v27 = 2082;
            char v28 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v7) {
            goto LABEL_19;
          }
LABEL_18:
          free(v7);
          goto LABEL_19;
        }

        if (!v14)
        {
LABEL_24:

          if (!v7) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446210;
        BOOL v26 = "tcp_connection_accept";
        id v10 = "%{public}s called with null connection, no backtrace";
        BOOL v15 = v8;
        os_log_type_t v16 = v13;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v15, v16, v10, buf, 0xCu);
        goto LABEL_24;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v26 = "tcp_connection_accept";
      id v10 = "%{public}s called with null connection, backtrace limit exceeded";
    }

    BOOL v15 = v8;
    os_log_type_t v16 = v9;
    goto LABEL_23;
  }

  if (v4)
  {
    if (v3[157] == 4)
    {
      tcp_connection_set_queue(v3, v4);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "tcp_connection_accept";
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s Connection is not applicable for accept",  buf,  0xCu);
      }
    }

    goto LABEL_19;
  }

  __nwlog_obj();
  os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v26 = "tcp_connection_accept";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    char v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v26 = "tcp_connection_accept";
      os_log_type_t v20 = "%{public}s called with null queue";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
      goto LABEL_43;
    }

    goto LABEL_43;
  }

  if (!v23)
  {
    __nwlog_obj();
    char v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v26 = "tcp_connection_accept";
      os_log_type_t v20 = "%{public}s called with null queue, backtrace limit exceeded";
      goto LABEL_42;
    }

BOOL tcp_connection_is_cellular(void *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v23 = "tcp_connection_is_cellular";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "tcp_connection_is_cellular";
        os_log_type_t v11 = "%{public}s called with null connection";
LABEL_27:
        char v18 = v9;
        os_log_type_t v19 = v10;
        goto LABEL_28;
      }

      if (!v20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "tcp_connection_is_cellular";
        os_log_type_t v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_27;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_29:

          if (!v8) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446210;
        char v23 = "tcp_connection_is_cellular";
        os_log_type_t v11 = "%{public}s called with null connection, no backtrace";
        char v18 = v9;
        os_log_type_t v19 = v14;
LABEL_28:
        _os_log_impl(&dword_181A5C000, v18, v19, v11, buf, 0xCu);
        goto LABEL_29;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        char v23 = "tcp_connection_is_cellular";
        __int16 v24 = 2082;
        BOOL v25 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8)
    {
LABEL_19:
      BOOL v6 = 0LL;
      goto LABEL_24;
    }

BOOL tcp_connection_is_expensive(void *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v23 = "tcp_connection_is_expensive";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "tcp_connection_is_expensive";
        os_log_type_t v11 = "%{public}s called with null connection";
LABEL_27:
        char v18 = v9;
        os_log_type_t v19 = v10;
        goto LABEL_28;
      }

      if (!v20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446210;
        char v23 = "tcp_connection_is_expensive";
        os_log_type_t v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_27;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_29:

          if (!v8) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446210;
        char v23 = "tcp_connection_is_expensive";
        os_log_type_t v11 = "%{public}s called with null connection, no backtrace";
        char v18 = v9;
        os_log_type_t v19 = v14;
LABEL_28:
        _os_log_impl(&dword_181A5C000, v18, v19, v11, buf, 0xCu);
        goto LABEL_29;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        char v23 = "tcp_connection_is_expensive";
        __int16 v24 = 2082;
        BOOL v25 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v8)
    {
LABEL_19:
      BOOL is_expensive = 0LL;
      goto LABEL_24;
    }

char *tcp_connection_copy_description(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "tcp_connection_copy_description";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "tcp_connection_copy_description";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v19 = "tcp_connection_copy_description";
            __int16 v20 = 2082;
            uint64_t v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v7) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "tcp_connection_copy_description";
          _os_log_impl(&dword_181A5C000, v8, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "tcp_connection_copy_description";
          _os_log_impl( &dword_181A5C000,  v8,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v7)
    {
LABEL_26:
      id v5 = 0LL;
      goto LABEL_27;
    }

void sub_1820897EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void tcp_connection_get_counts(void *a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_connection_get_counts";
    os_log_type_t v9 = (void *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v33[0] = 0;
    if (__nwlog_fault((const char *)v9, type, v33))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_get_counts";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v33[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type[0];
        BOOL v15 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_connection_get_counts";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v9) {
            goto LABEL_28;
          }
LABEL_13:
          free(v9);
          goto LABEL_28;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_get_counts";
          _os_log_impl(&dword_181A5C000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_connection_get_counts";
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9) {
      goto LABEL_28;
    }
    goto LABEL_13;
  }

  if (v3[2])
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x1B810000000LL;
    int v38 = &unk_18296448D;
    *(void *)os_log_type_t type = 0LL;
    char v30 = type;
    uint64_t v31 = 0x2020000000LL;
    char v32 = 0;
    if (a2)
    {
      *(_OWORD *)(a2 + 80) = 0u;
      *(_OWORD *)(a2 + 96) = 0u;
      *(_OWORD *)(a2 + 48) = 0u;
      *(_OWORD *)(a2 + 64) = 0u;
      *(_OWORD *)(a2 + 16) = 0u;
      *(_OWORD *)(a2 + 32) = 0u;
      *(_OWORD *)a2 = 0u;
      id v5 = nw_connection_copy_tcp_info(v3[2]);
      id v6 = v5;
      if (v5)
      {
        applier[0] = MEMORY[0x1895F87A8];
        applier[1] = 3221225472LL;
        applier[2] = __tcp_connection_get_counts_block_invoke;
        applier[3] = &unk_189BBBD78;
        void applier[4] = buf;
        applier[5] = type;
        xpc_dictionary_apply(v5, applier);
        if (*((_BYTE *)v30 + 24))
        {
          id v7 = *(void **)&buf[8];
          *(void *)(a2 + 8) = *(void *)(*(void *)&buf[8] + 140LL);
          *(void *)(a2 + 24) = *(void *)((char *)v7 + 108);
          *(_DWORD *)(a2 + 80) = *(void *)((char *)v7 + 148);
          *(_DWORD *)(a2 + 88) = *(void *)((char *)v7 + 116);
          *(void *)(a2 + 92) = 0x100000001LL;
          *(void *)(a2 + 104) = v7[7];
          *(void *)(a2 + 48) = v7[27];
          *(void *)(a2 + 56) = v7[29];
          *(void *)(a2 + 32) = v7[23];
          *(void *)(a2 + 40) = v7[25];
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v33 = 136446210;
          __int16 v34 = "tcp_connection_get_counts";
          _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_ERROR, "%{public}s Could not retreive TCP info", v33, 0xCu);
        }
      }

LABEL_27:
      _Block_object_dispose(type, 8);
      _Block_object_dispose(buf, 8);
      goto LABEL_28;
    }

    __nwlog_obj();
    char v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uint64_t v33 = 136446210;
    __int16 v34 = "tcp_connection_get_counts";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v28 = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v19, &v28, &v27))
    {
      if (v28 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = v28;
        if (os_log_type_enabled(v20, v28))
        {
          *(_DWORD *)uint64_t v33 = 136446210;
          __int16 v34 = "tcp_connection_get_counts";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null counts", v33, 0xCu);
        }
      }

      else if (v27)
      {
        uint64_t v22 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = v28;
        BOOL v24 = os_log_type_enabled(v20, v28);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)uint64_t v33 = 136446466;
            __int16 v34 = "tcp_connection_get_counts";
            __int16 v35 = 2082;
            uint64_t v36 = v22;
            _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s called with null counts, dumping backtrace:%{public}s",  v33,  0x16u);
          }

          free(v22);
          goto LABEL_51;
        }

        if (v24)
        {
          *(_DWORD *)uint64_t v33 = 136446210;
          __int16 v34 = "tcp_connection_get_counts";
          _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null counts, no backtrace", v33, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = v28;
        if (os_log_type_enabled(v20, v28))
        {
          *(_DWORD *)uint64_t v33 = 136446210;
          __int16 v34 = "tcp_connection_get_counts";
          _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null counts, backtrace limit exceeded",  v33,  0xCu);
        }
      }
    }

void sub_182089F08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

uint64_t __tcp_connection_get_counts_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F9240] && xpc_data_get_length(v4) == 408 && xpc_data_get_bytes_ptr(v4))
  {
    id v5 = (void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 32LL);
    bytes_ptr = xpc_data_get_bytes_ptr(v4);
    memcpy(v5, bytes_ptr, 0x198uLL);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136446210;
      os_log_type_t v10 = "tcp_connection_get_counts_block_invoke";
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s TCP info has invalid data",  (uint8_t *)&v9,  0xCu);
    }
  }

  return 0LL;
}

void tcp_connection_retry(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v18 = "tcp_connection_retry";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v18 = "tcp_connection_retry";
        id v8 = "%{public}s called with null connection";
LABEL_21:
        BOOL v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_22;
      }

      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        char v18 = "tcp_connection_retry";
        id v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v5) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }

        *(_DWORD *)buf = 136446210;
        char v18 = "tcp_connection_retry";
        id v8 = "%{public}s called with null connection, no backtrace";
        BOOL v13 = v6;
        os_log_type_t v14 = v11;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        char v18 = "tcp_connection_retry";
        __int16 v19 = 2082;
        __int16 v20 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5) {
      goto LABEL_18;
    }
LABEL_17:
    free(v5);
    goto LABEL_18;
  }

  id v3 = v1[2];
  if (v3)
  {
    nw_connection_restart(v3);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v9 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      char v18 = "tcp_connection_retry";
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }
  }

void tcp_connection_set_connection_attempt_timeout(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)(a1 + 104) = a2;
    *(_BYTE *)(a1 + 158) |= 0x40u;
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  char v15 = "tcp_connection_set_connection_attempt_timeout";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_connection_attempt_timeout";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_connection_attempt_timeout";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      char v15 = "tcp_connection_set_connection_attempt_timeout";
      __int16 v16 = 2082;
      os_log_type_t v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_connection_attempt_timeout";
    id v6 = "%{public}s called with null connection, no backtrace";
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_tfo(uint64_t a1, BOOL a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_tfo(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  char v15 = "tcp_connection_set_tfo";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_tfo";
    id v6 = "%{public}s called with null connection";
LABEL_17:
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_tfo";
    id v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      char v15 = "tcp_connection_set_tfo";
      __int16 v16 = 2082;
      os_log_type_t v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_tfo";
    id v6 = "%{public}s called with null connection, no backtrace";
    os_log_type_t v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_extended_background_idle(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (os_log_s *)(id)gLogObj;
  id v3 = v2;
  if (!a1)
  {
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "tcp_connection_set_extended_background_idle";
    id v4 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = (os_log_s *)(id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "tcp_connection_set_extended_background_idle";
        os_log_type_t v7 = "%{public}s called with null connection";
LABEL_19:
        os_log_type_t v11 = v5;
        os_log_type_t v12 = v6;
        goto LABEL_20;
      }

      if (!v13)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = (os_log_s *)(id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "tcp_connection_set_extended_background_idle";
        os_log_type_t v7 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_19;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (!v10)
        {
LABEL_21:

          if (!v4) {
            return;
          }
LABEL_15:
          free(v4);
          return;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v16 = "tcp_connection_set_extended_background_idle";
        os_log_type_t v7 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v11 = v5;
        os_log_type_t v12 = v9;
LABEL_20:
        _os_log_impl(&dword_181A5C000, v11, v12, v7, buf, 0xCu);
        goto LABEL_21;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v16 = "tcp_connection_set_extended_background_idle";
        __int16 v17 = 2082;
        uint64_t v18 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v9,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v4) {
      return;
    }
    goto LABEL_15;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "tcp_connection_set_extended_background_idle";
    _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s Extended background idle not supported",  buf,  0xCu);
  }
}

void tcp_connection_set_receive_any_interface(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_parameters_set_receive_any_interface(*(void **)(a1 + 48), a2);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  char v15 = "tcp_connection_set_receive_any_interface";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3) {
      return;
    }
    goto LABEL_13;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_receive_any_interface";
    os_log_type_t v6 = "%{public}s called with null connection";
LABEL_17:
    BOOL v10 = v4;
    os_log_type_t v11 = v5;
LABEL_18:
    _os_log_impl(&dword_181A5C000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)(id)gLogObj;
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_receive_any_interface";
    os_log_type_t v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  BOOL v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      char v15 = "tcp_connection_set_receive_any_interface";
      __int16 v16 = 2082;
      __int16 v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v8,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    char v15 = "tcp_connection_set_receive_any_interface";
    os_log_type_t v6 = "%{public}s called with null connection, no backtrace";
    BOOL v10 = v4;
    os_log_type_t v11 = v8;
    goto LABEL_18;
  }

void tcp_connection_set_ecn_enabled(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "tcp_connection_set_ecn_enabled";
    os_log_type_t v5 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault((const char *)v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "tcp_connection_set_ecn_enabled";
        os_log_type_t v8 = "%{public}s called with null connection";
LABEL_20:
        char v12 = v6;
        os_log_type_t v13 = v7;
        goto LABEL_21;
      }

      if (!v14)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "tcp_connection_set_ecn_enabled";
        os_log_type_t v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_22:

          if (!v5) {
            return;
          }
LABEL_16:
          free(v5);
          return;
        }

        *(_DWORD *)buf = 136446210;
        __int16 v17 = "tcp_connection_set_ecn_enabled";
        os_log_type_t v8 = "%{public}s called with null connection, no backtrace";
        char v12 = v6;
        os_log_type_t v13 = v10;
LABEL_21:
        _os_log_impl(&dword_181A5C000, v12, v13, v8, buf, 0xCu);
        goto LABEL_22;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v17 = "tcp_connection_set_ecn_enabled";
        __int16 v18 = 2082;
        uint64_t v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5) {
      return;
    }
    goto LABEL_16;
  }

  id v2 = *(void **)(a1 + 48);
  if (a2) {
    unsigned int v3 = 1;
  }
  else {
    unsigned int v3 = 2;
  }
  nw_parameters_set_ecn_mode(v2, v3);
}

uint64_t tcp_connection_get_statistics(void *a1, uint64_t a2, int *a3)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  id v4 = a1;
  os_log_type_t v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v17 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v39 = "tcp_connection_get_statistics";
    __int16 v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "tcp_connection_get_statistics";
      uint64_t v21 = "%{public}s called with null connection";
    }

    else
    {
      if (v36)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v19 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v39 = "tcp_connection_get_statistics";
            __int16 v40 = 2082;
            *(void *)uint64_t v41 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          uint64_t v26 = (char *)backtrace_string;
          goto LABEL_23;
        }

        if (!v25)
        {
LABEL_32:

          if (!v18) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v39 = "tcp_connection_get_statistics";
        uint64_t v21 = "%{public}s called with null connection, no backtrace";
        os_log_type_t v28 = v19;
        os_log_type_t v29 = v24;
LABEL_31:
        _os_log_impl(&dword_181A5C000, v28, v29, v21, buf, 0xCu);
        goto LABEL_32;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "tcp_connection_get_statistics";
      uint64_t v21 = "%{public}s called with null connection, backtrace limit exceeded";
    }

    os_log_type_t v28 = v19;
    os_log_type_t v29 = v20;
    goto LABEL_31;
  }

  os_log_type_t v6 = (void *)*((void *)v4 + 2);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "tcp_connection_get_statistics";
      uint64_t v22 = "%{public}s API Misuse: Function must be called after tcp_connection_start";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
    }

void tcp_connection_log_event(void *a1, char *a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  os_log_type_t v5 = a1;
  id v6 = a3;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "tcp_connection_log_event";
    int v10 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault((const char *)v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "tcp_connection_log_event";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v22 = "tcp_connection_log_event";
            __int16 v23 = 2082;
            os_log_type_t v24 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v10) {
            goto LABEL_27;
          }
LABEL_12:
          free(v10);
          goto LABEL_27;
        }

        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "tcp_connection_log_event";
          _os_log_impl(&dword_181A5C000, v11, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "tcp_connection_log_event";
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v10) {
      goto LABEL_27;
    }
    goto LABEL_12;
  }

  BOOL v7 = (void *)v5[2];
  if (v7)
  {
    if (a2 == (char *)1)
    {
      int v8 = 2;
      goto LABEL_23;
    }

    if (!a2)
    {
      int v8 = 1;
LABEL_23:
      nw_connection_add_client_event_internal(v7, v8, v6, 0LL);
      goto LABEL_27;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "tcp_connection_log_event";
      __int16 v23 = 2048;
      os_log_type_t v24 = a2;
      _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, "%{public}s Invalid log event %lld", buf, 0x16u);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v13 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "tcp_connection_log_event";
      _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }
  }

void __nw_write_request_create_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 22);
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_18208E6A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_32860()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

NWConcrete_nw_write_request *nw_write_request_create_idempotent(void *a1, void *a2, void *a3, int a4)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a2;
  int v47 = v8;
  id v48 = a3;
  if (!v8)
  {
    __nwlog_obj();
    char v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v52 = "nw_write_request_create_idempotent";
    uint64_t v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        id v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_181A5C000, v34, v37, "%{public}s called with null context", buf, 0xCu);
      }

      goto LABEL_100;
    }

    if (!v49)
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        id v52 = "nw_write_request_create_idempotent";
        _os_log_impl( &dword_181A5C000,  v34,  v44,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_100;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v41 = type;
    BOOL v42 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        id v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_181A5C000, v34, v41, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }

      goto LABEL_100;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      id v52 = "nw_write_request_create_idempotent";
      __int16 v53 = 2082;
      nw_protocol_definition_t v54 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v34,  v41,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_82;
  }

  if (!v7
    && (a4 & 1) == 0
    && (v8 == &__block_literal_global_3_41839
     || v8 == &__block_literal_global_41831
     || v8 == &__block_literal_global_4
     || v8 == &__block_literal_global_5_41854))
  {
    __nwlog_obj();
    os_log_type_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v52 = "nw_write_request_create_idempotent";
    uint64_t v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        id v52 = "nw_write_request_create_idempotent";
        _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s Send content may only be nil if the request is marked as complete",  buf,  0xCu);
      }

void sub_18208F0C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_write_request *nw_write_request_create_clone(void *a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if (((_BYTE)v1[16] & 4) != 0)
  {
    id v6 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_write_request);
    id v7 = v6;
    if (v6)
    {
      p_data = (dispatch_data_t *)&v6->data;
      objc_storeStrong((id *)&v6->data, v1[7]);
      objc_storeStrong((id *)&v7->context, v1[8]);
      char v9 = (_BYTE)v1[16] & 1 | *((_BYTE *)v7 + 128) & 0xFE | 4;
      *((_BYTE *)v7 + 128) = v9;
      *(void *)&v7->relative_priority = v1[15];
      *((_BYTE *)v7 + 128) = (_BYTE)v1[16] & 8 | v9 & 0xF7;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_32859);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled())
      {
        if (*p_data) {
          dispatch_data_get_size(*p_data);
        }
        CFRunLoopTimerContext context = v7->context;
        if (context) {
          nw_content_context_get_is_final(context);
        }
        kdebug_trace();
      }

      int v10 = v7;
      goto LABEL_47;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_write_request_create_clone";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v15, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v28 = "nw_write_request_create_clone";
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed",  buf,  0xCu);
        }
      }

      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v28 = "nw_write_request_create_clone";
            __int16 v29 = 2082;
            os_log_type_t v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v16,  v20,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v15) {
            goto LABEL_47;
          }
          goto LABEL_46;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v28 = "nw_write_request_create_clone";
          _os_log_impl( &dword_181A5C000,  v16,  v20,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v28 = "nw_write_request_create_clone";
          _os_log_impl( &dword_181A5C000,  v16,  v22,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v15)
    {
LABEL_47:

      goto LABEL_48;
    }

void sub_18208F764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_write_request_create_with_file_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 22);
  (*(void (**)(uint64_t, void, void))(v1 + 16))(v1, 0LL, 0LL);
}

void sub_18208F7E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

size_t nw_write_request_remaining_bytes(void *a1)
{
  uint64_t v1 = a1;
  id v2 = (dispatch_data_s *)v1[7];
  uint64_t v3 = v1[9];
  if (!v2)
  {
    if (!v3)
    {
      size_t v6 = 0LL;
      goto LABEL_9;
    }

    goto LABEL_5;
  }

  if (v3)
  {
LABEL_5:
    size_t size = v1[12];
    goto LABEL_6;
  }

  size_t size = dispatch_data_get_size(v2);
LABEL_6:
  size_t v5 = v1[14];
  if (size <= v5) {
    size_t v5 = 0LL;
  }
  size_t v6 = size - v5;
LABEL_9:

  return v6;
}

void ___ZL35nw_write_request_start_file_updatesP27NWConcrete_nw_write_request_block_invoke(uint64_t a1)
{
  WeakRetained = (const void **)objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v3 = _Block_copy(WeakRetained[4]);
    id v4 = v3;
    if (v3)
    {
      size_t v5 = (void *)v2[5];
      dispatch_qos_class_t v6 = *((_DWORD *)v2 + 12);
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      v7[2] = ___ZL35nw_write_request_start_file_updatesP27NWConcrete_nw_write_request_block_invoke_2;
      v7[3] = &unk_189BC91E8;
      id v9 = v3;
      id v8 = v2;
      nw_connection_async_client_if_needed_with_override(v5, 0LL, v6, v7);
    }
  }
}

void sub_18208F91C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL35nw_write_request_start_file_updatesP27NWConcrete_nw_write_request_block_invoke_2(uint64_t a1)
{
  if (((*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))() & 1) == 0)
  {
    id v2 = *(void **)(a1 + 32);
    uint64_t v3 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
    nw_write_request_report_error_with_override(v2, 0LL, v3);
  }

void sub_18208F9C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_write_request_report(void *a1, void *a2, void *a3)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  size_t v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if ((v5[128] & 2) != 0) {
    goto LABEL_59;
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_32859);
  }
  if (v7 || (char v8 = v5[128], (v8 & 1) != 0))
  {
    nw_content_context_mark_completed_send(*((void **)v5 + 8), v7);
    char v8 = v5[128];
  }

  v5[128] = v8 | 2;
  if (_nw_signposts_once == -1)
  {
    if (!_nw_signposts_enabled) {
      goto LABEL_13;
    }
  }

  else
  {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_32859);
    if (!_nw_signposts_enabled) {
      goto LABEL_13;
    }
  }

  if (kdebug_is_enabled())
  {
    char v49 = (dispatch_data_s *)*((void *)v5 + 7);
    if (v49) {
      dispatch_data_get_size(v49);
    }
    uint64_t v50 = (nw_content_context *)*((void *)v5 + 8);
    if (v50) {
      nw_content_context_get_is_final(v50);
    }
    kdebug_trace();
  }

void sub_182090048( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, void *a22)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

uint64_t ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke_93( void *a1)
{
  return (*(uint64_t (**)(void, void, BOOL))(a1[6] + 16LL))( a1[6],  *(void *)(a1[4] + 112LL),  a1[5] == 0LL);
}

void nw_write_request_fail(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (v3)
  {
    if (a2) {
      posix_error = nw_error_create_posix_error(a2);
    }
    else {
      posix_error = 0LL;
    }
    nw_write_request_report(v3, 0LL, posix_error);

    goto LABEL_6;
  }

  __nwlog_obj();
  size_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_write_request_fail";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_write_request_fail";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_write_request_fail";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_write_request_fail";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_write_request_fail";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18209038C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t nw_write_request_remaining_datagram_count(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    id v2 = (uint64_t *)v1;
    if (*((void *)v1 + 7)) {
      unint64_t v3 = !nw_content_context_is_blocked_by_antecedents(*((void **)v1 + 8));
    }
    else {
      unint64_t v3 = 0LL;
    }
    size_t v5 = v2 + 1;
    uint64_t v4 = v2[1];
    if (v4)
    {
      do
      {
        uint64_t v6 = *(void *)(v4 + 56);
        if (v6)
        {
          uint64_t v6 = !nw_content_context_is_blocked_by_antecedents(*(void **)(v4 + 64));
          uint64_t v4 = *v5;
        }

        v3 += v6;
        id v7 = (uint64_t *)(id)v4;

        size_t v5 = v7 + 1;
        uint64_t v4 = v7[1];
        if (!v4) {
          break;
        }
        id v2 = v7;
      }

      while (v3 < 0x100);
    }

    else
    {
      id v7 = v2;
    }

    goto LABEL_12;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v20 = "nw_write_request_remaining_datagram_count";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_write_request_remaining_datagram_count";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v20 = "nw_write_request_remaining_datagram_count";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_write_request_remaining_datagram_count";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_write_request_remaining_datagram_count";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_write_request_copy_data_from_fd_block_invoke(uint64_t a1, int a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = read(a2, *(void **)(a1 + 40), *(void *)(a1 + 48));
  return 1LL;
}

id nw_write_request_copy_context(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[8];
    goto LABEL_3;
  }

  __nwlog_obj();
  size_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_write_request_copy_context";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_write_request_copy_context";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_write_request_copy_context";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_write_request_copy_context";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_write_request_copy_context";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void ___ZL35nw_write_request_coalesce_with_nextP27NWConcrete_nw_write_requestS0__block_invoke( uint64_t a1, void *a2)
{
  id v3 = a2;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void sub_1820909D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

char **nw_protocol_http_encoding_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (char **)calloc(1uLL, 0x290uLL);
  if (!v6)
  {
    __int16 v21 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    uint32_t v33 = "strict_calloc";
    __int16 v34 = 2048;
    uint64_t v35 = 1LL;
    __int16 v36 = 2048;
    uint64_t v37 = 656LL;
    uint64_t v22 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v22))
    {
LABEL_54:
      __break(1u);
      JUMPOUT(0x182091200LL);
    }

    free(v22);
  }

  bzero(v6, 0x290uLL);
  if (gLogDatapath)
  {
    uint64_t v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      uint32_t v33 = "nw_protocol_http_encoding_create";
      __int16 v34 = 2082;
      uint64_t v35 = (uint64_t)v6 + 114;
      __int16 v36 = 2080;
      uint64_t v37 = (uint64_t)" ";
      _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
    }
  }

  if (nw_protocol_http_encoding_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http_encoding_identifier::onceToken, &__block_literal_global_33083);
  }
  v6[2] = (char *)nw_protocol_http_encoding_identifier::protocol_identifier;
  v6[3] = (char *)&nw_protocol_http_encoding_get_callbacks(void)::protocol_callbacks;
  v6[5] = (char *)v6;
  if (a3) {
    a3 = os_retain(a3);
  }
  char v7 = *((_BYTE *)v6 + 520);
  if ((v7 & 1) != 0)
  {
    os_log_type_t v8 = v6[64];
    if (v8)
    {
      os_release(v8);
      char v7 = *((_BYTE *)v6 + 520);
    }
  }

  v6[64] = (char *)a3;
  *((_BYTE *)v6 + 520) = v7 | 1;
  if (a4)
  {
    uint64_t v9 = (char *)os_retain(a4);
    char v10 = *((_BYTE *)v6 + 536);
    if ((v10 & 1) == 0) {
      goto LABEL_18;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    char v10 = *((_BYTE *)v6 + 536);
    if ((v10 & 1) == 0) {
      goto LABEL_18;
    }
  }

  BOOL v11 = v6[66];
  if (v11)
  {
    os_release(v11);
    char v10 = *((_BYTE *)v6 + 536);
  }

uint64_t nw_protocol_http_encoding_create::$_0::__invoke( nw_protocol_http_encoding_create::$_0 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

void nw_protocol_http_encoding_create::$_1::__invoke( nw_protocol_http_encoding_create::$_1 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "operator()";
    char v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "operator()";
      char v13 = "%{public}s called with null protocol";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v21 = "operator()";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v10) {
          return;
        }
LABEL_43:
        free(v10);
        return;
      }

      if (!v15) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "operator()";
      char v13 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "operator()";
      char v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_http_encoding_create::$_2::__invoke( nw_protocol_http_encoding_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (this)
  {
    uint64_t v3 = *((void *)this + 5);
    if (v3)
    {
      uint64_t result = 0LL;
      *(_WORD *)(v3 + 648) |= 0x40u;
      return result;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "operator()";
    size_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "operator()";
        os_log_type_t v8 = "%{public}s called with null http_encoding";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v13)
    {
      char v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "operator()";
        os_log_type_t v8 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v12 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "operator()";
        os_log_type_t v8 = "%{public}s called with null http_encoding, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v16 = "operator()";
      __int16 v17 = 2082;
      char v18 = backtrace_string;
      BOOL v11 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "operator()";
  size_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v13)
    {
      char v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "operator()";
        os_log_type_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "operator()";
        os_log_type_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v16 = "operator()";
      __int16 v17 = 2082;
      char v18 = backtrace_string;
      BOOL v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v6, v7, v11, buf, 0x16u);
    }

uint64_t nw_protocol_http_encoding_create::$_3::__invoke( nw_protocol_http_encoding_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_encoding_create::$_4::__invoke( nw_protocol_http_encoding_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1LL;
}

uint64_t nw_protocol_http_encoding_create::$_5::__invoke( nw_protocol_http_encoding_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      BOOL v10 = "%{public}s called with null protocol";
      goto LABEL_45;
    }

    if (!v20)
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      BOOL v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type[0];
    BOOL v12 = os_log_type_enabled(v8, type[0]);
    if (!backtrace_string)
    {
      if (!v12) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      BOOL v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_45;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_46:
    if (!v7) {
      return 1LL;
    }
LABEL_47:
    free(v7);
    return 1LL;
  }

  uint64_t v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      BOOL v10 = "%{public}s called with null http_encoding";
      goto LABEL_45;
    }

    if (!v20)
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      BOOL v10 = "%{public}s called with null http_encoding, backtrace limit exceeded";
      goto LABEL_45;
    }

    char v13 = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type[0];
    BOOL v14 = os_log_type_enabled(v8, type[0]);
    if (v13)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "operator()";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v13;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null http_encoding, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v13);
      if (!v7) {
        return 1LL;
      }
      goto LABEL_47;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      BOOL v10 = "%{public}s called with null http_encoding, no backtrace";
LABEL_45:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      goto LABEL_46;
    }

    goto LABEL_46;
  }

  if ((_DWORD)a3 != 96) {
    return 1LL;
  }
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3802000000LL;
  __int16 v22 = __Block_byref_object_copy__33095;
  uint64_t v23 = __Block_byref_object_dispose__33096;
  object = 0LL;
  char v25 = -1;
  char v4 = (unsigned __int8 *)nw_protocol_copy_info(*(void *)(v3 + 32), 255);
  *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
  uint64_t v16 = 0x40000000LL;
  __int16 v17 = ___ZZ32nw_protocol_http_encoding_createENK3__5clEP11nw_protocolS1_i_block_invoke;
  char v18 = &unk_189BBBF88;
  uint64_t v19 = buf;
  nw_array_apply(v4, (uint64_t)type);
  size_t v5 = *(void **)(*(void *)&buf[8] + 40LL);
  if (!v5 || nw_http_connection_metadata_get_version(v5) != 3)
  {
    if (v4) {
      os_release(v4);
    }
    _Block_object_dispose(buf, 8);
    if ((v25 & 1) != 0 && object) {
      os_release(object);
    }
    return 1LL;
  }

  *(_WORD *)(v3 + 648) |= 0x100u;
  nw_http_encoding_check_http1_content_length(v3);
  if (v4) {
    os_release(v4);
  }
  _Block_object_dispose(buf, 8);
  if ((v25 & 1) != 0)
  {
    if (object) {
      os_release(object);
    }
  }

  return 0LL;
}

uint64_t __Block_byref_object_copy__33095(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__33096(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

BOOL ___ZZ32nw_protocol_http_encoding_createENK3__5clEP11nw_protocolS1_i_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3;
  BOOL is_http_connection = nw_protocol_metadata_is_http_connection(a3);
  if (is_http_connection)
  {
    if (v3) {
      uint64_t v3 = os_retain(v3);
    }
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    char v7 = *(_BYTE *)(v6 + 48);
    if ((v7 & 1) != 0)
    {
      os_log_type_t v8 = *(void **)(v6 + 40);
      if (v8)
      {
        os_release(v8);
        char v7 = *(_BYTE *)(v6 + 48);
      }
    }

    *(void *)(v6 + 40) = v3;
    *(_BYTE *)(v6 + 48) = v7 | 1;
  }

  return !is_http_connection;
}

void nw_http_encoding_check_http1_content_length(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if ((~*(unsigned __int16 *)(a1 + 648) & 0x180) == 0)
  {
    id v2 = *(void **)(a1 + 496);
    if (!v2) {
      goto LABEL_13;
    }
    id v3 = nw_http_metadata_copy_response(v2);
    uint64_t v8 = 0LL;
    os_log_type_t v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    uint64_t v11 = -1LL;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    v7[2] = ___ZL43nw_http_encoding_check_http1_content_lengthP25nw_protocol_http_encoding_block_invoke;
    v7[3] = &unk_189BBBFB0;
    void v7[4] = &v8;
    nw_http_fields_access_value_by_name(v3, (unint64_t)"Content-Length", v7);
    uint64_t v4 = v9[3];
    if (v4 == -1 || v4 != *(void *)(a1 + 472))
    {
      int v6 = 1;
    }

    else
    {
      if ((*(_BYTE *)(a1 + 198) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v5 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          char v13 = "nw_http_encoding_check_http1_content_length";
          __int16 v14 = 2082;
          uint64_t v15 = a1 + 114;
          __int16 v16 = 2080;
          __int16 v17 = " ";
          _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%saccepting invalid Content-Length matching decompressed body",  buf,  0x20u);
        }
      }

      int v6 = 0;
    }

    _Block_object_dispose(&v8, 8);
    if (v3) {
      os_release(v3);
    }
    if (v6) {
LABEL_13:
    }
      nw_protocol_error(*(void **)(a1 + 48), a1);
  }

void ___ZL43nw_http_encoding_check_http1_content_lengthP25nw_protocol_http_encoding_block_invoke( uint64_t a1, char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    std::string::size_type v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (std::string *)operator new(v7 + 1);
      __dst.__r_.__value_.__l.__size_ = v5;
      __dst.__r_.__value_.__l.__cap_ = v8 | 0x8000000000000000LL;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }

    else
    {
      __dst.__r_.__value_.__s.__size_ = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        p_dst->__r_.__value_.__s.__data_[v5] = 0;
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = std::stoull(&__dst, 0LL, 10);
        return;
      }
    }

    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }

void ___ZL39nw_protocol_http_encoding_get_callbacksv_block_invoke()
{
  qword_18C592CA8 = (uint64_t)nw_protocol_common_get_parameters;
  unk_18C592CB0 = nw_protocol_common_get_path;
  qword_18C592CB8 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_18C592CC0 = nw_protocol_common_get_remote_endpoint;
  qword_18C592C48 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_18C592C50 = nw_protocol_common_connect;
  qword_18C592C58 = (uint64_t)nw_protocol_common_disconnect;
  unk_18C592C60 = nw_protocol_common_connected;
  qword_18C592C78 = (uint64_t)nw_protocol_common_input_available;
  unk_18C592C80 = nw_protocol_common_output_available;
  qword_18C592CF8 = (uint64_t)nw_protocol_common_output_finished;
  unk_18C592D00 = nw_protocol_common_get_output_local_endpoint;
  qword_18C592D40 = (uint64_t)nw_protocol_common_input_flush;
  qword_18C592C68 = (uint64_t)nw_protocol_common_disconnected;
  unk_18C592C70 = nw_protocol_common_error;
  qword_18C592D30 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_18C592D38 = nw_protocol_common_reset;
  qword_18C592D18 = (uint64_t)nw_protocol_common_copy_info;
  qword_18C592CE8 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_18C592CF0 = nw_protocol_common_input_finished;
  qword_18C592D08 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_18C592D10 = nw_protocol_common_waiting_for_output;
  qword_18C592CC8 = (uint64_t)nw_protocol_common_register_notification;
  unk_18C592CD0 = nw_protocol_common_unregister_notification;
  qword_18C592CD8 = (uint64_t)nw_protocol_common_notify;
  unk_18C592CE0 = nw_protocol_common_updated_path;
  qword_18C592C88 = (uint64_t)nw_protocol_http_encoding_get_input_frames;
  unk_18C592C90 = nw_protocol_common_get_output_frames;
  qword_18C592C98 = (uint64_t)nw_protocol_http_encoding_finalize_output_frames;
  unk_18C592CA0 = nw_protocol_common_link_state;
  nw_protocol_http_encoding_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  unk_18C592C40 = nw_protocol_http_encoding_remove_input_handler;
}

uint64_t nw_protocol_http_encoding_get_input_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    v58[0] = 16;
    LOBYTE(v54) = 0;
    if (v58[0] != 17)
    {
      if (!(_BYTE)v54)
      {
        uint64_t v27 = (os_log_s *)__nwlog_obj();
        os_log_type_t v28 = v58[0];
        if (!os_log_type_enabled(v27, (os_log_type_t)v58[0])) {
          goto LABEL_73;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames";
        int v29 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_72;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = v58[0];
      BOOL v32 = os_log_type_enabled(v27, (os_log_type_t)v58[0]);
      if (!backtrace_string)
      {
        if (!v32) {
          goto LABEL_73;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames";
        int v29 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_72;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint32_t v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_60:
        _os_log_impl(&dword_181A5C000, v27, v28, v33, buf, 0x16u);
      }

uint64_t nw_protocol_http_encoding_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
      uint64_t v18 = "%{public}s called with null protocol";
LABEL_65:
      _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      goto LABEL_66;
    }

    if (!v25)
    {
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_65;
      }

      goto LABEL_66;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v21 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_65;
      }

      goto LABEL_66;
    }

    if (!v21) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
    __int16 v29 = 2082;
    os_log_type_t v30 = backtrace_string;
    uint64_t v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_51:
    _os_log_impl(&dword_181A5C000, v16, v17, v22, buf, 0x16u);
    goto LABEL_52;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
      uint64_t v18 = "%{public}s called with null http_encoding";
      goto LABEL_65;
    }

    if (!v25)
    {
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        goto LABEL_65;
      }

      goto LABEL_66;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null http_encoding, no backtrace";
        goto LABEL_65;
      }

      goto LABEL_66;
    }

    if (!v23) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
    __int16 v29 = 2082;
    os_log_type_t v30 = backtrace_string;
    uint64_t v22 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
    goto LABEL_51;
  }

  if (a2)
  {
    if ((handle[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        __int16 v19 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
          __int16 v29 = 2082;
          os_log_type_t v30 = handle + 114;
          __int16 v31 = 2080;
          BOOL v32 = " ";
          _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }

    __int16 v4 = *((_WORD *)handle + 324);
    if ((v4 & 0x11) == 0)
    {
      *((_WORD *)handle + 324) = v4 | 0x10;
      tqh_first = a2->tqh_first;
      if (nw_protocol_copy_http_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
      }
      id v6 = (id)nw_protocol_copy_http_definition_http_definition;
      uint64_t v7 = nw_frame_copy_metadata_for_protocol((uint64_t)tqh_first, (uint64_t)v6);
      id v8 = nw_http_metadata_copy_request(v7);
      else {
        __int16 v9 = 0;
      }
      *((_WORD *)handle + 324) = *((_WORD *)handle + 324) & 0xFFFD | v9;
      if (!nw_http_fields_have_field_with_name(v8, (unint64_t)"Accept-Encoding"))
      {
        parameters = (void *)nw_protocol_get_parameters((uint64_t)handle);
        id v11 = nw_parameters_copy_url_endpoint(parameters);
        url_scheme = (const char *)nw_endpoint_get_url_scheme(v11);
        uint64_t v13 = "gzip, deflate, br";
        if (strcasecmp(url_scheme, "https") && strcasecmp(url_scheme, "wss")) {
          uint64_t v13 = "gzip, deflate";
        }
        nw_http_fields_append(v8, (uint64_t)"Accept-Encoding", (uint64_t)v13);
        if (v11) {
          os_release(v11);
        }
      }

      if (v8) {
        os_release(v8);
      }
      if (v7) {
        os_release(v7);
      }
      if (v6) {
        os_release(v6);
      }
    }

    return nw_protocol_finalize_output_frames(*((void *)handle + 4), (uint64_t)a2);
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
  uint64_t v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v25)
    {
      char v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null frames, backtrace limit exceeded";
        goto LABEL_65;
      }

      goto LABEL_66;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v24 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
        uint64_t v18 = "%{public}s called with null frames, no backtrace";
        goto LABEL_65;
      }

      goto LABEL_66;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v28 = "nw_protocol_http_encoding_finalize_output_frames";
      __int16 v29 = 2082;
      os_log_type_t v30 = backtrace_string;
      uint64_t v22 = "%{public}s called with null frames, dumping backtrace:%{public}s";
      goto LABEL_51;
    }

uint64_t nw_protocol_http_encoding_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 0x40000000LL;
      void v15[2] = ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v15[3] = &__block_descriptor_tmp_54_33149;
      v15[4] = handle;
      v13[0] = MEMORY[0x1895F87A8];
      v13[1] = 0x40000000LL;
      v13[2] = ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
      v13[3] = &__block_descriptor_tmp_55_33150;
      char v14 = a3;
      v13[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v15, (uint64_t)v13);
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
    std::string::size_type v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
        id v8 = "%{public}s called with null http_encoding";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v16)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
        id v8 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = v17;
    BOOL v12 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
        id v8 = "%{public}s called with null http_encoding, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
      __int16 v20 = 2082;
      BOOL v21 = backtrace_string;
      id v11 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
  std::string::size_type v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (v17 != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
        id v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = v17;
    BOOL v10 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
        id v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v19 = "nw_protocol_http_encoding_remove_input_handler";
      __int16 v20 = 2082;
      BOOL v21 = backtrace_string;
      id v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v6, v7, v11, buf, 0x16u);
    }

void ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v2 = (void *)(*(void *)(a1 + 32) + 608LL);
  if (gLogDatapath)
  {
    id v11 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  uint64_t v3 = MEMORY[0x1895F87A8];
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33165;
  __int16 v19 = (const char *)&__block_descriptor_tmp_38_33166;
  __int16 v20 = v2;
  char v21 = 0;
  uint64_t v4 = *v2;
  do
  {
    if (!v4) {
      break;
    }
    uint64_t v5 = *(void *)(v4 + 32);
    char v6 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    uint64_t v4 = v5;
  }

  while ((v6 & 1) != 0);
  uint64_t v7 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v7 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      BOOL v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
      uint64_t v7 = *(void *)(a1 + 32);
      if (v13)
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_remove_input_handler_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v7 + 114;
        *(_WORD *)&buf[22] = 2080;
        __int16 v19 = " ";
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sremoving finalized_output_frames",  buf,  0x20u);
        uint64_t v7 = *(void *)(a1 + 32);
      }
    }
  }

  v14[0] = v3;
  v14[1] = 0x40000000LL;
  uint64_t v15 = (uint64_t (*)(void *))___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_52;
  char v16 = &__block_descriptor_tmp_53_33168;
  uint64_t v17 = v7;
  uint64_t v8 = *(void *)(v7 + 592);
  do
  {
    if (!v8) {
      break;
    }
    uint64_t v9 = *(void *)(v8 + 32);
    char v10 = v15(v14);
    uint64_t v8 = v9;
  }

  while ((v10 & 1) != 0);
  nw_frame_cache_remove_all((uint64_t *)(*(void *)(a1 + 32) + 432LL));
}

void ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!*(_BYTE *)(a1 + 40)) {
    return;
  }
  uint64_t v1 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v1 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      BOOL v32 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_encoding_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v1 + 114;
        *(_WORD *)&buf[22] = 2080;
        id v48 = " ";
        _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
  }

  if ((*(_BYTE *)(v1 + 198) & 1) == 0)
  {
    if (!gLogDatapath) {
      goto LABEL_6;
    }
    uint64_t v33 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_http_encoding_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v1 + 114;
      *(_WORD *)&buf[22] = 2080;
      id v48 = " ";
      _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sfinalizing frame arrays",  buf,  0x20u);
    }
  }

  if (gLogDatapath)
  {
    __int16 v34 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int v43 = 136446210;
      os_log_type_t v44 = "nw_protocol_finalize_master_frame_array";
      _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_DEBUG, "%{public}s called", v43, 0xCu);
    }
  }

uint64_t ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33155( uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33165( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v3;
  }

  void *v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

uint64_t ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_52( uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a2[4];
  uint64_t v4 = (void *)a2[5];
  if (v3)
  {
    *(void *)(v3 + 40) = v4;
    uint64_t v4 = (void *)a2[5];
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 600LL) = v4;
  }

  void *v4 = v3;
  a2[4] = 0LL;
  a2[5] = 0LL;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    if ((*(_BYTE *)(v5 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        char v11 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v17 = "nw_http_encoding_outbound_frame_return_to_cache";
          __int16 v18 = 2082;
          __int16 v19 = (char *)(v5 + 114);
          __int16 v20 = 2080;
          char v21 = " ";
          __int16 v22 = 2048;
          BOOL v23 = a2;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sreturning frame %p to cache",  buf,  0x2Au);
        }
      }
    }

    a2[10] = 0LL;
    a2[11] = 0LL;
    nw_frame_cache_return_frame(v5 + 432, (uint64_t)a2);
    return 1LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_http_encoding_outbound_frame_return_to_cache";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_http_encoding_outbound_frame_return_to_cache";
      uint64_t v10 = "%{public}s called with null http_encoding";
      goto LABEL_24;
    }

    if (!v14)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_http_encoding_outbound_frame_return_to_cache";
      uint64_t v10 = "%{public}s called with null http_encoding, backtrace limit exceeded";
      goto LABEL_24;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v13 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v17 = "nw_http_encoding_outbound_frame_return_to_cache";
        __int16 v18 = 2082;
        __int16 v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null http_encoding, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_25;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_http_encoding_outbound_frame_return_to_cache";
      uint64_t v10 = "%{public}s called with null http_encoding, no backtrace";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    }
  }

__n128 __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t __Block_byref_object_copy__20_33212(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__21_33213(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

BOOL ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v234 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    __int16 v34 = (char *)_os_log_send_and_compose_impl();
    v227[0] = 16;
    LOBYTE(v224[0]) = 0;
    if (__nwlog_fault(v34, v227, v224))
    {
      if (v227[0] == 17)
      {
        uint64_t v35 = (os_log_s *)__nwlog_obj();
        os_log_type_t v36 = v227[0];
        if (os_log_type_enabled(v35, (os_log_type_t)v227[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          char v37 = "%{public}s called with null frame";
LABEL_255:
          _os_log_impl(&dword_181A5C000, v35, v36, v37, buf, 0xCu);
        }
      }

      else if (LOBYTE(v224[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v35 = (os_log_s *)__nwlog_obj();
        os_log_type_t v36 = v227[0];
        BOOL v39 = os_log_type_enabled(v35, (os_log_type_t)v227[0]);
        if (backtrace_string)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_256;
        }

        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          char v37 = "%{public}s called with null frame, no backtrace";
          goto LABEL_255;
        }
      }

      else
      {
        uint64_t v35 = (os_log_s *)__nwlog_obj();
        os_log_type_t v36 = v227[0];
        if (os_log_type_enabled(v35, (os_log_type_t)v227[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          char v37 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_255;
        }
      }
    }

LABEL_205:
    if (v138) {
      free(v138);
    }
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) = -1;
LABEL_208:
    BOOL v156 = 1LL;
    if (v5) {
      goto LABEL_234;
    }
    return v156;
  }

  LODWORD(v23) = *(_DWORD *)(a2 + 52);
  uint64_t v24 = *(unsigned int *)(a2 + 56);
  if ((_DWORD)v23) {
    LODWORD(v23) = v23 - (v24 + *(_DWORD *)(a2 + 60));
  }
  uint64_t v25 = *(void *)(a2 + 112) + v24;
  uint64_t v26 = *(void *)(a2 + 64);
  if (!v26) {
    goto LABEL_58;
  }
LABEL_35:
  unsigned int v27 = *(unsigned __int8 *)(v26 + 66);
  __int16 v29 = a1 + 7;
  uint64_t v28 = a1[7];
  uint64_t v30 = *(void *)(v28 + 544);
  if (v30) {
    BOOL v31 = (_DWORD)v23 == 0;
  }
  else {
    BOOL v31 = 1;
  }
  if (v31)
  {
    if ((v27 & 0x40) != 0)
    {
      if (v30)
      {
        if ((*(_WORD *)(v28 + 648) & 0x24) == 4 && (*(_BYTE *)(v28 + 198) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v32 = (os_log_s *)gLogObj;
          BOOL v33 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          uint64_t v28 = *v29;
          if (v33)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v28 + 114;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v232 = (uint64_t)" ";
            _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%smetadata completed before decoder completed",  buf,  0x20u);
            uint64_t v28 = *v29;
          }
        }
      }

      *(_WORD *)(v28 + 648) |= 0x80u;
      nw_http_encoding_check_http1_content_length(*v29);
    }

    goto LABEL_63;
  }

  v206 = a1;
  v207 = v5;
  unsigned int v208 = (v27 >> 6) & 1;
LABEL_65:
  *(_WORD *)(v28 + 648) |= 4u;
  uint64_t v44 = *v29;
  int v45 = (*(unsigned __int8 *)(*v29 + 648) >> 5) & 1;
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  uint64_t v209 = v23;
  uint64_t v46 = MEMORY[0x1895F87A8];
  *(void *)&buf[16] = 0x3802000000LL;
  uint64_t v232 = (uint64_t)__Block_byref_object_copy__18;
  *(void *)v233 = __Block_byref_object_dispose__19;
  *(void *)&v233[8] = 0LL;
  *(void *)&v233[16] = &v233[8];
  unsigned __int8 v223 = v45;
  uint64_t v219 = 0LL;
  v220 = &v219;
  uint64_t v221 = 0x2000000000LL;
  uint64_t v222 = 0LL;
  while (1)
  {
    uint64_t v47 = *(void *)(v44 + 544);
    v218[0] = v46;
    v218[1] = 0x40000000LL;
    v218[2] = ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_22;
    v218[3] = &unk_189BBC018;
    v218[5] = v44;
    v218[6] = a2;
    v218[4] = buf;
    if (v47)
    {
      if (v25)
      {
        if (v223)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v48 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v227 = 136446210;
            *(void *)&v227[4] = "nw_decoder_decode";
            _os_log_impl(&dword_181A5C000, v48, OS_LOG_TYPE_ERROR, "%{public}s extra data", v227, 0xCu);
          }

          uint64_t v49 = 0LL;
        }

        else
        {
          uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int8 *, void *))(*(void *)v47 + 16LL))( v47,  v25,  v209,  v208,  &v223,  v218);
        }

        goto LABEL_74;
      }

      __nwlog_obj();
      *(_DWORD *)v227 = 136446210;
      *(void *)&v227[4] = "nw_decoder_decode";
      os_log_type_t v71 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v226 = OS_LOG_TYPE_ERROR;
      char v225 = 0;
      if (v226 != OS_LOG_TYPE_FAULT)
      {
        if (!v225)
        {
          v105 = (os_log_s *)__nwlog_obj();
          os_log_type_t v106 = v226;
          if (os_log_type_enabled(v105, v226))
          {
            *(_DWORD *)v227 = 136446210;
            *(void *)&v227[4] = "nw_decoder_decode";
            os_log_type_t v74 = v105;
            os_log_type_t v75 = v106;
            os_log_type_t v76 = "%{public}s called with null in_bytes, backtrace limit exceeded";
            goto LABEL_149;
          }

          goto LABEL_150;
        }

        __int16 v84 = (char *)__nw_create_backtrace_string();
        v91 = (os_log_s *)__nwlog_obj();
        os_log_type_t v92 = v226;
        os_log_t loga = v91;
        BOOL v93 = os_log_type_enabled(v91, v226);
        if (!v84)
        {
          if (v93)
          {
            *(_DWORD *)v227 = 136446210;
            *(void *)&v227[4] = "nw_decoder_decode";
            os_log_type_t v74 = loga;
            os_log_type_t v75 = v92;
            os_log_type_t v76 = "%{public}s called with null in_bytes, no backtrace";
            goto LABEL_149;
          }

          goto LABEL_150;
        }

        if (v93)
        {
          *(_DWORD *)v227 = 136446466;
          *(void *)&v227[4] = "nw_decoder_decode";
          *(_WORD *)&v227[12] = 2082;
          *(void *)&v227[14] = v84;
          __int16 v88 = loga;
          os_log_type_t v89 = v92;
          __int16 v90 = "%{public}s called with null in_bytes, dumping backtrace:%{public}s";
LABEL_125:
          _os_log_impl(&dword_181A5C000, v88, v89, v90, v227, 0x16u);
        }

        goto LABEL_126;
      }

      __int16 v77 = (os_log_s *)__nwlog_obj();
      os_log_type_t v78 = v226;
      if (os_log_type_enabled(v77, v226))
      {
        *(_DWORD *)v227 = 136446210;
        *(void *)&v227[4] = "nw_decoder_decode";
        os_log_type_t v74 = v77;
        os_log_type_t v75 = v78;
        os_log_type_t v76 = "%{public}s called with null in_bytes";
        goto LABEL_149;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)v227 = 136446210;
      *(void *)&v227[4] = "nw_decoder_decode";
      os_log_type_t v71 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v226 = OS_LOG_TYPE_ERROR;
      char v225 = 0;
      if (v226 == OS_LOG_TYPE_FAULT)
      {
        BOOL v72 = (os_log_s *)__nwlog_obj();
        os_log_type_t v73 = v226;
        if (os_log_type_enabled(v72, v226))
        {
          *(_DWORD *)v227 = 136446210;
          *(void *)&v227[4] = "nw_decoder_decode";
          os_log_type_t v74 = v72;
          os_log_type_t v75 = v73;
          os_log_type_t v76 = "%{public}s called with null decoder";
LABEL_149:
          _os_log_impl(&dword_181A5C000, v74, v75, v76, v227, 0xCu);
        }
      }

      else
      {
        if (v225)
        {
          __int16 v84 = (char *)__nw_create_backtrace_string();
          v85 = (os_log_s *)__nwlog_obj();
          os_log_type_t v86 = v226;
          os_log_t log = v85;
          BOOL v87 = os_log_type_enabled(v85, v226);
          if (!v84)
          {
            if (v87)
            {
              *(_DWORD *)v227 = 136446210;
              *(void *)&v227[4] = "nw_decoder_decode";
              os_log_type_t v74 = log;
              os_log_type_t v75 = v86;
              os_log_type_t v76 = "%{public}s called with null decoder, no backtrace";
              goto LABEL_149;
            }

            goto LABEL_150;
          }

          if (v87)
          {
            *(_DWORD *)v227 = 136446466;
            *(void *)&v227[4] = "nw_decoder_decode";
            *(_WORD *)&v227[12] = 2082;
            *(void *)&v227[14] = v84;
            __int16 v88 = log;
            os_log_type_t v89 = v86;
            __int16 v90 = "%{public}s called with null decoder, dumping backtrace:%{public}s";
            goto LABEL_125;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          v95 = "nw_protocol_http1_notify";
          uint64_t v47 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          os_log_type_t v92 = 0;
          if (__nwlog_fault(v47, &type, &v92))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v48 = (os_log_s *)gLogObj;
              uint64_t v49 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                goto LABEL_274;
              }
              *(_DWORD *)buf = 136446210;
              v95 = "nw_protocol_http1_notify";
              int v50 = "%{public}s called with null http1_stream";
              goto LABEL_273;
            }

            if (!v92)
            {
              id v48 = (os_log_s *)__nwlog_obj();
              uint64_t v49 = type;
              if (!os_log_type_enabled(v48, type)) {
                goto LABEL_274;
              }
              *(_DWORD *)buf = 136446210;
              v95 = "nw_protocol_http1_notify";
              int v50 = "%{public}s called with null http1_stream, backtrace limit exceeded";
              goto LABEL_273;
            }

            uint64_t v56 = (char *)__nw_create_backtrace_string();
            id v48 = (os_log_s *)__nwlog_obj();
            uint64_t v49 = type;
            __int16 v88 = os_log_type_enabled(v48, type);
            if (!v56)
            {
              if (!v88) {
                goto LABEL_274;
              }
              *(_DWORD *)buf = 136446210;
              v95 = "nw_protocol_http1_notify";
              int v50 = "%{public}s called with null http1_stream, no backtrace";
              goto LABEL_273;
            }

            if (v88)
            {
LABEL_212:
              *(_DWORD *)buf = 136446466;
              v95 = "nw_protocol_http1_notify";
              os_log_type_t v96 = 2082;
              v97 = v56;
              uint64_t v58 = "%{public}s called with null http1_stream, dumping backtrace:%{public}s";
              goto LABEL_266;
            }

            goto LABEL_267;
          }

          free(v45);
          goto LABEL_206;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v91 = "_http_safe_append";
        char v41 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(__src) = 16;
        os_log_type_t v89 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v41, &__src, &v89))
        {
          if (__src == 17)
          {
            uint64_t v42 = (os_log_s *)__nwlog_obj();
            int v43 = __src;
            if (!os_log_type_enabled(v42, (os_log_type_t)__src)) {
              goto LABEL_183;
            }
            *(_DWORD *)buf = 136446210;
            v91 = "_http_safe_append";
            uint64_t v44 = "%{public}s called with null (*remaining >= length)";
LABEL_182:
            _os_log_impl(&dword_181A5C000, v42, v43, v44, buf, 0xCu);
            goto LABEL_183;
          }

          if (v89 == OS_LOG_TYPE_DEFAULT)
          {
            uint64_t v42 = (os_log_s *)__nwlog_obj();
            int v43 = __src;
            if (!os_log_type_enabled(v42, (os_log_type_t)__src)) {
              goto LABEL_183;
            }
            *(_DWORD *)buf = 136446210;
            v91 = "_http_safe_append";
            uint64_t v44 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
            goto LABEL_182;
          }

          uint64_t v60 = (char *)__nw_create_backtrace_string();
          uint64_t v42 = (os_log_s *)__nwlog_obj();
          int v43 = __src;
          char v61 = os_log_type_enabled(v42, (os_log_type_t)__src);
          if (!v60)
          {
            if (!v61) {
              goto LABEL_183;
            }
            *(_DWORD *)buf = 136446210;
            v91 = "_http_safe_append";
            uint64_t v44 = "%{public}s called with null (*remaining >= length), no backtrace";
            goto LABEL_182;
          }

          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            v91 = "_http_safe_append";
            os_log_type_t v92 = 2082;
            BOOL v93 = v60;
            _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v60);
        }

      free(backtrace_string);
      goto LABEL_231;
    }

    if (!v79) {
      goto LABEL_231;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    os_log_type_t v73 = "%{public}s called with null body_buffer_length, no backtrace";
LABEL_230:
    _os_log_impl(&dword_181A5C000, v71, v72, v73, buf, 0xCu);
LABEL_231:
    if (v70) {
      free(v70);
    }
    return 0LL;
  }

  char v8 = *(unsigned __int8 *)a1;
  if (v8 > 0x3F)
  {
    id v15 = v8 >> 6;
    if (v15 == 2)
    {
      if (a2 < 4) {
        return 0LL;
      }
      char v8 = bswap32(*a1 & 0xFFFFFF7F);
      os_log_type_t v9 = 4LL;
    }

    else if (v15 == 1)
    {
      if (a2 < 2) {
        return 0LL;
      }
      char v8 = bswap32(*(_WORD *)a1 & 0xFFBF) >> 16;
      os_log_type_t v9 = 2LL;
    }

    else
    {
      if (a2 < 8) {
        return 0LL;
      }
      char v8 = bswap64(*(void *)a1 & 0xFFFFFFFFFFFFFF3FLL);
      os_log_type_t v9 = 8LL;
    }
  }

  else
  {
    os_log_type_t v9 = 1LL;
  }

  if (v8 > 3) {
    return 0LL;
  }
  id v10 = (_DWORD *)((char *)a1 + v9);
  char v11 = a2 - v9;
  if ((v8 & 0xFFFFFFFFFFFFFFFDLL) == 0)
  {
    if (a2 != v9)
    {
      char v16 = *(unsigned __int8 *)v10;
      if (v16 > 0x3F)
      {
        BOOL v38 = v16 >> 6;
        if (v38 == 2)
        {
          if (v11 < 4) {
            return 0LL;
          }
          char v16 = bswap32(*v10 & 0xFFFFFF7F);
          unsigned int v17 = 4LL;
        }

        else if (v38 == 1)
        {
          if (v11 < 2) {
            return 0LL;
          }
          char v16 = bswap32(*(_WORD *)v10 & 0xFFBF) >> 16;
          unsigned int v17 = 2LL;
        }

        else
        {
          if (v11 < 8) {
            return 0LL;
          }
          char v16 = bswap64(*(void *)v10 & 0xFFFFFFFFFFFFFF3FLL);
          unsigned int v17 = 8LL;
        }
      }

      else
      {
        unsigned int v17 = 1LL;
      }

      __n128 result = 0LL;
      if (v16 >> 16) {
        return result;
      }
      __int16 v19 = v11 - v17;
      if (v19 < v16) {
        return result;
      }
      __int16 v20 = v19 - v16;
      if (v20)
      {
        uint64_t v21 = (_DWORD *)((char *)v10 + v17 + v16);
        __int16 v22 = *(unsigned __int8 *)v21;
        if (v22 > 0x3F)
        {
          uint64_t v59 = v22 >> 6;
          if (v59 == 2)
          {
            if (v20 < 4) {
              return 0LL;
            }
            __int16 v22 = bswap32(*v21 & 0xFFFFFF7F);
            uint64_t v23 = 4LL;
          }

          else if (v59 == 1)
          {
            if (v20 < 2) {
              return 0LL;
            }
            __int16 v22 = bswap32(*(_WORD *)v21 & 0xFFBF) >> 16;
            uint64_t v23 = 2LL;
          }

          else
          {
            if (v20 < 8) {
              return 0LL;
            }
            __int16 v22 = bswap64(*(void *)v21 & 0xFFFFFFFFFFFFFF3FLL);
            uint64_t v23 = 8LL;
          }
        }

        else
        {
          uint64_t v23 = 1LL;
        }

        __n128 result = 0LL;
        if (v22 >> 16) {
          return result;
        }
        uint64_t v24 = v20 - v23;
        if (v24 < v22) {
          return result;
        }
        uint64_t v25 = v24 - v22;
        if (v25)
        {
          uint64_t v26 = (_DWORD *)((char *)v21 + v23 + v22);
          unsigned int v27 = *(unsigned __int8 *)v26;
          if (v27 > 0x3F)
          {
            BOOL v69 = v27 >> 6;
            if (v69 == 2)
            {
              if (v25 < 4) {
                return 0LL;
              }
              unsigned int v27 = bswap32(*v26 & 0xFFFFFF7F);
              uint64_t v28 = 4LL;
            }

            else if (v69 == 1)
            {
              if (v25 < 2) {
                return 0LL;
              }
              unsigned int v27 = bswap32(*(_WORD *)v26 & 0xFFBF) >> 16;
              uint64_t v28 = 2LL;
            }

            else
            {
              if (v25 < 8) {
                return 0LL;
              }
              unsigned int v27 = bswap64(*(void *)v26 & 0xFFFFFFFFFFFFFF3FLL);
              uint64_t v28 = 8LL;
            }
          }

          else
          {
            uint64_t v28 = 1LL;
          }

          __int16 v29 = v25 - v28;
          if (v27 >> 16) {
            uint64_t v30 = 0;
          }
          else {
            uint64_t v30 = v29 >= v27;
          }
          if (!v30) {
            return 0LL;
          }
          BOOL v31 = v29 - v27;
          if (!v31) {
            return 0LL;
          }
          BOOL v32 = (_DWORD *)((char *)v26 + v28 + v27);
          BOOL v33 = *(unsigned __int8 *)v32;
          if (v33 > 0x3F)
          {
            BOOL v80 = v33 >> 6;
            if (v80 == 2)
            {
              if (v31 < 4) {
                return 0LL;
              }
              BOOL v33 = bswap32(*v32 & 0xFFFFFF7F);
              __int16 v34 = 4LL;
            }

            else if (v80 == 1)
            {
              if (v31 < 2) {
                return 0LL;
              }
              BOOL v33 = bswap32(*(_WORD *)v32 & 0xFFBF) >> 16;
              __int16 v34 = 2LL;
            }

            else
            {
              if (v31 < 8) {
                return 0LL;
              }
              BOOL v33 = bswap64(*(void *)v32 & 0xFFFFFFFFFFFFFF3FLL);
              __int16 v34 = 8LL;
            }
          }

          else
          {
            __int16 v34 = 1LL;
          }

          uint64_t v35 = v31 - v34;
          if (v33 >> 16) {
            os_log_type_t v36 = 0;
          }
          else {
            os_log_type_t v36 = v35 >= v33;
          }
          if (!v36) {
            return 0LL;
          }
          BOOL v13 = (char *)v32 + v34 + v33;
          id v14 = v35 - v33;
          goto LABEL_64;
        }
      }
    }

    return 0LL;
  }

  if (a2 == v9) {
    return 0LL;
  }
  uint64_t v12 = *(unsigned __int8 *)v10;
  if (v12 > 0x3F)
  {
    if (v12 >> 6 == 2)
    {
      if (v11 < 4) {
        return 0LL;
      }
      uint64_t v12 = bswap32(*v10 & 0xFFFFFF7F);
      char v37 = 4LL;
    }

    else if (v12 >> 6 == 1)
    {
      if (v11 < 2) {
        return 0LL;
      }
      uint64_t v12 = bswap32(*(_WORD *)v10 & 0xFFBF) >> 16;
      char v37 = 2LL;
    }

    else
    {
      if (v11 < 8) {
        return 0LL;
      }
      uint64_t v12 = bswap64(*(void *)v10 & 0xFFFFFFFFFFFFFF3FLL);
      char v37 = 8LL;
    }

    if (v12 > 0x3E8) {
      return 0LL;
    }
    BOOL v13 = (char *)v10 + v37;
    id v14 = v11 - v37;
  }

  else
  {
    BOOL v13 = (char *)v10 + 1;
    id v14 = v11 - 1;
  }

  if (v12 - 601 <= 0xFFFFFFFFFFFFFE6ELL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v39 = (os_log_s *)gLogObj;
    __n128 result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    v85 = 2048;
    os_log_type_t v86 = v12;
    _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s Informational statuses not supported: %llu",  buf,  0x16u);
    return 0LL;
  }

      goto LABEL_70;
    }

    if (!v129)
    {
      __nwlog_obj();
      __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v106 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl( &dword_181A5C000,  v34,  v106,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_205;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v101 = type;
    v102 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v102)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v34, v101, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }

      goto LABEL_205;
    }

    if (v102)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      uint64_t v132 = 2082;
      v133 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v34,  v101,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

uint64_t ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_31( uint64_t a1, _DWORD *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(*(void *)(a1 + 32) + 198LL) & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v6 = *(void *)(a1 + 32) + 114LL;
        int v7 = 136447234;
        char v8 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        __int16 v9 = 2082;
        uint64_t v10 = v6;
        __int16 v11 = 2080;
        uint64_t v12 = " ";
        __int16 v13 = 2048;
        id v14 = a2;
        __int16 v15 = 1024;
        int v16 = nw_frame_unclaimed_length(a2);
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sframe %p unclaimed length %u",  (uint8_t *)&v7,  0x30u);
      }
    }
  }

  return 1LL;
}

void ___ZL33nw_http_encoding_get_content_typeP25nw_protocol_http_encodingP20nw_protocol_metadata_block_invoke( uint64_t a1, char *a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if (!strcasecmp(a2, "gzip") || !strcasecmp(a2, "x-gzip"))
    {
      int v6 = 2;
    }

    else if (!strcasecmp(a2, "deflate"))
    {
      int v6 = 3;
    }

    else if (!strcasecmp(a2, "br"))
    {
      int v6 = 5;
    }

    else
    {
      if ((*(_BYTE *)(*(void *)(a1 + 40) + 198LL) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v4 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          uint64_t v5 = *(void *)(a1 + 40) + 114LL;
          int v7 = 136446978;
          char v8 = "nw_http_encoding_get_content_type_block_invoke";
          __int16 v9 = 2082;
          uint64_t v10 = v5;
          __int16 v11 = 2080;
          uint64_t v12 = " ";
          __int16 v13 = 2080;
          id v14 = a2;
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sunknown encoding type %s, ignoring",  (uint8_t *)&v7,  0x2Au);
        }
      }

      int v6 = 0;
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v6;
  }

uint64_t ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_22( void *a1, size_t __size)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a1[5];
  char v5 = *(_BYTE *)(v4 + 198);
  if ((v5 & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
      uint64_t v4 = a1[5];
      if (v13)
      {
        *(_DWORD *)buf = 136446978;
        uint64_t v26 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = (char *)(v4 + 114);
        __int16 v29 = 2080;
        uint64_t v30 = " ";
        __int16 v31 = 2048;
        size_t v32 = __size;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sdecoder asking for frame of size %zu",  buf,  0x2Au);
        uint64_t v4 = a1[5];
      }

      if (!v4)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_http_encoding_create_inbound_frame";
        id v14 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v23 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v26 = "nw_http_encoding_create_inbound_frame";
            uint64_t v17 = "%{public}s called with null http_encoding";
LABEL_40:
            _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
            goto LABEL_41;
          }

          goto LABEL_41;
        }

        if (!v23)
        {
          uint64_t v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v26 = "nw_http_encoding_create_inbound_frame";
            uint64_t v17 = "%{public}s called with null http_encoding, backtrace limit exceeded";
            goto LABEL_40;
          }

          goto LABEL_41;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v22 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v26 = "nw_http_encoding_create_inbound_frame";
            uint64_t v17 = "%{public}s called with null http_encoding, no backtrace";
            goto LABEL_40;
          }

          goto LABEL_41;
        }

        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_http_encoding_create_inbound_frame";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          uint64_t v21 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
          goto LABEL_30;
        }

        goto LABEL_31;
      }
    }

    char v5 = *(_BYTE *)(v4 + 198);
  }

  if ((v5 & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        uint64_t v26 = "nw_http_encoding_create_inbound_frame";
        __int16 v27 = 2082;
        uint64_t v28 = (char *)(v4 + 114);
        __int16 v29 = 2080;
        uint64_t v30 = " ";
        __int16 v31 = 1024;
        LODWORD(v32) = __size;
        _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled for size %u", buf, 0x26u);
      }
    }
  }

  BOOL frame = nw_frame_cache_create_frame((uint64_t *)(v4 + 432), __size);
  if (frame)
  {
    uint64_t v7 = frame;
    *(void *)(frame + 16) = 0LL;
    char v8 = *(BOOL **)(v4 + 568);
    *(void *)(frame + 24) = v8;
    BOOL *v8 = frame;
    *(void *)(v4 + 568) = frame + 16;
    *(void *)(frame + 80) = nw_http_encoding_inbound_frame_finalizer;
    *(void *)(frame + 88) = v4;
    goto LABEL_8;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v26 = "nw_http_encoding_create_inbound_frame";
  id v14 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v23)
    {
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_http_encoding_create_inbound_frame";
        uint64_t v17 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_40;
      }

      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v20 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_http_encoding_create_inbound_frame";
        uint64_t v17 = "%{public}s called with null frame, no backtrace";
        goto LABEL_40;
      }

      goto LABEL_41;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_http_encoding_create_inbound_frame";
      __int16 v27 = 2082;
      uint64_t v28 = backtrace_string;
      uint64_t v21 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_30:
      _os_log_impl(&dword_181A5C000, v15, v16, v21, buf, 0x16u);
    }

void nw_http_encoding_inbound_frame_finalizer(nw_frame *a1, int a2, _BYTE *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_http_encoding_inbound_frame_finalizer";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_http_encoding_inbound_frame_finalizer";
      uint64_t v12 = "%{public}s called with null frame";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v21 = "nw_http_encoding_inbound_frame_finalizer";
          __int16 v22 = 2082;
          char v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_47:
        if (!v9) {
          return;
        }
LABEL_48:
        free(v9);
        return;
      }

      if (!v15) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_http_encoding_inbound_frame_finalizer";
      uint64_t v12 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_http_encoding_inbound_frame_finalizer";
      uint64_t v12 = "%{public}s called with null frame, backtrace limit exceeded";
    }

uint64_t ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_26( void *a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  unsigned int v5 = nw_frame_unclaimed_length((_DWORD *)a2);
  uint64_t v6 = a1[7];
  if ((*(_BYTE *)(v6 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      __int16 v28 = (os_log_s *)__nwlog_obj();
      BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG);
      uint64_t v6 = a1[7];
      if (v29)
      {
        *(_DWORD *)buf = 136446978;
        BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        __int16 v39 = 2082;
        BOOL v40 = (const char *)(v6 + 114);
        __int16 v41 = 2080;
        uint64_t v42 = (uint64_t)" ";
        __int16 v43 = 1024;
        LODWORD(v44) = v5;
        _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sunclaimed length %u", buf, 0x26u);
        uint64_t v6 = a1[7];
      }
    }
  }

  if (v5 >= *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL)) {
    unsigned int v5 = *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
  }
  if ((*(_BYTE *)(v6 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      __int16 v30 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v31 = a1[7] + 114LL;
        *(_DWORD *)buf = 136446978;
        BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        __int16 v39 = 2082;
        BOOL v40 = (const char *)v31;
        __int16 v41 = 2080;
        uint64_t v42 = (uint64_t)" ";
        __int16 v43 = 1024;
        LODWORD(v44) = v5;
        _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%u bytes to claim", buf, 0x26u);
      }
    }
  }

  nw_frame_claim(a2, v4, v5, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v7, v5, 0);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) -= v5;
  if ((*(_BYTE *)(a1[7] + 198LL) & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v33 = a1[7] + 114LL;
        uint64_t v34 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
        *(_DWORD *)buf = 136446978;
        BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        __int16 v39 = 2082;
        BOOL v40 = (const char *)v33;
        __int16 v41 = 2080;
        uint64_t v42 = (uint64_t)" ";
        __int16 v43 = 2048;
        uint64_t v44 = v34;
        _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%zu bytes decoded", buf, 0x2Au);
      }
    }
  }

  uint64_t v9 = *(void *)(a2 + 32);
  uint64_t v10 = *(void **)(a2 + 40);
  char v8 = (void *)(a2 + 32);
  if (v9)
  {
    *(void *)(v9 + 40) = v10;
    uint64_t v10 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1[5] + 8LL) + 48LL) = v10;
  }

  void *v10 = v9;
  void *v8 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  uint64_t v11 = a1[9];
  uint64_t v12 = *(uint64_t **)(v11 + 8);
  *(void *)(a2 + 40) = v12;
  uint64_t *v12 = a2;
  *(void *)(v11 + 8) = v8;
  uint64_t v13 = *(void *)(a1[6] + 8LL);
  uint64_t v14 = *(unsigned int *)(v13 + 24) + 1LL;
  uint64_t v15 = v14 << 31 >> 31;
  *(_DWORD *)(v13 + 24) = v14;
  if (v15 != v14 || v15 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v16 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    __int16 v39 = 2082;
    BOOL v40 = "count";
    __int16 v41 = 2048;
    uint64_t v42 = 1LL;
    __int16 v43 = 2048;
    uint64_t v44 = v16;
    BOOL v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v17, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (os_log_s *)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v20 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          __int16 v39 = 2082;
          BOOL v40 = "count";
          __int16 v41 = 2048;
          uint64_t v42 = 1LL;
          __int16 v43 = 2048;
          uint64_t v44 = v20;
          uint64_t v21 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_27:
          _os_log_impl(&dword_181A5C000, v18, v19, v21, buf, 0x2Au);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (os_log_s *)gLogObj;
        os_log_type_t v19 = type;
        BOOL v23 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v23)
          {
            uint64_t v24 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
            *(_DWORD *)buf = 136447234;
            BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            __int16 v39 = 2082;
            BOOL v40 = "count";
            __int16 v41 = 2048;
            uint64_t v42 = 1LL;
            __int16 v43 = 2048;
            uint64_t v44 = v24;
            __int16 v45 = 2082;
            uint64_t v46 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v23)
        {
          uint64_t v26 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          __int16 v39 = 2082;
          BOOL v40 = "count";
          __int16 v41 = 2048;
          uint64_t v42 = 1LL;
          __int16 v43 = 2048;
          uint64_t v44 = v26;
          uint64_t v21 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_27;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (os_log_s *)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v25 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          BOOL v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          __int16 v39 = 2082;
          BOOL v40 = "count";
          __int16 v41 = 2048;
          uint64_t v42 = 1LL;
          __int16 v43 = 2048;
          uint64_t v44 = v25;
          uint64_t v21 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_27;
        }
      }
    }

double __nw_protocol_http_encoding_identifier_block_invoke()
{
  *(void *)&double result = 0x100000005LL;
  qword_18C5927C8 = 0x100000005LL;
  return result;
}

BOOL nw_link_set_flow_control_status(void *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    int v5 = *((_DWORD *)v3 + 2);
    *((_DWORD *)v3 + 2) = a2;
    BOOL v6 = v5 != a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  char v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_link_set_flow_control_status";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_link_set_flow_control_status";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null link_info", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v19 = "nw_link_set_flow_control_status";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null link_info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_link_set_flow_control_status";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null link_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_link_set_flow_control_status";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null link_info, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_link_get_flow_control_status(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[2];
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_link_get_flow_control_status";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_link_get_flow_control_status";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null link_info", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_link_get_flow_control_status";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null link_info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_link_get_flow_control_status";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null link_info, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_link_get_flow_control_status";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null link_info, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_link_get_local_congestion_info(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_link_get_local_congestion_info";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        __nwlog_obj();
        int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_link_get_local_congestion_info";
          uint64_t v7 = "%{public}s called with null link_congestion_info, backtrace limit exceeded";
          goto LABEL_46;
        }

        goto LABEL_47;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      BOOL v11 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_link_get_local_congestion_info";
          uint64_t v7 = "%{public}s called with null link_congestion_info, no backtrace";
          goto LABEL_46;
        }

        goto LABEL_47;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = "nw_link_get_local_congestion_info";
        __int16 v20 = 2082;
        uint64_t v21 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null link_congestion_info, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_48;
    }

    __nwlog_obj();
    int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_link_get_local_congestion_info";
    uint64_t v7 = "%{public}s called with null link_congestion_info";
LABEL_46:
    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_47;
  }

  if (a2)
  {
    if (a3)
    {
      *a2 = *a1;
      *a3 = a1[1];
      return;
    }

    __nwlog_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_link_get_local_congestion_info";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v4, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_link_get_local_congestion_info";
          uint64_t v7 = "%{public}s called with null pkt_count";
          goto LABEL_46;
        }

void nw_link_set_local_congestion_info(_DWORD *a1, int a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *a1 = a2;
    a1[1] = a3;
    return;
  }

  __nwlog_obj();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v13 = "nw_link_set_local_congestion_info";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_link_set_local_congestion_info";
        uint64_t v7 = "%{public}s called with null link_congestion_info";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      }
    }

    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v6 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v13 = "nw_link_set_local_congestion_info";
            __int16 v14 = 2082;
            BOOL v15 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null link_congestion_info, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v9) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_link_set_local_congestion_info";
        uint64_t v7 = "%{public}s called with null link_congestion_info, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_link_set_local_congestion_info";
        uint64_t v7 = "%{public}s called with null link_congestion_info, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

double __nw_protocol_webtransport_identifier_block_invoke()
{
  unk_18C5A3715 = 0LL;
  unk_18C5A370D = 0LL;
  dword_18C5A371C = 0;
  strcpy((char *)nw_protocol_webtransport_identifier::protocol_identifier, "webtransport");
  *(void *)&double result = 0x200000004LL;
  qword_18C5A3720 = 0x200000004LL;
  return result;
}

BOOL nw_protocol_webtransport_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v7 = (char *)calloc(1uLL, 0x228uLL);
  if (!v7)
  {
    os_log_type_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = 1LL;
    *(_WORD *)&buf[22] = 2048;
    uint64_t v21 = 552LL;
    BOOL v13 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v13);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v13);
  }

  bzero(v7, 0x228uLL);
  *((void *)v7 + 2) = a1;
  *((void *)v7 + 3) = &nw_protocol_webtransport_session_callbacks(void)::protocol_callbacks;
  *((void *)v7 + 5) = v7;
  *((void *)v7 + 8) = &nw_protocol_webtransport_session_get_listen_callbacks(void)::listen_protocol_callbacks;
  *((void *)v7 + 11) = v7;
  *((void *)v7 + 12) = 0LL;
  *((void *)v7 + 13) = v7 + 96;
  *((void *)v7 + 14) = 0LL;
  *((void *)v7 + 17) = 0LL;
  *((void *)v7 + 18) = -1LL;
  *((void *)v7 + 15) = v7 + 112;
  *((void *)v7 + 16) = 0LL;
  *((void *)v7 + 19) = 0LL;
  *((void *)v7 + 20) = 0LL;
  *((_WORD *)v7 + 84) = 0;
  if (a3) {
    a3 = os_retain(a3);
  }
  char v8 = v7[368];
  if ((v8 & 1) != 0)
  {
    BOOL v9 = (void *)*((void *)v7 + 45);
    if (v9)
    {
      os_release(v9);
      char v8 = v7[368];
    }
  }

  *((void *)v7 + 45) = a3;
  v7[368] = v8 | 1;
  *((_DWORD *)v7 + 112) = 2;
  *((void *)v7 + 55) = 0LL;
  *((void *)v7 + 22) = -1LL;
  v7[548] = v7[548] & 0xFE | nw_parameters_get_server_mode(a4);
  *((void *)v7 + 23) = 0LL;
  *((void *)v7 + 24) = 0LL;
  *((void *)v7 + 41) = 0LL;
  *((void *)v7 + 42) = v7 + 328;
  *((_DWORD *)v7 + 114) = 0;
  else {
    char v10 = 0;
  }
  v7[548] = v7[548] & 0xFD | v10;
  *((void *)v7 + 49) = nw_parameters_copy_context(a4);
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  uint64_t v21 = (uint64_t)v7;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 0x40000000LL;
  aBlock[2] = __nw_protocol_webtransport_create_block_invoke;
  aBlock[3] = &unk_189BBC390;
  void aBlock[4] = buf;
  *((void *)v7 + 54) = _Block_copy(aBlock);
  _Block_object_dispose(buf, 8);
  if ((v7[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      __int16 v14 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        BOOL v15 = v7 + 464;
        int v16 = *((_DWORD *)v7 + 115);
        __int16 v17 = " ";
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_create";
        *(_WORD *)&buf[12] = 2082;
        char v18 = v7[548];
        if (!v7) {
          __int16 v17 = "";
        }
        *(_DWORD *)buf = 136447234;
        if (!v7) {
          BOOL v15 = "";
        }
        *(void *)&buf[14] = v15;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v21 = (uint64_t)v17;
        __int16 v22 = 1024;
        int v23 = v16;
        __int16 v24 = 1024;
        int v25 = v18 & 1;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Created webtransport, server mode: %d",  buf,  0x2Cu);
      }
    }
  }

  return (BOOL)v7;
}

uint64_t __nw_protocol_webtransport_create_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void ___ZL53nw_protocol_webtransport_session_get_listen_callbacksv_block_invoke()
{
  nw_protocol_webtransport_session_get_listen_callbacks(void)::listen_protocol_callbacks = (uint64_t)nw_protocol_webtransport_session_listen_protocol_new_flow;
  *(void *)algn_18C5A3B98 = nw_protocol_webtransport_session_listen_protocol_disconnected;
}

uint64_t nw_protocol_webtransport_session_listen_protocol_new_flow( nw_listen_protocol *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v112 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v100[0]) = 0;
    if (__nwlog_fault(v11, type, v100))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          __int16 v14 = "%{public}s called with null listener";
LABEL_48:
          _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        }
      }

      else if (LOBYTE(v100[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type[0];
        BOOL v66 = os_log_type_enabled(v12, type[0]);
        if (backtrace_string)
        {
          if (!v66) {
            goto LABEL_25;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          int v23 = "%{public}s called with null listener, dumping backtrace:%{public}s";
          goto LABEL_24;
        }

        if (v66)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          __int16 v14 = "%{public}s called with null listener, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          __int16 v14 = "%{public}s called with null listener, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }

void nw_protocol_webtransport_session_listen_protocol_disconnected( nw_listen_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault(v6, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          BOOL v9 = "%{public}s called with null listener";
LABEL_29:
          _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v35 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v35)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          BOOL v9 = "%{public}s called with null listener, no backtrace";
          goto LABEL_29;
        }
      }

      else
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          BOOL v9 = "%{public}s called with null listener, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }

uint64_t ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v4 = object;
    int v5 = *(_DWORD *)(a1 + 32);
    os_log_type_t v6 = *(void **)(object + 48);
    if (v5) {
      nw_protocol_error(*(void **)(object + 48), object);
    }
    nw_protocol_disconnected(v6, v4);
    return 1LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v17 = "nw_webtransport_stream_terminate";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_webtransport_stream_terminate";
      int v11 = "%{public}s called with null webtransport_stream";
      goto LABEL_19;
    }

    if (!v14)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_webtransport_stream_terminate";
      int v11 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_19;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        int v17 = "nw_webtransport_stream_terminate";
        __int16 v18 = 2082;
        uint32_t v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_20;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      int v17 = "nw_webtransport_stream_terminate";
      int v11 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_19:
      _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    }
  }

uint64_t __Block_byref_object_copy__33539(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__33540(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke( void *a1, void *a2)
{
  uint64_t v2 = a2;
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    if (!*(void *)(*(void *)(a1[5] + 8LL) + 40LL) && nw_protocol_options_is_http_messaging(a2))
    {
      if (v2) {
        uint64_t v2 = os_retain(v2);
      }
      uint64_t v4 = *(void *)(a1[5] + 8LL);
      char v5 = *(_BYTE *)(v4 + 48);
      if ((v5 & 1) != 0)
      {
        os_log_type_t v6 = *(void **)(v4 + 40);
        if (v6)
        {
          os_release(v6);
          char v5 = *(_BYTE *)(v4 + 48);
        }
      }

      *(void *)(v4 + 40) = v2;
      *(_BYTE *)(v4 + 48) = v5 | 1;
    }
  }

  else if (nw_protocol_options_get_protocol_handle(a2) == a1[6])
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
  }

uint64_t ___ZL57nw_protocol_webtransport_session_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke( uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (result) {
    return nw_protocol_connect(*(void *)(result + 32), result);
  }
  return result;
}

void ___ZL42nw_protocol_webtransport_session_callbacksv_block_invoke()
{
  qword_18C5A3830 = (uint64_t)nw_protocol_default_reset;
  unk_18C5A3838 = nw_protocol_default_input_flush;
  qword_18C5A3800 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C5A3808 = nw_protocol_default_waiting_for_output;
  qword_18C5A37C0 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C5A37C8 = nw_protocol_default_unregister_notification;
  nw_protocol_webtransport_session_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_session_add_input_handler;
  *(void *)algn_18C5A3738 = nw_protocol_webtransport_session_remove_input_handler;
  qword_18C5A3740 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_18C5A3748 = nw_protocol_webtransport_session_connect;
  qword_18C5A3750 = (uint64_t)nw_protocol_webtransport_session_disconnect;
  unk_18C5A3758 = nw_protocol_webtransport_session_connected;
  qword_18C5A3760 = (uint64_t)nw_protocol_webtransport_session_disconnected;
  unk_18C5A3768 = nw_protocol_webtransport_session_error;
  qword_18C5A3770 = (uint64_t)nw_protocol_webtransport_session_input_available;
  unk_18C5A3778 = nw_protocol_webtransport_session_output_available;
  qword_18C5A3780 = (uint64_t)nw_protocol_webtransport_session_get_input_frames;
  unk_18C5A3788 = nw_protocol_webtransport_session_get_output_frames;
  qword_18C5A3790 = (uint64_t)nw_protocol_webtransport_session_finalize_output_frames;
  unk_18C5A3798 = nw_protocol_default_link_state;
  qword_18C5A37A0 = (uint64_t)nw_protocol_webtransport_session_get_parameters;
  unk_18C5A37A8 = nw_protocol_default_get_path;
  qword_18C5A37B0 = (uint64_t)nw_protocol_default_get_local;
  unk_18C5A37B8 = nw_protocol_webtransport_session_get_remote_endpoint;
  qword_18C5A37D0 = (uint64_t)nw_protocol_webtransport_session_notify;
  unk_18C5A37D8 = nw_protocol_default_updated_path;
  qword_18C5A37E0 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_18C5A37E8 = nw_protocol_webtransport_session_input_finished;
  qword_18C5A37F0 = (uint64_t)nw_protocol_webtransport_session_output_finished;
  unk_18C5A37F8 = nw_protocol_default_get_output_local;
  qword_18C5A3810 = (uint64_t)nw_protocol_webtransport_session_copy_info;
  unk_18C5A3818 = nw_protocol_webtransport_session_add_listen_handler;
  qword_18C5A3820 = (uint64_t)nw_protocol_webtransport_session_remove_listen_handler;
  unk_18C5A3828 = nw_protocol_default_get_message_properties;
}

BOOL nw_protocol_webtransport_session_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v357 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    unsigned int v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (aBlock == 17)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null protocol";
      goto LABEL_481;
    }

    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_481;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v209 = (os_log_s *)__nwlog_obj();
    os_log_type_t v210 = aBlock;
    BOOL v217 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v217) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_481;
    }

    if (!v217) {
      goto LABEL_394;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_393:
    _os_log_impl(&dword_181A5C000, v209, v210, v218, buf, 0x16u);
    goto LABEL_394;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    unsigned int v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (aBlock == 17)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null webtransport_session";
      goto LABEL_481;
    }

    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_481;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v209 = (os_log_s *)__nwlog_obj();
    os_log_type_t v210 = aBlock;
    BOOL v219 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v219) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_481;
    }

    if (!v219) {
      goto LABEL_394;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
    goto LABEL_393;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    unsigned int v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (aBlock == 17)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null input_protocol";
      goto LABEL_481;
    }

    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_481;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v209 = (os_log_s *)__nwlog_obj();
    os_log_type_t v210 = aBlock;
    BOOL v220 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v220) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_481;
    }

    if (!v220) {
      goto LABEL_394;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_393;
  }

  if ((handle[137] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v212 = a2;
      v213 = (os_log_s *)__nwlog_obj();
      BOOL v214 = os_log_type_enabled(v213, OS_LOG_TYPE_DEBUG);
      a2 = v212;
      if (v214)
      {
        int v215 = handle[115];
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 116;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v215;
        _os_log_impl(&dword_181A5C000, v213, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        a2 = v212;
      }
    }
  }

  if (handle[111] == 5)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      if (result)
      {
        int v6 = handle[115];
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 116;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v6;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> cannot add input handler to closed session",  buf,  0x26u);
        return 0LL;
      }

      return result;
    }

    return 0LL;
  }

  uint64_t v7 = a2;
  uint64_t parameters = nw_protocol_get_parameters((uint64_t)a2);
  if (!parameters)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    unsigned int v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (aBlock == 17)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null parameters";
      goto LABEL_481;
    }

    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_481;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v209 = (os_log_s *)__nwlog_obj();
    os_log_type_t v210 = aBlock;
    BOOL v242 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v242) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_481;
    }

    if (!v242) {
      goto LABEL_394;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
    goto LABEL_393;
  }

  BOOL v9 = (uint64_t *)parameters;
  v329 = v7;
  uint64_t remote_endpoint = nw_protocol_get_remote_endpoint((uint64_t)v7);
  if (!remote_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    unsigned int v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (aBlock == 17)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null remote_endpoint";
      goto LABEL_481;
    }

    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v209 = (os_log_s *)__nwlog_obj();
      os_log_type_t v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock)) {
        goto LABEL_482;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null remote_endpoint, backtrace limit exceeded";
      goto LABEL_481;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v209 = (os_log_s *)__nwlog_obj();
    os_log_type_t v210 = aBlock;
    BOOL v243 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (backtrace_string)
    {
      if (v243)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v218 = "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s";
        goto LABEL_393;
      }

LABEL_394:
      free(backtrace_string);
      goto LABEL_482;
    }

    if (!v243) {
      goto LABEL_482;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    v211 = "%{public}s called with null remote_endpoint, no backtrace";
LABEL_481:
    _os_log_impl(&dword_181A5C000, v209, v210, v211, buf, 0xCu);
LABEL_482:
    if (v208) {
      free(v208);
    }
    return 0LL;
  }

  int v11 = (void *)remote_endpoint;
  if (*((void *)handle + 43)) {
    goto LABEL_35;
  }
  os_log_type_t v12 = v9;
  BOOL v13 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v12,  0,  1);

  char v14 = nw_parameters_copy_protocol_options_legacy((void *)v13, (nw_protocol *)handle);
  nw_protocol_options_get_log_id_str(v14, (_BYTE *)handle + 464, 84LL);
  handle[115] = nw_protocol_get_next_instance_id();
  uint64_t v15 = v14;
  int v16 = v15;
  if (!v15)
  {
    __nwlog_obj();
    v247 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_options_get_top_id";
    v327 = (const char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    v248 = (char *)v327;
    if (!__nwlog_fault(v327, &aBlock, v339))
    {
LABEL_537:
      if (v248) {
        free(v248);
      }
      int v17 = 0;
      goto LABEL_15;
    }

    if (aBlock == 17)
    {
      __nwlog_obj();
      v249 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v250 = aBlock;
      if (os_log_type_enabled(v249, (os_log_type_t)aBlock))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_options_get_top_id";
        _os_log_impl(&dword_181A5C000, v249, v250, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else
    {
      if (v339[0])
      {
        v271 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v272 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t type = aBlock;
        BOOL v273 = os_log_type_enabled(v272, (os_log_type_t)aBlock);
        if (v271)
        {
          if (v273)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_options_get_top_id";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v271;
            _os_log_impl( &dword_181A5C000,  v272,  type,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v271);
          goto LABEL_536;
        }

        if (v273)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_options_get_top_id";
          _os_log_impl(&dword_181A5C000, v272, type, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v272 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v294 = aBlock;
        if (os_log_type_enabled(v272, (os_log_type_t)aBlock))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_options_get_top_id";
          _os_log_impl( &dword_181A5C000,  v272,  v294,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_503:
  if (v235) {
    free(v235);
  }
LABEL_69:
  uint64_t v47 = nw_parameters_copy_protocol_options_legacy((void *)v30[18], (nw_protocol *)v30);
  if (v47)
  {
    uint64_t v48 = v47;
    uint64_t v49 = v48;
    uint64_t v50 = 0LL;
    *((_BYTE *)v30 + 192) = 0;
    int v51 = (char *)(v30 + 24);
    unint64_t v52 = 84LL;
    while (1)
    {
      int v53 = v48[v50 + 48];
      v51[v50] = v53;
      if (!v53) {
        break;
      }
      --v52;
      ++v50;
      if (v52 <= 1)
      {
        v51[v50] = 0;
        break;
      }
    }

    os_release(v49);
  }

  else if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v58 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v59 = v30[11];
      if (v59) {
        int v60 = *(_DWORD *)(v59 + 460);
      }
      else {
        int v60 = -1;
      }
      uint64_t v63 = v30[8];
      BOOL v64 = (void *)v30[18];
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v30 + 24;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v60;
      *(_WORD *)&v345[6] = 2048;
      *(void *)&v345[8] = v63;
      *(_WORD *)&v345[16] = 2048;
      *(void *)&v345[18] = v30;
      *(_WORD *)&v345[26] = 2048;
      v346 = v64;
      _os_log_impl( &dword_181A5C000,  v58,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Failed to access options for protocol %p, parameters %p",  buf,  0x44u);
    }
  }

      if (v341) {
        free(v341);
      }
      LODWORD(v331) = 0;
LABEL_506:

      break;
    }

    uint64_t v333 = v309->used_timestamps;
    if (!v333) {
      goto LABEL_506;
    }
    v334 = 0LL;
    v335 = 0LL;
    LODWORD(v336) = -1;
    v337 = v331;
    while (1)
    {
      v339 = v309->timestamps;
      if (*(unsigned __int16 *)((char *)&v339->var1.event + v334) == 1
        && *(unsigned __int16 *)((char *)&v339->var1.domain + v334) == 6)
      {
        break;
      }

      v338 = v337;
LABEL_479:
      ++v335;
      v334 += 16LL;
      v337 = v338;
      if (v335 >= v333) {
        goto LABEL_485;
      }
    }

    v338 = (v337 - 1);
    v336 = nw_delta_nanos(v309->start_time, *(unint64_t *)((char *)&v339->var0 + v334)) / 0xF4240uLL;
    if ((_DWORD)v337 == -1)
    {
      uint64_t v333 = v309->used_timestamps;
      v338 = 0xFFFFFFFFLL;
      goto LABEL_479;
    }

LABEL_598:
      if (v301) {
        free(v301);
      }
      char v205 = 0;
      v107 = v328;
LABEL_319:
      _Block_object_dispose(buf, 8);
      if ((v345[16] & 1) != 0 && *(void *)&v345[8]) {
        os_release(*(void **)&v345[8]);
      }
      _Block_object_dispose(v339, 8);
      if (v191) {
        os_release(v191);
      }
      if ((v205 & 1) == 0) {
        goto LABEL_580;
      }
      goto LABEL_325;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v286 = (char *)_os_log_send_and_compose_impl();
    v339[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v353) = 0;
    if (v339[0] == OS_LOG_TYPE_FAULT)
    {
      v287 = (os_log_s *)__nwlog_obj();
      os_log_type_t v288 = v339[0];
      if (!os_log_type_enabled(v287, v339[0])) {
        goto LABEL_578;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
      v289 = "%{public}s called with null parameters";
      goto LABEL_576;
    }

    if (!(_BYTE)v353)
    {
      v287 = (os_log_s *)__nwlog_obj();
      os_log_type_t v288 = v339[0];
      if (!os_log_type_enabled(v287, v339[0])) {
        goto LABEL_578;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
      v289 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_576;
    }

    v307 = (char *)__nw_create_backtrace_string();
    v298 = (os_log_s *)__nwlog_obj();
    os_log_type_t v299 = v339[0];
    BOOL v308 = os_log_type_enabled(v298, v339[0]);
    if (v307)
    {
      if (v308)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v307;
        _os_log_impl( &dword_181A5C000,  v298,  v299,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v307);
      if (!v286) {
        goto LABEL_580;
      }
LABEL_579:
      free(v286);
      goto LABEL_580;
    }

    if (v308)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
      v289 = "%{public}s called with null parameters, no backtrace";
LABEL_603:
      v315 = v298;
      os_log_type_t v316 = v299;
      goto LABEL_577;
    }

    goto LABEL_578;
  }

  if (!nw_protocol_add_input_handler(*(void *)(v80 + 32), (uint64_t)v30))
  {
LABEL_580:
    if ((*((_BYTE *)v30 + 276) & 0x10) != 0) {
      goto LABEL_587;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v165 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_587;
    }
    uint64_t v317 = v30[11];
    if (v317) {
      int v318 = *(_DWORD *)(v317 + 460);
    }
    else {
      int v318 = -1;
    }
    uint64_t v319 = v30[8];
    *(_DWORD *)buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v30 + 24;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v344 = (uint64_t)" ";
    *(_WORD *)v345 = 1024;
    *(_DWORD *)&v345[2] = v318;
    *(_WORD *)&v345[6] = 2048;
    *(void *)&v345[8] = v319;
    v172 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
LABEL_586:
    _os_log_impl(&dword_181A5C000, v165, OS_LOG_TYPE_ERROR, v172, buf, 0x30u);
LABEL_587:
    v320 = (void *)v30[6];
    nw_protocol_error(v320, (uint64_t)v30);
    nw_protocol_disconnected(v320, (uint64_t)v30);
    goto LABEL_588;
  }

                if (v256) {
                  free(v256);
                }
                uint64_t v150 = v255;
LABEL_601:
                if (!nw_ip_options_get_use_minimum_mtu(v190)
                  || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 41, 42, &v551, 4u))
                {
                  goto LABEL_627;
                }

                v264 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                uint64_t v265 = (os_log_s *)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 2080;
                  *(void *)v555 = (char *)a1 + 404;
                  *(_WORD *)&v555[8] = 1024;
                  *(_DWORD *)&v555[10] = v264;
                  _os_log_impl( &dword_181A5C000,  v265,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d",  buf,  0x1Cu);
                }

                int v266 = (os_log_s *)__nwlog_obj();
                v267 = v266;
                if (v264 == 22)
                {
                  if (os_log_type_enabled(v266, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = 22;
                    _os_log_impl( &dword_181A5C000,  v267,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d",  buf,  0x12u);
                  }

                  goto LABEL_627;
                }

                BOOL v268 = v150;
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v264;
                v269 = (char *)_os_log_send_and_compose_impl();
                v547[0] = OS_LOG_TYPE_ERROR;
                v545[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v269, v547, v545))
                {
                  if (v547[0] == OS_LOG_TYPE_FAULT)
                  {
                    BOOL v270 = (os_log_s *)__nwlog_obj();
                    v271 = v547[0];
                    if (os_log_type_enabled(v270, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v264;
                      v272 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d";
LABEL_623:
                      _os_log_impl(&dword_181A5C000, v270, v271, v272, buf, 0x12u);
                    }
                  }

                  else if (v545[0])
                  {
                    BOOL v273 = (char *)__nw_create_backtrace_string();
                    BOOL v270 = (os_log_s *)__nwlog_obj();
                    v271 = v547[0];
                    v274 = os_log_type_enabled(v270, v547[0]);
                    if (v273)
                    {
                      if (v274)
                      {
                        *(_DWORD *)buf = 136446722;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v264;
                        *(_WORD *)&v555[4] = 2082;
                        *(void *)&v555[6] = v273;
                        _os_log_impl( &dword_181A5C000,  v270,  v271,  "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
                      }

                      free(v273);
                      uint64_t v192 = identifier_low;
                      goto LABEL_624;
                    }

                    uint64_t v192 = identifier_low;
                    if (v274)
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v264;
                      v272 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, no backtrace";
                      goto LABEL_623;
                    }
                  }

                  else
                  {
                    BOOL v270 = (os_log_s *)__nwlog_obj();
                    v271 = v547[0];
                    if (os_log_type_enabled(v270, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v264;
                      v272 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_623;
                    }
                  }
                }

void sub_18209F6C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_webtransport_session_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v159 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    char v110 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v137[0]))
      {
        char v111 = (os_log_s *)__nwlog_obj();
        os_log_type_t v112 = type[0];
        if (os_log_type_enabled(v111, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          uint64_t v113 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_243;
        }

        goto LABEL_244;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v111 = (os_log_s *)__nwlog_obj();
      os_log_type_t v112 = type[0];
      BOOL v115 = os_log_type_enabled(v111, type[0]);
      if (!backtrace_string)
      {
        if (v115)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          uint64_t v113 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_243;
        }

        goto LABEL_244;
      }

      if (!v115) {
        goto LABEL_219;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
      __int16 v151 = 2082;
      uint64_t v152 = backtrace_string;
      uint64_t v116 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_218;
    }

    char v111 = (os_log_s *)__nwlog_obj();
    os_log_type_t v112 = type[0];
    if (!os_log_type_enabled(v111, type[0])) {
      goto LABEL_244;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    uint64_t v113 = "%{public}s called with null protocol";
LABEL_243:
    _os_log_impl(&dword_181A5C000, v111, v112, v113, buf, 0xCu);
    goto LABEL_244;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    char v110 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v137[0]))
      {
        char v111 = (os_log_s *)__nwlog_obj();
        os_log_type_t v112 = type[0];
        if (os_log_type_enabled(v111, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          uint64_t v113 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
          goto LABEL_243;
        }

        goto LABEL_244;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v111 = (os_log_s *)__nwlog_obj();
      os_log_type_t v112 = type[0];
      BOOL v117 = os_log_type_enabled(v111, type[0]);
      if (!backtrace_string)
      {
        if (v117)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          uint64_t v113 = "%{public}s called with null webtransport_session, no backtrace";
          goto LABEL_243;
        }

        goto LABEL_244;
      }

      if (!v117) {
        goto LABEL_219;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
      __int16 v151 = 2082;
      uint64_t v152 = backtrace_string;
      uint64_t v116 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_218;
    }

    char v111 = (os_log_s *)__nwlog_obj();
    os_log_type_t v112 = type[0];
    if (!os_log_type_enabled(v111, type[0])) {
      goto LABEL_244;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    uint64_t v113 = "%{public}s called with null webtransport_session";
    goto LABEL_243;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    char v110 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v111 = (os_log_s *)__nwlog_obj();
      os_log_type_t v112 = type[0];
      if (!os_log_type_enabled(v111, type[0])) {
        goto LABEL_244;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
      uint64_t v113 = "%{public}s called with null input_protocol";
      goto LABEL_243;
    }

    if (!LOBYTE(v137[0]))
    {
      char v111 = (os_log_s *)__nwlog_obj();
      os_log_type_t v112 = type[0];
      if (os_log_type_enabled(v111, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        uint64_t v113 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_243;
      }

      goto LABEL_244;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v111 = (os_log_s *)__nwlog_obj();
    os_log_type_t v112 = type[0];
    BOOL v118 = os_log_type_enabled(v111, type[0]);
    if (!backtrace_string)
    {
      if (v118)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        uint64_t v113 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_243;
      }

      goto LABEL_244;
    }

    if (!v118) {
      goto LABEL_219;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    __int16 v151 = 2082;
    uint64_t v152 = backtrace_string;
    uint64_t v116 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_218:
    _os_log_impl(&dword_181A5C000, v111, v112, v116, buf, 0x16u);
    goto LABEL_219;
  }

  char v5 = (char *)a2->handle;
  if (v5)
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v6 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        int v7 = *((_DWORD *)handle + 115);
        default_input_handler = a1->default_input_handler;
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        __int16 v151 = 2082;
        uint64_t v152 = handle + 464;
        __int16 v153 = 2080;
        uint64_t v154 = (uint64_t)" ";
        __int16 v155 = 1024;
        *(_DWORD *)uint64_t v156 = v7;
        *(_WORD *)&v156[4] = 2048;
        *(void *)&v156[6] = a1;
        *(_WORD *)&v156[14] = 2048;
        *(void *)&v156[16] = default_input_handler;
        __int16 v157 = 2048;
        uint64_t v158 = a2;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> called, protocol %p, default_input_handler %p, input protocol %p",  buf,  0x44u);
      }
    }

    uint32_t v136 = handle;
    if ((v5[276] & 0x20) == 0)
    {
      if (*((char **)handle + 52) == v5)
      {
        if ((handle[548] & 2) == 0)
        {
          if (gLogDatapath)
          {
            BOOL v125 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
            {
              int v126 = *((_DWORD *)handle + 115);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
              __int16 v151 = 2082;
              uint64_t v152 = handle + 464;
              __int16 v153 = 2080;
              uint64_t v154 = (uint64_t)" ";
              __int16 v155 = 1024;
              *(_DWORD *)uint64_t v156 = v126;
              _os_log_impl( &dword_181A5C000,  v125,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Removing placeholder stream for session",  buf,  0x26u);
            }
          }
        }

        *((void *)handle + 52) = 0LL;
        goto LABEL_69;
      }

      if (*((char **)handle + 53) == v5)
      {
        if ((handle[548] & 2) == 0)
        {
          if (gLogDatapath)
          {
            v127 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
            {
              int v128 = *((_DWORD *)handle + 115);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
              __int16 v151 = 2082;
              uint64_t v152 = handle + 464;
              __int16 v153 = 2080;
              uint64_t v154 = (uint64_t)" ";
              __int16 v155 = 1024;
              *(_DWORD *)uint64_t v156 = v128;
              _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Removing datagram stream for session",  buf,  0x26u);
            }
          }
        }

        *((void *)handle + 53) = 0LL;
        goto LABEL_69;
      }

      *(void *)os_log_type_t type = *((void *)v5 + 8);
      BOOL node = nw_hash_table_get_node(*((void *)handle + 23), (uint64_t)type, 8LL);
      if (node)
      {
        if (nw_hash_table_remove_node(*((void *)handle + 23), node)) {
          goto LABEL_69;
        }
        if ((handle[548] & 2) != 0) {
          goto LABEL_69;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_69;
        }
        int v11 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        __int16 v151 = 2082;
        uint64_t v152 = handle + 464;
        __int16 v153 = 2080;
        uint64_t v154 = (uint64_t)" ";
        __int16 v155 = 1024;
        *(_DWORD *)uint64_t v156 = v11;
        *(_WORD *)&v156[4] = 2048;
        *(void *)&v156[6] = *(void *)type;
        os_log_type_t v12 = "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table";
      }

      else
      {
        if ((handle[548] & 2) != 0) {
          goto LABEL_69;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_69;
        }
        int v28 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        __int16 v151 = 2082;
        uint64_t v152 = handle + 464;
        __int16 v153 = 2080;
        uint64_t v154 = (uint64_t)" ";
        __int16 v155 = 1024;
        *(_DWORD *)uint64_t v156 = v28;
        *(_WORD *)&v156[4] = 2048;
        *(void *)&v156[6] = *(void *)type;
        os_log_type_t v12 = "%{public}s %{public}s%s<i%u> called remove_input_handler with stream id %lld, but no stream found";
      }

      uint64_t v29 = (os_log_s *)v10;
      os_log_type_t v30 = OS_LOG_TYPE_ERROR;
      uint32_t v31 = 48;
LABEL_46:
      _os_log_impl(&dword_181A5C000, v29, v30, v12, buf, v31);
LABEL_69:
      *((void *)v5 + 11) = 0LL;
      if (*((_DWORD *)handle + 111))
      {
        uint64_t v38 = *((void *)handle + 53);
        if (v38)
        {
LABEL_72:
          nw_protocol_set_input_handler((uint64_t)handle, v38);
          if ((handle[548] & 2) != 0) {
            return 1LL;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v39 = (os_log_s *)gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
            return 1LL;
          }
          int v40 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
          __int16 v151 = 2082;
          uint64_t v152 = handle + 464;
          __int16 v153 = 2080;
          uint64_t v154 = (uint64_t)" ";
          __int16 v155 = 1024;
          *(_DWORD *)uint64_t v156 = v40;
          nw_protocol_options_t v41 = "%{public}s %{public}s%s<i%u> not destroying, still have datagram stream";
          goto LABEL_75;
        }
      }

      else
      {
        if ((handle[548] & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v43 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            int v44 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
            __int16 v151 = 2082;
            uint64_t v152 = handle + 464;
            __int16 v153 = 2080;
            uint64_t v154 = (uint64_t)" ";
            __int16 v155 = 1024;
            *(_DWORD *)uint64_t v156 = v44;
            _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> first input handler bailed, closing",  buf,  0x26u);
          }
        }

        uint64_t v45 = *((void *)handle + 54);
        int v46 = (void *)*((void *)handle + 49);
        v137[0] = MEMORY[0x1895F87A8];
        v137[1] = 0x40000000LL;
        v137[2] = ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke;
        v137[3] = &unk_189BBC460;
        v137[4] = v45;
        nw_queue_context_async(v46, v137);
        uint64_t v38 = *((void *)handle + 53);
        if (v38) {
          goto LABEL_72;
        }
      }

      uint64_t v47 = (os_unfair_lock_s *)*((void *)handle + 23);
      if (v47 && v47[10]._os_unfair_lock_opaque)
      {
        some_BOOL node = nw_hash_table_get_some_node(v47);
        uint64_t object = nw_hash_node_get_object(some_node);
        nw_protocol_set_input_handler((uint64_t)handle, object);
        if ((handle[548] & 2) != 0) {
          return 1LL;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v39 = (os_log_s *)gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          return 1LL;
        }
        int v50 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        __int16 v151 = 2082;
        uint64_t v152 = handle + 464;
        __int16 v153 = 2080;
        uint64_t v154 = (uint64_t)" ";
        __int16 v155 = 1024;
        *(_DWORD *)uint64_t v156 = v50;
        nw_protocol_options_t v41 = "%{public}s %{public}s%s<i%u> not destroying, still have active streams";
        goto LABEL_75;
      }

      if (*((_DWORD *)handle + 114))
      {
        uint64_t v51 = *((void *)handle + 41);
        if (v51)
        {
          if ((*(_BYTE *)(v51 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              uint64_t v131 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v132 = *(void *)(v51 + 88);
                if (v132) {
                  int v133 = *(_DWORD *)(v132 + 460);
                }
                else {
                  int v133 = -1;
                }
                uint64_t v134 = *(void *)(v51 + 64);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
                __int16 v151 = 2082;
                uint64_t v152 = (const char *)(v51 + 192);
                __int16 v153 = 2080;
                uint64_t v154 = (uint64_t)" ";
                __int16 v155 = 1024;
                *(_DWORD *)uint64_t v156 = v133;
                *(_WORD *)&v156[4] = 2048;
                *(void *)&v156[6] = v134;
                *(_WORD *)&v156[14] = 2048;
                *(void *)&v156[16] = v51;
                _os_log_impl( &dword_181A5C000,  v131,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)",  buf,  0x3Au);
              }
            }
          }
        }

        nw_protocol_set_input_handler((uint64_t)handle, v51);
        if ((handle[548] & 2) != 0) {
          return 1LL;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v39 = (os_log_s *)gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          return 1LL;
        }
        int v52 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        __int16 v151 = 2082;
        uint64_t v152 = handle + 464;
        __int16 v153 = 2080;
        uint64_t v154 = (uint64_t)" ";
        __int16 v155 = 1024;
        *(_DWORD *)uint64_t v156 = v52;
        nw_protocol_options_t v41 = "%{public}s %{public}s%s<i%u> not destroying, still have pending streams";
LABEL_75:
        _os_log_impl(&dword_181A5C000, v39, OS_LOG_TYPE_INFO, v41, buf, 0x26u);
        return 1LL;
      }

      uint64_t v53 = *((void *)handle + 52);
      if (v53)
      {
        nw_protocol_set_input_handler((uint64_t)handle, v53);
        if ((handle[548] & 2) != 0) {
          return 1LL;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v39 = (os_log_s *)gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          return 1LL;
        }
        int v54 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        __int16 v151 = 2082;
        uint64_t v152 = handle + 464;
        __int16 v153 = 2080;
        uint64_t v154 = (uint64_t)" ";
        __int16 v155 = 1024;
        *(_DWORD *)uint64_t v156 = v54;
        nw_protocol_options_t v41 = "%{public}s %{public}s%s<i%u> not destroying, still have placeholder stream";
        goto LABEL_75;
      }

      nw_protocol_set_input_handler((uint64_t)handle, 0LL);
      if ((handle[548] & 2) == 0)
      {
        int v55 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
        {
          int v56 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          __int16 v151 = 2082;
          uint64_t v152 = handle + 464;
          __int16 v153 = 2080;
          uint64_t v154 = (uint64_t)" ";
          __int16 v155 = 1024;
          *(_DWORD *)uint64_t v156 = v56;
          _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> called, destroying session",  buf,  0x26u);
        }
      }

      *(void *)buf = 0LL;
      nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(handle + 344), buf);
      *(void *)buf = 0LL;
      nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(handle + 360), buf);
      *(void *)buf = 0LL;
      nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(handle + 376), buf);
      nw_http_capsule_framer_cleanup((void *)handle + 12, v57);
      uint64_t v58 = *((void *)handle + 50);
      if (v58) {
        (*(void (**)(uint64_t, char *, void))(*(void *)v58 + 8LL))(v58, handle, 0LL);
      }
      if ((handle[548] & 4) != 0)
      {
        if ((nw_protocol_remove_listen_handler(*((void *)handle + 51), (uint64_t)(handle + 64)) & 1) == 0
          && (handle[548] & 2) == 0)
        {
          uint64_t v59 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
          {
            int v60 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
            __int16 v151 = 2082;
            uint64_t v152 = handle + 464;
            __int16 v153 = 2080;
            uint64_t v154 = (uint64_t)" ";
            __int16 v155 = 1024;
            *(_DWORD *)uint64_t v156 = v60;
            _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> failed to remove listen handler",  buf,  0x26u);
          }
        }

        *((void *)handle + 51) = 0LL;
      }

      uint64_t v61 = *((void *)handle + 4);
      if (v61) {
        nw_protocol_remove_input_handler(v61, (uint64_t)handle);
      }
      uint64_t v144 = 0LL;
      v145 = &v144;
      uint64_t v146 = 0x2000000000LL;
      uint64_t v147 = 0LL;
      BOOL v62 = (char *)*((void *)handle + 23);
      if (v62)
      {
        *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
        uint64_t v139 = 0x40000000LL;
        os_log_type_t v140 = ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke;
        uint64_t v141 = &unk_189BBC4A8;
        os_log_type_t v142 = &v144;
        uint32_t v143 = handle;
        nw_hash_table_apply(v62, (uint64_t)type);
        BOOL v64 = (os_unfair_lock_s *)*((void *)handle + 23);
        if (v64)
        {
          _nw_hash_table_release(v64, v63);
          *((void *)handle + 23) = 0LL;
        }
      }

      uint64_t v65 = *((void *)handle + 41);
      v145[3] = v65;
      if (!v65)
      {
        (*(void (**)(void, void))(*((void *)handle + 54) + 16LL))(*((void *)handle + 54), 0LL);
        BOOL v109 = (const void *)*((void *)handle + 54);
        if (v109)
        {
          _Block_release(v109);
          *((void *)handle + 54) = 0LL;
        }

        std::destroy_at[abi:nn180100]<nw_webtransport_session,0>((uint64_t)handle);
        free(handle);
        _Block_object_dispose(&v144, 8);
        return 1LL;
      }

      os_log_type_t v135 = handle + 464;
      while (1)
      {
        uint64_t v65 = *(void *)(v65 + 112);
        if ((handle[548] & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v66 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            int v67 = *((_DWORD *)handle + 115);
            uint64_t v68 = v145[3];
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
            __int16 v151 = 2082;
            uint64_t v152 = v135;
            __int16 v153 = 2080;
            uint64_t v154 = (uint64_t)" ";
            __int16 v155 = 1024;
            *(_DWORD *)uint64_t v156 = v67;
            *(_WORD *)&v156[4] = 2048;
            *(void *)&v156[6] = v68;
            _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways",  buf,  0x30u);
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
        int v69 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t v149 = OS_LOG_TYPE_ERROR;
        char v148 = 0;
        if (__nwlog_fault(v69, &v149, &v148))
        {
          if (v149 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v70 = gLogObj;
            os_log_type_t v71 = v149;
            if (!os_log_type_enabled((os_log_t)gLogObj, v149)) {
              goto LABEL_132;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
            BOOL v72 = (os_log_s *)v70;
            os_log_type_t v73 = v71;
            os_log_type_t v74 = "%{public}s should not have streams left when destroying";
LABEL_131:
            _os_log_impl(&dword_181A5C000, v72, v73, v74, buf, 0xCu);
            goto LABEL_132;
          }

          if (!v148)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v79 = gLogObj;
            os_log_type_t v80 = v149;
            if (!os_log_type_enabled((os_log_t)gLogObj, v149)) {
              goto LABEL_132;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
            BOOL v72 = (os_log_s *)v79;
            os_log_type_t v73 = v80;
            os_log_type_t v74 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
            goto LABEL_131;
          }

          char v75 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v76 = (os_log_s *)gLogObj;
          os_log_type_t v77 = v149;
          BOOL v78 = os_log_type_enabled((os_log_t)gLogObj, v149);
          if (!v75)
          {
            if (!v78) {
              goto LABEL_132;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
            BOOL v72 = v76;
            os_log_type_t v73 = v77;
            os_log_type_t v74 = "%{public}s should not have streams left when destroying, no backtrace";
            goto LABEL_131;
          }

          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
            __int16 v151 = 2082;
            uint64_t v152 = v75;
            _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v75);
        }

uint64_t nw_protocol_webtransport_session_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        BOOL v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
          int v11 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
          int v11 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      if (!v15) {
        goto LABEL_57;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      int v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_56;
    }

    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_77;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
    int v11 = "%{public}s called with null protocol";
LABEL_76:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_77;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        BOOL v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
          int v11 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
          int v11 = "%{public}s called with null webtransport_session, no backtrace";
          goto LABEL_76;
        }

        goto LABEL_77;
      }

      if (!v17) {
        goto LABEL_57;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
      __int16 v26 = 2082;
      __int16 v27 = backtrace_string;
      int v16 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_56;
    }

    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_77;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
    int v11 = "%{public}s called with null webtransport_session";
    goto LABEL_76;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_77;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
      int v11 = "%{public}s called with null other_protocol";
      goto LABEL_76;
    }

    if (!v22)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
        int v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v18 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
        int v11 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    if (!v18) {
      goto LABEL_57;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
    __int16 v26 = 2082;
    __int16 v27 = backtrace_string;
    int v16 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_56:
    _os_log_impl(&dword_181A5C000, v9, v10, v16, buf, 0x16u);
    goto LABEL_57;
  }

  if (!a2->handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
        int v11 = "%{public}s called with null webtransport_stream";
        goto LABEL_76;
      }

void nw_protocol_webtransport_session_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v17 = "nw_protocol_webtransport_session_disconnect";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_webtransport_session_disconnect";
      char v6 = "%{public}s called with null protocol";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v11 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v17 = "nw_protocol_webtransport_session_disconnect";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v3) {
          return;
        }
LABEL_37:
        free(v3);
        return;
      }

      if (!v11) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_webtransport_session_disconnect";
      char v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_webtransport_session_disconnect";
      char v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_session_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v118 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
    BOOL v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v104[0]) = 0;
    if (v112[0] == 17)
    {
      os_log_type_t v73 = (os_log_s *)__nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      char v75 = "%{public}s called with null protocol";
      goto LABEL_152;
    }

    if (!LOBYTE(v104[0]))
    {
      os_log_type_t v73 = (os_log_s *)__nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      char v75 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_152;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v73 = (os_log_s *)__nwlog_obj();
    os_log_type_t v74 = v112[0];
    BOOL v82 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!backtrace_string)
    {
      if (!v82) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      char v75 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_152;
    }

    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_153;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
    BOOL v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v104[0]) = 0;
    if (v112[0] == 17)
    {
      os_log_type_t v73 = (os_log_s *)__nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      char v75 = "%{public}s called with null webtransport_session";
      goto LABEL_152;
    }

    if (!LOBYTE(v104[0]))
    {
      os_log_type_t v73 = (os_log_s *)__nwlog_obj();
      os_log_type_t v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0])) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      char v75 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_152;
    }

    uint64_t v83 = (char *)__nw_create_backtrace_string();
    os_log_type_t v73 = (os_log_s *)__nwlog_obj();
    os_log_type_t v74 = v112[0];
    BOOL v84 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!v83)
    {
      if (!v84) {
        goto LABEL_153;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
      char v75 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_152;
    }

    if (!v84) {
      goto LABEL_142;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v83;
    uint64_t v85 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
    goto LABEL_141;
  }

  if ((handle[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      char v76 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
      {
        int v77 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        os_log_type_t v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v77;
        _os_log_impl( &dword_181A5C000,  v76,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Got a connected event from the lower layer",  buf,  0x26u);
      }
    }
  }

  if (a1->output_handler != a2)
  {
    if ((handle[548] & 2) == 0 && gLogDatapath)
    {
      BOOL v78 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
      {
        int v79 = *((_DWORD *)handle + 115);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_connected";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        os_log_type_t v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v79;
        HIWORD(v109) = 2048;
        char v110 = a2;
        LOWORD(v111) = 2080;
        *(void *)((char *)&v111 + 2) = identifier;
        _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> connected protocol %p (%s) is not our output_handler, ignoring",  buf,  0x3Au);
      }
    }

    return;
  }

  uint64_t v5 = *((void *)handle + 4);
  if (!v5 || *((_DWORD *)handle + 112) != 2) {
    goto LABEL_40;
  }
  char v6 = *(void **)(v5 + 16);
  if (nw_protocol_http2_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http2_identifier::onceToken, &__block_literal_global_83570);
  }
  if (!nw_protocols_are_equal(v6, &nw_protocol_http2_identifier::http2_protocol_identifier))
  {
    int v7 = *(void **)(v5 + 16);
    if (nw_protocol_http3_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http3_identifier::onceToken, &__block_literal_global_10);
    }
    if (!nw_protocols_are_equal(v7, &nw_protocol_http3_identifier::http3_protocol_identifier))
    {
      os_log_type_t v8 = *(void **)(v5 + 16);
      if (nw_protocol_http_messaging_identifier::onceToken != -1) {
        dispatch_once(&nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_76181);
      }
      if (!nw_protocols_are_equal(v8, nw_protocol_http_messaging_identifier::protocol_identifier)) {
        goto LABEL_40;
      }
    }
  }

  int v9 = (unsigned __int8 *)nw_protocol_copy_info(v5, 255);
  v104[0] = MEMORY[0x1895F87A8];
  v104[1] = 0x40000000LL;
  v104[2] = ___ZL33nw_webtransport_session_establishP23nw_webtransport_session_block_invoke;
  v104[3] = &__block_descriptor_tmp_45_34315;
  v104[4] = handle;
  nw_array_apply(v9, (uint64_t)v104);
  os_log_type_t v10 = (void *)*((void *)handle + 47);
  if (!v10)
  {
    if (v9) {
      os_release(v9);
    }
    goto LABEL_68;
  }

  int version = nw_http_connection_metadata_get_version(v10);
  int v12 = version;
  if (version == 4)
  {
    int v13 = 0;
LABEL_27:
    *((_DWORD *)handle + 112) = v13;
    goto LABEL_28;
  }

  if (version == 5)
  {
    int v13 = 1;
    goto LABEL_27;
  }

void nw_protocol_webtransport_session_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_disconnected";
    int v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_disconnected";
      uint64_t v26 = "%{public}s called with null protocol";
    }

    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v31 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_disconnected";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_65:
        if (!v23) {
          return;
        }
LABEL_66:
        free(v23);
        return;
      }

      if (!v31) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_disconnected";
      uint64_t v26 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      __int16 v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_disconnected";
      uint64_t v26 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_session_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_protocol_webtransport_session_error";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_session_error";
      os_log_type_t v8 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v13 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_webtransport_session_error";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_37:
        if (!v5) {
          return;
        }
LABEL_38:
        free(v5);
        return;
      }

      if (!v13) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_session_error";
      os_log_type_t v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_session_error";
      os_log_type_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_session_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v157 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
    char v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v109[0]))
      {
        char v76 = (os_log_s *)__nwlog_obj();
        os_log_type_t v77 = type[0];
        if (!os_log_type_enabled(v76, type[0])) {
          goto LABEL_204;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
        BOOL v78 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_203;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v76 = (os_log_s *)__nwlog_obj();
      os_log_type_t v77 = type[0];
      BOOL v84 = os_log_type_enabled(v76, type[0]);
      if (!backtrace_string)
      {
        if (!v84) {
          goto LABEL_204;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
        BOOL v78 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_203;
      }

      if (v84)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_204;
    }

    char v76 = (os_log_s *)__nwlog_obj();
    os_log_type_t v77 = type[0];
    if (!os_log_type_enabled(v76, type[0])) {
      goto LABEL_204;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
    BOOL v78 = "%{public}s called with null protocol";
LABEL_203:
    _os_log_impl(&dword_181A5C000, v76, v77, v78, buf, 0xCu);
    goto LABEL_204;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
    char v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v109[0]))
      {
        char v76 = (os_log_s *)__nwlog_obj();
        os_log_type_t v77 = type[0];
        if (!os_log_type_enabled(v76, type[0])) {
          goto LABEL_204;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
        BOOL v78 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_203;
      }

      uint64_t v85 = (char *)__nw_create_backtrace_string();
      char v76 = (os_log_s *)__nwlog_obj();
      os_log_type_t v77 = type[0];
      BOOL v86 = os_log_type_enabled(v76, type[0]);
      if (!v85)
      {
        if (!v86) {
          goto LABEL_204;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
        BOOL v78 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_203;
      }

      if (v86)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v85;
        int v87 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
LABEL_182:
        _os_log_impl(&dword_181A5C000, v76, v77, v87, buf, 0x16u);
      }

void nw_protocol_webtransport_session_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
    char v13 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type[0];
      if (!os_log_type_enabled(v14, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
      char v16 = "%{public}s called with null protocol";
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type[0];
      BOOL v20 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v13) {
          return;
        }
LABEL_50:
        free(v13);
        return;
      }

      if (!v20) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
      char v16 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type[0];
      if (!os_log_type_enabled(v14, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
      char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_webtransport_session_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_protocol_webtransport_session_get_input_frames";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      char v21 = "nw_protocol_webtransport_session_get_input_frames";
      char v13 = "%{public}s called with null protocol";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          char v21 = "nw_protocol_webtransport_session_get_input_frames";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v10) {
          return 0LL;
        }
LABEL_36:
        free(v10);
        return 0LL;
      }

      if (!v15) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      char v21 = "nw_protocol_webtransport_session_get_input_frames";
      char v13 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      char v21 = "nw_protocol_webtransport_session_get_input_frames";
      char v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_webtransport_session_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_protocol_webtransport_session_get_output_frames";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      char v21 = "nw_protocol_webtransport_session_get_output_frames";
      char v13 = "%{public}s called with null protocol";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          char v21 = "nw_protocol_webtransport_session_get_output_frames";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v10) {
          return 0LL;
        }
LABEL_36:
        free(v10);
        return 0LL;
      }

      if (!v15) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      char v21 = "nw_protocol_webtransport_session_get_output_frames";
      char v13 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      char v21 = "nw_protocol_webtransport_session_get_output_frames";
      char v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_webtransport_session_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    int v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_webtransport_session_finalize_output_frames";
      BOOL v9 = "%{public}s called with null protocol";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v17 = "nw_protocol_webtransport_session_finalize_output_frames";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v6) {
          return 0LL;
        }
LABEL_36:
        free(v6);
        return 0LL;
      }

      if (!v11) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_webtransport_session_finalize_output_frames";
      BOOL v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_webtransport_session_finalize_output_frames";
      BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_webtransport_session_get_parameters(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[43];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_webtransport_session_get_parameters";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_parameters";
        int v6 = "%{public}s called with null webtransport_session";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_parameters";
        int v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_parameters";
        int v6 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_webtransport_session_get_parameters";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_protocol_webtransport_session_get_parameters";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_parameters";
        int v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_parameters";
        int v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_webtransport_session_get_parameters";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

uint64_t nw_protocol_webtransport_session_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[45];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        int v6 = "%{public}s called with null webtransport_session";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        int v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        int v6 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        int v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        int v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

void nw_protocol_webtransport_session_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_protocol_webtransport_session_notify";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v20 = "nw_protocol_webtransport_session_notify";
      BOOL v10 = "%{public}s called with null protocol";
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v20 = "nw_protocol_webtransport_session_notify";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_37:
        if (!v7) {
          return;
        }
LABEL_38:
        free(v7);
        return;
      }

      if (!v14) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v20 = "nw_protocol_webtransport_session_notify";
      BOOL v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v20 = "nw_protocol_webtransport_session_notify";
      BOOL v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_session_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_protocol_webtransport_session_input_finished";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v16 = "nw_protocol_webtransport_session_input_finished";
      int v6 = "%{public}s called with null protocol";
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_webtransport_session_input_finished";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v3) {
          return;
        }
LABEL_37:
        free(v3);
        return;
      }

      if (!v10) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v16 = "nw_protocol_webtransport_session_input_finished";
      int v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v16 = "nw_protocol_webtransport_session_input_finished";
      int v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_session_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_protocol_webtransport_session_output_finished";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v16 = "nw_protocol_webtransport_session_output_finished";
      int v8 = "%{public}s called with null protocol";
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_webtransport_session_output_finished";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v5) {
          return;
        }
LABEL_36:
        free(v5);
        return;
      }

      if (!v10) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v16 = "nw_protocol_webtransport_session_output_finished";
      int v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v16 = "nw_protocol_webtransport_session_output_finished";
      int v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_webtransport_session_copy_info(uint64_t a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      if ((*(_BYTE *)(v3 + 548) & 2) == 0 && gLogDatapath)
      {
        BOOL v10 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          int v11 = *(_DWORD *)(v3 + 460);
          *(_DWORD *)buf = 136446978;
          __int16 v19 = "nw_protocol_webtransport_session_copy_info";
          __int16 v20 = 2082;
          __int16 v21 = (char *)(v3 + 464);
          __int16 v22 = 2080;
          uint64_t v23 = " ";
          __int16 v24 = 1024;
          int v25 = v11;
          _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }

      return nw_protocol_common_copy_info(a1, a2);
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "nw_protocol_webtransport_session_copy_info";
    int v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_webtransport_session_copy_info";
        os_log_type_t v9 = "%{public}s called with null webtransport_session";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (!v16)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_webtransport_session_copy_info";
        os_log_type_t v9 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v15 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_webtransport_session_copy_info";
        os_log_type_t v9 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v19 = "nw_protocol_webtransport_session_copy_info";
      __int16 v20 = 2082;
      __int16 v21 = backtrace_string;
      BOOL v14 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "nw_protocol_webtransport_session_copy_info";
  int v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_webtransport_session_copy_info";
        os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_protocol_webtransport_session_copy_info";
        os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v19 = "nw_protocol_webtransport_session_copy_info";
      __int16 v20 = 2082;
      __int16 v21 = backtrace_string;
      BOOL v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v7, v8, v14, buf, 0x16u);
    }

BOOL nw_protocol_webtransport_session_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v24 = "nw_protocol_webtransport_session_add_listen_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        BOOL v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v24 = "nw_protocol_webtransport_session_add_listen_handler";
        BOOL v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_45;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v16) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v24 = "nw_protocol_webtransport_session_add_listen_handler";
        BOOL v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_45;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v24 = "nw_protocol_webtransport_session_add_listen_handler";
        __int16 v25 = 2082;
        uint64_t v26 = backtrace_string;
        __int16 v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v10, v11, v17, buf, 0x16u);
      }

uint64_t nw_protocol_webtransport_session_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v33 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            int v34 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v46 = " ";
            *(_WORD *)int v47 = 1024;
            *(_DWORD *)&v47[2] = v34;
            _os_log_impl(&dword_181A5C000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }

      int v4 = (handle[548] >> 1) & 1;
      if (!gLogDatapath) {
        LOBYTE(v4) = 1;
      }
      if (*((nw_listen_protocol **)handle + 50) != a2)
      {
        if ((v4 & 1) != 0) {
          return 1LL;
        }
        char v35 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
          return 1LL;
        }
        int v36 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v46 = " ";
        *(_WORD *)int v47 = 1024;
        *(_DWORD *)&v47[2] = v36;
        int v8 = "%{public}s %{public}s%s<i%u> ignoring request to remove webtransport listen handler, does not match our handler";
        os_log_type_t v9 = v35;
        os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
LABEL_15:
        _os_log_impl(&dword_181A5C000, v9, v10, v8, buf, 0x26u);
        return 1LL;
      }

      if ((v4 & 1) == 0)
      {
        int v41 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          int v42 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v46 = " ";
          *(_WORD *)int v47 = 1024;
          *(_DWORD *)&v47[2] = v42;
          _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> removing protocol listen handler",  buf,  0x26u);
        }
      }

      handle[548] |= 8u;
      *((void *)handle + 50) = 0LL;
      a2->protocol_handler = 0LL;
      if (*((_DWORD *)handle + 111) == 5)
      {
        if ((handle[548] & 2) != 0) {
          return 1LL;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          return 1LL;
        }
        int v7 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v46 = " ";
        *(_WORD *)int v47 = 1024;
        *(_DWORD *)&v47[2] = v7;
        int v8 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
        os_log_type_t v9 = (os_log_s *)v6;
        os_log_type_t v10 = OS_LOG_TYPE_INFO;
        goto LABEL_15;
      }

      int v11 = *((_DWORD *)handle + 113);
      if (v11)
      {
        if ((handle[548] & 2) != 0) {
          goto LABEL_24;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_24;
        }
        int v13 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v46 = " ";
        *(_WORD *)int v47 = 1024;
        *(_DWORD *)&v47[2] = v13;
        __int16 v48 = 1024;
        int v49 = v11;
        int v14 = "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d";
        BOOL v15 = (os_log_s *)v12;
        uint32_t v16 = 44;
      }

      else
      {
        if ((handle[548] & 2) != 0) {
          goto LABEL_24;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_24;
        }
        int v18 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v46 = " ";
        *(_WORD *)int v47 = 1024;
        *(_DWORD *)&v47[2] = v18;
        int v14 = "%{public}s %{public}s%s<i%u> Closing webtransport session without error";
        BOOL v15 = (os_log_s *)v17;
        uint32_t v16 = 38;
      }

      _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_INFO, v14, buf, v16);
LABEL_24:
      *((_DWORD *)handle + 111) = 5;
      __int16 v19 = (char *)*((void *)handle + 23);
      if (v19)
      {
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
        uint64_t v46 = (const char *)&__block_descriptor_tmp_22_33505;
        *(_DWORD *)int v47 = v11;
        nw_hash_table_apply(v19, (uint64_t)buf);
      }

      uint64_t v20 = *((void *)handle + 53);
      if (v20)
      {
        char v21 = *(void **)(v20 + 48);
        if (v11) {
          nw_protocol_error(*(void **)(v20 + 48), *((void *)handle + 53));
        }
        nw_protocol_disconnected(v21, v20);
      }

      uint64_t v22 = *((void *)handle + 41);
      if (v22)
      {
        if (v11)
        {
          do
          {
            uint64_t v23 = *(void *)(v22 + 112);
            __int16 v24 = *(void **)(v22 + 48);
            nw_protocol_error(v24, v22);
            uint64_t v25 = v22;
            uint64_t v22 = v23;
            nw_protocol_disconnected(v24, v25);
          }

          while (v23);
        }

        else
        {
          do
          {
            uint64_t v26 = *(void *)(v22 + 112);
            nw_protocol_disconnected(*(void **)(v22 + 48), v22);
            uint64_t v22 = v26;
          }

          while (v26);
        }
      }

      uint64_t v27 = *((void *)handle + 52);
      if (v27)
      {
        uint64_t v28 = *(void **)(v27 + 48);
        if (v11) {
          nw_protocol_error(*(void **)(v27 + 48), *((void *)handle + 52));
        }
        nw_protocol_disconnected(v28, v27);
      }

      if (*((void *)handle + 4))
      {
        nw_protocol_remove_instance((uint64_t)handle);
        nw_protocol_disconnect(*((void **)handle + 4), (uint64_t)handle);
      }

      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
    __int16 v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        uint64_t v32 = "%{public}s called with null webtransport_session";
        goto LABEL_73;
      }

      goto LABEL_74;
    }

    if (!v43)
    {
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        uint64_t v32 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_73;
      }

      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v40 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        uint64_t v32 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_73;
      }

      goto LABEL_74;
    }

    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint32_t v39 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_61;
    }

    goto LABEL_62;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
  __int16 v29 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v43)
    {
      int v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        uint64_t v32 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_73;
      }

      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v38 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        uint64_t v32 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_73;
      }

      goto LABEL_74;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint32_t v39 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_61:
      _os_log_impl(&dword_181A5C000, v30, v31, v39, buf, 0x16u);
    }

BOOL ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke( uint64_t a1, uint64_t a2, unint64_t *a3)
{
  v55[0] = 0LL;
  v55[1] = v55;
  v55[2] = 0x2000000000LL;
  unint64_t v56 = 0LL;
  v53[0] = 0LL;
  v53[1] = v53;
  v53[2] = 0x2000000000LL;
  unint64_t v5 = a3[1];
  if (v5 >> 62)
  {
    int v15 = 0;
  }

  else
  {
    unint64_t v6 = v5 >> 14;
    unint64_t v7 = bswap64(v5 | 0xC000000000000000LL);
    unint64_t v8 = bswap32(v5 | 0x80000000);
    if (v5 >> 30) {
      unint64_t v9 = v7;
    }
    else {
      unint64_t v9 = v8;
    }
    if (v5 >> 30) {
      int v10 = 8;
    }
    else {
      int v10 = 4;
    }
    unint64_t v11 = bswap32(v5 | 0x4000) >> 16;
    BOOL v12 = v6 == 0;
    if (v6) {
      unint64_t v13 = v9;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v12) {
      int v14 = 2;
    }
    else {
      int v14 = v10;
    }
    if (v5 >= 0x40)
    {
      int v15 = v14;
    }

    else
    {
      unint64_t v13 = a3[1];
      int v15 = 1;
    }

    unint64_t v56 = v13;
  }

  char v54 = v15;
  v51[0] = 0LL;
  v51[1] = v51;
  v51[2] = 0x2000000000LL;
  unint64_t v52 = 0LL;
  v49[0] = 0LL;
  v49[1] = v49;
  v49[2] = 0x2000000000LL;
  unint64_t v16 = a3[2];
  if (v16 >> 62)
  {
    int v26 = 0;
  }

  else
  {
    unint64_t v17 = v16 >> 14;
    unint64_t v18 = bswap64(v16 | 0xC000000000000000LL);
    unint64_t v19 = bswap32(v16 | 0x80000000);
    if (v16 >> 30) {
      unint64_t v20 = v18;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v16 >> 30) {
      int v21 = 8;
    }
    else {
      int v21 = 4;
    }
    unint64_t v22 = bswap32(v16 | 0x4000) >> 16;
    BOOL v23 = v17 == 0;
    if (v17) {
      unint64_t v24 = v20;
    }
    else {
      unint64_t v24 = v22;
    }
    if (v23) {
      int v25 = 2;
    }
    else {
      int v25 = v21;
    }
    if (v16 >= 0x40)
    {
      int v26 = v25;
    }

    else
    {
      unint64_t v24 = a3[2];
      int v26 = 1;
    }

    unint64_t v52 = v24;
  }

  char v50 = v26;
  v48[0] = 0LL;
  v48[1] = (uint64_t)v48;
  BOOL output_frames = nw_http_capsule_framer_get_output_frames( *(void *)(a1 + 32) + 96LL,  *(void *)(a1 + 32),  *a3,  v26 + v15,  v26 + v15,  1LL,  v48);
  if (output_frames)
  {
    v46[0] = 0LL;
    v46[1] = v46;
    v46[2] = 0x2000000000LL;
    char v47 = 0;
    uint64_t v42 = 0LL;
    char v43 = &v42;
    uint64_t v44 = 0x2000000000LL;
    uint64_t v45 = v48;
    v32[0] = MEMORY[0x1895F87A8];
    v32[1] = 0x40000000LL;
    uint64_t v33 = (uint64_t (*)(void *))___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_2;
    int v34 = &unk_189BBC578;
    char v35 = v46;
    int v36 = &v42;
    uint64_t v41 = *(void *)(a1 + 32);
    char v37 = v55;
    BOOL v38 = v53;
    uint32_t v39 = v51;
    BOOL v40 = v49;
    uint64_t v28 = v48[0];
    do
    {
      if (!v28) {
        break;
      }
      uint64_t v29 = *(void *)(v28 + 32);
      char v30 = v33(v32);
      uint64_t v28 = v29;
    }

    while ((v30 & 1) != 0);
    nw_http_capsule_framer_finalize_output_frames( *(void *)(a1 + 32) + 96LL,  *(void *)(a1 + 32),  *a3,  (uint64_t *)v43[3]);
    nw_array_append(*(void *)(a1 + 40), a3);
    _Block_object_dispose(&v42, 8);
    _Block_object_dispose(v46, 8);
  }

  _Block_object_dispose(v49, 8);
  _Block_object_dispose(v51, 8);
  _Block_object_dispose(v53, 8);
  _Block_object_dispose(v55, 8);
  return output_frames;
}

uint64_t ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_38( uint64_t a1, uint64_t a2, void *a3)
{
  if (a3) {
    free(a3);
  }
  return 1LL;
}

uint64_t ___ZL49nw_protocol_webtransport_session_output_availableP11nw_protocolS0__block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t object = (void *)nw_hash_node_get_object(a2);
  nw_protocol_output_available(object, *(void *)(a1 + 32));
  return 1LL;
}

uint64_t ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_2( void *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    nw_frame_finalize(a2);
    uint64_t v4 = *(void *)(a2 + 32);
    unint64_t v5 = *(void **)(a2 + 40);
    if (v4)
    {
      *(void *)(v4 + 40) = v5;
      unint64_t v5 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(*(void *)(*(void *)(a1[5] + 8LL) + 24LL) + 8LL) = v5;
    }

    void *v5 = v4;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    uint64_t v7 = a1[10];
    if (!v7 || (*(_BYTE *)(v7 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        unint64_t v9 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v10 = a1[10];
          unint64_t v11 = (const char *)(v10 + 464);
          BOOL v12 = "";
          BOOL v13 = v10 == 0;
          int v14 = *(_DWORD *)(v10 + 460);
          if (v13) {
            unint64_t v11 = "";
          }
          unint64_t v16 = "nw_webtransport_http2_send_pending_control_capsules_block_invoke_2";
          __int16 v17 = 2082;
          int v15 = 136446978;
          if (!v13) {
            BOOL v12 = " ";
          }
          unint64_t v18 = v11;
          __int16 v19 = 2080;
          unint64_t v20 = v12;
          __int16 v21 = 1024;
          int v22 = v14;
          _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Dropping unneeded output frame",  (uint8_t *)&v15,  0x26u);
        }
      }
    }
  }

  else
  {
    int v15 = 0;
    unint64_t v6 = (char *)nw_frame_unclaimed_bytes(a2, &v15);
    memcpy(v6, (const void *)(*(void *)(a1[6] + 8LL) + 24LL), *(unsigned __int8 *)(*(void *)(a1[7] + 8LL) + 24LL));
    memcpy( &v6[*(unsigned __int8 *)(*(void *)(a1[7] + 8LL) + 24LL)],  (const void *)(*(void *)(a1[8] + 8LL) + 24LL),  *(unsigned __int8 *)(*(void *)(a1[9] + 8LL) + 24LL));
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
  }

  return 1LL;
}

uint64_t __Block_byref_object_copy__50(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__51(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

uint64_t ___ZL38nw_webtransport_session_http_get_inputP23nw_webtransport_session_block_invoke( uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = (uint64_t)a2;
  uint64_t v544 = *MEMORY[0x1895F89C0];
  if (nw_frame_unclaimed_length(a2))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4 || (*(_BYTE *)(v4 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v5 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v6 = *(void *)(a1 + 40);
        uint64_t v7 = (const char *)(v6 + 464);
        unint64_t v8 = "";
        int v9 = *(_DWORD *)(v6 + 460);
        BOOL v10 = v6 == 0;
        if (!v6) {
          uint64_t v7 = "";
        }
        int v11 = *(_DWORD *)(v6 + 444);
        if (!v10) {
          unint64_t v8 = " ";
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v531 = (uint64_t)v8;
        *(_WORD *)v532 = 1024;
        *(_DWORD *)&v532[2] = v9;
        *(_WORD *)&v532[6] = 1024;
        *(_DWORD *)&v532[8] = v11;
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Unexpected data received in state: %d",  buf,  0x2Cu);
      }
    }
  }

  BOOL v12 = nw_frame_copy_metadata_for_protocol(v2, *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
  uint64_t v13 = *(void *)(a1 + 40);
  if (v12)
  {
    int v14 = v12;
    int v15 = *(_DWORD *)(v13 + 444);
    if (v15 != 3)
    {
      if (v15 != 1)
      {
LABEL_721:
        nw_frame_finalize(v2);
        os_release(v14);
        return 1LL;
      }

      if (nw_protocol_metadata_is_http(v12))
      {
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v488 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v488, OS_LOG_TYPE_DEBUG))
            {
              int v489 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v13 + 464;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v489;
              _os_log_impl(&dword_181A5C000, v488, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
            }
          }
        }

        id v16 = nw_http_metadata_copy_response(v14);
        if (v16)
        {
          id v17 = v16;
          int status_code = _nw_http_response_get_status_code();
          id v523 = v17;

          if ((status_code - 200) > 0x63)
          {
            if (*(_DWORD *)(v13 + 444) != 5)
            {
              if ((*(_BYTE *)(v13 + 548) & 2) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v270 = (os_log_s *)gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                {
                  int v271 = *(_DWORD *)(v13 + 460);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v13 + 464;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v271;
                  *(_WORD *)&v532[6] = 1024;
                  *(_DWORD *)&v532[8] = 57;
                  _os_log_impl( &dword_181A5C000,  v270,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d",  buf,  0x2Cu);
                }
              }

              *(_DWORD *)(v13 + 444) = 5;
              v272 = *(char **)(v13 + 184);
              if (v272)
              {
                *(void *)buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 0x40000000LL;
                *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
                uint64_t v531 = (uint64_t)&__block_descriptor_tmp_22_33505;
                *(_DWORD *)v532 = 57;
                nw_hash_table_apply(v272, (uint64_t)buf);
              }

              uint64_t v273 = *(void *)(v13 + 424);
              if (v273)
              {
                v274 = *(void **)(v273 + 48);
                nw_protocol_error(v274, *(void *)(v13 + 424));
                nw_protocol_disconnected(v274, v273);
              }

              uint64_t v275 = *(void *)(v13 + 328);
              if (v275)
              {
                do
                {
                  uint64_t v276 = *(void *)(v275 + 112);
                  BOOL v277 = *(void **)(v275 + 48);
                  nw_protocol_error(v277, v275);
                  nw_protocol_disconnected(v277, v275);
                  uint64_t v275 = v276;
                }

                while (v276);
              }

              uint64_t v278 = *(void *)(v13 + 416);
              if (v278)
              {
                BOOL v279 = *(void **)(v278 + 48);
                nw_protocol_error(v279, *(void *)(v13 + 416));
                nw_protocol_disconnected(v279, v278);
              }

              if (*(void *)(v13 + 32))
              {
                nw_protocol_remove_instance(v13);
                nw_protocol_disconnect(*(void **)(v13 + 32), v13);
              }

              goto LABEL_720;
            }

            if ((*(_BYTE *)(v13 + 548) & 2) != 0
              || (pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once),
                  networkd_settings_init(),
                  uint64_t v49 = gLogObj,
                  !os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)))
            {
LABEL_720:
              os_release(v523);
              goto LABEL_721;
            }

            int v50 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v50;
            int v22 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
            uint64_t v23 = (os_log_s *)v49;
            os_log_type_t v24 = OS_LOG_TYPE_INFO;
            uint32_t v25 = 38;
LABEL_57:
            _os_log_impl(&dword_181A5C000, v23, v24, v22, buf, v25);
            goto LABEL_720;
          }

          if (*(_DWORD *)(v13 + 444) == 4)
          {
            if ((*(_BYTE *)(v13 + 548) & 2) != 0) {
              goto LABEL_720;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v19 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_720;
            }
            int v20 = *(_DWORD *)(v13 + 460);
            int v21 = *(_DWORD *)(v13 + 444);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v20;
            *(_WORD *)&v532[6] = 1024;
            *(_DWORD *)&v532[8] = v21;
            int v22 = "%{public}s %{public}s%s<i%u> Tried to ready streams with incorrect state: %d, ignoring";
            uint64_t v23 = (os_log_s *)v19;
            os_log_type_t v24 = OS_LOG_TYPE_ERROR;
            uint32_t v25 = 44;
            goto LABEL_57;
          }

          *(_DWORD *)(v13 + 444) = 4;
          if ((*(_BYTE *)(v13 + 548) & 2) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v61 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              int v62 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v13 + 464;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v62;
              _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Webtransport session established, reconfiguring streams",  buf,  0x26u);
            }
          }

          uint64_t v63 = *(void *)(v13 + 328);
          if (!v63) {
            goto LABEL_720;
          }
          if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v507 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v507, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v508 = *(void *)(v63 + 88);
                if (v508) {
                  int v509 = *(_DWORD *)(v508 + 460);
                }
                else {
                  int v509 = -1;
                }
                uint64_t v513 = *(void *)(v63 + 64);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v63 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v509;
                *(_WORD *)&v532[6] = 2048;
                *(void *)&v532[8] = v513;
                *(_WORD *)&v532[16] = 2048;
                *(void *)&v532[18] = v63;
                _os_log_impl( &dword_181A5C000,  v507,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)",  buf,  0x3Au);
              }
            }
          }

          int v64 = *(_BYTE *)(v13 + 548) & 1;
          int v520 = v64;
          while (1)
          {
            if ((*(_BYTE *)(v13 + 548) & 2) == 0)
            {
              if (gLogDatapath)
              {
                os_log_type_t v210 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v210, OS_LOG_TYPE_DEBUG))
                {
                  int v211 = *(_DWORD *)(v13 + 460);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v13 + 464;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v211;
                  *(_WORD *)&v532[6] = 2048;
                  *(void *)&v532[8] = v63;
                  _os_log_impl( &dword_181A5C000,  v210,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream (%p)",  buf,  0x30u);
                }
              }
            }

            if ((*(_BYTE *)(v63 + 276) & 0x20) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v63;
              uint64_t v65 = (char *)_os_log_send_and_compose_impl();
              iterate_block[0] = 16;
              type[0] = OS_LOG_TYPE_DEFAULT;
              if (iterate_block[0] == 17)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v66 = gLogObj;
                os_log_type_t v67 = iterate_block[0];
                if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2048;
                  *(void *)&buf[14] = v63;
                  int v68 = (os_log_s *)v66;
                  os_log_type_t v69 = v67;
                  int v70 = "%{public}s stream %p not in pending list, cannot remove";
                  goto LABEL_107;
                }

                goto LABEL_108;
              }

              if (type[0])
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v74 = (os_log_s *)gLogObj;
                os_log_type_t v75 = iterate_block[0];
                BOOL v76 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
                if (backtrace_string)
                {
                  if (v76)
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v63;
                    *(_WORD *)&buf[22] = 2082;
                    uint64_t v531 = (uint64_t)backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
                  }

                  free(backtrace_string);
                  goto LABEL_108;
                }

                if (!v76)
                {
LABEL_108:
                  if (v65) {
                    free(v65);
                  }
                  goto LABEL_120;
                }

                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v63;
                int v68 = v74;
                os_log_type_t v69 = v75;
                int v70 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v86 = gLogObj;
                os_log_type_t v87 = iterate_block[0];
                if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0])) {
                  goto LABEL_108;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v63;
                int v68 = (os_log_s *)v86;
                os_log_type_t v69 = v87;
                int v70 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
              }

LABEL_371:
                        if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          uint64_t v264 = gLogObj;
                          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                          {
                            uint64_t v265 = *(void *)(v63 + 88);
                            if (v265) {
                              int v266 = *(_DWORD *)(v265 + 460);
                            }
                            else {
                              int v266 = -1;
                            }
                            uint64_t v267 = *(void *)(v63 + 64);
                            *(_DWORD *)buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                            *(_WORD *)&_BYTE buf[12] = 2082;
                            *(void *)&buf[14] = v63 + 192;
                            *(_WORD *)&buf[22] = 2080;
                            uint64_t v531 = (uint64_t)" ";
                            *(_WORD *)v532 = 1024;
                            *(_DWORD *)&v532[2] = v266;
                            *(_WORD *)&v532[6] = 2048;
                            *(void *)&v532[8] = v267;
                            uint64_t v171 = (os_log_s *)v264;
                            v172 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
                            goto LABEL_377;
                          }
                        }

                        goto LABEL_378;
                      }

                      v517 = v121;
                      uint64_t parameters = (void *)nw_protocol_get_parameters(v63);
                      if (parameters)
                      {
                        os_log_type_t v188 = parameters;
                        nw_parameters_log_protocol_instances(parameters);
                        v189 = v188;
                        stack = (nw_protocol_stack *)v189[19];

                        *(void *)os_log_type_t type = 0LL;
                        v527 = type;
                        uint64_t v528 = 0x2000000000LL;
                        char v529 = 0;
                        *(void *)buf = 0LL;
                        *(void *)&buf[8] = buf;
                        *(void *)&buf[16] = 0x3802000000LL;
                        uint64_t v531 = (uint64_t)__Block_byref_object_copy__33539;
                        *(void *)v532 = __Block_byref_object_dispose__33540;
                        *(void *)&v532[8] = 0LL;
                        v532[16] |= 1u;
                        *(void *)iterate_block = MEMORY[0x1895F87A8];
                        *(void *)&iterate_block[8] = 0x40000000LL;
                        *(void *)&iterate_block[16] = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
                        v540 = (const char *)&unk_189BBC648;
                        v541 = type;
                        v542 = buf;
                        uint64_t v543 = v63;
                        nw_protocol_stack_iterate_application_protocols(stack, iterate_block);
                        v190 = *(void **)(*(void *)&buf[8] + 40LL);
                        if (v190)
                        {
                          if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
                            dispatch_once( &nw_protocol_copy_http_messaging_definition_onceToken,  &__block_literal_global_57_72514);
                          }
                          id v191 = (id)nw_protocol_copy_http_messaging_definition_definition;
                          uint64_t v192 = v190;
                          v192[2] = v186;

                          if (v191) {
                            os_release(v191);
                          }
                          id v193 = (void *)nw_protocol_get_parameters(v186);
                          if (v193)
                          {
                            v194 = v193;
                            os_log_type_t v195 = (nw_protocol_stack *)v194[19];

                            v196 = v189;
                            BOOL v197 = (nw_protocol_stack *)v189[19];

                            uint64_t v198 = v2;
                            BOOL v199 = v14;
                            nw_protocol_options_t v200 = nw_protocol_stack_copy_transport_protocol(v195);
                            nw_protocol_options_t v201 = nw_protocol_stack_copy_transport_protocol(v197);
                            nw_protocol_options_t v202 = v201;
                            if (v200)
                            {
                              if (v201)
                              {
                                nw_protocol_definition_t v203 = nw_protocol_options_copy_definition(v200);
                                if (nw_protocol_options_matches_definition(v202, v203))
                                {
                                  uint64_t protocol_handle = nw_protocol_options_get_protocol_handle(v200);
                                  nw_parameters_set_protocol_instance(v202, v205, protocol_handle);
                                }

                                os_release(v202);
                              }

                              nw_protocol_options_t v202 = v200;
LABEL_288:
                              os_release(v202);
                            }

                            else if (v201)
                            {
                              goto LABEL_288;
                            }

                            int v14 = v199;
                            if (v197) {
                              os_release(v197);
                            }
                            uint64_t v2 = v198;
                            if (v195) {
                              os_release(v195);
                            }
                          }

                          nw_protocol_set_output_handler(v63, 0LL);
                          char v206 = nw_protocol_add_input_handler(v186, v63);
LABEL_294:
                          _Block_object_dispose(buf, 8);
                          int v64 = v520;
                          int v121 = v517;
                          if ((v532[16] & 1) != 0 && *(void *)&v532[8]) {
                            os_release(*(void **)&v532[8]);
                          }
                          _Block_object_dispose(type, 8);
                          if (stack) {
                            os_release(stack);
                          }
                          if ((v206 & 1) != 0) {
                            goto LABEL_300;
                          }
                          goto LABEL_371;
                        }

                        __nwlog_obj();
                        *(_DWORD *)v535 = 136446210;
                        v536 = "nw_webtransport_session_add_to_http_messaging";
                        v238 = (char *)_os_log_send_and_compose_impl();
                        os_log_type_t v525 = OS_LOG_TYPE_ERROR;
                        char v524 = 0;
                        if (v525 == OS_LOG_TYPE_FAULT)
                        {
                          v239 = (os_log_s *)__nwlog_obj();
                          os_log_type_t v240 = v525;
                          if (os_log_type_enabled(v239, v525))
                          {
                            *(_DWORD *)v535 = 136446210;
                            v536 = "nw_webtransport_session_add_to_http_messaging";
                            int v241 = v239;
                            os_log_type_t v242 = v240;
                            BOOL v243 = "%{public}s called with null options";
                            goto LABEL_383;
                          }

                          goto LABEL_384;
                        }

                        if (v524)
                        {
                          v252 = (char *)__nw_create_backtrace_string();
                          os_log_type_t v253 = (os_log_s *)__nwlog_obj();
                          os_log_type_t v254 = v525;
                          BOOL v255 = os_log_type_enabled(v253, v525);
                          if (v252)
                          {
                            if (v255)
                            {
                              *(_DWORD *)v535 = 136446466;
                              v536 = "nw_webtransport_session_add_to_http_messaging";
                              __int16 v537 = 2082;
                              v538 = v252;
                              _os_log_impl( &dword_181A5C000,  v253,  v254,  "%{public}s called with null options, dumping backtrace:%{public}s",  v535,  0x16u);
                            }

                            free(v252);
                            goto LABEL_384;
                          }

                          if (!v255)
                          {
LABEL_384:
                            if (v238) {
                              free(v238);
                            }
                            char v206 = 0;
                            goto LABEL_294;
                          }

                          *(_DWORD *)v535 = 136446210;
                          v536 = "nw_webtransport_session_add_to_http_messaging";
                          int v241 = v253;
                          os_log_type_t v242 = v254;
                          BOOL v243 = "%{public}s called with null options, no backtrace";
                        }

                        else
                        {
                          uint64_t v262 = (os_log_s *)__nwlog_obj();
                          os_log_type_t v263 = v525;
                          if (!os_log_type_enabled(v262, v525)) {
                            goto LABEL_384;
                          }
                          *(_DWORD *)v535 = 136446210;
                          v536 = "nw_webtransport_session_add_to_http_messaging";
                          int v241 = v262;
                          os_log_type_t v242 = v263;
                          BOOL v243 = "%{public}s called with null options, backtrace limit exceeded";
                        }

      if (v184) {
        free(v184);
      }
      *(_DWORD *)(v580 + 348) = 0;
      unint64_t v5 = v579;
      uint64_t v4 = v181;
      goto LABEL_374;
    }

    if (!*(void *)(v5 + 32))
    {
      if (!(*(_BYTE *)(v5 + 158) & 1 | (*((_BYTE *)v4 + 1537) == 0)))
      {
        int v112 = (os_log_s *)__nwlog_obj();
        uint64_t v113 = os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG);
        uint64_t v3 = v580;
        if (v113)
        {
          uint64_t v114 = *(void *)(v5 + 256);
          int v115 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
          if (v114) {
            LODWORD(v114) = *(_DWORD *)(v114 + 860);
          }
          __int16 v116 = *(_DWORD *)(v579 + 424);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v5 + 74;
          *(_WORD *)&buf[22] = 2080;
          v608 = (uint64_t)" ";
          *(_WORD *)v609 = 1024;
          *(_DWORD *)&v609[2] = v115;
          *(_WORD *)&v609[6] = 1024;
          *(_DWORD *)&v609[8] = v114;
          *(_WORD *)&v609[12] = 1024;
          *(_DWORD *)&v609[14] = v116;
          *(_WORD *)&v609[18] = 2048;
          *(void *)&v609[20] = v579;
          os_log_type_t v24 = "%{public}s %{public}s%s<i%u:c%u:s%u> Stream %p still awaiting new output handler";
          uint32_t v25 = v112;
          int v26 = 60;
          goto LABEL_33;
        }
      }

      goto LABEL_34;
    }

    if (!(*(_BYTE *)(v5 + 158) & 1 | (*((_BYTE *)v4 + 1537) == 0)))
    {
      v433 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v433, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v434 = v5 + 74;
        int v435 = *(void *)(v5 + 256);
        uint64_t v436 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
        if (v435) {
          LODWORD(v435) = *(_DWORD *)(v435 + 860);
        }
        unint64_t v5 = v579;
        v437 = *(_DWORD *)(v579 + 424);
        uint64_t v438 = *(void *)(v579 + 32);
        *(_DWORD *)buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v434;
        *(_WORD *)&buf[22] = 2080;
        v608 = (uint64_t)" ";
        *(_WORD *)v609 = 1024;
        *(_DWORD *)&v609[2] = v436;
        *(_WORD *)&v609[6] = 1024;
        *(_DWORD *)&v609[8] = v435;
        *(_WORD *)&v609[12] = 1024;
        *(_DWORD *)&v609[14] = v437;
        *(_WORD *)&v609[18] = 2048;
        *(void *)&v609[20] = v579;
        *(_WORD *)&v609[28] = 2048;
        *(void *)&v609[30] = v438;
        _os_log_impl( &dword_181A5C000,  v433,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> creating connection for stream %p with new output_handler %p",  buf,  0x46u);
      }
    }

    char v38 = *(_OWORD **)(v5 + 32);
    if (v38)
    {
      char v39 = *(void **)(v5 + 336);
      if (v39)
      {
        uint64_t v40 = *(void **)(v5 + 320);
        if (v40)
        {
          int v41 = calloc(1uLL, 0x370uLL);
          if (!v41)
          {
            int v439 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v439, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "strict_calloc";
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(void *)&buf[14] = 1LL;
            *(_WORD *)&buf[22] = 2048;
            v608 = 880LL;
            v440 = (void *)_os_log_send_and_compose_impl();
            free(v440);
          }

          bzero(v41, 0x370uLL);
          if (nw_protocol_http1_identifier::onceToken != -1) {
            dispatch_once(&nw_protocol_http1_identifier::onceToken, &__block_literal_global_39881);
          }
          int v42 = v580;
          *((void *)v41 + 2) = &nw_protocol_http1_identifier::http1_protocol_identifier;
          if (nw_protocol_http1_get_callbacks(void)::onceToken != -1)
          {
            dispatch_once(&nw_protocol_http1_get_callbacks(void)::onceToken, &__block_literal_global_17_39683);
            int v42 = v580;
          }

          *((void *)v41 + 3) = &nw_protocol_http1_get_callbacks(void)::http1_protocol_callbacks;
          *((_DWORD *)v41 + 46) = 3;
          *((void *)v41 + 22) = v41;
          *((void *)v41 + 5) = v41 + 10;
          *((void *)v41 + 60) = v42;
          nw_protocol_set_output_handler((uint64_t)v41, (uint64_t)v38);
          char v43 = os_retain(v39);
          uint64_t v44 = *((_BYTE *)v41 + 760);
          if ((v44 & 1) != 0)
          {
            os_log_type_t v45 = (void *)*((void *)v41 + 94);
            if (v45)
            {
              os_release(v45);
              uint64_t v44 = *((_BYTE *)v41 + 760);
            }
          }

          *((void *)v41 + 94) = v43;
          *((_BYTE *)v41 + 760) = v44 | 1;
          uint32_t v46 = os_retain(v40);
          uint64_t v47 = *((_BYTE *)v41 + 744);
          if ((v47 & 1) != 0)
          {
            int v48 = (void *)*((void *)v41 + 92);
            if (v48)
            {
              os_release(v48);
              uint64_t v47 = *((_BYTE *)v41 + 744);
            }
          }

          *((void *)v41 + 92) = v46;
          *((_BYTE *)v41 + 744) = v47 | 1;
          uint64_t v49 = v40;
          int v50 = *(id *)(v49[13] + 136LL);

          uint64_t v51 = *((_BYTE *)v41 + 504);
          int v52 = v580;
          if ((v51 & 1) != 0)
          {
            char v53 = (void *)*((void *)v41 + 62);
            if (v53)
            {
              os_release(v53);
              int v52 = v580;
              uint64_t v51 = *((_BYTE *)v41 + 504);
            }
          }

          *((void *)v41 + 62) = v50;
          *((_BYTE *)v41 + 504) = v51 | 1;
          uint64_t v54 = MEMORY[0x1895F87A8];
          *((void *)v41 + 24) = *(void *)(v52 + 192);
          *(void *)os_log_type_t type = v54;
          v592 = 0x40000000LL;
          v593 = (uint64_t)___ZL26nw_http1_connection_createP11nw_protocolP17nw_protocol_http1P11nw_endpointP13nw_parameters_block_invoke;
          v594 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_40_39882;
          v595 = (void (*)(uint64_t))v41;
          metadata = nw_http_connection_create_metadata(v50, type, 0LL);
          uint64_t v56 = *((_BYTE *)v41 + 776);
          if ((v56 & 1) != 0)
          {
            uint64_t v57 = (void *)*((void *)v41 + 96);
            if (v57)
            {
              os_release(v57);
              uint64_t v56 = *((_BYTE *)v41 + 776);
            }
          }

          *((void *)v41 + 96) = metadata;
          *((_BYTE *)v41 + 776) = v56 | 1;
          nw_http_connection_metadata_set_version(metadata, 3);
          nw_http_connection_metadata_set_shared_connection_pool_metadata(*((void **)v41 + 96), *(void **)(v580 + 312));
          *((void *)v41 + 77) = 0LL;
          *((void *)v41 + 78) = (char *)v41 + 616;
          *((void *)v41 + 79) = 0LL;
          *((void *)v41 + 80) = (char *)v41 + 632;
          *((void *)v41 + 81) = 0LL;
          *((void *)v41 + 82) = (char *)v41 + 648;
          *((void *)v41 + 83) = 0LL;
          *((void *)v41 + 84) = (char *)v41 + 664;
          *((void *)v41 + 86) = (char *)v41 + 680;
          *((void *)v41 + 85) = 0LL;
          nw_frame_cache_init((uint64_t)v41 + 696, (uint64_t)v41, 256, 0x40000, 16);
          uint64_t v58 = *((void *)v41 + 60);
          if (v58)
          {
            *(_OWORD *)((char *)v41 + 360) = 0u;
            *(_OWORD *)((char *)v41 + 376) = 0u;
            *(_OWORD *)((char *)v41 + 392) = 0u;
            *(_OWORD *)((char *)v41 + 408) = 0u;
            *(_OWORD *)((char *)v41 + 424) = 0u;
            *(_OWORD *)((char *)v41 + 440) = 0u;
            *(_OWORD *)((char *)v41 + 328) = 0u;
            *(_OWORD *)((char *)v41 + 344) = 0u;
            *((void *)v41 + 59) = nw_http1_on_reset;
            *((void *)v41 + 37) = nw_http1_on_message_begin;
            *((void *)v41 + 38) = nw_http1_on_url;
            *((void *)v41 + 48) = nw_http1_on_message_complete;
            *((void *)v41 + 49) = nw_http1_on_url_complete;
            *((void *)v41 + 39) = nw_http1_on_status;
            *((void *)v41 + 40) = nw_http1_on_method;
            *((void *)v41 + 50) = nw_http1_on_status_complete;
            *((void *)v41 + 51) = nw_http1_on_method_complete;
            *((void *)v41 + 42) = nw_http1_on_header_field;
            *((void *)v41 + 43) = nw_http1_on_header_value;
            *((void *)v41 + 53) = nw_http1_on_header_field_complete;
            *((void *)v41 + 54) = nw_http1_on_header_value_complete;
            *((void *)v41 + 46) = nw_http1_on_headers_complete;
            *((void *)v41 + 47) = nw_http1_on_body;
            *((void *)v41 + 57) = nw_http1_on_chunk_header;
            *((void *)v41 + 58) = nw_http1_on_chunk_complete;
            uint64_t v59 = *(_BYTE *)(v58 + 376);
            *(_OWORD *)((char *)v41 + 248) = 0u;
            *(_OWORD *)((char *)v41 + 200) = 0u;
            *(_OWORD *)((char *)v41 + 264) = 0u;
            *(_OWORD *)((char *)v41 + 232) = 0u;
            *(_OWORD *)((char *)v41 + 216) = 0u;
            if ((v59 & 1) != 0) {
              uint64_t v60 = 1;
            }
            else {
              uint64_t v60 = 2;
            }
            *((_BYTE *)v41 + 272) = v60;
            *((void *)v41 + 35) = 0LL;
            *((void *)v41 + 36) = (char *)v41 + 296;
            *((_WORD *)v41 + 139) = 16131;
            *((void *)v41 + 31) = v41;
            *((void *)v41 + 32) = 238LL;
            if ((*((_BYTE *)v41 + 158) & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v61 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v62 = *((void *)v41 + 61);
                uint64_t v63 = *(_DWORD *)(*((void *)v41 + 60) + 372LL);
                int v64 = *((_DWORD *)v41 + 215);
                if (v62) {
                  LODWORD(v62) = *(_DWORD *)(v62 + 424);
                }
                *(_DWORD *)buf = 136448258;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_log_parser_version";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = (char *)v41 + 74;
                *(_WORD *)&buf[22] = 2080;
                v608 = (uint64_t)" ";
                *(_WORD *)v609 = 1024;
                *(_DWORD *)&v609[2] = v63;
                *(_WORD *)&v609[6] = 1024;
                *(_DWORD *)&v609[8] = v64;
                *(_WORD *)&v609[12] = 1024;
                *(_DWORD *)&v609[14] = v62;
                *(_WORD *)&v609[18] = 1024;
                *(_DWORD *)&v609[20] = 9;
                *(_WORD *)&v609[24] = 1024;
                *(_DWORD *)&v609[26] = 2;
                *(_WORD *)&v609[30] = 1024;
                *(_DWORD *)&v609[32] = 1;
                _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> using http parser v%u.%u.%u",  buf,  0x44u);
              }
            }

            goto LABEL_86;
          }

          v441 = v38;
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
          os_log_type_t v442 = (char *)_os_log_send_and_compose_impl();
          v602[0] = 16;
          LOBYTE(v583[0]) = 0;
          if (__nwlog_fault(v442, v602, v583))
          {
            if (v602[0] == 17)
            {
              v443 = (os_log_s *)__nwlog_obj();
              os_log_type_t v444 = v602[0];
              if (os_log_type_enabled(v443, (os_log_type_t)v602[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                v445 = "%{public}s called with null http1_connection->protocol_http1";
LABEL_817:
                _os_log_impl(&dword_181A5C000, v443, v444, v445, buf, 0xCu);
              }
            }

            else if (LOBYTE(v583[0]))
            {
              v516 = (char *)__nw_create_backtrace_string();
              v443 = (os_log_s *)__nwlog_obj();
              os_log_type_t v444 = v602[0];
              v517 = os_log_type_enabled(v443, (os_log_type_t)v602[0]);
              if (v516)
              {
                if (v517)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v516;
                  _os_log_impl( &dword_181A5C000,  v443,  v444,  "%{public}s called with null http1_connection->protocol_http1, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v516);
                goto LABEL_818;
              }

              if (v517)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                v445 = "%{public}s called with null http1_connection->protocol_http1, no backtrace";
                goto LABEL_817;
              }
            }

            else
            {
              v443 = (os_log_s *)__nwlog_obj();
              os_log_type_t v444 = v602[0];
              if (os_log_type_enabled(v443, (os_log_type_t)v602[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                v445 = "%{public}s called with null http1_connection->protocol_http1, backtrace limit exceeded";
                goto LABEL_817;
              }
            }
          }

      free(v82);
      goto LABEL_372;
    }

    if (v115)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v205 = "_http_safe_append";
      uint64_t v85 = "%{public}s called with null (*remaining >= length), no backtrace";
LABEL_369:
      _os_log_impl(&dword_181A5C000, v83, v84, v85, buf, 0xCu);
      goto LABEL_370;
    }

    goto LABEL_370;
  }

  memcpy(v27, &__src, v18);
  uint64_t v29 = v28[3];
  v28[3] = v29 - v18;
  if (v29 < v18)
  {
    if (gLogDatapath)
    {
      os_log_t log = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v113 = v28[3];
        *(_DWORD *)buf = 136446978;
        uint64_t v205 = "_http_safe_append";
        char v206 = 2082;
        uint64_t v207 = "*remaining";
        unsigned int v208 = 2048;
        uint64_t v209 = v18;
        os_log_type_t v210 = 2048;
        int v211 = v113;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
      }
    }

    v28[3] = 0LL;
  }

  v199[3] = (uint64_t)&v27[v18];
  if (v16) {
    goto LABEL_26;
  }
LABEL_27:
  __src = 0LL;
  p_src = &__src;
  os_log_type_t v188 = 0x2000000000LL;
  v189 = 0LL;
  BOOL v30 = nw_http_metadata_copy_header_fields(a1);
  v185[0] = v15;
  v185[1] = 0x40000000LL;
  v185[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_22;
  v185[3] = &unk_189BBF930;
  v185[4] = &__src;
  nw_http_fields_enumerate(v30, v185);
  if ((a2 & 1) != 0) {
    goto LABEL_42;
  }
  int v31 = p_src[3];
  if (v31 <= 0x3F)
  {
    *(void *)os_log_type_t type = p_src[3];
    uint64_t v32 = 1LL;
    goto LABEL_36;
  }

  if (!(v31 >> 14))
  {
    *(void *)os_log_type_t type = bswap32(v31 | 0x4000) >> 16;
    uint64_t v32 = 2LL;
    goto LABEL_36;
  }

  if (!(v31 >> 30))
  {
    *(void *)os_log_type_t type = bswap32(v31 | 0x80000000);
    uint64_t v32 = 4LL;
    goto LABEL_36;
  }

  if (!(v31 >> 62))
  {
    *(void *)os_log_type_t type = bswap64(v31 | 0xC000000000000000LL);
    uint64_t v32 = 8LL;
LABEL_36:
    uint64_t v33 = (char *)v199[3];
    if (v33)
    {
      uint64_t v34 = v195;
      if (v195[3] >= v32)
      {
        memcpy(v33, type, v32);
        char v35 = v34[3];
        v34[3] = v35 - v32;
        if (v35 < v32)
        {
          if (gLogDatapath)
          {
            char v124 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
            {
              char v125 = v34[3];
              *(_DWORD *)buf = 136446978;
              uint64_t v205 = "_http_safe_append";
              char v206 = 2082;
              uint64_t v207 = "*remaining";
              unsigned int v208 = 2048;
              uint64_t v209 = v32;
              os_log_type_t v210 = 2048;
              int v211 = v125;
              _os_log_impl( &dword_181A5C000,  v124,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          v34[3] = 0LL;
        }

        v199[3] = (uint64_t)&v33[v32];
        goto LABEL_42;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v205 = "_http_safe_append";
      BOOL v88 = (char *)_os_log_send_and_compose_impl();
      v178[0] = OS_LOG_TYPE_ERROR;
      nw_protocol_definition_t v203 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v88, v178, &v203))
      {
        if (v178[0] == OS_LOG_TYPE_FAULT)
        {
          BOOL v89 = (os_log_s *)__nwlog_obj();
          os_log_type_t v90 = v178[0];
          if (!os_log_type_enabled(v89, v178[0])) {
            goto LABEL_417;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v205 = "_http_safe_append";
          BOOL v91 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_416;
        }

        if (v203 == OS_LOG_TYPE_DEFAULT)
        {
          BOOL v89 = (os_log_s *)__nwlog_obj();
          os_log_type_t v90 = v178[0];
          if (!os_log_type_enabled(v89, v178[0])) {
            goto LABEL_417;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v205 = "_http_safe_append";
          BOOL v91 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_416;
        }

        int v126 = (char *)__nw_create_backtrace_string();
        BOOL v89 = (os_log_s *)__nwlog_obj();
        os_log_type_t v90 = v178[0];
        uint64_t v127 = os_log_type_enabled(v89, v178[0]);
        if (v126)
        {
          if (v127)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v205 = "_http_safe_append";
            char v206 = 2082;
            uint64_t v207 = v126;
            _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v126);
          if (!v88) {
            goto LABEL_419;
          }
          goto LABEL_418;
        }

        if (v127)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v205 = "_http_safe_append";
          BOOL v91 = "%{public}s called with null (*remaining >= length), no backtrace";
LABEL_416:
          _os_log_impl(&dword_181A5C000, v89, v90, v91, buf, 0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v205 = "_http_safe_append";
      BOOL v88 = (char *)_os_log_send_and_compose_impl();
      v178[0] = OS_LOG_TYPE_ERROR;
      nw_protocol_definition_t v203 = OS_LOG_TYPE_DEFAULT;
      if (v178[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v89 = (os_log_s *)__nwlog_obj();
        os_log_type_t v90 = v178[0];
        if (!os_log_type_enabled(v89, v178[0])) {
          goto LABEL_417;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v205 = "_http_safe_append";
        BOOL v91 = "%{public}s called with null buffer";
        goto LABEL_416;
      }

      if (v203 == OS_LOG_TYPE_DEFAULT)
      {
        BOOL v89 = (os_log_s *)__nwlog_obj();
        os_log_type_t v90 = v178[0];
        if (!os_log_type_enabled(v89, v178[0])) {
          goto LABEL_417;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v205 = "_http_safe_append";
        BOOL v91 = "%{public}s called with null buffer, backtrace limit exceeded";
        goto LABEL_416;
      }

      char v120 = (char *)__nw_create_backtrace_string();
      BOOL v89 = (os_log_s *)__nwlog_obj();
      os_log_type_t v90 = v178[0];
      int v121 = os_log_type_enabled(v89, v178[0]);
      if (!v120)
      {
        if (!v121) {
          goto LABEL_417;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v205 = "_http_safe_append";
        BOOL v91 = "%{public}s called with null buffer, no backtrace";
        goto LABEL_416;
      }

      if (v121)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v205 = "_http_safe_append";
        char v206 = 2082;
        uint64_t v207 = v120;
        _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s called with null buffer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v120);
    }

LABEL_367:
                      _os_log_impl(&dword_181A5C000, v235, v236, v237, buf, 0xCu);
                      goto LABEL_368;
                    }

                    uint64_t v222 = v121;
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                    unsigned __int8 v223 = (char *)_os_log_send_and_compose_impl();
                    iterate_block[0] = 16;
                    type[0] = OS_LOG_TYPE_DEFAULT;
                    if (iterate_block[0] == 17)
                    {
                      v224 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v225 = iterate_block[0];
                      if (os_log_type_enabled(v224, (os_log_type_t)iterate_block[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                        os_log_type_t v226 = v224;
                        os_log_type_t v227 = v225;
                        v228 = "%{public}s called with null transport_protocol";
                        goto LABEL_355;
                      }

                      goto LABEL_356;
                    }

                    if (type[0])
                    {
                      v244 = (char *)__nw_create_backtrace_string();
                      uint64_t v245 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v246 = iterate_block[0];
                      BOOL v247 = os_log_type_enabled(v245, (os_log_type_t)iterate_block[0]);
                      if (v244)
                      {
                        if (v247)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v244;
                          _os_log_impl( &dword_181A5C000,  v245,  v246,  "%{public}s called with null transport_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v244);
                        goto LABEL_356;
                      }

                      if (!v247)
                      {
LABEL_356:
                        if (v223) {
                          free(v223);
                        }
                        int v64 = v520;
                        int v121 = v222;
                        goto LABEL_371;
                      }

                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                      os_log_type_t v226 = v245;
                      os_log_type_t v227 = v246;
                      v228 = "%{public}s called with null transport_protocol, no backtrace";
                    }

                    else
                    {
                      os_log_type_t v257 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v258 = iterate_block[0];
                      if (!os_log_type_enabled(v257, (os_log_type_t)iterate_block[0])) {
                        goto LABEL_356;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                      os_log_type_t v226 = v257;
                      os_log_type_t v227 = v258;
                      v228 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
                    }

      if (v207) {
        free(v207);
      }
      *(_DWORD *)(v11 + 344) = 0;
      int v15 = &qword_18C45F000;
      if ((*(_WORD *)(v14 + 428) & 8) == 0)
      {
LABEL_388:
        if ((*(_BYTE *)(v14 + 158) & 1) == 0)
        {
          if (*((_BYTE *)v15 + 1537))
          {
            __int16 v533 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v533, OS_LOG_TYPE_DEBUG))
            {
              int v534 = *(void *)(v14 + 256);
              v535 = *(_DWORD *)(*(void *)(v14 + 248) + 372LL);
              if (v534) {
                LODWORD(v534) = *(_DWORD *)(v534 + 860);
              }
              v536 = *(_DWORD *)(v14 + 424);
              __int16 v537 = *(_DWORD *)(v11 + 344);
              *(_DWORD *)buf = 136448258;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_stream";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v14 + 74;
              *(_WORD *)&buf[22] = 2080;
              v1051 = (uint64_t)" ";
              *(_WORD *)v1052 = 1024;
              *(_DWORD *)&v1052[2] = v535;
              *(_WORD *)&v1052[6] = 1024;
              *(_DWORD *)&v1052[8] = v534;
              *(_WORD *)&v1052[12] = 1024;
              *(_DWORD *)&v1052[14] = v536;
              *(_WORD *)&v1052[18] = 1024;
              *(_DWORD *)&v1052[20] = v536;
              *(_WORD *)&v1052[24] = 2048;
              *(void *)&v1052[26] = v14;
              *(_WORD *)&v1052[34] = 1024;
              *(_DWORD *)&v1052[36] = v537;
              _os_log_impl( &dword_181A5C000,  v533,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed stream %u (%p), now have %u streams",  buf,  0x48u);
            }
          }
        }

        if (*(nw_protocol **)(v11 + 48) == a2)
        {
          nw_protocol_set_input_handler(v11, 0LL);
          uint64_t v229 = *(void *)(v11 + 232);
          if (v229) {
            nw_protocol_set_input_handler(v11, *(void *)(v229 + 48));
          }
        }

        if ((*(_BYTE *)(v14 + 158) & 1) == 0)
        {
          if (*((_BYTE *)v15 + 1537))
          {
            v538 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v538, OS_LOG_TYPE_DEBUG))
            {
              v539 = *(void *)(v14 + 256);
              v540 = *(_DWORD *)(*(void *)(v14 + 248) + 372LL);
              if (v539) {
                LODWORD(v539) = *(_DWORD *)(v539 + 860);
              }
              v541 = *(_DWORD *)(v14 + 424);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_destroy";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v14 + 74;
              *(_WORD *)&buf[22] = 2080;
              v1051 = (uint64_t)" ";
              *(_WORD *)v1052 = 1024;
              *(_DWORD *)&v1052[2] = v540;
              *(_WORD *)&v1052[6] = 1024;
              *(_DWORD *)&v1052[8] = v539;
              *(_WORD *)&v1052[12] = 1024;
              *(_DWORD *)&v1052[14] = v541;
              *(_WORD *)&v1052[18] = 2048;
              *(void *)&v1052[20] = v14;
              _os_log_impl( &dword_181A5C000,  v538,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> destroying %p",  buf,  0x3Cu);
            }
          }
        }

        if ((*(_WORD *)(v14 + 428) & 0x4000) != 0) {
          nw_http_transaction_metadata_set_event_handler(*(void **)(v14 + 352), 0LL);
        }
        int v230 = *(_BYTE *)(v14 + 344);
        if ((v230 & 1) != 0)
        {
          uint64_t v231 = *(void **)(v14 + 336);
          if (v231)
          {
            os_release(v231);
            int v230 = *(_BYTE *)(v14 + 344);
          }
        }

        *(void *)(v14 + 336) = 0LL;
        *(_BYTE *)(v14 + 344) = v230 | 1;
        uint64_t v232 = *(_BYTE *)(v14 + 328);
        if ((v232 & 1) != 0)
        {
          uint64_t v233 = *(void **)(v14 + 320);
          if (v233)
          {
            os_release(v233);
            uint64_t v232 = *(_BYTE *)(v14 + 328);
          }
        }

        *(void *)(v14 + 320) = 0LL;
        *(_BYTE *)(v14 + 328) = v232 | 1;
        os_log_type_t v234 = *(_BYTE *)(v14 + 376);
        if ((v234 & 1) != 0)
        {
          v235 = *(void **)(v14 + 368);
          if (v235)
          {
            os_release(v235);
            os_log_type_t v234 = *(_BYTE *)(v14 + 376);
          }
        }

        *(void *)(v14 + 368) = 0LL;
        *(_BYTE *)(v14 + 376) = v234 | 1;
        os_log_type_t v236 = *(_BYTE *)(v14 + 392);
        if ((v236 & 1) != 0)
        {
          os_log_type_t v237 = *(void **)(v14 + 384);
          if (v237)
          {
            os_release(v237);
            os_log_type_t v236 = *(_BYTE *)(v14 + 392);
          }
        }

        *(void *)(v14 + 384) = 0LL;
        *(_BYTE *)(v14 + 392) = v236 | 1;
        v238 = *(void *)(v14 + 256);
        if (v238 && *(void *)(v238 + 488) == v14) {
          *(void *)(v238 + 488) = 0LL;
        }
        *(void *)(v14 + 256) = 0LL;
        v239 = *(void *)(v14 + 48);
        if (v239 && *(void *)(v239 + 56) == v14) {
          *(void *)(v239 + 56) = 0LL;
        }
        (*(void (**)(void, void))(*(void *)(v14 + 312) + 16LL))(*(void *)(v14 + 312), 0LL);
        os_log_type_t v240 = *(const void **)(v14 + 312);
        if (v240)
        {
          _Block_release(v240);
          *(void *)(v14 + 312) = 0LL;
        }

        nw_http1_stream::~nw_http1_stream((nw_http1_stream *)v14);
        free(v241);
        if (!v115) {
          goto LABEL_715;
        }
        if ((*(_BYTE *)(v11 + 376) & 1) == 0
          || ((*(unsigned __int16 *)(v16 + 872) | (*(unsigned __int8 *)(v16 + 874) << 16)) & 0x20000) == 0)
        {
          BOOL v243 = *(void *)(v11 + 248);
          if (v243)
          {
            v1041 = *(void *)(v11 + 248);
            if ((*(_BYTE *)(v243 + 158) & 1) == 0)
            {
              if (*((_BYTE *)v15 + 1537))
              {
                v728 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v728, OS_LOG_TYPE_DEBUG))
                {
                  v729 = v243 + 74;
                  v730 = *(void *)(v243 + 256);
                  v731 = *(_DWORD *)(*(void *)(v243 + 248) + 372LL);
                  if (v730) {
                    LODWORD(v730) = *(_DWORD *)(v730 + 860);
                  }
                  BOOL v243 = v1041;
                  v732 = *(_DWORD *)(v1041 + 424);
                  *(_DWORD *)buf = 136448002;
                  *(void *)&uint8_t buf[4] = "nw_http1_get_next_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v729;
                  *(_WORD *)&buf[22] = 2080;
                  v1051 = (uint64_t)" ";
                  *(_WORD *)v1052 = 1024;
                  *(_DWORD *)&v1052[2] = v731;
                  *(_WORD *)&v1052[6] = 1024;
                  *(_DWORD *)&v1052[8] = v730;
                  *(_WORD *)&v1052[12] = 1024;
                  *(_DWORD *)&v1052[14] = v732;
                  *(_WORD *)&v1052[18] = 1024;
                  *(_DWORD *)&v1052[20] = v732;
                  *(_WORD *)&v1052[24] = 2048;
                  *(void *)&v1052[26] = v1041;
                  _os_log_impl( &dword_181A5C000,  v728,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> found stream %u (%p)",  buf,  0x42u);
                  int v11 = v1042;
                  int v15 = &qword_18C45F000;
                }
              }
            }

            v244 = (_OWORD *)(v243 + 64);
            uint64_t v245 = *(void *)(v11 + 208);
            if (v245)
            {
              os_log_type_t v246 = 0LL;
              BOOL v247 = v11 + 74;
              do
              {
                v248 = v245;
                uint64_t v245 = *(void *)(v245 + 592);
                if ((*(_WORD *)(v248 + 872) & 0x800) == 0)
                {
                  if ((*(_BYTE *)(v1042 + 158) & 1) != 0 || !gLogDatapath)
                  {
                    os_log_type_t v246 = v248;
                  }

                  else
                  {
                    v1032 = v247;
                    v1038 = v244;
                    v249 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v249, OS_LOG_TYPE_DEBUG))
                    {
                      os_log_type_t v250 = *(_DWORD *)(v1042 + 372);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_http1_get_next_idle_connection";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v1032;
                      *(_WORD *)&buf[22] = 2080;
                      v1051 = (uint64_t)" ";
                      *(_WORD *)v1052 = 1024;
                      *(_DWORD *)&v1052[2] = v250;
                      *(_WORD *)&v1052[6] = 2048;
                      *(void *)&v1052[8] = v248;
                      _os_log_impl( &dword_181A5C000,  v249,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> found idle connection connection %p",  buf,  0x30u);
                      BOOL v247 = v1032;
                      os_log_type_t v246 = v248;
                      v244 = v1038;
                    }

                    else
                    {
                      os_log_type_t v246 = v248;
                      v244 = v1038;
                      BOOL v247 = v1032;
                    }
                  }
                }
              }

              while (v245);
              int v11 = v1042;
              int v15 = &qword_18C45F000;
              BOOL v243 = v1041;
              if (v246)
              {
                v1033 = v247;
                if ((*(_BYTE *)(v246 + 158) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    v759 = v244;
                    v760 = (os_log_s *)__nwlog_obj();
                    v761 = os_log_type_enabled(v760, OS_LOG_TYPE_DEBUG);
                    v244 = v759;
                    if (v761)
                    {
                      v762 = *(void *)(v246 + 488);
                      v763 = *(_DWORD *)(*(void *)(v246 + 480) + 372LL);
                      v764 = *(_DWORD *)(v246 + 860);
                      if (v762) {
                        LODWORD(v762) = *(_DWORD *)(v762 + 424);
                      }
                      *(_DWORD *)buf = 136447746;
                      *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v246 + 74;
                      *(_WORD *)&buf[22] = 2080;
                      v1051 = (uint64_t)" ";
                      *(_WORD *)v1052 = 1024;
                      *(_DWORD *)&v1052[2] = v763;
                      *(_WORD *)&v1052[6] = 1024;
                      *(_DWORD *)&v1052[8] = v764;
                      *(_WORD *)&v1052[12] = 1024;
                      *(_DWORD *)&v1052[14] = v762;
                      *(_WORD *)&v1052[18] = 2048;
                      *(void *)&v1052[20] = v246;
                      _os_log_impl( &dword_181A5C000,  v760,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> called for connection %p",  buf,  0x3Cu);
                      int v11 = v1042;
                      BOOL v243 = v1041;
                      v244 = v759;
                    }
                  }
                }

                v1039 = v244;
                BOOL v251 = (_WORD *)(v246 + 872);
                if (((*(unsigned __int16 *)(v246 + 872) | (*(unsigned __int8 *)(v246 + 874) << 16)) & 0x80000) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                  *(_WORD *)&_BYTE buf[12] = 2048;
                  *(void *)&buf[14] = v246;
                  v252 = (char *)_os_log_send_and_compose_impl();
                  v1065[0] = 16;
                  aBlock[0] = 0;
                  if (v1065[0] == 17)
                  {
                    os_log_type_t v253 = (os_log_s *)__nwlog_obj();
                    os_log_type_t v254 = v1065[0];
                    if (!os_log_type_enabled(v253, (os_log_type_t)v1065[0])) {
                      goto LABEL_614;
                    }
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v246;
                    BOOL v255 = "%{public}s connection %p not in idle list, cannot remove";
                  }

                  else if (aBlock[0])
                  {
                    uint64_t v337 = (char *)__nw_create_backtrace_string();
                    os_log_type_t v253 = (os_log_s *)__nwlog_obj();
                    os_log_type_t v254 = v1065[0];
                    v338 = os_log_type_enabled(v253, (os_log_type_t)v1065[0]);
                    if (v337)
                    {
                      if (v338)
                      {
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                        *(_WORD *)&_BYTE buf[12] = 2048;
                        *(void *)&buf[14] = v246;
                        *(_WORD *)&buf[22] = 2082;
                        v1051 = (uint64_t)v337;
                        _os_log_impl( &dword_181A5C000,  v253,  v254,  "%{public}s connection %p not in idle list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
                      }

                      free(v337);
                      BOOL v243 = v1041;
                      goto LABEL_614;
                    }

                    BOOL v243 = v1041;
                    if (!v338)
                    {
LABEL_614:
                      if (v252) {
                        free(v252);
                      }
                      goto LABEL_644;
                    }

                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v246;
                    BOOL v255 = "%{public}s connection %p not in idle list, cannot remove, no backtrace";
                  }

                  else
                  {
                    os_log_type_t v253 = (os_log_s *)__nwlog_obj();
                    os_log_type_t v254 = v1065[0];
                    if (!os_log_type_enabled(v253, (os_log_type_t)v1065[0])) {
                      goto LABEL_614;
                    }
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v246;
                    BOOL v255 = "%{public}s connection %p not in idle list, cannot remove, backtrace limit exceeded";
                  }

                  _os_log_impl(&dword_181A5C000, v253, v254, v255, buf, 0x16u);
                  goto LABEL_614;
                }

                BOOL v294 = *(void *)(v246 + 592);
                int v295 = *(void **)(v246 + 600);
                if (v294)
                {
                  *(void *)(v294 + 600) = v295;
                  int v295 = *(void **)(v246 + 600);
                }

                else
                {
                  *(void *)(v11 + 216) = v295;
                }

                *int v295 = v294;
                *(void *)(v246 + 592) = 0LL;
                *(void *)(v246 + 600) = 0LL;
                v339 = *(_DWORD *)(v11 + 340);
                *(_DWORD *)(v11 + 340) = v339 - 1;
                if (v339)
                {
LABEL_638:
                  uint64_t v384 = (unsigned __int16)*v251;
                  v385 = (v384 | (*(unsigned __int8 *)(v246 + 874) << 16)) & 0xFFF7FFFF;
                  char *v251 = v384;
                  *(_BYTE *)(v246 + 874) = BYTE2(v385);
                  if ((*(_BYTE *)(v246 + 158) & 1) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v801 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v801, OS_LOG_TYPE_DEBUG))
                      {
                        v802 = *(void *)(v246 + 488);
                        v803 = *(_DWORD *)(*(void *)(v246 + 480) + 372LL);
                        v804 = *(_DWORD *)(v246 + 860);
                        if (v802) {
                          LODWORD(v802) = *(_DWORD *)(v802 + 424);
                        }
                        int v11 = v1042;
                        v805 = *(_DWORD *)(v1042 + 340);
                        *(_DWORD *)buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v246 + 74;
                        *(_WORD *)&buf[22] = 2080;
                        v1051 = (uint64_t)" ";
                        *(_WORD *)v1052 = 1024;
                        *(_DWORD *)&v1052[2] = v803;
                        *(_WORD *)&v1052[6] = 1024;
                        *(_DWORD *)&v1052[8] = v804;
                        *(_WORD *)&v1052[12] = 1024;
                        *(_DWORD *)&v1052[14] = v802;
                        *(_WORD *)&v1052[18] = 2048;
                        *(void *)&v1052[20] = v246;
                        *(_WORD *)&v1052[28] = 1024;
                        *(_DWORD *)&v1052[30] = v805;
                        _os_log_impl( &dword_181A5C000,  v801,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed idle connection %p, now have %u idle connections",  buf,  0x42u);
                        BOOL v243 = v1041;
                      }
                    }
                  }

                  if (*(void *)(v246 + 784))
                  {
                    if ((*(_BYTE *)(v246 + 158) & 1) == 0)
                    {
                      if (gLogDatapath)
                      {
                        v820 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v820, OS_LOG_TYPE_DEBUG))
                        {
                          v821 = *(void *)(v246 + 488);
                          v822 = *(_DWORD *)(*(void *)(v246 + 480) + 372LL);
                          v823 = *(_DWORD *)(v246 + 860);
                          if (v821) {
                            LODWORD(v821) = *(_DWORD *)(v821 + 424);
                          }
                          *(_DWORD *)buf = 136447746;
                          *(void *)&uint8_t buf[4] = "nw_http1_remove_idle_connection";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v246 + 74;
                          *(_WORD *)&buf[22] = 2080;
                          v1051 = (uint64_t)" ";
                          *(_WORD *)v1052 = 1024;
                          *(_DWORD *)&v1052[2] = v822;
                          *(_WORD *)&v1052[6] = 1024;
                          *(_DWORD *)&v1052[8] = v823;
                          *(_WORD *)&v1052[12] = 1024;
                          *(_DWORD *)&v1052[14] = v821;
                          *(_WORD *)&v1052[18] = 2048;
                          *(void *)&v1052[20] = v246;
                          _os_log_impl( &dword_181A5C000,  v820,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> deactivating destroy timer for connection %p",  buf,  0x3Cu);
                          int v11 = v1042;
                          BOOL v243 = v1041;
                        }
                      }
                    }

                    nw_queue_cancel_source(*(void *)(v246 + 784), v242);
                    *(void *)(v246 + 784) = 0LL;
                  }

LABEL_378:
                    BOOL v268 = *(void **)(v63 + 48);
                    nw_protocol_error(v268, v63);
                    nw_protocol_disconnected(v268, v63);
LABEL_379:
                    os_release(v121);
                    uint64_t v63 = *(void *)(v13 + 328);
                    if (!v63) {
                      goto LABEL_720;
                    }
                    goto LABEL_237;
                  }

                  if ((*(_BYTE *)(v63 + 276) & 0x40) != 0) {
                    goto LABEL_270;
                  }
LABEL_269:
                  nw_webtransport_http3_stream_fix_http_parameters(v109, v63);
                  goto LABEL_270;
                }

                if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v135 = (os_log_s *)gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v136 = *(void *)(v63 + 88);
                    if (v136) {
                      int v137 = *(_DWORD *)(v136 + 460);
                    }
                    else {
                      int v137 = -1;
                    }
                    uint64_t v147 = *(void *)(v63 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v63 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    uint64_t v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v137;
                    *(_WORD *)&v532[6] = 2048;
                    *(void *)&v532[8] = v147;
                    _os_log_impl( &dword_181A5C000,  v135,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Preemptively configuring metadata with incoming stream ID",  buf,  0x30u);
                  }
                }

                if (*(void *)(v109 + 176) != -1LL)
                {
                  if (*(void *)(v63 + 64) == -1LL)
                  {
                    uint64_t v151 = *(void *)(*(void *)(v63 + 88) + 176LL);
                    if (v151 == -1)
                    {
                      if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                      {
                        int v167 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v168 = *(void *)(v63 + 88);
                          if (v168) {
                            int v169 = *(_DWORD *)(v168 + 460);
                          }
                          else {
                            int v169 = -1;
                          }
                          uint64_t v174 = *(void *)(v63 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v169;
                          *(_WORD *)&v532[6] = 2048;
                          *(void *)&v532[8] = v174;
                          _os_log_impl( &dword_181A5C000,  v167,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing",  buf,  0x30u);
                        }
                      }

                      uint64_t v175 = *(void **)(v63 + 48);
                      nw_protocol_error(v175, v63);
                      nw_protocol_disconnected(v175, v63);
                    }

                    else
                    {
                      *(void *)(v63 + 64) = v151;
                      nw_webtransport_metadata_set_stream_id(*(void **)(v63 + 160), v151);
                      if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                      {
                        uint64_t v152 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v152, OS_LOG_TYPE_INFO))
                        {
                          uint64_t v153 = *(void *)(v63 + 88);
                          if (v153) {
                            int v154 = *(_DWORD *)(v153 + 460);
                          }
                          else {
                            int v154 = -1;
                          }
                          uint64_t v173 = *(void *)(v63 + 64);
                          *(_DWORD *)buf = 136448002;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v154;
                          *(_WORD *)&v532[6] = 2048;
                          *(void *)&v532[8] = v173;
                          *(_WORD *)&v532[16] = 2048;
                          *(void *)&v532[18] = v173;
                          *(_WORD *)&v532[26] = 2048;
                          *(void *)&v532[28] = v63;
                          __int16 v533 = 1024;
                          int v534 = 1;
                          _os_log_impl( &dword_181A5C000,  v152,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u",  buf,  0x4Au);
                        }
                      }
                    }
                  }

                  else if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                  {
                    if (gLogDatapath)
                    {
                      uint64_t v148 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v148, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v149 = *(void *)(v63 + 88);
                        if (v149) {
                          int v150 = *(_DWORD *)(v149 + 460);
                        }
                        else {
                          int v150 = -1;
                        }
                        uint64_t v269 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447490;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v150;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v269;
                        *(_WORD *)&v532[16] = 2048;
                        *(void *)&v532[18] = v269;
                        _os_log_impl( &dword_181A5C000,  v148,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping",  buf,  0x3Au);
                      }
                    }
                  }

                  uint64_t v176 = *(void *)(v63 + 64);
                  char v177 = *(_BYTE *)(v63 + 276);
                  if (v176 == -1)
                  {
                    if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                    {
                      v181 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v182 = *(void *)(v63 + 88);
                        if (v182) {
                          int v183 = *(_DWORD *)(v182 + 460);
                        }
                        else {
                          int v183 = -1;
                        }
                        uint64_t v209 = *(void *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v183;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v209;
                        _os_log_impl( &dword_181A5C000,  v181,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set",  buf,  0x30u);
                        if ((*(_BYTE *)(v63 + 276) & 0x40) != 0) {
                          goto LABEL_270;
                        }
                        goto LABEL_269;
                      }
                    }
                  }

                  else
                  {
                    *(_BYTE *)(v63 + 276) = v177 & 0xF0 | (4 * ((v176 & 2) != 0)) | 3;
                    if ((v177 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v178 = (os_log_s *)gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v179 = *(void *)(v63 + 88);
                        if (v179) {
                          int v180 = *(_DWORD *)(v179 + 460);
                        }
                        else {
                          int v180 = -1;
                        }
                        uint64_t v184 = *(void *)(v63 + 64);
                        unsigned int v185 = *(unsigned __int8 *)(v63 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v180;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v184;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v185 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v185 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v185 >> 2) & 1;
                        _os_log_impl( &dword_181A5C000,  v178,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagr am: %u, unidirectional: %u",  buf,  0x42u);
                      }
                    }

                    nw_webtransport_metadata_set_is_peer_initiated( *(void **)(v63 + 160),  (*(_BYTE *)(v63 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional( *(void **)(v63 + 160),  (*(_BYTE *)(v63 + 276) & 4) != 0);
                  }
                }

                if ((*(_BYTE *)(v63 + 276) & 0x40) != 0) {
                  goto LABEL_270;
                }
                goto LABEL_269;
              }

              if ((*(_BYTE *)(v63 + 276) & 0x10) != 0) {
                goto LABEL_236;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v132 = (os_log_s *)gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
                goto LABEL_236;
              }
              uint64_t v133 = *(void *)(v63 + 88);
              if (v133) {
                int v134 = *(_DWORD *)(v133 + 460);
              }
              else {
                int v134 = -1;
              }
              uint64_t v146 = *(void *)(v63 + 64);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v63 + 192;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v134;
              *(_WORD *)&v532[6] = 2048;
              *(void *)&v532[8] = v146;
              _os_log_impl( &dword_181A5C000,  v132,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring",  buf,  0x30u);
              uint64_t v63 = *(void *)(v13 + 328);
              if (!v63) {
                goto LABEL_720;
              }
            }

LABEL_777:
        if (!v484) {
          goto LABEL_721;
        }
LABEL_778:
        free(v484);
        goto LABEL_721;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
      v484 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (iterate_block[0] == 17)
      {
        v485 = (os_log_s *)__nwlog_obj();
        os_log_type_t v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0])) {
          goto LABEL_777;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
LABEL_775:
        v505 = v485;
        os_log_type_t v506 = v486;
LABEL_776:
        _os_log_impl(&dword_181A5C000, v505, v506, v487, buf, 0xCu);
        goto LABEL_777;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v485 = (os_log_s *)__nwlog_obj();
        os_log_type_t v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0])) {
          goto LABEL_777;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_775;
      }

      v496 = (char *)__nw_create_backtrace_string();
      v497 = (os_log_s *)__nwlog_obj();
      os_log_type_t v498 = iterate_block[0];
      BOOL v499 = os_log_type_enabled(v497, (os_log_type_t)iterate_block[0]);
      if (v496)
      {
        if (v499)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v496;
          _os_log_impl( &dword_181A5C000,  v497,  v498,  "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v496);
        goto LABEL_777;
      }

      if (!v499) {
        goto LABEL_777;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_response";
      v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
LABEL_790:
      v505 = v497;
      os_log_type_t v506 = v498;
      goto LABEL_776;
    }

    if (nw_protocol_metadata_is_http(v12))
    {
      if ((*(_BYTE *)(v13 + 548) & 2) == 0)
      {
        if (gLogDatapath)
        {
          v490 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v490, OS_LOG_TYPE_DEBUG))
          {
            int v491 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v491;
            _os_log_impl(&dword_181A5C000, v490, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }

      id v523 = nw_http_metadata_copy_request(v14);
      if (v523)
      {
        well_known = (void *)_nw_http_response_create_well_known(200LL);
        metadata_for_response = nw_http_create_metadata_for_response(well_known);
        uint64_t v34 = *(void *)(v13 + 32);
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v492 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v492, OS_LOG_TYPE_DEBUG))
            {
              int v493 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)iterate_block = 136446978;
              *(void *)&iterate_void block[4] = "nw_webtransport_session_send_metadata";
              *(_WORD *)&iterate_block[12] = 2082;
              *(void *)&iterate_block[14] = v13 + 464;
              *(_WORD *)&iterate_block[22] = 2080;
              v540 = " ";
              LOWORD(v541) = 1024;
              *(_DWORD *)((char *)&v541 + 2) = v493;
              _os_log_impl( &dword_181A5C000,  v492,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called",  iterate_block,  0x26u);
            }
          }
        }

        *(void *)os_log_type_t type = 0LL;
        v527 = type;
        int output_frames = nw_protocol_get_output_frames(v34, v13, 0LL, 0LL, 1LL, (uint64_t)type);
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v494 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v494, OS_LOG_TYPE_DEBUG))
            {
              int v495 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)iterate_block = 136447234;
              *(void *)&iterate_void block[4] = "nw_webtransport_session_send_metadata";
              *(_WORD *)&iterate_block[12] = 2082;
              *(void *)&iterate_block[14] = v13 + 464;
              *(_WORD *)&iterate_block[22] = 2080;
              v540 = " ";
              LOWORD(v541) = 1024;
              *(_DWORD *)((char *)&v541 + 2) = v495;
              HIWORD(v541) = 1024;
              LODWORD(v542) = output_frames;
              _os_log_impl( &dword_181A5C000,  v494,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Got %u output frames",  iterate_block,  0x2Cu);
            }
          }
        }

        v522 = metadata_for_response;
        if (!output_frames) {
          goto LABEL_48;
        }
        *(void *)iterate_block = 0LL;
        *(void *)&iterate_block[8] = iterate_block;
        *(void *)&iterate_block[16] = 0x2000000000LL;
        LOBYTE(v540) = 0;
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke;
        uint64_t v531 = (uint64_t)&unk_189BBC690;
        *(void *)v532 = iterate_block;
        *(void *)&v532[8] = type;
        *(void *)&v532[16] = v13;
        *(void *)&v532[24] = metadata_for_response;
        uint64_t v36 = *(void *)type;
        do
        {
          if (!v36) {
            break;
          }
          uint64_t v37 = *(void *)(v36 + 32);
          char v38 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          uint64_t v36 = v37;
        }

        while ((v38 & 1) != 0);
        char v39 = nw_protocol_finalize_output_frames(v34, (uint64_t)type);
        _Block_object_dispose(iterate_block, 8);
        if ((v39 & 1) == 0)
        {
LABEL_48:
          if (*(_DWORD *)(v13 + 444) != 5)
          {
            if ((*(_BYTE *)(v13 + 548) & 2) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v51 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
              {
                int v52 = *(_DWORD *)(v13 + 460);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v13 + 464;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v52;
                *(_WORD *)&v532[6] = 1024;
                *(_DWORD *)&v532[8] = 57;
                _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d",  buf,  0x2Cu);
              }
            }

            *(_DWORD *)(v13 + 444) = 5;
            char v53 = *(char **)(v13 + 184);
            if (v53)
            {
              *(void *)buf = MEMORY[0x1895F87A8];
              *(void *)&buf[8] = 0x40000000LL;
              *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
              uint64_t v531 = (uint64_t)&__block_descriptor_tmp_22_33505;
              *(_DWORD *)v532 = 57;
              nw_hash_table_apply(v53, (uint64_t)buf);
            }

            uint64_t v54 = *(void *)(v13 + 424);
            if (v54)
            {
              uint64_t v55 = *(void **)(v54 + 48);
              nw_protocol_error(v55, *(void *)(v13 + 424));
              nw_protocol_disconnected(v55, v54);
            }

            uint64_t v56 = *(void *)(v13 + 328);
            if (v56)
            {
              do
              {
                uint64_t v57 = *(void *)(v56 + 112);
                uint64_t v58 = *(void **)(v56 + 48);
                nw_protocol_error(v58, v56);
                nw_protocol_disconnected(v58, v56);
                uint64_t v56 = v57;
              }

              while (v57);
            }

            uint64_t v59 = *(void *)(v13 + 416);
            if (v59)
            {
              uint64_t v60 = *(void **)(v59 + 48);
              nw_protocol_error(v60, *(void *)(v13 + 416));
              nw_protocol_disconnected(v60, v59);
            }

            if (*(void *)(v13 + 32))
            {
              nw_protocol_remove_instance(v13);
              nw_protocol_disconnect(*(void **)(v13 + 32), v13);
            }

            goto LABEL_716;
          }

          if ((*(_BYTE *)(v13 + 548) & 2) != 0
            || (pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once),
                networkd_settings_init(),
                uint64_t v47 = gLogObj,
                !os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)))
          {
LABEL_716:
            if (v522) {
              os_release(v522);
            }
            if (well_known) {
              os_release(well_known);
            }
            goto LABEL_720;
          }

          int v48 = *(_DWORD *)(v13 + 460);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v13 + 464;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v531 = (uint64_t)" ";
          *(_WORD *)v532 = 1024;
          *(_DWORD *)&v532[2] = v48;
          char v43 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
          uint64_t v44 = (os_log_s *)v47;
          os_log_type_t v45 = OS_LOG_TYPE_INFO;
          uint32_t v46 = 38;
LABEL_52:
          _os_log_impl(&dword_181A5C000, v44, v45, v43, buf, v46);
          goto LABEL_716;
        }

        if (*(_DWORD *)(v13 + 444) == 4)
        {
          if ((*(_BYTE *)(v13 + 548) & 2) != 0) {
            goto LABEL_716;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v40 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_716;
          }
          int v41 = *(_DWORD *)(v13 + 460);
          int v42 = *(_DWORD *)(v13 + 444);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v13 + 464;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v531 = (uint64_t)" ";
          *(_WORD *)v532 = 1024;
          *(_DWORD *)&v532[2] = v41;
          *(_WORD *)&v532[6] = 1024;
          *(_DWORD *)&v532[8] = v42;
          char v43 = "%{public}s %{public}s%s<i%u> Tried to ready streams with incorrect state: %d, ignoring";
          uint64_t v44 = (os_log_s *)v40;
          os_log_type_t v45 = OS_LOG_TYPE_ERROR;
          uint32_t v46 = 44;
          goto LABEL_52;
        }

        *(_DWORD *)(v13 + 444) = 4;
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v280 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            int v281 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_streams_ready";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v281;
            _os_log_impl( &dword_181A5C000,  v280,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Webtransport session established, reconfiguring streams",  buf,  0x26u);
          }
        }

        uint64_t v282 = *(void *)(v13 + 328);
        if (!v282) {
          goto LABEL_716;
        }
        v515 = well_known;
        if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v510 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v510, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v511 = *(void *)(v282 + 88);
              if (v511) {
                int v512 = *(_DWORD *)(v511 + 460);
              }
              else {
                int v512 = -1;
              }
              uint64_t v514 = *(void *)(v282 + 64);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v282 + 192;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v512;
              *(_WORD *)&v532[6] = 2048;
              *(void *)&v532[8] = v514;
              *(_WORD *)&v532[16] = 2048;
              *(void *)&v532[18] = v282;
              _os_log_impl( &dword_181A5C000,  v510,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)",  buf,  0x3Au);
            }
          }
        }

        int v521 = *(_BYTE *)(v13 + 548) & 1;
        while (1)
        {
          if ((*(_BYTE *)(v13 + 548) & 2) == 0)
          {
            if (gLogDatapath)
            {
              v428 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v428, OS_LOG_TYPE_DEBUG))
              {
                int v429 = *(_DWORD *)(v13 + 460);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v13 + 464;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v429;
                *(_WORD *)&v532[6] = 2048;
                *(void *)&v532[8] = v282;
                _os_log_impl( &dword_181A5C000,  v428,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream (%p)",  buf,  0x30u);
              }
            }
          }

          if ((*(_BYTE *)(v282 + 276) & 0x20) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(void *)&buf[14] = v282;
            v283 = (char *)_os_log_send_and_compose_impl();
            iterate_block[0] = 16;
            type[0] = OS_LOG_TYPE_DEFAULT;
            if (iterate_block[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v284 = gLogObj;
              os_log_type_t v285 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v282;
                v286 = (os_log_s *)v284;
                os_log_type_t v287 = v285;
                os_log_type_t v288 = "%{public}s stream %p not in pending list, cannot remove";
                goto LABEL_438;
              }

              goto LABEL_439;
            }

            if (type[0])
            {
              uint64_t v291 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v292 = (os_log_s *)gLogObj;
              os_log_type_t v293 = iterate_block[0];
              BOOL v294 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
              if (v291)
              {
                if (v294)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2048;
                  *(void *)&buf[14] = v282;
                  *(_WORD *)&buf[22] = 2082;
                  uint64_t v531 = (uint64_t)v291;
                  _os_log_impl( &dword_181A5C000,  v292,  v293,  "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(v291);
                goto LABEL_439;
              }

              if (!v294)
              {
LABEL_439:
                if (v283) {
                  free(v283);
                }
                goto LABEL_451;
              }

              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v282;
              v286 = v292;
              os_log_type_t v287 = v293;
              os_log_type_t v288 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v304 = gLogObj;
              os_log_type_t v305 = iterate_block[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0])) {
                goto LABEL_439;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v282;
              v286 = (os_log_s *)v304;
              os_log_type_t v287 = v305;
              os_log_type_t v288 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            }

    _os_log_impl(&dword_181A5C000, v430, v431, v432, buf, 0xCu);
    goto LABEL_778;
  }

  if ((*(_BYTE *)(v3 + 158) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v27 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      BOOL v30 = *(_DWORD *)(v580 + 372);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http1_match_idle_connection_with_pending_stream";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v580 + 74;
      *(_WORD *)&buf[22] = 2080;
      v608 = (uint64_t)" ";
      *(_WORD *)v609 = 1024;
      *(_DWORD *)&v609[2] = v30;
      uint64_t v29 = "%{public}s %{public}s%s<i%u> no pending streams, nothing to do";
      goto LABEL_40;
    }
  }

LABEL_438:
            _os_log_impl(&dword_181A5C000, v286, v287, v288, buf, 0x16u);
            goto LABEL_439;
          }

          uint64_t v289 = *(void *)(v282 + 112);
          uint64_t v290 = *(void **)(v282 + 120);
          if (v289)
          {
            *(void *)(v289 + 120) = v290;
            uint64_t v290 = *(void **)(v282 + 120);
          }

          else
          {
            *(void *)(v13 + 336) = v290;
          }

          *uint64_t v290 = v289;
          *(void *)(v282 + 112) = 0LL;
          *(void *)(v282 + 120) = 0LL;
          int v295 = *(_DWORD *)(v13 + 456);
          *(_DWORD *)(v13 + 456) = v295 - 1;
          if (!v295) {
            break;
          }
LABEL_449:
          char v315 = *(_BYTE *)(v282 + 276);
          *(_BYTE *)(v282 + 276) = v315 & 0xDF;
          if ((v315 & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v430 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v430, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v431 = *(void *)(v282 + 88);
                if (v431) {
                  int v432 = *(_DWORD *)(v431 + 460);
                }
                else {
                  int v432 = -1;
                }
                uint64_t v446 = *(void *)(v282 + 64);
                int v447 = *(_DWORD *)(v13 + 456);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v432;
                *(_WORD *)&v532[6] = 2048;
                *(void *)&v532[8] = v446;
                *(_WORD *)&v532[16] = 2048;
                *(void *)&v532[18] = v282;
                *(_WORD *)&v532[26] = 1024;
                *(_DWORD *)&v532[28] = v447;
                _os_log_impl( &dword_181A5C000,  v430,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams",  buf,  0x40u);
                well_known = v515;
              }
            }
          }

        if (*(void *)(v15 + 248))
        {
          if (!*(void *)(v81 + 488))
          {
            *(void *)(v15 + 256) = v81;
            *(void *)(v81 + 488) = v15;
            nw_protocol_set_output_handler(v15, *(void *)(v81 + 32));
            nw_protocol_set_input_handler(v81, *(void *)(v15 + 48));
            *(_OWORD *)int v15 = *(_OWORD *)v81;
            v297 = *(_OWORD *)(v15 + 144);
            os_log_type_t v299 = *(_OWORD *)(v15 + 96);
            uint64_t v298 = *(_OWORD *)(v15 + 112);
            *(_OWORD *)(v81 + 128) = *(_OWORD *)(v15 + 128);
            *(_OWORD *)(v81 + 144) = v297;
            *(_OWORD *)(v81 + 96) = v299;
            *(_OWORD *)(v81 + 112) = v298;
            uint64_t v300 = *(_OWORD *)(v15 + 80);
            *(_OWORD *)(v81 + 64) = *v753;
            *(_OWORD *)(v81 + 80) = v300;
            nw_http_transaction_metadata_set_connection_metadata(*(void **)(v15 + 352), *(void **)(v81 + 768));
            *v89 &= 0xFFD7u;
            *(_DWORD *)(v81 + 864) = 1;
            if ((*(_BYTE *)(v81 + 158) & 1) == 0)
            {
              v301 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v301, OS_LOG_TYPE_DEBUG))
              {
                os_log_type_t v302 = *(void *)(v81 + 488);
                os_log_type_t v303 = *(_DWORD *)(*(void *)(v81 + 480) + 372LL);
                uint64_t v304 = *(_DWORD *)(v81 + 860);
                if (v302) {
                  LODWORD(v302) = *(_DWORD *)(v302 + 424);
                }
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v81 + 74;
                *(_WORD *)&buf[22] = 2080;
                v783 = (uint64_t)" ";
                *(_WORD *)v784 = 1024;
                *(_DWORD *)&v784[2] = v303;
                *(_WORD *)&v784[6] = 1024;
                *(_DWORD *)&v784[8] = v304;
                *(_WORD *)&v784[12] = 1024;
                *(_DWORD *)&v784[14] = v302;
                _os_log_impl( &dword_181A5C000,  v301,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: reading",  buf,  0x32u);
              }
            }

            if ((*(_BYTE *)(v15 + 158) & 1) == 0)
            {
              os_log_type_t v305 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v305, OS_LOG_TYPE_INFO))
              {
                int v306 = *(void *)(v15 + 256);
                v307 = *(_DWORD *)(*(void *)(v15 + 248) + 372LL);
                if (v306) {
                  LODWORD(v306) = *(_DWORD *)(v306 + 860);
                }
                os_log_type_t v308 = *(_DWORD *)(v15 + 424);
                *(_DWORD *)buf = 136448002;
                *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v15 + 74;
                *(_WORD *)&buf[22] = 2080;
                v783 = (uint64_t)" ";
                *(_WORD *)v784 = 1024;
                *(_DWORD *)&v784[2] = v307;
                *(_WORD *)&v784[6] = 1024;
                *(_DWORD *)&v784[8] = v306;
                *(_WORD *)&v784[12] = 1024;
                *(_DWORD *)&v784[14] = v308;
                *(_WORD *)&v784[18] = 2048;
                *(void *)&v784[20] = v15;
                *(_WORD *)&v784[28] = 2048;
                *(void *)&v784[30] = v81;
                _os_log_impl( &dword_181A5C000,  v305,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:c%u:s%u> stream (%p) now using connection %p",  buf,  0x46u);
              }
            }

            goto LABEL_468;
          }

          __nwlog_obj();
          uint64_t v291 = *(void *)(v81 + 488);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v81;
          *(_WORD *)&buf[22] = 2048;
          v783 = v291;
          uint64_t v292 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(aBlock) = 0;
          if (__nwlog_fault(v292, type, &aBlock))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v293 = (os_log_s *)__nwlog_obj();
              BOOL v294 = type[0];
              if (!os_log_type_enabled(v293, type[0])) {
                goto LABEL_466;
              }
              int v295 = *(void *)(v81 + 488);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v81;
              *(_WORD *)&buf[22] = 2048;
              v783 = v295;
              uint64_t v296 = "%{public}s Connection %p already has a stream (%p)";
              goto LABEL_464;
            }

            if (!(_BYTE)aBlock)
            {
              os_log_type_t v293 = (os_log_s *)__nwlog_obj();
              BOOL v294 = type[0];
              if (!os_log_type_enabled(v293, type[0])) {
                goto LABEL_466;
              }
              os_log_type_t v312 = *(void *)(v81 + 488);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v81;
              *(_WORD *)&buf[22] = 2048;
              v783 = v312;
              uint64_t v296 = "%{public}s Connection %p already has a stream (%p), backtrace limit exceeded";
              goto LABEL_464;
            }

            BOOL v309 = (char *)__nw_create_backtrace_string();
            os_log_type_t v293 = (os_log_s *)__nwlog_obj();
            BOOL v294 = type[0];
            uint64_t v310 = os_log_type_enabled(v293, type[0]);
            if (v309)
            {
              if (v310)
              {
                uint64_t v311 = *(void *)(v81 + 488);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v81;
                *(_WORD *)&buf[22] = 2048;
                v783 = v311;
                *(_WORD *)v784 = 2082;
                *(void *)&v784[2] = v309;
                _os_log_impl( &dword_181A5C000,  v293,  v294,  "%{public}s Connection %p already has a stream (%p), dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(v309);
              if (!v292) {
                goto LABEL_468;
              }
              goto LABEL_467;
            }

            if (v310)
            {
              uint64_t v313 = *(void *)(v81 + 488);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v81;
              *(_WORD *)&buf[22] = 2048;
              v783 = v313;
              uint64_t v296 = "%{public}s Connection %p already has a stream (%p), no backtrace";
LABEL_464:
              uint64_t v314 = v293;
              char v315 = v294;
              int v316 = 32;
LABEL_465:
              _os_log_impl(&dword_181A5C000, v314, v315, v296, buf, v316);
            }
          }

LABEL_567:
            uint64_t v282 = *(void *)(v13 + 328);
            if (!v282) {
              goto LABEL_716;
            }
            goto LABEL_568;
          }

          uint64_t v327 = *(void *)(v282 + 88);
          if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v328 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              uint64_t v329 = *(void *)(v282 + 88);
              if (v329) {
                int v330 = *(_DWORD *)(v329 + 460);
              }
              else {
                int v330 = -1;
              }
              uint64_t v337 = *(void *)(v282 + 64);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v282 + 192;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v330;
              *(_WORD *)&v532[6] = 2048;
              *(void *)&v532[8] = v337;
              *(_WORD *)&v532[16] = 2048;
              *(void *)&v532[18] = v282;
              *(_WORD *)&v532[26] = 1024;
              *(_DWORD *)&v532[28] = v521;
              _os_log_impl( &dword_181A5C000,  v328,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP3 stream with protocol: %p, peer_initiated: %u",  buf,  0x40u);
            }
          }

          if (*(void *)(v327 + 416) == v282)
          {
            if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v347 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v348 = *(void *)(v282 + 88);
                if (v348) {
                  int v349 = *(_DWORD *)(v348 + 460);
                }
                else {
                  int v349 = -1;
                }
                uint64_t v362 = *(void *)(v282 + 64);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v349;
                *(_WORD *)&v532[6] = 2048;
                *(void *)&v532[8] = v362;
                _os_log_impl( &dword_181A5C000,  v347,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Returning connected without more reconfiguration for placeholder stream",  buf,  0x30u);
              }
            }

            nw_protocol_connected(*(void **)(v282 + 48), v282);
            uint64_t v282 = *(void *)(v13 + 328);
            if (!v282) {
              goto LABEL_716;
            }
          }

          else
          {
            v338 = nw_parameters_copy_protocol_options_legacy(*(void **)(v282 + 144), (nw_protocol *)v282);
            if (v338)
            {
              v339 = (nw_protocol_stack *)v338;
              if (nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken != -1) {
                dispatch_once( &nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken,  &__block_literal_global_42);
              }
              *(void *)(v282 + 24) = &nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks;
              nw_protocol_stack_t stacka = v339;
              if (v521)
              {
                if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  int v353 = (os_log_s *)gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v354 = *(void *)(v282 + 88);
                    if (v354) {
                      int v355 = *(_DWORD *)(v354 + 460);
                    }
                    else {
                      int v355 = -1;
                    }
                    uint64_t v365 = *(void *)(v282 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    uint64_t v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v355;
                    *(_WORD *)&v532[6] = 2048;
                    *(void *)&v532[8] = v365;
                    _os_log_impl( &dword_181A5C000,  v353,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Preemptively configuring metadata with incoming stream ID",  buf,  0x30u);
                  }
                }

                if (*(void *)(v327 + 176) != -1LL)
                {
                  if (*(void *)(v282 + 64) == -1LL)
                  {
                    uint64_t v369 = *(void *)(*(void *)(v282 + 88) + 176LL);
                    if (v369 == -1)
                    {
                      if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                      {
                        v385 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v385, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v386 = *(void *)(v282 + 88);
                          if (v386) {
                            int v387 = *(_DWORD *)(v386 + 460);
                          }
                          else {
                            int v387 = -1;
                          }
                          uint64_t v392 = *(void *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v387;
                          *(_WORD *)&v532[6] = 2048;
                          *(void *)&v532[8] = v392;
                          _os_log_impl( &dword_181A5C000,  v385,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing",  buf,  0x30u);
                        }
                      }

                      v393 = *(void **)(v282 + 48);
                      nw_protocol_error(v393, v282);
                      nw_protocol_disconnected(v393, v282);
                    }

                    else
                    {
                      *(void *)(v282 + 64) = v369;
                      nw_webtransport_metadata_set_stream_id(*(void **)(v282 + 160), v369);
                      if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                      {
                        v370 = (os_log_s *)__nwlog_obj();
                        if (os_log_type_enabled(v370, OS_LOG_TYPE_INFO))
                        {
                          uint64_t v371 = *(void *)(v282 + 88);
                          if (v371) {
                            int v372 = *(_DWORD *)(v371 + 460);
                          }
                          else {
                            int v372 = -1;
                          }
                          uint64_t v391 = *(void *)(v282 + 64);
                          *(_DWORD *)buf = 136448002;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v372;
                          *(_WORD *)&v532[6] = 2048;
                          *(void *)&v532[8] = v391;
                          *(_WORD *)&v532[16] = 2048;
                          *(void *)&v532[18] = v391;
                          *(_WORD *)&v532[26] = 2048;
                          *(void *)&v532[28] = v282;
                          __int16 v533 = 1024;
                          int v534 = 1;
                          _os_log_impl( &dword_181A5C000,  v370,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u",  buf,  0x4Au);
                        }
                      }
                    }
                  }

                  else if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v366 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v366, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v367 = *(void *)(v282 + 88);
                        if (v367) {
                          int v368 = *(_DWORD *)(v367 + 460);
                        }
                        else {
                          int v368 = -1;
                        }
                        uint64_t v482 = *(void *)(v282 + 64);
                        *(_DWORD *)buf = 136447490;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v368;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v482;
                        *(_WORD *)&v532[16] = 2048;
                        *(void *)&v532[18] = v482;
                        _os_log_impl( &dword_181A5C000,  v366,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping",  buf,  0x3Au);
                        well_known = v515;
                      }
                    }
                  }

                  uint64_t v394 = *(void *)(v282 + 64);
                  char v395 = *(_BYTE *)(v282 + 276);
                  if (v394 == -1)
                  {
                    if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                    {
                      v399 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v399, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v400 = *(void *)(v282 + 88);
                        if (v400) {
                          int v401 = *(_DWORD *)(v400 + 460);
                        }
                        else {
                          int v401 = -1;
                        }
                        uint64_t v404 = *(void *)(v282 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v401;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v404;
                        _os_log_impl( &dword_181A5C000,  v399,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set",  buf,  0x30u);
                      }
                    }
                  }

                  else
                  {
                    *(_BYTE *)(v282 + 276) = v395 & 0xF0 | (4 * ((v394 & 2) != 0)) | 3;
                    if ((v395 & 0x10) == 0)
                    {
                      v396 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v396, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v397 = *(void *)(v282 + 88);
                        if (v397) {
                          int v398 = *(_DWORD *)(v397 + 460);
                        }
                        else {
                          int v398 = -1;
                        }
                        uint64_t v402 = *(void *)(v282 + 64);
                        unsigned int v403 = *(unsigned __int8 *)(v282 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        uint64_t v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v398;
                        *(_WORD *)&v532[6] = 2048;
                        *(void *)&v532[8] = v402;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v403 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v403 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v403 >> 2) & 1;
                        _os_log_impl( &dword_181A5C000,  v396,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagr am: %u, unidirectional: %u",  buf,  0x42u);
                      }
                    }

                    nw_webtransport_metadata_set_is_peer_initiated( *(void **)(v282 + 160),  (*(_BYTE *)(v282 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional( *(void **)(v282 + 160),  (*(_BYTE *)(v282 + 276) & 4) != 0);
                  }
                }

                if ((*(_BYTE *)(v282 + 276) & 0x40) != 0) {
                  goto LABEL_603;
                }
              }

              else
              {
                if (nw_protocol_options_is_webtransport(v339))
                {
                  *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xFC | 1;
                  if (nw_webtransport_options_get_is_datagram(v339)) {
                    char v340 = 8;
                  }
                  else {
                    char v340 = 0;
                  }
                  *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xF7 | v340;
                  BOOL v341 = nw_webtransport_options_get_is_unidirectional(v339);
                  char v342 = *(_BYTE *)(v282 + 276);
                  if (v341) {
                    char v343 = 4;
                  }
                  else {
                    char v343 = 0;
                  }
                  *(_BYTE *)(v282 + 276) = v342 & 0xFB | v343;
                  if ((v342 & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    uint64_t v344 = (os_log_s *)gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                    {
                      uint64_t v345 = *(void *)(v282 + 88);
                      if (v345) {
                        int v346 = *(_DWORD *)(v345 + 460);
                      }
                      else {
                        int v346 = -1;
                      }
                      uint64_t v375 = *(void *)(v282 + 64);
                      unsigned int v376 = *(unsigned __int8 *)(v282 + 276);
                      *(_DWORD *)buf = 136448002;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      uint64_t v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v346;
                      *(_WORD *)&v532[6] = 2048;
                      *(void *)&v532[8] = v375;
                      *(_WORD *)&v532[16] = 1024;
                      *(_DWORD *)&v532[18] = (v376 >> 1) & 1;
                      *(_WORD *)&v532[22] = 1024;
                      *(_DWORD *)&v532[24] = (v376 >> 3) & 1;
                      *(_WORD *)&v532[28] = 1024;
                      *(_DWORD *)&v532[30] = (v376 >> 2) & 1;
                      _os_log_impl( &dword_181A5C000,  v344,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram : %u, unidirectional: %u",  buf,  0x42u);
                    }
                  }

                  nw_webtransport_metadata_set_is_peer_initiated( *(void **)(v282 + 160),  (*(_BYTE *)(v282 + 276) & 2) != 0);
                  nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 8) != 0);
                  nw_webtransport_metadata_set_is_unidirectional( *(void **)(v282 + 160),  (*(_BYTE *)(v282 + 276) & 4) != 0);
LABEL_554:
                  if ((*(_BYTE *)(v282 + 276) & 8) == 0) {
                    goto LABEL_555;
                  }
LABEL_575:
                  nw_protocol_connected((void *)v282, v327);
LABEL_603:
                  uint64_t v405 = *(void *)(v327 + 32);
                  if (v405)
                  {
                    if ((*(_BYTE *)(v327 + 548) & 0x40) == 0)
                    {
                      v339 = stacka;
LABEL_633:
                      if (*(void *)(v282 + 32))
                      {
                        uint64_t v426 = *(void *)(v282 + 176);
                        v427 = *(void **)(v327 + 392);
                        *(void *)buf = MEMORY[0x1895F87A8];
                        *(void *)&buf[8] = 0x40000000LL;
                        *(void *)&buf[16] = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
                        uint64_t v531 = (uint64_t)&unk_189BBC5E0;
                        *(void *)v532 = v426;
                        nw_queue_context_async(v427, buf);
                        goto LABEL_706;
                      }

          if (v264) {
            free(v264);
          }
          id v17 = v260;
          uint64_t v44 = *(void *)(a1 + 48);
          if (!v44)
          {
LABEL_51:
            uint64_t v47 = v17;
            __nwlog_obj();
            int v48 = *(void *)(a1 + 48);
            uint64_t v49 = "invalid";
            if (v48)
            {
              int v50 = *(const char **)(v48 + 16);
              if (v50) {
                uint64_t v49 = v50;
              }
            }

            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v49;
            uint64_t v51 = (char *)_os_log_send_and_compose_impl();
            type[0] = 16;
            LOBYTE(v413) = 0;
            if (__nwlog_fault(v51, type, &v413))
            {
              if (type[0] == 17)
              {
                int v52 = (os_log_s *)__nwlog_obj();
                char v53 = type[0];
                if (!os_log_type_enabled(v52, (os_log_type_t)type[0])) {
                  goto LABEL_610;
                }
                uint64_t v54 = *(void *)(a1 + 48);
                uint64_t v55 = "invalid";
                if (v54)
                {
                  uint64_t v56 = *(const char **)(v54 + 16);
                  if (v56) {
                    uint64_t v55 = v56;
                  }
                }

LABEL_698:
                      if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        uint64_t v477 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v478 = *(void *)(v282 + 88);
                          if (v478) {
                            int v479 = *(_DWORD *)(v478 + 460);
                          }
                          else {
                            int v479 = -1;
                          }
                          uint64_t v480 = *(void *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          uint64_t v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v479;
                          *(_WORD *)&v532[6] = 2048;
                          *(void *)&v532[8] = v480;
                          v389 = (os_log_s *)v477;
                          v390 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
                          goto LABEL_704;
                        }
                      }

                      goto LABEL_705;
                    }

                    v406 = (void *)nw_protocol_get_parameters(v282);
                    if (v406)
                    {
                      v407 = v406;
                      nw_parameters_log_protocol_instances(v406);
                      v408 = v407;
                      v516 = (nw_protocol_stack *)v408[19];

                      *(void *)os_log_type_t type = 0LL;
                      v527 = type;
                      uint64_t v528 = 0x2000000000LL;
                      char v529 = 0;
                      *(void *)buf = 0LL;
                      *(void *)&buf[8] = buf;
                      *(void *)&buf[16] = 0x3802000000LL;
                      uint64_t v531 = (uint64_t)__Block_byref_object_copy__33539;
                      *(void *)v532 = __Block_byref_object_dispose__33540;
                      *(void *)&v532[8] = 0LL;
                      v532[16] |= 1u;
                      *(void *)iterate_block = MEMORY[0x1895F87A8];
                      *(void *)&iterate_block[8] = 0x40000000LL;
                      *(void *)&iterate_block[16] = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
                      v540 = (const char *)&unk_189BBC648;
                      v541 = type;
                      v542 = buf;
                      uint64_t v543 = v282;
                      nw_protocol_stack_iterate_application_protocols(v516, iterate_block);
                      v409 = *(void **)(*(void *)&buf[8] + 40LL);
                      if (v409)
                      {
                        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
                          dispatch_once( &nw_protocol_copy_http_messaging_definition_onceToken,  &__block_literal_global_57_72514);
                        }
                        id v410 = (id)nw_protocol_copy_http_messaging_definition_definition;
                        v411 = v409;
                        v411[2] = v405;

                        if (v410) {
                          os_release(v410);
                        }
                        v412 = (void *)nw_protocol_get_parameters(v405);
                        if (v412)
                        {
                          v413 = v412;
                          v414 = (nw_protocol_stack *)v413[19];

                          v415 = v408;
                          v416 = (nw_protocol_stack *)v408[19];

                          uint64_t v417 = v2;
                          v418 = v14;
                          v419 = nw_protocol_stack_copy_transport_protocol(v414);
                          nw_protocol_options_t v420 = nw_protocol_stack_copy_transport_protocol(v416);
                          nw_protocol_options_t v421 = v420;
                          if (v419)
                          {
                            if (v420)
                            {
                              nw_protocol_definition_t v422 = nw_protocol_options_copy_definition(v419);
                              if (nw_protocol_options_matches_definition(v421, v422))
                              {
                                uint64_t v423 = nw_protocol_options_get_protocol_handle(v419);
                                nw_parameters_set_protocol_instance(v421, v424, v423);
                              }

                              os_release(v421);
                            }

                            nw_protocol_options_t v421 = v419;
LABEL_621:
                            os_release(v421);
                          }

                          else if (v420)
                          {
                            goto LABEL_621;
                          }

                          int v14 = v418;
                          if (v416) {
                            os_release(v416);
                          }
                          uint64_t v2 = v417;
                          if (v414) {
                            os_release(v414);
                          }
                        }

                        nw_protocol_set_output_handler(v282, 0LL);
                        char v425 = nw_protocol_add_input_handler(v405, v282);
LABEL_627:
                        _Block_object_dispose(buf, 8);
                        well_known = v515;
                        v339 = stacka;
                        if ((v532[16] & 1) != 0 && *(void *)&v532[8]) {
                          os_release(*(void **)&v532[8]);
                        }
                        _Block_object_dispose(type, 8);
                        if (v516) {
                          os_release(v516);
                        }
                        if ((v425 & 1) != 0) {
                          goto LABEL_633;
                        }
                        goto LABEL_698;
                      }

                      __nwlog_obj();
                      *(_DWORD *)v535 = 136446210;
                      v536 = "nw_webtransport_session_add_to_http_messaging";
                      v451 = (char *)_os_log_send_and_compose_impl();
                      os_log_type_t v525 = OS_LOG_TYPE_ERROR;
                      char v524 = 0;
                      if (v525 == OS_LOG_TYPE_FAULT)
                      {
                        v452 = (os_log_s *)__nwlog_obj();
                        os_log_type_t v453 = v525;
                        if (os_log_type_enabled(v452, v525))
                        {
                          *(_DWORD *)v535 = 136446210;
                          v536 = "nw_webtransport_session_add_to_http_messaging";
                          v454 = v452;
                          os_log_type_t v455 = v453;
                          v456 = "%{public}s called with null options";
                          goto LABEL_710;
                        }

                        goto LABEL_711;
                      }

                      if (v524)
                      {
                        v465 = (char *)__nw_create_backtrace_string();
                        v466 = (os_log_s *)__nwlog_obj();
                        os_log_type_t v467 = v525;
                        BOOL v468 = os_log_type_enabled(v466, v525);
                        if (v465)
                        {
                          if (v468)
                          {
                            *(_DWORD *)v535 = 136446466;
                            v536 = "nw_webtransport_session_add_to_http_messaging";
                            __int16 v537 = 2082;
                            v538 = v465;
                            _os_log_impl( &dword_181A5C000,  v466,  v467,  "%{public}s called with null options, dumping backtrace:%{public}s",  v535,  0x16u);
                          }

                          free(v465);
                          goto LABEL_711;
                        }

                        if (!v468)
                        {
LABEL_711:
                          if (v451) {
                            free(v451);
                          }
                          char v425 = 0;
                          goto LABEL_627;
                        }

                        *(_DWORD *)v535 = 136446210;
                        v536 = "nw_webtransport_session_add_to_http_messaging";
                        v454 = v466;
                        os_log_type_t v455 = v467;
                        v456 = "%{public}s called with null options, no backtrace";
                      }

                      else
                      {
                        v475 = (os_log_s *)__nwlog_obj();
                        os_log_type_t v476 = v525;
                        if (!os_log_type_enabled(v475, v525)) {
                          goto LABEL_711;
                        }
                        *(_DWORD *)v535 = 136446210;
                        v536 = "nw_webtransport_session_add_to_http_messaging";
                        v454 = v475;
                        os_log_type_t v455 = v476;
                        v456 = "%{public}s called with null options, backtrace limit exceeded";
                      }

LABEL_710:
                      _os_log_impl(&dword_181A5C000, v454, v455, v456, v535, 0xCu);
                      goto LABEL_711;
                    }

                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                    v440 = (char *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    v535[0] = 0;
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v449 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v450 = type[0];
                      if (os_log_type_enabled(v449, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v443 = v449;
                        os_log_type_t v444 = v450;
                        v445 = "%{public}s called with null parameters";
                        goto LABEL_694;
                      }

LABEL_695:
                      if (v440) {
LABEL_696:
                      }
                        free(v440);
LABEL_697:
                      well_known = v515;
                      v339 = stacka;
                      goto LABEL_698;
                    }

                    if (v535[0])
                    {
                      v461 = (char *)__nw_create_backtrace_string();
                      v462 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v463 = type[0];
                      BOOL v464 = os_log_type_enabled(v462, type[0]);
                      if (v461)
                      {
                        if (v464)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v461;
                          _os_log_impl( &dword_181A5C000,  v462,  v463,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v461);
                        if (v440) {
                          goto LABEL_696;
                        }
                        goto LABEL_697;
                      }

                      if (!v464) {
                        goto LABEL_695;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v443 = v462;
                      os_log_type_t v444 = v463;
                      v445 = "%{public}s called with null parameters, no backtrace";
                    }

                    else
                    {
                      v473 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v474 = type[0];
                      if (!os_log_type_enabled(v473, type[0])) {
                        goto LABEL_695;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v443 = v473;
                      os_log_type_t v444 = v474;
                      v445 = "%{public}s called with null parameters, backtrace limit exceeded";
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                    v440 = (char *)_os_log_send_and_compose_impl();
                    iterate_block[0] = 16;
                    type[0] = OS_LOG_TYPE_DEFAULT;
                    if (iterate_block[0] == 17)
                    {
                      v441 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v442 = iterate_block[0];
                      if (os_log_type_enabled(v441, (os_log_type_t)iterate_block[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                        v443 = v441;
                        os_log_type_t v444 = v442;
                        v445 = "%{public}s called with null transport_protocol";
                        goto LABEL_694;
                      }

                      goto LABEL_695;
                    }

                    if (type[0])
                    {
                      v457 = (char *)__nw_create_backtrace_string();
                      v458 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v459 = iterate_block[0];
                      BOOL v460 = os_log_type_enabled(v458, (os_log_type_t)iterate_block[0]);
                      if (v457)
                      {
                        if (v460)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v457;
                          _os_log_impl( &dword_181A5C000,  v458,  v459,  "%{public}s called with null transport_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v457);
                        goto LABEL_695;
                      }

                      if (!v460) {
                        goto LABEL_695;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                      v443 = v458;
                      os_log_type_t v444 = v459;
                      v445 = "%{public}s called with null transport_protocol, no backtrace";
                    }

                    else
                    {
                      v470 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v471 = iterate_block[0];
                      if (!os_log_type_enabled(v470, (os_log_type_t)iterate_block[0])) {
                        goto LABEL_695;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_transport";
                      v443 = v470;
                      os_log_type_t v444 = v471;
                      v445 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
                    }
                  }

LABEL_705:
                  v481 = *(void **)(v282 + 48);
                  nw_protocol_error(v481, v282);
                  nw_protocol_disconnected(v481, v282);
LABEL_706:
                  os_release(v339);
                  uint64_t v282 = *(void *)(v13 + 328);
                  if (!v282) {
                    goto LABEL_716;
                  }
                  goto LABEL_568;
                }

                if ((*(_BYTE *)(v282 + 276) & 0x40) != 0) {
                  goto LABEL_603;
                }
              }

              nw_webtransport_http3_stream_fix_http_parameters(v327, v282);
              goto LABEL_603;
            }

            if ((*(_BYTE *)(v282 + 276) & 0x10) != 0) {
              goto LABEL_567;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v350 = (os_log_s *)gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_567;
            }
            uint64_t v351 = *(void *)(v282 + 88);
            if (v351) {
              int v352 = *(_DWORD *)(v351 + 460);
            }
            else {
              int v352 = -1;
            }
            uint64_t v364 = *(void *)(v282 + 64);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v282 + 192;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v352;
            *(_WORD *)&v532[6] = 2048;
            *(void *)&v532[8] = v364;
            _os_log_impl( &dword_181A5C000,  v350,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring",  buf,  0x30u);
            uint64_t v282 = *(void *)(v13 + 328);
            if (!v282) {
              goto LABEL_716;
            }
          }

    os_log_type_t v258 = v406;
    if (v305) {
      free(v305);
    }
LABEL_442:

    nw_protocol_stack_prepend_application_protocol(stack, v406);
    if (nw_protocol_copy_http_encoding_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_encoding_definition_onceToken, &__block_literal_global_30_73148);
    }
    uint64_t v259 = nw_protocol_create_options((void *)nw_protocol_copy_http_encoding_definition_http_encoding_definition);
    nw_protocol_stack_prepend_application_protocol(stack, (nw_protocol_options_t)v259);

    if (nw_protocol_copy_http_redirect_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_31_73205);
    }
    v408 = nw_protocol_create_options((void *)nw_protocol_copy_http_redirect_definition_http_redirect_definition);
    nw_http_redirect_options_set_limit(v408, 20);
    v417[0] = MEMORY[0x1895F87A8];
    v417[1] = v2;
    v417[2] = __34__NWURLLoaderHTTP_continueLoading__block_invoke_10;
    v417[3] = &unk_189BC5D70;
    v417[4] = a1;
    nw_http_redirect_options_set_handler(v408, v417, *(void **)(a1 + 56));
    nw_protocol_stack_prepend_application_protocol(stack, (nw_protocol_options_t)v408);
    [*(id *)(a1 + 24) _propertyForKey:*MEMORY[0x1896020B8]];
    uint64_t v402 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v402 || [MEMORY[0x189604A88] isEqual:v402])
    {
      if (nw_protocol_copy_http_sniffing_definition_onceToken[0] != -1) {
        dispatch_once(nw_protocol_copy_http_sniffing_definition_onceToken, &__block_literal_global_35);
      }
      os_log_type_t v260 = nw_protocol_create_options((void *)nw_protocol_copy_http_sniffing_definition_http_sniffing_definition);
      nw_protocol_stack_prepend_application_protocol(stack, (nw_protocol_options_t)v260);
    }

    if (nw_protocol_copy_http_client_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_52);
    }
    os_log_type_t v261 = nw_protocol_create_options((void *)nw_protocol_copy_http_client_definition_definition);
    v416[0] = MEMORY[0x1895F87A8];
    v416[1] = v2;
    v416[2] = __34__NWURLLoaderHTTP_continueLoading__block_invoke_14;
    v416[3] = &unk_189BC5D98;
    v416[4] = a1;
    uint64_t v262 = v261;
    os_log_type_t v263 = v416;
    if (!v262)
    {
      __nwlog_obj();
      os_log_type_t v308 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_client_options_set_resend_handler";
      LODWORD(v389) = 12;
      uint64_t v388 = buf;
      uint64_t v6 = 16LL;
      BOOL v309 = (char *)_os_log_send_and_compose_impl();

      v427 = OS_LOG_TYPE_ERROR;
      uint64_t v426 = 0;
      if (v427 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v310 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v6 = v427;
        if (os_log_type_enabled(v310, v427))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_set_resend_handler";
          _os_log_impl(&dword_181A5C000, v310, (os_log_type_t)v6, "%{public}s called with null options", buf, 0xCu);
        }
      }

      else if (v426)
      {
        uint64_t v6 = (uint64_t)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v310 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v331 = v427;
        uint64_t v332 = os_log_type_enabled(v310, v427);
        if (v6)
        {
          if (v332)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_client_options_set_resend_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v6;
            _os_log_impl( &dword_181A5C000,  v310,  v331,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free((void *)v6);
LABEL_710:
          if (!v309) {
            goto LABEL_458;
          }
LABEL_711:
          free(v309);
          goto LABEL_458;
        }

        if (v332)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_set_resend_handler";
          _os_log_impl(&dword_181A5C000, v310, v331, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v310 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v6 = v427;
        if (os_log_type_enabled(v310, v427))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_set_resend_handler";
          _os_log_impl( &dword_181A5C000,  v310,  (os_log_type_t)v6,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }
      }

LABEL_568:
          if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v381 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v381, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v382 = *(void *)(v282 + 88);
                if (v382) {
                  int v383 = *(_DWORD *)(v382 + 460);
                }
                else {
                  int v383 = -1;
                }
                uint64_t v436 = *(void *)(v282 + 64);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_get_next_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v383;
                *(_WORD *)&v532[6] = 2048;
                *(void *)&v532[8] = v436;
                *(_WORD *)&v532[16] = 2048;
                *(void *)&v532[18] = v282;
                _os_log_impl( &dword_181A5C000,  v381,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)",  buf,  0x3Au);
              }
            }
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v296 = *(unsigned int *)(v13 + 456);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = "webtransport_session->pending_stream_count";
        *(_WORD *)&buf[22] = 2048;
        uint64_t v531 = 1LL;
        *(_WORD *)v532 = 2048;
        *(void *)&v532[2] = v296;
        v297 = (char *)_os_log_send_and_compose_impl();
        iterate_block[0] = 16;
        type[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v297, iterate_block, type))
        {
          if (iterate_block[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v298 = gLogObj;
            os_log_type_t v299 = iterate_block[0];
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
            {
              uint64_t v300 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              uint64_t v531 = 1LL;
              *(_WORD *)v532 = 2048;
              *(void *)&v532[2] = v300;
              v301 = (os_log_s *)v298;
              os_log_type_t v302 = v299;
              os_log_type_t v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_445:
              _os_log_impl(&dword_181A5C000, v301, v302, v303, buf, 0x2Au);
            }
          }

          else if (type[0])
          {
            int v306 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v307 = (os_log_s *)gLogObj;
            os_log_type_t v308 = iterate_block[0];
            BOOL v309 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
            if (v306)
            {
              if (v309)
              {
                uint64_t v310 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                uint64_t v531 = 1LL;
                *(_WORD *)v532 = 2048;
                *(void *)&v532[2] = v310;
                *(_WORD *)&v532[10] = 2082;
                *(void *)&v532[12] = v306;
                _os_log_impl( &dword_181A5C000,  v307,  v308,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v306);
              well_known = v515;
              goto LABEL_446;
            }

            well_known = v515;
            if (v309)
            {
              uint64_t v314 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              uint64_t v531 = 1LL;
              *(_WORD *)v532 = 2048;
              *(void *)&v532[2] = v314;
              v301 = v307;
              os_log_type_t v302 = v308;
              os_log_type_t v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_445;
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v311 = gLogObj;
            os_log_type_t v312 = iterate_block[0];
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
            {
              uint64_t v313 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              uint64_t v531 = 1LL;
              *(_WORD *)v532 = 2048;
              *(void *)&v532[2] = v313;
              v301 = (os_log_s *)v311;
              os_log_type_t v302 = v312;
              os_log_type_t v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_445;
            }
          }
        }

LABEL_446:
        if (v297) {
          free(v297);
        }
        *(_DWORD *)(v13 + 456) = 0;
        goto LABEL_449;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      v484 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (iterate_block[0] == 17)
      {
        v485 = (os_log_s *)__nwlog_obj();
        os_log_type_t v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0])) {
          goto LABEL_777;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null request";
        goto LABEL_775;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v485 = (os_log_s *)__nwlog_obj();
        os_log_type_t v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0])) {
          goto LABEL_777;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null request, backtrace limit exceeded";
        goto LABEL_775;
      }

      v500 = (char *)__nw_create_backtrace_string();
      v497 = (os_log_s *)__nwlog_obj();
      os_log_type_t v498 = iterate_block[0];
      BOOL v504 = os_log_type_enabled(v497, (os_log_type_t)iterate_block[0]);
      if (!v500)
      {
        if (v504)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
          v487 = "%{public}s called with null request, no backtrace";
          goto LABEL_790;
        }

        goto LABEL_777;
      }

      if (!v504) {
        goto LABEL_765;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v500;
      v502 = "%{public}s called with null request, dumping backtrace:%{public}s";
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      v484 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (iterate_block[0] == 17)
      {
        v485 = (os_log_s *)__nwlog_obj();
        os_log_type_t v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0])) {
          goto LABEL_777;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
        goto LABEL_775;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v485 = (os_log_s *)__nwlog_obj();
        os_log_type_t v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0])) {
          goto LABEL_777;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_775;
      }

      v500 = (char *)__nw_create_backtrace_string();
      v497 = (os_log_s *)__nwlog_obj();
      os_log_type_t v498 = iterate_block[0];
      BOOL v501 = os_log_type_enabled(v497, (os_log_type_t)iterate_block[0]);
      if (!v500)
      {
        if (!v501) {
          goto LABEL_777;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
        goto LABEL_790;
      }

      if (!v501) {
        goto LABEL_765;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_handle_connect_request";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v500;
      v502 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s";
    }

            if (v225) {
              free(v225);
            }
            return 0LL;
          }

            if (v150) {
              free(v150);
            }
            BOOL v76 = v272;
            goto LABEL_449;
          }

          uint64_t v93 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (v93 <= 0x2A && ((1LL << v93) & 0x40000400004LL) != 0)
          {
            __nwlog_obj();
            os_log_type_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)nw_endpoint_t address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v93;
              _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d",  (uint8_t *)address,  0x12u);
            }

            uint64_t v78 = v274;
            BOOL v76 = v272;
            goto LABEL_276;
          }

          __nwlog_obj();
          uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)nw_endpoint_t address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 1024;
          *(_DWORD *)&address[7] = v93;
          char v110 = (const char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          BOOL v279 = OS_LOG_TYPE_DEFAULT;
          uint64_t v111 = (char *)v110;
          if (!__nwlog_fault(v110, type, &v279))
          {
LABEL_273:
            BOOL v76 = v272;
            if (v111) {
              free(v111);
            }
            uint64_t v78 = v274;
            goto LABEL_276;
          }

          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v112 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v113 = type[0];
            if (os_log_type_enabled(v112, type[0]))
            {
              *(_DWORD *)nw_endpoint_t address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v93;
              _os_log_impl( &dword_181A5C000,  v112,  v113,  "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d",  (uint8_t *)address,  0x12u);
            }
          }

          else
          {
            if (v279)
            {
              int v121 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              char v122 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v263 = type[0];
              BOOL v123 = os_log_type_enabled(v122, type[0]);
              if (v121)
              {
                if (v123)
                {
                  *(_DWORD *)nw_endpoint_t address = 136446722;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v93;
                  address[9] = 2082;
                  *(void *)&address[10] = v121;
                  _os_log_impl( &dword_181A5C000,  v122,  v263,  "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)address,  0x1Cu);
                }

                free(v121);
              }

              else
              {
                if (v123)
                {
                  *(_DWORD *)nw_endpoint_t address = 136446466;
                  *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                  address[6] = 1024;
                  *(_DWORD *)&address[7] = v93;
                  _os_log_impl( &dword_181A5C000,  v122,  v263,  "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, no backtrace",  (uint8_t *)address,  0x12u);
                }
              }

              goto LABEL_272;
            }

            __nwlog_obj();
            int v112 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v130 = type[0];
            if (os_log_type_enabled(v112, type[0]))
            {
              *(_DWORD *)nw_endpoint_t address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v93;
              _os_log_impl( &dword_181A5C000,  v112,  v130,  "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)address,  0x12u);
            }
          }

LABEL_272:
          uint64_t v111 = (char *)v110;
          goto LABEL_273;
        }

        uint64_t v56 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        __nwlog_obj();
        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)nw_endpoint_t address = 136446466;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        address[6] = 1024;
        uint64_t v269 = v56;
        *(_DWORD *)&address[7] = v56;
        int v271 = (const char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v280) = 0;
        uint64_t v58 = (char *)v271;
        if (!__nwlog_fault(v271, type, &v280))
        {
LABEL_150:
          if (v58) {
            free(v58);
          }
          goto LABEL_152;
        }

        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v60 = type[0];
          if (os_log_type_enabled(v59, type[0]))
          {
            *(_DWORD *)nw_endpoint_t address = 136446466;
            *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
            address[6] = 1024;
            *(_DWORD *)&address[7] = v269;
            _os_log_impl( &dword_181A5C000,  v59,  v60,  "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d",  (uint8_t *)address,  0x12u);
          }
        }

        else
        {
          if ((_BYTE)v280)
          {
            int v68 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            os_log_type_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v262 = type[0];
            int v70 = os_log_type_enabled(v69, type[0]);
            if (v68)
            {
              if (v70)
              {
                *(_DWORD *)nw_endpoint_t address = 136446722;
                *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
                address[6] = 1024;
                *(_DWORD *)&address[7] = v269;
                address[9] = 2082;
                *(void *)&address[10] = v68;
                _os_log_impl( &dword_181A5C000,  v69,  v262,  "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)address,  0x1Cu);
              }

              free(v68);
              goto LABEL_149;
            }

            if (v70)
            {
              *(_DWORD *)nw_endpoint_t address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v269;
              _os_log_impl( &dword_181A5C000,  v69,  v262,  "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, no backtrace",  (uint8_t *)address,  0x12u);
            }
          }

          else
          {
            __nwlog_obj();
            os_log_type_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v73 = type[0];
            if (os_log_type_enabled(v69, type[0]))
            {
              *(_DWORD *)nw_endpoint_t address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = v269;
              _os_log_impl( &dword_181A5C000,  v69,  v73,  "%{public}s SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)address,  0x12u);
            }
          }
        }

LABEL_764:
    _os_log_impl(&dword_181A5C000, v497, v498, v502, buf, 0x16u);
LABEL_765:
    free(v500);
    if (!v484) {
      goto LABEL_721;
    }
    goto LABEL_778;
  }

  if (!v13 || (*(_BYTE *)(v13 + 548) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v26 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = *(void *)(a1 + 40);
      uint64_t v28 = (const char *)(v27 + 464);
      uint64_t v29 = "";
      BOOL v30 = v27 == 0;
      int v31 = *(_DWORD *)(v27 + 460);
      if (v30) {
        uint64_t v28 = "";
      }
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(_DWORD *)buf = 136446978;
      if (!v30) {
        uint64_t v29 = " ";
      }
      *(void *)&buf[14] = v28;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v531 = (uint64_t)v29;
      *(_WORD *)v532 = 1024;
      *(_DWORD *)&v532[2] = v31;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Received unexpected input frame without HTTP metadata",  buf,  0x26u);
    }
  }

  nw_frame_finalize(v2);
  return 1LL;
}

            goto LABEL_765;
          }

          if (!v556)
          {
            __nwlog_obj();
            v181 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v310 = v561;
            if (os_log_type_enabled(v181, v561))
            {
              *(_DWORD *)uu = 136446210;
              *(void *)&uu[4] = "nw_path_parse_necp_parameters";
              _os_log_impl( &dword_181A5C000,  v181,  v310,  "%{public}s xpc_array_create failed, backtrace limit exceeded",  uu,  0xCu);
            }

            goto LABEL_764;
          }

          v249 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v181 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v250 = v561;
          BOOL v251 = os_log_type_enabled(v181, v561);
          if (!v249)
          {
            if (v251)
            {
              *(_DWORD *)uu = 136446210;
              *(void *)&uu[4] = "nw_path_parse_necp_parameters";
              _os_log_impl(&dword_181A5C000, v181, v250, "%{public}s xpc_array_create failed, no backtrace", uu, 0xCu);
            }

            goto LABEL_764;
          }

          if (v251)
          {
            *(_DWORD *)uu = 136446466;
            *(void *)&uu[4] = "nw_path_parse_necp_parameters";
            *(_WORD *)&uu[12] = 2082;
            *(void *)&uu[14] = v249;
            _os_log_impl( &dword_181A5C000,  v181,  v250,  "%{public}s xpc_array_create failed, dumping backtrace:%{public}s",  uu,  0x16u);
          }

          free(v249);
LABEL_765:
          if (v180) {
            free(v180);
          }
          int v68 = 0LL;
LABEL_768:
          if (!v71)
          {
            uint64_t v71 = xpc_array_create(0LL, 0LL);
            if (!v71)
            {
              __nwlog_obj();
              v381 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)uu = 136446210;
              *(void *)&uu[4] = "nw_path_parse_necp_parameters";
              uint64_t v382 = (char *)_os_log_send_and_compose_impl();

              v561 = OS_LOG_TYPE_ERROR;
              v556 = 0;
              if (__nwlog_fault(v382, &v561, &v556))
              {
                if (v561 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  int v383 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  uint64_t v384 = v561;
                  if (os_log_type_enabled(v383, v561))
                  {
                    *(_DWORD *)uu = 136446210;
                    *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                    _os_log_impl(&dword_181A5C000, v383, v384, "%{public}s xpc_array_create failed", uu, 0xCu);
                  }

                  goto LABEL_864;
                }

                if (v556)
                {
                  uint64_t v388 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  int v383 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v389 = v561;
                  v390 = os_log_type_enabled(v383, v561);
                  if (v388)
                  {
                    if (v390)
                    {
                      *(_DWORD *)uu = 136446466;
                      *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                      *(_WORD *)&uu[12] = 2082;
                      *(void *)&uu[14] = v388;
                      _os_log_impl( &dword_181A5C000,  v383,  v389,  "%{public}s xpc_array_create failed, dumping backtrace:%{public}s",  uu,  0x16u);
                    }

                    free(v388);
                    goto LABEL_865;
                  }

                  if (v390)
                  {
                    *(_DWORD *)uu = 136446210;
                    *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                    _os_log_impl( &dword_181A5C000,  v383,  v389,  "%{public}s xpc_array_create failed, no backtrace",  uu,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  int v383 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v393 = v561;
                  if (os_log_type_enabled(v383, v561))
                  {
                    *(_DWORD *)uu = 136446210;
                    *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                    _os_log_impl( &dword_181A5C000,  v383,  v393,  "%{public}s xpc_array_create failed, backtrace limit exceeded",  uu,  0xCu);
                  }
                }

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 24LL) = v3;
  }

  void *v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

uint64_t nw_webtransport_session_get_stream(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  uint64_t result = *(void *)(a1 + 184);
  if (result)
  {
    uint64_t result = nw_hash_table_get_node(result, (uint64_t)&v3, 8LL);
    if (result) {
      return *(void *)(result + 16);
    }
  }

  return result;
}

void nw_protocol_webtransport_stream_error(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v22 = "nw_protocol_webtransport_stream_error";
    unint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      int v22 = "nw_protocol_webtransport_stream_error";
      unint64_t v8 = "%{public}s called with null protocol";
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v13 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_protocol_webtransport_stream_error";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_54:
        if (!v5) {
          return;
        }
        goto LABEL_55;
      }

      if (!v13) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      int v22 = "nw_protocol_webtransport_stream_error";
      unint64_t v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      int v22 = "nw_protocol_webtransport_stream_error";
      unint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_53;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v22 = "nw_protocol_webtransport_stream_error";
    unint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v19)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_54;
        }
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_protocol_webtransport_stream_error";
        unint64_t v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_53;
      }

      int v14 = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v15 = os_log_type_enabled(v6, type);
      if (!v14)
      {
        if (!v15) {
          goto LABEL_54;
        }
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_protocol_webtransport_stream_error";
        unint64_t v8 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_53;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        int v22 = "nw_protocol_webtransport_stream_error";
        __int16 v23 = 2082;
        os_log_type_t v24 = v14;
        id v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v6, v7, v16, buf, 0x16u);
      }

void nw_protocol_webtransport_stream_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_webtransport_stream_disconnect";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_stream_disconnect";
      os_log_type_t v7 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          char v19 = "nw_protocol_webtransport_stream_disconnect";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v4) {
          return;
        }
LABEL_44:
        free(v4);
        return;
      }

      if (!v12) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_stream_disconnect";
      os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_stream_disconnect";
      os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_54( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  unint64_t v5 = *(void **)(a2 + 40);
  os_log_type_t v6 = (void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    unint64_t v5 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 24LL) = v5;
  }

  void *v5 = v4;
  void *v6 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  int is_metadata_complete = nw_frame_is_metadata_complete(a2);
  int v8 = is_metadata_complete;
  if (*(_BYTE *)(a1 + 48))
  {
    if (*(void *)(*(void *)(a1 + 32) + 16LL)) {
      int v8 = is_metadata_complete;
    }
    else {
      int v8 = 1;
    }
  }

  int v9 = *(_WORD *)(a2 + 204) & 0xFFC7 | (*(unsigned __int8 *)(a2 + 206) << 16);
  *(_WORD *)(a2 + 204) &= 0xFFC7u;
  *(_BYTE *)(a2 + 206) = BYTE2(v9);
  int v10 = *(void **)(a2 + 64);
  if (v10)
  {
    do
    {
      int v11 = (void *)*v10;
      BOOL v12 = (void *)v10[6];
      BOOL v13 = (void *)*v10;
      if (v12)
      {
        os_release(v12);
        v10[6] = 0LL;
        BOOL v13 = (void *)*v10;
      }

      BOOL v14 = (void *)v10[1];
      if (v13)
      {
        v13[1] = v14;
        BOOL v14 = (void *)v10[1];
      }

      else
      {
        *(void *)(a2 + 72) = v14;
      }

      void *v14 = v13;
      if (v10 != (void *)(a2 + 120)) {
        free(v10);
      }
      int v10 = v11;
    }

    while (v11);
  }

  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = a2 + 64;
  uint64_t v15 = *(void **)(a2 + 168);
  if (v15) {
    os_release(v15);
  }
  *(void *)(a2 + 184) = 0LL;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  nw_frame_set_metadata(a2, *(nw_protocol_metadata **)(*(void *)(a1 + 40) + 160LL), 1, v8);
  uint64_t v16 = *(void *)(a1 + 40);
  BOOL v17 = *(uint64_t **)(v16 + 80);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = v17;
  uint64_t *v17 = a2;
  *(void *)(v16 + 80) = v6;
  return 1LL;
}

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 24LL) = v3;
  }

  void *v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_3( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  unint64_t v5 = *(void **)(a2 + 40);
  os_log_type_t v6 = (void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    unint64_t v5 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 24LL) = v5;
  }

  void *v5 = v4;
  void *v6 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  int is_metadata_complete = nw_frame_is_metadata_complete(a2);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 16LL);
  int v9 = *(_WORD *)(a2 + 204) & 0xFFC7 | (*(unsigned __int8 *)(a2 + 206) << 16);
  *(_WORD *)(a2 + 204) &= 0xFFC7u;
  *(_BYTE *)(a2 + 206) = BYTE2(v9);
  int v10 = *(void **)(a2 + 64);
  if (v10)
  {
    do
    {
      int v11 = (void *)*v10;
      BOOL v12 = (void *)v10[6];
      BOOL v13 = (void *)*v10;
      if (v12)
      {
        os_release(v12);
        v10[6] = 0LL;
        BOOL v13 = (void *)*v10;
      }

      BOOL v14 = (void *)v10[1];
      if (v13)
      {
        v13[1] = v14;
        BOOL v14 = (void *)v10[1];
      }

      else
      {
        *(void *)(a2 + 72) = v14;
      }

      void *v14 = v13;
      if (v10 != (void *)(a2 + 120)) {
        free(v10);
      }
      int v10 = v11;
    }

    while (v11);
  }

  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = a2 + 64;
  uint64_t v15 = *(void **)(a2 + 168);
  if (v15) {
    os_release(v15);
  }
  if (v8) {
    int v16 = is_metadata_complete;
  }
  else {
    int v16 = 1;
  }
  *(void *)(a2 + 184) = 0LL;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  nw_frame_set_metadata(a2, *(nw_protocol_metadata **)(*(void *)(a1 + 40) + 160LL), 1, v16);
  uint64_t v17 = *(void *)(a1 + 40);
  uint64_t v18 = *(uint64_t **)(v17 + 80);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = v18;
  uint64_t *v18 = a2;
  *(void *)(v17 + 80) = v6;
  return 1LL;
}

void nw_webtransport_http3_stream_fix_http_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_webtransport_http3_stream_fix_http_parameters";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v32 = "nw_webtransport_http3_stream_fix_http_parameters";
      uint64_t v18 = "%{public}s called with null webtransport_session";
    }

    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v32 = "nw_webtransport_http3_stream_fix_http_parameters";
          __int16 v33 = 2082;
          uint64_t v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v15) {
          return;
        }
LABEL_62:
        free(v15);
        return;
      }

      if (!v20) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v32 = "nw_webtransport_http3_stream_fix_http_parameters";
      uint64_t v18 = "%{public}s called with null webtransport_session, no backtrace";
    }

    else
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v32 = "nw_webtransport_http3_stream_fix_http_parameters";
      uint64_t v18 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }

uint64_t ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke( uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (result) {
    return nw_protocol_connect(*(void *)(result + 32), result);
  }
  return result;
}

uint64_t ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    nw_frame_finalize(a2);
    uint64_t v4 = *(void *)(a2 + 32);
    unint64_t v5 = *(void **)(a2 + 40);
    if (v4)
    {
      *(void *)(v4 + 40) = v5;
      unint64_t v5 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(*(void *)(a1 + 40) + 8LL) = v5;
    }

    void *v5 = v4;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    uint64_t v6 = *(void *)(a1 + 48);
    if (!v6 || (*(_BYTE *)(v6 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        int v8 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v9 = *(void *)(a1 + 48);
          int v10 = (const char *)(v9 + 464);
          int v11 = "";
          BOOL v12 = v9 == 0;
          int v13 = *(_DWORD *)(v9 + 460);
          if (v12) {
            int v10 = "";
          }
          uint64_t v15 = "nw_webtransport_session_send_metadata_block_invoke";
          __int16 v16 = 2082;
          int v14 = 136446978;
          if (!v12) {
            int v11 = " ";
          }
          os_log_type_t v17 = v10;
          __int16 v18 = 2080;
          char v19 = v11;
          __int16 v20 = 1024;
          int v21 = v13;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Dropping unneeded output frame",  (uint8_t *)&v14,  0x26u);
        }
      }
    }
  }

  else
  {
    nw_frame_collapse(a2);
    nw_frame_set_metadata(a2, *(nw_protocol_metadata **)(a1 + 56), 0, 0);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  return 1LL;
}

void ___ZL47nw_protocol_webtransport_http3_stream_callbacksv_block_invoke()
{
  qword_18C5A3B78 = (uint64_t)nw_protocol_default_reset;
  unk_18C5A3B80 = nw_protocol_default_input_flush;
  qword_18C5A3B48 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C5A3B50 = nw_protocol_default_waiting_for_output;
  qword_18C5A3B08 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C5A3B10 = nw_protocol_default_unregister_notification;
  qword_18C5A3AE8 = (uint64_t)nw_protocol_webtransport_stream_get_parameters;
  unk_18C5A3AF0 = nw_protocol_default_get_path;
  qword_18C5A3AF8 = (uint64_t)nw_protocol_default_get_local;
  unk_18C5A3B00 = nw_protocol_webtransport_stream_get_remote_endpoint;
  qword_18C5A3AA8 = (uint64_t)nw_protocol_webtransport_stream_disconnected;
  unk_18C5A3AB0 = nw_protocol_webtransport_stream_error;
  qword_18C5A3AB8 = (uint64_t)nw_protocol_webtransport_stream_input_available;
  unk_18C5A3AC0 = nw_protocol_webtransport_stream_output_available;
  qword_18C5A3B18 = (uint64_t)nw_protocol_webtransport_stream_notify;
  unk_18C5A3B20 = nw_protocol_default_updated_path;
  qword_18C5A3B58 = (uint64_t)nw_protocol_webtransport_stream_copy_info;
  unk_18C5A3B60 = nw_protocol_webtransport_stream_add_listen_handler;
  qword_18C5A3B68 = (uint64_t)nw_protocol_webtransport_stream_remove_listen_handler;
  unk_18C5A3B70 = nw_protocol_webtransport_stream_get_message_properties;
  nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_stream_add_input_handler;
  unk_18C5A3A80 = nw_protocol_webtransport_http3_stream_remove_input_handler;
  qword_18C5A3A88 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_18C5A3A90 = nw_protocol_webtransport_http3_stream_connect;
  qword_18C5A3A98 = (uint64_t)nw_protocol_webtransport_stream_disconnect;
  unk_18C5A3AA0 = nw_protocol_webtransport_http3_stream_connected;
  qword_18C5A3AC8 = (uint64_t)nw_protocol_webtransport_http3_stream_get_input_frames;
  unk_18C5A3AD0 = nw_protocol_webtransport_http3_stream_get_output_frames;
  qword_18C5A3AD8 = (uint64_t)nw_protocol_webtransport_http3_stream_finalize_output_frames;
  unk_18C5A3AE0 = nw_protocol_default_link_state;
  qword_18C5A3B28 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_18C5A3B30 = nw_protocol_webtransport_http3_stream_input_finished;
  qword_18C5A3B38 = (uint64_t)nw_protocol_webtransport_http3_stream_output_finished;
  unk_18C5A3B40 = nw_protocol_default_get_output_local;
}

uint64_t nw_protocol_webtransport_stream_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      __int16 v18 = "%{public}s called with null protocol";
      goto LABEL_74;
    }

    if (!v43)
    {
      __int16 v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      __int16 v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v23) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      __int16 v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_74;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      __int16 v47 = 2082;
      int v48 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_75:
    if (!v15) {
      return 0LL;
    }
LABEL_76:
    free(v15);
    return 0LL;
  }

  handle = (nw_protocol *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      __int16 v18 = "%{public}s called with null webtransport_stream";
      goto LABEL_74;
    }

    if (!v43)
    {
      __int16 v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      __int16 v18 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_74;
    }

    uint64_t v24 = (char *)__nw_create_backtrace_string();
    __int16 v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v25 = os_log_type_enabled(v16, type);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
        __int16 v47 = 2082;
        int v48 = v24;
        _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v24);
      if (!v15) {
        return 0LL;
      }
      goto LABEL_76;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      __int16 v18 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_74:
      _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      goto LABEL_75;
    }

    goto LABEL_75;
  }

  if ((BYTE4(handle[4].identifier) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      char v19 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        callbacks = handle[1].callbacks;
        if (callbacks) {
          int input_finished_high = HIDWORD(callbacks[1].input_finished);
        }
        else {
          int input_finished_high = -1;
        }
        uint64_t v38 = *(void *)handle[1].flow_id;
        *(_DWORD *)buf = 136447234;
        uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
        __int16 v47 = 2082;
        int v48 = (char *)&handle[3];
        __int16 v49 = 2080;
        int v50 = " ";
        __int16 v51 = 1024;
        int v52 = input_finished_high;
        __int16 v53 = 2048;
        uint64_t v54 = v38;
        _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }

  uint64_t v5 = (uint64_t)handle[1].callbacks;
  if (v5) {
    BOOL v6 = a1->default_input_handler == a2;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (gLogDatapath)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      uint64_t result = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result) {
        return result;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s Rejecting duplicate request for a webtransport stream",  buf,  0xCu);
    }
  }

  else
  {
    if ((BYTE4(handle[4].identifier) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        __int16 v26 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          int v27 = handle[1].callbacks;
          if (v27) {
            int v28 = HIDWORD(v27[1].input_finished);
          }
          else {
            int v28 = -1;
          }
          uint64_t v39 = *(void *)handle[1].flow_id;
          *(_DWORD *)buf = 136447490;
          uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
          __int16 v47 = 2082;
          int v48 = (char *)&handle[3];
          __int16 v49 = 2080;
          int v50 = " ";
          __int16 v51 = 1024;
          int v52 = v28;
          __int16 v53 = 2048;
          uint64_t v54 = v39;
          __int16 v55 = 2048;
          uint64_t v56 = handle;
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Peeling off a new stream from %p",  buf,  0x3Au);
        }
      }
    }

    uint64_t parameters = nw_protocol_get_parameters((uint64_t)a2);
    if (parameters)
    {
      int v10 = (nw_protocol *)parameters;
      if ((BYTE4(handle[4].identifier) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          char v29 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v30 = handle[1].callbacks;
            if (v30) {
              int v31 = HIDWORD(v30[1].input_finished);
            }
            else {
              int v31 = -1;
            }
            uint64_t v40 = *(void *)handle[1].flow_id;
            *(_DWORD *)buf = 136447234;
            uint32_t v46 = "nw_webtransport_stream_replace_protocol_instance";
            __int16 v47 = 2082;
            int v48 = (char *)&handle[3];
            __int16 v49 = 2080;
            int v50 = " ";
            __int16 v51 = 1024;
            int v52 = v31;
            __int16 v53 = 2048;
            uint64_t v54 = v40;
            _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
          }
        }
      }

      int v11 = nw_parameters_copy_protocol_options_legacy(v10, handle);
      if (v11)
      {
        BOOL v12 = v11;
        if ((BYTE4(handle[4].identifier) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            __int16 v35 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v36 = handle[1].callbacks;
              if (v36) {
                int v37 = HIDWORD(v36[1].input_finished);
              }
              else {
                int v37 = -1;
              }
              uint64_t v42 = *(void *)handle[1].flow_id;
              *(_DWORD *)buf = 136448514;
              uint32_t v46 = "nw_webtransport_stream_replace_protocol_instance";
              __int16 v47 = 2082;
              int v48 = (char *)&handle[3];
              __int16 v49 = 2080;
              int v50 = " ";
              __int16 v51 = 1024;
              int v52 = v37;
              __int16 v53 = 2048;
              uint64_t v54 = v42;
              __int16 v55 = 2048;
              uint64_t v56 = handle;
              __int16 v57 = 2048;
              uint64_t v58 = v5;
              __int16 v59 = 2048;
              uint64_t v60 = handle;
              __int16 v61 = 2048;
              int v62 = v10;
              __int16 v63 = 2048;
              int v64 = v12;
              _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> webtransport_stream protocol %p, set protocol instance to %p instead of %p in parameters %p options %p",  buf,  0x62u);
            }
          }
        }

        if (nw_protocol_copy_webtransport_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_60063);
        }
        id v13 = (id)nw_protocol_copy_webtransport_definition::definition;
        int v14 = v12;
        *((void *)v14 + 2) = v5;

        if (v13) {
          os_release(v13);
        }
        os_release(v14);
      }

      if ((BYTE4(handle[4].identifier) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v32 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            __int16 v33 = handle[1].callbacks;
            if (v33) {
              int v34 = HIDWORD(v33[1].input_finished);
            }
            else {
              int v34 = -1;
            }
            uint64_t v41 = *(void *)handle[1].flow_id;
            *(_DWORD *)buf = 136447490;
            uint32_t v46 = "nw_protocol_webtransport_stream_add_input_handler";
            __int16 v47 = 2082;
            int v48 = (char *)&handle[3];
            __int16 v49 = 2080;
            int v50 = " ";
            __int16 v51 = 1024;
            int v52 = v34;
            __int16 v53 = 2048;
            uint64_t v54 = v41;
            __int16 v55 = 2048;
            uint64_t v56 = v10;
            _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Set connection protocol as instance in peeled off parameters %p",  buf,  0x3Au);
          }
        }
      }
    }

    if (handle[1].callbacks) {
      return nw_protocol_add_input_handler(v5, (uint64_t)a2);
    }
  }

  return 0LL;
}

uint64_t nw_protocol_webtransport_stream_get_parameters(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[18];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_webtransport_stream_get_parameters";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_webtransport_stream_get_parameters";
        BOOL v6 = "%{public}s called with null webtransport_stream";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_webtransport_stream_get_parameters";
        BOOL v6 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_webtransport_stream_get_parameters";
        BOOL v6 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_webtransport_stream_get_parameters";
      __int16 v15 = 2082;
      __int16 v16 = backtrace_string;
      uint64_t v9 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_webtransport_stream_get_parameters";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_webtransport_stream_get_parameters";
        BOOL v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_webtransport_stream_get_parameters";
        BOOL v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_webtransport_stream_get_parameters";
      __int16 v15 = 2082;
      __int16 v16 = backtrace_string;
      uint64_t v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

uint64_t nw_protocol_webtransport_stream_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      BOOL v8 = "%{public}s called with null protocol";
      goto LABEL_34;
    }

    if (!v13)
    {
      BOOL v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      BOOL v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (!v10) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      BOOL v8 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_34;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      __int16 v17 = 2082;
      __int16 v18 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_35:
    if (!v5) {
      return 0LL;
    }
LABEL_36:
    free(v5);
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      BOOL v8 = "%{public}s called with null webtransport_stream";
      goto LABEL_34;
    }

    if (!v13)
    {
      BOOL v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      BOOL v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_34;
    }

    char v11 = (char *)__nw_create_backtrace_string();
    BOOL v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v12 = os_log_type_enabled(v6, type);
    if (v11)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
        __int16 v17 = 2082;
        __int16 v18 = v11;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v11);
      if (!v5) {
        return 0LL;
      }
      goto LABEL_36;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      BOOL v8 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_34:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      goto LABEL_35;
    }

    goto LABEL_35;
  }

  uint64_t v2 = handle[6];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3)
    {
      if (*(void *)(v3 + 136)) {
        return nw_protocol_get_remote_endpoint((uint64_t)a1->default_input_handler);
      }
    }
  }

  return 0LL;
}

void nw_protocol_webtransport_stream_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_protocol_webtransport_stream_disconnected";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_disconnected";
      os_log_type_t v7 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_webtransport_stream_disconnected";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v4) {
          return;
        }
LABEL_41:
        free(v4);
        return;
      }

      if (!v12) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_disconnected";
      os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_disconnected";
      os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_stream_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_protocol_webtransport_stream_input_available";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_input_available";
      os_log_type_t v7 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_webtransport_stream_input_available";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v4) {
          return;
        }
LABEL_42:
        free(v4);
        return;
      }

      if (!v12) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_input_available";
      os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_input_available";
      os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_stream_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_protocol_webtransport_stream_output_available";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_output_available";
      os_log_type_t v7 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_webtransport_stream_output_available";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v4) {
          return;
        }
LABEL_42:
        free(v4);
        return;
      }

      if (!v12) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_output_available";
      os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_webtransport_stream_output_available";
      os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_stream_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_webtransport_stream_notify";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_webtransport_stream_notify";
      int v10 = "%{public}s called with null protocol";
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v15 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v22 = "nw_protocol_webtransport_stream_notify";
          __int16 v23 = 2082;
          __int16 v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v7) {
          return;
        }
LABEL_41:
        free(v7);
        return;
      }

      if (!v15) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_webtransport_stream_notify";
      int v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_webtransport_stream_notify";
      int v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_webtransport_stream_copy_info(uint64_t a1, int a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      if ((*(_BYTE *)(v3 + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          char v11 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v12 = *(void *)(v3 + 88);
            if (v12) {
              int v13 = *(_DWORD *)(v12 + 460);
            }
            else {
              int v13 = -1;
            }
            uint64_t v18 = *(void *)(v3 + 64);
            *(_DWORD *)buf = 136447234;
            __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
            __int16 v23 = 2082;
            __int16 v24 = (char *)(v3 + 192);
            __int16 v25 = 2080;
            __int16 v26 = " ";
            __int16 v27 = 1024;
            int v28 = v13;
            __int16 v29 = 2048;
            uint64_t v30 = v18;
            _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
          }
        }
      }

      if (*(void *)(v3 + 32)) {
        uint64_t v5 = a1;
      }
      else {
        uint64_t v5 = *(void *)(v3 + 88);
      }
      return nw_protocol_common_copy_info(v5, a2);
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
        int v10 = "%{public}s called with null webtransport_stream";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    if (!v19)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
        int v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v17 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
        int v10 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      char v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_29;
    }

    goto LABEL_30;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
        int v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v15 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
        int v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_41;
      }

      goto LABEL_42;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v22 = "nw_protocol_webtransport_stream_copy_info";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      char v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v8, v9, v16, buf, 0x16u);
    }

uint64_t nw_protocol_webtransport_stream_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      goto LABEL_52;
    }

    if (!v19)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (!v14) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    __int16 v23 = 2082;
    __int16 v24 = backtrace_string;
    BOOL v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v7, v8, v15, buf, 0x16u);
    goto LABEL_36;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
      os_log_type_t v9 = "%{public}s called with null webtransport_stream";
      goto LABEL_51;
    }

    if (!v19)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v16 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (!v16) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    __int16 v23 = 2082;
    __int16 v24 = backtrace_string;
    BOOL v15 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_35;
  }

  uint64_t v3 = handle[11];
  if (v3)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        int v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        uint64_t v3 = handle[11];
        if (v11)
        {
          if (v3) {
            int v12 = *(_DWORD *)(v3 + 460);
          }
          else {
            int v12 = -1;
          }
          uint64_t v18 = handle[8];
          *(_DWORD *)buf = 136447234;
          __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
          __int16 v23 = 2082;
          __int16 v24 = (char *)(handle + 24);
          __int16 v25 = 2080;
          __int16 v26 = " ";
          __int16 v27 = 1024;
          int v28 = v12;
          __int16 v29 = 2048;
          uint64_t v30 = v18;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
          uint64_t v3 = handle[11];
        }
      }
    }

    return nw_protocol_add_listen_handler(v3, (uint64_t)a2);
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream->webtransport_session, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream->webtransport_session, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v22 = "nw_protocol_webtransport_stream_add_listen_handler";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      BOOL v15 = "%{public}s called with null webtransport_stream->webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

uint64_t nw_protocol_webtransport_stream_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
      os_log_type_t v9 = "%{public}s called with null protocol";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      goto LABEL_52;
    }

    if (!v19)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (!v14) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    __int16 v23 = 2082;
    __int16 v24 = backtrace_string;
    BOOL v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v7, v8, v15, buf, 0x16u);
    goto LABEL_36;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
      os_log_type_t v9 = "%{public}s called with null webtransport_stream";
      goto LABEL_51;
    }

    if (!v19)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v16 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (!v16) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    __int16 v23 = 2082;
    __int16 v24 = backtrace_string;
    BOOL v15 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_35;
  }

  uint64_t v3 = handle[11];
  if (v3)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        int v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        uint64_t v3 = handle[11];
        if (v11)
        {
          if (v3) {
            int v12 = *(_DWORD *)(v3 + 460);
          }
          else {
            int v12 = -1;
          }
          uint64_t v18 = handle[8];
          *(_DWORD *)buf = 136447234;
          __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
          __int16 v23 = 2082;
          __int16 v24 = (char *)(handle + 24);
          __int16 v25 = 2080;
          __int16 v26 = " ";
          __int16 v27 = 1024;
          int v28 = v12;
          __int16 v29 = 2048;
          uint64_t v30 = v18;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
          uint64_t v3 = handle[11];
        }
      }
    }

    return nw_protocol_remove_listen_handler(v3, (uint64_t)a2);
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream->webtransport_session, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream->webtransport_session, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      BOOL v15 = "%{public}s called with null webtransport_stream->webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

void nw_protocol_webtransport_stream_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_webtransport_stream_get_message_properties";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_stream_get_message_properties";
      os_log_type_t v9 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v19 = "nw_protocol_webtransport_stream_get_message_properties";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_50:
        if (!v6) {
          return;
        }
        goto LABEL_51;
      }

      if (!v11) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_stream_get_message_properties";
      os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_stream_get_message_properties";
      os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_49;
  }

  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_webtransport_stream_get_message_properties";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        os_log_type_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_webtransport_stream_get_message_properties";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_49;
      }

      int v12 = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (!v12)
      {
        if (!v13) {
          goto LABEL_50;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_webtransport_stream_get_message_properties";
        os_log_type_t v9 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_49;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        char v19 = "nw_protocol_webtransport_stream_get_message_properties";
        __int16 v20 = 2082;
        int v21 = v12;
        BOOL v14 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_34:
        _os_log_impl(&dword_181A5C000, v7, v8, v14, buf, 0x16u);
      }

uint64_t nw_protocol_webtransport_http3_stream_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v196 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    int v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null protocol";
      goto LABEL_277;
    }

    if (!LOBYTE(v172[0]))
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_277;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v138 = (os_log_s *)__nwlog_obj();
    os_log_type_t v139 = type[0];
    BOOL v145 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v145) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_277;
    }

    if (!v145) {
      goto LABEL_251;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    __int16 v186 = 2082;
    uint64_t v187 = backtrace_string;
    uint64_t v146 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_250:
    _os_log_impl(&dword_181A5C000, v138, v139, v146, buf, 0x16u);
    goto LABEL_251;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    int v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null webtransport_stream";
      goto LABEL_277;
    }

    if (!LOBYTE(v172[0]))
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_277;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v138 = (os_log_s *)__nwlog_obj();
    os_log_type_t v139 = type[0];
    BOOL v147 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v147) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_277;
    }

    if (!v147) {
      goto LABEL_251;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    __int16 v186 = 2082;
    uint64_t v187 = backtrace_string;
    uint64_t v146 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_250;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    int v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null input_protocol";
      goto LABEL_277;
    }

    if (!LOBYTE(v172[0]))
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      int v140 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_277;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v138 = (os_log_s *)__nwlog_obj();
    os_log_type_t v139 = type[0];
    BOOL v148 = os_log_type_enabled(v138, type[0]);
    if (backtrace_string)
    {
      if (v148)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
        __int16 v186 = 2082;
        uint64_t v187 = backtrace_string;
        uint64_t v146 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_250;
      }

LABEL_251:
      free(backtrace_string);
      goto LABEL_278;
    }

    if (!v148) {
      goto LABEL_278;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    int v140 = "%{public}s called with null input_protocol, no backtrace";
LABEL_277:
    _os_log_impl(&dword_181A5C000, v138, v139, v140, buf, 0xCu);
LABEL_278:
    if (v137) {
      free(v137);
    }
    return 0LL;
  }

  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v141 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v142 = *((void *)handle + 11);
        if (v142) {
          int v143 = *(_DWORD *)(v142 + 460);
        }
        else {
          int v143 = -1;
        }
        uint64_t v155 = *((void *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
        __int16 v186 = 2082;
        uint64_t v187 = handle + 192;
        __int16 v188 = 2080;
        uint64_t v189 = (uint64_t)" ";
        __int16 v190 = 1024;
        *(_DWORD *)id v191 = v143;
        *(_WORD *)&v191[4] = 2048;
        *(void *)&v191[6] = v155;
        _os_log_impl(&dword_181A5C000, v141, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }

  int v5 = &qword_18C45F000;
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *((void *)handle + 11);
      if (v7) {
        int v8 = *(_DWORD *)(v7 + 460);
      }
      else {
        int v8 = -1;
      }
      uint64_t v9 = *((void *)handle + 8);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136448002;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      __int16 v186 = 2082;
      uint64_t v187 = handle + 192;
      __int16 v188 = 2080;
      uint64_t v189 = (uint64_t)" ";
      __int16 v190 = 1024;
      *(_DWORD *)id v191 = v8;
      *(_WORD *)&v191[4] = 2048;
      *(void *)&v191[6] = v9;
      *(_WORD *)&v191[14] = 2048;
      *(void *)&v191[16] = a1;
      __int16 v192 = 2048;
      id v193 = default_input_handler;
      __int16 v194 = 2048;
      os_log_type_t v195 = a2;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%s<i%u:s%lld> protocol %p, default_input_handler %p, input protocol %p",  buf,  0x4Eu);
    }
  }

  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  nw_protocol_remove_input_handler(*((void *)handle + 4), (uint64_t)a1);
  uint64_t v171 = *((void *)handle + 11);
  if (!v171)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
    uint64_t v149 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v150 = (os_log_s *)__nwlog_obj();
      os_log_type_t v151 = type[0];
      if (!os_log_type_enabled(v150, type[0])) {
        goto LABEL_292;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      uint64_t v152 = "%{public}s called with null webtransport_session";
    }

    else if (LOBYTE(v172[0]))
    {
      unsigned int v156 = (char *)__nw_create_backtrace_string();
      int v150 = (os_log_s *)__nwlog_obj();
      os_log_type_t v151 = type[0];
      BOOL v157 = os_log_type_enabled(v150, type[0]);
      if (v156)
      {
        if (v157)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
          __int16 v186 = 2082;
          uint64_t v187 = v156;
          _os_log_impl( &dword_181A5C000,  v150,  v151,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v156);
        goto LABEL_292;
      }

      if (!v157)
      {
LABEL_292:
        if (v149) {
          free(v149);
        }
        goto LABEL_86;
      }

      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      uint64_t v152 = "%{public}s called with null webtransport_session, no backtrace";
    }

    else
    {
      int v150 = (os_log_s *)__nwlog_obj();
      os_log_type_t v151 = type[0];
      if (!os_log_type_enabled(v150, type[0])) {
        goto LABEL_292;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      uint64_t v152 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v150, v151, v152, buf, 0xCu);
    goto LABEL_292;
  }

  if ((handle[276] & 0x20) != 0)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v153 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEBUG))
        {
          int v154 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          __int16 v186 = 2082;
          uint64_t v187 = (const char *)(v171 + 464);
          __int16 v188 = 2080;
          uint64_t v189 = (uint64_t)" ";
          __int16 v190 = 1024;
          *(_DWORD *)id v191 = v154;
          *(_WORD *)&v191[4] = 2048;
          *(void *)&v191[6] = handle;
          _os_log_impl( &dword_181A5C000,  v153,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream (%p)",  buf,  0x30u);
        }
      }
    }

    if ((handle[276] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
      __int16 v186 = 2048;
      uint64_t v187 = handle;
      char v16 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v172[0]) = 0;
      if (__nwlog_fault(v16, type, v172))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v17 = (os_log_s *)gLogObj;
          os_log_type_t v18 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            __int16 v186 = 2048;
            uint64_t v187 = handle;
            char v19 = "%{public}s stream %p not in pending list, cannot remove";
LABEL_58:
            uint64_t v38 = v17;
            os_log_type_t v39 = v18;
LABEL_59:
            _os_log_impl(&dword_181A5C000, v38, v39, v19, buf, 0x16u);
          }
        }

        else if (LOBYTE(v172[0]))
        {
          __int16 v23 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v24 = (os_log_s *)gLogObj;
          os_log_type_t v25 = type[0];
          BOOL v26 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v23)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              __int16 v186 = 2048;
              uint64_t v187 = handle;
              __int16 v188 = 2082;
              uint64_t v189 = (uint64_t)v23;
              _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v23);
            goto LABEL_60;
          }

          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            __int16 v186 = 2048;
            uint64_t v187 = handle;
            char v19 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            uint64_t v38 = v24;
            os_log_type_t v39 = v25;
            goto LABEL_59;
          }
        }

        else
        {
          BOOL v17 = (os_log_s *)__nwlog_obj();
          os_log_type_t v18 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            __int16 v186 = 2048;
            uint64_t v187 = handle;
            char v19 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            goto LABEL_58;
          }
        }
      }

      free(backtrace_string);
      goto LABEL_278;
    }

    if (!v148) {
      goto LABEL_278;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    int v140 = "%{public}s called with null input_protocol, no backtrace";
LABEL_277:
    _os_log_impl(&dword_181A5C000, v138, v139, v140, buf, 0xCu);
LABEL_278:
    if (v137) {
      free(v137);
    }
    return 0LL;
  }

  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v141 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v142 = *((void *)handle + 11);
        if (v142) {
          int v143 = *(_DWORD *)(v142 + 460);
        }
        else {
          int v143 = -1;
        }
        uint64_t v155 = *((void *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
        __int16 v186 = 2082;
        uint64_t v187 = handle + 192;
        __int16 v188 = 2080;
        uint64_t v189 = (uint64_t)" ";
        __int16 v190 = 1024;
        *(_DWORD *)id v191 = v143;
        *(_WORD *)&v191[4] = 2048;
        *(void *)&v191[6] = v155;
        _os_log_impl(&dword_181A5C000, v141, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }

  int v5 = &qword_18C45F000;
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *((void *)handle + 11);
      if (v7) {
        int v8 = *(_DWORD *)(v7 + 460);
      }
      else {
        int v8 = -1;
      }
      uint64_t v9 = *((void *)handle + 8);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136448002;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      __int16 v186 = 2082;
      uint64_t v187 = handle + 192;
      __int16 v188 = 2080;
      uint64_t v189 = (uint64_t)" ";
      __int16 v190 = 1024;
      *(_DWORD *)id v191 = v8;
      *(_WORD *)&v191[4] = 2048;
      *(void *)&v191[6] = v9;
      *(_WORD *)&v191[14] = 2048;
      *(void *)&v191[16] = a1;
      __int16 v192 = 2048;
      id v193 = default_input_handler;
      __int16 v194 = 2048;
      os_log_type_t v195 = a2;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%s<i%u:s%lld> protocol %p, default_input_handler %p, input protocol %p",  buf,  0x4Eu);
    }
  }

  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  uint64_t v171 = *((void *)handle + 11);
  if (!v171)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
    uint64_t v149 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v150 = (os_log_s *)__nwlog_obj();
      os_log_type_t v151 = type[0];
      if (!os_log_type_enabled(v150, type[0])) {
        goto LABEL_292;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      uint64_t v152 = "%{public}s called with null webtransport_session";
    }

    else if (LOBYTE(v172[0]))
    {
      unsigned int v156 = (char *)__nw_create_backtrace_string();
      int v150 = (os_log_s *)__nwlog_obj();
      os_log_type_t v151 = type[0];
      BOOL v157 = os_log_type_enabled(v150, type[0]);
      if (v156)
      {
        if (v157)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
          __int16 v186 = 2082;
          uint64_t v187 = v156;
          _os_log_impl( &dword_181A5C000,  v150,  v151,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v156);
        goto LABEL_292;
      }

      if (!v157)
      {
LABEL_292:
        if (v149) {
          free(v149);
        }
        goto LABEL_86;
      }

      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      uint64_t v152 = "%{public}s called with null webtransport_session, no backtrace";
    }

    else
    {
      int v150 = (os_log_s *)__nwlog_obj();
      os_log_type_t v151 = type[0];
      if (!os_log_type_enabled(v150, type[0])) {
        goto LABEL_292;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      uint64_t v152 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v150, v151, v152, buf, 0xCu);
    goto LABEL_292;
  }

  if ((handle[276] & 0x20) != 0)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v153 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEBUG))
        {
          int v154 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          __int16 v186 = 2082;
          uint64_t v187 = (const char *)(v171 + 464);
          __int16 v188 = 2080;
          uint64_t v189 = (uint64_t)" ";
          __int16 v190 = 1024;
          *(_DWORD *)id v191 = v154;
          *(_WORD *)&v191[4] = 2048;
          *(void *)&v191[6] = handle;
          _os_log_impl( &dword_181A5C000,  v153,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream (%p)",  buf,  0x30u);
        }
      }
    }

    if ((handle[276] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
      __int16 v186 = 2048;
      uint64_t v187 = handle;
      char v16 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v172[0]) = 0;
      if (__nwlog_fault(v16, type, v172))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v17 = (os_log_s *)gLogObj;
          os_log_type_t v18 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            __int16 v186 = 2048;
            uint64_t v187 = handle;
            char v19 = "%{public}s stream %p not in pending list, cannot remove";
LABEL_58:
            uint64_t v38 = v17;
            os_log_type_t v39 = v18;
LABEL_59:
            _os_log_impl(&dword_181A5C000, v38, v39, v19, buf, 0x16u);
          }
        }

        else if (LOBYTE(v172[0]))
        {
          __int16 v23 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v24 = (os_log_s *)gLogObj;
          os_log_type_t v25 = type[0];
          BOOL v26 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v23)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
              __int16 v186 = 2048;
              uint64_t v187 = handle;
              __int16 v188 = 2082;
              uint64_t v189 = (uint64_t)v23;
              _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v23);
            goto LABEL_60;
          }

          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            __int16 v186 = 2048;
            uint64_t v187 = handle;
            char v19 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            uint64_t v38 = v24;
            os_log_type_t v39 = v25;
            goto LABEL_59;
          }
        }

        else
        {
          BOOL v17 = (os_log_s *)__nwlog_obj();
          os_log_type_t v18 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            __int16 v186 = 2048;
            uint64_t v187 = handle;
            char v19 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            goto LABEL_58;
          }
        }
      }

    if (v100) {
      free(v100);
    }
    __nwlog_obj();
    char v122 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_message_request_in_process_flow_divert";
    BOOL v123 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v148 = 0;
    if (__nwlog_fault(v123, &type, &v148))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v125 = type;
        if (os_log_type_enabled(v124, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_message_request_in_process_flow_divert";
          _os_log_impl(&dword_181A5C000, v124, v125, "%{public}s called with null result", buf, 0xCu);
        }

uint64_t nw_protocol_webtransport_http3_stream_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((*((_BYTE *)handle + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v10 = handle[11];
            if (v10) {
              int v11 = *(_DWORD *)(v10 + 460);
            }
            else {
              int v11 = -1;
            }
            uint64_t v16 = handle[8];
            *(_DWORD *)buf = 136447234;
            uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
            __int16 v21 = 2082;
            uint64_t v22 = (char *)(handle + 24);
            __int16 v23 = 2080;
            __int16 v24 = " ";
            __int16 v25 = 1024;
            int v26 = v11;
            __int16 v27 = 2048;
            uint64_t v28 = v16;
            _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
          }
        }
      }

      return nw_protocol_connect((uint64_t)a1->output_handler, (uint64_t)a1);
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
        int v8 = "%{public}s called with null webtransport_stream";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (!v17)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
        int v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v15 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
        int v8 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
      __int16 v21 = 2082;
      uint64_t v22 = backtrace_string;
      int v14 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_26;
    }

    goto LABEL_27;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
        int v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v13 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
        int v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_protocol_webtransport_http3_stream_connect";
      __int16 v21 = 2082;
      uint64_t v22 = backtrace_string;
      int v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_181A5C000, v6, v7, v14, buf, 0x16u);
    }

void nw_protocol_webtransport_http3_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v116 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
    uint64_t v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      uint64_t v32 = "%{public}s called with null protocol";
      goto LABEL_86;
    }

    if (!v98)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      uint64_t v32 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_86;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v37 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      uint64_t v32 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_86;
    }

    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      __int16 v102 = 2082;
      os_log_type_t v103 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_87:
    if (!v29) {
      return;
    }
    goto LABEL_88;
  }

  handle = (unsigned __int8 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
    uint64_t v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      uint64_t v32 = "%{public}s called with null webtransport_stream";
      goto LABEL_86;
    }

    if (!v98)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      uint64_t v32 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_86;
    }

    uint64_t v38 = (char *)__nw_create_backtrace_string();
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v39 = os_log_type_enabled(v30, type);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
        __int16 v102 = 2082;
        os_log_type_t v103 = v38;
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v38);
      if (!v29) {
        return;
      }
LABEL_88:
      free(v29);
      return;
    }

    if (v39)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      uint64_t v32 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_86:
      _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0xCu);
      goto LABEL_87;
    }

    goto LABEL_87;
  }

  unsigned int v4 = (nw_protocol *)*((void *)handle + 11);
  int v5 = (handle[276] >> 4) & 1;
  os_log_type_t v6 = &qword_18C45F000;
  if (!gLogDatapath) {
    LOBYTE(v5) = 1;
  }
  if (!v4)
  {
    if ((v5 & 1) != 0) {
      return;
    }
    int v11 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    uint64_t v40 = *((void *)handle + 11);
    if (v40) {
      int v41 = *(_DWORD *)(v40 + 460);
    }
    else {
      int v41 = -1;
    }
    uint64_t v49 = *((void *)handle + 8);
    *(_DWORD *)buf = 136447234;
    BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
    __int16 v102 = 2082;
    os_log_type_t v103 = (char *)(handle + 192);
    __int16 v104 = 2080;
    uint64_t v105 = " ";
    __int16 v106 = 1024;
    int v107 = v41;
    __int16 v108 = 2048;
    uint64_t v109 = v49;
    uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> Stream is not fully setup. Ignoring connected.";
    goto LABEL_95;
  }

  if ((v5 & 1) == 0)
  {
    __int16 v33 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v34 = *((void *)handle + 11);
      if (v34) {
        int v35 = *(_DWORD *)(v34 + 460);
      }
      else {
        int v35 = -1;
      }
      uint64_t v42 = *((void *)handle + 8);
      *(_DWORD *)buf = 136447234;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      __int16 v102 = 2082;
      os_log_type_t v103 = (char *)(handle + 192);
      __int16 v104 = 2080;
      uint64_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v35;
      __int16 v108 = 2048;
      uint64_t v109 = v42;
      _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Got a connected event from the lower layer",  buf,  0x30u);
    }
  }

  nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a2);
  if (a1->output_handler == a2)
  {
    if (*((_DWORD *)handle + 46) == 2 || *((_DWORD *)handle + 47) == 2)
    {
      if ((handle[276] & 0x10) != 0) {
        return;
      }
      if (!gLogDatapath) {
        return;
      }
      int v11 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
        return;
      }
      uint64_t v12 = *((void *)handle + 11);
      if (v12) {
        int v13 = *(_DWORD *)(v12 + 460);
      }
      else {
        int v13 = -1;
      }
      uint64_t v50 = *((void *)handle + 8);
      *(_DWORD *)buf = 136447234;
      BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
      __int16 v102 = 2082;
      os_log_type_t v103 = (char *)(handle + 192);
      __int16 v104 = 2080;
      uint64_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v13;
      __int16 v108 = 2048;
      uint64_t v109 = v50;
      uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> stream is already connected, not forwarding";
LABEL_95:
      uint32_t v46 = v11;
      os_log_type_t v47 = OS_LOG_TYPE_DEBUG;
      goto LABEL_177;
    }

    if ((handle[276] & 8) != 0)
    {
      if (v4 != a2)
      {
        if ((handle[276] & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            char v17 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v18 = *((void *)handle + 11);
              if (v18) {
                int v19 = *(_DWORD *)(v18 + 460);
              }
              else {
                int v19 = -1;
              }
              uint64_t v62 = *((void *)handle + 8);
              *(_DWORD *)buf = 136447490;
              BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
              __int16 v102 = 2082;
              os_log_type_t v103 = (char *)(handle + 192);
              __int16 v104 = 2080;
              uint64_t v105 = " ";
              __int16 v106 = 1024;
              int v107 = v19;
              __int16 v108 = 2048;
              uint64_t v109 = v62;
              __int16 v110 = 2048;
              uint64_t v111 = v4;
              uint64_t v45 = "%{public}s %{public}s%s<i%u:s%lld> connected protocol is not our WebTransport session (%p), ignoring";
              uint32_t v46 = v17;
              os_log_type_t v47 = OS_LOG_TYPE_DEBUG;
              uint32_t v48 = 58;
              goto LABEL_178;
            }
          }
        }

        return;
      }

      goto LABEL_157;
    }

    if (*((void *)handle + 8) != -1LL)
    {
      if ((handle[276] & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          int v14 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v15 = *((void *)handle + 11);
            if (v15) {
              int v16 = *(_DWORD *)(v15 + 460);
            }
            else {
              int v16 = -1;
            }
            __int16 v61 = (nw_protocol *)*((void *)handle + 8);
            *(_DWORD *)buf = 136447490;
            BOOL v101 = "nw_webtransport_http3_stream_assign_stream_id";
            __int16 v102 = 2082;
            os_log_type_t v103 = (char *)(handle + 192);
            __int16 v104 = 2080;
            uint64_t v105 = " ";
            __int16 v106 = 1024;
            int v107 = v16;
            __int16 v108 = 2048;
            uint64_t v109 = (uint64_t)v61;
            __int16 v110 = 2048;
            uint64_t v111 = v61;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping",  buf,  0x3Au);
          }
        }
      }

      goto LABEL_140;
    }

    uint64_t v20 = *((void *)handle + 11);
    if (v20)
    {
      uint64_t v21 = *((void *)handle + 4);
      if (v21)
      {
        uint64_t v22 = (void *)nw_protocol_copy_info(v21, 255);
        if (v22) {
          os_release(v22);
        }
        __int16 v23 = *(void **)(v20 + 376);
        if (v23) {
          uint64_t last_application_stream_id = nw_http_connection_metadata_get_last_application_stream_id(v23);
        }
        else {
          uint64_t last_application_stream_id = -1LL;
        }
        if ((*(_BYTE *)(v20 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            uint64_t v55 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
            {
              int v56 = *(_DWORD *)(v20 + 460);
              *(_DWORD *)buf = 136447490;
              BOOL v101 = "nw_webtransport_http3_get_quic_stream_id";
              __int16 v102 = 2082;
              os_log_type_t v103 = (char *)(v20 + 464);
              __int16 v104 = 2080;
              uint64_t v105 = " ";
              __int16 v106 = 1024;
              int v107 = v56;
              __int16 v108 = 2048;
              uint64_t v109 = last_application_stream_id;
              __int16 v110 = 1024;
              LODWORD(v111) = 0;
              _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Got stream ID: %llu from session: %u",  buf,  0x36u);
            }
          }
        }

        if (last_application_stream_id != -1)
        {
          *((void *)handle + 8) = last_application_stream_id;
          nw_webtransport_metadata_set_stream_id(*((void **)handle + 20), last_application_stream_id);
          if ((handle[276] & 0x10) == 0)
          {
            __int16 v25 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
            {
              uint64_t v26 = *((void *)handle + 11);
              if (v26) {
                int v27 = *(_DWORD *)(v26 + 460);
              }
              else {
                int v27 = -1;
              }
              uint64_t v28 = (nw_protocol *)*((void *)handle + 8);
              *(_DWORD *)buf = 136448002;
              BOOL v101 = "nw_webtransport_http3_stream_assign_stream_id";
              __int16 v102 = 2082;
              os_log_type_t v103 = (char *)(handle + 192);
              __int16 v104 = 2080;
              uint64_t v105 = " ";
              __int16 v106 = 1024;
              int v107 = v27;
              __int16 v108 = 2048;
              uint64_t v109 = (uint64_t)v28;
              __int16 v110 = 2048;
              uint64_t v111 = v28;
              __int16 v112 = 2048;
              uint64_t v113 = (nw_protocol_identifier *)handle;
              __int16 v114 = 1024;
              LODWORD(v115) = 0;
              _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u",  buf,  0x4Au);
            }
          }

          goto LABEL_140;
        }

uint64_t nw_protocol_webtransport_http3_stream_get_input_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
      uint64_t v18 = "%{public}s called with null protocol";
LABEL_52:
      _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      goto LABEL_53;
    }

    if (!v28)
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        uint64_t v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        uint64_t v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    if (!v23) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    __int16 v32 = 2082;
    __int16 v33 = backtrace_string;
    __int16 v24 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v16, v17, v24, buf, 0x16u);
    goto LABEL_37;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
      uint64_t v18 = "%{public}s called with null webtransport_stream";
      goto LABEL_52;
    }

    if (!v28)
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        uint64_t v18 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v25 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        uint64_t v18 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    if (!v25) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    __int16 v32 = 2082;
    __int16 v33 = backtrace_string;
    __int16 v24 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_36;
  }

  if (a2)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        int v19 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v20 = handle[11];
          if (v20) {
            int v21 = *(_DWORD *)(v20 + 460);
          }
          else {
            int v21 = -1;
          }
          uint64_t v27 = handle[8];
          *(_DWORD *)buf = 136447746;
          os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
          __int16 v32 = 2082;
          __int16 v33 = (char *)(handle + 24);
          __int16 v34 = 2080;
          int v35 = " ";
          __int16 v36 = 1024;
          int v37 = v21;
          __int16 v38 = 2048;
          uint64_t v39 = v27;
          __int16 v40 = 2048;
          int v41 = a1;
          __int16 v42 = 2048;
          uint64_t v43 = a2;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called with protocol %p and input protocol %p",  buf,  0x44u);
        }
      }
    }

    uint64_t input_frames = nw_protocol_common_get_input_frames((uint64_t)a1, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
    if ((_DWORD)input_frames) {
      nw_protocol_input_finished(a2, (uint64_t)a1);
    }
    return input_frames;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
  uint64_t v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v28)
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        uint64_t v18 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v26 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        uint64_t v18 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
      __int16 v32 = 2082;
      __int16 v33 = backtrace_string;
      __int16 v24 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }

uint64_t nw_protocol_webtransport_http3_stream_get_output_frames( nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
      int v16 = "%{public}s called with null protocol";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      goto LABEL_52;
    }

    if (!v27)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        int v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        int v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (!v22) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    __int16 v31 = 2082;
    __int16 v32 = backtrace_string;
    BOOL v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
    _os_log_impl(&dword_181A5C000, v14, v15, v23, buf, 0x16u);
    goto LABEL_36;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
      int v16 = "%{public}s called with null webtransport_stream";
      goto LABEL_51;
    }

    if (!v27)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        int v16 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        int v16 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (!v24) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    __int16 v31 = 2082;
    __int16 v32 = backtrace_string;
    BOOL v23 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_35;
  }

  if (a6)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v18 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v19 = handle[11];
          if (v19) {
            int v20 = *(_DWORD *)(v19 + 460);
          }
          else {
            int v20 = -1;
          }
          uint64_t v26 = handle[8];
          *(_DWORD *)buf = 136447746;
          uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
          __int16 v31 = 2082;
          __int16 v32 = (char *)(handle + 24);
          __int16 v33 = 2080;
          __int16 v34 = " ";
          __int16 v35 = 1024;
          int v36 = v20;
          __int16 v37 = 2048;
          uint64_t v38 = v26;
          __int16 v39 = 2048;
          __int16 v40 = a1;
          __int16 v41 = 2048;
          __int16 v42 = a2;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called with protocol %p and input protocol %p",  buf,  0x44u);
        }
      }
    }

    return nw_protocol_common_get_output_frames((uint64_t)a1, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
  int v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v27)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        int v16 = "%{public}s called with null return_array, backtrace limit exceeded";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v25 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        int v16 = "%{public}s called with null return_array, no backtrace";
        goto LABEL_51;
      }

      goto LABEL_52;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
      __int16 v31 = 2082;
      __int16 v32 = backtrace_string;
      BOOL v23 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

uint64_t nw_protocol_webtransport_http3_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((*((_BYTE *)handle + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          int v11 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v12 = handle[11];
            if (v12) {
              int v13 = *(_DWORD *)(v12 + 460);
            }
            else {
              int v13 = -1;
            }
            uint64_t v18 = handle[8];
            *(_DWORD *)buf = 136447234;
            BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
            __int16 v23 = 2082;
            BOOL v24 = (char *)(handle + 24);
            __int16 v25 = 2080;
            uint64_t v26 = " ";
            __int16 v27 = 1024;
            int v28 = v13;
            __int16 v29 = 2048;
            uint64_t v30 = v18;
            _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
          }
        }
      }

      uint64_t v5 = nw_protocol_common_finalize_output_frames((uint64_t)a1, (uint64_t)a2);
      nw_protocol_output_finished(a1->output_handler->flow_id, (uint64_t)a1);
      return v5;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        int v10 = "%{public}s called with null webtransport_stream";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (!v19)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        int v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v17 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        int v10 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
      __int16 v23 = 2082;
      BOOL v24 = backtrace_string;
      int v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_26;
    }

    goto LABEL_27;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        int v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v15 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        int v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
      __int16 v23 = 2082;
      BOOL v24 = backtrace_string;
      int v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_181A5C000, v8, v9, v16, buf, 0x16u);
    }

void nw_protocol_webtransport_http3_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_webtransport_http3_stream_input_finished";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_http3_stream_input_finished";
      os_log_type_t v7 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          char v19 = "nw_protocol_webtransport_http3_stream_input_finished";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v4) {
          return;
        }
LABEL_42:
        free(v4);
        return;
      }

      if (!v12) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_http3_stream_input_finished";
      os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_http3_stream_input_finished";
      os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_http3_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_protocol_webtransport_http3_stream_output_finished";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_http3_stream_output_finished";
      os_log_type_t v7 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          char v19 = "nw_protocol_webtransport_http3_stream_output_finished";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v4) {
          return;
        }
LABEL_43:
        free(v4);
        return;
      }

      if (!v12) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_http3_stream_output_finished";
      os_log_type_t v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      char v19 = "nw_protocol_webtransport_http3_stream_output_finished";
      os_log_type_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_webtransport_stream_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 8;
  return (uint64_t)a1 + 64;
}

uint64_t nw_webtransport_stream_key_hash(_DWORD *a1)
{
  return (a1[1] + *a1);
}

BOOL nw_webtransport_stream_matches_key(void *a1, void *a2)
{
  return a1[8] == *a2;
}

void ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke( uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (v1)
  {
    uint64_t v2 = v1;
    if (*(_DWORD *)(v1 + 444) == 5)
    {
      if ((*(_BYTE *)(v1 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v3 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          int v4 = *(_DWORD *)(v2 + 460);
          *(_DWORD *)uint64_t v15 = 136446978;
          *(void *)&v15[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&v15[12] = 2082;
          *(void *)&v15[14] = v2 + 464;
          *(_WORD *)&v15[22] = 2080;
          char v16 = " ";
          *(_WORD *)BOOL v17 = 1024;
          *(_DWORD *)&v17[2] = v4;
          _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Session already terminated, ignoring",  v15,  0x26u);
        }
      }
    }

    else
    {
      if ((*(_BYTE *)(v1 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v5 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          int v6 = *(_DWORD *)(v2 + 460);
          *(_DWORD *)uint64_t v15 = 136447234;
          *(void *)&v15[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&v15[12] = 2082;
          *(void *)&v15[14] = v2 + 464;
          *(_WORD *)&v15[22] = 2080;
          char v16 = " ";
          *(_WORD *)BOOL v17 = 1024;
          *(_DWORD *)&v17[2] = v6;
          __int16 v18 = 1024;
          int v19 = 57;
          _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d",  v15,  0x2Cu);
        }
      }

      *(_DWORD *)(v2 + 444) = 5;
      os_log_type_t v7 = *(char **)(v2 + 184);
      if (v7)
      {
        *(void *)uint64_t v15 = MEMORY[0x1895F87A8];
        *(void *)&v15[8] = 0x40000000LL;
        *(void *)&v15[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
        char v16 = (const char *)&__block_descriptor_tmp_22_33505;
        *(_DWORD *)BOOL v17 = 57;
        nw_hash_table_apply(v7, (uint64_t)v15);
      }

      uint64_t v8 = *(void *)(v2 + 424);
      if (v8)
      {
        uint64_t v9 = *(void **)(v8 + 48);
        nw_protocol_error(v9, *(void *)(v2 + 424));
        nw_protocol_disconnected(v9, v8);
      }

      uint64_t v10 = *(void *)(v2 + 328);
      if (v10)
      {
        do
        {
          uint64_t v11 = *(void *)(v10 + 112);
          BOOL v12 = *(void **)(v10 + 48);
          nw_protocol_error(v12, v10);
          nw_protocol_disconnected(v12, v10);
          uint64_t v10 = v11;
        }

        while (v11);
      }

      uint64_t v13 = *(void *)(v2 + 416);
      if (v13)
      {
        BOOL v14 = *(void **)(v13 + 48);
        nw_protocol_error(v14, *(void *)(v2 + 416));
        nw_protocol_disconnected(v14, v13);
      }

      if (*(void *)(v2 + 32))
      {
        nw_protocol_remove_instance(v2);
        nw_protocol_disconnect(*(void **)(v2 + 32), v2);
      }
    }
  }

uint64_t ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = nw_hash_node_get_object(a2);
  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4 || (*(_BYTE *)(v4 + 548) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      os_log_type_t v7 = (const char *)(v6 + 464);
      uint64_t v8 = "";
      BOOL v9 = v6 == 0;
      if (!v6) {
        os_log_type_t v7 = "";
      }
      int v10 = *(_DWORD *)(v6 + 460);
      if (!v9) {
        uint64_t v8 = " ";
      }
      uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      *(_DWORD *)buf = 136447234;
      uint64_t v49 = "nw_webtransport_session_destroy_block_invoke";
      __int16 v50 = 2082;
      __int16 v51 = (void *)v7;
      __int16 v52 = 2080;
      os_log_type_t v53 = v8;
      __int16 v54 = 1024;
      int v55 = v10;
      __int16 v56 = 2048;
      uint64_t v57 = v11;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways",  buf,  0x30u);
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  uint64_t v49 = "nw_webtransport_session_destroy_block_invoke";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v46 = 0;
  if (__nwlog_fault(v12, &type, &v46))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v49 = "nw_webtransport_session_destroy_block_invoke";
      uint64_t v15 = "%{public}s should not have streams left when destroying";
LABEL_22:
      _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
      goto LABEL_23;
    }

    if (!v46)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v49 = "nw_webtransport_session_destroy_block_invoke";
      uint64_t v15 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
      goto LABEL_22;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (os_log_s *)gLogObj;
    os_log_type_t v14 = type;
    BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v17) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v49 = "nw_webtransport_session_destroy_block_invoke";
      uint64_t v15 = "%{public}s should not have streams left when destroying, no backtrace";
      goto LABEL_22;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v49 = "nw_webtransport_session_destroy_block_invoke";
      __int16 v50 = 2082;
      __int16 v51 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
  }

void std::destroy_at[abi:nn180100]<nw_webtransport_session,0>(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 384) & 1) != 0)
  {
    uint64_t v2 = *(void **)(a1 + 376);
    if (v2) {
      os_release(v2);
    }
  }

  *(void *)(a1 + 376) = 0LL;
  if ((*(_BYTE *)(a1 + 368) & 1) != 0)
  {
    uint64_t v3 = *(void **)(a1 + 360);
    if (v3) {
      os_release(v3);
    }
  }

  *(void *)(a1 + 360) = 0LL;
  if ((*(_BYTE *)(a1 + 352) & 1) != 0)
  {
    uint64_t v4 = *(void **)(a1 + 344);
    if (v4) {
      os_release(v4);
    }
  }

  *(void *)(a1 + 344) = 0LL;
}

void ___ZL47nw_protocol_webtransport_http2_stream_callbacksv_block_invoke()
{
  qword_18C5A3A60 = (uint64_t)nw_protocol_default_reset;
  unk_18C5A3A68 = nw_protocol_default_input_flush;
  qword_18C5A3A30 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C5A3A38 = nw_protocol_default_waiting_for_output;
  qword_18C5A39F0 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C5A39F8 = nw_protocol_default_unregister_notification;
  qword_18C5A39D0 = (uint64_t)nw_protocol_webtransport_stream_get_parameters;
  unk_18C5A39D8 = nw_protocol_default_get_path;
  qword_18C5A39E0 = (uint64_t)nw_protocol_default_get_local;
  unk_18C5A39E8 = nw_protocol_webtransport_stream_get_remote_endpoint;
  qword_18C5A3990 = (uint64_t)nw_protocol_webtransport_stream_disconnected;
  unk_18C5A3998 = nw_protocol_webtransport_stream_error;
  qword_18C5A39A0 = (uint64_t)nw_protocol_webtransport_stream_input_available;
  unk_18C5A39A8 = nw_protocol_webtransport_stream_output_available;
  qword_18C5A3A00 = (uint64_t)nw_protocol_webtransport_stream_notify;
  unk_18C5A3A08 = nw_protocol_default_updated_path;
  qword_18C5A3A40 = (uint64_t)nw_protocol_webtransport_stream_copy_info;
  unk_18C5A3A48 = nw_protocol_webtransport_stream_add_listen_handler;
  qword_18C5A3A50 = (uint64_t)nw_protocol_webtransport_stream_remove_listen_handler;
  unk_18C5A3A58 = nw_protocol_webtransport_stream_get_message_properties;
  nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_stream_add_input_handler;
  *(void *)algn_18C5A3968 = nw_protocol_webtransport_http2_stream_remove_input_handler;
  qword_18C5A3970 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_18C5A3978 = nw_protocol_webtransport_http2_stream_connect;
  qword_18C5A3980 = (uint64_t)nw_protocol_webtransport_stream_disconnect;
  unk_18C5A3988 = nw_protocol_webtransport_http2_stream_connected;
  qword_18C5A39B0 = (uint64_t)nw_protocol_webtransport_http2_stream_get_input_frames;
  unk_18C5A39B8 = nw_protocol_webtransport_http2_stream_get_output_frames;
  qword_18C5A39C0 = (uint64_t)nw_protocol_webtransport_http2_stream_finalize_output_frames;
  unk_18C5A39C8 = nw_protocol_default_link_state;
  qword_18C5A3A10 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_18C5A3A18 = nw_protocol_webtransport_http2_stream_input_finished;
  qword_18C5A3A20 = (uint64_t)nw_protocol_webtransport_http2_stream_output_finished;
  unk_18C5A3A28 = nw_protocol_default_get_output_local;
}

uint64_t nw_protocol_webtransport_http2_stream_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v196 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    int v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null protocol";
      goto LABEL_277;
    }

    if (!LOBYTE(v172[0]))
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_277;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v138 = (os_log_s *)__nwlog_obj();
    os_log_type_t v139 = type[0];
    BOOL v145 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v145) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_277;
    }

    if (!v145) {
      goto LABEL_251;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    __int16 v186 = 2082;
    uint64_t v187 = backtrace_string;
    uint64_t v146 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_250:
    _os_log_impl(&dword_181A5C000, v138, v139, v146, buf, 0x16u);
    goto LABEL_251;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    int v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null webtransport_stream";
      goto LABEL_277;
    }

    if (!LOBYTE(v172[0]))
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_277;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v138 = (os_log_s *)__nwlog_obj();
    os_log_type_t v139 = type[0];
    BOOL v147 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v147) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_277;
    }

    if (!v147) {
      goto LABEL_251;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    __int16 v186 = 2082;
    uint64_t v187 = backtrace_string;
    uint64_t v146 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_250;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    int v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null input_protocol";
      goto LABEL_277;
    }

    if (!LOBYTE(v172[0]))
    {
      int v138 = (os_log_s *)__nwlog_obj();
      os_log_type_t v139 = type[0];
      if (!os_log_type_enabled(v138, type[0])) {
        goto LABEL_278;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      int v140 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_277;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v138 = (os_log_s *)__nwlog_obj();
    os_log_type_t v139 = type[0];
    BOOL v148 = os_log_type_enabled(v138, type[0]);
    if (backtrace_string)
    {
      if (v148)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
        __int16 v186 = 2082;
        uint64_t v187 = backtrace_string;
        uint64_t v146 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_250;
      }

uint64_t nw_protocol_webtransport_http2_stream_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((*((_BYTE *)handle + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v10 = handle[11];
            if (v10) {
              int v11 = *(_DWORD *)(v10 + 460);
            }
            else {
              int v11 = -1;
            }
            uint64_t v16 = handle[8];
            *(_DWORD *)buf = 136447234;
            uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
            __int16 v21 = 2082;
            uint64_t v22 = (char *)(handle + 24);
            __int16 v23 = 2080;
            uint64_t v24 = " ";
            __int16 v25 = 1024;
            int v26 = v11;
            __int16 v27 = 2048;
            uint64_t v28 = v16;
            _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
          }
        }
      }

      nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a1);
      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
        int v8 = "%{public}s called with null webtransport_stream";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (!v17)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
        int v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v15 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
        int v8 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
      __int16 v21 = 2082;
      uint64_t v22 = backtrace_string;
      int v14 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_26;
    }

    goto LABEL_27;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
        int v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v13 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
        int v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }

      goto LABEL_39;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_protocol_webtransport_http2_stream_connect";
      __int16 v21 = 2082;
      uint64_t v22 = backtrace_string;
      int v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_181A5C000, v6, v7, v14, buf, 0x16u);
    }

void nw_protocol_webtransport_http2_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v106 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v92 = "nw_protocol_webtransport_http2_stream_connected";
    __int16 v58 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v89 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type;
      if (!os_log_type_enabled(v59, type)) {
        goto LABEL_142;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v92 = "nw_protocol_webtransport_http2_stream_connected";
      __int16 v61 = "%{public}s called with null protocol";
    }

    else if (v89)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type;
      BOOL v66 = os_log_type_enabled(v59, type);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v92 = "nw_protocol_webtransport_http2_stream_connected";
          __int16 v93 = 2082;
          p_identifier = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v59,  v60,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_142:
        if (!v58) {
          return;
        }
LABEL_143:
        free(v58);
        return;
      }

      if (!v66) {
        goto LABEL_142;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v92 = "nw_protocol_webtransport_http2_stream_connected";
      __int16 v61 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type;
      if (!os_log_type_enabled(v59, type)) {
        goto LABEL_142;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v92 = "nw_protocol_webtransport_http2_stream_connected";
      __int16 v61 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_webtransport_http2_stream_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null protocol";
      goto LABEL_55;
    }

    if (!v33)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v21) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_55;
    }

    if (!v21) {
      goto LABEL_40;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v14, v15, v22, buf, 0x16u);
    goto LABEL_40;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null webtransport_stream";
      goto LABEL_55;
    }

    if (!v33)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v23 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v23) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_55;
    }

    if (!v23) {
      goto LABEL_40;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v22 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_39;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null input_protocol";
      goto LABEL_55;
    }

    if (!v33)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      uint64_t v16 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v24 = os_log_type_enabled(v14, type);
    if (backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v22 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_39;
      }

BOOL nw_protocol_webtransport_http2_stream_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, uint64_t a5, nw_frame_array_s *a6)
{
  *(void *)&v57[11] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    int v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null protocol";
      goto LABEL_75;
    }

    if (!v48)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_75;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v34 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v34) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_75;
    }

    if (!v34) {
      goto LABEL_60;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    __int16 v52 = 2082;
    os_log_type_t v53 = backtrace_string;
    uint64_t v35 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_59:
    _os_log_impl(&dword_181A5C000, v27, v28, v35, buf, 0x16u);
    goto LABEL_60;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    int v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null webtransport_stream";
      goto LABEL_75;
    }

    if (!v48)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_75;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v36 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_75;
    }

    if (!v36) {
      goto LABEL_60;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    __int16 v52 = 2082;
    os_log_type_t v53 = backtrace_string;
    uint64_t v35 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_59;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    int v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null return_array";
      goto LABEL_75;
    }

    if (!v48)
    {
      __int16 v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      uint32_t v29 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_75;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v37 = os_log_type_enabled(v27, type);
    if (backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
        __int16 v52 = 2082;
        os_log_type_t v53 = backtrace_string;
        uint64_t v35 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_59;
      }

uint64_t nw_protocol_webtransport_http2_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
    unint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        uint64_t v16 = "%{public}s called with null protocol";
LABEL_53:
        _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      }

void nw_protocol_webtransport_http2_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v19 = "nw_protocol_webtransport_http2_stream_input_finished";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v19 = "nw_protocol_webtransport_http2_stream_input_finished";
      uint64_t v7 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          int v19 = "nw_protocol_webtransport_http2_stream_input_finished";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v4) {
          return;
        }
LABEL_42:
        free(v4);
        return;
      }

      if (!v12) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v19 = "nw_protocol_webtransport_http2_stream_input_finished";
      uint64_t v7 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v19 = "nw_protocol_webtransport_http2_stream_input_finished";
      uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_http2_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
    int v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      if (!os_log_type_enabled(v11, type[0])) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
      unint64_t v13 = "%{public}s called with null protocol";
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      BOOL v18 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_64:
        if (!v10) {
          return;
        }
        goto LABEL_65;
      }

      if (!v18) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
      unint64_t v13 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      if (!os_log_type_enabled(v11, type[0])) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
      unint64_t v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_63;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
    int v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        char v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type[0];
        if (!os_log_type_enabled(v11, type[0])) {
          goto LABEL_64;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
        unint64_t v13 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_63;
      }

      int v19 = (char *)__nw_create_backtrace_string();
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      BOOL v20 = os_log_type_enabled(v11, type[0]);
      if (!v19)
      {
        if (!v20) {
          goto LABEL_64;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
        unint64_t v13 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_63;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v19;
        BOOL v21 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v11, v12, v21, buf, 0x16u);
      }

uint64_t ___ZL60nw_protocol_webtransport_http2_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  int v6 = 0;
  uint64_t v4 = (void *)nw_frame_unclaimed_bytes(a2, &v6);
  memcpy(v4, (const void *)(a1 + 40), *(unsigned __int8 *)(a1 + 56));
  return 1LL;
}

uint64_t ___ZL55nw_protocol_webtransport_http2_stream_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t ___ZL54nw_protocol_webtransport_http2_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a2 + 32);
  unint64_t v5 = *(void **)(a2 + 40);
  uint64_t v3 = (void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    unint64_t v5 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(a1[5] + 80LL) = v5;
  }

  void *v5 = v4;
  void *v3 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  uint64_t v6 = a1[6];
  BOOL v7 = *(uint64_t **)(v6 + 8);
  *(void *)(a2 + 40) = v7;
  *BOOL v7 = a2;
  *(void *)(v6 + 8) = v3;
  if (nw_frame_is_metadata_complete(a2))
  {
    uint64_t v8 = a1[5];
    if ((*(_BYTE *)(v8 + 276) & 8) == 0) {
      *(_DWORD *)(v8 + 184) = 3;
    }
  }

  uint64_t v9 = *(void *)(a1[4] + 8LL);
  uint64_t v10 = *(unsigned int *)(v9 + 24) + 1LL;
  uint64_t v11 = v10 << 31 >> 31;
  *(_DWORD *)(v9 + 24) = v10;
  if (v11 != v10 || v11 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    uint64_t v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
    __int16 v28 = 2082;
    unint64_t v29 = "count";
    __int16 v30 = 2048;
    uint64_t v31 = 1LL;
    __int16 v32 = 2048;
    uint64_t v33 = v12;
    unint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v16 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          uint64_t v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
          __int16 v28 = 2082;
          unint64_t v29 = "count";
          __int16 v30 = 2048;
          uint64_t v31 = 1LL;
          __int16 v32 = 2048;
          uint64_t v33 = v16;
          char v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_22:
          _os_log_impl(&dword_181A5C000, v14, v15, v17, buf, 0x2Au);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type;
        BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v19)
          {
            uint64_t v20 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
            *(_DWORD *)buf = 136447234;
            uint64_t v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
            __int16 v28 = 2082;
            unint64_t v29 = "count";
            __int16 v30 = 2048;
            uint64_t v31 = 1LL;
            __int16 v32 = 2048;
            uint64_t v33 = v20;
            __int16 v34 = 2082;
            BOOL v35 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (v19)
        {
          uint64_t v22 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          uint64_t v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
          __int16 v28 = 2082;
          unint64_t v29 = "count";
          __int16 v30 = 2048;
          uint64_t v31 = 1LL;
          __int16 v32 = 2048;
          uint64_t v33 = v22;
          char v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_22;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v21 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          uint64_t v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
          __int16 v28 = 2082;
          unint64_t v29 = "count";
          __int16 v30 = 2048;
          uint64_t v31 = 1LL;
          __int16 v32 = 2048;
          uint64_t v33 = v21;
          char v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }

BOOL ___ZL33nw_webtransport_session_establishP23nw_webtransport_session_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3;
  BOOL is_http_connection = nw_protocol_metadata_is_http_connection(a3);
  if (is_http_connection)
  {
    if (v3) {
      uint64_t v3 = os_retain(v3);
    }
    uint64_t v6 = *(void *)(a1 + 32);
    char v7 = *(_BYTE *)(v6 + 384);
    if ((v7 & 1) != 0)
    {
      uint64_t v8 = *(void **)(v6 + 376);
      if (v8)
      {
        os_release(v8);
        char v7 = *(_BYTE *)(v6 + 384);
      }
    }

    *(void *)(v6 + 376) = v3;
    *(_BYTE *)(v6 + 384) = v7 | 1;
  }

  return !is_http_connection;
}

uint64_t ___ZL38nw_protocol_webtransport_stream_createPK22nw_protocol_identifierP23nw_webtransport_sessionP11nw_endpointP13nw_parameters_block_invoke( uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void ___ZL41nw_protocol_webtransport_stream_callbacksv_block_invoke()
{
  qword_18C5A3948 = (uint64_t)nw_protocol_default_reset;
  unk_18C5A3950 = nw_protocol_default_input_flush;
  qword_18C5A3918 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C5A3920 = nw_protocol_default_waiting_for_output;
  qword_18C5A38D8 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C5A38E0 = nw_protocol_default_unregister_notification;
  qword_18C5A38B8 = (uint64_t)nw_protocol_webtransport_stream_get_parameters;
  unk_18C5A38C0 = nw_protocol_default_get_path;
  qword_18C5A38C8 = (uint64_t)nw_protocol_default_get_local;
  unk_18C5A38D0 = nw_protocol_webtransport_stream_get_remote_endpoint;
  qword_18C5A3878 = (uint64_t)nw_protocol_webtransport_stream_disconnected;
  unk_18C5A3880 = nw_protocol_webtransport_stream_error;
  qword_18C5A3888 = (uint64_t)nw_protocol_webtransport_stream_input_available;
  unk_18C5A3890 = nw_protocol_webtransport_stream_output_available;
  qword_18C5A38E8 = (uint64_t)nw_protocol_webtransport_stream_notify;
  unk_18C5A38F0 = nw_protocol_default_updated_path;
  qword_18C5A3928 = (uint64_t)nw_protocol_webtransport_stream_copy_info;
  unk_18C5A3930 = nw_protocol_webtransport_stream_add_listen_handler;
  qword_18C5A3938 = (uint64_t)nw_protocol_webtransport_stream_remove_listen_handler;
  unk_18C5A3940 = nw_protocol_webtransport_stream_get_message_properties;
  nw_protocol_webtransport_stream_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_stream_add_input_handler;
  unk_18C5A3850 = nw_protocol_webtransport_stream_remove_input_handler;
  qword_18C5A3858 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_18C5A3860 = nw_protocol_webtransport_stream_connect;
  qword_18C5A3868 = (uint64_t)nw_protocol_webtransport_stream_disconnect;
  unk_18C5A3870 = nw_protocol_webtransport_stream_connected;
  qword_18C5A3898 = (uint64_t)nw_protocol_webtransport_stream_get_input_frames;
  unk_18C5A38A0 = nw_protocol_webtransport_stream_get_output_frames;
  qword_18C5A38A8 = (uint64_t)nw_protocol_webtransport_stream_finalize_output_frames;
  unk_18C5A38B0 = nw_protocol_default_link_state;
  qword_18C5A38F8 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_18C5A3900 = nw_protocol_webtransport_stream_input_finished;
  qword_18C5A3908 = (uint64_t)nw_protocol_webtransport_stream_output_finished;
  unk_18C5A3910 = nw_protocol_default_get_output_local;
}

uint64_t nw_protocol_webtransport_stream_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v198 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    os_log_type_t v139 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v140 = (os_log_s *)__nwlog_obj();
      os_log_type_t v141 = type[0];
      if (!os_log_type_enabled(v140, type[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null protocol";
      goto LABEL_280;
    }

    if (!LOBYTE(v174[0]))
    {
      int v140 = (os_log_s *)__nwlog_obj();
      os_log_type_t v141 = type[0];
      if (!os_log_type_enabled(v140, type[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_280;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v140 = (os_log_s *)__nwlog_obj();
    os_log_type_t v141 = type[0];
    BOOL v147 = os_log_type_enabled(v140, type[0]);
    if (!backtrace_string)
    {
      if (!v147) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_280;
    }

    if (!v147) {
      goto LABEL_254;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    __int16 v188 = 2082;
    uint64_t v189 = backtrace_string;
    BOOL v148 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_253:
    _os_log_impl(&dword_181A5C000, v140, v141, v148, buf, 0x16u);
    goto LABEL_254;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    os_log_type_t v139 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v140 = (os_log_s *)__nwlog_obj();
      os_log_type_t v141 = type[0];
      if (!os_log_type_enabled(v140, type[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null webtransport_stream";
      goto LABEL_280;
    }

    if (!LOBYTE(v174[0]))
    {
      int v140 = (os_log_s *)__nwlog_obj();
      os_log_type_t v141 = type[0];
      if (!os_log_type_enabled(v140, type[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_280;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v140 = (os_log_s *)__nwlog_obj();
    os_log_type_t v141 = type[0];
    BOOL v149 = os_log_type_enabled(v140, type[0]);
    if (!backtrace_string)
    {
      if (!v149) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_280;
    }

    if (!v149) {
      goto LABEL_254;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    __int16 v188 = 2082;
    uint64_t v189 = backtrace_string;
    BOOL v148 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_253;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    os_log_type_t v139 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v140 = (os_log_s *)__nwlog_obj();
      os_log_type_t v141 = type[0];
      if (!os_log_type_enabled(v140, type[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null input_protocol";
      goto LABEL_280;
    }

    if (!LOBYTE(v174[0]))
    {
      int v140 = (os_log_s *)__nwlog_obj();
      os_log_type_t v141 = type[0];
      if (!os_log_type_enabled(v140, type[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      uint64_t v142 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_280;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v140 = (os_log_s *)__nwlog_obj();
    os_log_type_t v141 = type[0];
    BOOL v150 = os_log_type_enabled(v140, type[0]);
    if (backtrace_string)
    {
      if (v150)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
        __int16 v188 = 2082;
        uint64_t v189 = backtrace_string;
        BOOL v148 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_253;
      }

uint64_t nw_protocol_webtransport_stream_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_protocol_webtransport_stream_connect";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        int v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "nw_protocol_webtransport_stream_connect";
          uint64_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_66;
        }

        goto LABEL_67;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v15 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "nw_protocol_webtransport_stream_connect";
          uint64_t v10 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_66;
        }

        goto LABEL_67;
      }

      if (!v15) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = "nw_protocol_webtransport_stream_connect";
      __int16 v25 = 2082;
      char v26 = backtrace_string;
      int v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }

    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_67;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_protocol_webtransport_stream_connect";
    uint64_t v10 = "%{public}s called with null protocol";
LABEL_66:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_67;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_protocol_webtransport_stream_connect";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        int v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "nw_protocol_webtransport_stream_connect";
          uint64_t v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_66;
        }

        goto LABEL_67;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v17 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v24 = "nw_protocol_webtransport_stream_connect";
          uint64_t v10 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_66;
        }

        goto LABEL_67;
      }

      if (!v17) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = "nw_protocol_webtransport_stream_connect";
      __int16 v25 = 2082;
      char v26 = backtrace_string;
      int v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_46;
    }

    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_67;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_protocol_webtransport_stream_connect";
    uint64_t v10 = "%{public}s called with null webtransport_stream";
    goto LABEL_66;
  }

  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v11 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = handle[11];
        if (v12) {
          int v13 = *(_DWORD *)(v12 + 460);
        }
        else {
          int v13 = -1;
        }
        uint64_t v20 = handle[8];
        *(_DWORD *)buf = 136447234;
        uint64_t v24 = "nw_protocol_webtransport_stream_connect";
        __int16 v25 = 2082;
        char v26 = (char *)(handle + 24);
        __int16 v27 = 2080;
        BOOL v28 = " ";
        __int16 v29 = 1024;
        int v30 = v13;
        __int16 v31 = 2048;
        uint64_t v32 = v20;
        _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }

  uint64_t v4 = handle[4];
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_protocol_webtransport_stream_connect";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = "nw_protocol_webtransport_stream_connect";
      uint64_t v10 = "%{public}s called with null output_protocol";
      goto LABEL_66;
    }

    if (!v21)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_webtransport_stream_connect";
        uint64_t v10 = "%{public}s called with null output_protocol, backtrace limit exceeded";
        goto LABEL_66;
      }

      goto LABEL_67;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v18 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_webtransport_stream_connect";
        uint64_t v10 = "%{public}s called with null output_protocol, no backtrace";
        goto LABEL_66;
      }

      goto LABEL_67;
    }

    if (!v18) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v24 = "nw_protocol_webtransport_stream_connect";
    __int16 v25 = 2082;
    char v26 = backtrace_string;
    int v16 = "%{public}s called with null output_protocol, dumping backtrace:%{public}s";
LABEL_46:
    _os_log_impl(&dword_181A5C000, v8, v9, v16, buf, 0x16u);
    goto LABEL_47;
  }

  uint64_t v5 = handle[11];
  if (v5)
  {
    if (!*(void *)(v5 + 32)) {
      nw_protocol_replace_input_handler(handle[4], (uint64_t)a1, handle[11]);
    }
    nw_protocol_set_output_handler(v5, v4);
    return nw_protocol_connect(v5, (uint64_t)a1);
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v24 = "nw_protocol_webtransport_stream_connect";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v21)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_webtransport_stream_connect";
        uint64_t v10 = "%{public}s called with null session_protocol, backtrace limit exceeded";
        goto LABEL_66;
      }

      goto LABEL_67;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v19 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_webtransport_stream_connect";
        uint64_t v10 = "%{public}s called with null session_protocol, no backtrace";
        goto LABEL_66;
      }

      goto LABEL_67;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = "nw_protocol_webtransport_stream_connect";
      __int16 v25 = 2082;
      char v26 = backtrace_string;
      int v16 = "%{public}s called with null session_protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }

void nw_protocol_webtransport_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_protocol_webtransport_stream_connected";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      uint64_t v10 = "%{public}s called with null protocol";
      goto LABEL_44;
    }

    if (!v20)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      uint64_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_44;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v12) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      uint64_t v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_44;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      __int16 v24 = 2082;
      __int16 v25 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_45:
    if (!v7) {
      return;
    }
    goto LABEL_46;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_protocol_webtransport_stream_connected";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      uint64_t v10 = "%{public}s called with null webtransport_stream";
      goto LABEL_44;
    }

    if (!v20)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      uint64_t v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_44;
    }

    int v13 = (char *)__nw_create_backtrace_string();
    int v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (v13)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v23 = "nw_protocol_webtransport_stream_connected";
        __int16 v24 = 2082;
        __int16 v25 = v13;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v13);
      if (!v7) {
        return;
      }
LABEL_46:
      free(v7);
      return;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      uint64_t v10 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_44:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      goto LABEL_45;
    }

    goto LABEL_45;
  }

  int v3 = (*((unsigned __int8 *)handle + 276) >> 4) & 1;
  if (!gLogDatapath) {
    LOBYTE(v3) = 1;
  }
  if (handle[11])
  {
    if ((v3 & 1) == 0)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v5 = handle[11];
        if (v5) {
          int v6 = *(_DWORD *)(v5 + 460);
        }
        else {
          int v6 = -1;
        }
        uint64_t v17 = handle[8];
        *(_DWORD *)buf = 136447234;
        BOOL v23 = "nw_protocol_webtransport_stream_connected";
        __int16 v24 = 2082;
        __int16 v25 = (char *)(handle + 24);
        __int16 v26 = 2080;
        __int16 v27 = " ";
        __int16 v28 = 1024;
        int v29 = v6;
        __int16 v30 = 2048;
        uint64_t v31 = v17;
        BOOL v18 = "%{public}s %{public}s%s<i%u:s%lld> Forwarding connect from lower layer, stream not reconfigured yet";
LABEL_49:
        _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEBUG, v18, buf, 0x30u);
      }
    }
  }

  else if ((v3 & 1) == 0)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v15 = handle[11];
      if (v15) {
        int v16 = *(_DWORD *)(v15 + 460);
      }
      else {
        int v16 = -1;
      }
      uint64_t v19 = handle[8];
      *(_DWORD *)buf = 136447234;
      BOOL v23 = "nw_protocol_webtransport_stream_connected";
      __int16 v24 = 2082;
      __int16 v25 = (char *)(handle + 24);
      __int16 v26 = 2080;
      __int16 v27 = " ";
      __int16 v28 = 1024;
      int v29 = v16;
      __int16 v30 = 2048;
      uint64_t v31 = v19;
      BOOL v18 = "%{public}s %{public}s%s<i%u:s%lld> Stream is not fully setup, ignoring connected event";
      goto LABEL_49;
    }
  }

uint64_t nw_protocol_webtransport_stream_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
      uint64_t v15 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
          __int16 v26 = 2082;
          __int16 v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_52:
        if (!v12) {
          return 0LL;
        }
LABEL_53:
        free(v12);
        return 0LL;
      }

      if (!v17) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
      uint64_t v15 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
      uint64_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_51;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        int v13 = (os_log_s *)__nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
        uint64_t v15 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }

      BOOL v18 = (char *)__nw_create_backtrace_string();
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
        uint64_t v15 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v25 = "nw_protocol_webtransport_stream_get_input_frames";
        __int16 v26 = 2082;
        __int16 v27 = v18;
        char v20 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v13, v14, v20, buf, 0x16u);
      }

uint64_t nw_protocol_webtransport_stream_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
      uint64_t v15 = "%{public}s called with null protocol";
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
          __int16 v26 = 2082;
          __int16 v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_52:
        if (!v12) {
          return 0LL;
        }
LABEL_53:
        free(v12);
        return 0LL;
      }

      if (!v17) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
      uint64_t v15 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
      uint64_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_51;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        int v13 = (os_log_s *)__nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
        uint64_t v15 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }

      BOOL v18 = (char *)__nw_create_backtrace_string();
      int v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
        uint64_t v15 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v25 = "nw_protocol_webtransport_stream_get_output_frames";
        __int16 v26 = 2082;
        __int16 v27 = v18;
        char v20 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v13, v14, v20, buf, 0x16u);
      }

uint64_t nw_protocol_webtransport_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
      uint64_t v11 = "%{public}s called with null protocol";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          return 0LL;
        }
LABEL_39:
        free(v8);
        return 0LL;
      }

      if (!v13) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
      uint64_t v11 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
      uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v18 = "nw_protocol_webtransport_stream_input_finished";
    int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_webtransport_stream_input_finished";
      uint64_t v6 = "%{public}s called with null protocol";
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v11 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_protocol_webtransport_stream_input_finished";
          __int16 v19 = 2082;
          __int16 v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v3) {
          return;
        }
LABEL_40:
        free(v3);
        return;
      }

      if (!v11) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_webtransport_stream_input_finished";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_webtransport_stream_input_finished";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_webtransport_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v18 = "nw_protocol_webtransport_stream_output_finished";
    int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_webtransport_stream_output_finished";
      uint64_t v6 = "%{public}s called with null protocol";
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v11 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_protocol_webtransport_stream_output_finished";
          __int16 v19 = 2082;
          __int16 v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v3) {
          return;
        }
LABEL_40:
        free(v3);
        return;
      }

      if (!v11) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_webtransport_stream_output_finished";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v18 = "nw_protocol_webtransport_stream_output_finished";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

BOOL nw_protocol_webtransport_accept(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_webtransport_accept";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_webtransport_accept";
      uint64_t v8 = "%{public}s called with null protocol";
      goto LABEL_37;
    }

    if (!v13)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_webtransport_accept";
      uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (!v10) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_webtransport_accept";
      uint64_t v8 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_37;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v16 = "nw_protocol_webtransport_accept";
      __int16 v17 = 2082;
      BOOL v18 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_38:
    if (!v5) {
      return 0LL;
    }
LABEL_39:
    free(v5);
    return 0LL;
  }

  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_webtransport_accept";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_webtransport_accept";
      uint64_t v8 = "%{public}s called with null webtransport_session";
      goto LABEL_37;
    }

    if (!v13)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_webtransport_accept";
      uint64_t v8 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_37;
    }

    BOOL v11 = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v12 = os_log_type_enabled(v6, type);
    if (v11)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        char v16 = "nw_protocol_webtransport_accept";
        __int16 v17 = 2082;
        BOOL v18 = v11;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v11);
      if (!v5) {
        return 0LL;
      }
      goto LABEL_39;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      char v16 = "nw_protocol_webtransport_accept";
      uint64_t v8 = "%{public}s called with null webtransport_session, no backtrace";
LABEL_37:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      goto LABEL_38;
    }

    goto LABEL_38;
  }

  if (*(_DWORD *)(v1 + 444) != 5) {
    return 1LL;
  }
  if ((*(_BYTE *)(v1 + 548) & 2) != 0) {
    return 0LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)gLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
  if (result)
  {
    int v4 = *(_DWORD *)(v1 + 460);
    *(_DWORD *)buf = 136446978;
    char v16 = "nw_protocol_webtransport_accept";
    __int16 v17 = 2082;
    BOOL v18 = (char *)(v1 + 464);
    __int16 v19 = 2080;
    __int16 v20 = " ";
    __int16 v21 = 1024;
    int v22 = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> cannot accept new streams after the session was closed",  buf,  0x26u);
    return 0LL;
  }

  return result;
}

uint64_t tcp_listener_create(dispatch_object_s *a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    __int16 v25 = "tcp_listener_create";
    char v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)__str = 136446210;
      __int16 v25 = "tcp_listener_create";
      char v16 = "%{public}s called with null queue";
      goto LABEL_37;
    }

    if (!v22)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)__str = 136446210;
      __int16 v25 = "tcp_listener_create";
      char v16 = "%{public}s called with null queue, backtrace limit exceeded";
      goto LABEL_37;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v21) {
        goto LABEL_38;
      }
      *(_DWORD *)__str = 136446210;
      __int16 v25 = "tcp_listener_create";
      char v16 = "%{public}s called with null queue, no backtrace";
      goto LABEL_37;
    }

    if (!v21) {
      goto LABEL_32;
    }
    *(_DWORD *)__str = 136446466;
    __int16 v25 = "tcp_listener_create";
    __int16 v26 = 2082;
    uint64_t v27 = backtrace_string;
    __int16 v19 = "%{public}s called with null queue, dumping backtrace:%{public}s";
    goto LABEL_31;
  }

  objc_opt_class();
  uint64_t v2 = _os_object_alloc();
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__str = 136446210;
    __int16 v25 = "tcp_listener_allocate";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__str = 136446210;
      __int16 v25 = "tcp_listener_allocate";
      BOOL v10 = "%{public}s tcp_listener_obj_alloc failed";
    }

    else if (v22)
    {
      BOOL v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)gLogObj;
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v11)
      {
        if (v12)
        {
          *(_DWORD *)__str = 136446466;
          __int16 v25 = "tcp_listener_allocate";
          __int16 v26 = 2082;
          uint64_t v27 = v11;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s tcp_listener_obj_alloc failed, dumping backtrace:%{public}s",  (uint8_t *)__str,  0x16u);
        }

        free(v11);
        goto LABEL_21;
      }

      if (!v12)
      {
LABEL_21:
        if (v7) {
          free(v7);
        }
        goto LABEL_23;
      }

      *(_DWORD *)__str = 136446210;
      __int16 v25 = "tcp_listener_allocate";
      BOOL v10 = "%{public}s tcp_listener_obj_alloc failed, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__str = 136446210;
      __int16 v25 = "tcp_listener_allocate";
      BOOL v10 = "%{public}s tcp_listener_obj_alloc failed, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, (uint8_t *)__str, 0xCu);
    goto LABEL_21;
  }

  uint64_t v3 = v2;
  *(_DWORD *)(v2 + 72) = 0;
  *(void *)(v2 + 64) = 0LL;
  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  *(void *)(v3 + 16) = v4;
  if (v4)
  {
    snprintf(__str, 0x35uLL, "com.apple.networking.tcp_listener.%p", (const void *)v3);
    char v28 = 0;
    os_log_type_t v5 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    dispatch_queue_t v6 = dispatch_queue_create(__str, v5);
    *(void *)(v3 + 24) = v6;
    if (v6)
    {
      *(_DWORD *)(v3 + 80) = 1;
      *(void *)(v3 + 32) = a1;
      dispatch_retain(a1);
      return v3;
    }
  }

  os_release((void *)v3);
LABEL_23:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)__str = 136446210;
  __int16 v25 = "tcp_listener_create";
  char v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)gLogObj;
    os_log_type_t v15 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)__str = 136446210;
      __int16 v25 = "tcp_listener_create";
      char v16 = "%{public}s tcp_listener_allocate failed";
LABEL_37:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, (uint8_t *)__str, 0xCu);
      goto LABEL_38;
    }

    goto LABEL_38;
  }

  if (v22)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)gLogObj;
    os_log_type_t v15 = type;
    BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)__str = 136446210;
        __int16 v25 = "tcp_listener_create";
        char v16 = "%{public}s tcp_listener_allocate failed, no backtrace";
        goto LABEL_37;
      }

      goto LABEL_38;
    }

    if (!v18)
    {
LABEL_32:
      free(backtrace_string);
      goto LABEL_38;
    }

    *(_DWORD *)__str = 136446466;
    __int16 v25 = "tcp_listener_create";
    __int16 v26 = 2082;
    uint64_t v27 = backtrace_string;
    __int16 v19 = "%{public}s tcp_listener_allocate failed, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v14, v15, v19, (uint8_t *)__str, 0x16u);
    goto LABEL_32;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v14 = (os_log_s *)gLogObj;
  os_log_type_t v15 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)__str = 136446210;
    __int16 v25 = "tcp_listener_create";
    char v16 = "%{public}s tcp_listener_allocate failed, backtrace limit exceeded";
    goto LABEL_37;
  }

uint64_t tcp_listener_create_launchd(dispatch_object_s *a1, const char *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v3 = tcp_listener_create(a1);
  uint64_t v4 = v3;
  if (v3) {
    xpc_dictionary_set_string(*(xpc_object_t *)(v3 + 16), "launchd", a2);
  }
  return v4;
}

void tcp_listener_start(uint64_t a1)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v62 = "tcp_listener_start";
    uint64_t v51 = (char *)_os_log_send_and_compose_impl();
    fds[0] = 16;
    LOBYTE(cnt) = 0;
    if (fds[0] == 17)
    {
      uint64_t v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = fds[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)fds[0])) {
        goto LABEL_116;
      }
      *(_DWORD *)buf = 136446210;
      int v62 = "tcp_listener_start";
      int v54 = "%{public}s called with null listener";
    }

    else if ((_BYTE)cnt)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = fds[0];
      BOOL v56 = os_log_type_enabled(v52, (os_log_type_t)fds[0]);
      if (backtrace_string)
      {
        if (v56)
        {
          *(_DWORD *)buf = 136446466;
          int v62 = "tcp_listener_start";
          __int16 v63 = 2082;
          uint64_t v64 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_116;
      }

      if (!v56)
      {
LABEL_116:
        if (v51) {
          free(v51);
        }
        return;
      }

      *(_DWORD *)buf = 136446210;
      int v62 = "tcp_listener_start";
      int v54 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      uint64_t v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = fds[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)fds[0])) {
        goto LABEL_116;
      }
      *(_DWORD *)buf = 136446210;
      int v62 = "tcp_listener_start";
      int v54 = "%{public}s called with null listener, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
    goto LABEL_116;
  }

  uint64_t v2 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  if (*(_DWORD *)(a1 + 80) != 1) {
    goto LABEL_82;
  }
  if (!*(void *)(a1 + 40))
  {
    uint64_t v14 = (void *)a1;
    int v15 = 22;
    goto LABEL_81;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v3 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    size_t v4 = *(void *)(a1 + 16);
    *(_DWORD *)buf = 136446722;
    int v62 = "tcp_listener_start_locked";
    __int16 v63 = 2048;
    uint64_t v64 = a1;
    __int16 v65 = 2114;
    size_t v66 = v4;
    _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %p: %{public}@", buf, 0x20u);
  }

  string = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "launchd");
  if (!string)
  {
    char v16 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "interface");
    if (v16)
    {
      __int16 v17 = v16;
      if (!strcasecmp(v16, (const char *)kTCPListenerInterfaceAll))
      {
        int v21 = 1;
        goto LABEL_40;
      }

      unsigned int v18 = if_nametoindex(v17);
      *(_DWORD *)(a1 + 76) = v18;
      if (!v18)
      {
        int v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        BOOL v37 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          int v62 = "tcp_listener_setup_sockets";
          __int16 v63 = 2082;
          uint64_t v64 = (uint64_t)v17;
          _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s could not find interface %{public}s",  buf,  0x16u);
        }

        goto LABEL_79;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v19 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v20 = *(_DWORD *)(a1 + 76);
        *(_DWORD *)buf = 136446466;
        int v62 = "tcp_listener_setup_sockets";
        __int16 v63 = 1024;
        LODWORD(v64) = v20;
        _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s ifindex %u", buf, 0x12u);
      }
    }

    int v21 = 0;
LABEL_40:
    unsigned __int16 uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 16), "port");
    uint64_t v23 = uint64;
    int v24 = -9;
    __int16 v25 = uint64;
    while (1)
    {
      int v26 = v24;
      LODWORD(cnt) = 0;
      uint64_t v27 = tcp_listener_socket_create(a1, 2, v25, *(_DWORD *)(a1 + 76), v21, (unsigned int *)&cnt);
      if (!v27) {
        goto LABEL_58;
      }
      uint64_t v28 = v27;
      socklen_t v60 = 28;
      if (getsockname(*(_DWORD *)(v27 + 16), (sockaddr *)buf, &v60)) {
        break;
      }
      BOOL v29 = tcp_listener_socket_create(a1, 30, *(__int16 *)&buf[2], *(_DWORD *)(a1 + 76), v21, (unsigned int *)&cnt);
      if (v29)
      {
        uint64_t v36 = v29;
        *(_WORD *)(a1 + 84) = *(_WORD *)&buf[2];
        dispatch_resume(*(dispatch_object_t *)(v28 + 8));
        *(_BYTE *)(v28 + 20) = 1;
        *(void *)uint64_t v28 = *(void *)(a1 + 64);
        *(void *)(a1 + 64) = v28;
        dispatch_resume(*(dispatch_object_t *)(v36 + 8));
        *(_BYTE *)(v36 + 20) = 1;
        *(void *)uint64_t v36 = *(void *)(a1 + 64);
        *(void *)(a1 + 64) = v36;
LABEL_58:
        int v7 = cnt;
LABEL_79:
        if (!v7)
        {
          if (!xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvtype")) {
            goto LABEL_38;
          }
          __int16 v42 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "interface");
          uint64_t v43 = v42;
          if (v42)
          {
            else {
              LODWORD(v43) = 0;
            }
          }

          if (xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 16), "registerp2p"))
          {
            LODWORD(v43) = v43 | 0x20000;
            if (*(_DWORD *)(a1 + 76))
            {
              os_log_type_t v44 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                BOOL v45 = if_indextoname(*(_DWORD *)(a1 + 76), fds);
                uint64_t v46 = "?";
                if (v45) {
                  uint64_t v46 = fds;
                }
                *(_DWORD *)buf = 136446466;
                int v62 = "tcp_listener_setup_bonjour";
                __int16 v63 = 2082;
                uint64_t v64 = (uint64_t)v46;
                _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s Client specified an interface (%{public}s) and RegisterP2P",  buf,  0x16u);
              }
            }
          }

          uint32_t v47 = *(_DWORD *)(a1 + 76);
          char v48 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvname");
          os_log_type_t v49 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvtype");
          char v50 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 16), "localonly")
              ? "local."
              : xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvdomain");
          int v7 = DNSServiceRegister( (DNSServiceRef *)(a1 + 56),  (DNSServiceFlags)v43,  v47,  v48,  v49,  v50,  0LL,  *(_WORD *)(a1 + 84),  0,  0LL,  (DNSServiceRegisterReply)tcp_listener_dns_handler,  (void *)a1);
          if (!v7)
          {
            int v7 = DNSServiceSetDispatchQueue(*(DNSServiceRef *)(a1 + 56), *(dispatch_queue_t *)(a1 + 24));
            if (!v7) {
              goto LABEL_38;
            }
          }
        }

        goto LABEL_80;
      }

      __int16 v30 = *(dispatch_source_s **)(v28 + 8);
      if (v30)
      {
        dispatch_source_cancel(v30);
        if (!*(_BYTE *)(v28 + 20)) {
          dispatch_resume(*(dispatch_object_t *)(v28 + 8));
        }
      }

      else
      {
        int v31 = *(_DWORD *)(v28 + 16);
        if (v31 != -1) {
          close(v31);
        }
      }

      free((void *)v28);
      if (!v23 && (_DWORD)cnt == 48)
      {
        int v24 = v26 + 1;
        if (v26) {
          continue;
        }
      }

      goto LABEL_58;
    }

    int v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)fds = 136446466;
    *(void *)&fds[4] = "tcp_listener_setup_sockets";
    __int16 v68 = 1024;
    int v69 = v7;
    __int16 v32 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v57) = 16;
    char v59 = 0;
    if (__nwlog_fault(v32, &v57, &v59))
    {
      if (v57 == 17)
      {
        uint64_t v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = v57;
        if (os_log_type_enabled(v33, (os_log_type_t)v57))
        {
          *(_DWORD *)fds = 136446466;
          *(void *)&fds[4] = "tcp_listener_setup_sockets";
          __int16 v68 = 1024;
          int v69 = v7;
          BOOL v35 = "%{public}s getsockname failed %{darwin.errno}d";
LABEL_70:
          _os_log_impl(&dword_181A5C000, v33, v34, v35, fds, 0x12u);
        }
      }

      else if (v59)
      {
        os_log_type_t v38 = (char *)__nw_create_backtrace_string();
        uint64_t v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = v57;
        BOOL v39 = os_log_type_enabled(v33, (os_log_type_t)v57);
        if (v38)
        {
          if (v39)
          {
            *(_DWORD *)fds = 136446722;
            *(void *)&fds[4] = "tcp_listener_setup_sockets";
            __int16 v68 = 1024;
            int v69 = v7;
            __int16 v70 = 2082;
            uint64_t v71 = v38;
            _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s",  fds,  0x1Cu);
          }

          free(v38);
          goto LABEL_71;
        }

        if (v39)
        {
          *(_DWORD *)fds = 136446466;
          *(void *)&fds[4] = "tcp_listener_setup_sockets";
          __int16 v68 = 1024;
          int v69 = v7;
          BOOL v35 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
          goto LABEL_70;
        }
      }

      else
      {
        uint64_t v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = v57;
        if (os_log_type_enabled(v33, (os_log_type_t)v57))
        {
          *(_DWORD *)fds = 136446466;
          *(void *)&fds[4] = "tcp_listener_setup_sockets";
          __int16 v68 = 1024;
          int v69 = v7;
          BOOL v35 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_70;
        }
      }
    }

void tcp_listener_call_error_handler_locked(void *a1, int a2)
{
  uint64_t v3 = (const void *)a1[6];
  if (v3)
  {
    v9[0] = 0LL;
    v9[1] = v9;
    v9[2] = 0x3002000000LL;
    v9[3] = __Block_byref_object_copy__34743;
    v9[4] = __Block_byref_object_dispose__34744;
    v9[5] = _Block_copy(v3);
    v8[0] = 0LL;
    v8[1] = v8;
    v8[2] = 0x2000000000LL;
    v8[3] = os_retain(a1);
    os_log_type_t v5 = (dispatch_queue_s *)a1[4];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __tcp_listener_call_error_handler_locked_block_invoke;
    block[3] = &unk_189BBC870;
    void block[4] = v8;
    block[5] = v9;
    int v7 = a2;
    dispatch_async(v5, block);
    _Block_object_dispose(v8, 8);
    _Block_object_dispose(v9, 8);
  }

  tcp_listener_cancel_locked(a1);
}

BOOL tcp_listener_socket_create_with_fd(int a1, uint64_t a2, int a3)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  int v55 = 1;
  if (ioctl(a3, 0x8004667EuLL, &v55) < 0)
  {
    int v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v11;
    int v7 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        BOOL v10 = "%{public}s FIONBIO failed %{darwin.errno}d";
        goto LABEL_50;
      }

BOOL tcp_listener_socket_create(uint64_t a1, int a2, __int16 a3, int a4, int a5, unsigned int *a6)
{
  *(void *)&v58[5] = *MEMORY[0x1895F89C0];
  int v52 = a4;
  int v11 = socket(a2, 1, 6);
  int v12 = v11;
  if (v11 < 0)
  {
    unsigned int v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v18;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    int v54 = "tcp_listener_socket_create";
    __int16 v55 = 1024;
    int v56 = v18;
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();
    type.os_log_type_t sa_len = 16;
    LOBYTE(v51) = 0;
    if (type.sa_len == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = (os_log_s *)gLogObj;
      os_log_type_t sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len)) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      int v54 = "tcp_listener_socket_create";
      __int16 v55 = 1024;
      int v56 = v18;
      __int16 v17 = "%{public}s socket failed %{darwin.errno}d";
      goto LABEL_122;
    }

    if (!(_BYTE)v51)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = (os_log_s *)gLogObj;
      os_log_type_t sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len)) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      int v54 = "tcp_listener_socket_create";
      __int16 v55 = 1024;
      int v56 = v18;
      __int16 v17 = "%{public}s socket failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_122;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = (os_log_s *)gLogObj;
    os_log_type_t sa_len = type.sa_len;
    BOOL v23 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len);
    if (!backtrace_string)
    {
      if (!v23) {
        goto LABEL_124;
      }
      *(_DWORD *)buf = 136446466;
      int v54 = "tcp_listener_socket_create";
      __int16 v55 = 1024;
      int v56 = v18;
      __int16 v17 = "%{public}s socket failed %{darwin.errno}d, no backtrace";
      goto LABEL_122;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446722;
      int v54 = "tcp_listener_socket_create";
      __int16 v55 = 1024;
      int v56 = v18;
      __int16 v57 = 2082;
      *(void *)int v58 = backtrace_string;
      os_log_type_t v22 = "%{public}s socket failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

void tcp_listener_dns_handler( uint64_t a1, int a2, int a3, const char *a4, const char *a5, const char *a6, uint64_t a7)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v13 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v18 = "tcp_listener_dns_handler";
    uint64_t v14 = "<NULL>";
    int v17 = 136447490;
    if (a4) {
      uint64_t v14 = a4;
    }
    __int16 v19 = 1024;
    int v20 = a2;
    os_log_type_t v15 = "NULL";
    __int16 v21 = 1024;
    if (a5) {
      char v16 = a5;
    }
    else {
      char v16 = "NULL";
    }
    int v22 = a3;
    if (a6) {
      os_log_type_t v15 = a6;
    }
    __int16 v23 = 2082;
    int v24 = v14;
    __int16 v25 = 2082;
    uint32_t v26 = v16;
    __int16 v27 = 2082;
    unsigned int v28 = v15;
    _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s flags=0x%x, errorCode=%d, name=%{public}s, type=%{public}s, domain=%{public}s",  (uint8_t *)&v17,  0x36u);
  }

  if (a3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a7 + 72));
    tcp_listener_call_error_handler_locked((void *)a7, a3);
    os_unfair_lock_unlock((os_unfair_lock_t)(a7 + 72));
  }

void __tcp_listener_socket_create_with_fd_block_invoke(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v84 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 72LL));
  uint64_t v2 = *(void *)(v1 + 32);
  if (!v2)
  {
    __nwlog_obj();
    int __buf = 136446210;
    *(void *)__int16 v55 = "tcp_listener_accept_locked";
    os_log_type_t v38 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(block[0]) = 16;
    address.os_log_type_t sa_len = 0;
    if (LOBYTE(block[0]) == 17)
    {
      os_log_type_t v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = block[0];
      if (!os_log_type_enabled(v39, block[0])) {
        goto LABEL_68;
      }
      int __buf = 136446210;
      *(void *)__int16 v55 = "tcp_listener_accept_locked";
      BOOL v41 = "%{public}s called with null listener";
    }

    else if (address.sa_len)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = block[0];
      BOOL v43 = os_log_type_enabled(v39, block[0]);
      if (backtrace_string)
      {
        if (v43)
        {
          int __buf = 136446466;
          *(void *)__int16 v55 = "tcp_listener_accept_locked";
          *(_WORD *)&v55[8] = 2082;
          *(void *)&v55[10] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s called with null listener, dumping backtrace:%{public}s",  (uint8_t *)&__buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_68;
      }

      if (!v43)
      {
LABEL_68:
        if (v38) {
          free(v38);
        }
        goto LABEL_53;
      }

      int __buf = 136446210;
      *(void *)__int16 v55 = "tcp_listener_accept_locked";
      BOOL v41 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      os_log_type_t v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = block[0];
      if (!os_log_type_enabled(v39, block[0])) {
        goto LABEL_68;
      }
      int __buf = 136446210;
      *(void *)__int16 v55 = "tcp_listener_accept_locked";
      BOOL v41 = "%{public}s called with null listener, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v39, v40, v41, (uint8_t *)&__buf, 0xCu);
    goto LABEL_68;
  }

  uint64_t v44 = v1;
  int v3 = *(_DWORD *)(v1 + 40);
  size_t v4 = &qword_18C45F000;
  while (1)
  {
    *(void *)&address.os_log_type_t sa_len = 0LL;
    *(void *)&address.sa_data[6] = 0LL;
    int v49 = 0;
    uint64_t v48 = 0LL;
    socklen_t v46 = 28;
    int v7 = accept(v3, &address, &v46);
    if (v7 < 0) {
      break;
    }
    int v8 = v7;
    if (setsockopt(v7, 0xFFFF, 4130, &tcp_listener_accept_locked_on, 4u))
    {
      nw_endpoint_t v25 = nw_endpoint_create_address(&address);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v26 = (os_log_s *)v4[131];
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        logging_description = nw_endpoint_get_logging_description(v25);
        int __buf = 136446466;
        *(void *)__int16 v55 = "tcp_listener_accept_locked";
        *(_WORD *)&v55[8] = 2082;
        *(void *)&v55[10] = logging_description;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to set SO_NOSIGPIPE on new connection from %{public}s",  (uint8_t *)&__buf,  0x16u);
      }

      uint64_t v1 = v44;
      if (v25) {
        goto LABEL_51;
      }
      goto LABEL_52;
    }

    if (xpc_dictionary_get_BOOL(*(xpc_object_t *)(v2 + 16), "localonly"))
    {
      pid_t v9 = getpid();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (os_log_s *)v4[131];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        int v51 = "tcp_listener_verify_local";
        __int16 v52 = 2048;
        uint64_t v53 = v2;
        _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %p", buf, 0x16u);
      }

      int v11 = socket(17, 3, 0);
      if (v11 < 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v29 = (os_log_s *)v4[131];
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          int v30 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          *(_DWORD *)buf = 136446466;
          int v51 = "tcp_listener_verify_local";
          __int16 v52 = 1024;
          LODWORD(v53) = v30;
          _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s failure to create routing socket %d",  buf,  0x12u);
        }
      }

      else
      {
        int v12 = v11;
        do
        {
          unsigned int v13 = __ldxr((unsigned int *)&tcp_listener_verify_local_seq);
          unsigned int v14 = v13 + 1;
        }

        while (__stxr(v14, (unsigned int *)&tcp_listener_verify_local_seq));
        tcp_listener_verify_local_seq = v14;
        *(_DWORD *)__int16 v55 = 0;
        memset(&v55[16], 0, 32);
        __int128 v56 = 0u;
        __int128 v57 = 0u;
        __int128 v58 = 0u;
        __int128 v59 = 0u;
        __int128 v60 = 0u;
        __int128 v61 = 0u;
        __int128 v62 = 0u;
        __int128 v63 = 0u;
        __int128 v64 = 0u;
        __int128 v65 = 0u;
        __int128 v66 = 0u;
        __int128 v67 = 0u;
        __int128 v68 = 0u;
        __int128 v69 = 0u;
        __int128 v70 = 0u;
        __int128 v71 = 0u;
        __int128 v72 = 0u;
        __int128 v73 = 0u;
        __int128 v74 = 0u;
        __int128 v75 = 0u;
        __int128 v76 = 0u;
        __int128 v77 = 0u;
        __int128 v78 = 0u;
        __int128 v79 = 0u;
        __int128 v80 = 0u;
        __int128 v81 = 0u;
        __int128 v82 = 0u;
        memset(v83, 0, sizeof(v83));
        HIWORD(__buf) = 4357;
        *(void *)&void v55[4] = 0x100000807LL;
        size_t v15 = address.sa_len + 92LL;
        LOWORD(__buf) = address.sa_len + 92;
        *(_DWORD *)&v55[12] = v9;
        *(_DWORD *)&v55[16] = v14;
        __memcpy_chk();
        if (write(v12, &__buf, v15) < 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unsigned int v31 = (os_log_s *)v4[131];
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            int v32 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            *(_DWORD *)buf = 136446466;
            int v51 = "tcp_listener_verify_local";
            __int16 v52 = 1024;
            LODWORD(v53) = v32;
            unsigned int v33 = "%{public}s failure while writing to the routing socket %d";
            goto LABEL_44;
          }
        }

        else
        {
          while (1)
          {
            ssize_t v16 = read(v12, &__buf, 0x200uLL);
            if (v16 < 1) {
              break;
            }
            if (*(_DWORD *)&v55[16] == tcp_listener_verify_local_seq && *(_DWORD *)&v55[12] == v9) {
              goto LABEL_20;
            }
          }

          if ((v16 & 0x8000000000000000LL) == 0)
          {
LABEL_20:
            close(v12);
            if ((*(_DWORD *)&v55[4] & 0x200400) == 0) {
              goto LABEL_46;
            }
            goto LABEL_21;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unsigned int v31 = (os_log_s *)v4[131];
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_45;
          }
          int v34 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          *(_DWORD *)buf = 136446466;
          int v51 = "tcp_listener_verify_local";
          __int16 v52 = 1024;
          LODWORD(v53) = v34;
          unsigned int v33 = "%{public}s failure reading from the routing socket %d";
LABEL_44:
          _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEBUG, v33, buf, 0x12u);
        }

void __tcp_listener_socket_create_with_fd_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  close(*(_DWORD *)(a1 + 48));
  int v3 = *(dispatch_object_s **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  if (v2) {
    os_release(v2);
  }
}

void __tcp_listener_accept_locked_block_invoke(void *a1)
{
  uint64_t v1 = (void *)a1[5];
  if (*(_DWORD *)(a1[6] + 80LL) != 3) {
    (*(void (**)(void))(a1[4] + 16LL))();
  }
  if (v1) {
    os_release(v1);
  }
}

void __Block_byref_object_copy__34743(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__34744(uint64_t a1)
{
}

void __tcp_listener_call_error_handler_locked_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v2[20] == 3
    || ((*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) + 16LL))(),
        (uint64_t v2 = *(_DWORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) != 0LL))
  {
    os_release(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  int v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  if (v3)
  {
    _Block_release(v3);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) = 0LL;
  }

void tcp_listener_cancel_locked(void *a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    int v9 = 136446466;
    BOOL v10 = "tcp_listener_cancel_locked";
    __int16 v11 = 2048;
    int v12 = a1;
    _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %p", (uint8_t *)&v9, 0x16u);
  }

  while (1)
  {
    int v3 = (void *)a1[8];
    if (!v3) {
      break;
    }
    a1[8] = *(void *)v3;
    size_t v4 = (dispatch_source_s *)*((void *)v3 + 1);
    if (v4)
    {
      dispatch_source_cancel(v4);
      if (!*((_BYTE *)v3 + 20)) {
        dispatch_resume(*((dispatch_object_t *)v3 + 1));
      }
    }

    else
    {
      int v5 = *((_DWORD *)v3 + 4);
      if (v5 != -1) {
        close(v5);
      }
    }

    free(v3);
  }

  int v6 = (const void *)a1[5];
  if (v6)
  {
    _Block_release(v6);
    a1[5] = 0LL;
  }

  int v7 = (const void *)a1[6];
  if (v7)
  {
    _Block_release(v7);
    a1[6] = 0LL;
  }

  int v8 = (_DNSServiceRef_t *)a1[7];
  if (v8)
  {
    DNSServiceRefDeallocate(v8);
    a1[7] = 0LL;
  }

void tcp_listener_cancel(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    *(_DWORD *)(a1 + 80) = 3;
    os_unfair_lock_unlock(v2);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000LL;
    unsigned int v14 = os_retain((void *)a1);
    int v3 = *(dispatch_queue_s **)(a1 + 24);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __tcp_listener_cancel_block_invoke;
    block[3] = &unk_189BBC7E8;
    void block[4] = buf;
    dispatch_async(v3, block);
    _Block_object_dispose(buf, 8);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "tcp_listener_cancel";
  size_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_listener_cancel";
      int v7 = "%{public}s called with null listener";
      goto LABEL_17;
    }

    if (!v11)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_listener_cancel";
      int v7 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_listener_cancel";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_listener_cancel";
      int v7 = "%{public}s called with null listener, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

void __tcp_listener_cancel_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v2)
  {
    os_release(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

uint64_t tcp_listener_get_dns_service_ref(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    uint64_t v3 = *(void *)(a1 + 56);
    os_unfair_lock_unlock(v2);
    return v3;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v14 = "tcp_listener_get_dns_service_ref";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v14 = "tcp_listener_get_dns_service_ref";
        int v8 = "%{public}s called with null listener";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v14 = "tcp_listener_get_dns_service_ref";
          __int16 v15 = 2082;
          ssize_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v14 = "tcp_listener_get_dns_service_ref";
        int v8 = "%{public}s called with null listener, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v14 = "tcp_listener_get_dns_service_ref";
        int v8 = "%{public}s called with null listener, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void tcp_listener_set_accept_handler(uint64_t a1, const void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v18 = "tcp_listener_set_accept_handler";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v18 = "tcp_listener_set_accept_handler";
      BOOL v10 = "%{public}s called with null listener";
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v18 = "tcp_listener_set_accept_handler";
          __int16 v19 = 2082;
          int v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v7) {
          return;
        }
        goto LABEL_37;
      }

      if (!v12) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v18 = "tcp_listener_set_accept_handler";
      BOOL v10 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v18 = "tcp_listener_set_accept_handler";
      BOOL v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }

void tcp_listener_set_accept_handler_f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "tcp_listener_set_accept_handler_f";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "tcp_listener_set_accept_handler_f";
      BOOL v10 = "%{public}s called with null listener";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      BOOL v12 = os_log_type_enabled(v8, v17);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v19 = "tcp_listener_set_accept_handler_f";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_37:
        if (!v7) {
          return;
        }
LABEL_38:
        free(v7);
        return;
      }

      if (!v12) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "tcp_listener_set_accept_handler_f";
      BOOL v10 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "tcp_listener_set_accept_handler_f";
      BOOL v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }

uint64_t __tcp_listener_set_accept_handler_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void tcp_listener_set_error_handler(uint64_t a1, const void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v18 = "tcp_listener_set_error_handler";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v18 = "tcp_listener_set_error_handler";
      BOOL v10 = "%{public}s called with null listener";
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v18 = "tcp_listener_set_error_handler";
          __int16 v19 = 2082;
          __int16 v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v7) {
          return;
        }
        goto LABEL_37;
      }

      if (!v12) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v18 = "tcp_listener_set_error_handler";
      BOOL v10 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v18 = "tcp_listener_set_error_handler";
      BOOL v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }

void tcp_listener_set_error_handler_f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "tcp_listener_set_error_handler_f";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "tcp_listener_set_error_handler_f";
      BOOL v10 = "%{public}s called with null listener";
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      BOOL v12 = os_log_type_enabled(v8, v17);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v19 = "tcp_listener_set_error_handler_f";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_37:
        if (!v7) {
          return;
        }
LABEL_38:
        free(v7);
        return;
      }

      if (!v12) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "tcp_listener_set_error_handler_f";
      BOOL v10 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      int v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v17;
      if (!os_log_type_enabled(v8, v17)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v19 = "tcp_listener_set_error_handler_f";
      BOOL v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }

uint64_t __tcp_listener_set_error_handler_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

uint64_t tcp_listener_set_port(uint64_t a1, const char *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    v16.ai_flags = 136446210;
    *(void *)&v16.ai_family = "tcp_listener_set_port";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v15)
      {
        os_log_type_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        if (!os_log_type_enabled(v7, type[0])) {
          goto LABEL_39;
        }
        v16.ai_flags = 136446210;
        *(void *)&v16.ai_family = "tcp_listener_set_port";
        os_log_type_t v9 = "%{public}s called with null listener, backtrace limit exceeded";
        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type[0];
      BOOL v11 = os_log_type_enabled(v7, type[0]);
      if (!backtrace_string)
      {
        if (!v11) {
          goto LABEL_39;
        }
        v16.ai_flags = 136446210;
        *(void *)&v16.ai_family = "tcp_listener_set_port";
        os_log_type_t v9 = "%{public}s called with null listener, no backtrace";
        goto LABEL_38;
      }

      if (v11)
      {
        v16.ai_flags = 136446466;
        *(void *)&v16.ai_family = "tcp_listener_set_port";
        LOWORD(v16.ai_protocol) = 2082;
        *(void *)((char *)&v16.ai_protocol + 2) = backtrace_string;
        BOOL v12 = "%{public}s called with null listener, dumping backtrace:%{public}s";
LABEL_28:
        _os_log_impl(&dword_181A5C000, v7, v8, v12, (uint8_t *)&v16, 0x16u);
      }

uint64_t tcp_listener_get_port(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    uint64_t v3 = *(unsigned __int16 *)(a1 + 84);
    os_unfair_lock_unlock(v2);
    return v3;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v14 = "tcp_listener_get_port";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v14 = "tcp_listener_get_port";
        os_log_type_t v8 = "%{public}s called with null listener";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v14 = "tcp_listener_get_port";
          __int16 v15 = 2082;
          addrinfo v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v14 = "tcp_listener_get_port";
        os_log_type_t v8 = "%{public}s called with null listener, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v14 = "tcp_listener_get_port";
        os_log_type_t v8 = "%{public}s called with null listener, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void tcp_listener_set_local_only(uint64_t a1, BOOL a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 16), "localonly", a2);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v5 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v15 = "tcp_listener_set_local_only";
        _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s listener is already running", buf, 0xCu);
      }
    }

    os_unfair_lock_unlock(v4);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v15 = "tcp_listener_set_local_only";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v15 = "tcp_listener_set_local_only";
      os_log_type_t v9 = "%{public}s called with null listener";
      goto LABEL_21;
    }

    if (!v12)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v15 = "tcp_listener_set_local_only";
      os_log_type_t v9 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_21;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v15 = "tcp_listener_set_local_only";
        __int16 v16 = 2082;
        uint64_t v17 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_22;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v15 = "tcp_listener_set_local_only";
      os_log_type_t v9 = "%{public}s called with null listener, no backtrace";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

void tcp_listener_set_tfo(uint64_t a1, BOOL a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 16), "tfo", a2);
LABEL_20:
      os_unfair_lock_unlock(v4);
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "tcp_listener_set_tfo";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v5, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v6 = (os_log_s *)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_listener_set_tfo";
        os_log_type_t v8 = "%{public}s listener is already running";
        goto LABEL_17;
      }

      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v6 = (os_log_s *)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_listener_set_tfo";
        os_log_type_t v8 = "%{public}s listener is already running, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v20 = "tcp_listener_set_tfo";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s listener is already running, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "tcp_listener_set_tfo";
        os_log_type_t v8 = "%{public}s listener is already running, no backtrace";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

void tcp_listener_enable_coprocessor_interface(uint64_t a1, char a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = *(dispatch_queue_s **)(a1 + 24);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __tcp_listener_enable_coprocessor_interface_block_invoke;
    block[3] = &__block_descriptor_tmp_6_34838;
    void block[4] = a1;
    char v10 = a2;
    dispatch_sync(v2, block);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v14 = "tcp_listener_enable_coprocessor_interface";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v12 = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v3, &v12, &v11))
  {
    if (v12 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = v12;
      if (!os_log_type_enabled(v4, v12)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v14 = "tcp_listener_enable_coprocessor_interface";
      os_log_type_t v6 = "%{public}s called with null listener";
      goto LABEL_17;
    }

    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = v12;
      if (!os_log_type_enabled(v4, v12)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v14 = "tcp_listener_enable_coprocessor_interface";
      os_log_type_t v6 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = v12;
    BOOL v8 = os_log_type_enabled(v4, v12);
    if (backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v14 = "tcp_listener_enable_coprocessor_interface";
        __int16 v15 = 2082;
        BOOL v16 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v14 = "tcp_listener_enable_coprocessor_interface";
      os_log_type_t v6 = "%{public}s called with null listener, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    }
  }

void __tcp_listener_enable_coprocessor_interface_block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v1 + 80) == 1)
  {
    xpc_dictionary_set_BOOL(*(xpc_object_t *)(v1 + 16), "coproc", *(_BYTE *)(a1 + 40));
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  char v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      char v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
      os_log_type_t v5 = "%{public}s listener is already running";
      goto LABEL_16;
    }

    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      char v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
      os_log_type_t v5 = "%{public}s listener is already running, backtrace limit exceeded";
      goto LABEL_16;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        char v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
        __int16 v12 = 2082;
        os_log_type_t v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s listener is already running, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_17;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      char v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
      os_log_type_t v5 = "%{public}s listener is already running, no backtrace";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

void tcp_listener_set_service(uint64_t a1, const char *a2, const char *a3, const char *a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "tcp_listener_set_service";
    char v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "tcp_listener_set_service";
      os_log_type_t v13 = "%{public}s called with null listener";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v21 = "tcp_listener_set_service";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v10) {
          return;
        }
LABEL_41:
        free(v10);
        return;
      }

      if (!v15) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "tcp_listener_set_service";
      os_log_type_t v13 = "%{public}s called with null listener, no backtrace";
    }

    else
    {
      char v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "tcp_listener_set_service";
      os_log_type_t v13 = "%{public}s called with null listener, backtrace limit exceeded";
    }

void tcp_listener_set_register_p2p(uint64_t a1, BOOL a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    os_log_type_t v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 16), "registerp2p", a2);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "tcp_listener_set_register_p2p";
        _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s listener is already running", buf, 0xCu);
      }
    }

    os_unfair_lock_unlock(v4);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v15 = "tcp_listener_set_register_p2p";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "tcp_listener_set_register_p2p";
      os_log_type_t v9 = "%{public}s called with null listener";
      goto LABEL_21;
    }

    if (!v12)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "tcp_listener_set_register_p2p";
      os_log_type_t v9 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_21;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v15 = "tcp_listener_set_register_p2p";
        __int16 v16 = 2082;
        BOOL v17 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_22;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "tcp_listener_set_register_p2p";
      os_log_type_t v9 = "%{public}s called with null listener, no backtrace";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

void tcp_listener_set_interface(uint64_t a1, const char *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    os_log_type_t v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 16), "interface", a2);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "tcp_listener_set_interface";
        _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s listener is already running", buf, 0xCu);
      }
    }

    os_unfair_lock_unlock(v4);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v15 = "tcp_listener_set_interface";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "tcp_listener_set_interface";
      os_log_type_t v9 = "%{public}s called with null listener";
      goto LABEL_21;
    }

    if (!v12)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "tcp_listener_set_interface";
      os_log_type_t v9 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_21;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v15 = "tcp_listener_set_interface";
        __int16 v16 = 2082;
        BOOL v17 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_22;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "tcp_listener_set_interface";
      os_log_type_t v9 = "%{public}s called with null listener, no backtrace";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

void *tcp_listener_retain(void *object)
{
  if (object) {
    return os_retain(object);
  }
  return object;
}

void tcp_listener_release(void *object)
{
  if (object) {
    os_release(object);
  }
}

void tcp_connection_retain(void *a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    os_retain(a1);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  char v10 = "tcp_connection_retain";
  uint64_t v1 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v7 = 0;
  if (__nwlog_fault(v1, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v2 = (os_log_s *)gLogObj;
      os_log_type_t v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      char v10 = "tcp_connection_retain";
      os_log_type_t v4 = "%{public}s called with null connection";
      goto LABEL_16;
    }

    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v2 = (os_log_s *)gLogObj;
      os_log_type_t v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      char v10 = "tcp_connection_retain";
      os_log_type_t v4 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_16;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)gLogObj;
    os_log_type_t v3 = type;
    BOOL v6 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v6)
      {
        *(_DWORD *)buf = 136446466;
        char v10 = "tcp_connection_retain";
        __int16 v11 = 2082;
        char v12 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_17;
    }

    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      char v10 = "tcp_connection_retain";
      os_log_type_t v4 = "%{public}s called with null connection, no backtrace";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v2, v3, v4, buf, 0xCu);
    }
  }

void tcp_connection_release(void *a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    os_release(a1);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  char v10 = "tcp_connection_release";
  uint64_t v1 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v7 = 0;
  if (__nwlog_fault(v1, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v2 = (os_log_s *)gLogObj;
      os_log_type_t v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      char v10 = "tcp_connection_release";
      os_log_type_t v4 = "%{public}s called with null connection";
      goto LABEL_16;
    }

    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v2 = (os_log_s *)gLogObj;
      os_log_type_t v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      char v10 = "tcp_connection_release";
      os_log_type_t v4 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_16;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)gLogObj;
    os_log_type_t v3 = type;
    BOOL v6 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v6)
      {
        *(_DWORD *)buf = 136446466;
        char v10 = "tcp_connection_release";
        __int16 v11 = 2082;
        char v12 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_17;
    }

    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      char v10 = "tcp_connection_release";
      os_log_type_t v4 = "%{public}s called with null connection, no backtrace";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v2, v3, v4, buf, 0xCu);
    }
  }

void sub_1820CE538( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_authentication_challenge;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

NWConcrete_nw_authentication_protection_space *nw_authentication_protection_space_create(int a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  BOOL result = objc_alloc(&OBJC_CLASS___NWConcrete_nw_authentication_protection_space);
  if (!result) {
    return result;
  }
  v13.receiver = result;
  v13.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_authentication_protection_space;
  BOOL result = (NWConcrete_nw_authentication_protection_space *)objc_msgSendSuper2(&v13, sel_init);
  if (result)
  {
    result->os_log_type_t type = a1;
    return result;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  BOOL v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s [super init] failed", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
        _os_log_impl(&dword_181A5C000, v5, v10, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void nw_authentication_protection_space_set_is_proxy(void *a1, char a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  os_log_type_t v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 28) = *((_BYTE *)v3 + 28) & 0xFE | a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_authentication_protection_space_set_is_proxy";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_set_is_proxy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_authentication_protection_space_set_is_proxy";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_set_is_proxy";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_set_is_proxy";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_authentication_protection_space_get_is_proxy(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((_BYTE *)v1 + 28) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_authentication_protection_space_get_is_proxy";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_get_is_proxy";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_authentication_protection_space_get_is_proxy";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_get_is_proxy";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_get_is_proxy";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_protection_space_set_endpoint(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 1, a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_authentication_protection_space_set_endpoint";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_set_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_authentication_protection_space_set_endpoint";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_set_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_set_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_authentication_protection_space_copy_endpoint(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[1];
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_authentication_protection_space_copy_endpoint";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_authentication_protection_space_copy_endpoint";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_authentication_protection_space_copy_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_protection_space_set_realm(void *a1, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_authentication_protection_space_set_realm";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_authentication_protection_space_set_realm";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null protection_space", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v20 = "nw_authentication_protection_space_set_realm";
            __int16 v21 = 2082;
            __int16 v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_authentication_protection_space_set_realm";
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null protection_space, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_authentication_protection_space_set_realm";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_authentication_protection_space_get_type(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[6];
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_authentication_protection_space_get_type";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_authentication_protection_space_get_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_authentication_protection_space_get_type";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_authentication_protection_space_get_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_authentication_protection_space_get_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_protection_space_set_proxy_origin_is_cleartext(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 2;
    }
    else {
      char v5 = 0;
    }
    *((_BYTE *)v3 + 28) = *((_BYTE *)v3 + 28) & 0xFD | v5;
    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
  char v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null protection_space, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null protection_space, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

NWConcrete_nw_authentication_challenge *nw_authentication_challenge_create()
{
  return objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_authentication_challenge);
}

uint64_t nw_authentication_challenge_get_type(void *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = (unint64_t *)v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_authentication_challenge_get_type";
    char v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null challenge", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (!v20)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_authentication_challenge_get_type";
        _os_log_impl( &dword_181A5C000,  v8,  v17,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v13 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v23 = "nw_authentication_challenge_get_type";
      __int16 v24 = 2082;
      nw_endpoint_t v25 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_24;
  }

  uint64_t v3 = *((void *)v1 + 3);
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_authentication_challenge_get_type";
    char v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_authentication_challenge_get_type";
        _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null challenge->protection_space_array",  buf,  0xCu);
      }

void nw_authentication_challenge_set_http_message(void *a1, const void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = (const void *)v3[2];
    if (v5)
    {
      CFRelease(v5);
      v4[2] = 0LL;
    }

    if (a2) {
      v4[2] = CFRetain(a2);
    }
    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_authentication_challenge_set_http_message";
  char v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_authentication_challenge_set_http_message";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null challenge", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_authentication_challenge_set_http_message";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_authentication_challenge_set_http_message";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_authentication_challenge_set_http_message";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1820D03D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFTypeRef nw_authentication_challenge_copy_http_message(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_authentication_challenge_copy_http_message";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_authentication_challenge_copy_http_message";
          _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
        }
      }

      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v17 = "nw_authentication_challenge_copy_http_message";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_authentication_challenge_copy_http_message";
          _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_authentication_challenge_copy_http_message";
          _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1820D0684(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_authentication_challenge_set_protection_space(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    BOOL v5 = nw_array_create();
    os_log_type_t v6 = (void *)v3[3];
    v3[3] = v5;

    v3[4] = 0LL;
    nw_array_append(v3[3], v4);
    goto LABEL_3;
  }

  __nwlog_obj();
  char v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v18 = "nw_authentication_challenge_set_protection_space";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_authentication_challenge_set_protection_space";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null challenge", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v18 = "nw_authentication_challenge_set_protection_space";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_authentication_challenge_set_protection_space";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_authentication_challenge_set_protection_space";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_authentication_challenge_copy_protection_space(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = (unint64_t *)v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 3);
    if (v3)
    {
      uint64_t v4 = nw_array_get_object_at_index(v3, v2[4]);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v22 = "nw_authentication_challenge_copy_protection_space";
    char v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v22 = "nw_authentication_challenge_copy_protection_space";
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null challenge->protection_space_array",  buf,  0xCu);
        }

void nw_authentication_challenge_set_attempt_count(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 10) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_authentication_challenge_set_attempt_count";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_attempt_count";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_authentication_challenge_set_attempt_count";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_attempt_count";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_attempt_count";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_authentication_challenge_get_attempt_count(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[10];
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_authentication_challenge_get_attempt_count";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_get_attempt_count";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_authentication_challenge_get_attempt_count";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_get_attempt_count";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_get_attempt_count";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_challenge_set_proposed_credential(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 1, a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_authentication_challenge_set_proposed_credential";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_proposed_credential";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_authentication_challenge_set_proposed_credential";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_proposed_credential";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_proposed_credential";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_authentication_challenge_get_proposed_credential(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[1];
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_authentication_challenge_get_proposed_credential";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_get_proposed_credential";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_authentication_challenge_get_proposed_credential";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_get_proposed_credential";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_get_proposed_credential";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_challenge_set_protection_space_array(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 3, a2);
    v3[4] = 0LL;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_authentication_challenge_set_protection_space_array";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_protection_space_array";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_authentication_challenge_set_protection_space_array";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_protection_space_array";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_authentication_challenge_set_protection_space_array";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_authentication_challenge_try_next_protection_space(void *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v24 = "nw_authentication_challenge_try_next_protection_space";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null challenge", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (!v21)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null challenge, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v24 = "nw_authentication_challenge_try_next_protection_space";
      __int16 v25 = 2082;
      uint64_t v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null challenge, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_26;
  }

  uint64_t v3 = v1[3];
  if (!v3)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v24 = "nw_authentication_challenge_try_next_protection_space";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null challenge->protection_space_array",  buf,  0xCu);
      }

_DWORD *nw_authentication_credential_create(int a1)
{
  return -[NWConcrete_nw_authentication_credential initWithType:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_authentication_credential),  a1);
}

void nw_authentication_credential_set_persistence(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  unint64_t v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 3) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_authentication_credential_set_persistence";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_set_persistence";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_authentication_credential_set_persistence";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_set_persistence";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_authentication_credential_set_persistence";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_credential_set_username(void *a1, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  unint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_authentication_credential_set_username";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_authentication_credential_set_username";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null credential", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_authentication_credential_set_username";
            __int16 v21 = 2082;
            __int16 v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_authentication_credential_set_username";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null credential, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_authentication_credential_set_username";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_authentication_credential_set_password(void *a1, const char *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  unint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v24 = "nw_authentication_credential_set_password";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v12, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_authentication_credential_set_password";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null credential", buf, 0xCu);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v24 = "nw_authentication_credential_set_password";
            __int16 v25 = 2082;
            uint64_t v26 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_authentication_credential_set_password";
          _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null credential, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_authentication_credential_set_password";
          _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_authentication_credential_add_valid_authentication_type(void *a1, unsigned int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  unint64_t v4 = v3;
  if (v3)
  {
    id v5 = (void *)v3[5];
    if (!v5)
    {
      xpc_object_t v6 = xpc_array_create(0LL, 0LL);
      char v7 = (void *)v4[5];
      v4[5] = v6;

      id v5 = (void *)v4[5];
    }

    xpc_array_set_uint64(v5, 0xFFFFFFFFFFFFFFFFLL, a2);
    goto LABEL_5;
  }

  __nwlog_obj();
  size_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v19 = "nw_authentication_credential_add_valid_authentication_type";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v19 = "nw_authentication_credential_add_valid_authentication_type";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null credential", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v19 = "nw_authentication_credential_add_valid_authentication_type";
          __int16 v20 = 2082;
          char v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v19 = "nw_authentication_credential_add_valid_authentication_type";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v19 = "nw_authentication_credential_add_valid_authentication_type";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1820D2EAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_authentication_credential_add_to_tlv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(_BYTE *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))++ = xpc_uint64_get_value(v4);

  return 1LL;
}

void sub_1820D2F10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_authentication_credential_is_equal(void *a1, void *a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a2;
  id v5 = (void *)v4;
  if (!(v3 | v4))
  {
    BOOL v6 = 1LL;
    goto LABEL_29;
  }

  BOOL v6 = 0LL;
  if (v3 && v4)
  {
    int v7 = *(_DWORD *)(v3 + 8);
    if (v7 != *(_DWORD *)(v4 + 8) || *(_DWORD *)(v3 + 12) != *(_DWORD *)(v4 + 12)) {
      goto LABEL_28;
    }
    if (v7 == 1)
    {
      size_t v8 = *(const char **)(v3 + 16);
      os_log_type_t v9 = (const char *)v5[2];
      if (v8 != v9 && v8 && v9)
      {
        if (strcmp(v8, v9)) {
          goto LABEL_28;
        }
      }

      else if (v8 != v9)
      {
        goto LABEL_28;
      }

      os_log_type_t v10 = *(const char **)(v3 + 24);
      os_log_type_t v11 = (const char *)v5[3];
      if (v10 != v11 && v10 && v11)
      {
        if (strcmp(v10, v11)) {
          goto LABEL_28;
        }
      }

      else if (v10 != v11)
      {
        goto LABEL_28;
      }
    }

    uint64_t v12 = v5[4];
    if (*(void *)(v3 + 32))
    {
      if (v12) {
        goto LABEL_22;
      }
    }

    else if (!v12)
    {
LABEL_22:
      os_log_type_t v13 = (void *)v5[5];
      id v14 = *(id *)(v3 + 40);
      id v15 = v13;
      char v16 = v15;
      BOOL v6 = v14 == v15;
      if (v14 != v15 && v14 && v15) {
        BOOL v6 = xpc_equal(v14, v15);
      }

      goto LABEL_29;
    }

void sub_1820D3064(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_authentication_credential_iterate_valid_authentication_types(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  unint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    int v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_authentication_credential_iterate_valid_authentication_types";
    size_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_authentication_credential_iterate_valid_authentication_types";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null credential", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_authentication_credential_iterate_valid_authentication_types";
          __int16 v27 = 2082;
          unsigned int v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_40:
        free(v8);
        goto LABEL_5;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_authentication_credential_iterate_valid_authentication_types";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_authentication_credential_iterate_valid_authentication_types";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1820D357C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_authentication_credential_iterate_valid_authentication_types_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  xpc_uint64_get_value(v4);
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();

  return v5;
}

void sub_1820D35E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_authentication_credential_get_username(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 2);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_authentication_credential_get_username";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_get_username";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_authentication_credential_get_username";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_get_username";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_get_username";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_authentication_credential_get_password(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 3);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_authentication_credential_get_password";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_get_password";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_authentication_credential_get_password";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_get_password";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_get_password";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_authentication_credential_set_identity(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 4, a2);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_authentication_credential_set_identity";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_set_identity";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_authentication_credential_set_identity";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_set_identity";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_authentication_credential_set_identity";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_proxy_options_authbroker_is_available_block_invoke()
{
  uint64_t result = bootstrap_look_up(*MEMORY[0x1895F9630], "com.apple.cfnetwork.AuthBrokerAgent", &sp);
  if ((_DWORD)result) {
    BOOL v1 = 1;
  }
  else {
    BOOL v1 = sp == 0;
  }
  if (!v1)
  {
    nw_proxy_options_authbroker_is_available::available = 1;
    return mach_port_deallocate(*MEMORY[0x1895FBBE0], sp);
  }

  return result;
}

BOOL __nw_proxy_copy_http_connect_definition_block_invoke()
{
  if (nw_protocol_http_connect_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http_connect_identifier::onceToken, &__block_literal_global_35370);
  }
  id v0 = nw_protocol_definition_create_with_identifier(&g_http_connect_protocol_identifier);
  BOOL v1 = (void *)nw_proxy_copy_http_connect_definition::proxy_definition;
  nw_proxy_copy_http_connect_definition::proxy_definition = (uint64_t)v0;

  nw_protocol_definition_set_options_allocator( (void *)nw_proxy_copy_http_connect_definition::proxy_definition,  (uint64_t)nw_proxy_allocate_options,  (uint64_t)nw_proxy_copy_options,  (uint64_t)nw_proxy_deallocate_options);
  nw_protocol_definition_set_options_equality_check( (void *)nw_proxy_copy_http_connect_definition::proxy_definition,  (uint64_t)nw_proxy_option_is_equal);
  return nw_protocol_register_handle( (uint64_t)&g_http_connect_protocol_identifier,  (void *)nw_proxy_copy_http_connect_definition::proxy_definition,  (uint64_t)nw_protocol_http_connect_create,  0LL);
}

BOOL nw_proxy_allocate_options(void *a1)
{
  id v1 = a1;
  uint64_t v2 = calloc(1uLL, 0x10uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  uint64_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_1820D3FE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_proxy_copy_options(void *a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_proxy_copy_options";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v11, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "nw_proxy_copy_options";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v25 = "nw_proxy_copy_options";
            __int16 v26 = 2082;
            uint64_t v27 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "nw_proxy_copy_options";
          _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s called with null existing_handle, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "nw_proxy_copy_options";
          _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1820D440C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_deallocate_options(uint64_t a1, void **a2)
{
  id v3 = *a2;
  *a2 = 0LL;

  id v4 = a2[1];
  if (v4) {
    free(v4);
  }
  free(a2);
}

BOOL nw_proxy_option_is_equal(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

void *nw_proxy_options_copy_authentication_challenge_handler(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0LL;
  BOOL v6 = &v5;
  uint64_t v7 = 0x3032000000LL;
  os_log_type_t v8 = __Block_byref_object_copy__35346;
  os_log_type_t v9 = __Block_byref_object_dispose__35347;
  id v10 = 0LL;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_proxy_options_copy_authentication_challenge_handler_block_invoke;
  v4[3] = &unk_189BC60A8;
  v4[4] = &v5;
  nw_protocol_options_access_handle(v1, v4);
  uint64_t v2 = _Block_copy((const void *)v6[5]);
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1820D4528( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__35346(uint64_t a1, uint64_t a2)
{
  BOOL result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__35347(uint64_t a1)
{
}

uint64_t __nw_proxy_options_copy_authentication_challenge_handler_block_invoke(uint64_t a1, const void **a2)
{
  id v3 = _Block_copy(*a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return 1LL;
}

void nw_proxy_options_set_http_proxy_authorization_header(void *a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_proxy_options_set_http_proxy_authorization_header_block_invoke;
    v13[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v13[4] = a2;
    nw_protocol_options_access_handle(v3, v13);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_proxy_options_set_http_proxy_authorization_header";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v6, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_proxy_options_set_http_proxy_authorization_header";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_proxy_options_set_http_proxy_authorization_header";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_proxy_options_set_http_proxy_authorization_header";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_proxy_options_set_http_proxy_authorization_header";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1820D487C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_proxy_options_set_http_proxy_authorization_header_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 8);
  if (v4)
  {
    free(v4);
    *(void *)(a2 + 8) = 0LL;
  }

  uint64_t v5 = *(const char **)(a1 + 32);
  if (!v5) {
    return 1LL;
  }
  BOOL v6 = strdup(v5);
  if (v6)
  {
LABEL_5:
    *(void *)(a2 + 8) = v6;
    return 1LL;
  }

  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  os_log_type_t v9 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v9);
  if (!result)
  {
    free(v9);
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

uint64_t __nw_proxy_options_get_http_proxy_authorization_header_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 8);
  return 1LL;
}

void *nw_proxy_copy_shoes_definition()
{
  BOOL result = (void *)nw_protocol_shoes_get_definition(void)::proxy_definition;
  return result;
}

void *nw_protocol_http_connect_create()
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v2 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v6 = "nw_protocol_http_connect_create";
      _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  id v0 = calloc(1uLL, 0x178uLL);
  if (v0) {
    goto LABEL_3;
  }
  id v3 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  BOOL v6 = "strict_calloc";
  __int16 v7 = 2048;
  uint64_t v8 = 1LL;
  __int16 v9 = 2048;
  uint64_t v10 = 376LL;
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = (void *)__nwlog_abort((uint64_t)v4);
  if (!(_DWORD)result)
  {
    free(v4);
LABEL_3:
    v0[5] = &g_http_connect_protocol_identifier;
    v0[6] = &g_http_connect_protocol_callbacks;
    v0[8] = v0;
    return v0 + 3;
  }

  __break(1u);
  return result;
}

double __nw_protocol_http_connect_identifier_block_invoke()
{
  unk_18C45F0CD = 0LL;
  unk_18C45F0C5 = 0LL;
  dword_18C45F0D4 = 0;
  strcpy((char *)&g_http_connect_protocol_identifier, "http_connect");
  *(void *)&double result = 0x100000004LL;
  qword_18C45F0D8 = 0x100000004LL;
  qword_18C45F060 = (uint64_t)nw_protocol_default_output_finished;
  unk_18C45F068 = nw_protocol_default_get_output_local;
  qword_18C45EFB0 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_18C45EFB8 = nw_protocol_default_connect;
  qword_18C45F0A0 = (uint64_t)nw_protocol_default_reset;
  unk_18C45F0A8 = nw_protocol_default_input_flush;
  qword_18C45F070 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C45F078 = nw_protocol_default_waiting_for_output;
  qword_18C45F030 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C45F038 = nw_protocol_default_unregister_notification;
  qword_18C45F040 = (uint64_t)nw_protocol_default_notify;
  unk_18C45F048 = nw_protocol_default_updated_path;
  qword_18C45F090 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_18C45F098 = nw_protocol_default_get_message_properties;
  g_http_connect_protocol_callbacks = (uint64_t)nw_protocol_http_connect_add_input_handler;
  *(void *)algn_18C45EFA8 = nw_protocol_http_connect_remove_input_handler;
  qword_18C45EFE0 = (uint64_t)nw_protocol_http_connect_input_available;
  unk_18C45EFE8 = nw_protocol_default_output_available;
  qword_18C45F050 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_18C45F058 = nw_protocol_http_connect_input_finished;
  qword_18C45EFF0 = (uint64_t)nw_protocol_http_connect_get_input_frames;
  unk_18C45EFF8 = nw_protocol_http_connect_get_output_frames;
  qword_18C45F000 = (uint64_t)nw_protocol_http_connect_finalize_output_frames;
  unk_18C45F008 = nw_protocol_default_link_state;
  qword_18C45EFC0 = (uint64_t)nw_protocol_default_disconnect;
  unk_18C45EFC8 = nw_protocol_http_connect_connected;
  qword_18C45EFD0 = (uint64_t)nw_protocol_http_connect_disconnected;
  unk_18C45EFD8 = nw_protocol_http_connect_error;
  qword_18C45F080 = (uint64_t)nw_protocol_http_connect_copy_info;
  unk_18C45F088 = nw_protocol_default_add_listen_handler;
  qword_18C45F010 = (uint64_t)nw_protocol_http_connect_get_parameters;
  unk_18C45F018 = nw_protocol_http_connect_get_path;
  qword_18C45F020 = (uint64_t)nw_protocol_http_connect_get_local_endpoint;
  unk_18C45F028 = nw_protocol_http_connect_get_remote_endpoint;
  return result;
}

uint64_t nw_protocol_http_connect_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v115 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    int v88 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
      _os_log_impl(&dword_181A5C000, v88, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
    uint64_t v89 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v111 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v111)
      {
        os_log_type_t v90 = (os_log_s *)__nwlog_obj();
        os_log_type_t v91 = type[0];
        if (!os_log_type_enabled(v90, type[0])) {
          goto LABEL_207;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
        uint64_t v92 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_206;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v94 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (!v94) {
          goto LABEL_207;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
        uint64_t v92 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_206;
      }

      if (v94)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        int v95 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_196:
        _os_log_impl(&dword_181A5C000, v90, v91, v95, buf, 0x16u);
      }

void sub_1820D66C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_http_connect_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        unint64_t v13 = (os_log_s *)__nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
        int v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_46;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v17) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
        int v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_46;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_remove_input_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
        _os_log_impl(&dword_181A5C000, v13, v14, v18, buf, 0x16u);
      }

void nw_protocol_http_connect_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v176 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v92 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      _os_log_impl(&dword_181A5C000, v92, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v93 = (os_log_s *)__nwlog_obj();
      os_log_type_t v94 = type[0];
      if (!os_log_type_enabled(v93, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      uint64_t v11 = "%{public}s called with null protocol";
    }

    else if (v174[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v93 = (os_log_s *)__nwlog_obj();
      os_log_type_t v94 = type[0];
      BOOL v98 = os_log_type_enabled(v93, type[0]);
      if (backtrace_string)
      {
        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v93,  v94,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_225;
      }

      if (!v98) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      uint64_t v11 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v93 = (os_log_s *)__nwlog_obj();
      os_log_type_t v94 = type[0];
      if (!os_log_type_enabled(v93, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_278;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v93 = (os_log_s *)__nwlog_obj();
      os_log_type_t v94 = type[0];
      if (!os_log_type_enabled(v93, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      uint64_t v11 = "%{public}s called with null http_connect";
      goto LABEL_278;
    }

    if (!v174[0])
    {
      uint64_t v93 = (os_log_s *)__nwlog_obj();
      os_log_type_t v94 = type[0];
      if (!os_log_type_enabled(v93, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      uint64_t v11 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_278;
    }

    __int16 v28 = (char *)__nw_create_backtrace_string();
    uint64_t v93 = (os_log_s *)__nwlog_obj();
    os_log_type_t v94 = type[0];
    BOOL v99 = os_log_type_enabled(v93, type[0]);
    if (!v28)
    {
      if (!v99) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      uint64_t v11 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_278;
    }

    if (!v99) {
      goto LABEL_100;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v28;
    uint64_t v30 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_256:
    BOOL v40 = v93;
    os_log_type_t v41 = v94;
    uint32_t v42 = 22;
    goto LABEL_99;
  }

  uint64_t default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v174[0])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)gLogObj;
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        uint64_t v11 = "%{public}s %{public}s%sNo input handler, backtrace limit exceeded";
        goto LABEL_223;
      }

      __int16 v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type[0];
      BOOL v29 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!v28)
      {
        if (!v29) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        uint64_t v11 = "%{public}s %{public}s%sNo input handler, no backtrace";
        goto LABEL_223;
      }

      if (!v29) {
        goto LABEL_100;
      }
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      LOWORD(v173) = 2082;
      *(void *)((char *)&v173 + 2) = v28;
      uint64_t v30 = "%{public}s %{public}s%sNo input handler, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
      goto LABEL_225;
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    uint64_t v11 = "%{public}s %{public}s%sNo input handler";
LABEL_223:
    uint64_t v89 = v9;
    os_log_type_t v90 = v10;
    uint32_t v91 = 32;
LABEL_224:
    _os_log_impl(&dword_181A5C000, v89, v90, v11, buf, v91);
    goto LABEL_225;
  }

  callbacks = default_input_handler->callbacks;
  if (!callbacks || (input_available = (void (*)(void))callbacks->input_available) == 0LL)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0) {
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type[0];
      if (!os_log_type_enabled(v9, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      uint64_t v11 = "%{public}s %{public}s%sinput_handler callback invalid: input_available";
      goto LABEL_223;
    }

    if (v174[0])
    {
      __int16 v28 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type[0];
      BOOL v96 = os_log_type_enabled(v9, type[0]);
      if (v28)
      {
        if (v96)
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v172 = " ";
          LOWORD(v173) = 2082;
          *(void *)((char *)&v173 + 2) = v28;
          uint64_t v30 = "%{public}s %{public}s%sinput_handler callback invalid: input_available, dumping backtrace:%{public}s";
          goto LABEL_98;
        }

        goto LABEL_100;
      }

      if (!v96) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      uint64_t v11 = "%{public}s %{public}s%sinput_handler callback invalid: input_available, no backtrace";
    }

    else
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type[0];
      if (!os_log_type_enabled(v9, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      uint64_t v11 = "%{public}s %{public}s%sinput_handler callback invalid: input_available, backtrace limit exceeded";
    }

    goto LABEL_223;
  }

  int v7 = *((_DWORD *)handle + 70);
  if (v7 == 3)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v174[0])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)gLogObj;
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        uint64_t v11 = "%{public}s %{public}s%sState is failed, backtrace limit exceeded";
        goto LABEL_223;
      }

      __int16 v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type[0];
      BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!v28)
      {
        if (!v31) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        uint64_t v11 = "%{public}s %{public}s%sState is failed, no backtrace";
        goto LABEL_223;
      }

      if (!v31) {
        goto LABEL_100;
      }
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      LOWORD(v173) = 2082;
      *(void *)((char *)&v173 + 2) = v28;
      uint64_t v30 = "%{public}s %{public}s%sState is failed, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
      goto LABEL_225;
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    uint64_t v11 = "%{public}s %{public}s%sState is failed";
    goto LABEL_223;
  }

  if (v7 == 2)
  {
    input_available();
    return;
  }

  output_handler = a1->output_handler;
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v100 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNot yet connected, reading input for http connect",  buf,  0x20u);
      }
    }
  }

  if (!output_handler)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      uint64_t v11 = "%{public}s %{public}s%sNo output handler";
      goto LABEL_223;
    }

    if (!v174[0])
    {
      uint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type[0];
      if (!os_log_type_enabled(v9, type[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      uint64_t v11 = "%{public}s %{public}s%sNo output handler, backtrace limit exceeded";
      goto LABEL_223;
    }

    __int16 v28 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type[0];
    BOOL v38 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!v28)
    {
      if (!v38) {
        goto LABEL_225;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v172 = " ";
      uint64_t v11 = "%{public}s %{public}s%sNo output handler, no backtrace";
      goto LABEL_223;
    }

    if (!v38) {
      goto LABEL_100;
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    LOWORD(v173) = 2082;
    *(void *)((char *)&v173 + 2) = v28;
    uint64_t v30 = "%{public}s %{public}s%sNo output handler, dumping backtrace:%{public}s";
LABEL_98:
    BOOL v40 = v9;
    os_log_type_t v41 = v10;
    uint32_t v42 = 42;
LABEL_99:
    _os_log_impl(&dword_181A5C000, v40, v41, v30, buf, v42);
    goto LABEL_100;
  }

  uint64_t v163 = 0LL;
  int v164 = &v163;
  int v162 = handle;
  if (((unsigned int (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, uint64_t *))output_handler->callbacks->get_input_frames)( output_handler,  a1,  1LL,  0xFFFFFFFFLL,  0xFFFFFFFFLL,  &v163))
  {
    int v13 = 0;
    int v14 = 0;
    uint64_t v161 = handle + 284;
    BOOL v159 = output_handler;
    int v160 = a1;
    while (1)
    {
      uint64_t v15 = v163;
      if (v163) {
        break;
      }
LABEL_25:
      if (!((unsigned int (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, uint64_t *))v159->callbacks->get_input_frames)( v159,  v160,  1LL,  0xFFFFFFFFLL,  0xFFFFFFFFLL,  &v163)) {
        goto LABEL_64;
      }
    }

    while (1)
    {
      uint64_t v18 = (void *)(v15 + 32);
      uint64_t v17 = *(void *)(v15 + 32);
      if (v17 || *(void *)(v15 + 40))
      {
        if (!*(void *)(v15 + 112)) {
          goto LABEL_41;
        }
      }

      else
      {
        uint64_t v17 = 0LL;
        if (!*(void *)(v15 + 112)) {
          goto LABEL_41;
        }
      }

      if ((*(_WORD *)(v15 + 204) & 0x100) != 0
        && g_channel_check_validity
        && !g_channel_check_validity(v15, *(void *)(v15 + 88)))
      {
LABEL_41:
        int v24 = 0;
        uint64_t v22 = 0LL;
        goto LABEL_42;
      }

      int v19 = *(_DWORD *)(v15 + 52);
      if (v19)
      {
        uint64_t v20 = *(unsigned int *)(v15 + 56);
        int v21 = v20 + *(_DWORD *)(v15 + 60);
        uint64_t v22 = *(void *)(v15 + 112) + v20;
        __int16 v23 = *((_WORD *)handle + 184);
        int v24 = v19 - v21;
        if (v19 != v21)
        {
          v23 |= 4u;
          *((_WORD *)handle + 184) = v23;
        }

        goto LABEL_43;
      }

      int v24 = 0;
      uint64_t v22 = *(void *)(v15 + 112) + *(unsigned int *)(v15 + 56);
LABEL_42:
      __int16 v23 = *((_WORD *)handle + 184);
LABEL_43:
      if ((v23 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v25 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v161;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v172 = " ";
          LOWORD(v173) = 1024;
          *(_DWORD *)((char *)&v173 + 2) = v24;
          WORD3(v173) = 2048;
          *((void *)&v173 + 1) = v22;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRead frame has %u bytes (%p)",  buf,  0x30u);
        }
      }

      uint64_t v26 = *(void *)(v15 + 32);
      uint64_t v27 = *(void **)(v15 + 40);
      if (v26)
      {
        *(void *)(v26 + 40) = v27;
        uint64_t v27 = *(void **)(v15 + 40);
      }

      else
      {
        int v164 = *(uint64_t **)(v15 + 40);
      }

      handle = v162;
      v13 += v24;
      void *v27 = v26;
      void *v18 = 0LL;
      *(void *)(v15 + 40) = 0LL;
      int v16 = (void *)*((void *)v162 + 29);
      *(void *)(v15 + 40) = v16;
      *int v16 = v15;
      *((void *)v162 + 29) = v18;
      ++v14;
      uint64_t v15 = v17;
      if (!v17) {
        goto LABEL_25;
      }
    }
  }

  int v14 = 0;
  int v13 = 0;
LABEL_64:
  int v32 = &qword_18C45F000;
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v101 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sGot 0 input frames, done reading",  buf,  0x20u);
      }
    }
  }

  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v102 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        LOWORD(v173) = 1024;
        *(_DWORD *)((char *)&v173 + 2) = v14;
        WORD3(v173) = 1024;
        DWORD2(v173) = v13;
        _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRead %u frames (%u bytes)",  buf,  0x2Cu);
      }
    }
  }

  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      BOOL v103 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        _os_log_impl(&dword_181A5C000, v103, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
  }

  if (*((_DWORD *)handle + 70) == 2)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v172 = " ";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v174[0] = 0;
    if (__nwlog_fault(v8, type, v174))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)gLogObj;
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        uint64_t v11 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected";
        goto LABEL_223;
      }

      if (!v174[0])
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        uint64_t v11 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected, backtrace limit exceeded";
        goto LABEL_223;
      }

      __int16 v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type[0];
      BOOL v39 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!v28)
      {
        if (!v39) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        uint64_t v11 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected, no backtrace";
        goto LABEL_223;
      }

      if (v39)
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v172 = " ";
        LOWORD(v173) = 2082;
        *(void *)((char *)&v173 + 2) = v28;
        uint64_t v30 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected, dumping backtrace:%{public}s";
        goto LABEL_98;
      }

LABEL_349:
            if (v119) {
              free(v119);
            }
            handle = v162;
            uint64_t v67 = *((void *)v162 + 9);
            if (!v67) {
              goto LABEL_352;
            }
            goto LABEL_178;
          }

          if ((*((_WORD *)handle + 184) & 0x80) == 0)
          {
            id v83 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              uint64_t v172 = " ";
              LOWORD(v173) = 2114;
              *(void *)((char *)&v173 + 2) = v57;
              _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%shttp connect Proxy received status: %{public}@",  buf,  0x2Au);
            }
          }

          _CFHTTPAuthenticationApplyProxyAuthorizationToRequest();
          uint64_t v84 = *((void *)handle + 21);
          if (!v84 || *(_DWORD *)(v84 + 124) != 4)
          {
            CFDictionaryRef v85 = CFHTTPMessageCopyAllHeaderFields(*((CFHTTPMessageRef *)handle + 25));
            if ((*((_WORD *)handle + 184) & 0x80) == 0)
            {
              uint64_t v86 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v86, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v172 = " ";
                LOWORD(v173) = 2114;
                *(void *)((char *)&v173 + 2) = v85;
                _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sHeaders:\n%{public}@",  buf,  0x2Au);
              }
            }

            if (v85) {
              CFRelease(v85);
            }
          }

          uint64_t v87 = (uint64_t)handle;
          int v88 = 57;
          goto LABEL_213;
        }

        __int16 v71 = *((_WORD *)handle + 184);
        *((_WORD *)handle + 184) = v71 & 0xFFF7;
        uint64_t v72 = *((void *)handle + 21);
        if ((!v72 || *(_DWORD *)(v72 + 124) != 4) && (v71 & 0x80) == 0)
        {
          __int16 v73 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v172 = " ";
            _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect proxy authentication required",  buf,  0x20u);
          }
        }

        if (*((void *)handle + 22) && !*((_DWORD *)handle + 67))
        {
          if (*((_DWORD *)handle + 68))
          {
            if ((*((_WORD *)handle + 184) & 0x80) == 0)
            {
              int v95 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v172 = " ";
                _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sProxy credential was rejected, cancelling connection",  buf,  0x20u);
              }
            }

            uint64_t v87 = (uint64_t)handle;
            int v88 = 80;
LABEL_213:
            nw_http_connect_fail(v87, v88);
            goto LABEL_296;
          }
        }

        else
        {
          __int128 v74 = (void *)*((void *)handle + 23);
          if (v74)
          {
            id v75 = nw_proxy_options_copy_authentication_challenge_handler(v74);
            if (v75)
            {
              __int128 v76 = (void (**)(void, void, void))v75;
              __int128 v77 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)handle + 25), @"Proxy-Authenticate");
              if (v77)
              {
                __int128 v78 = v77;
                CFIndex Length = CFStringGetLength(v77);
                if (Length < CFStringGetLength(@"NTLM")
                  || (v177.length = CFStringGetLength(@"NTLM"),
                      v177.location = 0LL,
                      CFStringCompareWithOptions(v78, @"NTLM", v177, 1uLL)))
                {
                  CFIndex v80 = CFStringGetLength(v78);
                  if (v80 < CFStringGetLength(@"Basic")
                    || (v178.length = CFStringGetLength(@"Basic"),
                        int v81 = 1,
                        v178.location = 0LL,
                        CFStringCompareWithOptions(v78, @"Basic", v178, 1uLL)))
                  {
                    CFIndex v82 = CFStringGetLength(v78);
                    if (v82 < CFStringGetLength(@"Digest")
                      || (v179.length = CFStringGetLength(@"Digest"),
                          v179.location = 0LL,
                          CFStringCompareWithOptions(v78, @"Digest", v179, 1uLL)))
                    {
                      int v81 = 0;
                    }

                    else
                    {
                      int v81 = 2;
                    }
                  }
                }

                else
                {
                  int v81 = 5;
                }

                os_log_type_t v104 = nw_authentication_protection_space_create(v81);
                CFRelease(v78);
                if (v104)
                {
                  nw_authentication_protection_space_set_is_proxy(v104, 1);
                  BOOL v105 = nw_endpoint_create_with_cfurl(*((const __CFURL **)handle + 27));
                  nw_authentication_protection_space_set_endpoint(v104, (void *)v105);
                  nw_authentication_protection_space_set_proxy_origin_is_cleartext(v104, 0);
                  uint64_t v106 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_authentication_challenge);
                  nw_authentication_challenge_set_protection_space(v106, v104);
                  nw_authentication_challenge_set_http_message(v106, *((const void **)handle + 25));
                  nw_authentication_challenge_set_attempt_count(v106, *((_DWORD *)handle + 67));
                  os_release(v104);
                  ++*((_DWORD *)handle + 67);
                  nw_http_connect_start_async((uint64_t)handle);
                  if ((*((_WORD *)handle + 184) & 0x80) == 0)
                  {
                    uint64_t v107 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v107, OS_LOG_TYPE_INFO))
                    {
                      *(_DWORD *)uint64_t v174 = 136446722;
                      *(void *)&v174[4] = "nw_http_connect_send_auth_challenge";
                      *(_WORD *)&v174[12] = 2082;
                      *(void *)&v174[14] = handle + 284;
                      *(_WORD *)&v174[22] = 2080;
                      uint64_t v175 = " ";
                      _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect calling out to challenge handler",  v174,  0x20u);
                    }
                  }

                  *(void *)uint64_t v174 = 0LL;
                  *(void *)&v174[8] = v174;
                  *(void *)&v174[16] = 0x2000000000LL;
                  os_log_type_t v108 = (void *)*((void *)handle + 21);
                  if (v108) {
                    os_log_type_t v108 = os_retain(v108);
                  }
                  uint64_t v175 = (const char *)v108;
                  *(void *)buf = v48;
                  *(void *)&buf[8] = 0x40000000LL;
                  *(void *)&buf[16] = ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke;
                  uint64_t v172 = (const char *)&unk_189BBCB00;
                  *(void *)&__int128 v173 = v174;
                  *((void *)&v173 + 1) = handle;
                  ((void (**)(void, NWConcrete_nw_authentication_challenge *, _BYTE *))v76)[2]( v76,  v106,  buf);
                  _Block_release(v76);
                  if (v106) {
                    os_release(v106);
                  }
                  _Block_object_dispose(v174, 8);
                  if (v105) {
                    os_release((void *)v105);
                  }
                  goto LABEL_296;
                }
              }

              uint64_t v109 = *((void *)handle + 21);
              if ((!v109 || *(_DWORD *)(v109 + 124) != 4) && (*((_WORD *)handle + 184) & 0x80) == 0)
              {
                __int16 v110 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v110, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)uint64_t v174 = 136446722;
                  *(void *)&v174[4] = "nw_http_connect_send_auth_challenge";
                  *(_WORD *)&v174[12] = 2082;
                  *(void *)&v174[14] = handle + 284;
                  *(_WORD *)&v174[22] = 2080;
                  uint64_t v175 = " ";
                  _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sCould not create challenge for HTTP Connect Proxy authentication",  v174,  0x20u);
                }
              }
            }
          }
        }

        nw_http_connect_send_auth_request((uint64_t)handle);
LABEL_296:
        if (v57) {
          CFRelease(v57);
        }
        return;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
      uint64_t v8 = (char *)_os_log_send_and_compose_impl();
      v174[0] = 16;
      char v170 = 0;
      if (v174[0] == 17)
      {
        uint64_t v93 = (os_log_s *)__nwlog_obj();
        os_log_type_t v94 = v174[0];
        if (!os_log_type_enabled(v93, (os_log_type_t)v174[0])) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
        uint64_t v11 = "%{public}s called with null http_connect->response_message";
        goto LABEL_278;
      }

      if (v170)
      {
        __int16 v28 = (char *)__nw_create_backtrace_string();
        uint64_t v93 = (os_log_s *)__nwlog_obj();
        os_log_type_t v94 = v174[0];
        BOOL v126 = os_log_type_enabled(v93, (os_log_type_t)v174[0]);
        if (v28)
        {
          if (!v126) {
            goto LABEL_100;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v28;
          uint64_t v30 = "%{public}s called with null http_connect->response_message, dumping backtrace:%{public}s";
          goto LABEL_256;
        }

        if (!v126) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
        uint64_t v11 = "%{public}s called with null http_connect->response_message, no backtrace";
      }

      else
      {
        uint64_t v93 = (os_log_s *)__nwlog_obj();
        os_log_type_t v94 = v174[0];
        if (!os_log_type_enabled(v93, (os_log_type_t)v174[0])) {
          goto LABEL_225;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
        uint64_t v11 = "%{public}s called with null http_connect->response_message, backtrace limit exceeded";
      }
          }

      if (v250) {
        free(v250);
      }
      uint64_t v204 = 0;
      uint64_t v11 = v286;
      uint64_t v137 = v281;
      if (v199 != &nw_protocol_ref_counted_handle)
      {
LABEL_221:
        if (handle == &nw_protocol_ref_counted_handle)
        {
          nw::release_if_needed<nw_protocol *>((uint64_t *)&v307);
          if ((v204 & 1) != 0) {
            goto LABEL_223;
          }
        }

        else if ((v204 & 1) != 0)
        {
          goto LABEL_223;
        }

void nw_protocol_http_connect_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v87 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    BOOL v31 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      CFIndex v82 = "nw_protocol_http_connect_input_finished";
      _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    CFIndex v82 = "nw_protocol_http_connect_input_finished";
    int v32 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_120;
      }
      *(_DWORD *)buf = 136446210;
      CFIndex v82 = "nw_protocol_http_connect_input_finished";
      BOOL v35 = "%{public}s called with null protocol";
    }

    else if (v79)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      BOOL v42 = os_log_type_enabled(v33, type);
      if (backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          CFIndex v82 = "nw_protocol_http_connect_input_finished";
          __int16 v83 = 2082;
          uint64_t v84 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_120:
        if (!v32) {
          return;
        }
        goto LABEL_121;
      }

      if (!v42) {
        goto LABEL_120;
      }
      *(_DWORD *)buf = 136446210;
      CFIndex v82 = "nw_protocol_http_connect_input_finished";
      BOOL v35 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      __int16 v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_120;
      }
      *(_DWORD *)buf = 136446210;
      CFIndex v82 = "nw_protocol_http_connect_input_finished";
      BOOL v35 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_119;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    CFIndex v82 = "nw_protocol_http_connect_input_finished";
    int v32 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        __int16 v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v34 = type;
        if (!os_log_type_enabled(v33, type)) {
          goto LABEL_120;
        }
        *(_DWORD *)buf = 136446210;
        CFIndex v82 = "nw_protocol_http_connect_input_finished";
        BOOL v35 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_119;
      }

      BOOL v43 = (char *)__nw_create_backtrace_string();
      __int16 v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      BOOL v44 = os_log_type_enabled(v33, type);
      if (!v43)
      {
        if (!v44) {
          goto LABEL_120;
        }
        *(_DWORD *)buf = 136446210;
        CFIndex v82 = "nw_protocol_http_connect_input_finished";
        BOOL v35 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_119;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        CFIndex v82 = "nw_protocol_http_connect_input_finished";
        __int16 v83 = 2082;
        uint64_t v84 = v43;
        __int16 v45 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_181A5C000, v33, v34, v45, buf, 0x16u);
      }

uint64_t nw_protocol_http_connect_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    __int16 v28 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_get_input_frames";
      _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_get_input_frames";
    BOOL v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v39)
      {
        uint64_t v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_get_input_frames";
        int v32 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_78;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v34 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v34) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_get_input_frames";
        int v32 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_78;
      }

      if (v34)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        BOOL v35 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_66:
        _os_log_impl(&dword_181A5C000, v30, v31, v35, buf, 0x16u);
      }

uint64_t nw_protocol_http_connect_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    unsigned int v12 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      int v24 = "nw_protocol_http_connect_get_output_frames";
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v24 = "nw_protocol_http_connect_get_output_frames";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_43;
        }
        *(_DWORD *)buf = 136446210;
        int v24 = "nw_protocol_http_connect_get_output_frames";
        uint64_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_42;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (!v18) {
          goto LABEL_43;
        }
        *(_DWORD *)buf = 136446210;
        int v24 = "nw_protocol_http_connect_get_output_frames";
        uint64_t v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_42;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        int v24 = "nw_protocol_http_connect_get_output_frames";
        __int16 v25 = 2082;
        os_log_type_t v26 = backtrace_string;
        int v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      }

uint64_t nw_protocol_http_connect_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    os_log_type_t v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_connect_finalize_output_frames";
      _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v33 = "nw_protocol_http_connect_finalize_output_frames";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_connect_finalize_output_frames";
      unsigned int v12 = "%{public}s called with null protocol";
      goto LABEL_71;
    }

    if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v28 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (!v28) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v33 = "nw_protocol_http_connect_finalize_output_frames";
        __int16 v34 = 2082;
        BOOL v35 = backtrace_string;
        os_log_type_t v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_58;
      }

      if (!v28) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_connect_finalize_output_frames";
      unsigned int v12 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "nw_protocol_http_connect_finalize_output_frames";
      unsigned int v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_http_connect_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v125 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v58 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v117 = "nw_protocol_http_connect_connected";
      _os_log_impl(&dword_181A5C000, v58, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v117 = "nw_protocol_http_connect_connected";
    os_log_type_t v31 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (uu == 17)
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v117 = "nw_protocol_http_connect_connected";
      __int16 v34 = "%{public}s called with null protocol";
      goto LABEL_177;
    }

    if (!(_BYTE)v112)
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v117 = "nw_protocol_http_connect_connected";
      __int16 v34 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_177;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v59 = (os_log_s *)__nwlog_obj();
    os_log_type_t v60 = uu;
    BOOL v67 = os_log_type_enabled(v59, (os_log_type_t)uu);
    if (!backtrace_string)
    {
      if (!v67) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v117 = "nw_protocol_http_connect_connected";
      __int16 v34 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_177;
    }

    if (v67)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v117 = "nw_protocol_http_connect_connected";
      __int16 v118 = 2082;
      uint64_t v119 = backtrace_string;
      uint64_t v68 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_129:
      _os_log_impl(&dword_181A5C000, v59, v60, v68, buf, 0x16u);
    }

void nw_protocol_http_connect_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v88 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    BOOL v37 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v83 = "nw_protocol_http_connect_disconnected";
      _os_log_impl(&dword_181A5C000, v37, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v83 = "nw_protocol_http_connect_disconnected";
    __int16 v38 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v83 = "nw_protocol_http_connect_disconnected";
      uint32_t v41 = "%{public}s called with null protocol";
    }

    else if (v80)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = type;
      BOOL v48 = os_log_type_enabled(v39, type);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v83 = "nw_protocol_http_connect_disconnected";
          __int16 v84 = 2082;
          __int16 v85 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_132:
        if (!v38) {
          return;
        }
        goto LABEL_133;
      }

      if (!v48) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v83 = "nw_protocol_http_connect_disconnected";
      uint32_t v41 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      char v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v83 = "nw_protocol_http_connect_disconnected";
      uint32_t v41 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_131;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v83 = "nw_protocol_http_connect_disconnected";
    __int16 v38 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v80)
      {
        char v39 = (os_log_s *)__nwlog_obj();
        os_log_type_t v40 = type;
        if (!os_log_type_enabled(v39, type)) {
          goto LABEL_132;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v83 = "nw_protocol_http_connect_disconnected";
        uint32_t v41 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_131;
      }

      unsigned int v49 = (char *)__nw_create_backtrace_string();
      char v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = type;
      BOOL v50 = os_log_type_enabled(v39, type);
      if (!v49)
      {
        if (!v50) {
          goto LABEL_132;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v83 = "nw_protocol_http_connect_disconnected";
        uint32_t v41 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_131;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v83 = "nw_protocol_http_connect_disconnected";
        __int16 v84 = 2082;
        __int16 v85 = v49;
        char v51 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_84:
        _os_log_impl(&dword_181A5C000, v39, v40, v51, buf, 0x16u);
      }

void nw_protocol_http_connect_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_http_connect_error";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v43 = "nw_protocol_http_connect_error";
      os_log_type_t v17 = "%{public}s called with null protocol";
LABEL_84:
      BOOL v37 = v18;
      os_log_type_t v38 = v19;
      uint32_t v39 = 12;
      goto LABEL_85;
    }

    if (!v40)
    {
      uint32_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v43 = "nw_protocol_http_connect_error";
      os_log_type_t v17 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_84;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v26 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v43 = "nw_protocol_http_connect_error";
      os_log_type_t v17 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_84;
    }

    if (!v26) {
      goto LABEL_57;
    }
    *(_DWORD *)buf = 136446466;
    BOOL v43 = "nw_protocol_http_connect_error";
    __int16 v44 = 2082;
    __int16 v45 = backtrace_string;
    os_log_type_t v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_56:
    _os_log_impl(&dword_181A5C000, v18, v19, v27, buf, 0x16u);
    goto LABEL_57;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_http_connect_error";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v43 = "nw_protocol_http_connect_error";
      os_log_type_t v17 = "%{public}s called with null http_connect";
      goto LABEL_84;
    }

    if (!v40)
    {
      uint32_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v43 = "nw_protocol_http_connect_error";
      os_log_type_t v17 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_84;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint32_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v28 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v43 = "nw_protocol_http_connect_error";
      os_log_type_t v17 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_84;
    }

    if (!v28) {
      goto LABEL_57;
    }
    *(_DWORD *)buf = 136446466;
    BOOL v43 = "nw_protocol_http_connect_error";
    __int16 v44 = 2082;
    __int16 v45 = backtrace_string;
    os_log_type_t v27 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
    goto LABEL_56;
  }

  if (a2)
  {
    if (!a3)
    {
      if ((handle[184] & 0x80) == 0)
      {
        if (gLogDatapath)
        {
          char v30 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            BOOL v43 = "nw_protocol_http_connect_error";
            __int16 v44 = 2082;
            __int16 v45 = (char *)(handle + 142);
            __int16 v46 = 2080;
            uint64_t v47 = " ";
            _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%ssuppressing error 0",  buf,  0x20u);
          }
        }
      }

      return;
    }

    if (*((_DWORD *)handle + 70) == 1 && a1->output_handler == a2) {
      return;
    }
    uint64_t default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        error = (void (*)(void))callbacks->error;
        if (error)
        {
          error();
          return;
        }
      }
    }

    __nwlog_obj();
    uint64_t v8 = a1->default_input_handler;
    __int16 v9 = "invalid";
    if (v8)
    {
      identifier = v8->identifier;
      if (identifier) {
        __int16 v9 = (const char *)identifier;
      }
    }

    *(_DWORD *)buf = 136446466;
    BOOL v43 = "nw_protocol_http_connect_error";
    __int16 v44 = 2082;
    __int16 v45 = (char *)v9;
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_86;
      }
      BOOL v14 = a1->default_input_handler;
      os_log_type_t v15 = "invalid";
      if (v14)
      {
        uint64_t v16 = v14->identifier;
        if (v16) {
          os_log_type_t v15 = (const char *)v16;
        }
      }

      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_protocol_http_connect_error";
      __int16 v44 = 2082;
      __int16 v45 = (char *)v15;
      os_log_type_t v17 = "%{public}s protocol %{public}s has invalid error callback";
    }

    else if (v40)
    {
      BOOL v20 = (char *)__nw_create_backtrace_string();
      unsigned int v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v21 = os_log_type_enabled(v12, type);
      if (v20)
      {
        if (v21)
        {
          uint64_t v22 = a1->default_input_handler;
          int v23 = "invalid";
          if (v22)
          {
            BOOL v24 = v22->identifier;
            if (v24) {
              int v23 = (const char *)v24;
            }
          }

          *(_DWORD *)buf = 136446722;
          BOOL v43 = "nw_protocol_http_connect_error";
          __int16 v44 = 2082;
          __int16 v45 = (char *)v23;
          __int16 v46 = 2082;
          uint64_t v47 = v20;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v20);
LABEL_86:
        if (v11) {
          goto LABEL_87;
        }
        return;
      }

      if (!v21) {
        goto LABEL_86;
      }
      __int16 v34 = a1->default_input_handler;
      BOOL v35 = "invalid";
      if (v34)
      {
        BOOL v36 = v34->identifier;
        if (v36) {
          BOOL v35 = (const char *)v36;
        }
      }

      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_protocol_http_connect_error";
      __int16 v44 = 2082;
      __int16 v45 = (char *)v35;
      os_log_type_t v17 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
    }

    else
    {
      unsigned int v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_86;
      }
      os_log_type_t v31 = a1->default_input_handler;
      int v32 = "invalid";
      if (v31)
      {
        os_log_type_t v33 = v31->identifier;
        if (v33) {
          int v32 = (const char *)v33;
        }
      }

      *(_DWORD *)buf = 136446466;
      BOOL v43 = "nw_protocol_http_connect_error";
      __int16 v44 = 2082;
      __int16 v45 = (char *)v32;
      os_log_type_t v17 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
    }

    BOOL v37 = v12;
    os_log_type_t v38 = v13;
    uint32_t v39 = 22;
LABEL_85:
    _os_log_impl(&dword_181A5C000, v37, v38, v17, buf, v39);
    goto LABEL_86;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v43 = "nw_protocol_http_connect_error";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v40 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint32_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_86;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_http_connect_error";
    os_log_type_t v17 = "%{public}s called with null other_protocol";
    goto LABEL_84;
  }

  if (!v40)
  {
    uint32_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_86;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_http_connect_error";
    os_log_type_t v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_84;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  uint32_t v18 = (os_log_s *)__nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v29 = os_log_type_enabled(v18, type);
  if (!backtrace_string)
  {
    if (!v29) {
      goto LABEL_86;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v43 = "nw_protocol_http_connect_error";
    os_log_type_t v17 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_84;
  }

  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v43 = "nw_protocol_http_connect_error";
    __int16 v44 = 2082;
    __int16 v45 = backtrace_string;
    os_log_type_t v27 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_56;
  }

uint64_t nw_protocol_http_connect_copy_info(uint64_t a1, int a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "nw_protocol_http_connect_copy_info";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        uint32_t v18 = (os_log_s *)__nwlog_obj();
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_56;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_http_connect_copy_info";
        BOOL v20 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_55;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v22 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (!v22) {
          goto LABEL_56;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_protocol_http_connect_copy_info";
        BOOL v20 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_55;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v28 = "nw_protocol_http_connect_copy_info";
        __int16 v29 = 2082;
        char v30 = backtrace_string;
        int v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_45:
        _os_log_impl(&dword_181A5C000, v18, v19, v23, buf, 0x16u);
      }

nw_protocol *nw_protocol_http_connect_get_parameters(nw_protocol *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_http_connect_get_parameters";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_protocol_http_connect_get_parameters";
      unint64_t v9 = "%{public}s called with null protocol";
    }

    else
    {
      if (!v14)
      {
        id v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_protocol_http_connect_get_parameters";
        unint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_protocol_http_connect_get_parameters";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v6) {
          return 0LL;
        }
        goto LABEL_38;
      }

      if (!v11) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_protocol_http_connect_get_parameters";
      unint64_t v9 = "%{public}s called with null protocol, no backtrace";
    }

nw_protocol *nw_protocol_http_connect_get_path(nw_protocol *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_http_connect_get_path";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_protocol_http_connect_get_path";
      unint64_t v9 = "%{public}s called with null protocol";
    }

    else
    {
      if (!v14)
      {
        id v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_protocol_http_connect_get_path";
        unint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_protocol_http_connect_get_path";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v6) {
          return 0LL;
        }
        goto LABEL_38;
      }

      if (!v11) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_protocol_http_connect_get_path";
      unint64_t v9 = "%{public}s called with null protocol, no backtrace";
    }

nw_protocol *nw_protocol_http_connect_get_local_endpoint(nw_protocol *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v16 = "nw_protocol_http_connect_get_local_endpoint";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v13)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_http_connect_get_local_endpoint";
        os_log_type_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v10) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_http_connect_get_local_endpoint";
        os_log_type_t v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v16 = "nw_protocol_http_connect_get_local_endpoint";
        __int16 v17 = 2082;
        __int16 v18 = backtrace_string;
        BOOL v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
        _os_log_impl(&dword_181A5C000, v6, v7, v11, buf, 0x16u);
      }

uint64_t nw_protocol_http_connect_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      uint64_t result = handle[19];
      if (!result) {
        return handle[17];
      }
      return result;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_http_connect_get_remote_endpoint";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_http_connect_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null http_connect";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_http_connect_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_http_connect_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_http_connect_get_remote_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      unint64_t v9 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
      goto LABEL_22;
    }

    goto LABEL_23;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_protocol_http_connect_get_remote_endpoint";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_http_connect_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_http_connect_get_remote_endpoint";
        uint64_t v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      char v14 = "nw_protocol_http_connect_get_remote_endpoint";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      unint64_t v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_22:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

uint64_t nw_http_connect_restart_after_disconnect(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_http_connect_restart_after_disconnect";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_http_connect_restart_after_disconnect";
      char v11 = "%{public}s called with null http_connect";
LABEL_52:
      _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      goto LABEL_53;
    }

    if (!v18)
    {
      unint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_http_connect_restart_after_disconnect";
        char v11 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_http_connect_restart_after_disconnect";
        char v11 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    if (!v13) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446466;
    BOOL v21 = "nw_http_connect_restart_after_disconnect";
    __int16 v22 = 2082;
    int v23 = backtrace_string;
    char v14 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_38:
    _os_log_impl(&dword_181A5C000, v9, v10, v14, buf, 0x16u);
    goto LABEL_39;
  }

  if (!*(void *)(a1 + 168))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_http_connect_restart_after_disconnect";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_http_connect_restart_after_disconnect";
      char v11 = "%{public}s called with null http_connect->context";
      goto LABEL_52;
    }

    if (!v18)
    {
      unint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_http_connect_restart_after_disconnect";
        char v11 = "%{public}s called with null http_connect->context, backtrace limit exceeded";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_http_connect_restart_after_disconnect";
        char v11 = "%{public}s called with null http_connect->context, no backtrace";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    if (!v15) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446466;
    BOOL v21 = "nw_http_connect_restart_after_disconnect";
    __int16 v22 = 2082;
    int v23 = backtrace_string;
    char v14 = "%{public}s called with null http_connect->context, dumping backtrace:%{public}s";
    goto LABEL_38;
  }

  __int16 v2 = *(_WORD *)(a1 + 368);
  if ((v2 & 0x20) != 0)
  {
    if (*(_DWORD *)(a1 + 276))
    {
      if ((v2 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v3 = (os_log_s *)gLogObj;
        uint64_t v4 = 1LL;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446722;
          BOOL v21 = "nw_http_connect_restart_after_disconnect";
          __int16 v22 = 2082;
          int v23 = (char *)(a1 + 284);
          __int16 v24 = 2080;
          char v25 = " ";
          _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sNot restarting after disconnect because async operation is active",  buf,  0x20u);
        }

        return v4;
      }
    }

    else
    {
      if ((v2 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446722;
          BOOL v21 = "nw_http_connect_restart_after_disconnect";
          __int16 v22 = 2082;
          int v23 = (char *)(a1 + 284);
          __int16 v24 = 2080;
          char v25 = " ";
          _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sWaiting to restart after disconnect",  buf,  0x20u);
        }
      }

      nw_http_connect_start_async(a1);
      uint64_t v6 = *(void **)(a1 + 168);
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 0x40000000LL;
      v17[2] = ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke;
      v17[3] = &__block_descriptor_tmp_36_35494;
      void v17[4] = a1;
      nw_queue_context_async(v6, v17);
    }

    return 1LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v21 = "nw_http_connect_restart_after_disconnect";
  BOOL v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v18)
    {
      unint64_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_http_connect_restart_after_disconnect";
        char v11 = "%{public}s called with null http_connect->was_disconnected, backtrace limit exceeded";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v16 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v21 = "nw_http_connect_restart_after_disconnect";
        char v11 = "%{public}s called with null http_connect->was_disconnected, no backtrace";
        goto LABEL_52;
      }

      goto LABEL_53;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v21 = "nw_http_connect_restart_after_disconnect";
      __int16 v22 = 2082;
      int v23 = backtrace_string;
      char v14 = "%{public}s called with null http_connect->was_disconnected, dumping backtrace:%{public}s";
      goto LABEL_38;
    }

void nw_http_connect_start_async(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = *(unsigned int *)(a1 + 276) + 1LL;
    uint64_t v3 = v2 << 31 >> 31;
    *(_DWORD *)(a1 + 276) = v2;
    if (v3 == v2 && (v3 & 0x8000000000000000LL) == 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = *(unsigned int *)(a1 + 276);
    *(_DWORD *)buf = 136446978;
    __int16 v24 = "nw_http_connect_start_async";
    __int16 v25 = 2082;
    uint64_t v26 = "http_connect->in_async";
    __int16 v27 = 2048;
    uint64_t v28 = 1LL;
    __int16 v29 = 2048;
    uint64_t v30 = v4;
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        uint64_t v8 = *(unsigned int *)(a1 + 276);
        *(_DWORD *)buf = 136446978;
        __int16 v24 = "nw_http_connect_start_async";
        __int16 v25 = 2082;
        uint64_t v26 = "http_connect->in_async";
        __int16 v27 = 2048;
        uint64_t v28 = 1LL;
        __int16 v29 = 2048;
        uint64_t v30 = v8;
        unint64_t v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v9, buf, 0x2Au);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v11)
        {
          uint64_t v12 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136447234;
          __int16 v24 = "nw_http_connect_start_async";
          __int16 v25 = 2082;
          uint64_t v26 = "http_connect->in_async";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v12;
          __int16 v31 = 2082;
          int v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v11)
      {
        uint64_t v14 = *(unsigned int *)(a1 + 276);
        *(_DWORD *)buf = 136446978;
        __int16 v24 = "nw_http_connect_start_async";
        __int16 v25 = 2082;
        uint64_t v26 = "http_connect->in_async";
        __int16 v27 = 2048;
        uint64_t v28 = 1LL;
        __int16 v29 = 2048;
        uint64_t v30 = v14;
        unint64_t v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)gLogObj;
      os_log_type_t v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        uint64_t v13 = *(unsigned int *)(a1 + 276);
        *(_DWORD *)buf = 136446978;
        __int16 v24 = "nw_http_connect_start_async";
        __int16 v25 = 2082;
        uint64_t v26 = "http_connect->in_async";
        __int16 v27 = 2048;
        uint64_t v28 = 1LL;
        __int16 v29 = 2048;
        uint64_t v30 = v13;
        unint64_t v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

void ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke(uint64_t a1)
{
  uint64_t v132 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(_WORD *)(v2 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = (os_log_s *)gLogObj;
    BOOL v4 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    uint64_t v2 = *(void *)(a1 + 32);
    if (v4)
    {
      os_log_type_t v5 = "";
      uint64_t v6 = (const char *)(v2 + 284);
      if (!v2) {
        uint64_t v6 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
      if (v2) {
        os_log_type_t v5 = " ";
      }
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v6;
      *(_WORD *)&_BYTE buf[22] = 2080;
      uint64_t v130 = (void *)v5;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sFinished waiting to restart after disconnect",  buf,  0x20u);
      uint64_t v2 = *(void *)(a1 + 32);
    }
  }

  BOOL v7 = nw_http_connect_end_async(v2);
  uint64_t v8 = *(void *)(a1 + 32);
  if (v7)
  {
    __int16 v9 = *(_WORD *)(v8 + 368);
    if ((v9 & 0x20) == 0)
    {
      if ((v9 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          uint64_t v11 = *(void *)(a1 + 32);
          uint64_t v12 = "";
          BOOL v13 = v11 == 0;
          if (v11) {
            uint64_t v14 = (const char *)(v11 + 284);
          }
          else {
            uint64_t v14 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (!v13) {
            uint64_t v12 = " ";
          }
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v14;
          *(_WORD *)&_BYTE buf[22] = 2080;
          uint64_t v130 = (void *)v12;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sNot restarting because not disconnected",  buf,  0x20u);
        }
      }

      return;
    }

    *(_WORD *)(v8 + 368) = v9 & 0xFFDF;
    uint64_t v19 = *(void *)(a1 + 32);
    __int16 v20 = *(_WORD *)(v19 + 368);
    if (*(_DWORD *)(v19 + 280) == 1)
    {
      if ((v20 & 4) == 0)
      {
        if ((v20 & 0x80) != 0) {
          goto LABEL_39;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = gLogObj;
        BOOL v22 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
        uint64_t v19 = *(void *)(a1 + 32);
        if (!v22) {
          goto LABEL_39;
        }
        int v23 = "";
        __int16 v24 = (const char *)(v19 + 284);
        if (!v19) {
          __int16 v24 = "";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        if (v19) {
          int v23 = " ";
        }
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v24;
        *(_WORD *)&_BYTE buf[22] = 2080;
        uint64_t v130 = (void *)v23;
        __int16 v25 = "%{public}s %{public}s%sNot restarting because no response bytes were received";
        uint64_t v26 = (os_log_s *)v21;
        os_log_type_t v27 = OS_LOG_TYPE_INFO;
        uint32_t v28 = 32;
LABEL_38:
        _os_log_impl(&dword_181A5C000, v26, v27, v25, buf, v28);
        uint64_t v19 = *(void *)(a1 + 32);
LABEL_39:
        nw_http_connect_fail(v19, 22);
        return;
      }

      BOOL v35 = (uint64_t *)(v19 + 224);
      if (gLogDatapath)
      {
        uint64_t v107 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_181A5C000, v107, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }

      uint64_t v36 = MEMORY[0x1895F87A8];
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_35503;
      uint64_t v130 = &__block_descriptor_tmp_15_35504;
      *(void *)&__int128 v131 = v35;
      BYTE8(v131) = 0;
      uint64_t v37 = *v35;
      do
      {
        if (!v37) {
          break;
        }
        uint64_t v38 = *(void *)(v37 + 32);
        char v39 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        uint64_t v37 = v38;
      }

      while ((v39 & 1) != 0);
      *(_WORD *)(*(void *)(a1 + 32) + 368LL) &= ~4u;
      *(_WORD *)(*(void *)(a1 + 32) + 368LL) &= ~2u;
      uint64_t v19 = *(void *)(a1 + 32);
      __int16 v40 = *(_WORD *)(v19 + 368);
      if ((v40 & 1) == 0)
      {
        uint64_t v41 = *(void *)(v19 + 56);
        if (!v41
          || (uint64_t v42 = *(void *)(v41 + 24)) == 0
          || (BOOL v43 = *(void (**)(void, uint64_t))(v42 + 256)) == 0LL)
        {
          if ((v40 & 0x80) != 0) {
            goto LABEL_39;
          }
          os_log_type_t v102 = (os_log_s *)__nwlog_obj();
          BOOL v103 = os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
          uint64_t v19 = *(void *)(a1 + 32);
          if (!v103) {
            goto LABEL_39;
          }
          os_log_type_t v104 = (const char *)(v19 + 284);
          uint64_t v105 = *(void *)(v19 + 56);
          if (!v19) {
            os_log_type_t v104 = "";
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v104;
          if (v19) {
            uint64_t v106 = " ";
          }
          else {
            uint64_t v106 = "";
          }
          *(_WORD *)&_BYTE buf[22] = 2080;
          uint64_t v130 = (void *)v106;
          LOWORD(v131) = 2048;
          *(void *)((char *)&v131 + 2) = v105;
          __int16 v25 = "%{public}s %{public}s%sNot restarting after disconnect because unable to call reset on output_handler %p";
          uint64_t v26 = v102;
          os_log_type_t v27 = OS_LOG_TYPE_ERROR;
          uint32_t v28 = 42;
          goto LABEL_38;
        }

        v43(*(void *)(v19 + 56), v19 + 24);
LABEL_56:
        uint64_t v44 = *(void *)(*(void *)(a1 + 32) + 56LL);
        if (v44)
        {
          uint64_t v45 = *(void *)(v44 + 24);
          if (v45)
          {
            __int16 v46 = *(void (**)(void))(v45 + 24);
            if (v46)
            {
              v46();
              return;
            }
          }
        }

        __nwlog_obj();
        uint64_t v92 = *(void *)(*(void *)(a1 + 32) + 56LL);
        BOOL v93 = "invalid";
        if (v92)
        {
          os_log_type_t v94 = *(const char **)(v92 + 16);
          if (v94) {
            BOOL v93 = v94;
          }
        }

        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v93;
        int v95 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        char v119 = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          BOOL v96 = (os_log_s *)__nwlog_obj();
          os_log_type_t v97 = type[0];
          if (!os_log_type_enabled(v96, type[0])) {
            goto LABEL_168;
          }
          uint64_t v98 = *(void *)(*(void *)(a1 + 32) + 56LL);
          BOOL v99 = "invalid";
          if (v98)
          {
            os_log_type_t v100 = *(const char **)(v98 + 16);
            if (v100) {
              BOOL v99 = v100;
            }
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v99;
          os_log_type_t v101 = "%{public}s protocol %{public}s has invalid connect callback";
        }

        else if (v119)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          BOOL v96 = (os_log_s *)__nwlog_obj();
          os_log_type_t v97 = type[0];
          BOOL v109 = os_log_type_enabled(v96, type[0]);
          if (backtrace_string)
          {
            if (v109)
            {
              uint64_t v110 = *(void *)(*(void *)(a1 + 32) + 56LL);
              char v111 = "invalid";
              if (v110)
              {
                uint64_t v112 = *(const char **)(v110 + 16);
                if (v112) {
                  char v111 = v112;
                }
              }

              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v111;
              *(_WORD *)&_BYTE buf[22] = 2082;
              uint64_t v130 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v96,  v97,  "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
            goto LABEL_168;
          }

          if (!v109)
          {
LABEL_168:
            if (v95) {
              free(v95);
            }
            return;
          }

          uint64_t v116 = *(void *)(*(void *)(a1 + 32) + 56LL);
          uint64_t v117 = "invalid";
          if (v116)
          {
            __int16 v118 = *(const char **)(v116 + 16);
            if (v118) {
              uint64_t v117 = v118;
            }
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v117;
          os_log_type_t v101 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
        }

        else
        {
          BOOL v96 = (os_log_s *)__nwlog_obj();
          os_log_type_t v97 = type[0];
          if (!os_log_type_enabled(v96, type[0])) {
            goto LABEL_168;
          }
          uint64_t v113 = *(void *)(*(void *)(a1 + 32) + 56LL);
          int v114 = "invalid";
          if (v113)
          {
            unsigned int v115 = *(const char **)(v113 + 16);
            if (v115) {
              int v114 = v115;
            }
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v114;
          os_log_type_t v101 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v96, v97, v101, buf, 0x16u);
        goto LABEL_168;
      }

      *(void *)os_log_type_t type = 0LL;
      BOOL v126 = type;
      uint64_t v127 = 0x2000000000LL;
      id v128 = nw_path_copy_flow_registration(*(void **)(v19 + 168), v19 + 24);
      uint64_t v47 = v126;
      if (!*((void *)v126 + 3))
      {
        uint64_t v67 = *(void *)(a1 + 32);
        if (!v67 || (*(_WORD *)(v67 + 368) & 0x80) == 0)
        {
          uint64_t v68 = (os_log_s *)__nwlog_obj();
          BOOL v69 = os_log_type_enabled(v68, OS_LOG_TYPE_INFO);
          uint64_t v67 = *(void *)(a1 + 32);
          if (v69)
          {
            BOOL v70 = "";
            __int16 v71 = (const char *)(v67 + 284);
            if (!v67) {
              __int16 v71 = "";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
            if (v67) {
              BOOL v70 = " ";
            }
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v71;
            *(_WORD *)&_BYTE buf[22] = 2080;
            uint64_t v130 = (void *)v70;
            _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sNot restarting after disconnect because unable to get flow registration",  buf,  0x20u);
            uint64_t v67 = *(void *)(a1 + 32);
          }
        }

        nw_http_connect_fail(v67, 22);
        goto LABEL_127;
      }

      v120[0] = v36;
      v120[1] = 0x40000000LL;
      os_log_type_t v121 = ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke_34;
      __int16 v122 = &unk_189BBCA40;
      uint64_t v48 = *(void *)(a1 + 32);
      BOOL v123 = type;
      uint64_t v124 = v48;
      unsigned int v49 = *(void **)(v48 + 96);
      if (v49)
      {
        os_release(v49);
        *(void *)(*(void *)(a1 + 32) + 96LL) = 0LL;
        uint64_t v47 = v126;
        uint64_t v48 = *(void *)(a1 + 32);
      }

      *(void *)(*(void *)(a1 + 32) + 96LL) = nw_path_flow_registration_create_new_flow( *((void **)v47 + 3),  1,  1,  0,  0,  (_OWORD *)(v48 + 240),  0LL,  0);
      uint64_t v50 = *(void *)(a1 + 32);
      if (*(void *)(v50 + 96))
      {
        nw_http_connect_start_async(v50);
        uint64_t v51 = *(void *)(a1 + 32);
        BOOL v52 = *(void **)(v51 + 104);
        if (v52)
        {
          os_release(v52);
          *(void *)(*(void *)(a1 + 32) + 104LL) = 0LL;
          uint64_t v51 = *(void *)(a1 + 32);
        }

        *(void *)(*(void *)(a1 + 32) + 104LL) = nw_path_flow_registration_force_update(*(void **)(v51 + 96));
        BOOL v53 = nw_http_connect_end_async(*(void *)(a1 + 32));
        uint64_t v50 = *(void *)(a1 + 32);
        if (!v53)
        {
          if (!v50 || (*(_WORD *)(v50 + 368) & 0x80) == 0)
          {
            char v80 = (os_log_s *)__nwlog_obj();
            BOOL v81 = os_log_type_enabled(v80, OS_LOG_TYPE_INFO);
            uint64_t v50 = *(void *)(a1 + 32);
            if (v81)
            {
              CFIndex v82 = "";
              __int16 v83 = (const char *)(v50 + 284);
              if (!v50) {
                __int16 v83 = "";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
              if (v50) {
                CFIndex v82 = " ";
              }
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v83;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v130 = (void *)v82;
              _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sNot restarting after disconnect because getting new path changed state to destroy",  buf,  0x20u);
              uint64_t v50 = *(void *)(a1 + 32);
            }
          }

          nw_http_connect_destroy(v50);
          goto LABEL_126;
        }

        BOOL v54 = *(nw_path **)(v50 + 104);
        if (v54)
        {
          __int16 v55 = *(void **)(v50 + 120);
          if (v55)
          {
            os_release(v55);
            *(void *)(*(void *)(a1 + 32) + 120LL) = 0LL;
            BOOL v54 = *(nw_path **)(*(void *)(a1 + 32) + 104LL);
          }

          *(void *)(*(void *)(a1 + 32) + 120LL) = nw_path_copy_effective_local_endpoint(v54);
          uint64_t v50 = *(void *)(a1 + 32);
          uint64_t v56 = *(void *)(v50 + 72);
          if (!v56) {
            goto LABEL_115;
          }
          uint64_t v57 = *(void *)(v56 + 24);
          if (!v57) {
            goto LABEL_115;
          }
          uint64_t v58 = *(uint64_t (**)(void))(v57 + 112);
          if (!v58) {
            goto LABEL_115;
          }
          uint64_t v59 = (nw_parameters *)v58(*(void *)(v50 + 72));
          uint64_t v50 = *(void *)(a1 + 32);
          if (v59)
          {
            os_log_type_t v60 = *(void **)(v50 + 112);
            if (v60)
            {
              os_release(v60);
              *(void *)(*(void *)(a1 + 32) + 112LL) = 0LL;
            }

            *(void *)(*(void *)(a1 + 32) + 112LL) = nw_parameters_copy(v59);
            *(void *)buf = 0LL;
            *(void *)&buf[8] = 0LL;
            nw_path_flow_registration_get_id(*(void **)(*(void *)(a1 + 32) + 96LL), buf);
            *(_OWORD *)(*(void *)(a1 + 32) + 24LL) = *(_OWORD *)buf;
            uint64_t v61 = *(void *)(a1 + 32);
            uint64_t v62 = *(void *)(v61 + 56);
            nw_protocol_set_output_handler(v61 + 24, 0LL);
            if (nw_http_connect_reattach_channel_protocol(*(void *)(a1 + 32)))
            {
              if (v62)
              {
                uint64_t v63 = *(void *)(v62 + 24);
                if (v63)
                {
                  uint64_t v64 = *(void (**)(uint64_t, uint64_t, uint64_t))(v63 + 8);
                  if (v64)
                  {
                    uint64_t v65 = *(void *)(a1 + 32);
                    uint64_t v66 = *(void *)(v65 + 56);
                    v64(v62, v65 + 24, 1LL);
                    nw_protocol_set_output_handler(*(void *)(a1 + 32) + 24LL, v66);
                  }
                }
              }

              v121((uint64_t)v120);
              _Block_object_dispose(type, 8);
              goto LABEL_56;
            }

            nw_protocol_set_output_handler(*(void *)(a1 + 32) + 24LL, v62);
            goto LABEL_124;
          }

          if (v50)
          {
LABEL_115:
            if ((*(_WORD *)(v50 + 368) & 0x80) != 0) {
              goto LABEL_125;
            }
          }

          uint64_t v88 = (os_log_s *)__nwlog_obj();
          BOOL v89 = os_log_type_enabled(v88, OS_LOG_TYPE_INFO);
          uint64_t v50 = *(void *)(a1 + 32);
          if (!v89)
          {
LABEL_125:
            nw_http_connect_fail(v50, 22);
LABEL_126:
            v121((uint64_t)v120);
LABEL_127:
            _Block_object_dispose(type, 8);
            return;
          }

          os_log_type_t v90 = "";
          uint32_t v91 = (const char *)(v50 + 284);
          if (!v50) {
            uint32_t v91 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (v50) {
            os_log_type_t v90 = " ";
          }
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v91;
          *(_WORD *)&_BYTE buf[22] = 2080;
          uint64_t v130 = (void *)v90;
          __int128 v76 = "%{public}s %{public}s%sNot restarting after disconnect because unable to get parameters";
          __int128 v77 = v88;
          os_log_type_t v78 = OS_LOG_TYPE_INFO;
        }

        else
        {
          if ((*(_WORD *)(v50 + 368) & 0x80) != 0) {
            goto LABEL_125;
          }
          __int16 v84 = (os_log_s *)__nwlog_obj();
          BOOL v85 = os_log_type_enabled(v84, OS_LOG_TYPE_ERROR);
          uint64_t v50 = *(void *)(a1 + 32);
          if (!v85) {
            goto LABEL_125;
          }
          __int16 v86 = "";
          uint64_t v87 = (const char *)(v50 + 284);
          if (!v50) {
            uint64_t v87 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (v50) {
            __int16 v86 = " ";
          }
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v87;
          *(_WORD *)&_BYTE buf[22] = 2080;
          uint64_t v130 = (void *)v86;
          __int128 v76 = "%{public}s %{public}s%sNot restarting after disconnect because unable to get new path";
          __int128 v77 = v84;
          os_log_type_t v78 = OS_LOG_TYPE_ERROR;
        }

        uint32_t v79 = 32;
      }

      else
      {
        if ((*(_WORD *)(v50 + 368) & 0x80) != 0) {
          goto LABEL_125;
        }
        uint64_t v72 = (os_log_s *)__nwlog_obj();
        BOOL v73 = os_log_type_enabled(v72, OS_LOG_TYPE_INFO);
        uint64_t v50 = *(void *)(a1 + 32);
        if (!v73) {
          goto LABEL_125;
        }
        __int128 v74 = (const char *)(v50 + 284);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        if (!v50) {
          __int128 v74 = "";
        }
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v74;
        *(_WORD *)&_BYTE buf[22] = 2080;
        id v75 = " ";
        if (!v50) {
          id v75 = "";
        }
        uint64_t v130 = (void *)v75;
        LOWORD(v131) = 1040;
        *(_DWORD *)((char *)&v131 + 2) = 16;
        WORD3(v131) = 2096;
        *((void *)&v131 + 1) = v50 + 240;
        __int128 v76 = "%{public}s %{public}s%sNot restarting after disconnect because unable to create new flow with nexus agent %{uuid_t}.16P";
        __int128 v77 = v72;
        os_log_type_t v78 = OS_LOG_TYPE_INFO;
        uint32_t v79 = 48;
      }

      _os_log_impl(&dword_181A5C000, v77, v78, v76, buf, v79);
LABEL_124:
      uint64_t v50 = *(void *)(a1 + 32);
      goto LABEL_125;
    }

    if ((v20 & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v29 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v30 = *(void *)(a1 + 32);
        __int16 v31 = (const char *)(v30 + 284);
        int v32 = "";
        BOOL v33 = v30 == 0;
        int v34 = *(_DWORD *)(v30 + 280);
        if (v33) {
          __int16 v31 = "";
        }
        *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(_DWORD *)buf = 136446978;
        if (!v33) {
          int v32 = " ";
        }
        *(void *)&buf[14] = v31;
        *(_WORD *)&_BYTE buf[22] = 2080;
        uint64_t v130 = (void *)v32;
        LOWORD(v131) = 1024;
        *(_DWORD *)((char *)&v131 + 2) = v34;
        _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sNot restarting because state %d is not negotiating",  buf,  0x26u);
      }
    }
  }

  else
  {
    if (!v8 || (*(_WORD *)(v8 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v15 = (os_log_s *)gLogObj;
      BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      uint64_t v8 = *(void *)(a1 + 32);
      if (v16)
      {
        os_log_type_t v17 = "";
        char v18 = (const char *)(v8 + 284);
        if (!v8) {
          char v18 = "";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        if (v8) {
          os_log_type_t v17 = " ";
        }
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v18;
        *(_WORD *)&_BYTE buf[22] = 2080;
        uint64_t v130 = (void *)v17;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sNot restarting after disconnect because http connect state was changed to destroy",  buf,  0x20u);
        uint64_t v8 = *(void *)(a1 + 32);
      }
    }

    nw_http_connect_destroy(v8);
  }

BOOL nw_http_connect_end_async(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 276);
    *(_DWORD *)(a1 + 276) = v2 - 1;
    if (v2) {
      return (*(_WORD *)(a1 + 368) & 0x40) == 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = *(unsigned int *)(a1 + 276);
    *(_DWORD *)buf = 136446978;
    __int16 v24 = "nw_http_connect_end_async";
    __int16 v25 = 2082;
    uint64_t v26 = "http_connect->in_async";
    __int16 v27 = 2048;
    uint64_t v28 = 1LL;
    __int16 v29 = 2048;
    uint64_t v30 = v3;
    BOOL v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v4, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = (os_log_s *)gLogObj;
        os_log_type_t v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v7 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136446978;
          __int16 v24 = "nw_http_connect_end_async";
          __int16 v25 = 2082;
          uint64_t v26 = "http_connect->in_async";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v7;
          uint64_t v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_16:
          _os_log_impl(&dword_181A5C000, v5, v6, v8, buf, 0x2Au);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = (os_log_s *)gLogObj;
        os_log_type_t v6 = type;
        BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v10)
          {
            uint64_t v11 = *(unsigned int *)(a1 + 276);
            *(_DWORD *)buf = 136447234;
            __int16 v24 = "nw_http_connect_end_async";
            __int16 v25 = 2082;
            uint64_t v26 = "http_connect->in_async";
            __int16 v27 = 2048;
            uint64_t v28 = 1LL;
            __int16 v29 = 2048;
            uint64_t v30 = v11;
            __int16 v31 = 2082;
            int v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(backtrace_string);
          goto LABEL_17;
        }

        if (v10)
        {
          uint64_t v13 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136446978;
          __int16 v24 = "nw_http_connect_end_async";
          __int16 v25 = 2082;
          uint64_t v26 = "http_connect->in_async";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v13;
          uint64_t v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_16;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v5 = (os_log_s *)gLogObj;
        os_log_type_t v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v12 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136446978;
          __int16 v24 = "nw_http_connect_end_async";
          __int16 v25 = 2082;
          uint64_t v26 = "http_connect->in_async";
          __int16 v27 = 2048;
          uint64_t v28 = 1LL;
          __int16 v29 = 2048;
          uint64_t v30 = v12;
          uint64_t v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_16;
        }
      }
    }

void nw_http_connect_destroy(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (a1 && (__int16 v2 = *(_WORD *)(a1 + 368), (v2 & 0x80) != 0))
  {
    if (*(_DWORD *)(a1 + 276))
    {
LABEL_12:
      *(_WORD *)(a1 + 368) |= 0x40u;
      return;
    }
  }

  else
  {
    if (gLogDatapath)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        __int16 v29 = (const char *)(a1 + 284);
        if (!a1) {
          __int16 v29 = "";
        }
        int v31 = 136446978;
        int v32 = "nw_http_connect_destroy";
        __int16 v33 = 2082;
        int v34 = v29;
        uint64_t v30 = " ";
        if (!a1) {
          uint64_t v30 = "";
        }
        __int16 v35 = 2080;
        uint64_t v36 = v30;
        __int16 v37 = 2048;
        uint64_t v38 = a1;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%stearing down %p",  (uint8_t *)&v31,  0x2Au);
      }
    }

    if (nw_http_connect_in_async(a1))
    {
      if (!a1 || (*(_WORD *)(a1 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v3 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          BOOL v4 = "";
          int v32 = "nw_http_connect_destroy";
          os_log_type_t v5 = " ";
          int v31 = 136446722;
          if (a1) {
            BOOL v4 = (const char *)(a1 + 284);
          }
          else {
            os_log_type_t v5 = "";
          }
          __int16 v33 = 2082;
          int v34 = v4;
          __int16 v35 = 2080;
          uint64_t v36 = v5;
          _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect in async, setting state to destroy",  (uint8_t *)&v31,  0x20u);
        }
      }

      goto LABEL_12;
    }

    __int16 v2 = *(_WORD *)(a1 + 368);
  }

  if ((v2 & 0x40) != 0)
  {
    *(_WORD *)(a1 + 368) = v2 & 0xFFBF;
    if (!a1 || (v2 & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v6 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v7 = "";
        int v32 = "nw_http_connect_destroy";
        uint64_t v8 = " ";
        int v31 = 136446722;
        if (a1) {
          uint64_t v7 = (const char *)(a1 + 284);
        }
        else {
          uint64_t v8 = "";
        }
        __int16 v33 = 2082;
        int v34 = v7;
        __int16 v35 = 2080;
        uint64_t v36 = v8;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect destroying after deferral",  (uint8_t *)&v31,  0x20u);
      }
    }
  }

  _CFHTTPAuthenticationApplyProxyAuthorizationToRequest();
  __int16 v9 = *(void **)(a1 + 96);
  if (v9)
  {
    nw_path_flow_registration_close(v9);
    BOOL v10 = *(void **)(a1 + 96);
    if (v10)
    {
      os_release(v10);
      *(void *)(a1 + 96) = 0LL;
    }
  }

  uint64_t v11 = *(void **)(a1 + 88);
  if (v11)
  {
    nw_path_flow_registration_close(v11);
    uint64_t v12 = *(void **)(a1 + 88);
    if (v12)
    {
      os_release(v12);
      *(void *)(a1 + 88) = 0LL;
    }
  }

  uint64_t v13 = *(void **)(a1 + 128);
  if (v13)
  {
    os_release(v13);
    *(void *)(a1 + 128) = 0LL;
  }

  uint64_t v14 = *(void **)(a1 + 104);
  if (v14)
  {
    os_release(v14);
    *(void *)(a1 + 104) = 0LL;
  }

  BOOL v15 = *(void **)(a1 + 112);
  if (v15)
  {
    os_release(v15);
    *(void *)(a1 + 112) = 0LL;
  }

  BOOL v16 = *(void **)(a1 + 120);
  if (v16)
  {
    os_release(v16);
    *(void *)(a1 + 120) = 0LL;
  }

  os_log_type_t v17 = *(void **)(a1 + 136);
  if (v17)
  {
    os_release(v17);
    *(void *)(a1 + 136) = 0LL;
  }

  char v18 = *(void **)(a1 + 144);
  if (v18)
  {
    os_release(v18);
    *(void *)(a1 + 144) = 0LL;
  }

  uint64_t v19 = *(void **)(a1 + 152);
  if (v19)
  {
    os_release(v19);
    *(void *)(a1 + 152) = 0LL;
  }

  BOOL v20 = *(void **)(a1 + 160);
  if (v20)
  {
    os_release(v20);
    *(void *)(a1 + 160) = 0LL;
  }

  char v21 = *(void **)(a1 + 168);
  if (v21)
  {
    os_release(v21);
    *(void *)(a1 + 168) = 0LL;
  }

  BOOL v22 = *(void **)(a1 + 176);
  if (v22)
  {
    os_release(v22);
    *(void *)(a1 + 176) = 0LL;
  }

  int v23 = *(void **)(a1 + 184);
  if (v23)
  {
    os_release(v23);
    *(void *)(a1 + 184) = 0LL;
  }

  __int16 v24 = *(const void **)(a1 + 192);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a1 + 192) = 0LL;
  }

  __int16 v25 = *(const void **)(a1 + 208);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(a1 + 208) = 0LL;
  }

  uint64_t v26 = *(const void **)(a1 + 200);
  if (v26)
  {
    CFRelease(v26);
    *(void *)(a1 + 200) = 0LL;
  }

  __int16 v27 = *(const void **)(a1 + 216);
  if (v27) {
    CFRelease(v27);
  }
  free((void *)a1);
}

void nw_http_connect_fail(uint64_t a1, int a2)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(_DWORD *)(a1 + 280) = 3;
    if (!a2) {
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 72);
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 24);
      if (v4)
      {
        os_log_type_t v5 = *(void (**)(void))(v4 + 56);
        if (v5)
        {
          v5();
          goto LABEL_7;
        }
      }
    }

    __nwlog_obj();
    uint64_t v32 = *(void *)(a1 + 72);
    __int16 v33 = "invalid";
    if (v32)
    {
      int v34 = *(const char **)(v32 + 16);
      if (v34) {
        __int16 v33 = v34;
      }
    }

    *(_DWORD *)buf = 136446466;
    BOOL v85 = "nw_http_connect_fail";
    __int16 v86 = 2082;
    uint64_t v87 = (void *)v33;
    __int16 v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v82 = 0;
    if (__nwlog_fault(v35, &type, &v82))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_116;
        }
        uint64_t v38 = *(void *)(a1 + 72);
        uint64_t v39 = "invalid";
        if (v38)
        {
          __int16 v40 = *(const char **)(v38 + 16);
          if (v40) {
            uint64_t v39 = v40;
          }
        }

        *(_DWORD *)buf = 136446466;
        BOOL v85 = "nw_http_connect_fail";
        __int16 v86 = 2082;
        uint64_t v87 = (void *)v39;
        uint64_t v41 = "%{public}s protocol %{public}s has invalid error callback";
        goto LABEL_115;
      }

      if (!v82)
      {
        uint64_t v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_116;
        }
        uint64_t v76 = *(void *)(a1 + 72);
        __int128 v77 = "invalid";
        if (v76)
        {
          os_log_type_t v78 = *(const char **)(v76 + 16);
          if (v78) {
            __int128 v77 = v78;
          }
        }

        *(_DWORD *)buf = 136446466;
        BOOL v85 = "nw_http_connect_fail";
        __int16 v86 = 2082;
        uint64_t v87 = (void *)v77;
        uint64_t v41 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_115;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v36 = (os_log_s *)__nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v57 = os_log_type_enabled(v36, type);
      if (backtrace_string)
      {
        if (v57)
        {
          uint64_t v58 = *(void *)(a1 + 72);
          uint64_t v59 = "invalid";
          if (v58)
          {
            os_log_type_t v60 = *(const char **)(v58 + 16);
            if (v60) {
              uint64_t v59 = v60;
            }
          }

          *(_DWORD *)buf = 136446722;
          BOOL v85 = "nw_http_connect_fail";
          __int16 v86 = 2082;
          uint64_t v87 = (void *)v59;
          __int16 v88 = 2082;
          BOOL v89 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(backtrace_string);
        goto LABEL_116;
      }

      if (v57)
      {
        uint64_t v79 = *(void *)(a1 + 72);
        char v80 = "invalid";
        if (v79)
        {
          BOOL v81 = *(const char **)(v79 + 16);
          if (v81) {
            char v80 = v81;
          }
        }

        *(_DWORD *)buf = 136446466;
        BOOL v85 = "nw_http_connect_fail";
        __int16 v86 = 2082;
        uint64_t v87 = (void *)v80;
        uint64_t v41 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
LABEL_115:
        _os_log_impl(&dword_181A5C000, v36, v37, v41, buf, 0x16u);
      }
    }

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_35503( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v3;
  }

  void *v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

void ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke_34(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v1 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v1)
  {
    __int128 v34 = 0uLL;
    uint64_t v3 = v1;
    if (!uuid_is_null(v3 + 32)) {
      __int128 v34 = *((_OWORD *)v3 + 2);
    }

    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = (*(unsigned __int16 *)(v4 + 368) >> 7) & 1;
    if (!gLogDatapath) {
      LOBYTE(v5) = 1;
    }
    if (*(void *)(v4 + 88))
    {
      if ((v5 & 1) == 0)
      {
        uint64_t v11 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v12 = *(void *)(a1 + 40);
          BOOL v13 = v12 == 0;
          *(_DWORD *)buf = 136447234;
          __int16 v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (v12) {
            uint64_t v14 = (const char *)(v12 + 284);
          }
          else {
            uint64_t v14 = "";
          }
          __int16 v26 = 2082;
          os_log_type_t v27 = (void *)v14;
          if (v13) {
            BOOL v15 = "";
          }
          else {
            BOOL v15 = " ";
          }
          __int16 v28 = 2080;
          __int16 v29 = v15;
          __int16 v30 = 1040;
          int v31 = 16;
          __int16 v32 = 2096;
          __int16 v33 = &v34;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sCleaning up flow registration %{uuid_t}.16P",  buf,  0x30u);
        }
      }

      nw_path_flow_registration_close(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
      uint64_t v6 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v6)
      {
        os_release(v6);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
      }
    }

    else
    {
      if ((v5 & 1) == 0)
      {
        uint64_t v18 = (os_log_s *)__nwlog_obj();
        BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
        uint64_t v4 = *(void *)(a1 + 40);
        if (v19)
        {
          *(_DWORD *)buf = 136447234;
          __int16 v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
          BOOL v20 = v4 == 0;
          if (v4) {
            char v21 = (const char *)(v4 + 284);
          }
          else {
            char v21 = "";
          }
          __int16 v26 = 2082;
          os_log_type_t v27 = (void *)v21;
          __int16 v28 = 2080;
          uint64_t v22 = " ";
          if (v20) {
            uint64_t v22 = "";
          }
          __int16 v29 = v22;
          __int16 v30 = 1040;
          int v31 = 16;
          __int16 v32 = 2096;
          __int16 v33 = &v34;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDeferring cleanup of flow registration %{uuid_t}.16P",  buf,  0x30u);
          uint64_t v4 = *(void *)(a1 + 40);
        }
      }

      *(void *)(v4 + 88) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v34) = 16;
  char v23 = 0;
  if (__nwlog_fault(v7, &v34, &v23))
  {
    if (v34 == 17)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v34;
      if (!os_log_type_enabled(v8, (os_log_type_t)v34)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
      uint64_t v10 = "%{public}s called with null flow_registration";
      goto LABEL_41;
    }

    if (!v23)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = v34;
      if (!os_log_type_enabled(v8, (os_log_type_t)v34)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
      uint64_t v10 = "%{public}s called with null flow_registration, backtrace limit exceeded";
      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = v34;
    BOOL v17 = os_log_type_enabled(v8, (os_log_type_t)v34);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
        __int16 v26 = 2082;
        os_log_type_t v27 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null flow_registration, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_42;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
      uint64_t v10 = "%{public}s called with null flow_registration, no backtrace";
LABEL_41:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    }
  }

void sub_1820E2D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_http_connect_reattach_channel_protocol(uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)uint64_t v51 = 136446210;
    *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    buf[0] = 0;
    if (uu == 17)
    {
      __int16 v40 = (os_log_s *)__nwlog_obj();
      os_log_type_t v41 = uu;
      if (!os_log_type_enabled(v40, (os_log_type_t)uu)) {
        goto LABEL_92;
      }
      *(_DWORD *)uint64_t v51 = 136446210;
      *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
      uint64_t v42 = "%{public}s called with null http_connect";
    }

    else if (buf[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v40 = (os_log_s *)__nwlog_obj();
      os_log_type_t v41 = uu;
      BOOL v44 = os_log_type_enabled(v40, (os_log_type_t)uu);
      if (backtrace_string)
      {
        if (v44)
        {
          *(_DWORD *)uint64_t v51 = 136446466;
          *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
          *(_WORD *)&v51[12] = 2082;
          *(void *)&v51[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s called with null http_connect, dumping backtrace:%{public}s",  v51,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_92;
      }

      if (!v44)
      {
LABEL_92:
        if (v39) {
          free(v39);
        }
        return 0LL;
      }

      *(_DWORD *)uint64_t v51 = 136446210;
      *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
      uint64_t v42 = "%{public}s called with null http_connect, no backtrace";
    }

    else
    {
      __int16 v40 = (os_log_s *)__nwlog_obj();
      os_log_type_t v41 = uu;
      if (!os_log_type_enabled(v40, (os_log_type_t)uu)) {
        goto LABEL_92;
      }
      *(_DWORD *)uint64_t v51 = 136446210;
      *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
      uint64_t v42 = "%{public}s called with null http_connect, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v40, v41, v42, v51, 0xCu);
    goto LABEL_92;
  }

  int protocol_level = nw_path_flow_registration_get_protocol_level(*(void **)(a1 + 104), *(void **)(a1 + 96));
  uint64_t v47 = 0LL;
  *(void *)&__int128 uu = 0LL;
  *((void *)&uu + 1) = &uu;
  uint64_t v57 = 0x2000000000LL;
  char v58 = 1;
  if (protocol_level > 4) {
    goto LABEL_3;
  }
  int v4 = protocol_level;
  int v5 = *(void **)(a1 + 112);
  uint64_t v6 = MEMORY[0x1895F87A8];
  *(void *)uint64_t v51 = MEMORY[0x1895F87A8];
  *(void *)&v51[8] = 0x40000000LL;
  *(void *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
  BOOL v52 = (const char *)&unk_189BBCA88;
  uint64_t v54 = a1;
  __int16 v55 = &v47;
  p___int128 uu = &uu;
  nw_parameters_internal_iterate_protocol_stack(v5, 4, 0, v51);
  if (!*(_BYTE *)(*((void *)&uu + 1) + 24LL)) {
    goto LABEL_42;
  }
  if (!v47) {
    goto LABEL_3;
  }
  _Block_object_dispose(&uu, 8);
  *(void *)&__int128 uu = 0LL;
  *((void *)&uu + 1) = &uu;
  uint64_t v57 = 0x2000000000LL;
  char v58 = 1;
  if (v4 <= 3)
  {
    uint64_t v7 = *(void **)(a1 + 112);
    *(void *)uint64_t v51 = v6;
    *(void *)&v51[8] = 0x40000000LL;
    *(void *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
    BOOL v52 = (const char *)&unk_189BBCA88;
    uint64_t v54 = a1;
    __int16 v55 = &v47;
    p___int128 uu = &uu;
    nw_parameters_internal_iterate_protocol_stack(v7, 3, 0, v51);
    if (!*(_BYTE *)(*((void *)&uu + 1) + 24LL)) {
      goto LABEL_42;
    }
  }

  if (!v47) {
    goto LABEL_3;
  }
  _Block_object_dispose(&uu, 8);
  *(void *)&__int128 uu = 0LL;
  *((void *)&uu + 1) = &uu;
  uint64_t v57 = 0x2000000000LL;
  char v58 = 1;
  if (v4 <= 2)
  {
    uint64_t v8 = *(void **)(a1 + 112);
    *(void *)uint64_t v51 = v6;
    *(void *)&v51[8] = 0x40000000LL;
    *(void *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
    BOOL v52 = (const char *)&unk_189BBCA88;
    uint64_t v54 = a1;
    __int16 v55 = &v47;
    p___int128 uu = &uu;
    nw_parameters_internal_iterate_protocol_stack(v8, 2, 0, v51);
    if (!*(_BYTE *)(*((void *)&uu + 1) + 24LL)) {
      goto LABEL_42;
    }
  }

  if (!v47) {
    goto LABEL_3;
  }
  _Block_object_dispose(&uu, 8);
  *(void *)&__int128 uu = 0LL;
  *((void *)&uu + 1) = &uu;
  uint64_t v57 = 0x2000000000LL;
  char v58 = 1;
  if (v4 <= 1)
  {
    os_log_type_t v9 = *(void **)(a1 + 112);
    *(void *)uint64_t v51 = v6;
    *(void *)&v51[8] = 0x40000000LL;
    *(void *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
    BOOL v52 = (const char *)&unk_189BBCA88;
    uint64_t v54 = a1;
    __int16 v55 = &v47;
    p___int128 uu = &uu;
    nw_parameters_internal_iterate_protocol_stack(v9, 1, 0, v51);
    if (!*(_BYTE *)(*((void *)&uu + 1) + 24LL))
    {
LABEL_42:
      _Block_object_dispose(&uu, 8);
      return 0LL;
    }
  }

  if (!v47)
  {
LABEL_3:
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v3 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_reattach_protocols";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 284;
        __int16 v49 = 2080;
        uint64_t v50 = " ";
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to locate http_connect in protocol stack",  buf,  0x20u);
      }
    }

    *(_BYTE *)(*((void *)&uu + 1) + 24LL) = 0;
    goto LABEL_42;
  }

  _Block_object_dispose(&uu, 8);
  unsigned int v46 = 0;
  if (!nw_path_flow_registration_get_nexus_instance( *(NWConcrete_nw_path **)(a1 + 104),  *(NWConcrete_nw_path_flow_registration **)(a1 + 96),  &uu,  &v46))
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      __int16 v25 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v51 = 136446722;
        *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
        *(_WORD *)&v51[12] = 2082;
        *(void *)&v51[14] = a1 + 284;
        *(_WORD *)&v51[22] = 2080;
        BOOL v52 = " ";
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sNot restarting after disconnect because nexus is not ready",  v51,  0x20u);
      }
    }

    return 0LL;
  }

  int v45 = 0;
  uint64_t nexus_key = nw_path_flow_registration_get_nexus_key( *(NWConcrete_nw_path **)(a1 + 104),  *(NWConcrete_nw_path_flow_registration **)(a1 + 96),  &v45);
  *(void *)buf = 0LL;
  *(void *)&buf[8] = 0LL;
  char can_support_user_packet_pool = nw_path_flow_registration_can_support_user_packet_pool( *(void **)(a1 + 104),  *(void **)(a1 + 96));
  _BYTE buf[12] = buf[12] & 0xFE | can_support_user_packet_pool;
  else {
    char v12 = 0;
  }
  _BYTE buf[12] = buf[12] & 0xFD | v12;
  *(void *)buf = nexus_key;
  *(_DWORD *)&buf[8] = 16;
  id v13 = nw_path_copy_endpoint(*(void **)(a1 + 104));
  id v14 = nw_path_copy_parameters(*(void **)(a1 + 104));
  BOOL v15 = *(void **)(a1 + 128);
  if (v15)
  {
    os_release(v15);
    *(void *)(a1 + 128) = 0LL;
  }

  BOOL v16 = nw_parameters_copy_context(v14);
  uint64_t v17 = nw_channel_create_with_attributes(v16, (unsigned __int8 *)&uu, v46, (uint64_t)buf);
  *(void *)(a1 + 128) = v17;
  if (v16)
  {
    os_release(v16);
    uint64_t v17 = *(void *)(a1 + 128);
  }

  __int16 v18 = *(_WORD *)(a1 + 368);
  if (!v17)
  {
    if ((v18 & 0x80) == 0)
    {
      __int16 v26 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v51 = 136446722;
        *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
        *(_WORD *)&v51[12] = 2082;
        *(void *)&v51[14] = a1 + 284;
        *(_WORD *)&v51[22] = 2080;
        BOOL v52 = " ";
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sNot restarting after disconnect because failed to open channel",  v51,  0x20u);
      }
    }

    if (v13) {
      os_release(v13);
    }
    uint64_t v23 = 0LL;
    if (v14) {
      goto LABEL_77;
    }
    return v23;
  }

  if ((v18 & 0x80) == 0)
  {
    BOOL v19 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t v51 = 136446978;
      *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
      *(_WORD *)&v51[12] = 2082;
      *(void *)&v51[14] = a1 + 284;
      *(_WORD *)&v51[22] = 2080;
      BOOL v52 = " ";
      LOWORD(p_uu) = 1024;
      *(_DWORD *)((char *)&p_uu + 2) = v4;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sopened channel at level %u",  v51,  0x26u);
    }
  }

  nw_channel_set_close_automatically(*(void *)(a1 + 128), 1);
  nw_channel_set_defer_input_available(*(void *)(a1 + 128), 1);
  nw_channel_set_protocol_level(*(void *)(a1 + 128), v4);
  if (v4 == 2)
  {
    if (nw_protocol_ip_identifier::onceToken[0] != -1) {
      dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
    }
    if (nw_parameters_has_protocol_in_stack(v14, &nw_protocol_ip_identifier::identifier)
      && v13
      && nw_endpoint_get_type((nw_endpoint_t)v13) == nw_endpoint_type_address)
    {
      else {
        int v20 = 2;
      }
      char v21 = *(void **)(a1 + 96);
      if (nw_protocol_ip_identifier::onceToken[0] != -1) {
        dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
      }
      uint64_t stats_region = nw_channel_get_stats_region(*(void *)(a1 + 128), v20);
      nw_path_flow_registration_set_stats_region( v21,  2,  (__int128 *)&nw_protocol_ip_identifier::identifier,  stats_region);
    }
  }

  else if ((v4 & 0xFFFFFFFE) != 2)
  {
    goto LABEL_67;
  }

  os_log_type_t v27 = (void *)nw_protocol_tcp_identifier();
  if (!nw_parameters_has_protocol_in_stack(v14, v27))
  {
    if (nw_protocol_udp_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
    }
    if (nw_parameters_has_protocol_in_stack(v14, &nw_protocol_udp_identifier::identifier))
    {
      __int16 v33 = *(void **)(a1 + 96);
      if (nw_protocol_udp_identifier::onceToken == -1) {
        goto LABEL_65;
      }
    }

    else
    {
      upper_transport_protocol_identifier = (__int128 *)nw_parameters_get_upper_transport_protocol_identifier(v14);
      uint64_t v35 = *(void **)(a1 + 96);
      uint64_t v36 = nw_channel_get_stats_region(*(void *)(a1 + 128), 5);
      nw_path_flow_registration_set_stats_region(v35, 3, upper_transport_protocol_identifier, v36);
      __int16 v33 = *(void **)(a1 + 96);
      if (nw_protocol_udp_identifier::onceToken == -1) {
        goto LABEL_65;
      }
    }

    dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
LABEL_65:
    uint64_t v30 = nw_channel_get_stats_region(*(void *)(a1 + 128), 4);
    __int16 v32 = (__int128 *)&nw_protocol_udp_identifier::identifier;
    int v31 = v33;
    goto LABEL_66;
  }

  __int16 v28 = *(void **)(a1 + 96);
  uint64_t v29 = nw_protocol_tcp_identifier();
  uint64_t v30 = nw_channel_get_stats_region(*(void *)(a1 + 128), 3);
  int v31 = v28;
  __int16 v32 = (__int128 *)v29;
LABEL_66:
  nw_path_flow_registration_set_stats_region(v31, 3, v32, v30);
LABEL_67:
  uint64_t protocol_handler = nw_channel_get_protocol_handler(*(void *)(a1 + 128));
  if ((**(unsigned int (***)(void))(protocol_handler + 24))())
  {
    if (nw_channel_set_path_flow_registration(*(void *)(a1 + 128), *(void **)(a1 + 104), *(void **)(a1 + 96)))
    {
      nw_channel_set_keep_path_flow_registration_open(*(void *)(a1 + 128), *(void **)(a1 + 96));
      uint64_t v23 = 1LL;
      goto LABEL_74;
    }

    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      uint64_t v38 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v51 = 136446722;
        *(void *)&void v51[4] = "nw_http_connect_reattach_channel_protocol";
        *(_WORD *)&v51[12] = 2082;
        *(void *)&v51[14] = a1 + 284;
        *(_WORD *)&v51[22] = 2080;
        BOOL v52 = " ";
        _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sNot restarting after disconnect because unable to set path flow registration",  v51,  0x20u);
      }
    }
  }

  uint64_t v23 = 0LL;
LABEL_74:
  if (v13) {
    os_release(v13);
  }
  if (v14) {
LABEL_77:
  }
    os_release(v14);
  return v23;
}

uint64_t ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke( uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  uint64_t v7 = *(void *)(a1 + 40);
  if (!v7 || (*(_WORD *)(v7 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      BOOL v10 = v9 == 0;
      if (v9) {
        uint64_t v11 = (const char *)(v9 + 284);
      }
      else {
        uint64_t v11 = "";
      }
      *(_DWORD *)buf = 136446978;
      uint64_t v57 = "nw_http_connect_reattach_protocols_block_invoke";
      __int16 v58 = 2082;
      uint64_t v59 = (void *)v11;
      if (v10) {
        char v12 = "";
      }
      else {
        char v12 = " ";
      }
      __int16 v60 = 2080;
      uint64_t v61 = v12;
      __int16 v62 = 2114;
      id v63 = a3;
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sEnumerating protocol: %{public}@",  buf,  0x2Au);
    }
  }

  uint64_t v13 = **(void **)(a1 + 48);
  if (!v13)
  {
    if (nw_proxy_copy_http_connect_definition::onceToken != -1) {
      dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_92);
    }
    if (nw_protocol_definition_is_equal_unsafe( (uint64_t)a3,  (uint64_t)(id)nw_proxy_copy_http_connect_definition::proxy_definition))
    {
      uint64_t v29 = *(void *)(a1 + 40);
      if (!v29 || (*(_WORD *)(v29 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v30 = (os_log_s *)gLogObj;
        BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
        uint64_t v29 = *(void *)(a1 + 40);
        if (v31)
        {
          BOOL v32 = v29 == 0;
          if (v29) {
            __int16 v33 = (const char *)(v29 + 284);
          }
          else {
            __int16 v33 = "";
          }
          *(_DWORD *)buf = 136446978;
          uint64_t v57 = "nw_http_connect_reattach_protocols_block_invoke";
          __int16 v58 = 2082;
          uint64_t v59 = (void *)v33;
          __int128 v34 = " ";
          if (v32) {
            __int128 v34 = "";
          }
          __int16 v60 = 2080;
          uint64_t v61 = v34;
          __int16 v62 = 2114;
          id v63 = a3;
          _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRebuilding stack under protocol: %{public}@",  buf,  0x2Au);
          uint64_t v29 = *(void *)(a1 + 40);
        }
      }

      **(void **)(a1 + 48) = v29 + 24;
    }

    return 1LL;
  }

  uint64_t v14 = *(void *)(a1 + 40);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_http_connect_reattach_protocol";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_http_connect_reattach_protocol";
      uint64_t v47 = "%{public}s called with null http_connect";
    }

    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type;
      BOOL v49 = os_log_type_enabled(v45, type);
      if (backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v57 = "nw_http_connect_reattach_protocol";
          __int16 v58 = 2082;
          uint64_t v59 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s called with null http_connect, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_107:
        if (!v44) {
          goto LABEL_52;
        }
LABEL_108:
        free(v44);
        goto LABEL_52;
      }

      if (!v49) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_http_connect_reattach_protocol";
      uint64_t v47 = "%{public}s called with null http_connect, no backtrace";
    }

    else
    {
      int v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_107;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "nw_http_connect_reattach_protocol";
      uint64_t v47 = "%{public}s called with null http_connect, backtrace limit exceeded";
    }

    goto LABEL_106;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_http_connect_reattach_protocol";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v54)
      {
        int v45 = (os_log_s *)__nwlog_obj();
        os_log_type_t v46 = type;
        if (!os_log_type_enabled(v45, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "nw_http_connect_reattach_protocol";
        uint64_t v47 = "%{public}s called with null definition, backtrace limit exceeded";
        goto LABEL_106;
      }

      uint64_t v50 = (char *)__nw_create_backtrace_string();
      int v45 = (os_log_s *)__nwlog_obj();
      os_log_type_t v46 = type;
      BOOL v51 = os_log_type_enabled(v45, type);
      if (!v50)
      {
        if (!v51) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "nw_http_connect_reattach_protocol";
        uint64_t v47 = "%{public}s called with null definition, no backtrace";
        goto LABEL_106;
      }

      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v57 = "nw_http_connect_reattach_protocol";
        __int16 v58 = 2082;
        uint64_t v59 = v50;
        BOOL v52 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_91:
        _os_log_impl(&dword_181A5C000, v45, v46, v52, buf, 0x16u);
      }

BOOL nw_http_connect_in_async(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(_DWORD *)(a1 + 276) != 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "nw_http_connect_in_async";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_http_connect_in_async";
        int v5 = "%{public}s called with null http_connect";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "nw_http_connect_in_async";
          __int16 v12 = 2082;
          uint64_t v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null http_connect, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_http_connect_in_async";
        int v5 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_http_connect_in_async";
        int v5 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_http_connect_send_request(uint64_t a1, CFTypeRef cf)
{
  uint64_t v173 = *MEMORY[0x1895F89C0];
  if (!a1 || (*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v133 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
      {
        BOOL v134 = " ";
        uint64_t v135 = (const char *)(a1 + 284);
        *(void *)&uint8_t buf[4] = "nw_http_connect_send_request";
        *(_DWORD *)buf = 136446722;
        if (!a1)
        {
          BOOL v134 = "";
          uint64_t v135 = "";
        }

        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v135;
        *(_WORD *)&_BYTE buf[22] = 2080;
        int v171 = v134;
        _os_log_impl(&dword_181A5C000, v133, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }

    if (!a1)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_connect_send_request";
      uint64_t v129 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v161[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v130 = (os_log_s *)__nwlog_obj();
        os_log_type_t v131 = type[0];
        if (!os_log_type_enabled(v130, type[0])) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connect_send_request";
        uint64_t v132 = "%{public}s called with null http_connect";
      }

      else if (v161[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v130 = (os_log_s *)__nwlog_obj();
        os_log_type_t v131 = type[0];
        BOOL v137 = os_log_type_enabled(v130, type[0]);
        if (backtrace_string)
        {
          if (v137)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_connect_send_request";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v130,  v131,  "%{public}s called with null http_connect, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_324;
        }

        if (!v137)
        {
LABEL_324:
          if (v129) {
            free(v129);
          }
          return 0LL;
        }

        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connect_send_request";
        uint64_t v132 = "%{public}s called with null http_connect, no backtrace";
      }

      else
      {
        uint64_t v130 = (os_log_s *)__nwlog_obj();
        os_log_type_t v131 = type[0];
        if (!os_log_type_enabled(v130, type[0])) {
          goto LABEL_324;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connect_send_request";
        uint64_t v132 = "%{public}s called with null http_connect, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v130, v131, v132, buf, 0xCu);
      goto LABEL_324;
    }
  }

  if (cf)
  {
    Request = (__CFHTTPMessage *)CFRetain(cf);
    goto LABEL_7;
  }

  if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v144 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v144, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 284;
        *(_WORD *)&_BYTE buf[22] = 2080;
        int v171 = " ";
        _os_log_impl(&dword_181A5C000, v144, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
  }

  nw_endpoint_type_t v26 = nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 144));
  if (v26 == nw_endpoint_type_address)
  {
    uint64_t v29 = nw_endpoint_copy_address_string(*(nw_endpoint_t *)(a1 + 144));
    hostname = 0LL;
  }

  else
  {
    nw_endpoint_type_t v27 = v26;
    if (v26 != nw_endpoint_type_host)
    {
      if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v48 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http_connect_create_request";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = a1 + 284;
          *(_WORD *)&_BYTE buf[22] = 2080;
          int v171 = " ";
          LOWORD(v172) = 1024;
          *(_DWORD *)((char *)&v172 + 2) = v27;
          BOOL v49 = "%{public}s %{public}s%sUnsupported endpoint type: %d";
          uint64_t v50 = (os_log_s *)v48;
          uint32_t v51 = 38;
LABEL_85:
          _os_log_impl(&dword_181A5C000, v50, OS_LOG_TYPE_ERROR, v49, buf, v51);
        }
      }

void sub_1820E6CC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL26nw_http_connect_send_bytesP24nw_protocol_http_connectPKhj_block_invoke( uint64_t a1, uint64_t a2)
{
  return 1LL;
}

BOOL ___ZL36nw_http_connect_process_inbound_dataP24nw_protocol_http_connect_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v175 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v168 = "nw_http_connect_process_inbound_data_block_invoke";
    int v154 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v165 = 0;
    if (__nwlog_fault(v154, &type, &v165))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v155 = (os_log_s *)__nwlog_obj();
        os_log_type_t v156 = type;
        if (os_log_type_enabled(v155, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v168 = "nw_http_connect_process_inbound_data_block_invoke";
          uint64_t v157 = "%{public}s called with null frame";
LABEL_271:
          _os_log_impl(&dword_181A5C000, v155, v156, v157, buf, 0xCu);
        }
      }

      else if (v165)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v155 = (os_log_s *)__nwlog_obj();
        os_log_type_t v156 = type;
        BOOL v163 = os_log_type_enabled(v155, type);
        if (backtrace_string)
        {
          if (v163)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v168 = "nw_http_connect_process_inbound_data_block_invoke";
            __int16 v169 = 2082;
            char v170 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v155,  v156,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_272;
        }

        if (v163)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v168 = "nw_http_connect_process_inbound_data_block_invoke";
          uint64_t v157 = "%{public}s called with null frame, no backtrace";
          goto LABEL_271;
        }
      }

      else
      {
        uint64_t v155 = (os_log_s *)__nwlog_obj();
        os_log_type_t v156 = type;
        if (os_log_type_enabled(v155, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v168 = "nw_http_connect_process_inbound_data_block_invoke";
          uint64_t v157 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_271;
        }
      }
    }

void nw_http_connect_send_auth_request(uint64_t a1)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)int v34 = 0LL;
    uint64_t v35 = v34;
    uint64_t v36 = 0x2000000000LL;
    unsigned int v2 = *(void **)(a1 + 168);
    if (v2) {
      unsigned int v2 = os_retain(v2);
    }
    os_log_type_t v37 = v2;
    if (!*(void *)(a1 + 176) || *(_DWORD *)(a1 + 272))
    {
      Mutable = 0LL;
      os_log_type_t v4 = *(const void **)(a1 + 208);
      if (!v4) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }

    int v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    if (Mutable)
    {
      username = (const char *)nw_authentication_credential_get_username(*(void **)(a1 + 176));
      if (!username)
      {
        nw_authentication_credential_get_password(*(void **)(a1 + 176));
        goto LABEL_71;
      }

      CFStringRef v8 = CFStringCreateWithCString(v6, username, 0x8000100u);
      if (v8)
      {
        CFStringRef v9 = v8;
        CFDictionarySetValue(Mutable, @"kCFHTTPAuthenticationUsername", v8);
        CFRelease(v9);
        goto LABEL_51;
      }

      if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
      {
LABEL_51:
        password = (const char *)nw_authentication_credential_get_password(*(void **)(a1 + 176));
        CFStringRef v23 = CFStringCreateWithCString(v6, password, 0x8000100u);
        if (v23)
        {
          CFStringRef v24 = v23;
          CFDictionarySetValue(Mutable, @"kCFHTTPAuthenticationPassword", v23);
          CFRelease(v24);
          goto LABEL_71;
        }

        if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446722;
          os_log_type_t v40 = "nw_http_connect_send_auth_request";
          __int16 v41 = 2082;
          uint64_t v42 = (char *)(a1 + 284);
          __int16 v43 = 2080;
          BOOL v44 = " ";
          BOOL v10 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v33 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v11 = (os_log_s *)__nwlog_obj();
            os_log_type_t v12 = type;
            if (!os_log_type_enabled(v11, type)) {
              goto LABEL_69;
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v40 = "nw_http_connect_send_auth_request";
            __int16 v41 = 2082;
            uint64_t v42 = (char *)(a1 + 284);
            __int16 v43 = 2080;
            BOOL v44 = " ";
            unsigned int v13 = "%{public}s %{public}s%sCFStringCreateWithCString failed";
            goto LABEL_68;
          }

          if (!v33)
          {
            os_log_type_t v11 = (os_log_s *)__nwlog_obj();
            os_log_type_t v12 = type;
            if (!os_log_type_enabled(v11, type)) {
              goto LABEL_69;
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v40 = "nw_http_connect_send_auth_request";
            __int16 v41 = 2082;
            uint64_t v42 = (char *)(a1 + 284);
            __int16 v43 = 2080;
            BOOL v44 = " ";
            unsigned int v13 = "%{public}s %{public}s%sCFStringCreateWithCString failed, backtrace limit exceeded";
            goto LABEL_68;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v11 = (os_log_s *)__nwlog_obj();
          os_log_type_t v12 = type;
          BOOL v26 = os_log_type_enabled(v11, type);
          if (!backtrace_string)
          {
            if (!v26) {
              goto LABEL_69;
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v40 = "nw_http_connect_send_auth_request";
            __int16 v41 = 2082;
            uint64_t v42 = (char *)(a1 + 284);
            __int16 v43 = 2080;
            BOOL v44 = " ";
            unsigned int v13 = "%{public}s %{public}s%sCFStringCreateWithCString failed, no backtrace";
            goto LABEL_68;
          }

          if (v26)
          {
            *(_DWORD *)buf = 136446978;
            os_log_type_t v40 = "nw_http_connect_send_auth_request";
            __int16 v41 = 2082;
            uint64_t v42 = (char *)(a1 + 284);
            __int16 v43 = 2080;
            BOOL v44 = " ";
            __int16 v45 = 2082;
            uint64_t v46 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %{public}s%sCFStringCreateWithCString failed, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          if (v10) {
LABEL_70:
          }
            free(v10);
        }

void ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke( uint64_t a1, char *object, int a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6 || (*(_WORD *)(v6 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      BOOL v9 = v8 == 0;
      if (v8) {
        BOOL v10 = (const char *)(v8 + 284);
      }
      else {
        BOOL v10 = "";
      }
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http_connect_send_auth_challenge_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v10;
      if (v9) {
        os_log_type_t v11 = "";
      }
      else {
        os_log_type_t v11 = " ";
      }
      *(_WORD *)&_BYTE buf[22] = 2080;
      os_log_type_t v18 = v11;
      __int16 v19 = 1024;
      int v20 = a3;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect returned from challenge handler, cancel is %d",  buf,  0x26u);
    }
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  os_log_type_t v18 = object;
  if (object) {
    os_retain(object);
  }
  uint64_t v12 = *(void *)(a1 + 40);
  unsigned int v13 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  v15[0] = MEMORY[0x1895F87A8];
  void v15[2] = ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke_65;
  v15[3] = &unk_189BBCAD8;
  v15[1] = 0x40000000LL;
  v15[4] = buf;
  void v15[5] = v12;
  char v16 = a3;
  nw_queue_context_async_if_needed(v13, v15);
  int v14 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v14)
  {
    os_release(v14);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  _Block_object_dispose(buf, 8);
}

void ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke_65(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2 || (*(_WORD *)(v2 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = (os_log_s *)gLogObj;
    BOOL v4 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    uint64_t v2 = *(void *)(a1 + 40);
    if (v4)
    {
      uint64_t v5 = "";
      uint64_t v6 = (const char *)(v2 + 284);
      if (!v2) {
        uint64_t v6 = "";
      }
      int v18 = 136446722;
      __int16 v19 = "nw_http_connect_send_auth_challenge_block_invoke";
      if (v2) {
        uint64_t v5 = " ";
      }
      __int16 v20 = 2082;
      uint64_t v21 = v6;
      __int16 v22 = 2080;
      CFStringRef v23 = v5;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect returned from challenge handler async",  (uint8_t *)&v18,  0x20u);
      uint64_t v2 = *(void *)(a1 + 40);
    }
  }

  if (nw_http_connect_end_async(v2))
  {
    if (*(_BYTE *)(a1 + 48))
    {
      nw_http_connect_fail(*(void *)(a1 + 40), 80);
    }

    else
    {
      uint64_t v14 = *(void *)(a1 + 40);
      BOOL v15 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v15)
      {
        char v16 = *(void **)(v14 + 176);
        if (!v16
          || (os_release(v16),
              *(void *)(*(void *)(a1 + 40) + 176LL) = 0LL,
              (BOOL v15 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) != 0LL))
        {
          BOOL v15 = os_retain(v15);
        }

        *(void *)(*(void *)(a1 + 40) + 176LL) = v15;
        uint64_t v14 = *(void *)(a1 + 40);
        *(_DWORD *)(v14 + 272) = 0;
      }

      nw_http_connect_send_auth_request(v14);
    }

    uint64_t v17 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v17)
    {
      os_release(v17);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }
  }

  else
  {
    uint64_t v7 = *(void *)(a1 + 40);
    if (!v7 || (*(_WORD *)(v7 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = *(void *)(a1 + 40);
        BOOL v10 = "";
        BOOL v11 = v9 == 0;
        if (v9) {
          uint64_t v12 = (const char *)(v9 + 284);
        }
        else {
          uint64_t v12 = "";
        }
        int v18 = 136446722;
        __int16 v19 = "nw_http_connect_send_auth_challenge_block_invoke";
        if (!v11) {
          BOOL v10 = " ";
        }
        __int16 v20 = 2082;
        uint64_t v21 = v12;
        __int16 v22 = 2080;
        CFStringRef v23 = v10;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sStopping proxy authorization because state has changed to destroyed while getting authe ntication credentials",  (uint8_t *)&v18,  0x20u);
      }
    }

    unsigned int v13 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v13)
    {
      os_release(v13);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }

    nw_http_connect_destroy(*(void *)(a1 + 40));
  }

void ___ZL33nw_http_connect_send_auth_requestP24nw_protocol_http_connect_block_invoke( uint64_t a1, const char *cf, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v8 = *(void *)(a1 + 40);
  if (!v8 || (*(_WORD *)(v8 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = *(void *)(a1 + 40);
      BOOL v11 = "";
      BOOL v12 = v10 == 0;
      if (v10) {
        unsigned int v13 = (const char *)(v10 + 284);
      }
      else {
        unsigned int v13 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_http_connect_send_auth_request_block_invoke";
      if (!v12) {
        BOOL v11 = " ";
      }
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v13;
      *(_WORD *)&_BYTE buf[22] = 2080;
      __int16 v19 = v11;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect returned from proxy authorization",  buf,  0x20u);
    }
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  __int16 v19 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v14 = *(void *)(a1 + 40);
  BOOL v15 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  v17[0] = MEMORY[0x1895F87A8];
  v17[2] = ___ZL33nw_http_connect_send_auth_requestP24nw_protocol_http_connect_block_invoke_29;
  v17[3] = &unk_189BBC9F0;
  v17[1] = 0x40000000LL;
  void v17[4] = buf;
  void v17[5] = v14;
  _BYTE v17[6] = a3;
  v17[7] = a4;
  nw_queue_context_async_if_needed(v15, v17);
  char v16 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v16)
  {
    os_release(v16);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  _Block_object_dispose(buf, 8);
}

void ___ZL33nw_http_connect_send_auth_requestP24nw_protocol_http_connect_block_invoke_29(uint64_t a1)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2 || (*(_WORD *)(v2 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = (os_log_s *)gLogObj;
    BOOL v4 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    uint64_t v2 = *(void *)(a1 + 40);
    if (v4)
    {
      uint64_t v5 = "";
      BOOL v6 = v2 == 0;
      if (v2) {
        uint64_t v7 = (const char *)(v2 + 284);
      }
      else {
        uint64_t v7 = "";
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
      if (!v6) {
        uint64_t v5 = " ";
      }
      __int16 v59 = 2082;
      BOOL v60 = v7;
      __int16 v61 = 2080;
      uint32_t v62 = (void *)v5;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect returned from proxy authorization async",  buf,  0x20u);
      uint64_t v2 = *(void *)(a1 + 40);
    }
  }

  *(void *)(v2 + 208) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  BOOL v8 = nw_http_connect_end_async(*(void *)(a1 + 40));
  uint64_t v9 = *(void *)(a1 + 40);
  if (!v8)
  {
    if (!v9 || (*(_WORD *)(v9 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      uint64_t v9 = *(void *)(a1 + 40);
      if (v18)
      {
        __int16 v19 = "";
        uint64_t v20 = (const char *)(v9 + 284);
        if (!v9) {
          uint64_t v20 = "";
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
        if (v9) {
          __int16 v19 = " ";
        }
        __int16 v59 = 2082;
        BOOL v60 = v20;
        __int16 v61 = 2080;
        uint32_t v62 = (void *)v19;
        _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sStopping proxy authorization because state has changed to destroyed while getting signed request",  buf,  0x20u);
        uint64_t v9 = *(void *)(a1 + 40);
      }
    }

    nw_http_connect_destroy(v9);
    return;
  }

  uint64_t v10 = *(void *)(v9 + 168);
  if ((!v10 || *(_DWORD *)(v10 + 124) != 4) && (*(_WORD *)(v9 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = (os_log_s *)gLogObj;
    BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    uint64_t v9 = *(void *)(a1 + 40);
    if (v12)
    {
      unsigned int v13 = (const char *)(v9 + 284);
      uint64_t v14 = "";
      if (!v9) {
        unsigned int v13 = "";
      }
      uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v9) {
        uint64_t v14 = " ";
      }
      int v16 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136447234;
      uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
      __int16 v59 = 2082;
      BOOL v60 = v13;
      __int16 v61 = 2080;
      uint32_t v62 = (void *)v14;
      __int16 v63 = 2048;
      uint64_t v64 = v15;
      __int16 v65 = 1024;
      int v66 = v16;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect proxy authentication received request %p error %d",  buf,  0x30u);
      uint64_t v9 = *(void *)(a1 + 40);
    }
  }

  if (*(_DWORD *)(a1 + 56))
  {
    if (!v9) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

  uint64_t v21 = *(const void **)(v9 + 208);
  if (!v21)
  {
LABEL_37:
    if ((*(_WORD *)(v9 + 368) & 0x80) != 0)
    {
LABEL_44:
      if (*(void *)(a1 + 48) == 1LL) {
        int v24 = *(_DWORD *)(a1 + 56);
      }
      else {
        int v24 = 80;
      }
      uint64_t v23 = *(void *)(a1 + 40);
      goto LABEL_48;
    }

uint64_t NWPBParametersReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  uint64_t v4 = (int)*MEMORY[0x189611CF0];
  unint64_t v5 = *(void *)(a2 + v4);
  BOOL v6 = (int *)MEMORY[0x189611CE8];
  unint64_t v7 = *(void *)(a2 + (int)*MEMORY[0x189611CE8]);
  BOOL v8 = (int *)MEMORY[0x189611CE0];
  if (v5 >= v7) {
    return *(_BYTE *)(a2 + *v8) == 0;
  }
  uint64_t v10 = (int *)MEMORY[0x189611CD8];
  while (1)
  {
    uint64_t v14 = (_BYTE *)(a2 + *v8);
    if (*v14) {
      return *(_BYTE *)(a2 + *v8) == 0;
    }
    if (v5 >= v7) {
      break;
    }
    char v15 = *(_BYTE *)(*(void *)(a2 + *v10) + v5);
    *(void *)(a2 + (int)v4) = v5 + 1;
    unint64_t v16 = v15 & 0x7F;
    if ((v15 & 0x80) == 0) {
      goto LABEL_40;
    }
    uint64_t v17 = *v3;
    unint64_t v18 = *(void *)(a2 + v17);
    if (v18 == -1LL || v18 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v19 = v18 + 1;
    int v20 = *(char *)(*(void *)(a2 + *v10) + v18);
    *(void *)(a2 + v17) = v19;
    v16 |= (unint64_t)(v20 & 0x7F) << 7;
    if ((v20 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v21 = *v3;
    unint64_t v22 = *(void *)(a2 + v21);
    if (v22 == -1LL || v22 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v23 = v22 + 1;
    int v24 = *(char *)(*(void *)(a2 + *v10) + v22);
    *(void *)(a2 + v21) = v23;
    v16 |= (unint64_t)(v24 & 0x7F) << 14;
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v25 = *v3;
    unint64_t v26 = *(void *)(a2 + v25);
    if (v26 == -1LL || v26 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v27 = v26 + 1;
    int v28 = *(char *)(*(void *)(a2 + *v10) + v26);
    *(void *)(a2 + v25) = v27;
    v16 |= (unint64_t)(v28 & 0x7F) << 21;
    if ((v28 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v29 = *v3;
    unint64_t v30 = *(void *)(a2 + v29);
    if (v30 == -1LL || v30 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v31 = v30 + 1;
    int v32 = *(char *)(*(void *)(a2 + *v10) + v30);
    *(void *)(a2 + v29) = v31;
    v16 |= (unint64_t)(v32 & 0x7F) << 28;
    if ((v32 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v33 = *v3;
    unint64_t v34 = *(void *)(a2 + v33);
    if (v34 == -1LL || v34 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v35 = v34 + 1;
    int v36 = *(char *)(*(void *)(a2 + *v10) + v34);
    *(void *)(a2 + v33) = v35;
    if ((v36 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v37 = *v3;
    unint64_t v38 = *(void *)(a2 + v37);
    if (v38 == -1LL || v38 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v39 = v38 + 1;
    int v40 = *(char *)(*(void *)(a2 + *v10) + v38);
    *(void *)(a2 + v37) = v39;
    if ((v40 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v41 = *v3;
    unint64_t v42 = *(void *)(a2 + v41);
    if (v42 == -1LL || v42 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v43 = v42 + 1;
    int v44 = *(char *)(*(void *)(a2 + *v10) + v42);
    *(void *)(a2 + v41) = v43;
    if ((v44 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v45 = *v3;
    unint64_t v46 = *(void *)(a2 + v45);
    if (v46 == -1LL || v46 >= *(void *)(a2 + *v6)) {
      goto LABEL_38;
    }
    unint64_t v47 = v46 + 1;
    int v48 = *(char *)(*(void *)(a2 + *v10) + v46);
    *(void *)(a2 + v45) = v47;
    if ((v48 & 0x80000000) == 0) {
      goto LABEL_40;
    }
    uint64_t v49 = *v3;
    unint64_t v50 = *(void *)(a2 + v49);
    if (v50 == -1LL || v50 >= *(void *)(a2 + *v6))
    {
LABEL_38:
      uint64_t v14 = (_BYTE *)(a2 + *v8);
      goto LABEL_39;
    }

    unint64_t v51 = v50 + 1;
    int v52 = *(char *)(*(void *)(a2 + *v10) + v50);
    *(void *)(a2 + v49) = v51;
    if (v52 < 0)
    {
      unint64_t v16 = 0LL;
      uint64_t v53 = *v8;
      int v54 = *(unsigned __int8 *)(a2 + v53);
      goto LABEL_42;
    }

LABEL_663:
        if (*(_BYTE *)(a2 + *v8)) {
          unsigned int v394 = 0;
        }
LABEL_665:
        *(_DWORD *)(a1 + 88) = v394;
        goto LABEL_5;
      case 7u:
        *(_WORD *)(a1 + 196) |= 1u;
        uint64_t v469 = *v3;
        unint64_t v470 = *(void *)(a2 + v469);
        if (v470 == -1LL || v470 >= *(void *)(a2 + *v6))
        {
          unsigned int v473 = 0;
LABEL_672:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_673;
        }

        unint64_t v471 = v470 + 1;
        char v472 = *(_BYTE *)(*(void *)(a2 + *v10) + v470);
        *(void *)(a2 + v469) = v471;
        unsigned int v473 = v472 & 0x7F;
        if ((v472 & 0x80) == 0) {
          goto LABEL_673;
        }
        uint64_t v474 = *v3;
        unint64_t v475 = *(void *)(a2 + v474);
        if (v475 == -1LL || v475 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        int v476 = *(char *)(*(void *)(a2 + *v10) + v475);
        *(void *)(a2 + v474) = v475 + 1;
        unsigned int v473 = v473 & 0xFFFFC07F | ((v476 & 0x7F) << 7);
        if ((v476 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v477 = *v3;
        unint64_t v478 = *(void *)(a2 + v477);
        if (v478 == -1LL || v478 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        int v479 = *(char *)(*(void *)(a2 + *v10) + v478);
        *(void *)(a2 + v477) = v478 + 1;
        unsigned int v473 = v473 & 0xFFE03FFF | ((v479 & 0x7F) << 14);
        if ((v479 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v480 = *v3;
        unint64_t v481 = *(void *)(a2 + v480);
        if (v481 == -1LL || v481 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        int v482 = *(char *)(*(void *)(a2 + *v10) + v481);
        *(void *)(a2 + v480) = v481 + 1;
        unsigned int v473 = v473 & 0xF01FFFFF | ((v482 & 0x7F) << 21);
        if ((v482 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v483 = *v3;
        unint64_t v484 = *(void *)(a2 + v483);
        if (v484 == -1LL || v484 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        unint64_t v485 = v484 + 1;
        int v486 = *(char *)(*(void *)(a2 + *v10) + v484);
        *(void *)(a2 + v483) = v485;
        v473 |= v486 << 28;
        if ((v486 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v487 = *v3;
        unint64_t v488 = *(void *)(a2 + v487);
        if (v488 == -1LL || v488 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        unint64_t v489 = v488 + 1;
        int v490 = *(char *)(*(void *)(a2 + *v10) + v488);
        *(void *)(a2 + v487) = v489;
        if ((v490 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v491 = *v3;
        unint64_t v492 = *(void *)(a2 + v491);
        if (v492 == -1LL || v492 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        unint64_t v493 = v492 + 1;
        int v494 = *(char *)(*(void *)(a2 + *v10) + v492);
        *(void *)(a2 + v491) = v493;
        if ((v494 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v495 = *v3;
        unint64_t v496 = *(void *)(a2 + v495);
        if (v496 == -1LL || v496 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        unint64_t v497 = v496 + 1;
        int v498 = *(char *)(*(void *)(a2 + *v10) + v496);
        *(void *)(a2 + v495) = v497;
        if ((v498 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v499 = *v3;
        unint64_t v500 = *(void *)(a2 + v499);
        if (v500 == -1LL || v500 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        unint64_t v501 = v500 + 1;
        int v502 = *(char *)(*(void *)(a2 + *v10) + v500);
        *(void *)(a2 + v499) = v501;
        if ((v502 & 0x80000000) == 0) {
          goto LABEL_673;
        }
        uint64_t v503 = *v3;
        unint64_t v504 = *(void *)(a2 + v503);
        if (v504 == -1LL || v504 >= *(void *)(a2 + *v6)) {
          goto LABEL_672;
        }
        unint64_t v505 = v504 + 1;
        int v506 = *(char *)(*(void *)(a2 + *v10) + v504);
        *(void *)(a2 + v503) = v505;
        if (v506 < 0)
        {
          unsigned int v473 = 0;
          goto LABEL_675;
        }

LABEL_673:
        if (*(_BYTE *)(a2 + *v8)) {
          unsigned int v473 = 0;
        }
LABEL_675:
        *(_DWORD *)(a1 + 64) = v473;
        goto LABEL_5;
      case 8u:
        *(_WORD *)(a1 + 196) |= 0x20u;
        uint64_t v311 = *v3;
        unint64_t v312 = *(void *)(a2 + v311);
        if (v312 == -1LL || v312 >= *(void *)(a2 + *v6))
        {
          unsigned int v315 = 0;
LABEL_652:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_653;
        }

        unint64_t v313 = v312 + 1;
        char v314 = *(_BYTE *)(*(void *)(a2 + *v10) + v312);
        *(void *)(a2 + v311) = v313;
        unsigned int v315 = v314 & 0x7F;
        if ((v314 & 0x80) == 0) {
          goto LABEL_653;
        }
        uint64_t v316 = *v3;
        unint64_t v317 = *(void *)(a2 + v316);
        if (v317 == -1LL || v317 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        int v318 = *(char *)(*(void *)(a2 + *v10) + v317);
        *(void *)(a2 + v316) = v317 + 1;
        unsigned int v315 = v315 & 0xFFFFC07F | ((v318 & 0x7F) << 7);
        if ((v318 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v319 = *v3;
        unint64_t v320 = *(void *)(a2 + v319);
        if (v320 == -1LL || v320 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        int v321 = *(char *)(*(void *)(a2 + *v10) + v320);
        *(void *)(a2 + v319) = v320 + 1;
        unsigned int v315 = v315 & 0xFFE03FFF | ((v321 & 0x7F) << 14);
        if ((v321 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v322 = *v3;
        unint64_t v323 = *(void *)(a2 + v322);
        if (v323 == -1LL || v323 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        int v324 = *(char *)(*(void *)(a2 + *v10) + v323);
        *(void *)(a2 + v322) = v323 + 1;
        unsigned int v315 = v315 & 0xF01FFFFF | ((v324 & 0x7F) << 21);
        if ((v324 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v325 = *v3;
        unint64_t v326 = *(void *)(a2 + v325);
        if (v326 == -1LL || v326 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        unint64_t v327 = v326 + 1;
        int v328 = *(char *)(*(void *)(a2 + *v10) + v326);
        *(void *)(a2 + v325) = v327;
        v315 |= v328 << 28;
        if ((v328 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v329 = *v3;
        unint64_t v330 = *(void *)(a2 + v329);
        if (v330 == -1LL || v330 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        unint64_t v331 = v330 + 1;
        int v332 = *(char *)(*(void *)(a2 + *v10) + v330);
        *(void *)(a2 + v329) = v331;
        if ((v332 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v333 = *v3;
        unint64_t v334 = *(void *)(a2 + v333);
        if (v334 == -1LL || v334 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        unint64_t v335 = v334 + 1;
        int v336 = *(char *)(*(void *)(a2 + *v10) + v334);
        *(void *)(a2 + v333) = v335;
        if ((v336 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v337 = *v3;
        unint64_t v338 = *(void *)(a2 + v337);
        if (v338 == -1LL || v338 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        unint64_t v339 = v338 + 1;
        int v340 = *(char *)(*(void *)(a2 + *v10) + v338);
        *(void *)(a2 + v337) = v339;
        if ((v340 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v341 = *v3;
        unint64_t v342 = *(void *)(a2 + v341);
        if (v342 == -1LL || v342 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        unint64_t v343 = v342 + 1;
        int v344 = *(char *)(*(void *)(a2 + *v10) + v342);
        *(void *)(a2 + v341) = v343;
        if ((v344 & 0x80000000) == 0) {
          goto LABEL_653;
        }
        uint64_t v345 = *v3;
        unint64_t v346 = *(void *)(a2 + v345);
        if (v346 == -1LL || v346 >= *(void *)(a2 + *v6)) {
          goto LABEL_652;
        }
        unint64_t v347 = v346 + 1;
        int v348 = *(char *)(*(void *)(a2 + *v10) + v346);
        *(void *)(a2 + v345) = v347;
        if (v348 < 0)
        {
          unsigned int v315 = 0;
          goto LABEL_655;
        }

            __nwlog_obj();
            *(_DWORD *)uint64_t v398 = 136446210;
            *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
            uint64_t v333 = (char *)_os_log_send_and_compose_impl();
            v394[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            if (v394[0] == OS_LOG_TYPE_FAULT)
            {
              unint64_t v334 = (os_log_s *)__nwlog_obj();
              unint64_t v335 = v394[0];
              if (!os_log_type_enabled(v334, v394[0])) {
                goto LABEL_761;
              }
              *(_DWORD *)uint64_t v398 = 136446210;
              *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
              int v336 = "%{public}s called with null http1_connection->context";
              goto LABEL_759;
            }

            if (type == OS_LOG_TYPE_DEFAULT)
            {
              unint64_t v334 = (os_log_s *)__nwlog_obj();
              unint64_t v335 = v394[0];
              if (!os_log_type_enabled(v334, v394[0])) {
                goto LABEL_761;
              }
              *(_DWORD *)uint64_t v398 = 136446210;
              *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
              int v336 = "%{public}s called with null http1_connection->context, backtrace limit exceeded";
              goto LABEL_759;
            }

            unint64_t v367 = (char *)__nw_create_backtrace_string();
            unint64_t v334 = (os_log_s *)__nwlog_obj();
            unint64_t v335 = v394[0];
            uint64_t v370 = os_log_type_enabled(v334, v394[0]);
            if (!v367)
            {
              if (!v370) {
                goto LABEL_761;
              }
              *(_DWORD *)uint64_t v398 = 136446210;
              *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
              int v336 = "%{public}s called with null http1_connection->context, no backtrace";
              goto LABEL_759;
            }

            if (v370)
            {
              *(_DWORD *)uint64_t v398 = 136446466;
              *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
              *(_WORD *)&v398[12] = 2082;
              *(void *)&v398[14] = v367;
              int v369 = "%{public}s called with null http1_connection->context, dumping backtrace:%{public}s";
              goto LABEL_714;
            }

LABEL_653:
        if (*(_BYTE *)(a2 + *v8)) {
          unsigned int v315 = 0;
        }
LABEL_655:
        *(_DWORD *)(a1 + 172) = v315;
        goto LABEL_5;
      case 9u:
        *(_WORD *)(a1 + 196) |= 2u;
        uint64_t v545 = *v3;
        unint64_t v546 = *(void *)(a2 + v545);
        if (v546 == -1LL || v546 >= *(void *)(a2 + *v6))
        {
          unsigned int v549 = 0;
LABEL_687:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_688;
        }

        unint64_t v547 = v546 + 1;
        char v548 = *(_BYTE *)(*(void *)(a2 + *v10) + v546);
        *(void *)(a2 + v545) = v547;
        unsigned int v549 = v548 & 0x7F;
        if ((v548 & 0x80) == 0) {
          goto LABEL_688;
        }
        uint64_t v550 = *v3;
        unint64_t v551 = *(void *)(a2 + v550);
        if (v551 == -1LL || v551 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        int v552 = *(char *)(*(void *)(a2 + *v10) + v551);
        *(void *)(a2 + v550) = v551 + 1;
        unsigned int v549 = v549 & 0xFFFFC07F | ((v552 & 0x7F) << 7);
        if ((v552 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v553 = *v3;
        unint64_t v554 = *(void *)(a2 + v553);
        if (v554 == -1LL || v554 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        int v555 = *(char *)(*(void *)(a2 + *v10) + v554);
        *(void *)(a2 + v553) = v554 + 1;
        unsigned int v549 = v549 & 0xFFE03FFF | ((v555 & 0x7F) << 14);
        if ((v555 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v556 = *v3;
        unint64_t v557 = *(void *)(a2 + v556);
        if (v557 == -1LL || v557 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        int v558 = *(char *)(*(void *)(a2 + *v10) + v557);
        *(void *)(a2 + v556) = v557 + 1;
        unsigned int v549 = v549 & 0xF01FFFFF | ((v558 & 0x7F) << 21);
        if ((v558 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v559 = *v3;
        unint64_t v560 = *(void *)(a2 + v559);
        if (v560 == -1LL || v560 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        unint64_t v561 = v560 + 1;
        int v562 = *(char *)(*(void *)(a2 + *v10) + v560);
        *(void *)(a2 + v559) = v561;
        v549 |= v562 << 28;
        if ((v562 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v563 = *v3;
        unint64_t v564 = *(void *)(a2 + v563);
        if (v564 == -1LL || v564 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        unint64_t v565 = v564 + 1;
        int v566 = *(char *)(*(void *)(a2 + *v10) + v564);
        *(void *)(a2 + v563) = v565;
        if ((v566 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v567 = *v3;
        unint64_t v568 = *(void *)(a2 + v567);
        if (v568 == -1LL || v568 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        unint64_t v569 = v568 + 1;
        int v570 = *(char *)(*(void *)(a2 + *v10) + v568);
        *(void *)(a2 + v567) = v569;
        if ((v570 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v571 = *v3;
        unint64_t v572 = *(void *)(a2 + v571);
        if (v572 == -1LL || v572 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        unint64_t v573 = v572 + 1;
        int v574 = *(char *)(*(void *)(a2 + *v10) + v572);
        *(void *)(a2 + v571) = v573;
        if ((v574 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v575 = *v3;
        unint64_t v576 = *(void *)(a2 + v575);
        if (v576 == -1LL || v576 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        unint64_t v577 = v576 + 1;
        int v578 = *(char *)(*(void *)(a2 + *v10) + v576);
        *(void *)(a2 + v575) = v577;
        if ((v578 & 0x80000000) == 0) {
          goto LABEL_688;
        }
        uint64_t v579 = *v3;
        unint64_t v580 = *(void *)(a2 + v579);
        if (v580 == -1LL || v580 >= *(void *)(a2 + *v6)) {
          goto LABEL_687;
        }
        unint64_t v581 = v580 + 1;
        int v582 = *(char *)(*(void *)(a2 + *v10) + v580);
        *(void *)(a2 + v579) = v581;
        if (v582 < 0)
        {
          unsigned int v549 = 0;
          goto LABEL_690;
        }

              os_release(v411);
              goto LABEL_654;
            }

            uint64_t v724 = v163;
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
            unint64_t v725 = (char *)_os_log_send_and_compose_impl();
            v963[0] = 16;
            LOBYTE(aBlock) = 0;
            if (__nwlog_fault(v725, v963, &aBlock))
            {
              if (v963[0] == 17)
              {
                unint64_t v726 = (os_log_s *)__nwlog_obj();
                int v727 = v963[0];
                if (os_log_type_enabled(v726, (os_log_type_t)v963[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                  uint64_t v728 = "%{public}s called with null http1_stream->protocol_http1";
LABEL_1427:
                  _os_log_impl(&dword_181A5C000, v726, v727, v728, buf, 0xCu);
                }
              }

              else if ((_BYTE)aBlock)
              {
                v800 = (char *)__nw_create_backtrace_string();
                unint64_t v726 = (os_log_s *)__nwlog_obj();
                int v727 = v963[0];
                v801 = os_log_type_enabled(v726, (os_log_type_t)v963[0]);
                if (v800)
                {
                  if (v801)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v800;
                    _os_log_impl( &dword_181A5C000,  v726,  v727,  "%{public}s called with null http1_stream->protocol_http1, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v800);
                  goto LABEL_1428;
                }

                if (v801)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                  uint64_t v728 = "%{public}s called with null http1_stream->protocol_http1, no backtrace";
                  goto LABEL_1427;
                }
              }

              else
              {
                unint64_t v726 = (os_log_s *)__nwlog_obj();
                int v727 = v963[0];
                if (os_log_type_enabled(v726, (os_log_type_t)v963[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                  uint64_t v728 = "%{public}s called with null http1_stream->protocol_http1, backtrace limit exceeded";
                  goto LABEL_1427;
                }
              }
            }

                  free(v268);
                  goto LABEL_342;
                }

                unint64_t v176 = *(void *)(v11 + 480);
                if (v176)
                {
                  int v177 = *(void *)(v176 + 200);
                  *(void *)buf = MEMORY[0x1895F87A8];
                  *(void *)&buf[8] = 0x40000000LL;
                  *(void *)&buf[16] = ___ZL56nw_http1_match_idle_connection_with_pending_stream_asyncP19nw_http1_connection_block_invoke;
                  *(void *)&_BYTE buf[24] = &unk_189BBD540;
                  *(void *)&_BYTE buf[32] = v177;
                  nw_queue_context_async(v175, buf);
                  goto LABEL_342;
                }

                __nwlog_obj();
                *(_DWORD *)uint64_t v398 = 136446210;
                *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                id v268 = (char *)_os_log_send_and_compose_impl();
                v394[0] = OS_LOG_TYPE_ERROR;
                os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v268, v394, &type))
                {
                  if (v394[0] == OS_LOG_TYPE_FAULT)
                  {
                    uint64_t v269 = (os_log_s *)__nwlog_obj();
                    uint64_t v270 = v394[0];
                    if (!os_log_type_enabled(v269, v394[0])) {
                      goto LABEL_652;
                    }
                    *(_DWORD *)uint64_t v398 = 136446210;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    unint64_t v271 = "%{public}s called with null http1";
                    goto LABEL_650;
                  }

                  if (type == OS_LOG_TYPE_DEFAULT)
                  {
                    uint64_t v269 = (os_log_s *)__nwlog_obj();
                    uint64_t v270 = v394[0];
                    if (!os_log_type_enabled(v269, v394[0])) {
                      goto LABEL_652;
                    }
                    *(_DWORD *)uint64_t v398 = 136446210;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    unint64_t v271 = "%{public}s called with null http1, backtrace limit exceeded";
                    goto LABEL_650;
                  }

                  unint64_t v304 = (char *)__nw_create_backtrace_string();
                  uint64_t v269 = (os_log_s *)__nwlog_obj();
                  uint64_t v270 = v394[0];
                  uint64_t v307 = os_log_type_enabled(v269, v394[0]);
                  if (!v304)
                  {
                    if (!v307) {
                      goto LABEL_652;
                    }
                    *(_DWORD *)uint64_t v398 = 136446210;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    unint64_t v271 = "%{public}s called with null http1, no backtrace";
                    goto LABEL_650;
                  }

                  if (v307)
                  {
                    *(_DWORD *)uint64_t v398 = 136446466;
                    *(void *)&v398[4] = "nw_http1_match_idle_connection_with_pending_stream_async";
                    *(_WORD *)&v398[12] = 2082;
                    *(void *)&v398[14] = v304;
                    int v306 = "%{public}s called with null http1, dumping backtrace:%{public}s";
                    goto LABEL_578;
                  }

                  goto LABEL_579;
                }

LABEL_688:
        if (*(_BYTE *)(a2 + *v8)) {
          unsigned int v549 = 0;
        }
LABEL_690:
        *(_DWORD *)(a1 + 68) = v549;
        goto LABEL_5;
      case 0xAu:
        *(_WORD *)(a1 + 196) |= 0x10u;
        uint64_t v227 = *v3;
        unint64_t v228 = *(void *)(a2 + v227);
        if (v228 == -1LL || v228 >= *(void *)(a2 + *v6))
        {
          unsigned int v231 = 0;
LABEL_642:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_643;
        }

        unint64_t v229 = v228 + 1;
        char v230 = *(_BYTE *)(*(void *)(a2 + *v10) + v228);
        *(void *)(a2 + v227) = v229;
        unsigned int v231 = v230 & 0x7F;
        if ((v230 & 0x80) == 0) {
          goto LABEL_643;
        }
        uint64_t v232 = *v3;
        unint64_t v233 = *(void *)(a2 + v232);
        if (v233 == -1LL || v233 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        int v234 = *(char *)(*(void *)(a2 + *v10) + v233);
        *(void *)(a2 + v232) = v233 + 1;
        unsigned int v231 = v231 & 0xFFFFC07F | ((v234 & 0x7F) << 7);
        if ((v234 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v235 = *v3;
        unint64_t v236 = *(void *)(a2 + v235);
        if (v236 == -1LL || v236 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        int v237 = *(char *)(*(void *)(a2 + *v10) + v236);
        *(void *)(a2 + v235) = v236 + 1;
        unsigned int v231 = v231 & 0xFFE03FFF | ((v237 & 0x7F) << 14);
        if ((v237 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v238 = *v3;
        unint64_t v239 = *(void *)(a2 + v238);
        if (v239 == -1LL || v239 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        int v240 = *(char *)(*(void *)(a2 + *v10) + v239);
        *(void *)(a2 + v238) = v239 + 1;
        unsigned int v231 = v231 & 0xF01FFFFF | ((v240 & 0x7F) << 21);
        if ((v240 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v241 = *v3;
        unint64_t v242 = *(void *)(a2 + v241);
        if (v242 == -1LL || v242 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        unint64_t v243 = v242 + 1;
        int v244 = *(char *)(*(void *)(a2 + *v10) + v242);
        *(void *)(a2 + v241) = v243;
        v231 |= v244 << 28;
        if ((v244 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v245 = *v3;
        unint64_t v246 = *(void *)(a2 + v245);
        if (v246 == -1LL || v246 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        unint64_t v247 = v246 + 1;
        int v248 = *(char *)(*(void *)(a2 + *v10) + v246);
        *(void *)(a2 + v245) = v247;
        if ((v248 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v249 = *v3;
        unint64_t v250 = *(void *)(a2 + v249);
        if (v250 == -1LL || v250 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        unint64_t v251 = v250 + 1;
        int v252 = *(char *)(*(void *)(a2 + *v10) + v250);
        *(void *)(a2 + v249) = v251;
        if ((v252 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v253 = *v3;
        unint64_t v254 = *(void *)(a2 + v253);
        if (v254 == -1LL || v254 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        unint64_t v255 = v254 + 1;
        int v256 = *(char *)(*(void *)(a2 + *v10) + v254);
        *(void *)(a2 + v253) = v255;
        if ((v256 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v257 = *v3;
        unint64_t v258 = *(void *)(a2 + v257);
        if (v258 == -1LL || v258 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        unint64_t v259 = v258 + 1;
        int v260 = *(char *)(*(void *)(a2 + *v10) + v258);
        *(void *)(a2 + v257) = v259;
        if ((v260 & 0x80000000) == 0) {
          goto LABEL_643;
        }
        uint64_t v261 = *v3;
        unint64_t v262 = *(void *)(a2 + v261);
        if (v262 == -1LL || v262 >= *(void *)(a2 + *v6)) {
          goto LABEL_642;
        }
        unint64_t v263 = v262 + 1;
        int v264 = *(char *)(*(void *)(a2 + *v10) + v262);
        *(void *)(a2 + v261) = v263;
        if (v264 < 0)
        {
          unsigned int v231 = 0;
          goto LABEL_645;
        }

LABEL_643:
        if (*(_BYTE *)(a2 + *v8)) {
          unsigned int v231 = 0;
        }
LABEL_645:
        *(_DWORD *)(a1 + 168) = v231;
        goto LABEL_5;
      case 0xBu:
        *(_WORD *)(a1 + 196) |= 0x400u;
        uint64_t v583 = *v3;
        unint64_t v584 = *(void *)(a2 + v583);
        if (v584 == -1LL || v584 >= *(void *)(a2 + *v6))
        {
          uint64_t v587 = 0LL;
LABEL_682:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_683;
        }

        unint64_t v585 = v584 + 1;
        char v586 = *(_BYTE *)(*(void *)(a2 + *v10) + v584);
        *(void *)(a2 + v583) = v585;
        uint64_t v587 = v586 & 0x7F;
        if ((v586 & 0x80) == 0) {
          goto LABEL_683;
        }
        uint64_t v588 = *v3;
        unint64_t v589 = *(void *)(a2 + v588);
        if (v589 == -1LL || v589 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v590 = v589 + 1;
        int v591 = *(char *)(*(void *)(a2 + *v10) + v589);
        *(void *)(a2 + v588) = v590;
        v587 |= (unint64_t)(v591 & 0x7F) << 7;
        if ((v591 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v592 = *v3;
        unint64_t v593 = *(void *)(a2 + v592);
        if (v593 == -1LL || v593 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v594 = v593 + 1;
        int v595 = *(char *)(*(void *)(a2 + *v10) + v593);
        *(void *)(a2 + v592) = v594;
        v587 |= (unint64_t)(v595 & 0x7F) << 14;
        if ((v595 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v596 = *v3;
        unint64_t v597 = *(void *)(a2 + v596);
        if (v597 == -1LL || v597 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v598 = v597 + 1;
        int v599 = *(char *)(*(void *)(a2 + *v10) + v597);
        *(void *)(a2 + v596) = v598;
        v587 |= (unint64_t)(v599 & 0x7F) << 21;
        if ((v599 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v600 = *v3;
        unint64_t v601 = *(void *)(a2 + v600);
        if (v601 == -1LL || v601 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v602 = v601 + 1;
        int v603 = *(char *)(*(void *)(a2 + *v10) + v601);
        *(void *)(a2 + v600) = v602;
        v587 |= (unint64_t)(v603 & 0x7F) << 28;
        if ((v603 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v604 = *v3;
        unint64_t v605 = *(void *)(a2 + v604);
        if (v605 == -1LL || v605 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v606 = v605 + 1;
        int v607 = *(char *)(*(void *)(a2 + *v10) + v605);
        *(void *)(a2 + v604) = v606;
        v587 |= (unint64_t)(v607 & 0x7F) << 35;
        if ((v607 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v608 = *v3;
        unint64_t v609 = *(void *)(a2 + v608);
        if (v609 == -1LL || v609 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v610 = v609 + 1;
        int v611 = *(char *)(*(void *)(a2 + *v10) + v609);
        *(void *)(a2 + v608) = v610;
        v587 |= (unint64_t)(v611 & 0x7F) << 42;
        if ((v611 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v612 = *v3;
        unint64_t v613 = *(void *)(a2 + v612);
        if (v613 == -1LL || v613 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v614 = v613 + 1;
        int v615 = *(char *)(*(void *)(a2 + *v10) + v613);
        *(void *)(a2 + v612) = v614;
        v587 |= (unint64_t)(v615 & 0x7F) << 49;
        if ((v615 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v616 = *v3;
        unint64_t v617 = *(void *)(a2 + v616);
        if (v617 == -1LL || v617 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v618 = v617 + 1;
        int v619 = *(char *)(*(void *)(a2 + *v10) + v617);
        *(void *)(a2 + v616) = v618;
        v587 |= (unint64_t)(v619 & 0x7F) << 56;
        if ((v619 & 0x80000000) == 0) {
          goto LABEL_683;
        }
        uint64_t v620 = *v3;
        unint64_t v621 = *(void *)(a2 + v620);
        if (v621 == -1LL || v621 >= *(void *)(a2 + *v6)) {
          goto LABEL_682;
        }
        unint64_t v622 = v621 + 1;
        uint64_t v623 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v621);
        *(void *)(a2 + v620) = v622;
        if ((v623 & 0x80) != 0)
        {
          uint64_t v587 = 0LL;
          goto LABEL_685;
        }

        v587 |= v623 << 63;
LABEL_683:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v587 = 0LL;
        }
LABEL_685:
        *(_BYTE *)(a1 + 188) = v587 != 0;
        goto LABEL_5;
      case 0xCu:
        *(_WORD *)(a1 + 196) |= 0x40u;
        uint64_t v145 = *v3;
        unint64_t v146 = *(void *)(a2 + v145);
        if (v146 == -1LL || v146 >= *(void *)(a2 + *v6))
        {
          uint64_t v149 = 0LL;
LABEL_632:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_633;
        }

        unint64_t v147 = v146 + 1;
        char v148 = *(_BYTE *)(*(void *)(a2 + *v10) + v146);
        *(void *)(a2 + v145) = v147;
        uint64_t v149 = v148 & 0x7F;
        if ((v148 & 0x80) == 0) {
          goto LABEL_633;
        }
        uint64_t v150 = *v3;
        unint64_t v151 = *(void *)(a2 + v150);
        if (v151 == -1LL || v151 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v152 = v151 + 1;
        int v153 = *(char *)(*(void *)(a2 + *v10) + v151);
        *(void *)(a2 + v150) = v152;
        v149 |= (unint64_t)(v153 & 0x7F) << 7;
        if ((v153 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v154 = *v3;
        unint64_t v155 = *(void *)(a2 + v154);
        if (v155 == -1LL || v155 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v156 = v155 + 1;
        int v157 = *(char *)(*(void *)(a2 + *v10) + v155);
        *(void *)(a2 + v154) = v156;
        v149 |= (unint64_t)(v157 & 0x7F) << 14;
        if ((v157 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v158 = *v3;
        unint64_t v159 = *(void *)(a2 + v158);
        if (v159 == -1LL || v159 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v160 = v159 + 1;
        int v161 = *(char *)(*(void *)(a2 + *v10) + v159);
        *(void *)(a2 + v158) = v160;
        v149 |= (unint64_t)(v161 & 0x7F) << 21;
        if ((v161 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v162 = *v3;
        unint64_t v163 = *(void *)(a2 + v162);
        if (v163 == -1LL || v163 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v164 = v163 + 1;
        int v165 = *(char *)(*(void *)(a2 + *v10) + v163);
        *(void *)(a2 + v162) = v164;
        v149 |= (unint64_t)(v165 & 0x7F) << 28;
        if ((v165 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v166 = *v3;
        unint64_t v167 = *(void *)(a2 + v166);
        if (v167 == -1LL || v167 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v168 = v167 + 1;
        int v169 = *(char *)(*(void *)(a2 + *v10) + v167);
        *(void *)(a2 + v166) = v168;
        v149 |= (unint64_t)(v169 & 0x7F) << 35;
        if ((v169 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v170 = *v3;
        unint64_t v171 = *(void *)(a2 + v170);
        if (v171 == -1LL || v171 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v172 = v171 + 1;
        int v173 = *(char *)(*(void *)(a2 + *v10) + v171);
        *(void *)(a2 + v170) = v172;
        v149 |= (unint64_t)(v173 & 0x7F) << 42;
        if ((v173 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v174 = *v3;
        unint64_t v175 = *(void *)(a2 + v174);
        if (v175 == -1LL || v175 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v176 = v175 + 1;
        int v177 = *(char *)(*(void *)(a2 + *v10) + v175);
        *(void *)(a2 + v174) = v176;
        v149 |= (unint64_t)(v177 & 0x7F) << 49;
        if ((v177 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v178 = *v3;
        unint64_t v179 = *(void *)(a2 + v178);
        if (v179 == -1LL || v179 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v180 = v179 + 1;
        int v181 = *(char *)(*(void *)(a2 + *v10) + v179);
        *(void *)(a2 + v178) = v180;
        v149 |= (unint64_t)(v181 & 0x7F) << 56;
        if ((v181 & 0x80000000) == 0) {
          goto LABEL_633;
        }
        uint64_t v182 = *v3;
        unint64_t v183 = *(void *)(a2 + v182);
        if (v183 == -1LL || v183 >= *(void *)(a2 + *v6)) {
          goto LABEL_632;
        }
        unint64_t v184 = v183 + 1;
        uint64_t v185 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v183);
        *(void *)(a2 + v182) = v184;
        if ((v185 & 0x80) != 0)
        {
          uint64_t v149 = 0LL;
          goto LABEL_635;
        }

        v149 |= v185 << 63;
LABEL_633:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v149 = 0LL;
        }
LABEL_635:
        *(_BYTE *)(a1 + 184) = v149 != 0;
        goto LABEL_5;
      case 0xDu:
        *(_WORD *)(a1 + 196) |= 0x800u;
        uint64_t v186 = *v3;
        unint64_t v187 = *(void *)(a2 + v186);
        if (v187 == -1LL || v187 >= *(void *)(a2 + *v6))
        {
          uint64_t v190 = 0LL;
LABEL_637:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_638;
        }

        unint64_t v188 = v187 + 1;
        char v189 = *(_BYTE *)(*(void *)(a2 + *v10) + v187);
        *(void *)(a2 + v186) = v188;
        uint64_t v190 = v189 & 0x7F;
        if ((v189 & 0x80) == 0) {
          goto LABEL_638;
        }
        uint64_t v191 = *v3;
        unint64_t v192 = *(void *)(a2 + v191);
        if (v192 == -1LL || v192 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v193 = v192 + 1;
        int v194 = *(char *)(*(void *)(a2 + *v10) + v192);
        *(void *)(a2 + v191) = v193;
        v190 |= (unint64_t)(v194 & 0x7F) << 7;
        if ((v194 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v195 = *v3;
        unint64_t v196 = *(void *)(a2 + v195);
        if (v196 == -1LL || v196 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v197 = v196 + 1;
        int v198 = *(char *)(*(void *)(a2 + *v10) + v196);
        *(void *)(a2 + v195) = v197;
        v190 |= (unint64_t)(v198 & 0x7F) << 14;
        if ((v198 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v199 = *v3;
        unint64_t v200 = *(void *)(a2 + v199);
        if (v200 == -1LL || v200 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v201 = v200 + 1;
        int v202 = *(char *)(*(void *)(a2 + *v10) + v200);
        *(void *)(a2 + v199) = v201;
        v190 |= (unint64_t)(v202 & 0x7F) << 21;
        if ((v202 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v203 = *v3;
        unint64_t v204 = *(void *)(a2 + v203);
        if (v204 == -1LL || v204 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v205 = v204 + 1;
        int v206 = *(char *)(*(void *)(a2 + *v10) + v204);
        *(void *)(a2 + v203) = v205;
        v190 |= (unint64_t)(v206 & 0x7F) << 28;
        if ((v206 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v207 = *v3;
        unint64_t v208 = *(void *)(a2 + v207);
        if (v208 == -1LL || v208 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v209 = v208 + 1;
        int v210 = *(char *)(*(void *)(a2 + *v10) + v208);
        *(void *)(a2 + v207) = v209;
        v190 |= (unint64_t)(v210 & 0x7F) << 35;
        if ((v210 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v211 = *v3;
        unint64_t v212 = *(void *)(a2 + v211);
        if (v212 == -1LL || v212 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v213 = v212 + 1;
        int v214 = *(char *)(*(void *)(a2 + *v10) + v212);
        *(void *)(a2 + v211) = v213;
        v190 |= (unint64_t)(v214 & 0x7F) << 42;
        if ((v214 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v215 = *v3;
        unint64_t v216 = *(void *)(a2 + v215);
        if (v216 == -1LL || v216 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v217 = v216 + 1;
        int v218 = *(char *)(*(void *)(a2 + *v10) + v216);
        *(void *)(a2 + v215) = v217;
        v190 |= (unint64_t)(v218 & 0x7F) << 49;
        if ((v218 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v219 = *v3;
        unint64_t v220 = *(void *)(a2 + v219);
        if (v220 == -1LL || v220 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v221 = v220 + 1;
        int v222 = *(char *)(*(void *)(a2 + *v10) + v220);
        *(void *)(a2 + v219) = v221;
        v190 |= (unint64_t)(v222 & 0x7F) << 56;
        if ((v222 & 0x80000000) == 0) {
          goto LABEL_638;
        }
        uint64_t v223 = *v3;
        unint64_t v224 = *(void *)(a2 + v223);
        if (v224 == -1LL || v224 >= *(void *)(a2 + *v6)) {
          goto LABEL_637;
        }
        unint64_t v225 = v224 + 1;
        uint64_t v226 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v224);
        *(void *)(a2 + v223) = v225;
        if ((v226 & 0x80) != 0)
        {
          uint64_t v190 = 0LL;
          goto LABEL_640;
        }

        v190 |= v226 << 63;
LABEL_638:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v190 = 0LL;
        }
LABEL_640:
        *(_BYTE *)(a1 + 189) = v190 != 0;
        goto LABEL_5;
      case 0xEu:
        *(_WORD *)(a1 + 196) |= 0x100u;
        uint64_t v428 = *v3;
        unint64_t v429 = *(void *)(a2 + v428);
        if (v429 == -1LL || v429 >= *(void *)(a2 + *v6))
        {
          uint64_t v432 = 0LL;
LABEL_667:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_668;
        }

        unint64_t v430 = v429 + 1;
        char v431 = *(_BYTE *)(*(void *)(a2 + *v10) + v429);
        *(void *)(a2 + v428) = v430;
        uint64_t v432 = v431 & 0x7F;
        if ((v431 & 0x80) == 0) {
          goto LABEL_668;
        }
        uint64_t v433 = *v3;
        unint64_t v434 = *(void *)(a2 + v433);
        if (v434 == -1LL || v434 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v435 = v434 + 1;
        int v436 = *(char *)(*(void *)(a2 + *v10) + v434);
        *(void *)(a2 + v433) = v435;
        v432 |= (unint64_t)(v436 & 0x7F) << 7;
        if ((v436 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v437 = *v3;
        unint64_t v438 = *(void *)(a2 + v437);
        if (v438 == -1LL || v438 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v439 = v438 + 1;
        int v440 = *(char *)(*(void *)(a2 + *v10) + v438);
        *(void *)(a2 + v437) = v439;
        v432 |= (unint64_t)(v440 & 0x7F) << 14;
        if ((v440 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v441 = *v3;
        unint64_t v442 = *(void *)(a2 + v441);
        if (v442 == -1LL || v442 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v443 = v442 + 1;
        int v444 = *(char *)(*(void *)(a2 + *v10) + v442);
        *(void *)(a2 + v441) = v443;
        v432 |= (unint64_t)(v444 & 0x7F) << 21;
        if ((v444 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v445 = *v3;
        unint64_t v446 = *(void *)(a2 + v445);
        if (v446 == -1LL || v446 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v447 = v446 + 1;
        int v448 = *(char *)(*(void *)(a2 + *v10) + v446);
        *(void *)(a2 + v445) = v447;
        v432 |= (unint64_t)(v448 & 0x7F) << 28;
        if ((v448 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v449 = *v3;
        unint64_t v450 = *(void *)(a2 + v449);
        if (v450 == -1LL || v450 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v451 = v450 + 1;
        int v452 = *(char *)(*(void *)(a2 + *v10) + v450);
        *(void *)(a2 + v449) = v451;
        v432 |= (unint64_t)(v452 & 0x7F) << 35;
        if ((v452 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v453 = *v3;
        unint64_t v454 = *(void *)(a2 + v453);
        if (v454 == -1LL || v454 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v455 = v454 + 1;
        int v456 = *(char *)(*(void *)(a2 + *v10) + v454);
        *(void *)(a2 + v453) = v455;
        v432 |= (unint64_t)(v456 & 0x7F) << 42;
        if ((v456 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v457 = *v3;
        unint64_t v458 = *(void *)(a2 + v457);
        if (v458 == -1LL || v458 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v459 = v458 + 1;
        int v460 = *(char *)(*(void *)(a2 + *v10) + v458);
        *(void *)(a2 + v457) = v459;
        v432 |= (unint64_t)(v460 & 0x7F) << 49;
        if ((v460 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v461 = *v3;
        unint64_t v462 = *(void *)(a2 + v461);
        if (v462 == -1LL || v462 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v463 = v462 + 1;
        int v464 = *(char *)(*(void *)(a2 + *v10) + v462);
        *(void *)(a2 + v461) = v463;
        v432 |= (unint64_t)(v464 & 0x7F) << 56;
        if ((v464 & 0x80000000) == 0) {
          goto LABEL_668;
        }
        uint64_t v465 = *v3;
        unint64_t v466 = *(void *)(a2 + v465);
        if (v466 == -1LL || v466 >= *(void *)(a2 + *v6)) {
          goto LABEL_667;
        }
        unint64_t v467 = v466 + 1;
        uint64_t v468 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v466);
        *(void *)(a2 + v465) = v467;
        if ((v468 & 0x80) != 0)
        {
          uint64_t v432 = 0LL;
          goto LABEL_670;
        }

        v432 |= v468 << 63;
LABEL_668:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v432 = 0LL;
        }
LABEL_670:
        *(_BYTE *)(a1 + 186) = v432 != 0;
        goto LABEL_5;
      case 0xFu:
        *(_WORD *)(a1 + 196) |= 0x2000u;
        uint64_t v104 = *v3;
        unint64_t v105 = *(void *)(a2 + v104);
        if (v105 == -1LL || v105 >= *(void *)(a2 + *v6))
        {
          uint64_t v108 = 0LL;
LABEL_627:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_628;
        }

        unint64_t v106 = v105 + 1;
        char v107 = *(_BYTE *)(*(void *)(a2 + *v10) + v105);
        *(void *)(a2 + v104) = v106;
        uint64_t v108 = v107 & 0x7F;
        if ((v107 & 0x80) == 0) {
          goto LABEL_628;
        }
        uint64_t v109 = *v3;
        unint64_t v110 = *(void *)(a2 + v109);
        if (v110 == -1LL || v110 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v111 = v110 + 1;
        int v112 = *(char *)(*(void *)(a2 + *v10) + v110);
        *(void *)(a2 + v109) = v111;
        v108 |= (unint64_t)(v112 & 0x7F) << 7;
        if ((v112 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v113 = *v3;
        unint64_t v114 = *(void *)(a2 + v113);
        if (v114 == -1LL || v114 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v115 = v114 + 1;
        int v116 = *(char *)(*(void *)(a2 + *v10) + v114);
        *(void *)(a2 + v113) = v115;
        v108 |= (unint64_t)(v116 & 0x7F) << 14;
        if ((v116 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v117 = *v3;
        unint64_t v118 = *(void *)(a2 + v117);
        if (v118 == -1LL || v118 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v119 = v118 + 1;
        int v120 = *(char *)(*(void *)(a2 + *v10) + v118);
        *(void *)(a2 + v117) = v119;
        v108 |= (unint64_t)(v120 & 0x7F) << 21;
        if ((v120 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v121 = *v3;
        unint64_t v122 = *(void *)(a2 + v121);
        if (v122 == -1LL || v122 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v123 = v122 + 1;
        int v124 = *(char *)(*(void *)(a2 + *v10) + v122);
        *(void *)(a2 + v121) = v123;
        v108 |= (unint64_t)(v124 & 0x7F) << 28;
        if ((v124 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v125 = *v3;
        unint64_t v126 = *(void *)(a2 + v125);
        if (v126 == -1LL || v126 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v127 = v126 + 1;
        int v128 = *(char *)(*(void *)(a2 + *v10) + v126);
        *(void *)(a2 + v125) = v127;
        v108 |= (unint64_t)(v128 & 0x7F) << 35;
        if ((v128 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v129 = *v3;
        unint64_t v130 = *(void *)(a2 + v129);
        if (v130 == -1LL || v130 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v131 = v130 + 1;
        int v132 = *(char *)(*(void *)(a2 + *v10) + v130);
        *(void *)(a2 + v129) = v131;
        v108 |= (unint64_t)(v132 & 0x7F) << 42;
        if ((v132 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v133 = *v3;
        unint64_t v134 = *(void *)(a2 + v133);
        if (v134 == -1LL || v134 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v135 = v134 + 1;
        int v136 = *(char *)(*(void *)(a2 + *v10) + v134);
        *(void *)(a2 + v133) = v135;
        v108 |= (unint64_t)(v136 & 0x7F) << 49;
        if ((v136 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v137 = *v3;
        unint64_t v138 = *(void *)(a2 + v137);
        if (v138 == -1LL || v138 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v139 = v138 + 1;
        int v140 = *(char *)(*(void *)(a2 + *v10) + v138);
        *(void *)(a2 + v137) = v139;
        v108 |= (unint64_t)(v140 & 0x7F) << 56;
        if ((v140 & 0x80000000) == 0) {
          goto LABEL_628;
        }
        uint64_t v141 = *v3;
        unint64_t v142 = *(void *)(a2 + v141);
        if (v142 == -1LL || v142 >= *(void *)(a2 + *v6)) {
          goto LABEL_627;
        }
        unint64_t v143 = v142 + 1;
        uint64_t v144 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v142);
        *(void *)(a2 + v141) = v143;
        if ((v144 & 0x80) != 0)
        {
          uint64_t v108 = 0LL;
          goto LABEL_630;
        }

        v108 |= v144 << 63;
LABEL_628:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v108 = 0LL;
        }
LABEL_630:
        *(_BYTE *)(a1 + 191) = v108 != 0;
        goto LABEL_5;
      case 0x10u:
        *(_WORD *)(a1 + 196) |= 0x4000u;
        uint64_t v270 = *v3;
        unint64_t v271 = *(void *)(a2 + v270);
        if (v271 == -1LL || v271 >= *(void *)(a2 + *v6))
        {
          uint64_t v274 = 0LL;
LABEL_647:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_648;
        }

        unint64_t v272 = v271 + 1;
        char v273 = *(_BYTE *)(*(void *)(a2 + *v10) + v271);
        *(void *)(a2 + v270) = v272;
        uint64_t v274 = v273 & 0x7F;
        if ((v273 & 0x80) == 0) {
          goto LABEL_648;
        }
        uint64_t v275 = *v3;
        unint64_t v276 = *(void *)(a2 + v275);
        if (v276 == -1LL || v276 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v277 = v276 + 1;
        int v278 = *(char *)(*(void *)(a2 + *v10) + v276);
        *(void *)(a2 + v275) = v277;
        v274 |= (unint64_t)(v278 & 0x7F) << 7;
        if ((v278 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v279 = *v3;
        unint64_t v280 = *(void *)(a2 + v279);
        if (v280 == -1LL || v280 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v281 = v280 + 1;
        int v282 = *(char *)(*(void *)(a2 + *v10) + v280);
        *(void *)(a2 + v279) = v281;
        v274 |= (unint64_t)(v282 & 0x7F) << 14;
        if ((v282 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v283 = *v3;
        unint64_t v284 = *(void *)(a2 + v283);
        if (v284 == -1LL || v284 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v285 = v284 + 1;
        int v286 = *(char *)(*(void *)(a2 + *v10) + v284);
        *(void *)(a2 + v283) = v285;
        v274 |= (unint64_t)(v286 & 0x7F) << 21;
        if ((v286 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v287 = *v3;
        unint64_t v288 = *(void *)(a2 + v287);
        if (v288 == -1LL || v288 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v289 = v288 + 1;
        int v290 = *(char *)(*(void *)(a2 + *v10) + v288);
        *(void *)(a2 + v287) = v289;
        v274 |= (unint64_t)(v290 & 0x7F) << 28;
        if ((v290 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v291 = *v3;
        unint64_t v292 = *(void *)(a2 + v291);
        if (v292 == -1LL || v292 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v293 = v292 + 1;
        int v294 = *(char *)(*(void *)(a2 + *v10) + v292);
        *(void *)(a2 + v291) = v293;
        v274 |= (unint64_t)(v294 & 0x7F) << 35;
        if ((v294 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v295 = *v3;
        unint64_t v296 = *(void *)(a2 + v295);
        if (v296 == -1LL || v296 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v297 = v296 + 1;
        int v298 = *(char *)(*(void *)(a2 + *v10) + v296);
        *(void *)(a2 + v295) = v297;
        v274 |= (unint64_t)(v298 & 0x7F) << 42;
        if ((v298 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v299 = *v3;
        unint64_t v300 = *(void *)(a2 + v299);
        if (v300 == -1LL || v300 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v301 = v300 + 1;
        int v302 = *(char *)(*(void *)(a2 + *v10) + v300);
        *(void *)(a2 + v299) = v301;
        v274 |= (unint64_t)(v302 & 0x7F) << 49;
        if ((v302 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v303 = *v3;
        unint64_t v304 = *(void *)(a2 + v303);
        if (v304 == -1LL || v304 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v305 = v304 + 1;
        int v306 = *(char *)(*(void *)(a2 + *v10) + v304);
        *(void *)(a2 + v303) = v305;
        v274 |= (unint64_t)(v306 & 0x7F) << 56;
        if ((v306 & 0x80000000) == 0) {
          goto LABEL_648;
        }
        uint64_t v307 = *v3;
        unint64_t v308 = *(void *)(a2 + v307);
        if (v308 == -1LL || v308 >= *(void *)(a2 + *v6)) {
          goto LABEL_647;
        }
        unint64_t v309 = v308 + 1;
        uint64_t v310 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v308);
        *(void *)(a2 + v307) = v309;
        if ((v310 & 0x80) != 0)
        {
          uint64_t v274 = 0LL;
          goto LABEL_650;
        }

        v274 |= v310 << 63;
LABEL_648:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v274 = 0LL;
        }
LABEL_650:
        *(_BYTE *)(a1 + 192) = v274 != 0;
        goto LABEL_5;
      case 0x11u:
        *(_WORD *)(a1 + 196) |= 0x1000u;
        uint64_t v63 = *v3;
        unint64_t v64 = *(void *)(a2 + v63);
        if (v64 == -1LL || v64 >= *(void *)(a2 + *v6))
        {
          uint64_t v67 = 0LL;
LABEL_622:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_623;
        }

        unint64_t v65 = v64 + 1;
        char v66 = *(_BYTE *)(*(void *)(a2 + *v10) + v64);
        *(void *)(a2 + v63) = v65;
        uint64_t v67 = v66 & 0x7F;
        if ((v66 & 0x80) == 0) {
          goto LABEL_623;
        }
        uint64_t v68 = *v3;
        unint64_t v69 = *(void *)(a2 + v68);
        if (v69 == -1LL || v69 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v70 = v69 + 1;
        int v71 = *(char *)(*(void *)(a2 + *v10) + v69);
        *(void *)(a2 + v68) = v70;
        v67 |= (unint64_t)(v71 & 0x7F) << 7;
        if ((v71 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v72 = *v3;
        unint64_t v73 = *(void *)(a2 + v72);
        if (v73 == -1LL || v73 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v74 = v73 + 1;
        int v75 = *(char *)(*(void *)(a2 + *v10) + v73);
        *(void *)(a2 + v72) = v74;
        v67 |= (unint64_t)(v75 & 0x7F) << 14;
        if ((v75 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v76 = *v3;
        unint64_t v77 = *(void *)(a2 + v76);
        if (v77 == -1LL || v77 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v78 = v77 + 1;
        int v79 = *(char *)(*(void *)(a2 + *v10) + v77);
        *(void *)(a2 + v76) = v78;
        v67 |= (unint64_t)(v79 & 0x7F) << 21;
        if ((v79 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v80 = *v3;
        unint64_t v81 = *(void *)(a2 + v80);
        if (v81 == -1LL || v81 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v82 = v81 + 1;
        int v83 = *(char *)(*(void *)(a2 + *v10) + v81);
        *(void *)(a2 + v80) = v82;
        v67 |= (unint64_t)(v83 & 0x7F) << 28;
        if ((v83 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v84 = *v3;
        unint64_t v85 = *(void *)(a2 + v84);
        if (v85 == -1LL || v85 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v86 = v85 + 1;
        int v87 = *(char *)(*(void *)(a2 + *v10) + v85);
        *(void *)(a2 + v84) = v86;
        v67 |= (unint64_t)(v87 & 0x7F) << 35;
        if ((v87 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v88 = *v3;
        unint64_t v89 = *(void *)(a2 + v88);
        if (v89 == -1LL || v89 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v90 = v89 + 1;
        int v91 = *(char *)(*(void *)(a2 + *v10) + v89);
        *(void *)(a2 + v88) = v90;
        v67 |= (unint64_t)(v91 & 0x7F) << 42;
        if ((v91 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v92 = *v3;
        unint64_t v93 = *(void *)(a2 + v92);
        if (v93 == -1LL || v93 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v94 = v93 + 1;
        int v95 = *(char *)(*(void *)(a2 + *v10) + v93);
        *(void *)(a2 + v92) = v94;
        v67 |= (unint64_t)(v95 & 0x7F) << 49;
        if ((v95 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v96 = *v3;
        unint64_t v97 = *(void *)(a2 + v96);
        if (v97 == -1LL || v97 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v98 = v97 + 1;
        int v99 = *(char *)(*(void *)(a2 + *v10) + v97);
        *(void *)(a2 + v96) = v98;
        v67 |= (unint64_t)(v99 & 0x7F) << 56;
        if ((v99 & 0x80000000) == 0) {
          goto LABEL_623;
        }
        uint64_t v100 = *v3;
        unint64_t v101 = *(void *)(a2 + v100);
        if (v101 == -1LL || v101 >= *(void *)(a2 + *v6)) {
          goto LABEL_622;
        }
        unint64_t v102 = v101 + 1;
        uint64_t v103 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v101);
        *(void *)(a2 + v100) = v102;
        if ((v103 & 0x80) != 0)
        {
          uint64_t v67 = 0LL;
          goto LABEL_625;
        }

        v67 |= v103 << 63;
LABEL_623:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v67 = 0LL;
        }
LABEL_625:
        *(_BYTE *)(a1 + 190) = v67 != 0;
        goto LABEL_5;
      case 0x12u:
        *(_WORD *)(a1 + 196) |= 0x200u;
        uint64_t v349 = *v3;
        unint64_t v350 = *(void *)(a2 + v349);
        if (v350 == -1LL || v350 >= *(void *)(a2 + *v6))
        {
          uint64_t v353 = 0LL;
LABEL_657:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_658;
        }

        unint64_t v351 = v350 + 1;
        char v352 = *(_BYTE *)(*(void *)(a2 + *v10) + v350);
        *(void *)(a2 + v349) = v351;
        uint64_t v353 = v352 & 0x7F;
        if ((v352 & 0x80) == 0) {
          goto LABEL_658;
        }
        uint64_t v354 = *v3;
        unint64_t v355 = *(void *)(a2 + v354);
        if (v355 == -1LL || v355 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v356 = v355 + 1;
        int v357 = *(char *)(*(void *)(a2 + *v10) + v355);
        *(void *)(a2 + v354) = v356;
        v353 |= (unint64_t)(v357 & 0x7F) << 7;
        if ((v357 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v358 = *v3;
        unint64_t v359 = *(void *)(a2 + v358);
        if (v359 == -1LL || v359 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v360 = v359 + 1;
        int v361 = *(char *)(*(void *)(a2 + *v10) + v359);
        *(void *)(a2 + v358) = v360;
        v353 |= (unint64_t)(v361 & 0x7F) << 14;
        if ((v361 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v362 = *v3;
        unint64_t v363 = *(void *)(a2 + v362);
        if (v363 == -1LL || v363 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v364 = v363 + 1;
        int v365 = *(char *)(*(void *)(a2 + *v10) + v363);
        *(void *)(a2 + v362) = v364;
        v353 |= (unint64_t)(v365 & 0x7F) << 21;
        if ((v365 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v366 = *v3;
        unint64_t v367 = *(void *)(a2 + v366);
        if (v367 == -1LL || v367 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v368 = v367 + 1;
        int v369 = *(char *)(*(void *)(a2 + *v10) + v367);
        *(void *)(a2 + v366) = v368;
        v353 |= (unint64_t)(v369 & 0x7F) << 28;
        if ((v369 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v370 = *v3;
        unint64_t v371 = *(void *)(a2 + v370);
        if (v371 == -1LL || v371 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v372 = v371 + 1;
        int v373 = *(char *)(*(void *)(a2 + *v10) + v371);
        *(void *)(a2 + v370) = v372;
        v353 |= (unint64_t)(v373 & 0x7F) << 35;
        if ((v373 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v374 = *v3;
        unint64_t v375 = *(void *)(a2 + v374);
        if (v375 == -1LL || v375 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v376 = v375 + 1;
        int v377 = *(char *)(*(void *)(a2 + *v10) + v375);
        *(void *)(a2 + v374) = v376;
        v353 |= (unint64_t)(v377 & 0x7F) << 42;
        if ((v377 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v378 = *v3;
        unint64_t v379 = *(void *)(a2 + v378);
        if (v379 == -1LL || v379 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v380 = v379 + 1;
        int v381 = *(char *)(*(void *)(a2 + *v10) + v379);
        *(void *)(a2 + v378) = v380;
        v353 |= (unint64_t)(v381 & 0x7F) << 49;
        if ((v381 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v382 = *v3;
        unint64_t v383 = *(void *)(a2 + v382);
        if (v383 == -1LL || v383 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v384 = v383 + 1;
        int v385 = *(char *)(*(void *)(a2 + *v10) + v383);
        *(void *)(a2 + v382) = v384;
        v353 |= (unint64_t)(v385 & 0x7F) << 56;
        if ((v385 & 0x80000000) == 0) {
          goto LABEL_658;
        }
        uint64_t v386 = *v3;
        unint64_t v387 = *(void *)(a2 + v386);
        if (v387 == -1LL || v387 >= *(void *)(a2 + *v6)) {
          goto LABEL_657;
        }
        unint64_t v388 = v387 + 1;
        uint64_t v389 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v387);
        *(void *)(a2 + v386) = v388;
        if ((v389 & 0x80) != 0)
        {
          uint64_t v353 = 0LL;
          goto LABEL_660;
        }

        v353 |= v389 << 63;
LABEL_658:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v353 = 0LL;
        }
LABEL_660:
        *(_BYTE *)(a1 + 187) = v353 != 0;
        goto LABEL_5;
      case 0x13u:
        *(_WORD *)(a1 + 196) |= 8u;
        uint64_t v507 = *v3;
        unint64_t v508 = *(void *)(a2 + v507);
        if (v508 == -1LL || v508 >= *(void *)(a2 + *v6))
        {
          unsigned int v511 = 0;
LABEL_677:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_678;
        }

        unint64_t v509 = v508 + 1;
        char v510 = *(_BYTE *)(*(void *)(a2 + *v10) + v508);
        *(void *)(a2 + v507) = v509;
        unsigned int v511 = v510 & 0x7F;
        if ((v510 & 0x80) == 0) {
          goto LABEL_678;
        }
        uint64_t v512 = *v3;
        unint64_t v513 = *(void *)(a2 + v512);
        if (v513 == -1LL || v513 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        int v514 = *(char *)(*(void *)(a2 + *v10) + v513);
        *(void *)(a2 + v512) = v513 + 1;
        unsigned int v511 = v511 & 0xFFFFC07F | ((v514 & 0x7F) << 7);
        if ((v514 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v515 = *v3;
        unint64_t v516 = *(void *)(a2 + v515);
        if (v516 == -1LL || v516 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        int v517 = *(char *)(*(void *)(a2 + *v10) + v516);
        *(void *)(a2 + v515) = v516 + 1;
        unsigned int v511 = v511 & 0xFFE03FFF | ((v517 & 0x7F) << 14);
        if ((v517 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v518 = *v3;
        unint64_t v519 = *(void *)(a2 + v518);
        if (v519 == -1LL || v519 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        int v520 = *(char *)(*(void *)(a2 + *v10) + v519);
        *(void *)(a2 + v518) = v519 + 1;
        unsigned int v511 = v511 & 0xF01FFFFF | ((v520 & 0x7F) << 21);
        if ((v520 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v521 = *v3;
        unint64_t v522 = *(void *)(a2 + v521);
        if (v522 == -1LL || v522 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        unint64_t v523 = v522 + 1;
        int v524 = *(char *)(*(void *)(a2 + *v10) + v522);
        *(void *)(a2 + v521) = v523;
        v511 |= v524 << 28;
        if ((v524 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v525 = *v3;
        unint64_t v526 = *(void *)(a2 + v525);
        if (v526 == -1LL || v526 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        unint64_t v527 = v526 + 1;
        int v528 = *(char *)(*(void *)(a2 + *v10) + v526);
        *(void *)(a2 + v525) = v527;
        if ((v528 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v529 = *v3;
        unint64_t v530 = *(void *)(a2 + v529);
        if (v530 == -1LL || v530 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        unint64_t v531 = v530 + 1;
        int v532 = *(char *)(*(void *)(a2 + *v10) + v530);
        *(void *)(a2 + v529) = v531;
        if ((v532 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v533 = *v3;
        unint64_t v534 = *(void *)(a2 + v533);
        if (v534 == -1LL || v534 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        unint64_t v535 = v534 + 1;
        int v536 = *(char *)(*(void *)(a2 + *v10) + v534);
        *(void *)(a2 + v533) = v535;
        if ((v536 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v537 = *v3;
        unint64_t v538 = *(void *)(a2 + v537);
        if (v538 == -1LL || v538 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        unint64_t v539 = v538 + 1;
        int v540 = *(char *)(*(void *)(a2 + *v10) + v538);
        *(void *)(a2 + v537) = v539;
        if ((v540 & 0x80000000) == 0) {
          goto LABEL_678;
        }
        uint64_t v541 = *v3;
        unint64_t v542 = *(void *)(a2 + v541);
        if (v542 == -1LL || v542 >= *(void *)(a2 + *v6)) {
          goto LABEL_677;
        }
        unint64_t v543 = v542 + 1;
        int v544 = *(char *)(*(void *)(a2 + *v10) + v542);
        *(void *)(a2 + v541) = v543;
        if (v544 < 0)
        {
          unsigned int v511 = 0;
          goto LABEL_680;
        }

LABEL_678:
        if (*(_BYTE *)(a2 + *v8)) {
          unsigned int v511 = 0;
        }
LABEL_680:
        *(_DWORD *)(a1 + 112) = v511;
        goto LABEL_5;
      case 0x14u:
        *(_WORD *)(a1 + 196) |= 0x80u;
        uint64_t v661 = *v3;
        unint64_t v662 = *(void *)(a2 + v661);
        if (v662 == -1LL || v662 >= *(void *)(a2 + *v6))
        {
          uint64_t v665 = 0LL;
LABEL_692:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_693;
        }

        unint64_t v663 = v662 + 1;
        char v664 = *(_BYTE *)(*(void *)(a2 + *v10) + v662);
        *(void *)(a2 + v661) = v663;
        uint64_t v665 = v664 & 0x7F;
        if ((v664 & 0x80) == 0) {
          goto LABEL_693;
        }
        uint64_t v666 = *v3;
        unint64_t v667 = *(void *)(a2 + v666);
        if (v667 == -1LL || v667 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v668 = v667 + 1;
        int v669 = *(char *)(*(void *)(a2 + *v10) + v667);
        *(void *)(a2 + v666) = v668;
        v665 |= (unint64_t)(v669 & 0x7F) << 7;
        if ((v669 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v670 = *v3;
        unint64_t v671 = *(void *)(a2 + v670);
        if (v671 == -1LL || v671 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v672 = v671 + 1;
        int v673 = *(char *)(*(void *)(a2 + *v10) + v671);
        *(void *)(a2 + v670) = v672;
        v665 |= (unint64_t)(v673 & 0x7F) << 14;
        if ((v673 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v674 = *v3;
        unint64_t v675 = *(void *)(a2 + v674);
        if (v675 == -1LL || v675 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v676 = v675 + 1;
        int v677 = *(char *)(*(void *)(a2 + *v10) + v675);
        *(void *)(a2 + v674) = v676;
        v665 |= (unint64_t)(v677 & 0x7F) << 21;
        if ((v677 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v678 = *v3;
        unint64_t v679 = *(void *)(a2 + v678);
        if (v679 == -1LL || v679 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v680 = v679 + 1;
        int v681 = *(char *)(*(void *)(a2 + *v10) + v679);
        *(void *)(a2 + v678) = v680;
        v665 |= (unint64_t)(v681 & 0x7F) << 28;
        if ((v681 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v682 = *v3;
        unint64_t v683 = *(void *)(a2 + v682);
        if (v683 == -1LL || v683 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v684 = v683 + 1;
        int v685 = *(char *)(*(void *)(a2 + *v10) + v683);
        *(void *)(a2 + v682) = v684;
        v665 |= (unint64_t)(v685 & 0x7F) << 35;
        if ((v685 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v686 = *v3;
        unint64_t v687 = *(void *)(a2 + v686);
        if (v687 == -1LL || v687 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v688 = v687 + 1;
        int v689 = *(char *)(*(void *)(a2 + *v10) + v687);
        *(void *)(a2 + v686) = v688;
        v665 |= (unint64_t)(v689 & 0x7F) << 42;
        if ((v689 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v690 = *v3;
        unint64_t v691 = *(void *)(a2 + v690);
        if (v691 == -1LL || v691 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v692 = v691 + 1;
        int v693 = *(char *)(*(void *)(a2 + *v10) + v691);
        *(void *)(a2 + v690) = v692;
        v665 |= (unint64_t)(v693 & 0x7F) << 49;
        if ((v693 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v694 = *v3;
        unint64_t v695 = *(void *)(a2 + v694);
        if (v695 == -1LL || v695 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v696 = v695 + 1;
        int v697 = *(char *)(*(void *)(a2 + *v10) + v695);
        *(void *)(a2 + v694) = v696;
        v665 |= (unint64_t)(v697 & 0x7F) << 56;
        if ((v697 & 0x80000000) == 0) {
          goto LABEL_693;
        }
        uint64_t v698 = *v3;
        unint64_t v699 = *(void *)(a2 + v698);
        if (v699 == -1LL || v699 >= *(void *)(a2 + *v6)) {
          goto LABEL_692;
        }
        unint64_t v700 = v699 + 1;
        uint64_t v701 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v699);
        *(void *)(a2 + v698) = v700;
        if ((v701 & 0x80) != 0)
        {
          uint64_t v665 = 0LL;
          goto LABEL_695;
        }

        v665 |= v701 << 63;
LABEL_693:
        if (*(_BYTE *)(a2 + *v8)) {
          uint64_t v665 = 0LL;
        }
LABEL_695:
        *(_BYTE *)(a1 + 185) = v665 != 0;
        goto LABEL_5;
      case 0x15u:
        uint64_t v58 = objc_alloc_init(&OBJC_CLASS___NWPBEndpoint);
        objc_storeStrong((id *)(a1 + 96), v58);
        goto LABEL_620;
      case 0x16u:
        uint64_t v58 = objc_alloc_init(&OBJC_CLASS___NWPBInterface);
        objc_storeStrong((id *)(a1 + 160), v58);
        goto LABEL_345;
      case 0x17u:
        if (v55 != 2) {
          goto LABEL_696;
        }
        uint64_t result = PBReaderPlaceMark();
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v625 = *v3;
        unint64_t v626 = *(void *)(a2 + v625);
        unint64_t v627 = *(void *)(a2 + *v6);
        if (v626 >= v627) {
          goto LABEL_609;
        }
        while (2)
        {
          v628 = (_BYTE *)(a2 + *v8);
          if (*v628) {
            goto LABEL_609;
          }
          if (v626 >= v627) {
            goto LABEL_538;
          }
          char v629 = *(_BYTE *)(*(void *)(a2 + *v10) + v626);
          *(void *)(a2 + (int)v625) = v626 + 1;
          if ((v629 & 0x80) == 0) {
            goto LABEL_539;
          }
          uint64_t v630 = *v3;
          unint64_t v631 = *(void *)(a2 + v630);
          if (v631 == -1LL || v631 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          int v632 = *(char *)(*(void *)(a2 + *v10) + v631);
          *(void *)(a2 + v630) = v631 + 1;
          if ((v632 & 0x80000000) == 0) {
            goto LABEL_539;
          }
          uint64_t v633 = *v3;
          unint64_t v634 = *(void *)(a2 + v633);
          if (v634 == -1LL || v634 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          int v635 = *(char *)(*(void *)(a2 + *v10) + v634);
          *(void *)(a2 + v633) = v634 + 1;
          if ((v635 & 0x80000000) == 0) {
            goto LABEL_539;
          }
          uint64_t v636 = *v3;
          unint64_t v637 = *(void *)(a2 + v636);
          if (v637 == -1LL || v637 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          int v638 = *(char *)(*(void *)(a2 + *v10) + v637);
          *(void *)(a2 + v636) = v637 + 1;
          if ((v638 & 0x80000000) == 0) {
            goto LABEL_539;
          }
          uint64_t v639 = *v3;
          unint64_t v640 = *(void *)(a2 + v639);
          if (v640 == -1LL || v640 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          unint64_t v641 = v640 + 1;
          int v642 = *(char *)(*(void *)(a2 + *v10) + v640);
          *(void *)(a2 + v639) = v641;
          if ((v642 & 0x80000000) == 0) {
            goto LABEL_539;
          }
          uint64_t v643 = *v3;
          unint64_t v644 = *(void *)(a2 + v643);
          if (v644 == -1LL || v644 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          unint64_t v645 = v644 + 1;
          int v646 = *(char *)(*(void *)(a2 + *v10) + v644);
          *(void *)(a2 + v643) = v645;
          if ((v646 & 0x80000000) == 0) {
            goto LABEL_539;
          }
          uint64_t v647 = *v3;
          unint64_t v648 = *(void *)(a2 + v647);
          if (v648 == -1LL || v648 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          unint64_t v649 = v648 + 1;
          int v650 = *(char *)(*(void *)(a2 + *v10) + v648);
          *(void *)(a2 + v647) = v649;
          if ((v650 & 0x80000000) == 0) {
            goto LABEL_539;
          }
          uint64_t v651 = *v3;
          unint64_t v652 = *(void *)(a2 + v651);
          if (v652 == -1LL || v652 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          unint64_t v653 = v652 + 1;
          int v654 = *(char *)(*(void *)(a2 + *v10) + v652);
          *(void *)(a2 + v651) = v653;
          if ((v654 & 0x80000000) == 0) {
            goto LABEL_539;
          }
          uint64_t v655 = *v3;
          unint64_t v656 = *(void *)(a2 + v655);
          if (v656 == -1LL || v656 >= *(void *)(a2 + *v6)) {
            goto LABEL_537;
          }
          unint64_t v657 = v656 + 1;
          int v658 = *(char *)(*(void *)(a2 + *v10) + v656);
          *(void *)(a2 + v655) = v657;
          if (v658 < 0)
          {
            uint64_t v659 = *v3;
            unint64_t v660 = *(void *)(a2 + v659);
            if (v660 == -1LL || v660 >= *(void *)(a2 + *v6))
            {
LABEL_537:
              v628 = (_BYTE *)(a2 + *v8);
LABEL_538:
              _BYTE *v628 = 1;
            }

            else
            {
              *(void *)(a2 + v659) = v660 + 1;
            }
          }

            goto LABEL_679;
          }

          if (!v556)
          {
            __nwlog_obj();
            unint64_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            unint64_t v308 = v561;
            if (os_log_type_enabled(v74, v561))
            {
              *(_DWORD *)__int128 uu = 136446210;
              *(void *)&uu[4] = "nw_path_parse_necp_parameters";
              _os_log_impl( &dword_181A5C000,  v74,  v308,  "%{public}s xpc_array_create failed, backtrace limit exceeded",  uu,  0xCu);
            }

            goto LABEL_678;
          }

          unint64_t v243 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          unint64_t v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v244 = v561;
          uint64_t v245 = os_log_type_enabled(v74, v561);
          if (!v243)
          {
            if (v245)
            {
              *(_DWORD *)__int128 uu = 136446210;
              *(void *)&uu[4] = "nw_path_parse_necp_parameters";
              _os_log_impl(&dword_181A5C000, v74, v244, "%{public}s xpc_array_create failed, no backtrace", uu, 0xCu);
            }

            goto LABEL_678;
          }

          if (v245)
          {
            *(_DWORD *)__int128 uu = 136446466;
            *(void *)&uu[4] = "nw_path_parse_necp_parameters";
            *(_WORD *)&uu[12] = 2082;
            *(void *)&uu[14] = v243;
            _os_log_impl( &dword_181A5C000,  v74,  v244,  "%{public}s xpc_array_create failed, dumping backtrace:%{public}s",  uu,  0x16u);
          }

          free(v243);
LABEL_679:
          if (v73) {
            free(v73);
          }
          uint64_t v68 = 0LL;
LABEL_682:
          if (!v71)
          {
            int v71 = xpc_array_create(0LL, 0LL);
            if (!v71)
            {
              __nwlog_obj();
              unint64_t v331 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)__int128 uu = 136446210;
              *(void *)&uu[4] = "nw_path_parse_necp_parameters";
              int v332 = (char *)_os_log_send_and_compose_impl();

              unint64_t v561 = OS_LOG_TYPE_ERROR;
              uint64_t v556 = 0;
              if (__nwlog_fault(v332, &v561, &v556))
              {
                if (v561 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  uint64_t v333 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  unint64_t v334 = v561;
                  if (os_log_type_enabled(v333, v561))
                  {
                    *(_DWORD *)__int128 uu = 136446210;
                    *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                    _os_log_impl(&dword_181A5C000, v333, v334, "%{public}s xpc_array_create failed", uu, 0xCu);
                  }

                  goto LABEL_850;
                }

                if (v556)
                {
                  unint64_t v338 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  uint64_t v333 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  unint64_t v339 = v561;
                  int v340 = os_log_type_enabled(v333, v561);
                  if (v338)
                  {
                    if (v340)
                    {
                      *(_DWORD *)__int128 uu = 136446466;
                      *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                      *(_WORD *)&uu[12] = 2082;
                      *(void *)&uu[14] = v338;
                      _os_log_impl( &dword_181A5C000,  v333,  v339,  "%{public}s xpc_array_create failed, dumping backtrace:%{public}s",  uu,  0x16u);
                    }

                    free(v338);
                    goto LABEL_851;
                  }

                  if (v340)
                  {
                    *(_DWORD *)__int128 uu = 136446210;
                    *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                    _os_log_impl( &dword_181A5C000,  v333,  v339,  "%{public}s xpc_array_create failed, no backtrace",  uu,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  uint64_t v333 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  unint64_t v343 = v561;
                  if (os_log_type_enabled(v333, v561))
                  {
                    *(_DWORD *)__int128 uu = 136446210;
                    *(void *)&uu[4] = "nw_path_parse_necp_parameters";
                    _os_log_impl( &dword_181A5C000,  v333,  v343,  "%{public}s xpc_array_create failed, backtrace limit exceeded",  uu,  0xCu);
                  }
                }

LABEL_539:
          PBRepeatedInt32Add();
          uint64_t v625 = *v3;
          unint64_t v626 = *(void *)(a2 + v625);
          unint64_t v627 = *(void *)(a2 + *v6);
          if (v626 >= v627) {
            goto LABEL_609;
          }
          continue;
        }

      case 0x18u:
        if (v55 != 2)
        {
LABEL_696:
          uint64_t v740 = *v3;
          unint64_t v741 = *(void *)(a2 + v740);
          if (v741 != -1LL && v741 < *(void *)(a2 + *v6))
          {
            char v742 = *(_BYTE *)(*(void *)(a2 + *v10) + v741);
            *(void *)(a2 + v740) = v741 + 1;
            if ((v742 & 0x80) == 0) {
              goto LABEL_727;
            }
            uint64_t v743 = *v3;
            unint64_t v744 = *(void *)(a2 + v743);
            if (v744 == -1LL || v744 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            int v745 = *(char *)(*(void *)(a2 + *v10) + v744);
            *(void *)(a2 + v743) = v744 + 1;
            if ((v745 & 0x80000000) == 0) {
              goto LABEL_727;
            }
            uint64_t v746 = *v3;
            unint64_t v747 = *(void *)(a2 + v746);
            if (v747 == -1LL || v747 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            int v748 = *(char *)(*(void *)(a2 + *v10) + v747);
            *(void *)(a2 + v746) = v747 + 1;
            if ((v748 & 0x80000000) == 0) {
              goto LABEL_727;
            }
            uint64_t v749 = *v3;
            unint64_t v750 = *(void *)(a2 + v749);
            if (v750 == -1LL || v750 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            int v751 = *(char *)(*(void *)(a2 + *v10) + v750);
            *(void *)(a2 + v749) = v750 + 1;
            if ((v751 & 0x80000000) == 0) {
              goto LABEL_727;
            }
            uint64_t v752 = *v3;
            unint64_t v753 = *(void *)(a2 + v752);
            if (v753 == -1LL || v753 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            unint64_t v754 = v753 + 1;
            int v755 = *(char *)(*(void *)(a2 + *v10) + v753);
            *(void *)(a2 + v752) = v754;
            if ((v755 & 0x80000000) == 0) {
              goto LABEL_727;
            }
            uint64_t v756 = *v3;
            unint64_t v757 = *(void *)(a2 + v756);
            if (v757 == -1LL || v757 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            unint64_t v758 = v757 + 1;
            int v759 = *(char *)(*(void *)(a2 + *v10) + v757);
            *(void *)(a2 + v756) = v758;
            if ((v759 & 0x80000000) == 0) {
              goto LABEL_727;
            }
            uint64_t v760 = *v3;
            unint64_t v761 = *(void *)(a2 + v760);
            if (v761 == -1LL || v761 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            unint64_t v762 = v761 + 1;
            int v763 = *(char *)(*(void *)(a2 + *v10) + v761);
            *(void *)(a2 + v760) = v762;
            if ((v763 & 0x80000000) == 0) {
              goto LABEL_727;
            }
            uint64_t v764 = *v3;
            unint64_t v765 = *(void *)(a2 + v764);
            if (v765 == -1LL || v765 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            unint64_t v766 = v765 + 1;
            int v767 = *(char *)(*(void *)(a2 + *v10) + v765);
            *(void *)(a2 + v764) = v766;
            if ((v767 & 0x80000000) == 0) {
              goto LABEL_727;
            }
            uint64_t v768 = *v3;
            unint64_t v769 = *(void *)(a2 + v768);
            if (v769 == -1LL || v769 >= *(void *)(a2 + *v6)) {
              goto LABEL_728;
            }
            unint64_t v770 = v769 + 1;
            int v771 = *(char *)(*(void *)(a2 + *v10) + v769);
            *(void *)(a2 + v768) = v770;
            if ((v771 & 0x80000000) == 0)
            {
LABEL_727:
              PBRepeatedInt32Add();
              goto LABEL_5;
            }

            uint64_t v772 = *v3;
            unint64_t v773 = *(void *)(a2 + v772);
            if (v773 != -1LL && v773 < *(void *)(a2 + *v6))
            {
              *(void *)(a2 + v772) = v773 + 1;
              goto LABEL_727;
            }

LABEL_728:
            uint64_t v57 = (_BYTE *)(a2 + *v8);
          }

          *uint64_t v57 = 1;
          goto LABEL_727;
        }

        uint64_t result = PBReaderPlaceMark();
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v702 = *v3;
        unint64_t v703 = *(void *)(a2 + v702);
        for (unint64_t i = *(void *)(a2 + *v6); v703 < i; unint64_t i = *(void *)(a2 + *v6))
        {
          v705 = (_BYTE *)(a2 + *v8);
          if (*v705) {
            break;
          }
          if (v703 >= i) {
            goto LABEL_607;
          }
          char v706 = *(_BYTE *)(*(void *)(a2 + *v10) + v703);
          *(void *)(a2 + (int)v702) = v703 + 1;
          if (v706 < 0)
          {
            uint64_t v707 = *v3;
            unint64_t v708 = *(void *)(a2 + v707);
            if (v708 == -1LL || v708 >= *(void *)(a2 + *v6))
            {
LABEL_606:
              v705 = (_BYTE *)(a2 + *v8);
LABEL_607:
              _BYTE *v705 = 1;
              goto LABEL_608;
            }

            int v709 = *(char *)(*(void *)(a2 + *v10) + v708);
            *(void *)(a2 + v707) = v708 + 1;
            if (v709 < 0)
            {
              uint64_t v710 = *v3;
              unint64_t v711 = *(void *)(a2 + v710);
              if (v711 == -1LL || v711 >= *(void *)(a2 + *v6)) {
                goto LABEL_606;
              }
              int v712 = *(char *)(*(void *)(a2 + *v10) + v711);
              *(void *)(a2 + v710) = v711 + 1;
              if (v712 < 0)
              {
                uint64_t v713 = *v3;
                unint64_t v714 = *(void *)(a2 + v713);
                if (v714 == -1LL || v714 >= *(void *)(a2 + *v6)) {
                  goto LABEL_606;
                }
                int v715 = *(char *)(*(void *)(a2 + *v10) + v714);
                *(void *)(a2 + v713) = v714 + 1;
                if (v715 < 0)
                {
                  uint64_t v716 = *v3;
                  unint64_t v717 = *(void *)(a2 + v716);
                  if (v717 == -1LL || v717 >= *(void *)(a2 + *v6)) {
                    goto LABEL_606;
                  }
                  unint64_t v718 = v717 + 1;
                  int v719 = *(char *)(*(void *)(a2 + *v10) + v717);
                  *(void *)(a2 + v716) = v718;
                  if (v719 < 0)
                  {
                    uint64_t v720 = *v3;
                    unint64_t v721 = *(void *)(a2 + v720);
                    if (v721 == -1LL || v721 >= *(void *)(a2 + *v6)) {
                      goto LABEL_606;
                    }
                    unint64_t v722 = v721 + 1;
                    int v723 = *(char *)(*(void *)(a2 + *v10) + v721);
                    *(void *)(a2 + v720) = v722;
                    if (v723 < 0)
                    {
                      uint64_t v724 = *v3;
                      unint64_t v725 = *(void *)(a2 + v724);
                      if (v725 == -1LL || v725 >= *(void *)(a2 + *v6)) {
                        goto LABEL_606;
                      }
                      unint64_t v726 = v725 + 1;
                      int v727 = *(char *)(*(void *)(a2 + *v10) + v725);
                      *(void *)(a2 + v724) = v726;
                      if (v727 < 0)
                      {
                        uint64_t v728 = *v3;
                        unint64_t v729 = *(void *)(a2 + v728);
                        if (v729 == -1LL || v729 >= *(void *)(a2 + *v6)) {
                          goto LABEL_606;
                        }
                        unint64_t v730 = v729 + 1;
                        int v731 = *(char *)(*(void *)(a2 + *v10) + v729);
                        *(void *)(a2 + v728) = v730;
                        if (v731 < 0)
                        {
                          uint64_t v732 = *v3;
                          unint64_t v733 = *(void *)(a2 + v732);
                          if (v733 == -1LL || v733 >= *(void *)(a2 + *v6)) {
                            goto LABEL_606;
                          }
                          unint64_t v734 = v733 + 1;
                          int v735 = *(char *)(*(void *)(a2 + *v10) + v733);
                          *(void *)(a2 + v732) = v734;
                          if (v735 < 0)
                          {
                            uint64_t v736 = *v3;
                            unint64_t v737 = *(void *)(a2 + v736);
                            if (v737 == -1LL || v737 >= *(void *)(a2 + *v6)) {
                              goto LABEL_606;
                            }
                            *(void *)(a2 + v736) = v737 + 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

LABEL_608:
          PBRepeatedInt32Add();
          uint64_t v702 = *v3;
          unint64_t v703 = *(void *)(a2 + v702);
        }

                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v340;
                uint64_t v57 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
                goto LABEL_609;
              }

              int v52 = (os_log_s *)__nwlog_obj();
              uint64_t v53 = type[0];
              if (!os_log_type_enabled(v52, (os_log_type_t)type[0])) {
                goto LABEL_610;
              }
              unsigned int v315 = *(void *)(a1 + 48);
              uint64_t v316 = "invalid";
              if (v315)
              {
                unint64_t v317 = *(const char **)(v315 + 16);
                if (v317) {
                  uint64_t v316 = v317;
                }
              }

LABEL_740:
        return 0LL;
      case 0x1Du:
        uint64_t v11 = PBReaderReadData();
        uint64_t v12 = 104LL;
LABEL_4:
        unsigned int v13 = *(void **)(a1 + v12);
        *(void *)(a1 + v12) = v11;

        goto LABEL_5;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0) {
          return 0LL;
        }
        goto LABEL_5;
    }
  }

  unint64_t v16 = 0LL;
LABEL_39:
  _BYTE *v14 = 1;
  goto LABEL_40;
}

void sub_1820F0DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_socks5_server_create(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  nw_allow_use_of_dispatch_internal();
  if (v4)
  {
    unint64_t v5 = (char *)-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_socks5_server),  v3,  v4);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v6 = (os_log_s *)(id)gLogObj;
    unint64_t v7 = v6;
    if (v5)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v29 = "nw_socks5_server_create";
        __int16 v30 = 2114;
        unint64_t v31 = v5;
        _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ created", buf, 0x16u);
      }

      BOOL v8 = v5;
      goto LABEL_17;
    }

    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_socks5_server_create";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v9, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_socks5_server_create";
        uint64_t v12 = "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed";
LABEL_21:
        uint64_t v17 = v10;
        os_log_type_t v18 = v11;
        goto LABEL_22;
      }

      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_socks5_server_create";
        uint64_t v12 = "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed, backtrace limit exceeded";
        goto LABEL_21;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_23:

          if (!v9) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }

        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_socks5_server_create";
        uint64_t v12 = "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed, no backtrace";
        uint64_t v17 = v10;
        os_log_type_t v18 = v14;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v17, v18, v12, buf, 0xCu);
        goto LABEL_23;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v29 = "nw_socks5_server_create";
        __int16 v30 = 2082;
        unint64_t v31 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v9)
    {
LABEL_17:

      goto LABEL_18;
    }

id nw_socks5_server_copy_parameters(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(id *)(a1 + 40);
  }
  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v12 = "nw_socks5_server_copy_parameters";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_socks5_server_copy_parameters";
        BOOL v6 = "%{public}s called with null server";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v12 = "nw_socks5_server_copy_parameters";
            __int16 v13 = 2082;
            os_log_type_t v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v8) {
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_socks5_server_copy_parameters";
        BOOL v6 = "%{public}s called with null server, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_socks5_server_copy_parameters";
        BOOL v6 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

uint64_t nw_socks5_server_get_port(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    __int16 v19 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_socks5_server_get_port_block_invoke;
    v13[3] = &unk_189BC9210;
    uint64_t v15 = buf;
    os_log_type_t v14 = v1;
    os_unfair_lock_lock(v2 + 6);
    __nw_socks5_server_get_port_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 6);
    uint64_t v3 = *(unsigned __int16 *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_socks5_server_get_port";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socks5_server_get_port";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null server", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socks5_server_get_port";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socks5_server_get_port";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socks5_server_get_port";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null server, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_socks5_server_get_port_block_invoke(uint64_t a1)
{
  uint64_t result = nw_listener_get_port(*(nw_listener_t *)(*(void *)(a1 + 32) + 72LL));
  *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

void nw_socks5_server_cancel_connections(void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = __nw_socks5_server_cancel_connections_block_invoke;
    v11[3] = &unk_189BC93A0;
    uint64_t v3 = v1;
    v11[4] = v3;
    os_unfair_lock_lock(v2 + 6);
    __nw_socks5_server_cancel_connections_block_invoke((uint64_t)v11);
    os_unfair_lock_unlock(v2 + 6);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_socks5_server_cancel_connections";
  os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_socks5_server_cancel_connections";
        os_log_type_t v8 = "%{public}s called with null server";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v15 = "nw_socks5_server_cancel_connections";
            __int16 v16 = 2082;
            uint64_t v17 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v10) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_socks5_server_cancel_connections";
        os_log_type_t v8 = "%{public}s called with null server, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_socks5_server_cancel_connections";
        os_log_type_t v8 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

void __nw_socks5_server_cancel_connections_block_invoke(uint64_t a1)
{
}

void nw_socks5_server_cancel_connections_locked(void *a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v3 = 136446466;
    id v4 = "nw_socks5_server_cancel_connections_locked";
    __int16 v5 = 2048;
    BOOL v6 = v1;
    _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %p", (uint8_t *)&v3, 0x16u);
  }

  nw_array_apply(v1[10], (uint64_t)&__block_literal_global_36359);
}

uint64_t __nw_socks5_server_cancel_connections_locked_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  int v3 = a3;
  id v4 = v3;
  if (v3)
  {
    __int16 v5 = (dispatch_queue_s *)v3[5];
    *(void *)block = MEMORY[0x1895F87A8];
    *(void *)&block[8] = 3221225472LL;
    *(void *)&block[16] = __nw_socks5_connection_cancel_block_invoke;
    uint64_t v18 = &unk_189BC93A0;
    __int16 v19 = v3;
    dispatch_async(v5, block);

    goto LABEL_3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v7 = (id)gLogObj;
  *(_DWORD *)block = 136446210;
  *(void *)&void block[4] = "nw_socks5_connection_cancel";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "nw_socks5_connection_cancel";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", block, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)block = 136446466;
          *(void *)&void block[4] = "nw_socks5_connection_cancel";
          *(_WORD *)&block[12] = 2082;
          *(void *)&block[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  block,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "nw_socks5_connection_cancel";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", block, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v9 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "nw_socks5_connection_cancel";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  block,  0xCu);
      }
    }
  }

void nw_socks5_server_set_error_handler(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  int v3 = a1;
  id v4 = a2;
  __int16 v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_socks5_server_set_error_handler";
    char v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_socks5_server_set_error_handler";
        os_log_type_t v12 = "%{public}s called with null server";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v20;
      BOOL v15 = os_log_type_enabled(v10, v20);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v22 = "nw_socks5_server_set_error_handler";
          __int16 v23 = 2082;
          int v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_35:
        free(v9);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_socks5_server_set_error_handler";
        os_log_type_t v12 = "%{public}s called with null server, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_socks5_server_set_error_handler";
        os_log_type_t v12 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

void __nw_socks5_server_set_error_handler_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 64);
  *(void *)(v3 + 64) = v2;
}

void nw_socks5_server_set_state_changed_handler(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  __int16 v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_socks5_server_set_state_changed_handler";
    char v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_socks5_server_set_state_changed_handler";
        os_log_type_t v12 = "%{public}s called with null server";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v20;
      BOOL v15 = os_log_type_enabled(v10, v20);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v22 = "nw_socks5_server_set_state_changed_handler";
          __int16 v23 = 2082;
          int v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_35:
        free(v9);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_socks5_server_set_state_changed_handler";
        os_log_type_t v12 = "%{public}s called with null server, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_socks5_server_set_state_changed_handler";
        os_log_type_t v12 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

void __nw_socks5_server_set_state_changed_handler_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 56);
  *(void *)(v3 + 56) = v2;
}

void nw_socks5_server_register_udp_associate_request(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  char v9 = a1;
  id v10 = a2;
  id v11 = a3;
  os_log_type_t v12 = a4;
  id v13 = a5;
  os_log_type_t v14 = v13;
  if (!v9)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v48 = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (v48 != OS_LOG_TYPE_FAULT)
    {
      if (v47)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = v48;
        BOOL v30 = os_log_type_enabled(v19, v48);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
            __int16 v51 = 2082;
            int v52 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_66:
          if (!v18) {
            goto LABEL_6;
          }
LABEL_67:
          free(v18);
          goto LABEL_6;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
          uint64_t v21 = "%{public}s called with null server, no backtrace";
          goto LABEL_64;
        }
      }

      else
      {
        __nwlog_obj();
        char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = v48;
        if (os_log_type_enabled(v19, v48))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
          uint64_t v21 = "%{public}s called with null server, backtrace limit exceeded";
          goto LABEL_64;
        }
      }

      goto LABEL_65;
    }

    __nwlog_obj();
    char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v20 = v48;
    if (!os_log_type_enabled(v19, v48)) {
      goto LABEL_65;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
    uint64_t v21 = "%{public}s called with null server";
    goto LABEL_64;
  }

  if (!v13)
  {
    __nwlog_obj();
    os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v48 = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (v48 != OS_LOG_TYPE_FAULT)
    {
      if (!v47)
      {
        __nwlog_obj();
        char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = v48;
        if (os_log_type_enabled(v19, v48))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
          uint64_t v21 = "%{public}s called with null handler, backtrace limit exceeded";
          goto LABEL_64;
        }

        goto LABEL_65;
      }

      unint64_t v31 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v48;
      BOOL v32 = os_log_type_enabled(v19, v48);
      if (!v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
          uint64_t v21 = "%{public}s called with null handler, no backtrace";
          goto LABEL_64;
        }

        goto LABEL_65;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v50 = "nw_socks5_server_register_udp_associate_request";
        __int16 v51 = 2082;
        int v52 = v31;
        uint64_t v33 = "%{public}s called with null handler, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v19, v20, v33, buf, 0x16u);
      }

uint64_t __nw_socks5_server_register_udp_associate_request_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __nw_socks5_server_register_udp_associate_request_block_invoke_2(uint64_t a1)
{
  if (!*(void *)(*(void *)(a1 + 32) + 88LL))
  {
    uint64_t v2 = nw_dictionary_create();
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = *(void **)(v3 + 88);
    *(void *)(v3 + 88) = v2;
  }

  hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 40));
  else {
    BOOL v6 = ":";
  }
  int port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 40));
  nw_endpoint_get_description(*(void **)(a1 + 40));
  xpc_object_t v8 = xpc_string_create_with_format("%s%s%u", hostname, v6, port);
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 88LL);
  string_ptr = xpc_string_get_string_ptr(v8);
  id v11 = nw_dictionary_copy_value(v9, (uint64_t)string_ptr);
  os_log_type_t v12 = *(void **)(a1 + 32);
  if (v11)
  {
    id v13 = (void *)v12[4];
    uint64_t v14 = MEMORY[0x1895F87A8];
    v26[0] = MEMORY[0x1895F87A8];
    v26[1] = 3221225472LL;
    v26[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_4;
    v26[3] = &unk_189BBCBA8;
    uint64_t v15 = (id *)&v27;
    os_log_type_t v27 = v12;
    id v28 = *(id *)(a1 + 48);
    id v29 = v8;
    id v30 = *(id *)(a1 + 56);
    id v31 = *(id *)(a1 + 64);
    id v16 = v11;
    id v17 = v13;
    uint64_t v18 = v26;
    char v19 = (dispatch_queue_s *)v16[5];
    block[0] = v14;
    block[1] = 3221225472LL;
    block[2] = __nw_socks5_connection_validate_udp_association_block_invoke_2;
    block[3] = &unk_189BC50A8;
    os_log_type_t v20 = v16;
    id v35 = v20;
    id v21 = v17;
    id v36 = v21;
    os_log_type_t v22 = v18;
    id v37 = v22;
    dispatch_async(v19, block);
  }

  else
  {
    uint64_t v23 = v12[11];
    int v24 = xpc_string_get_string_ptr(v8);
    nw_dictionary_set_value(v23, v24, *(void **)(a1 + 48));
    v32[0] = MEMORY[0x1895F87A8];
    v32[1] = 3221225472LL;
    void v32[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_3;
    v32[3] = &unk_189BC8740;
    uint64_t v15 = &v33;
    uint64_t v25 = *(dispatch_queue_s **)(a1 + 56);
    id v33 = *(id *)(a1 + 64);
    dispatch_async(v25, v32);
  }
}

uint64_t __nw_socks5_server_register_udp_associate_request_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __nw_socks5_server_register_udp_associate_request_block_invoke_4(uint64_t a1, char a2)
{
  id v4 = *(os_unfair_lock_s **)(a1 + 32);
  __int16 v5 = v4 + 6;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_5;
  v11[3] = &unk_189BBCB80;
  id v10 = v4;
  v11[4] = v10;
  id v6 = *(id *)(a1 + 40);
  void v11[5] = v6;
  char v12 = a2;
  id v7 = *(id *)(a1 + 48);
  v11[6] = v7;
  id v8 = *(id *)(a1 + 56);
  v11[7] = v8;
  id v9 = *(id *)(a1 + 64);
  v11[8] = v9;
  os_unfair_lock_lock(v5);
  __nw_socks5_server_register_udp_associate_request_block_invoke_5((uint64_t)v11);
  os_unfair_lock_unlock(v5);
}

void __nw_socks5_server_register_udp_associate_request_block_invoke_5(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  if (v1[9])
  {
    uint64_t v3 = v1[10];
    uint64_t v4 = *(void *)(a1 + 40);
    if (v3 && v4 != 0)
    {
      id v7 = *(void **)(v3 + 16);
      id v6 = *(void **)(v3 + 24);
      if (v7 != v6)
      {
        while (*v7 != v4)
        {
          if (++v7 == v6)
          {
            id v7 = v6;
            break;
          }
        }
      }

      if (v7 != v6)
      {
        char v8 = *(_BYTE *)(a1 + 72) ^ 1;
        if (!*(_BYTE *)(a1 + 72))
        {
          uint64_t v9 = v1[11];
          string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 48));
          nw_dictionary_set_value(v9, string_ptr, *(void **)(a1 + 40));
        }

        v12[0] = MEMORY[0x1895F87A8];
        v12[1] = 3221225472LL;
        v12[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_6;
        v12[3] = &unk_189BC71E8;
        id v11 = *(dispatch_queue_s **)(a1 + 56);
        id v13 = *(id *)(a1 + 64);
        char v14 = v8;
        dispatch_async(v11, v12);
      }
    }
  }

uint64_t __nw_socks5_server_register_udp_associate_request_block_invoke_6(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

void nw_socks5_server_call_outer_connection_handler(void *a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  __int16 v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (v5)
  {
    uint64_t v8 = v5[12];
    if (v8) {
      (*(void (**)(uint64_t, id, id))(v8 + 16))(v8, v6, v7);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v19 = "nw_socks5_server_call_outer_connection_handler";
  id v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_socks5_server_call_outer_connection_handler";
        id v13 = "%{public}s called with null server";
LABEL_18:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      }
    }

    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            char v19 = "nw_socks5_server_call_outer_connection_handler";
            __int16 v20 = 2082;
            id v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v15) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_socks5_server_call_outer_connection_handler";
        id v13 = "%{public}s called with null server, no backtrace";
        goto LABEL_18;
      }

      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_socks5_server_call_outer_connection_handler";
        id v13 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

void nw_socks5_server_start(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v2 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v3 = (os_log_s *)(id)gLogObj;
  uint64_t v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v25 = "nw_socks5_server_start";
      __int16 v26 = 2114;
      os_log_type_t v27 = v2;
      _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ start", buf, 0x16u);
    }

    __int16 v5 = v2[9];
    uint64_t v6 = MEMORY[0x1895F87A8];
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = __nw_socks5_server_start_block_invoke;
    handler[3] = &unk_189BC9318;
    id v7 = v2;
    id v21 = v7;
    nw_listener_set_state_changed_handler(v5, handler);
    uint64_t v8 = v2[9];
    v18[0] = v6;
    v18[1] = 3221225472LL;
    v18[2] = __nw_socks5_server_start_block_invoke_10;
    v18[3] = &unk_189BBCBD0;
    uint64_t v9 = v7;
    char v19 = v9;
    nw_listener_set_new_connection_handler(v8, v18);
    nw_listener_set_queue(v2[9], (dispatch_queue_t)v9[4]);
    nw_listener_start(v2[9]);
    nw_listener_t v11 = v9[2];
    id v10 = (id *)(v9 + 2);
    if (!v11) {
      objc_storeStrong(v10, a1);
    }

    goto LABEL_7;
  }

  *(_DWORD *)buf = 136446210;
  uint64_t v25 = "nw_socks5_server_start";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v23 = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v12, &v23, &v22))
  {
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v23;
      if (os_log_type_enabled(v13, v23))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_socks5_server_start";
        BOOL v15 = "%{public}s called with null server";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
      }
    }

    else
    {
      if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = v23;
        BOOL v17 = os_log_type_enabled(v13, v23);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v25 = "nw_socks5_server_start";
            __int16 v26 = 2082;
            os_log_type_t v27 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (!v17) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_socks5_server_start";
        BOOL v15 = "%{public}s called with null server, no backtrace";
        goto LABEL_21;
      }

      __nwlog_obj();
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v23;
      if (os_log_type_enabled(v13, v23))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v25 = "nw_socks5_server_start";
        BOOL v15 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

void __nw_socks5_server_start_block_invoke(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(os_unfair_lock_s **)(a1 + 32);
  id v7 = v6 + 6;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = __nw_socks5_server_start_block_invoke_2;
  v10[3] = &unk_189BC92F0;
  uint64_t v8 = v6;
  int v11 = a2;
  v10[4] = v8;
  v10[5] = v5;
  id v9 = v5;
  os_unfair_lock_lock(v7);
  __nw_socks5_server_start_block_invoke_2((uint64_t)v10);
  os_unfair_lock_unlock(v7);
}

void __nw_socks5_server_start_block_invoke_10(uint64_t a1, void *a2)
{
  uint64_t v92 = *MEMORY[0x1895F89C0];
  id v4 = a2;
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void **)(v5 + 40);
  uint64_t v78 = a1;
  if (v6)
  {
    id v7 = v6;
    int v8 = (*(unsigned __int16 *)(v7[13] + 108LL) >> 1) & 1;

    uint64_t v5 = *(void *)(a1 + 32);
  }

  else
  {
    int v8 = 0;
  }

  id v9 = *(void **)(v5 + 32);
  char v10 = *(_BYTE *)(v5 + 136);
  id v11 = v4;
  id v12 = v9;
  id v79 = (id)v5;
  if (v11)
  {
    if (v12)
    {
      id v13 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_socks5_connection);
      id v14 = v11;
      id v15 = v12;
      id v16 = v79;
      if (!v13) {
        goto LABEL_16;
      }
      v88.os_log_type_t receiver = v13;
      v88.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_socks5_connection;
      BOOL v17 = (NWConcrete_nw_socks5_connection *)objc_msgSendSuper2(&v88, sel_init);
      id v13 = v17;
      if (v17)
      {
        do
          unint64_t v18 = __ldaxr(&s_last_connection_id);
        while (__stlxr(v18 + 1, &s_last_connection_id));
        v17->sc_id = v18;
        objc_storeStrong((id *)&v17->sc_in_connection, a2);
        objc_storeStrong((id *)&v13->sc_queue, v9);
        if ((v10 & 1) != 0) {
          char v19 = 101;
        }
        else {
          char v19 = 1;
        }
        v13->sc_uint64_t state = v19;
        if (v8) {
          char v20 = 4;
        }
        else {
          char v20 = 0;
        }
        *((_BYTE *)v13 + 160) = *((_BYTE *)v13 + 160) & 0xFB | v20;
        objc_storeWeak((id *)&v13->sc_parent, v16);
        goto LABEL_16;
      }

      __nwlog_obj();
      uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
      unint64_t v64 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v86 = 0;
      if ((__nwlog_fault(v64, &type, &v86) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          unint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
            _os_log_impl(&dword_181A5C000, v65, v66, "%{public}s [super init] failed", buf, 0xCu);
          }
        }

        else if (v86)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          unint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v73 = type;
          BOOL v74 = os_log_type_enabled(v65, type);
          if (backtrace_string)
          {
            if (v74)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v65,  v73,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_115;
          }

          if (v74)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
            _os_log_impl(&dword_181A5C000, v65, v73, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          unint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v77 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
            _os_log_impl( &dword_181A5C000,  v65,  v77,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

void sub_1820F4D30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void __nw_socks5_server_start_block_invoke_11(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 108);
  if (v3 != -1)
  {
    *(_DWORD *)(v2 + 108) = v3 + 1;
    uint64_t v2 = *(void *)(a1 + 32);
  }

  uint64_t v4 = *(void *)(v2 + 80);
  if (v4)
  {
    unint64_t v5 = (uint64_t)(*(void *)(v4 + 24) - *(void *)(v4 + 16)) >> 3;
    if (v5 > *(unsigned int *)(v2 + 104))
    {
      if (v5 >= 0xFFFFFFFF) {
        LODWORD(v5) = -1;
      }
      *(_DWORD *)(v2 + 104) = v5;
    }
  }

void __nw_socks5_server_start_block_invoke_2_12(uint64_t a1)
{
  uint64_t v2 = *(os_unfair_lock_s **)(a1 + 32);
  int v3 = v2 + 6;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __nw_socks5_server_start_block_invoke_3;
  v6[3] = &unk_189BC9238;
  unint64_t v5 = v2;
  void v6[4] = v5;
  id v4 = *(id *)(a1 + 40);
  v6[5] = v4;
  os_unfair_lock_lock(v3);
  __nw_socks5_server_start_block_invoke_3((uint64_t)v6);
  os_unfair_lock_unlock(v3);
}

void __nw_socks5_server_start_block_invoke_3(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  BOOL v2 = nw_array_duplicate_array_without_object(*(void *)(*(void *)(a1 + 32) + 80LL), *(void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 80);
  *(void *)(v3 + 80) = v2;

  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 80LL);
  if (v5) {
    uint64_t v6 = (uint64_t)(*(void *)(v5 + 24) - *(void *)(v5 + 16)) >> 3;
  }
  else {
    uint64_t v6 = 0LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v7 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    id v9 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 40);
    int v10 = *(_DWORD *)(v8 + 132);
    *(_DWORD *)buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_socks5_server_start_block_invoke_3";
    *(_WORD *)&_BYTE buf[12] = 2112;
    *(void *)&buf[14] = v8;
    *(_WORD *)&_BYTE buf[22] = 2112;
    id v31 = v9;
    LOWORD(v32) = 2048;
    *(void *)((char *)&v32 + 2) = v6;
    WORD5(v32) = 1024;
    HIDWORD(v32) = v10;
    _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ cancelled connection %@, %zu remaining, busy count %u",  buf,  0x30u);
  }

  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 88LL);
  if (v11)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    id v31 = __Block_byref_object_copy__36441;
    *(void *)&__int128 v32 = __Block_byref_object_dispose__36442;
    *((void *)&v32 + 1) = 0LL;
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 3221225472LL;
    v19[2] = __nw_socks5_server_start_block_invoke_13;
    v19[3] = &unk_189BC7820;
    id v20 = *(id *)(a1 + 40);
    id v21 = buf;
    nw_dictionary_apply(v11, (uint64_t)v19);
    id v12 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v12)
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 88LL);
      string_ptr = xpc_string_get_string_ptr(v12);
      nw_dictionary_set_value(v13, string_ptr, 0LL);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v15 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = *(void *)(a1 + 32);
        uint64_t v16 = *(void *)(a1 + 40);
        size_t count = nw_dictionary_get_count(*(void *)(v17 + 88));
        *(_DWORD *)id v22 = 136446978;
        os_log_type_t v23 = "nw_socks5_server_start_block_invoke_2";
        __int16 v24 = 2112;
        uint64_t v25 = v17;
        __int16 v26 = 2112;
        uint64_t v27 = v16;
        __int16 v28 = 2048;
        size_t v29 = count;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ removed connection %@ from udp associate %zu remaining",  v22,  0x2Au);
      }
    }

    _Block_object_dispose(buf, 8);
  }

void sub_1820F5108( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t __Block_byref_object_copy__36441(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__36442(uint64_t a1)
{
}

BOOL __nw_socks5_server_start_block_invoke_13(uint64_t a1, char *string, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 == a3)
  {
    xpc_object_t v6 = xpc_string_create(string);
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }

  return v4 != a3;
}

void __nw_socks5_server_start_block_invoke_2(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  int v2 = *(_DWORD *)(a1 + 48);
  uint64_t v3 = *(void **)(a1 + 40);
  uint64_t v4 = *(id *)(a1 + 32);
  id v5 = v3;
  xpc_object_t v6 = (const void *)v4[7];
  if (v6)
  {
    uint64_t v7 = _Block_copy(v6);
    if (v2 == 4)
    {
      uint64_t v8 = (void *)v4[7];
      v4[7] = 0LL;
    }

    id v9 = (dispatch_queue_s *)v4[6];
    *(void *)block = MEMORY[0x1895F87A8];
    *(void *)&block[8] = 3221225472LL;
    *(void *)&block[16] = __nw_socks5_server_call_state_handler_locked_block_invoke;
    uint64_t v33 = &unk_189BC9440;
    id v35 = v7;
    int v36 = v2;
    id v34 = v5;
    id v10 = v7;
    dispatch_async(v9, block);
  }

  if (*(_DWORD *)(a1 + 48) == 3)
  {
    uint64_t v11 = *(void **)(a1 + 40);
    if (v11)
    {
      id v12 = *(void **)(a1 + 32);
      id v13 = v11;
      id v14 = (const void *)v12[8];
      if (v14)
      {
        id v15 = v12;
        uint64_t v16 = _Block_copy(v14);
        uint64_t v17 = (dispatch_queue_s *)v15[6];
        *(void *)block = MEMORY[0x1895F87A8];
        *(void *)&block[8] = 3221225472LL;
        *(void *)&block[16] = __nw_socks5_server_call_error_handler_locked_block_invoke;
        uint64_t v33 = &unk_189BC91E8;
        id v35 = v16;
        id v34 = v13;
        id v18 = v16;
        dispatch_async(v17, block);
        char v19 = (void *)v12[8];
        v12[8] = 0LL;
      }

      nw_socks5_server_cancel_locked(*(void **)(a1 + 32));
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v20 = (id)gLogObj;
    *(_DWORD *)block = 136446210;
    *(void *)&void block[4] = "nw_socks5_server_start_block_invoke_2";
    id v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (os_log_s *)(id)gLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "nw_socks5_server_start_block_invoke";
        __int16 v24 = "%{public}s listener reported state of failed with NULL error";
LABEL_21:
        __int16 v28 = v22;
        os_log_type_t v29 = v23;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v28, v29, v24, block, 0xCu);
      }
    }

    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (os_log_s *)(id)gLogObj;
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)block = 136446466;
          *(void *)&void block[4] = "nw_socks5_server_start_block_invoke";
          *(_WORD *)&block[12] = 2082;
          *(void *)&block[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v26,  "%{public}s listener reported state of failed with NULL error, dumping backtrace:%{public}s",  block,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v27)
      {
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "nw_socks5_server_start_block_invoke";
        __int16 v24 = "%{public}s listener reported state of failed with NULL error, no backtrace";
        __int16 v28 = v22;
        os_log_type_t v29 = v26;
        goto LABEL_22;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (os_log_s *)(id)gLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)block = 136446210;
        *(void *)&void block[4] = "nw_socks5_server_start_block_invoke";
        __int16 v24 = "%{public}s listener reported state of failed with NULL error, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

LABEL_24:
    if (v21) {
      free(v21);
    }
  }

uint64_t __nw_socks5_server_call_state_handler_locked_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48),  *(void *)(a1 + 32));
}

uint64_t __nw_socks5_server_call_error_handler_locked_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void nw_socks5_server_cancel_locked(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v15 = 136446466;
    uint64_t v16 = "nw_socks5_server_cancel_locked";
    __int16 v17 = 2048;
    id v18 = v1;
    _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %p", (uint8_t *)&v15, 0x16u);
  }

  uint64_t v3 = (void *)*((void *)v1 + 8);
  *((void *)v1 + _Block_object_dispose(va, 8) = 0LL;

  uint64_t v4 = (nw_listener *)*((void *)v1 + 9);
  if (v4)
  {
    nw_listener_cancel(v4);
    id v5 = (void *)*((void *)v1 + 9);
    *((void *)v1 + 9) = 0LL;
  }

  nw_socks5_server_cancel_connections_locked(v1);
  xpc_object_t v6 = (dispatch_source_s *)*((void *)v1 + 15);
  if (v6)
  {
    dispatch_source_cancel(v6);
    if ((*((_BYTE *)v1 + 136) & 2) == 0)
    {
      *((_BYTE *)v1 + 136) |= 2u;
      dispatch_resume(*((dispatch_object_t *)v1 + 15));
    }

    uint64_t v7 = (void *)*((void *)v1 + 15);
    *((void *)v1 + 15) = 0LL;
  }

  IOPMAssertionID v8 = *((_DWORD *)v1 + 32);
  if (v8)
  {
    IOPMAssertionRelease(v8);
    uint64_t v9 = mach_continuous_time();
    if (v9 <= 1) {
      uint64_t v10 = 1LL;
    }
    else {
      uint64_t v10 = v9;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      int v12 = *((_DWORD *)v1 + 32);
      unint64_t v13 = nw_delta_nanos(*((void *)v1 + 14), v10);
      uint64_t v16 = "nw_socks5_server_cancel_locked";
      __int16 v17 = 2112;
      int v15 = 136446978;
      id v18 = v1;
      __int16 v19 = 1024;
      int v20 = v12;
      __int16 v21 = 2048;
      unint64_t v22 = v13 / 0x3B9ACA00;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s %@ released power assertion: %u after %llus",  (uint8_t *)&v15,  0x26u);
    }

    *((void *)v1 + 14) = v10;
    *((_DWORD *)v1 + 32) = 0;
  }

  id v14 = (void *)*((void *)v1 + 2);
  if (v14)
  {
    *((void *)v1 + 2) = 0LL;
  }
}

void nw_socks5_server_cancel(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v2 = (os_log_s *)(id)gLogObj;
  uint64_t v3 = v2;
  if (v1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v16 = "nw_socks5_server_cancel";
      __int16 v17 = 2114;
      id v18 = (char *)v1;
      _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ cancel", buf, 0x16u);
    }

    uint64_t v4 = (dispatch_queue_s *)v1[4];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_socks5_server_cancel_block_invoke;
    block[3] = &unk_189BC93A0;
    int v12 = v1;
    dispatch_async(v4, block);

    goto LABEL_5;
  }

  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_socks5_server_cancel";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      xpc_object_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_socks5_server_cancel";
        IOPMAssertionID v8 = "%{public}s called with null server";
LABEL_19:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        xpc_object_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v16 = "nw_socks5_server_cancel";
            __int16 v17 = 2082;
            id v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null server, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (!v10) {
          goto LABEL_20;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_socks5_server_cancel";
        IOPMAssertionID v8 = "%{public}s called with null server, no backtrace";
        goto LABEL_19;
      }

      __nwlog_obj();
      xpc_object_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_socks5_server_cancel";
        IOPMAssertionID v8 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_19;
      }
    }

void __nw_socks5_server_cancel_block_invoke(uint64_t a1)
{
  id v1 = *(os_unfair_lock_s **)(a1 + 32);
  int v2 = v1 + 6;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_socks5_server_cancel_block_invoke_2;
  v4[3] = &unk_189BC93A0;
  uint64_t v3 = v1;
  v4[4] = v3;
  os_unfair_lock_lock(v2);
  __nw_socks5_server_cancel_block_invoke_2((uint64_t)v4);
  os_unfair_lock_unlock(v2);
}

void __nw_socks5_server_cancel_block_invoke_2(uint64_t a1)
{
}

void __nw_socks5_server_handle_busy_changed_block_invoke(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (MEMORY[0x1896083B8])
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (*(_DWORD *)(v2 + 132))
    {
      uint64_t v3 = *(dispatch_object_s **)(v2 + 120);
      if (v3 && (*(_BYTE *)(v2 + 136) & 2) != 0)
      {
        dispatch_suspend(v3);
        *(_BYTE *)(*(void *)(a1 + 32) + 136LL) &= ~2u;
        uint64_t v2 = *(void *)(a1 + 32);
      }

      if (!*(_DWORD *)(v2 + 128))
      {
        uint64_t v4 = (uint64_t *)(id)v2;
        keys[0] = xmmword_189BBCC10;
        keys[1] = *(_OWORD *)off_189BBCC20;
        unint64_t v50 = @"TimeoutAction";
        int v36 = 10800;
        int valuePtr = 255;
        id v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
        CFStringRef v7 = CFStringCreateWithFormat(v5, 0LL, @"%@", v4);
        CFNumberRef v8 = CFNumberCreate(v5, kCFNumberIntType, &v36);
        CFNumberRef v9 = v8;
        values[0] = @"PreventUserIdleSystemSleep";
        values[1] = v6;
        values[2] = (void *)v7;
        values[3] = v8;
        values[4] = @"TimeoutActionTurnOff";
        if (v6 && v7 && v8)
        {
          CFDictionaryRef v10 = CFDictionaryCreate( v5,  (const void **)keys,  (const void **)values,  5LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
        }

        else
        {
          CFDictionaryRef v10 = 0LL;
          id v18 = 0LL;
          if (!v6) {
            goto LABEL_18;
          }
        }

        CFRelease(v6);
        id v18 = v10;
LABEL_18:
        if (v7) {
          CFRelease(v7);
        }
        if (v9) {
          CFRelease(v9);
        }
        if (!v18)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v22 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v39 = "nw_socks5_server_create_power_assertion";
            __int16 v40 = 2112;
            id v41 = v4;
            _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s %@ Failed to create power assertion properties",  buf,  0x16u);
          }

          IOPMAssertionID v21 = 0;
          goto LABEL_40;
        }

        IOPMAssertionID AssertionID = 0;
        unsigned int v19 = IOPMAssertionCreateWithProperties(v18, &AssertionID);
        CFRelease(v18);
        if (v19)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v20 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447490;
            unint64_t v39 = "nw_socks5_server_create_power_assertion";
            __int16 v40 = 2112;
            id v41 = v4;
            __int16 v42 = 1024;
            IOPMAssertionID v43 = v19;
            __int16 v44 = 1024;
            *(_DWORD *)uint64_t v45 = v19 >> 26;
            *(_WORD *)&v45[4] = 1024;
            *(_DWORD *)&v45[6] = (v19 >> 14) & 0xFFF;
            __int16 v46 = 1024;
            int v47 = v19 & 0x3FFF;
            _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s %@ IOPMAssertionCreateWithProperties failed: %x (system: %d, subsystem: %d, code: %d)",  buf,  0x2Eu);
          }

          IOPMAssertionID v21 = 0;
          goto LABEL_40;
        }

        uint64_t v23 = mach_continuous_time();
        if (v23 <= 1) {
          uint64_t v24 = 1LL;
        }
        else {
          uint64_t v24 = v23;
        }
        uint64_t v25 = v4[14];
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v26 = (os_log_s *)(id)gLogObj;
        BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
        if (v25)
        {
          if (v27)
          {
            IOPMAssertionID v28 = AssertionID;
            unint64_t v29 = nw_delta_nanos(v4[14], v24);
            unint64_t v39 = "nw_socks5_server_create_power_assertion";
            __int16 v40 = 2112;
            *(_DWORD *)buf = 136446978;
            id v41 = v4;
            __int16 v42 = 1024;
            IOPMAssertionID v43 = v28;
            __int16 v44 = 2048;
            *(void *)uint64_t v45 = v29 / 0x3B9ACA00;
            char v30 = "%{public}s %@ created power assertion: %u after %llus";
            id v31 = v26;
            uint32_t v32 = 38;
LABEL_38:
            _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
          }
        }

        else if (v27)
        {
          *(_DWORD *)buf = 136446722;
          unint64_t v39 = "nw_socks5_server_create_power_assertion";
          __int16 v40 = 2112;
          id v41 = v4;
          __int16 v42 = 1024;
          IOPMAssertionID v43 = AssertionID;
          char v30 = "%{public}s %@ created power assertion: %u";
          id v31 = v26;
          uint32_t v32 = 28;
          goto LABEL_38;
        }

        v4[14] = v24;
        IOPMAssertionID v21 = AssertionID;
LABEL_40:

        *(_DWORD *)(*(void *)(a1 + 32) + 128LL) = v21;
      }
    }

    else if (*(_DWORD *)(v2 + 128))
    {
      uint64_t v11 = *(dispatch_source_s **)(v2 + 120);
      if (v11) {
        goto LABEL_14;
      }
      dispatch_source_t v12 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *(dispatch_queue_t *)(v2 + 32));
      uint64_t v13 = *(void *)(a1 + 32);
      id v14 = *(void **)(v13 + 120);
      *(void *)(v13 + 120) = v12;

      *(_BYTE *)(*(void *)(a1 + 32) + 136LL) &= ~2u;
      int v15 = *(void **)(a1 + 32);
      uint64_t v16 = (dispatch_source_s *)v15[15];
      handler[0] = MEMORY[0x1895F87A8];
      handler[1] = 3221225472LL;
      handler[2] = __nw_socks5_server_handle_busy_changed_block_invoke_2;
      handler[3] = &unk_189BC93A0;
      id v34 = v15;
      dispatch_source_set_event_handler(v16, handler);

      uint64_t v2 = *(void *)(a1 + 32);
      uint64_t v11 = *(dispatch_source_s **)(v2 + 120);
      if (v11)
      {
LABEL_14:
        if ((*(_BYTE *)(v2 + 136) & 2) == 0)
        {
          dispatch_time_t v17 = dispatch_time(0LL, 5000000000LL);
          dispatch_source_set_timer(v11, v17, 0xFFFFFFFFFFFFFFFFLL, 0x989680uLL);
          dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 32) + 120LL));
          *(_BYTE *)(*(void *)(a1 + 32) + 136LL) |= 2u;
        }
      }
    }
  }

void __nw_socks5_server_handle_busy_changed_block_invoke_2(uint64_t a1)
{
  id v1 = *(os_unfair_lock_s **)(a1 + 32);
  uint64_t v2 = v1 + 6;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_socks5_server_handle_busy_changed_block_invoke_3;
  v4[3] = &unk_189BC93A0;
  uint64_t v3 = v1;
  v4[4] = v3;
  os_unfair_lock_lock(v2);
  __nw_socks5_server_handle_busy_changed_block_invoke_3((uint64_t)v4);
  os_unfair_lock_unlock(v2);
}

void __nw_socks5_server_handle_busy_changed_block_invoke_3(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(dispatch_object_s **)(v2 + 120);
  if (v3 && (*(_BYTE *)(v2 + 136) & 2) != 0)
  {
    dispatch_suspend(v3);
    *(_BYTE *)(*(void *)(a1 + 32) + 136LL) &= ~2u;
    uint64_t v2 = *(void *)(a1 + 32);
  }

  if (!*(_DWORD *)(v2 + 132))
  {
    IOPMAssertionID v4 = *(_DWORD *)(v2 + 128);
    if (v4)
    {
      IOPMAssertionRelease(v4);
      uint64_t v5 = mach_continuous_time();
      if (v5 <= 1) {
        uint64_t v6 = 1LL;
      }
      else {
        uint64_t v6 = v5;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFStringRef v7 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *(void *)(a1 + 32);
        int v9 = *(_DWORD *)(v8 + 128);
        unint64_t v10 = nw_delta_nanos(*(void *)(v8 + 112), v6);
        dispatch_source_t v12 = "nw_socks5_server_handle_busy_changed_block_invoke_3";
        __int16 v13 = 2112;
        int v11 = 136446978;
        uint64_t v14 = v8;
        __int16 v15 = 1024;
        int v16 = v9;
        __int16 v17 = 2048;
        unint64_t v18 = v10 / 0x3B9ACA00;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ released power assertion: %u after %llus",  (uint8_t *)&v11,  0x26u);
      }

      *(void *)(*(void *)(a1 + 32) + 112LL) = v6;
      *(_DWORD *)(*(void *)(a1 + 32) + 128LL) = 0;
    }
  }

char *nw_shoes_server_create(void *a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v2 = nw_socks5_server_create(a1, a2);
  uint64_t v3 = v2;
  if (v2)
  {
    v2[136] |= 1u;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    IOPMAssertionID v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136446466;
      uint64_t v8 = "nw_shoes_server_create";
      __int16 v9 = 2114;
      unint64_t v10 = v3;
      _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ created", (uint8_t *)&v7, 0x16u);
    }

    uint64_t v5 = v3;
  }

  return v3;
}

void nw_shoes_server_set_error_handler(void *a1, void *a2)
{
  id v3 = a2;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __nw_shoes_server_set_error_handler_block_invoke;
  v5[3] = &unk_189BC5710;
  id v6 = v3;
  id v4 = v3;
  nw_socks5_server_set_error_handler(a1, v5);
}

void __nw_shoes_server_set_error_handler_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v5 = v3;
  if (v3) {
    CFErrorRef v4 = nw_error_copy_cf_error(v3);
  }
  else {
    CFErrorRef v4 = 0LL;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t nw_shoes_server_fillout_statistics(void *a1, void *a2, unint64_t a3, char a4)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  int v7 = a1;
  uint64_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
    __int16 v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
        unint64_t v18 = "%{public}s called with null server";
LABEL_39:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      }

uint64_t __nw_socks5_server_fillout_statistics_block_invoke(uint64_t result)
{
  **(void **)(result + 40) = *(void *)(*(void *)(result + 32) + 104LL);
  if (*(_BYTE *)(result + 48)) {
    *(void *)(*(void *)(result + 32) + 104LL) = 0LL;
  }
  return result;
}

void sub_1820F8F98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, void *a24, void *a25, void *a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31)
{
  _Unwind_Resume(a1);
}

void sub_1820F9840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1820FA9A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1820FB2F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_fallback_start_fallback_child(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v146 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v95 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v133 = "nw_endpoint_fallback_start_fallback_child";
    uint64_t v96 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v130 = 0;
    if (__nwlog_fault(v96, &type, &v130))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v98 = type;
        if (os_log_type_enabled(v97, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v133 = "nw_endpoint_fallback_start_fallback_child";
          _os_log_impl(&dword_181A5C000, v97, v98, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v130)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v100 = type;
        BOOL v101 = os_log_type_enabled(v97, type);
        if (backtrace_string)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v133 = "nw_endpoint_fallback_start_fallback_child";
            __int16 v134 = 2082;
            unint64_t v135 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v97,  v100,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_111;
        }

        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v133 = "nw_endpoint_fallback_start_fallback_child";
          _os_log_impl(&dword_181A5C000, v97, v100, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unint64_t v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v102 = type;
        if (os_log_type_enabled(v97, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v133 = "nw_endpoint_fallback_start_fallback_child";
          _os_log_impl( &dword_181A5C000,  v97,  v102,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1820FC2B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_fallback_receive_report(void *a1, uint64_t a2, int a3, _WORD *a4, void *a5, void *a6)
{
  uint64_t v311 = *MEMORY[0x1895F89C0];
  uint64_t v10 = a1;
  id v281 = a5;
  id v11 = a6;
  unint64_t v280 = v10;
  int v282 = v11;
  if (!v11)
  {
    __nwlog_obj();
    uint64_t v185 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v286 = "nw_endpoint_fallback_receive_report";
    uint64_t v186 = _os_log_send_and_compose_impl();

    LOBYTE(type) = 16;
    char v283 = 0;
    if (__nwlog_fault((const char *)v186, &type, &v283))
    {
      if (type == 17)
      {
        uint64_t v187 = __nwlog_obj();
        os_log_type_t v188 = type;
        if (os_log_type_enabled((os_log_t)v187, (os_log_type_t)type))
        {
          *(_DWORD *)buf = 136446210;
          int v286 = "nw_endpoint_fallback_receive_report";
          _os_log_impl(&dword_181A5C000, (os_log_t)v187, v188, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else
      {
        if (v283)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v190 = __nwlog_obj();
          os_log_type_t v191 = type;
          BOOL v192 = os_log_type_enabled((os_log_t)v190, (os_log_type_t)type);
          if (backtrace_string)
          {
            if (v192)
            {
              *(_DWORD *)buf = 136446466;
              int v286 = "nw_endpoint_fallback_receive_report";
              __int16 v287 = 2082;
              unint64_t v288 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  (os_log_t)v190,  v191,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
          }

          else
          {
            if (v192)
            {
              *(_DWORD *)buf = 136446210;
              int v286 = "nw_endpoint_fallback_receive_report";
              _os_log_impl( &dword_181A5C000,  (os_log_t)v190,  v191,  "%{public}s called with null handler, no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_214;
        }

        uint64_t v187 = __nwlog_obj();
        os_log_type_t v193 = type;
        if (os_log_type_enabled((os_log_t)v187, (os_log_type_t)type))
        {
          *(_DWORD *)buf = 136446210;
          int v286 = "nw_endpoint_fallback_receive_report";
          _os_log_impl( &dword_181A5C000,  (os_log_t)v187,  v193,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1820FE52C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, void *a20, void *a21, uint64_t a22, void *a23, void *a24)
{
  _Unwind_Resume(a1);
}

void ___ZL32nw_endpoint_fallback_start_timerP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1)
{
}

void nw_endpoint_fallback_start_post_transport_timer(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v3 = (uint64_t *)nw_endpoint_handler_copy_fallback(v1);
  uint64_t v4 = v3[10];
  if (v4)
  {
    nw_queue_cancel_source(v4, v2);
    v3[10] = 0LL;
  }

  int64_t int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_tcpconn_fallback_post_transport_timeout,  3000LL);
  if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v6 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(v1);
      uint64_t v8 = nw_endpoint_handler_dry_run_string(v1);
      os_log_type_t v26 = v3;
      nw_endpoint_t v9 = nw_endpoint_handler_copy_endpoint(v1);
      logging_description = nw_endpoint_get_logging_description(v9);
      id v11 = nw_endpoint_handler_state_string(v1);
      size_t v12 = nw_endpoint_handler_mode_string(v1);
      id v13 = nw_endpoint_handler_copy_current_path(v1);
      *(_DWORD *)buf = 136448002;
      char v32 = "nw_endpoint_fallback_start_post_transport_timer";
      __int16 v33 = 2082;
      nw_endpoint_t v34 = (void *)id_string;
      __int16 v35 = 2082;
      uint64_t v36 = v8;
      __int16 v37 = 2082;
      unint64_t v38 = logging_description;
      __int16 v39 = 2082;
      __int16 v40 = v11;
      __int16 v41 = 2082;
      char v42 = v12;
      __int16 v43 = 2114;
      id v44 = v13;
      __int16 v45 = 2048;
      int64_t v46 = int64_with_default;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting post-transport fallbac k timer for %llums",  buf,  0x52u);

      id v3 = v26;
    }
  }

  id v14 = nw_endpoint_handler_copy_context(v1);
  v29[0] = MEMORY[0x1895F87A8];
  v29[1] = 3221225472LL;
  v29[2] = ___ZL47nw_endpoint_fallback_start_post_transport_timerP30NWConcrete_nw_endpoint_handler_block_invoke;
  v29[3] = &unk_189BC93A0;
  __int16 v15 = v1;
  char v30 = v15;
  v3[10] = nw_queue_context_create_source(v14, 2, 3, 0, v29, 0LL);

  uint64_t v16 = v3[10];
  if (v16)
  {
    dispatch_time_t v17 = dispatch_time(0x8000000000000000LL, 1000000 * int64_with_default);
    if (*(void *)v16)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }

    else
    {
      *(void *)(v16 + 32) = v17;
      *(void *)(v16 + 40) = -1LL;
      if (*(_BYTE *)(v16 + 48) && *(_BYTE *)(v16 + 49)) {
        nw_queue_source_run_timer(v16, v17);
      }
    }

    nw_queue_activate_source(v3[10], v17);
    goto LABEL_20;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v18 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  char v32 = "nw_endpoint_fallback_start_post_transport_timer";
  nw_endpoint_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v20 = (os_log_s *)(id)gLogObj;
    os_log_type_t v21 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      char v32 = "nw_endpoint_fallback_start_post_transport_timer";
      _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s nw_queue_context_create_source(timer) failed", buf, 0xCu);
    }

void sub_1820FECBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_fallback_start_usage_cap_timer(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v3 = nw_endpoint_handler_copy_fallback(v1);
  uint64_t v4 = *((void *)v3 + 11);
  if (v4)
  {
    nw_queue_cancel_source(v4, v2);
    *((void *)v3 + 11) = 0LL;
  }

  *((void *)v3 + 2) = networkd_settings_get_int64_with_default( (const char *)nw_setting_tcpconn_fallback_usage_cap_interval,  3000LL);
  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v1);
  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v1);
  if (!minimize_logging)
  {
    if ((logging_disabled & 1) != 0) {
      goto LABEL_10;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v7 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id_string = nw_endpoint_handler_get_id_string(v1);
      nw_endpoint_t v9 = nw_endpoint_handler_dry_run_string(v1);
      nw_endpoint_t v10 = nw_endpoint_handler_copy_endpoint(v1);
      logging_description = nw_endpoint_get_logging_description(v10);
      size_t v12 = nw_endpoint_handler_state_string(v1);
      id v13 = nw_endpoint_handler_mode_string(v1);
      id v14 = nw_endpoint_handler_copy_current_path(v1);
      uint64_t v15 = *((void *)v3 + 1);
      uint64_t v16 = *((void *)v3 + 2);
      *(_DWORD *)buf = 136448258;
      __int16 v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      __int16 v44 = 2082;
      __int16 v45 = (void *)id_string;
      __int16 v46 = 2082;
      uint64_t v47 = v9;
      __int16 v48 = 2082;
      id v49 = logging_description;
      __int16 v50 = 2082;
      uint64_t v51 = v12;
      __int16 v52 = 2082;
      uint64_t v53 = v13;
      __int16 v54 = 2114;
      id v55 = v14;
      __int16 v56 = 2048;
      uint64_t v57 = v15;
      __int16 v58 = 2048;
      uint64_t v59 = v16;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] applying data cap of %llu to fa llback child, checking every %llums",  buf,  0x5Cu);
    }

    goto LABEL_9;
  }

  if ((logging_disabled & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v7 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      char v29 = nw_endpoint_handler_get_id_string(v1);
      char v30 = nw_endpoint_handler_dry_run_string(v1);
      nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(v1);
      char v32 = nw_endpoint_get_logging_description(v31);
      __int16 v33 = nw_endpoint_handler_state_string(v1);
      nw_endpoint_t v34 = nw_endpoint_handler_mode_string(v1);
      id v35 = nw_endpoint_handler_copy_current_path(v1);
      uint64_t v36 = *((void *)v3 + 1);
      uint64_t v37 = *((void *)v3 + 2);
      *(_DWORD *)buf = 136448258;
      __int16 v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      __int16 v44 = 2082;
      __int16 v45 = (void *)v29;
      __int16 v46 = 2082;
      uint64_t v47 = v30;
      __int16 v48 = 2082;
      id v49 = v32;
      __int16 v50 = 2082;
      uint64_t v51 = v33;
      __int16 v52 = 2082;
      uint64_t v53 = v34;
      __int16 v54 = 2114;
      id v55 = v35;
      __int16 v56 = 2048;
      uint64_t v57 = v36;
      __int16 v58 = 2048;
      uint64_t v59 = v37;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] applying data cap of %llu to fa llback child, checking every %llums",  buf,  0x5Cu);
    }

void sub_1820FF398(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void ___ZL42nw_endpoint_fallback_start_usage_cap_timerP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1)
{
  uint64_t v198 = *MEMORY[0x1895F89C0];
  id v170 = *(id *)(a1 + 32);
  if (!v170)
  {
    __nwlog_obj();
    unint64_t v135 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v183 = "nw_endpoint_fallback_check_usage_cap";
    nw_endpoint_t v136 = (char *)_os_log_send_and_compose_impl();

    v173[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v181) = 0;
    if (__nwlog_fault(v136, v173, &v181))
    {
      if (v173[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v138 = v173[0];
        if (os_log_type_enabled(v137, v173[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v183 = "nw_endpoint_fallback_check_usage_cap";
          _os_log_impl(&dword_181A5C000, v137, v138, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if ((_BYTE)v181)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v140 = v173[0];
        BOOL v141 = os_log_type_enabled(v137, v173[0]);
        if (backtrace_string)
        {
          if (v141)
          {
            *(_DWORD *)buf = 136446466;
            id v183 = "nw_endpoint_fallback_check_usage_cap";
            __int16 v184 = 2082;
            id_str = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v137,  v140,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_155;
        }

        if (v141)
        {
          *(_DWORD *)buf = 136446210;
          id v183 = "nw_endpoint_fallback_check_usage_cap";
          _os_log_impl(&dword_181A5C000, v137, v140, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v149 = v173[0];
        if (os_log_type_enabled(v137, v173[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v183 = "nw_endpoint_fallback_check_usage_cap";
          _os_log_impl( &dword_181A5C000,  v137,  v149,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182100864( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21)
{
  _Unwind_Resume(a1);
}

void ___ZL36nw_endpoint_fallback_check_usage_capP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  id v3 = *(void **)(a1 + 32);
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
    dispatch_time_t v40 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (__nwlog_fault(v40, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
          _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v54)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        BOOL v45 = os_log_type_enabled(v41, type);
        if (backtrace_string)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
            __int16 v58 = 2082;
            BOOL v59 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v41,  v44,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_58;
        }

        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
          _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
          _os_log_impl( &dword_181A5C000,  v41,  v46,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182101134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL47nw_endpoint_fallback_start_post_transport_timerP30NWConcrete_nw_endpoint_handler_block_invoke( uint64_t a1)
{
  id v1 = *(_WORD **)(a1 + 32);
  *((_DWORD *)v1 + 20) = 327685;
  nw_endpoint_handler_report(v1, 0LL, v1 + 40, 0LL);
}

uint64_t nw_endpoint_fallback_get_timeout_nanos_for_path(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1;
    char v4 = v3[473];

    if ((v4 & 1) != 0)
    {
      unint64_t int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_tcpconn_weak_fallback_delay,  200LL);
      unint64_t v5 = networkd_settings_get_int64_with_default(nw_setting_tcpconn_fallback_delay_cap_ms, 500LL);
      uint64_t v7 = 2 * int64_with_default;
    }

    else
    {
      unint64_t v5 = networkd_settings_get_int64_with_default(nw_setting_tcpconn_strong_fallback_delay, 100LL);
    }

    uint64_t v8 = 1000000 * v5;
    goto LABEL_9;
  }

  __nwlog_obj();
  nw_endpoint_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          id v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
          __int16 v22 = 2082;
          id v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        id v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_fallback_reset_expected_progress_target(void *a1, uint64_t a2)
{
  uint64_t v92 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v77 = "nw_endpoint_handler_get_mode";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (__nwlog_fault(v44, &type, &v74))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v45, type))
        {
          *(_DWORD *)buf = 136446210;
          id v77 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v45, v46, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v74)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v48 = type;
        BOOL v49 = os_log_type_enabled(v45, type);
        if (backtrace_string)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446466;
            id v77 = "nw_endpoint_handler_get_mode";
            __int16 v78 = 2082;
            char v79 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v45,  v48,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_55;
        }

        if (v49)
        {
          *(_DWORD *)buf = 136446210;
          id v77 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v45, v48, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v45, type))
        {
          *(_DWORD *)buf = 136446210;
          id v77 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v45,  v50,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182101F3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__int128 *nw_protocol_http2_transport_identifier()
{
  if (nw_protocol_http2_transport_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_http2_transport_identifier::onceToken, &__block_literal_global_36918);
  }
  return &g_http2_transport_protocol_identifier;
}

BOOL __nw_protocol_http2_transport_identifier_block_invoke()
{
  qword_18C593F38 = (uint64_t)nw_protocol_default_reset;
  unk_18C593F40 = nw_protocol_default_input_flush;
  qword_18C593F08 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_18C593F10 = nw_protocol_default_waiting_for_output;
  qword_18C593EC8 = (uint64_t)nw_protocol_default_register_notification;
  unk_18C593ED0 = nw_protocol_default_unregister_notification;
  qword_18C593E58 = (uint64_t)nw_protocol_http2_transport_disconnect;
  unk_18C593E60 = nw_protocol_http2_transport_connected;
  qword_18C593EF8 = (uint64_t)nw_protocol_http2_transport_output_finished;
  unk_18C593F00 = nw_protocol_default_get_output_local;
  qword_18C593EE8 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_18C593EF0 = nw_protocol_http2_transport_input_finished;
  g_http2_transport_protocol_callbacks = (uint64_t)nw_protocol_http2_transport_add_input_handler;
  unk_18C593E40 = nw_protocol_http2_transport_remove_input_handler;
  qword_18C593E48 = (uint64_t)nw_protocol_http2_replace_input_handler;
  unk_18C593E50 = nw_protocol_http2_transport_connect;
  qword_18C593E78 = (uint64_t)nw_protocol_http2_transport_input_available;
  unk_18C593E80 = nw_protocol_http2_transport_output_available;
  qword_18C593E88 = (uint64_t)nw_protocol_http2_transport_get_input_frames;
  unk_18C593E90 = nw_protocol_http2_transport_get_output_frames;
  qword_18C593EA8 = (uint64_t)nw_protocol_http2_transport_get_parameters;
  unk_18C593EB0 = nw_protocol_default_get_path;
  qword_18C593E98 = (uint64_t)nw_protocol_http2_transport_finalize_output_frames;
  unk_18C593EA0 = nw_protocol_default_link_state;
  qword_18C593F18 = (uint64_t)nw_protocol_default_copy_info;
  unk_18C593F20 = nw_protocol_http2_transport_add_listen_handler;
  qword_18C593F28 = (uint64_t)nw_protocol_http2_transport_remove_listen_handler;
  unk_18C593F30 = nw_protocol_default_get_message_properties;
  qword_18C593EB8 = (uint64_t)nw_protocol_default_get_local;
  unk_18C593EC0 = nw_protocol_http2_transport_get_remote_endpoint;
  qword_18C593E68 = (uint64_t)nw_protocol_http2_transport_disconnected;
  unk_18C593E70 = nw_protocol_http2_transport_error;
  qword_18C593ED8 = (uint64_t)nw_protocol_http2_transport_notify;
  unk_18C593EE0 = nw_protocol_default_updated_path;
  qword_18C593F70 = 0x200000003LL;
  return nw_protocol_register_many_to_one( (uint64_t)&g_http2_transport_protocol_identifier,  (uint64_t)nw_protocol_http2_transport_create,  (uint64_t)nw_protocol_http2_transport_accept);
}

BOOL nw_protocol_http2_transport_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v64 = "nw_protocol_http2_transport_connect";
    BOOL v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_116;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v64 = "nw_protocol_http2_transport_connect";
      char v30 = "%{public}s called with null protocol";
LABEL_115:
      _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      goto LABEL_116;
    }

    if (!v61)
    {
      nw_endpoint_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v64 = "nw_protocol_http2_transport_connect";
        char v30 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_115;
      }

      goto LABEL_116;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v43 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v64 = "nw_protocol_http2_transport_connect";
        char v30 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_115;
      }

      goto LABEL_116;
    }

    if (!v43) {
      goto LABEL_94;
    }
    *(_DWORD *)buf = 136446466;
    unint64_t v64 = "nw_protocol_http2_transport_connect";
    __int16 v65 = 2082;
    nw_endpoint_t v66 = backtrace_string;
    os_log_type_t v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_93:
    _os_log_impl(&dword_181A5C000, v28, v29, v44, buf, 0x16u);
    goto LABEL_94;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v64 = "nw_protocol_http2_transport_connect";
    BOOL v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_116;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v64 = "nw_protocol_http2_transport_connect";
      char v30 = "%{public}s called with null http2_transport";
      goto LABEL_115;
    }

    if (!v61)
    {
      nw_endpoint_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v64 = "nw_protocol_http2_transport_connect";
        char v30 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_115;
      }

      goto LABEL_116;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v45 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v64 = "nw_protocol_http2_transport_connect";
        char v30 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_115;
      }

      goto LABEL_116;
    }

    if (!v45) {
      goto LABEL_94;
    }
    *(_DWORD *)buf = 136446466;
    unint64_t v64 = "nw_protocol_http2_transport_connect";
    __int16 v65 = 2082;
    nw_endpoint_t v66 = backtrace_string;
    os_log_type_t v44 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_93;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v64 = "nw_protocol_http2_transport_connect";
    BOOL v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v64 = "nw_protocol_http2_transport_connect";
        char v30 = "%{public}s called with null other_protocol";
        goto LABEL_115;
      }

void nw_protocol_http2_transport_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
    int64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
      char v22 = "%{public}s called with null protocol";
    }

    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v27 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_98:
        if (!v19) {
          return;
        }
        goto LABEL_99;
      }

      if (!v27) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
      char v22 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      int64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
      char v22 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_97;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
    int64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        int64_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_98;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
        char v22 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_97;
      }

      nw_endpoint_t v28 = (char *)__nw_create_backtrace_string();
      int64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v29 = os_log_type_enabled(v20, type);
      if (!v28)
      {
        if (!v29) {
          goto LABEL_98;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
        char v22 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_97;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_connected";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v28;
        char v30 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_68:
        _os_log_impl(&dword_181A5C000, v20, v21, v30, buf, 0x16u);
      }

void nw_protocol_http2_transport_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v39 = "nw_protocol_http2_transport_disconnect";
    int v13 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "nw_protocol_http2_transport_disconnect";
      uint32_t v16 = "%{public}s called with null protocol";
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v25 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v39 = "nw_protocol_http2_transport_disconnect";
          __int16 v40 = 2082;
          uint64_t v41 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_79:
        if (!v13) {
          return;
        }
        goto LABEL_80;
      }

      if (!v25) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "nw_protocol_http2_transport_disconnect";
      uint32_t v16 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "nw_protocol_http2_transport_disconnect";
      uint32_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_78;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v39 = "nw_protocol_http2_transport_disconnect";
    int v13 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v36)
      {
        BOOL v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (!os_log_type_enabled(v14, type)) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v39 = "nw_protocol_http2_transport_disconnect";
        uint32_t v16 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_78;
      }

      char v26 = (char *)__nw_create_backtrace_string();
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v27 = os_log_type_enabled(v14, type);
      if (!v26)
      {
        if (!v27) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v39 = "nw_protocol_http2_transport_disconnect";
        uint32_t v16 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_78;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v39 = "nw_protocol_http2_transport_disconnect";
        __int16 v40 = 2082;
        uint64_t v41 = (nw_protocol_identifier *)v26;
        nw_endpoint_t v28 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_51:
        _os_log_impl(&dword_181A5C000, v14, v15, v28, buf, 0x16u);
      }

void nw_protocol_http2_transport_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        uint32_t v16 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          BOOL v29 = "nw_protocol_http2_transport_disconnected";
          __int16 v30 = 2082;
          BOOL v31 = (char *)handle + 205;
          _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
        }
      }

      nw_protocol_remove_instance((uint64_t)a1);
      uint64_t v4 = handle[13];
      if (!v4) {
        goto LABEL_8;
      }
      if (*(void *)v4)
      {
        uint64_t v5 = *(void (**)(void))(*(void *)v4 + 8LL);
        if (v5)
        {
          v5();
LABEL_8:
          nw_http2_transport_connection_close((uint64_t)handle);
          return;
        }
      }

      __nwlog_obj();
      uint64_t v6 = (char *)handle[13];
      *(_DWORD *)buf = 136446466;
      BOOL v29 = "nw_protocol_http2_transport_disconnected";
      __int16 v30 = 2048;
      BOOL v31 = v6;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (__nwlog_fault(v7, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v8 = (os_log_s *)__nwlog_obj();
          os_log_type_t v9 = type;
          if (!os_log_type_enabled(v8, type)) {
            goto LABEL_49;
          }
          uint64_t v10 = (char *)handle[13];
          *(_DWORD *)buf = 136446466;
          BOOL v29 = "nw_protocol_http2_transport_disconnected";
          __int16 v30 = 2048;
          BOOL v31 = v10;
          uint32_t v11 = "%{public}s listen protocol (%p) has invalid disconnected callback";
          goto LABEL_48;
        }

        if (!v26)
        {
          uint64_t v8 = (os_log_s *)__nwlog_obj();
          os_log_type_t v9 = type;
          if (!os_log_type_enabled(v8, type)) {
            goto LABEL_49;
          }
          BOOL v24 = (char *)handle[13];
          *(_DWORD *)buf = 136446466;
          BOOL v29 = "nw_protocol_http2_transport_disconnected";
          __int16 v30 = 2048;
          BOOL v31 = v24;
          uint32_t v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, backtrace limit exceeded";
          goto LABEL_48;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v8 = (os_log_s *)__nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v18 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v18)
          {
            int64_t v19 = (char *)handle[13];
            *(_DWORD *)buf = 136446722;
            BOOL v29 = "nw_protocol_http2_transport_disconnected";
            __int16 v30 = 2048;
            BOOL v31 = v19;
            __int16 v32 = 2082;
            uint64_t v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s listen protocol (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          goto LABEL_49;
        }

        if (v18)
        {
          BOOL v25 = (char *)handle[13];
          *(_DWORD *)buf = 136446466;
          BOOL v29 = "nw_protocol_http2_transport_disconnected";
          __int16 v30 = 2048;
          BOOL v31 = v25;
          uint32_t v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, no backtrace";
LABEL_48:
          _os_log_impl(&dword_181A5C000, v8, v9, v11, buf, 0x16u);
        }
      }

void nw_protocol_http2_transport_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_protocol_http2_transport_output_finished";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_http2_transport_output_finished";
      uint32_t v11 = "%{public}s called with null protocol";
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v14 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v23 = "nw_protocol_http2_transport_output_finished";
          __int16 v24 = 2082;
          BOOL v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_60:
        if (!v8) {
          return;
        }
        goto LABEL_61;
      }

      if (!v14) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_http2_transport_output_finished";
      uint32_t v11 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v23 = "nw_protocol_http2_transport_output_finished";
      uint32_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_59;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_protocol_http2_transport_output_finished";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        os_log_type_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type;
        if (!os_log_type_enabled(v9, type)) {
          goto LABEL_60;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_protocol_http2_transport_output_finished";
        uint32_t v11 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_59;
      }

      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v16 = os_log_type_enabled(v9, type);
      if (!v15)
      {
        if (!v16) {
          goto LABEL_60;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_protocol_http2_transport_output_finished";
        uint32_t v11 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_59;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v23 = "nw_protocol_http2_transport_output_finished";
        __int16 v24 = 2082;
        BOOL v25 = v15;
        os_log_type_t v17 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_42:
        _os_log_impl(&dword_181A5C000, v9, v10, v17, buf, 0x16u);
      }

void nw_protocol_http2_transport_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v20 = "nw_protocol_http2_transport_input_finished";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v18 = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v18;
      if (!os_log_type_enabled(v6, v18)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      char v20 = "nw_protocol_http2_transport_input_finished";
      uint64_t v8 = "%{public}s called with null protocol";
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v18;
      BOOL v11 = os_log_type_enabled(v6, v18);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v20 = "nw_protocol_http2_transport_input_finished";
          __int16 v21 = 2082;
          char v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_53:
        if (!v5) {
          return;
        }
        goto LABEL_54;
      }

      if (!v11) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      char v20 = "nw_protocol_http2_transport_input_finished";
      uint64_t v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v18;
      if (!os_log_type_enabled(v6, v18)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      char v20 = "nw_protocol_http2_transport_input_finished";
      uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_52;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v20 = "nw_protocol_http2_transport_input_finished";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v18 = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (v18 != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        uint64_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = v18;
        if (!os_log_type_enabled(v6, v18)) {
          goto LABEL_53;
        }
        *(_DWORD *)buf = 136446210;
        char v20 = "nw_protocol_http2_transport_input_finished";
        uint64_t v8 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_52;
      }

      uint64_t v12 = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = v18;
      BOOL v13 = os_log_type_enabled(v6, v18);
      if (!v12)
      {
        if (!v13) {
          goto LABEL_53;
        }
        *(_DWORD *)buf = 136446210;
        char v20 = "nw_protocol_http2_transport_input_finished";
        uint64_t v8 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_52;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        char v20 = "nw_protocol_http2_transport_input_finished";
        __int16 v21 = 2082;
        char v22 = v12;
        BOOL v14 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A5C000, v6, v7, v14, buf, 0x16u);
      }

BOOL nw_protocol_http2_transport_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v123 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
    int v87 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v88 = (os_log_s *)__nwlog_obj();
      os_log_type_t v89 = type;
      if (!os_log_type_enabled(v88, type)) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null protocol";
      goto LABEL_197;
    }

    if (v111 == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v88 = (os_log_s *)__nwlog_obj();
      os_log_type_t v89 = type;
      if (!os_log_type_enabled(v88, type)) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_197;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v88 = (os_log_s *)__nwlog_obj();
    os_log_type_t v89 = type;
    BOOL v94 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (!v94) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_197;
    }

    if (!v94) {
      goto LABEL_180;
    }
    *(_DWORD *)buf = 136446466;
    unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
    __int16 v115 = 2082;
    uint64_t v116 = (uint64_t)backtrace_string;
    nw_endpoint_t v95 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_179:
    _os_log_impl(&dword_181A5C000, v88, v89, v95, buf, 0x16u);
    goto LABEL_180;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
    int v87 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v88 = (os_log_s *)__nwlog_obj();
      os_log_type_t v89 = type;
      if (!os_log_type_enabled(v88, type)) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null http2_transport";
      goto LABEL_197;
    }

    if (v111 == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v88 = (os_log_s *)__nwlog_obj();
      os_log_type_t v89 = type;
      if (!os_log_type_enabled(v88, type)) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null http2_transport, backtrace limit exceeded";
      goto LABEL_197;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v88 = (os_log_s *)__nwlog_obj();
    os_log_type_t v89 = type;
    BOOL v96 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (!v96) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null http2_transport, no backtrace";
      goto LABEL_197;
    }

    if (!v96) {
      goto LABEL_180;
    }
    *(_DWORD *)buf = 136446466;
    unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
    __int16 v115 = 2082;
    uint64_t v116 = (uint64_t)backtrace_string;
    nw_endpoint_t v95 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_179;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
    int v87 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v88 = (os_log_s *)__nwlog_obj();
      os_log_type_t v89 = type;
      if (!os_log_type_enabled(v88, type)) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null input_protocol";
      goto LABEL_197;
    }

    if (v111 == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v88 = (os_log_s *)__nwlog_obj();
      os_log_type_t v89 = type;
      if (!os_log_type_enabled(v88, type)) {
        goto LABEL_198;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
      __int16 v90 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_197;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v88 = (os_log_s *)__nwlog_obj();
    os_log_type_t v89 = type;
    BOOL v97 = os_log_type_enabled(v88, type);
    if (backtrace_string)
    {
      if (v97)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v114 = "nw_protocol_http2_transport_add_input_handler";
        __int16 v115 = 2082;
        uint64_t v116 = (uint64_t)backtrace_string;
        nw_endpoint_t v95 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_179;
      }

BOOL nw_protocol_http2_transport_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    BOOL v43 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      __int16 v69 = 2048;
      BOOL v70 = a2;
      _os_log_impl(&dword_181A5C000, v43, OS_LOG_TYPE_DEBUG, "%{public}s called with input_protocol %p", buf, 0x16u);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
    char v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      id v23 = "%{public}s called with null protocol";
      goto LABEL_128;
    }

    if (!v65)
    {
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      id v23 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_128;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v44 = (os_log_s *)__nwlog_obj();
    os_log_type_t v45 = type;
    BOOL v52 = os_log_type_enabled(v44, type);
    if (!backtrace_string)
    {
      if (!v52) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      id v23 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_128;
    }

    if (!v52) {
      goto LABEL_104;
    }
    *(_DWORD *)buf = 136446466;
    uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
    __int16 v69 = 2082;
    BOOL v70 = (nw_protocol *)backtrace_string;
    id v53 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_103;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
    char v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      id v23 = "%{public}s called with null http2_transport";
      goto LABEL_128;
    }

    if (!v65)
    {
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      id v23 = "%{public}s called with null http2_transport, backtrace limit exceeded";
      goto LABEL_128;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v44 = (os_log_s *)__nwlog_obj();
    os_log_type_t v45 = type;
    BOOL v54 = os_log_type_enabled(v44, type);
    if (!backtrace_string)
    {
      if (!v54) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      id v23 = "%{public}s called with null http2_transport, no backtrace";
      goto LABEL_128;
    }

    if (!v54) {
      goto LABEL_104;
    }
    *(_DWORD *)buf = 136446466;
    uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
    __int16 v69 = 2082;
    BOOL v70 = (nw_protocol *)backtrace_string;
    id v53 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_103:
    _os_log_impl(&dword_181A5C000, v44, v45, v53, buf, 0x16u);
    goto LABEL_104;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
    char v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
      id v23 = "%{public}s called with null input_protocol";
      goto LABEL_128;
    }

    if (v65)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      BOOL v55 = os_log_type_enabled(v44, type);
      if (backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          uint32_t v68 = "nw_protocol_http2_transport_remove_input_handler";
          __int16 v69 = 2082;
          BOOL v70 = (nw_protocol *)backtrace_string;
          id v53 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
          goto LABEL_103;
        }

BOOL nw_protocol_http2_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  v48[1] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)BOOL v47 = 136446210;
    *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    char v38 = 0;
    if (buf[0] == 17)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null protocol";
      goto LABEL_85;
    }

    if (!v38)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_85;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = buf[0];
    BOOL v30 = os_log_type_enabled(v25, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (!v30) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_85;
    }

    if (!v30) {
      goto LABEL_66;
    }
    *(_DWORD *)BOOL v47 = 136446466;
    *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
    *(_WORD *)&v47[12] = 2082;
    *(void *)&v47[14] = backtrace_string;
    uint64_t v31 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_65:
    _os_log_impl(&dword_181A5C000, v25, v26, v31, v47, 0x16u);
    goto LABEL_66;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)BOOL v47 = 136446210;
    *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    char v38 = 0;
    if (buf[0] == 17)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null http2_transport";
      goto LABEL_85;
    }

    if (!v38)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null http2_transport, backtrace limit exceeded";
      goto LABEL_85;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = buf[0];
    BOOL v32 = os_log_type_enabled(v25, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (!v32) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null http2_transport, no backtrace";
      goto LABEL_85;
    }

    if (!v32) {
      goto LABEL_66;
    }
    *(_DWORD *)BOOL v47 = 136446466;
    *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
    *(_WORD *)&v47[12] = 2082;
    *(void *)&v47[14] = backtrace_string;
    uint64_t v31 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_65;
  }

  if (gLogDatapath)
  {
    BOOL v28 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)BOOL v47 = 136446466;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      *(_WORD *)&v47[12] = 2082;
      *(void *)&v47[14] = (char *)handle + 205;
      _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", v47, 0x16u);
    }
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)BOOL v47 = 136446210;
    *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    char v38 = 0;
    if (buf[0] == 17)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null old_input_protocol";
      goto LABEL_85;
    }

    if (!v38)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null old_input_protocol, backtrace limit exceeded";
      goto LABEL_85;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = buf[0];
    BOOL v33 = os_log_type_enabled(v25, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (!v33) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null old_input_protocol, no backtrace";
      goto LABEL_85;
    }

    if (!v33) {
      goto LABEL_66;
    }
    *(_DWORD *)BOOL v47 = 136446466;
    *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
    *(_WORD *)&v47[12] = 2082;
    *(void *)&v47[14] = backtrace_string;
    uint64_t v31 = "%{public}s called with null old_input_protocol, dumping backtrace:%{public}s";
    goto LABEL_65;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)BOOL v47 = 136446210;
    *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    char v38 = 0;
    if (buf[0] == 17)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null new_input_protocol";
      goto LABEL_85;
    }

    if (!v38)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (!os_log_type_enabled(v25, (os_log_type_t)buf[0])) {
        goto LABEL_86;
      }
      *(_DWORD *)BOOL v47 = 136446210;
      *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
      id v27 = "%{public}s called with null new_input_protocol, backtrace limit exceeded";
      goto LABEL_85;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = buf[0];
    BOOL v34 = os_log_type_enabled(v25, (os_log_type_t)buf[0]);
    if (backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)BOOL v47 = 136446466;
        *(void *)&v47[4] = "nw_protocol_http2_replace_input_handler";
        *(_WORD *)&v47[12] = 2082;
        *(void *)&v47[14] = backtrace_string;
        uint64_t v31 = "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s";
        goto LABEL_65;
      }

void nw_protocol_http2_transport_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "nw_protocol_http2_transport_input_available";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_http2_transport_input_available";
      uint64_t v6 = "%{public}s called with null protocol";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v9 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v15 = "nw_protocol_http2_transport_input_available";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_37:
        if (!v3) {
          return;
        }
LABEL_38:
        free(v3);
        return;
      }

      if (!v9) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_http2_transport_input_available";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_http2_transport_input_available";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_protocol_http2_transport_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        uint64_t v10 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_output_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = handle + 205;
          _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
        }
      }

      if (nghttp2_session_want_write())
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v3 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_output_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = handle + 205;
          _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s session send wanted by nghttp2 library",  buf,  0x16u);
        }

        nw_http2_transport_session_send((uint64_t)handle);
        if (!gLogDatapath) {
          goto LABEL_11;
        }
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_output_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = handle + 205;
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called session send for nghttp2 session",  buf,  0x16u);
        }
      }

      if (gLogDatapath)
      {
        BOOL v11 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)BOOL v21 = 136446466;
          uint64_t v22 = "nw_http2_transport_drain_output_frames";
          __int16 v23 = 2082;
          uint64_t v24 = handle + 205;
          _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", v21, 0x16u);
        }

        if (gLogDatapath)
        {
          char v12 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)BOOL v21 = 136446466;
            uint64_t v22 = "nw_http2_transport_drain_output_frames";
            __int16 v23 = 2082;
            uint64_t v24 = handle + 205;
            _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s draining output frames",  v21,  0x16u);
          }
        }
      }

uint64_t nw_protocol_http2_transport_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, int a5, nw_frame_array_s *a6)
{
  v81[2] = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        uint32_t v39 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)BOOL v79 = 136447234;
          *(void *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
          *(_WORD *)&v79[12] = 2082;
          *(void *)&v79[14] = handle + 205;
          *(_WORD *)&v79[22] = 1024;
          LODWORD(v80) = a3;
          WORD2(v80) = 1024;
          *(_DWORD *)((char *)&v80 + 6) = a4;
          WORD5(v80) = 1024;
          HIDWORD(v80) = a5;
          _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called min_bytes: %u, max_bytes: %u, max_frame_count: %u",  v79,  0x28u);
        }
      }

      *(void *)BOOL v79 = 0LL;
      *(void *)&v79[8] = v79;
      *(void *)&v79[16] = 0x3802000000LL;
      *(void *)&__int128 v80 = __Block_byref_object_copy__38026;
      *((void *)&v80 + 1) = __Block_byref_object_dispose__38027;
      v81[0] = 0LL;
      v81[1] = v81;
      a6->tqh_first = 0LL;
      a6->tqh_last = &a6->tqh_first;
      if (a2)
      {
        output_handler_CFRunLoopTimerContext context = a2->output_handler_context;
        if (output_handler_context)
        {
          os_log_type_t v13 = (void *)output_handler_context[4];
          if (v13)
          {
            *(void *)os_log_type_t type = 0LL;
            uint32_t v68 = type;
            int v70 = 0;
            uint64_t v69 = 0x2000000000LL;
            uint64_t v63 = 0LL;
            unint64_t v64 = &v63;
            int v66 = 0;
            uint64_t v65 = 0x2000000000LL;
            uint64_t v14 = MEMORY[0x1895F87A8];
            v52[0] = MEMORY[0x1895F87A8];
            v52[1] = 0x40000000LL;
            id v53 = ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            BOOL v54 = &unk_189BBCDF0;
            BOOL v55 = type;
            nw_endpoint_t v56 = &v63;
            int v61 = a5;
            int v62 = a4;
            BOOL v57 = v79;
            os_log_type_t v58 = handle;
            BOOL v59 = v13;
            uint64_t v60 = a6;
            uint64_t v15 = *v13;
            do
            {
              if (!v15) {
                break;
              }
              uint64_t v16 = *(void *)(v15 + 16);
              char v17 = ((uint64_t (*)(void *))v53)(v52);
              uint64_t v15 = v16;
            }

            while ((v17 & 1) != 0);
            if (*((_DWORD *)v64 + 6) >= a3)
            {
              uint64_t v31 = *(void *)&v79[8];
              uint64_t v32 = *(void *)&v79[8] + 40LL;
              uint64_t v33 = *(void *)(*(void *)&v79[8] + 40LL);
              if (v33)
              {
                **((void **)handle + 19) = v33;
                *(void *)(*(void *)(v31 + 40) + 24LL) = *((void *)handle + 19);
                *((void *)handle + 19) = *(void *)(v31 + 48);
                *(void *)(v31 + 40) = 0LL;
                *(void *)(v31 + 4_Block_object_dispose(va, 8) = v32;
              }

              if (gLogDatapath)
              {
                __int16 v45 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
                {
                  int v46 = *((_DWORD *)v68 + 6);
                  int v47 = *((_DWORD *)v64 + 6);
                  *(_DWORD *)buf = 136446978;
                  nw_endpoint_t v72 = "nw_protocol_http2_transport_get_input_frames";
                  __int16 v73 = 2082;
                  int v74 = handle + 205;
                  __int16 v75 = 1024;
                  int v76 = v46;
                  __int16 v77 = 1024;
                  LODWORD(v7_Block_object_dispose(va, 8) = v47;
                  _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s returning %u frames (%u total bytes)",  buf,  0x22u);
                }
              }

              uint64_t v23 = *((unsigned int *)v68 + 6);
            }

            else
            {
              if (*((_DWORD *)v68 + 6))
              {
                uint64_t v18 = *(void *)&v79[8];
                uint64_t v19 = (void *)(*(void *)&v79[8] + 40LL);
                if (*v13)
                {
                  **(void **)(*(void *)&v79[8] + 48LL) = *v13;
                  *(void *)(*v13 + 24LL) = *(void *)(v18 + 48);
                  *(void *)(v18 + 4_Block_object_dispose(va, 8) = v13[1];
                  *os_log_type_t v13 = 0LL;
                  v13[1] = v13;
                }

                if (*v19)
                {
                  *(void *)v13[1] = *v19;
                  *(void *)(*(void *)(v18 + 40) + 24LL) = v13[1];
                  v13[1] = *(void *)(v18 + 48);
                  *(void *)(v18 + 40) = 0LL;
                  *(void *)(v18 + 4_Block_object_dispose(va, 8) = v19;
                }

                v48[0] = v14;
                v48[1] = 0x40000000LL;
                BOOL v49 = ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_37;
                os_log_type_t v50 = &__block_descriptor_tmp_38_38035;
                BOOL v51 = a6;
                tqh_first = a6->tqh_first;
                do
                {
                  if (!tqh_first) {
                    break;
                  }
                  BOOL v21 = (nw_frame *)*((void *)tqh_first + 4);
                  char v22 = ((uint64_t (*)(void *))v49)(v48);
                  tqh_first = v21;
                }

                while ((v22 & 1) != 0);
                a6->tqh_first = 0LL;
                a6->tqh_last = &a6->tqh_first;
              }

              if (gLogDatapath && (int v44 = (os_log_s *)__nwlog_obj(), os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)))
              {
                *(_DWORD *)buf = 136446722;
                nw_endpoint_t v72 = "nw_protocol_http2_transport_get_input_frames";
                __int16 v73 = 2082;
                int v74 = handle + 205;
                __int16 v75 = 1024;
                int v76 = a3;
                _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s failed to find enough (%u) bytes to return, returning 0 frames",  buf,  0x1Cu);
                uint64_t v23 = 0LL;
              }

              else
              {
                uint64_t v23 = 0LL;
              }
            }

            _Block_object_dispose(&v63, 8);
            _Block_object_dispose(type, 8);
            goto LABEL_46;
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          nw_endpoint_t v72 = "nw_protocol_http2_transport_get_input_frames";
          __int16 v73 = 2082;
          int v74 = handle + 205;
          __int16 v75 = 1042;
          int v76 = 16;
          __int16 v77 = 2098;
          __int16 v78 = a2;
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s can't find hash table entry for %{public,uuid_t}.16P",  buf,  0x26u);
        }

BOOL nw_protocol_http2_transport_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    BOOL v51 = (char *)_os_log_send_and_compose_impl();
    v82[0] = 16;
    LOBYTE(v7_Block_object_dispose(va, 8) = 0;
    if (v82[0] == 17)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null protocol";
      goto LABEL_163;
    }

    if (!(_BYTE)v78)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_163;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v52 = (os_log_s *)__nwlog_obj();
    os_log_type_t v53 = v82[0];
    BOOL v64 = os_log_type_enabled(v52, (os_log_type_t)v82[0]);
    if (!backtrace_string)
    {
      if (!v64) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_163;
    }

    if (!v64) {
      goto LABEL_146;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v65 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_145:
    _os_log_impl(&dword_181A5C000, v52, v53, v65, buf, 0x16u);
    goto LABEL_146;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    BOOL v51 = (char *)_os_log_send_and_compose_impl();
    v82[0] = 16;
    LOBYTE(v7_Block_object_dispose(va, 8) = 0;
    if (v82[0] == 17)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null http2_transport";
      goto LABEL_163;
    }

    if (!(_BYTE)v78)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null http2_transport, backtrace limit exceeded";
      goto LABEL_163;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v52 = (os_log_s *)__nwlog_obj();
    os_log_type_t v53 = v82[0];
    BOOL v66 = os_log_type_enabled(v52, (os_log_type_t)v82[0]);
    if (!backtrace_string)
    {
      if (!v66) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null http2_transport, no backtrace";
      goto LABEL_163;
    }

    if (!v66) {
      goto LABEL_146;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v65 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_145;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    BOOL v51 = (char *)_os_log_send_and_compose_impl();
    v82[0] = 16;
    LOBYTE(v7_Block_object_dispose(va, 8) = 0;
    if (v82[0] == 17)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null input_protocol";
      goto LABEL_163;
    }

    if (!(_BYTE)v78)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_163;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v52 = (os_log_s *)__nwlog_obj();
    os_log_type_t v53 = v82[0];
    BOOL v67 = os_log_type_enabled(v52, (os_log_type_t)v82[0]);
    if (!backtrace_string)
    {
      if (!v67) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_163;
    }

    if (!v67) {
      goto LABEL_146;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v65 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_145;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    BOOL v51 = (char *)_os_log_send_and_compose_impl();
    v82[0] = 16;
    LOBYTE(v7_Block_object_dispose(va, 8) = 0;
    if (v82[0] == 17)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null return_array";
      goto LABEL_163;
    }

    if (!(_BYTE)v78)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      os_log_type_t v53 = v82[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)v82[0])) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      BOOL v54 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_163;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v52 = (os_log_s *)__nwlog_obj();
    os_log_type_t v53 = v82[0];
    BOOL v68 = os_log_type_enabled(v52, (os_log_type_t)v82[0]);
    if (backtrace_string)
    {
      if (v68)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v65 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_145;
      }

uint64_t nw_protocol_http2_transport_get_parameters(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[11];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_http2_transport_get_parameters";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http2_transport_get_parameters";
        uint64_t v6 = "%{public}s called with null http2_transport";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http2_transport_get_parameters";
        uint64_t v6 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http2_transport_get_parameters";
        uint64_t v6 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http2_transport_get_parameters";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      size_t v9 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_http2_transport_get_parameters";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http2_transport_get_parameters";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        int v14 = "nw_protocol_http2_transport_get_parameters";
        uint64_t v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      int v14 = "nw_protocol_http2_transport_get_parameters";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      size_t v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

uint64_t nw_protocol_http2_transport_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v24 = "nw_protocol_http2_transport_finalize_output_frames";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      size_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      if (!os_log_type_enabled(v9, v22)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      char v24 = "nw_protocol_http2_transport_finalize_output_frames";
      char v11 = "%{public}s called with null protocol";
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      BOOL v14 = os_log_type_enabled(v9, v22);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          char v24 = "nw_protocol_http2_transport_finalize_output_frames";
          __int16 v25 = 2082;
          int v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v8) {
          return 0LL;
        }
LABEL_40:
        free(v8);
        return 0LL;
      }

      if (!v14) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      char v24 = "nw_protocol_http2_transport_finalize_output_frames";
      char v11 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      size_t v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = v22;
      if (!os_log_type_enabled(v9, v22)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 136446210;
      char v24 = "nw_protocol_http2_transport_finalize_output_frames";
      char v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

BOOL nw_protocol_http2_transport_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if (*((void *)handle + 13))
      {
        if ((handle[204] & 0x40) == 0)
        {
LABEL_37:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = (os_log_s *)gLogObj;
          BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          if (result)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = handle + 205;
            _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s already have a listen handler, ignoring add",  buf,  0x16u);
            return 0LL;
          }

          return result;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 205;
        uint64_t v4 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        char v31 = 0;
        if (__nwlog_fault(v4, type, &v31))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v5 = (os_log_s *)gLogObj;
            os_log_type_t v6 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
              goto LABEL_35;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = handle + 205;
            os_log_type_t v7 = "%{public}s %{public}s cannot have listen handler and be waiting for listen handler at the same time";
            goto LABEL_34;
          }

          if (!v31)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v5 = (os_log_s *)gLogObj;
            os_log_type_t v6 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
              goto LABEL_35;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = handle + 205;
            os_log_type_t v7 = "%{public}s %{public}s cannot have listen handler and be waiting for listen handler at the same time, ba"
                 "cktrace limit exceeded";
            goto LABEL_34;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v5 = (os_log_s *)gLogObj;
          os_log_type_t v6 = type[0];
          BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (backtrace_string)
          {
            if (v13)
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = handle + 205;
              *(_WORD *)&_BYTE buf[22] = 2082;
              uint64_t v33 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s %{public}s cannot have listen handler and be waiting for listen handler at the same time, dum ping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
            goto LABEL_35;
          }

          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_add_listen_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = handle + 205;
            os_log_type_t v7 = "%{public}s %{public}s cannot have listen handler and be waiting for listen handler at the same time, no backtrace";
LABEL_34:
            _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0x16u);
          }
        }

uint64_t nw_protocol_http2_transport_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((nw_listen_protocol *)handle[13] == a2)
      {
        handle[13] = 0LL;
        a2->uint64_t protocol_handler = 0LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
        __int16 v17 = 2082;
        uint32_t v18 = (char *)handle + 205;
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s removed protocol listen handler",  buf,  0x16u);
      }

      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
        BOOL v8 = "%{public}s called with null http2_transport";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (!v13)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
        BOOL v8 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v12 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
        BOOL v8 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
      __int16 v17 = 2082;
      uint32_t v18 = backtrace_string;
      char v11 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
  os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v13)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
        BOOL v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
        BOOL v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }

      goto LABEL_36;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v16 = "nw_protocol_http2_transport_remove_listen_handler";
      __int16 v17 = 2082;
      uint32_t v18 = backtrace_string;
      char v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v6, v7, v11, buf, 0x16u);
    }

uint64_t nw_protocol_http2_transport_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      uint64_t v2 = handle[6];
      else {
        return handle[12];
      }
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
        size_t v9 = "%{public}s called with null http2_transport";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (!v14)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
        size_t v9 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
        size_t v9 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
      __int16 v18 = 2082;
      uint64_t v19 = backtrace_string;
      BOOL v12 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
      goto LABEL_24;
    }

    goto LABEL_25;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v14)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
        size_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
        size_t v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_34;
      }

      goto LABEL_35;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v17 = "nw_protocol_http2_transport_get_remote_endpoint";
      __int16 v18 = 2082;
      uint64_t v19 = backtrace_string;
      BOOL v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v7, v8, v12, buf, 0x16u);
    }

void nw_protocol_http2_transport_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v27 = "nw_protocol_http2_transport_error";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v27 = "nw_protocol_http2_transport_error";
      __int16 v15 = "%{public}s called with null protocol";
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v27 = "nw_protocol_http2_transport_error";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v12) {
          return;
        }
        goto LABEL_56;
      }

      if (!v17) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v27 = "nw_protocol_http2_transport_error";
      __int16 v15 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v27 = "nw_protocol_http2_transport_error";
      __int16 v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_54;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v27 = "nw_protocol_http2_transport_error";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v24)
      {
        BOOL v13 = (os_log_s *)__nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v27 = "nw_protocol_http2_transport_error";
        __int16 v15 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_54;
      }

      __int16 v18 = (char *)__nw_create_backtrace_string();
      BOOL v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v27 = "nw_protocol_http2_transport_error";
        __int16 v15 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_54;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v27 = "nw_protocol_http2_transport_error";
        __int16 v28 = 2082;
        uint64_t v29 = v18;
        uint64_t v20 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_39:
        _os_log_impl(&dword_181A5C000, v13, v14, v20, buf, 0x16u);
      }

void nw_protocol_http2_transport_notify(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_http2_transport_notify";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v26 = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (v26 == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      if (!os_log_type_enabled(v12, v26)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null protocol";
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      BOOL v17 = os_log_type_enabled(v12, v26);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v28 = "nw_protocol_http2_transport_notify";
          __int16 v29 = 2082;
          __int16 v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_63:
        if (!v11) {
          return;
        }
        goto LABEL_64;
      }

      if (!v17) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      if (!os_log_type_enabled(v12, v26)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_62;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_http2_transport_notify";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v26 = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (v26 != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        BOOL v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = v26;
        if (!os_log_type_enabled(v12, v26)) {
          goto LABEL_63;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_http2_transport_notify";
        os_log_type_t v14 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_62;
      }

      __int16 v18 = (char *)__nw_create_backtrace_string();
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      BOOL v19 = os_log_type_enabled(v12, v26);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_63;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_http2_transport_notify";
        os_log_type_t v14 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_62;
      }

      if (!v19) {
        goto LABEL_44;
      }
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      __int16 v29 = 2082;
      __int16 v30 = v18;
      uint64_t v20 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
      goto LABEL_43;
    }

    BOOL v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = v26;
    if (!os_log_type_enabled(v12, v26)) {
      goto LABEL_63;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_http2_transport_notify";
    os_log_type_t v14 = "%{public}s called with null http2_transport";
LABEL_62:
    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_63;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_http2_transport_notify";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v26 = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (v26 == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      if (!os_log_type_enabled(v12, v26)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null other_protocol";
      goto LABEL_62;
    }

    if (!v25)
    {
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      if (!os_log_type_enabled(v12, v26)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_62;
    }

    __int16 v18 = (char *)__nw_create_backtrace_string();
    BOOL v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = v26;
    BOOL v21 = os_log_type_enabled(v12, v26);
    if (!v18)
    {
      if (!v21) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_62;
    }

    if (!v21) {
      goto LABEL_44;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v28 = "nw_protocol_http2_transport_notify";
    __int16 v29 = 2082;
    __int16 v30 = v18;
    uint64_t v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_43:
    _os_log_impl(&dword_181A5C000, v12, v13, v20, buf, 0x16u);
    goto LABEL_44;
  }

  if (!*(void *)(v5 + 112))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_http2_transport_notify";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v26 = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (v26 == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      if (!os_log_type_enabled(v12, v26)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_protocol";
      goto LABEL_62;
    }

    if (!v25)
    {
      BOOL v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v26;
      if (!os_log_type_enabled(v12, v26)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_protocol, backtrace limit exceeded";
      goto LABEL_62;
    }

    __int16 v18 = (char *)__nw_create_backtrace_string();
    BOOL v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = v26;
    BOOL v22 = os_log_type_enabled(v12, v26);
    if (!v18)
    {
      if (!v22) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_protocol, no backtrace";
      goto LABEL_62;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_protocol_http2_transport_notify";
      __int16 v29 = 2082;
      __int16 v30 = v18;
      uint64_t v20 = "%{public}s called with null http2_transport->http2_transport_streams_protocol, dumping backtrace:%{public}s";
      goto LABEL_43;
    }

BOOL nw_protocol_http2_transport_create( const nw_protocol_identifier *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v36 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v49 = "nw_protocol_http2_transport_create";
      _os_log_impl(&dword_181A5C000, v36, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  __memptr = 0LL;
  if (!posix_memalign(&__memptr, 8uLL, 0x128uLL))
  {
    uint64_t v4 = __memptr;
    if (__memptr)
    {
LABEL_4:
      *((void *)v4 + 36) = 0LL;
      *((_OWORD *)v4 + 16) = 0u;
      *((_OWORD *)v4 + 17) = 0u;
      *((_OWORD *)v4 + 14) = 0u;
      *((_OWORD *)v4 + 15) = 0u;
      *((_OWORD *)v4 + 12) = 0u;
      *((_OWORD *)v4 + 13) = 0u;
      *((_OWORD *)v4 + 6) = 0u;
      *((_OWORD *)v4 + 7) = 0u;
      *((_OWORD *)v4 + 4) = 0u;
      *((_OWORD *)v4 + 5) = 0u;
      *((_OWORD *)v4 + 11) = 0u;
      uint64_t v5 = v4 + 176;
      *((_OWORD *)v4 + 10) = 0u;
      os_log_type_t v6 = v4 + 160;
      *((_OWORD *)v4 + 9) = 0u;
      os_log_type_t v7 = v4 + 144;
      *((_OWORD *)v4 + _Block_object_dispose(va, 8) = 0u;
      os_log_type_t v8 = v4 + 128;
      *((_OWORD *)v4 + 2) = 0u;
      *((_OWORD *)v4 + 3) = 0u;
      *(_OWORD *)uint64_t v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *((void *)v4 + 2) = &g_http2_transport_protocol_identifier;
      *((void *)v4 + 3) = &g_http2_transport_protocol_callbacks;
      *((void *)v4 + 5) = v4;
      *((void *)v4 + _Block_object_dispose(va, 8) = -1LL;
      else {
        char v9 = 0;
      }
      v4[204] = v4[204] & 0xEF | v9;
      void *v8 = 0LL;
      *((void *)v4 + 17) = v8;
      *os_log_type_t v7 = 0LL;
      *((void *)v4 + 19) = v7;
      void *v6 = 0LL;
      *((void *)v4 + 21) = v6;
      void *v5 = 0LL;
      *((void *)v4 + 23) = v5;
      *((void *)v4 + 24) = 0LL;
      if (nghttp2_session_callbacks_new())
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        BOOL v49 = "nw_protocol_http2_transport_create";
        __int16 v50 = 2082;
        uint64_t v51 = v10;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v46 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v12 = (os_log_s *)gLogObj;
          os_log_type_t v13 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_31;
          }
          uint64_t v14 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          BOOL v49 = "nw_protocol_http2_transport_create";
          __int16 v50 = 2082;
          uint64_t v51 = v14;
          __int16 v15 = "%{public}s nghttp2_session_callbacks_new: %{public}s failed";
LABEL_29:
          char v25 = v12;
          os_log_type_t v26 = v13;
          uint32_t v27 = 22;
LABEL_30:
          _os_log_impl(&dword_181A5C000, v25, v26, v15, buf, v27);
          goto LABEL_31;
        }

        if (v46 == OS_LOG_TYPE_DEFAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v12 = (os_log_s *)gLogObj;
          os_log_type_t v13 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_31;
          }
          uint64_t v23 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          BOOL v49 = "nw_protocol_http2_transport_create";
          __int16 v50 = 2082;
          uint64_t v51 = v23;
          __int16 v15 = "%{public}s nghttp2_session_callbacks_new: %{public}s failed, backtrace limit exceeded";
          goto LABEL_29;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (os_log_s *)gLogObj;
        os_log_type_t v13 = type[0];
        BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (!backtrace_string)
        {
          if (!v21) {
            goto LABEL_31;
          }
          uint64_t v24 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          BOOL v49 = "nw_protocol_http2_transport_create";
          __int16 v50 = 2082;
          uint64_t v51 = v24;
          __int16 v15 = "%{public}s nghttp2_session_callbacks_new: %{public}s failed, no backtrace";
          goto LABEL_29;
        }

        if (v21)
        {
          uint64_t v22 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          BOOL v49 = "nw_protocol_http2_transport_create";
          __int16 v50 = 2082;
          uint64_t v51 = v22;
          __int16 v52 = 2082;
          uint64_t v53 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s nghttp2_session_callbacks_new: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(backtrace_string);
LABEL_31:
        if (!v11)
        {
LABEL_33:
          free(v4);
          return 0LL;
        }

BOOL nw_protocol_http2_transport_accept(nw_protocol *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http2_transport_accept";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      char v9 = "%{public}s called with null protocol";
      goto LABEL_39;
    }

    if (!v15)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      char v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v12 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (!v12) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      char v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_39;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      __int16 v19 = 2082;
      uint64_t v20 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_40:
    if (!v6) {
      return 0LL;
    }
LABEL_41:
    free(v6);
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http2_transport_accept";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      char v9 = "%{public}s called with null http2_transport";
      goto LABEL_39;
    }

    if (!v15)
    {
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      char v9 = "%{public}s called with null http2_transport, backtrace limit exceeded";
      goto LABEL_39;
    }

    os_log_type_t v13 = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v14 = os_log_type_enabled(v7, type);
    if (v13)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v18 = "nw_protocol_http2_transport_accept";
        __int16 v19 = 2082;
        uint64_t v20 = v13;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v13);
      if (!v6) {
        return 0LL;
      }
      goto LABEL_41;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      char v9 = "%{public}s called with null http2_transport, no backtrace";
LABEL_39:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      goto LABEL_40;
    }

    goto LABEL_40;
  }

  if (gLogDatapath)
  {
    uint64_t v10 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v18 = "nw_protocol_http2_transport_accept";
      __int16 v19 = 2082;
      uint64_t v20 = handle + 205;
      _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if ((handle[204] & 4) == 0) {
    return 1LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)gLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
  if (result)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v18 = "nw_protocol_http2_transport_accept";
    __int16 v19 = 2082;
    uint64_t v20 = handle + 205;
    _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s cannot accept new streams after the tunnel is closed",  buf,  0x16u);
    return 0LL;
  }

  return result;
}

uint64_t before_frame_send_callback(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v24 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      int v25 = *((_DWORD *)a2 + 2);
      uint64_t v26 = *a2;
      *(_DWORD *)buf = 136446722;
      uint64_t v34 = "before_frame_send_callback";
      __int16 v35 = 1024;
      *(_DWORD *)uint64_t v36 = v25;
      *(_WORD *)&v36[4] = 2048;
      *(void *)&v36[6] = v26;
      _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s called for frame on stream %d, length (no header) %zu",  buf,  0x1Cu);
    }
  }

  int v5 = *((_DWORD *)a2 + 2);
  if (v5)
  {
    if (*((_BYTE *)a2 + 12) != 1 || *((_DWORD *)a2 + 14) > 1u) {
      return 0LL;
    }
    if (a3)
    {
      if (*(void *)(a3 + 120))
      {
        *(void *)os_log_type_t type = 0LL;
        uint64_t stream_from_id = nw_http2_transport_get_stream_from_id(a3, v5, type);
        if (stream_from_id)
        {
          uint64_t v7 = stream_from_id;
          if ((*(_BYTE *)(stream_from_id + 36) & 1) != 0) {
            return 0LL;
          }
          if (*(void *)type)
          {
            nw_http2_transport_stream_connected(a3, stream_from_id, *(uint64_t *)type);
            return 0LL;
          }

          uint64_t v20 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v34 = "before_frame_send_callback";
            __int16 v35 = 2082;
            *(void *)uint64_t v36 = a3 + 205;
            *(_WORD *)&v36[8] = 2048;
            *(void *)&v36[10] = v7;
            _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s stream (%p) did not have protocol extra",  buf,  0x20u);
          }
        }

        return 4294966775LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = a3 + 205;
      *(_DWORD *)buf = 136446466;
      uint64_t v34 = "before_frame_send_callback";
      __int16 v35 = 2082;
      *(void *)uint64_t v36 = a3 + 205;
      uint64_t v10 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v32 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (os_log_s *)gLogObj;
        os_log_type_t v12 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v34 = "before_frame_send_callback";
          __int16 v35 = 2082;
          *(void *)uint64_t v36 = v9;
          os_log_type_t v13 = "%{public}s %{public}s id based hash table has not yet been created, failing connection";
LABEL_31:
          uint64_t v21 = v11;
          os_log_type_t v22 = v12;
          uint32_t v23 = 22;
LABEL_32:
          _os_log_impl(&dword_181A5C000, v21, v22, v13, buf, v23);
          goto LABEL_33;
        }

        goto LABEL_33;
      }

      if (!v32)
      {
        uint64_t v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v34 = "before_frame_send_callback";
          __int16 v35 = 2082;
          *(void *)uint64_t v36 = v9;
          os_log_type_t v13 = "%{public}s %{public}s id based hash table has not yet been created, failing connection, backtrace limit exceeded";
          goto LABEL_31;
        }

{
  int v5;
  unsigned int v6;
  uint64_t stream_from_id;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t result;
  int v13;
  const char *v14;
  os_log_s *v15;
  os_log_type_t v16;
  int v17;
  const char *v18;
  int v19;
  int v20;
  char *v21;
  os_log_s *v22;
  os_log_type_t v23;
  int v24;
  int v25;
  const char *v26;
  char *v27;
  BOOL v28;
  int v29;
  char *backtrace_string;
  BOOL v31;
  int v32;
  int v33;
  int v34;
  os_log_s *v35;
  int v36;
  int v37;
  int v38;
  char *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  os_log_s *v44;
  int v45;
  uint64_t v46;
  os_log_s *v47;
  const char *v48;
  os_log_s *v49;
  os_log_type_t v50;
  const char *v51;
  char *v52;
  BOOL v53;
  os_log_s *v54;
  int v55;
  int v56;
  os_log_s *v57;
  int v58;
  int v59;
  char v60;
  os_log_type_t type[8];
  os_log_type_t v62;
  uint8_t buf[4];
  const char *v64;
  __int16 v65;
  _BYTE v66[18];
  __int16 v67;
  int v68;
  __int16 v69;
  void v70[3];
  v70[2] = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    char v44 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
    {
      __int16 v45 = *((_DWORD *)a2 + 2);
      os_log_type_t v46 = *a2;
      *(_DWORD *)buf = 136446722;
      BOOL v64 = "before_frame_send_callback";
      uint64_t v65 = 1024;
      *(_DWORD *)BOOL v66 = v45;
      *(_WORD *)&v66[4] = 2048;
      *(void *)&v66[6] = v46;
      _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s called for frame on stream %d, length (no header) %zu",  buf,  0x1Cu);
    }
  }

  int v5 = *((_DWORD *)a2 + 2);
  if (v5)
  {
    if (*((_BYTE *)a2 + 12) != 1) {
      return 0LL;
    }
    os_log_type_t v6 = *((_DWORD *)a2 + 14);
    if (v6 > 3 || v6 == 2) {
      return 0LL;
    }
    if (a3)
    {
      if (*(void *)(a3 + 160))
      {
        *(void *)os_log_type_t type = 0LL;
        uint64_t stream_from_id = nw_http2_get_stream_from_id(a3, v5, type);
        if (stream_from_id)
        {
          uint64_t v9 = stream_from_id;
          if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            __int16 v54 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v56 = *(_DWORD *)(v9 + 176);
              BOOL v55 = *(_DWORD *)(v9 + 180);
              *(_DWORD *)buf = 136447490;
              BOOL v64 = "before_frame_send_callback";
              uint64_t v65 = 2082;
              *(void *)BOOL v66 = v9 + 191;
              *(_WORD *)&v66[8] = 2080;
              *(void *)&v66[10] = " ";
              BOOL v67 = 1024;
              BOOL v68 = v55;
              uint64_t v69 = 1024;
              LODWORD(v70[0]) = v56;
              WORD2(v70[0]) = 1024;
              *(_DWORD *)((char *)v70 + 6) = v56;
              _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> outgoing headers for stream %d",  buf,  0x32u);
            }
          }

          nw_http_connection_metadata_increment_outbound_message_count(*(void **)(a3 + 256));
          if ((*(_WORD *)(v9 + 188) & 0x2002) != 0) {
            return 0LL;
          }
          if (((*(unsigned __int16 *)(v9 + 188) | (*(unsigned __int8 *)(v9 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            BOOL v57 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              os_log_type_t v59 = *(_DWORD *)(v9 + 176);
              os_log_type_t v58 = *(_DWORD *)(v9 + 180);
              *(_DWORD *)buf = 136447234;
              BOOL v64 = "before_frame_send_callback";
              uint64_t v65 = 2082;
              *(void *)BOOL v66 = v9 + 191;
              *(_WORD *)&v66[8] = 2080;
              *(void *)&v66[10] = " ";
              BOOL v67 = 1024;
              BOOL v68 = v58;
              uint64_t v69 = 1024;
              LODWORD(v70[0]) = v59;
              _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> stream is now open, sending body",  buf,  0x2Cu);
            }
          }

          uint64_t v10 = *(unsigned __int16 *)(v9 + 188);
          uint64_t v11 = *(unsigned __int8 *)(v9 + 190);
          *(_WORD *)(v9 + 18_Block_object_dispose(va, 8) = v10 | 2;
          if (*(void *)type)
          {
            return 0LL;
          }

          if (((v10 | (v11 << 16)) & 0x80000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            __int16 v35 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
            {
              uint64_t v37 = *(_DWORD *)(v9 + 176);
              uint64_t v36 = *(_DWORD *)(v9 + 180);
              *(_DWORD *)buf = 136447490;
              BOOL v64 = "before_frame_send_callback";
              uint64_t v65 = 2082;
              *(void *)BOOL v66 = v9 + 191;
              *(_WORD *)&v66[8] = 2080;
              *(void *)&v66[10] = " ";
              BOOL v67 = 1024;
              BOOL v68 = v36;
              uint64_t v69 = 1024;
              LODWORD(v70[0]) = v37;
              WORD2(v70[0]) = 2048;
              *(void *)((char *)v70 + 6) = v9;
              _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%d> stream (%p) did not have protocol extra",  buf,  0x36u);
            }
          }

          return 4294966775LL;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint32_t v19 = *(_DWORD *)(a3 + 368);
        uint64_t v20 = *((_DWORD *)a2 + 2);
        *(_DWORD *)buf = 136447234;
        BOOL v64 = "before_frame_send_callback";
        uint64_t v65 = 2082;
        *(void *)BOOL v66 = a3 + 390;
        *(_WORD *)&v66[8] = 2080;
        *(void *)&v66[10] = " ";
        BOOL v67 = 1024;
        BOOL v68 = v19;
        uint64_t v69 = 1024;
        LODWORD(v70[0]) = v20;
        uint64_t v21 = (char *)_os_log_send_and_compose_impl();
        BOOL v62 = OS_LOG_TYPE_ERROR;
        uint64_t v60 = 0;
        if (__nwlog_fault(v21, &v62, &v60))
        {
          if (v62 == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v22 = (os_log_s *)gconnectionLogObj;
            uint32_t v23 = v62;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v62)) {
              goto LABEL_77;
            }
            uint64_t v24 = *(_DWORD *)(a3 + 368);
            int v25 = *((_DWORD *)a2 + 2);
            *(_DWORD *)buf = 136447234;
            BOOL v64 = "before_frame_send_callback";
            uint64_t v65 = 2082;
            *(void *)BOOL v66 = a3 + 390;
            *(_WORD *)&v66[8] = 2080;
            *(void *)&v66[10] = " ";
            BOOL v67 = 1024;
            BOOL v68 = v24;
            uint64_t v69 = 1024;
            LODWORD(v70[0]) = v25;
            uint64_t v26 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
            goto LABEL_76;
          }

          if (!v60)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v22 = (os_log_s *)gconnectionLogObj;
            uint32_t v23 = v62;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v62)) {
              goto LABEL_77;
            }
            os_log_type_t v40 = *(_DWORD *)(a3 + 368);
            os_log_type_t v41 = *((_DWORD *)a2 + 2);
            *(_DWORD *)buf = 136447234;
            BOOL v64 = "before_frame_send_callback";
            uint64_t v65 = 2082;
            *(void *)BOOL v66 = a3 + 390;
            *(_WORD *)&v66[8] = 2080;
            *(void *)&v66[10] = " ";
            BOOL v67 = 1024;
            BOOL v68 = v40;
            uint64_t v69 = 1024;
            LODWORD(v70[0]) = v41;
            uint64_t v26 = "%{public}s %{public}s%s<i%u> failed to find stream %d, backtrace limit exceeded";
            goto LABEL_76;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v22 = (os_log_s *)gconnectionLogObj;
          uint32_t v23 = v62;
          BOOL v31 = os_log_type_enabled((os_log_t)gconnectionLogObj, v62);
          if (backtrace_string)
          {
            if (v31)
            {
              char v32 = *(_DWORD *)(a3 + 368);
              uint64_t v33 = *((_DWORD *)a2 + 2);
              *(_DWORD *)buf = 136447490;
              BOOL v64 = "before_frame_send_callback";
              uint64_t v65 = 2082;
              *(void *)BOOL v66 = a3 + 390;
              *(_WORD *)&v66[8] = 2080;
              *(void *)&v66[10] = " ";
              BOOL v67 = 1024;
              BOOL v68 = v32;
              uint64_t v69 = 1024;
              LODWORD(v70[0]) = v33;
              WORD2(v70[0]) = 2082;
              *(void *)((char *)v70 + 6) = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s %{public}s%s<i%u> failed to find stream %d, dumping backtrace:%{public}s",  buf,  0x36u);
            }

            free(backtrace_string);
            goto LABEL_77;
          }

          if (v31)
          {
            uint64_t v42 = *(_DWORD *)(a3 + 368);
            BOOL v43 = *((_DWORD *)a2 + 2);
            *(_DWORD *)buf = 136447234;
            BOOL v64 = "before_frame_send_callback";
            uint64_t v65 = 2082;
            *(void *)BOOL v66 = a3 + 390;
            *(_WORD *)&v66[8] = 2080;
            *(void *)&v66[10] = " ";
            BOOL v67 = 1024;
            BOOL v68 = v42;
            uint64_t v69 = 1024;
            LODWORD(v70[0]) = v43;
            uint64_t v26 = "%{public}s %{public}s%s<i%u> failed to find stream %d, no backtrace";
LABEL_76:
            _os_log_impl(&dword_181A5C000, v22, v23, v26, buf, 0x2Cu);
          }
        }

uint64_t on_header_callback( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    os_log_type_t v22 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      __int16 v35 = "on_header_callback";
      __int16 v36 = 2082;
      uint64_t v37 = a3;
      __int16 v38 = 2082;
      *(void *)uint64_t v39 = a5;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s called name %{public}s value %{public}s",  buf,  0x20u);
    }
  }

  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v35 = "on_header_callback";
    uint32_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "on_header_callback";
      uint64_t v26 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v28 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v35 = "on_header_callback";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (!v28)
      {
LABEL_35:
        if (v23) {
          free(v23);
        }
        return 4294966394LL;
      }

      *(_DWORD *)buf = 136446210;
      __int16 v35 = "on_header_callback";
      uint64_t v26 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }

    else
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "on_header_callback";
      uint64_t v26 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
    goto LABEL_35;
  }

  int v12 = *(unsigned __int8 *)(a2 + 12);
  if (v12 == 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775LL;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v35 = "on_header_callback";
    __int16 v36 = 2082;
    uint64_t v37 = (char *)(a8 + 205);
    uint64_t v16 = "%{public}s %{public}s push promise frames currently not supported";
    BOOL v17 = (os_log_s *)v15;
    uint32_t v18 = 22;
LABEL_16:
    _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
    return 4294966775LL;
  }

  if (v12 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v19 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v35 = "on_header_callback";
      __int16 v36 = 2082;
      uint64_t v37 = (char *)(a8 + 205);
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s returning callback failure with unknown error",  buf,  0x16u);
    }

    return 4294966394LL;
  }

  if (*(_DWORD *)(a2 + 56) != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775LL;
    }
    int v21 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)buf = 136446722;
    __int16 v35 = "on_header_callback";
    __int16 v36 = 2082;
    uint64_t v37 = (char *)(a8 + 205);
    __int16 v38 = 1024;
    *(_DWORD *)uint64_t v39 = v21;
    uint64_t v16 = "%{public}s %{public}s ERROR: Got headers for stream %d, a stream that doesn't exist.";
    BOOL v17 = (os_log_s *)v20;
    uint32_t v18 = 28;
    goto LABEL_16;
  }

  uint64_t stream_from_id = nw_http2_transport_get_stream_from_id(a8, *(_DWORD *)(a2 + 8), 0LL);
  if (!stream_from_id) {
    return 4294966775LL;
  }
  if (!gLogDatapath) {
    return 0LL;
  }
  uint64_t v29 = stream_from_id;
  BOOL v30 = (os_log_s *)__nwlog_obj();
  uint64_t result = os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    int v31 = *(_DWORD *)(v29 + 32);
    *(_DWORD *)buf = 136447234;
    __int16 v35 = "on_header_callback";
    __int16 v36 = 2082;
    uint64_t v37 = (char *)(a8 + 205);
    __int16 v38 = 1024;
    *(_DWORD *)uint64_t v39 = v31;
    *(_WORD *)&void v39[4] = 2082;
    *(void *)&v39[6] = a3;
    __int16 v40 = 2082;
    uint64_t v41 = a5;
    _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s received header response on stream %d: name: %{public}s value: %{public}s",  buf,  0x30u);
    return 0LL;
  }

  return result;
}

uint64_t on_begin_headers_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v98 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v93 = "on_begin_headers_callback";
    uint64_t v60 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type[0];
      if (!os_log_type_enabled(v61, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136446210;
      int v93 = "on_begin_headers_callback";
      uint64_t v63 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (v91)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type[0];
      BOOL v66 = os_log_type_enabled(v61, type[0]);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          int v93 = "on_begin_headers_callback";
          __int16 v94 = 2082;
          uint64_t v95 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v61,  v62,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_128;
      }

      if (!v66)
      {
LABEL_128:
        if (v60) {
          free(v60);
        }
        return 4294966394LL;
      }

      *(_DWORD *)buf = 136446210;
      int v93 = "on_begin_headers_callback";
      uint64_t v63 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }

    else
    {
      int v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type[0];
      if (!os_log_type_enabled(v61, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136446210;
      int v93 = "on_begin_headers_callback";
      uint64_t v63 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v61, v62, v63, buf, 0xCu);
    goto LABEL_128;
  }

  if (gLogDatapath)
  {
    BOOL v64 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      int v93 = "on_begin_headers_callback";
      __int16 v94 = 2082;
      uint64_t v95 = a3 + 205;
      _os_log_impl(&dword_181A5C000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  int v5 = *(unsigned __int8 *)(a2 + 12);
  if (v5 == 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775LL;
    }
    *(_DWORD *)buf = 136446466;
    int v93 = "on_begin_headers_callback";
    __int16 v94 = 2082;
    uint64_t v95 = a3 + 205;
    uint64_t v16 = "%{public}s %{public}s push promise frames currently not supported";
    BOOL v17 = (os_log_s *)v15;
    uint32_t v18 = 22;
    goto LABEL_20;
  }

  if (v5 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint32_t v19 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      int v93 = "on_begin_headers_callback";
      __int16 v94 = 2082;
      uint64_t v95 = a3 + 205;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s returning callback failure with unknown error",  buf,  0x16u);
    }

    return 4294966394LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v6 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)buf = 136446722;
    int v93 = "on_begin_headers_callback";
    __int16 v94 = 2082;
    uint64_t v95 = a3 + 205;
    __int16 v96 = 1024;
    *(_DWORD *)BOOL v97 = v7;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s got header frame on stream %d",  buf,  0x1Cu);
  }

  uint64_t stream_node_from_id = nw_http2_transport_get_stream_node_from_id(a3, *(_DWORD *)(a2 + 8));
  if (!stream_node_from_id)
  {
    if (*(void *)(a3 + 104))
    {
      if (!*(void *)(a3 + 96))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v45 = a3 + 205;
        *(_DWORD *)buf = 136446466;
        int v93 = "on_begin_headers_callback";
        __int16 v94 = 2082;
        uint64_t v95 = a3 + 205;
        __int16 v35 = (const char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        char v91 = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v46 = (os_log_s *)__nwlog_obj();
          os_log_type_t v47 = type[0];
          if (!os_log_type_enabled(v46, type[0])) {
            goto LABEL_107;
          }
          *(_DWORD *)buf = 136446466;
          int v93 = "on_begin_headers_callback";
          __int16 v94 = 2082;
          uint64_t v95 = v45;
          uint64_t v39 = "%{public}s %{public}s http2_transport has no remote endpoint when new stream is being opened";
LABEL_105:
          BOOL v55 = v46;
          os_log_type_t v56 = v47;
          uint32_t v57 = 22;
          goto LABEL_106;
        }

        if (!v91)
        {
          os_log_type_t v46 = (os_log_s *)__nwlog_obj();
          os_log_type_t v47 = type[0];
          if (!os_log_type_enabled(v46, type[0])) {
            goto LABEL_107;
          }
          *(_DWORD *)buf = 136446466;
          int v93 = "on_begin_headers_callback";
          __int16 v94 = 2082;
          uint64_t v95 = v45;
          uint64_t v39 = "%{public}s %{public}s http2_transport has no remote endpoint when new stream is being opened, backtrace limit exceeded";
          goto LABEL_105;
        }

        BOOL v49 = (char *)__nw_create_backtrace_string();
        os_log_type_t v46 = (os_log_s *)__nwlog_obj();
        os_log_type_t v47 = type[0];
        BOOL v50 = os_log_type_enabled(v46, type[0]);
        if (!v49)
        {
          if (!v50) {
            goto LABEL_107;
          }
          *(_DWORD *)buf = 136446466;
          int v93 = "on_begin_headers_callback";
          __int16 v94 = 2082;
          uint64_t v95 = v45;
          uint64_t v39 = "%{public}s %{public}s http2_transport has no remote endpoint when new stream is being opened, no backtrace";
          goto LABEL_105;
        }

        if (v50)
        {
          *(_DWORD *)buf = 136446722;
          int v93 = "on_begin_headers_callback";
          __int16 v94 = 2082;
          uint64_t v95 = v45;
          __int16 v96 = 2082;
          *(void *)BOOL v97 = v49;
          uint64_t v51 = "%{public}s %{public}s http2_transport has no remote endpoint when new stream is being opened, dumping ba"
                "cktrace:%{public}s";
LABEL_95:
          _os_log_impl(&dword_181A5C000, v46, v47, v51, buf, 0x20u);
        }

{
  int v5;
  uint64_t stream_node_from_id;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  int v10;
  const char *v11;
  os_log_s *v12;
  uint32_t v13;
  os_log_s *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  void *v19;
  id v20;
  BOOL v21;
  int v22;
  int v23;
  unsigned int v24;
  void **v25;
  void *v26;
  char v27;
  os_log_s *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  const char *v33;
  os_log_s *v34;
  os_log_type_t v35;
  int v36;
  int v37;
  const char *v38;
  uint64_t v39;
  int v40;
  int v41;
  char *v42;
  BOOL v43;
  int v44;
  int v45;
  int v46;
  os_log_s *v47;
  os_log_type_t v48;
  int v49;
  const char *v50;
  int v51;
  char *v52;
  os_log_s *v53;
  os_log_type_t v54;
  int v55;
  const char *v56;
  int v57;
  int v58;
  char *v59;
  BOOL v60;
  int v61;
  os_log_s *v62;
  int v63;
  int v64;
  int v65;
  int v66;
  void *v67;
  char *v68;
  BOOL v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  char *v75;
  os_log_s *v76;
  os_log_type_t v77;
  const char *v78;
  os_log_s *v79;
  int v80;
  char *backtrace_string;
  BOOL v82;
  os_log_s *v83;
  int v84;
  int v85;
  os_log_s *v86;
  int v87;
  int v88;
  os_log_s *v89;
  void *v90;
  os_log_s *v91;
  int v92;
  os_log_s *v93;
  int v94;
  int v95;
  os_log_s *v96;
  int v97;
  int v98;
  char v99;
  os_log_s *v100;
  BOOL v101;
  int v102;
  int v103;
  char v104;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v107;
  __int16 v108;
  uint64_t v109;
  __int16 v110;
  uint64_t v111;
  __int16 v112;
  int v113;
  __int16 v114;
  void v115[3];
  void v115[2] = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v107 = "on_begin_headers_callback";
    __int16 v75 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v104 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v76 = (os_log_s *)__nwlog_obj();
      BOOL v77 = type;
      if (!os_log_type_enabled(v76, type)) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      id v107 = "on_begin_headers_callback";
      uint64_t v78 = "%{public}s nghttp2 user data is NULL, not http2";
    }

    else if (v104)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v76 = (os_log_s *)__nwlog_obj();
      BOOL v77 = type;
      uint64_t v82 = os_log_type_enabled(v76, type);
      if (backtrace_string)
      {
        if (v82)
        {
          *(_DWORD *)buf = 136446466;
          id v107 = "on_begin_headers_callback";
          nw_endpoint_t v108 = 2082;
          uint64_t v109 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_164;
      }

      if (!v82)
      {
LABEL_164:
        if (v75) {
          free(v75);
        }
        return 4294966394LL;
      }

      *(_DWORD *)buf = 136446210;
      id v107 = "on_begin_headers_callback";
      uint64_t v78 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }

    else
    {
      char v76 = (os_log_s *)__nwlog_obj();
      BOOL v77 = type;
      if (!os_log_type_enabled(v76, type)) {
        goto LABEL_164;
      }
      *(_DWORD *)buf = 136446210;
      id v107 = "on_begin_headers_callback";
      uint64_t v78 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v76, v77, v78, buf, 0xCu);
    goto LABEL_164;
  }

  if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v79 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v80 = *(_DWORD *)(a3 + 368);
      *(_DWORD *)buf = 136446978;
      id v107 = "on_begin_headers_callback";
      nw_endpoint_t v108 = 2082;
      uint64_t v109 = a3 + 390;
      char v110 = 2080;
      os_log_type_t v111 = (uint64_t)" ";
      id v112 = 1024;
      os_log_type_t v113 = v80;
      _os_log_impl(&dword_181A5C000, v79, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  int v5 = *(unsigned __int8 *)(a2 + 12);
  if (v5 == 5)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v9 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775LL;
    }
    uint64_t v10 = *(_DWORD *)(a3 + 368);
    *(_DWORD *)buf = 136446978;
    id v107 = "on_begin_headers_callback";
    nw_endpoint_t v108 = 2082;
    uint64_t v109 = a3 + 390;
    char v110 = 2080;
    os_log_type_t v111 = (uint64_t)" ";
    id v112 = 1024;
    os_log_type_t v113 = v10;
    uint64_t v11 = "%{public}s %{public}s%s<i%u> push promise frames currently not supported";
    int v12 = (os_log_s *)v9;
    int v13 = 38;
LABEL_16:
    _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
    return 4294966775LL;
  }

  if (v5 != 1)
  {
    if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v14 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v15 = *(_DWORD *)(a3 + 368);
        *(_DWORD *)buf = 136446978;
        id v107 = "on_begin_headers_callback";
        nw_endpoint_t v108 = 2082;
        uint64_t v109 = a3 + 390;
        char v110 = 2080;
        os_log_type_t v111 = (uint64_t)" ";
        id v112 = 1024;
        os_log_type_t v113 = v15;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> returning callback failure with unknown error",  buf,  0x26u);
      }
    }

    return 4294966394LL;
  }

  if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v83 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      __int16 v84 = *(_DWORD *)(a3 + 368);
      uint64_t v85 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 136447234;
      id v107 = "on_begin_headers_callback";
      nw_endpoint_t v108 = 2082;
      uint64_t v109 = a3 + 390;
      char v110 = 2080;
      os_log_type_t v111 = (uint64_t)" ";
      id v112 = 1024;
      os_log_type_t v113 = v84;
      unint64_t v114 = 1024;
      LODWORD(v115[0]) = v85;
      _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> got header frame on stream %d",  buf,  0x2Cu);
    }
  }

  uint64_t stream_node_from_id = nw_http2_get_stream_node_from_id(a3, *(_DWORD *)(a2 + 8));
  if (stream_node_from_id)
  {
    int v7 = stream_node_from_id;
    nw_http_connection_metadata_increment_inbound_message_count(*(void **)(a3 + 256));
    if (*(void *)(v7 + 16)) {
      return 0LL;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v31 = *(_DWORD *)(a3 + 368);
    char v32 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)buf = 136447234;
    id v107 = "on_begin_headers_callback";
    nw_endpoint_t v108 = 2082;
    uint64_t v109 = a3 + 390;
    char v110 = 2080;
    os_log_type_t v111 = (uint64_t)" ";
    id v112 = 1024;
    os_log_type_t v113 = v31;
    unint64_t v114 = 1024;
    LODWORD(v115[0]) = v32;
    uint64_t v33 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v104 = 0;
    if (__nwlog_fault(v33, &type, &v104))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v34 = (os_log_s *)gconnectionLogObj;
        __int16 v35 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          __int16 v36 = *(_DWORD *)(a3 + 368);
          os_log_type_t v37 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136447234;
          id v107 = "on_begin_headers_callback";
          nw_endpoint_t v108 = 2082;
          uint64_t v109 = a3 + 390;
          char v110 = 2080;
          os_log_type_t v111 = (uint64_t)" ";
          id v112 = 1024;
          os_log_type_t v113 = v36;
          unint64_t v114 = 1024;
          LODWORD(v115[0]) = v37;
          int v38 = "%{public}s %{public}s%s<i%u> could not get stream (%d) from node";
LABEL_110:
          _os_log_impl(&dword_181A5C000, v34, v35, v38, buf, 0x2Cu);
        }
      }

      else if (v104)
      {
        uint64_t v42 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v34 = (os_log_s *)gconnectionLogObj;
        __int16 v35 = type;
        BOOL v43 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (!v42)
        {
          if (!v43) {
            goto LABEL_111;
          }
          uint64_t v65 = *(_DWORD *)(a3 + 368);
          BOOL v66 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136447234;
          id v107 = "on_begin_headers_callback";
          nw_endpoint_t v108 = 2082;
          uint64_t v109 = a3 + 390;
          char v110 = 2080;
          os_log_type_t v111 = (uint64_t)" ";
          id v112 = 1024;
          os_log_type_t v113 = v65;
          unint64_t v114 = 1024;
          LODWORD(v115[0]) = v66;
          int v38 = "%{public}s %{public}s%s<i%u> could not get stream (%d) from node, no backtrace";
          goto LABEL_110;
        }

        if (v43)
        {
          int v44 = *(_DWORD *)(a3 + 368);
          uint64_t v45 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136447490;
          id v107 = "on_begin_headers_callback";
          nw_endpoint_t v108 = 2082;
          uint64_t v109 = a3 + 390;
          char v110 = 2080;
          os_log_type_t v111 = (uint64_t)" ";
          id v112 = 1024;
          os_log_type_t v113 = v44;
          unint64_t v114 = 1024;
          LODWORD(v115[0]) = v45;
          WORD2(v115[0]) = 2082;
          *(void *)((char *)v115 + 6) = v42;
          _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s %{public}s%s<i%u> could not get stream (%d) from node, dumping backtrace:%{public}s",  buf,  0x36u);
        }

        free(v42);
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v34 = (os_log_s *)gconnectionLogObj;
        __int16 v35 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          uint32_t v57 = *(_DWORD *)(a3 + 368);
          BOOL v58 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136447234;
          id v107 = "on_begin_headers_callback";
          nw_endpoint_t v108 = 2082;
          uint64_t v109 = a3 + 390;
          char v110 = 2080;
          os_log_type_t v111 = (uint64_t)" ";
          id v112 = 1024;
          os_log_type_t v113 = v57;
          unint64_t v114 = 1024;
          LODWORD(v115[0]) = v58;
          int v38 = "%{public}s %{public}s%s<i%u> could not get stream (%d) from node, backtrace limit exceeded";
          goto LABEL_110;
        }
      }
    }

void sub_1821127C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t on_frame_recv_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v68 = "on_frame_recv_callback";
    uint32_t v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (__nwlog_fault(v27, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v68 = "on_frame_recv_callback";
          BOOL v30 = "%{public}s nghttp2 user data is NULL, not http2_transport";
LABEL_65:
          _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
        }
      }

      else if (v65)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        BOOL v33 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v68 = "on_frame_recv_callback";
            __int16 v69 = 2082;
            int v70 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_66;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v68 = "on_frame_recv_callback";
          BOOL v30 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
          goto LABEL_65;
        }
      }

      else
      {
        BOOL v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v68 = "on_frame_recv_callback";
          BOOL v30 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
          goto LABEL_65;
        }
      }
    }

uint64_t on_data_chunk_recv_callback(uint64_t a1, uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t v76 = *MEMORY[0x1895F89C0];
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v69 = "on_data_chunk_recv_callback";
    int v45 = (char *)_os_log_send_and_compose_impl();
    v66[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v66[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = v66[0];
      if (!os_log_type_enabled(v46, v66[0])) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v69 = "on_data_chunk_recv_callback";
      uint64_t v48 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = v66[0];
      BOOL v51 = os_log_type_enabled(v46, v66[0]);
      if (backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_103;
      }

      if (!v51)
      {
LABEL_103:
        if (v45) {
          free(v45);
        }
        return 4294966394LL;
      }

      *(_DWORD *)buf = 136446210;
      __int16 v69 = "on_data_chunk_recv_callback";
      uint64_t v48 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }

    else
    {
      os_log_type_t v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = v66[0];
      if (!os_log_type_enabled(v46, v66[0])) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v69 = "on_data_chunk_recv_callback";
      uint64_t v48 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
    goto LABEL_103;
  }

  if (gLogDatapath)
  {
    int v49 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = a6 + 205;
      _os_log_impl(&dword_181A5C000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  *(void *)BOOL v66 = 0LL;
  uint64_t stream_from_id = nw_http2_transport_get_stream_from_id(a6, a3, v66);
  if (!stream_from_id) {
    return 4294966775LL;
  }
  uint64_t v11 = stream_from_id;
  input_BOOL frame = http2_transport_create_input_frame(a6, stream_from_id, a5);
  if (!input_frame)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = a6 + 205;
    int v19 = *(_DWORD *)(v11 + 32);
    *(_DWORD *)buf = 136446978;
    __int16 v69 = "on_data_chunk_recv_callback";
    __int16 v70 = 2082;
    uint64_t v71 = a6 + 205;
    __int16 v72 = 2048;
    *(void *)int v73 = a5;
    *(_WORD *)&v73[8] = 1024;
    *(_DWORD *)&v73[10] = v19;
    int v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v21 = (os_log_s *)gLogObj;
      os_log_type_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      int v23 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      __int16 v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = v18;
      __int16 v72 = 2048;
      *(void *)int v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v23;
      uint64_t v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d";
    }

    else if (v65)
    {
      int v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v21 = (os_log_s *)gLogObj;
      os_log_type_t v22 = type;
      BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v26)
      {
        if (v27)
        {
          int v28 = *(_DWORD *)(v11 + 32);
          *(_DWORD *)buf = 136447234;
          __int16 v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v18;
          __int16 v72 = 2048;
          *(void *)int v73 = a5;
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v28;
          __int16 v74 = 2082;
          __int16 v75 = v26;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, dumping backtrace:%{public}s",  buf,  0x30u);
        }

        free(v26);
        goto LABEL_54;
      }

      if (!v27)
      {
LABEL_54:
        if (v20) {
          free(v20);
        }
        return 4294966394LL;
      }

      int v43 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      __int16 v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = v18;
      __int16 v72 = 2048;
      *(void *)int v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v43;
      uint64_t v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v21 = (os_log_s *)gLogObj;
      os_log_type_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      int v42 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      __int16 v69 = "on_data_chunk_recv_callback";
      __int16 v70 = 2082;
      uint64_t v71 = v18;
      __int16 v72 = 2048;
      *(void *)int v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v42;
      uint64_t v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x26u);
    goto LABEL_54;
  }

  uint64_t v13 = input_frame;
  if (!*(void *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(void *)(input_frame + 88)))
  {
    int v16 = 0;
    int v25 = 0LL;
  }

  else
  {
    int v15 = *(_DWORD *)(v13 + 52);
    uint64_t v14 = *(unsigned int *)(v13 + 56);
    if (v15) {
      int v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    }
    else {
      int v16 = 0;
    }
    int v25 = (void *)(*(void *)(v13 + 112) + v14);
  }

  if (v16 != a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v33 = a6 + 205;
    *(_DWORD *)buf = 136446978;
    __int16 v69 = "on_data_chunk_recv_callback";
    __int16 v70 = 2082;
    uint64_t v71 = a6 + 205;
    __int16 v72 = 1024;
    *(_DWORD *)int v73 = v16;
    *(_WORD *)&v73[4] = 2048;
    *(void *)&v73[6] = a5;
    uint64_t v34 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v65 = 0;
    if (__nwlog_fault(v34, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v35 = (os_log_s *)gLogObj;
        os_log_type_t v36 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          __int16 v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v33;
          __int16 v72 = 1024;
          *(_DWORD *)int v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(void *)&v73[6] = a5;
          os_log_type_t v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame";
LABEL_58:
          _os_log_impl(&dword_181A5C000, v35, v36, v37, buf, 0x26u);
        }
      }

      else if (v65)
      {
        int v40 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v35 = (os_log_s *)gLogObj;
        os_log_type_t v36 = type;
        BOOL v41 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v40)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136447234;
            __int16 v69 = "on_data_chunk_recv_callback";
            __int16 v70 = 2082;
            uint64_t v71 = v33;
            __int16 v72 = 1024;
            *(_DWORD *)int v73 = v16;
            *(_WORD *)&v73[4] = 2048;
            *(void *)&v73[6] = a5;
            __int16 v74 = 2082;
            __int16 v75 = v40;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_cre ate_input_frame, dumping backtrace:%{public}s",  buf,  0x30u);
          }

          free(v40);
          goto LABEL_59;
        }

        if (v41)
        {
          *(_DWORD *)buf = 136446978;
          __int16 v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v33;
          __int16 v72 = 1024;
          *(_DWORD *)int v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(void *)&v73[6] = a5;
          os_log_type_t v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame, no backtrace";
          goto LABEL_58;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v35 = (os_log_s *)gLogObj;
        os_log_type_t v36 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          __int16 v69 = "on_data_chunk_recv_callback";
          __int16 v70 = 2082;
          uint64_t v71 = v33;
          __int16 v72 = 1024;
          *(_DWORD *)int v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(void *)&v73[6] = a5;
          os_log_type_t v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame, backtrace limit exceeded";
          goto LABEL_58;
        }
      }
    }

{
  uint64_t stream_from_id;
  uint64_t v11;
  uint64_t input_frame;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  char *v18;
  os_log_s *v19;
  os_log_type_t v20;
  int v21;
  const char *v22;
  int v23;
  int v24;
  char *v25;
  os_log_s *v26;
  os_log_type_t v27;
  int v28;
  int v29;
  const char *v30;
  char *v31;
  BOOL v32;
  int v33;
  void *v34;
  char *v35;
  BOOL v36;
  int v37;
  int v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  os_log_s *v42;
  uint64_t result;
  int v44;
  int v45;
  int v46;
  int v47;
  char *v48;
  os_log_s *v49;
  os_log_type_t v50;
  int v51;
  int v52;
  const char *v53;
  uint64_t v54;
  void (*v55)(void);
  char *v56;
  BOOL v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  char *v70;
  os_log_s *v71;
  os_log_type_t v72;
  const char *v73;
  os_log_s *v74;
  int v75;
  char *backtrace_string;
  BOOL v77;
  const char *v78;
  char *v79;
  os_log_s *v80;
  os_log_type_t v81;
  const char *v82;
  const char *v83;
  char *v84;
  BOOL v85;
  const char *v86;
  os_log_s *v87;
  uint64_t v88;
  os_log_s *v89;
  int v90;
  int v91;
  const char *v92;
  const char *v93;
  char v94;
  os_log_type_t v95[15];
  os_log_type_t type;
  uint8_t buf[4];
  const char *v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  _BYTE v104[10];
  __int16 v105;
  _BYTE v106[14];
  __int16 v107;
  char *v108;
  uint64_t v109;
  uint64_t v109 = *MEMORY[0x1895F89C0];
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v98 = "on_data_chunk_recv_callback";
    __int16 v70 = (char *)_os_log_send_and_compose_impl();
    v95[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v95[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      __int16 v72 = v95[0];
      if (!os_log_type_enabled(v71, v95[0])) {
        goto LABEL_149;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v98 = "on_data_chunk_recv_callback";
      int v73 = "%{public}s nghttp2 user data is NULL, not http2";
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      __int16 v72 = v95[0];
      BOOL v77 = os_log_type_enabled(v71, v95[0]);
      if (backtrace_string)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v98 = "on_data_chunk_recv_callback";
          uint64_t v99 = 2082;
          os_log_type_t v100 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v71,  v72,  "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_149;
      }

      if (!v77)
      {
LABEL_149:
        if (v70) {
          free(v70);
        }
        return 4294966394LL;
      }

      *(_DWORD *)buf = 136446210;
      uint64_t v98 = "on_data_chunk_recv_callback";
      int v73 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }

    else
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      __int16 v72 = v95[0];
      if (!os_log_type_enabled(v71, v95[0])) {
        goto LABEL_149;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v98 = "on_data_chunk_recv_callback";
      int v73 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v71, v72, v73, buf, 0xCu);
    goto LABEL_149;
  }

  if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    __int16 v74 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      __int16 v75 = *(_DWORD *)(a6 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v98 = "on_data_chunk_recv_callback";
      uint64_t v99 = 2082;
      os_log_type_t v100 = (const char *)(a6 + 390);
      BOOL v101 = 2080;
      os_log_type_t v102 = " ";
      nw_endpoint_t v103 = 1024;
      *(_DWORD *)uint64_t v104 = v75;
      _os_log_impl(&dword_181A5C000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  *(void *)uint64_t v95 = 0LL;
  uint64_t stream_from_id = nw_http2_get_stream_from_id(a6, a3, v95);
  if (!stream_from_id)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint32_t v17 = *(_DWORD *)(a6 + 368);
    *(_DWORD *)buf = 136447234;
    uint64_t v98 = "on_data_chunk_recv_callback";
    uint64_t v99 = 2082;
    os_log_type_t v100 = (const char *)(a6 + 390);
    BOOL v101 = 2080;
    os_log_type_t v102 = " ";
    nw_endpoint_t v103 = 1024;
    *(_DWORD *)uint64_t v104 = v17;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = a3;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v94 = 0;
    if (__nwlog_fault(v18, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v19 = (os_log_s *)gconnectionLogObj;
        int v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_89;
        }
        int v21 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        uint64_t v98 = "on_data_chunk_recv_callback";
        uint64_t v99 = 2082;
        os_log_type_t v100 = (const char *)(a6 + 390);
        BOOL v101 = 2080;
        os_log_type_t v102 = " ";
        nw_endpoint_t v103 = 1024;
        *(_DWORD *)uint64_t v104 = v21;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        os_log_type_t v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
        goto LABEL_88;
      }

      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v19 = (os_log_s *)gconnectionLogObj;
        int v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_89;
        }
        int v60 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        uint64_t v98 = "on_data_chunk_recv_callback";
        uint64_t v99 = 2082;
        os_log_type_t v100 = (const char *)(a6 + 390);
        BOOL v101 = 2080;
        os_log_type_t v102 = " ";
        nw_endpoint_t v103 = 1024;
        *(_DWORD *)uint64_t v104 = v60;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        os_log_type_t v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d, backtrace limit exceeded";
        goto LABEL_88;
      }

      char v31 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v19 = (os_log_s *)gconnectionLogObj;
      int v20 = type;
      int v32 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v31)
      {
        if (v32)
        {
          uint64_t v33 = *(_DWORD *)(a6 + 368);
          *(_DWORD *)buf = 136447490;
          uint64_t v98 = "on_data_chunk_recv_callback";
          uint64_t v99 = 2082;
          os_log_type_t v100 = (const char *)(a6 + 390);
          BOOL v101 = 2080;
          os_log_type_t v102 = " ";
          nw_endpoint_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v33;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = a3;
          uint64_t v105 = 2082;
          *(void *)int v106 = v31;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s %{public}s%s<i%u> failed to find stream %d, dumping backtrace:%{public}s",  buf,  0x36u);
        }

        free(v31);
        goto LABEL_89;
      }

      if (v32)
      {
        int v61 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        uint64_t v98 = "on_data_chunk_recv_callback";
        uint64_t v99 = 2082;
        os_log_type_t v100 = (const char *)(a6 + 390);
        BOOL v101 = 2080;
        os_log_type_t v102 = " ";
        nw_endpoint_t v103 = 1024;
        *(_DWORD *)uint64_t v104 = v61;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        os_log_type_t v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d, no backtrace";
LABEL_88:
        _os_log_impl(&dword_181A5C000, v19, v20, v22, buf, 0x2Cu);
      }
    }

uint64_t on_stream_close_callback(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v34 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      int v43 = "on_stream_close_callback";
      __int16 v44 = 1024;
      LODWORD(v45) = a2;
      _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_DEBUG, "%{public}s called for stream %d", buf, 0x12u);
    }
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v43 = "on_stream_close_callback";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v35 = (os_log_s *)__nwlog_obj();
      os_log_type_t v36 = type;
      if (!os_log_type_enabled(v35, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "on_stream_close_callback";
      uint64_t v14 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v35 = (os_log_s *)__nwlog_obj();
      os_log_type_t v36 = type;
      BOOL v37 = os_log_type_enabled(v35, type);
      if (backtrace_string)
      {
        if (!v37) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446466;
        int v43 = "on_stream_close_callback";
        __int16 v44 = 2082;
        int v45 = backtrace_string;
        BOOL v27 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
        int v28 = v35;
        os_log_type_t v29 = v36;
        uint32_t v30 = 22;
        goto LABEL_37;
      }

      if (!v37) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "on_stream_close_callback";
      uint64_t v14 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }

    else
    {
      uint64_t v35 = (os_log_s *)__nwlog_obj();
      os_log_type_t v36 = type;
      if (!os_log_type_enabled(v35, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      int v43 = "on_stream_close_callback";
      uint64_t v14 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }

    char v31 = v35;
    os_log_type_t v32 = v36;
    uint32_t v33 = 12;
    goto LABEL_49;
  }

  uint64_t stream_node_from_id = nw_http2_transport_get_stream_node_from_id(a4, a2);
  if (!stream_node_from_id)
  {
    if (gLogDatapath)
    {
      int v15 = (os_log_s *)__nwlog_obj();
      uint64_t result = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result) {
        return result;
      }
      *(_DWORD *)buf = 136446466;
      int v43 = "on_stream_close_callback";
      __int16 v44 = 2082;
      int v45 = (char *)(a4 + 205);
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called for stream that is not in id based table, ignoring",  buf,  0x16u);
    }

    return 0LL;
  }

  uint64_t v7 = (char *)stream_node_from_id;
  uint64_t v8 = *(void *)(stream_node_from_id + 16);
  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = a4 + 205;
    *(_DWORD *)buf = 136446722;
    int v43 = "on_stream_close_callback";
    __int16 v44 = 2082;
    int v45 = (char *)(a4 + 205);
    __int16 v46 = 2048;
    os_log_type_t v47 = v7;
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = (os_log_s *)gLogObj;
      os_log_type_t v19 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446722;
      int v43 = "on_stream_close_callback";
      __int16 v44 = 2082;
      int v45 = (char *)v17;
      __int16 v46 = 2048;
      os_log_type_t v47 = v7;
      uint64_t v14 = "%{public}s %{public}s no stream found in id hash node %p";
    }

    else if (v40)
    {
      int v23 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = (os_log_s *)gLogObj;
      os_log_type_t v19 = type;
      BOOL v24 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v23)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446978;
          int v43 = "on_stream_close_callback";
          __int16 v44 = 2082;
          int v45 = (char *)v17;
          __int16 v46 = 2048;
          os_log_type_t v47 = v7;
          __int16 v48 = 2082;
          int v49 = v23;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s %{public}s no stream found in id hash node %p, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v23);
        goto LABEL_50;
      }

      if (!v24) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446722;
      int v43 = "on_stream_close_callback";
      __int16 v44 = 2082;
      int v45 = (char *)v17;
      __int16 v46 = 2048;
      os_log_type_t v47 = v7;
      uint64_t v14 = "%{public}s %{public}s no stream found in id hash node %p, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = (os_log_s *)gLogObj;
      os_log_type_t v19 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446722;
      int v43 = "on_stream_close_callback";
      __int16 v44 = 2082;
      int v45 = (char *)v17;
      __int16 v46 = 2048;
      os_log_type_t v47 = v7;
      uint64_t v14 = "%{public}s %{public}s no stream found in id hash node %p, backtrace limit exceeded";
    }

    char v31 = v18;
    os_log_type_t v32 = v19;
    uint32_t v33 = 32;
LABEL_49:
    _os_log_impl(&dword_181A5C000, v31, v32, v14, buf, v33);
    goto LABEL_50;
  }

  uint64_t v9 = *(void *)(stream_node_from_id + 32);
  if (!v9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v20 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      int v21 = *(_DWORD *)(v8 + 32);
      *(_DWORD *)buf = 136446722;
      int v43 = "on_stream_close_callback";
      __int16 v44 = 2082;
      int v45 = (char *)(a4 + 205);
      __int16 v46 = 1024;
      LODWORD(v47) = v21;
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s closing stream %d that has no input handler",  buf,  0x1Cu);
    }

    goto LABEL_20;
  }

  if (*(void *)(v9 + 24))
  {
LABEL_20:
    if ((*(_BYTE *)(v8 + 36) & 1) != 0)
    {
      if (gLogDatapath)
      {
        uint64_t v38 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          int v39 = *(_DWORD *)(v8 + 32);
          *(_DWORD *)buf = 136446722;
          int v43 = "on_stream_close_callback";
          __int16 v44 = 2082;
          int v45 = (char *)(a4 + 205);
          __int16 v46 = 1024;
          LODWORD(v47) = v39;
          _os_log_impl(&dword_181A5C000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s closing stream %d", buf, 0x1Cu);
        }
      }

      *(_BYTE *)(v8 + 36) &= ~1u;
      nw_http2_transport_stream_close(a4, v8);
    }

    else if (gLogDatapath)
    {
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        int v43 = "on_stream_close_callback";
        __int16 v44 = 2082;
        int v45 = (char *)(a4 + 205);
        _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s not closing already closed stream",  buf,  0x16u);
      }
    }

    nw_http2_transport_protocol_close(a4, v9);
    return 0LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v10 = a4 + 205;
  *(_DWORD *)buf = 136446466;
  int v43 = "on_stream_close_callback";
  __int16 v44 = 2082;
  int v45 = (char *)(a4 + 205);
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v40 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v12 = (os_log_s *)gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446466;
      int v43 = "on_stream_close_callback";
      __int16 v44 = 2082;
      int v45 = (char *)v10;
      uint64_t v14 = "%{public}s %{public}s protocol has null callbacks";
LABEL_48:
      char v31 = v12;
      os_log_type_t v32 = v13;
      uint32_t v33 = 22;
      goto LABEL_49;
    }

    goto LABEL_50;
  }

  if (v40)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v12 = (os_log_s *)gLogObj;
    os_log_type_t v13 = type;
    BOOL v26 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        int v43 = "on_stream_close_callback";
        __int16 v44 = 2082;
        int v45 = (char *)v10;
        uint64_t v14 = "%{public}s %{public}s protocol has null callbacks, no backtrace";
        goto LABEL_48;
      }

      goto LABEL_50;
    }

    if (!v26)
    {
LABEL_38:
      free(backtrace_string);
      goto LABEL_50;
    }

    *(_DWORD *)buf = 136446722;
    int v43 = "on_stream_close_callback";
    __int16 v44 = 2082;
    int v45 = (char *)v10;
    __int16 v46 = 2082;
    os_log_type_t v47 = backtrace_string;
    BOOL v27 = "%{public}s %{public}s protocol has null callbacks, dumping backtrace:%{public}s";
    int v28 = v12;
    os_log_type_t v29 = v13;
    uint32_t v30 = 32;
LABEL_37:
    _os_log_impl(&dword_181A5C000, v28, v29, v27, buf, v30);
    goto LABEL_38;
  }

  int v12 = (os_log_s *)__nwlog_obj();
  os_log_type_t v13 = type;
  if (os_log_type_enabled(v12, type))
  {
    *(_DWORD *)buf = 136446466;
    int v43 = "on_stream_close_callback";
    __int16 v44 = 2082;
    int v45 = (char *)v10;
    uint64_t v14 = "%{public}s %{public}s protocol has null callbacks, backtrace limit exceeded";
    goto LABEL_48;
  }

{
  uint64_t stream_from_id;
  uint64_t v7;
  int v8;
  int v9;
  const char *v10;
  os_log_s *v11;
  os_log_type_t v12;
  int v13;
  int v14;
  const char *v15;
  os_log_s *v16;
  uint64_t result;
  int v18;
  os_log_s *v19;
  int v20;
  int v21;
  int v22;
  os_log_s *v23;
  int v24;
  int v25;
  os_log_s *v26;
  int v27;
  uint64_t v28;
  char *v29;
  BOOL v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  char *v40;
  os_log_s *v41;
  const char *v42;
  os_log_s *v43;
  os_log_type_t v44;
  const char *v45;
  char *backtrace_string;
  BOOL v47;
  os_log_s *v48;
  int v49;
  int v50;
  char v51;
  os_log_type_t v52[8];
  os_log_type_t type;
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  char *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  _BYTE v63[18];
  uint64_t v64;
  uint64_t v64 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    BOOL v41 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v55 = "on_stream_close_callback";
      int v56 = 1024;
      LODWORD(v57) = a2;
      _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_DEBUG, "%{public}s called for stream %d", buf, 0x12u);
    }
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v55 = "on_stream_close_callback";
    int v42 = (const char *)_os_log_send_and_compose_impl();
    v52[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v42, v52, &type))
    {
      if (v52[0] == OS_LOG_TYPE_FAULT)
      {
        int v43 = (os_log_s *)__nwlog_obj();
        __int16 v44 = v52[0];
        if (os_log_type_enabled(v43, v52[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v55 = "on_stream_close_callback";
          int v45 = "%{public}s nghttp2 user data is NULL, not http2";
LABEL_87:
          _os_log_impl(&dword_181A5C000, v43, v44, v45, buf, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v43 = (os_log_s *)__nwlog_obj();
        __int16 v44 = v52[0];
        os_log_type_t v47 = os_log_type_enabled(v43, v52[0]);
        if (backtrace_string)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v55 = "on_stream_close_callback";
            int v56 = 2082;
            BOOL v57 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_88;
        }

        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v55 = "on_stream_close_callback";
          int v45 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
          goto LABEL_87;
        }
      }

      else
      {
        int v43 = (os_log_s *)__nwlog_obj();
        __int16 v44 = v52[0];
        if (os_log_type_enabled(v43, v52[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v55 = "on_stream_close_callback";
          int v45 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
          goto LABEL_87;
        }
      }
    }

uint64_t on_frame_send_callback(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    os_log_type_t v29 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      int v30 = *((unsigned __int8 *)a2 + 12);
      int v31 = *((_DWORD *)a2 + 2);
      uint64_t v32 = *a2;
      *(_DWORD *)buf = 136446978;
      int v58 = "on_frame_send_callback";
      __int16 v59 = 1024;
      *(_DWORD *)int v60 = v30;
      *(_WORD *)&v60[4] = 1024;
      *(_DWORD *)&v60[6] = v31;
      *(_WORD *)int v61 = 2048;
      *(void *)&v61[2] = v32;
      _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s called for frame type %u on stream %d length (no header) %zu",  buf,  0x22u);
    }
  }

  int v5 = *((unsigned __int8 *)a2 + 12);
  if (v5 == 8)
  {
    if (gLogDatapath)
    {
      uint32_t v33 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        int v34 = *((_DWORD *)a2 + 2);
        int v35 = *((_DWORD *)a2 + 4);
        *(_DWORD *)buf = 136446722;
        int v58 = "on_frame_send_callback";
        __int16 v59 = 1024;
        *(_DWORD *)int v60 = v34;
        *(_WORD *)&v60[4] = 1024;
        *(_DWORD *)&v60[6] = v35;
        _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s sending window update frame for stream %d, window increment %d",  buf,  0x18u);
      }
    }

    int v5 = *((unsigned __int8 *)a2 + 12);
  }

  if (v5) {
    return 0LL;
  }
  int v7 = *((_DWORD *)a2 + 2);
  if (!v7) {
    return 0LL;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v58 = "on_frame_send_callback";
    int v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v56 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v36 = (os_log_s *)__nwlog_obj();
      os_log_type_t v37 = type[0];
      if (!os_log_type_enabled(v36, type[0])) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v58 = "on_frame_send_callback";
      int v15 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (v56)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v36 = (os_log_s *)__nwlog_obj();
      os_log_type_t v37 = type[0];
      BOOL v38 = os_log_type_enabled(v36, type[0]);
      if (backtrace_string)
      {
        if (!v38) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446466;
        int v58 = "on_frame_send_callback";
        __int16 v59 = 2082;
        *(void *)int v60 = backtrace_string;
        uint64_t v18 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
        os_log_type_t v19 = v36;
        os_log_type_t v20 = v37;
        uint32_t v21 = 22;
        goto LABEL_23;
      }

      if (!v38) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v58 = "on_frame_send_callback";
      int v15 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }

    else
    {
      os_log_type_t v36 = (os_log_s *)__nwlog_obj();
      os_log_type_t v37 = type[0];
      if (!os_log_type_enabled(v36, type[0])) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v58 = "on_frame_send_callback";
      int v15 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }

    BOOL v26 = v36;
    os_log_type_t v27 = v37;
    uint32_t v28 = 12;
    goto LABEL_40;
  }

  if (*(void *)(a3 + 120))
  {
    *(void *)os_log_type_t type = 0LL;
    uint64_t stream_from_id = nw_http2_transport_get_stream_from_id(a3, v7, type);
    if (stream_from_id)
    {
      uint64_t v9 = stream_from_id;
      uint64_t v10 = *(void *)type;
      if (*(void *)type)
      {
        if (*(void *)(stream_from_id + 16))
        {
          nw_http2_transport_drain_next_frame_for_stream(a3, *(uint64_t *)type, stream_from_id, 0);
          return 0LL;
        }

        if ((*(_BYTE *)(stream_from_id + 36) & 4) != 0)
        {
          if (gLogDatapath)
          {
            BOOL v51 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              int v58 = "on_frame_send_callback";
              __int16 v59 = 2082;
              *(void *)int v60 = a3 + 205;
              _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s sending deferred end stream",  buf,  0x16u);
            }
          }

          nw_http2_transport_send_end_stream(a3, v9);
          return 0LL;
        }

        if (!gLogDatapath) {
          goto LABEL_99;
        }
        int v39 = (os_log_s *)__nwlog_obj();
        BOOL v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG);
        uint64_t v10 = *(void *)type;
        if (v40)
        {
          int v41 = *(_DWORD *)(v9 + 32);
          *(_DWORD *)buf = 136446978;
          int v58 = "on_frame_send_callback";
          __int16 v59 = 2082;
          *(void *)int v60 = a3 + 205;
          *(_WORD *)&v60[8] = 2048;
          *(void *)int v61 = *(void *)type;
          *(_WORD *)&v61[8] = 1024;
          int v62 = v41;
          _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s no more pending output frames, delivering output available to protocol %p for stream %d",  buf,  0x26u);
          uint64_t v10 = *(void *)type;
        }

        if (v10)
        {
LABEL_99:
          uint64_t v24 = *(void *)(v10 + 24);
          if (v24)
          {
            int v25 = *(void (**)(uint64_t, uint64_t))(v24 + 72);
            if (v25)
            {
              v25(v10, a3);
              return 0LL;
            }
          }
        }

        __nwlog_obj();
        int v42 = "invalid";
        if (*(void *)type && *(void *)(*(void *)type + 16LL)) {
          int v42 = *(const char **)(*(void *)type + 16LL);
        }
        *(_DWORD *)buf = 136446466;
        int v58 = "on_frame_send_callback";
        __int16 v59 = 2082;
        *(void *)int v60 = v42;
        int v43 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t v56 = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (__nwlog_fault(v43, &v56, &v54))
        {
          if (v56 == OS_LOG_TYPE_FAULT)
          {
            __int16 v44 = (os_log_s *)__nwlog_obj();
            os_log_type_t v45 = v56;
            if (!os_log_type_enabled(v44, v56)) {
              goto LABEL_95;
            }
            __int16 v46 = "invalid";
            if (*(void *)type && *(void *)(*(void *)type + 16LL)) {
              __int16 v46 = *(const char **)(*(void *)type + 16LL);
            }
            *(_DWORD *)buf = 136446466;
            int v58 = "on_frame_send_callback";
            __int16 v59 = 2082;
            *(void *)int v60 = v46;
            os_log_type_t v47 = "%{public}s protocol %{public}s has invalid output_available callback";
            goto LABEL_94;
          }

          if (!v54)
          {
            __int16 v44 = (os_log_s *)__nwlog_obj();
            os_log_type_t v45 = v56;
            if (!os_log_type_enabled(v44, v56)) {
              goto LABEL_95;
            }
            BOOL v52 = "invalid";
            if (*(void *)type && *(void *)(*(void *)type + 16LL)) {
              BOOL v52 = *(const char **)(*(void *)type + 16LL);
            }
            *(_DWORD *)buf = 136446466;
            int v58 = "on_frame_send_callback";
            __int16 v59 = 2082;
            *(void *)int v60 = v52;
            os_log_type_t v47 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
            goto LABEL_94;
          }

          __int16 v48 = (char *)__nw_create_backtrace_string();
          __int16 v44 = (os_log_s *)__nwlog_obj();
          os_log_type_t v45 = v56;
          BOOL v49 = os_log_type_enabled(v44, v56);
          if (v48)
          {
            if (v49)
            {
              uint64_t v50 = "invalid";
              if (*(void *)type && *(void *)(*(void *)type + 16LL)) {
                uint64_t v50 = *(const char **)(*(void *)type + 16LL);
              }
              *(_DWORD *)buf = 136446722;
              int v58 = "on_frame_send_callback";
              __int16 v59 = 2082;
              *(void *)int v60 = v50;
              *(_WORD *)&v60[8] = 2082;
              *(void *)int v61 = v48;
              _os_log_impl( &dword_181A5C000,  v44,  v45,  "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v48);
            goto LABEL_95;
          }

          if (v49)
          {
            int v53 = "invalid";
            if (*(void *)type && *(void *)(*(void *)type + 16LL)) {
              int v53 = *(const char **)(*(void *)type + 16LL);
            }
            *(_DWORD *)buf = 136446466;
            int v58 = "on_frame_send_callback";
            __int16 v59 = 2082;
            *(void *)int v60 = v53;
            os_log_type_t v47 = "%{public}s protocol %{public}s has invalid output_available callback, no backtrace";
LABEL_94:
            _os_log_impl(&dword_181A5C000, v44, v45, v47, buf, 0x16u);
          }
        }

{
  unsigned int v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  int v17;
  const char *v18;
  os_log_s *v19;
  os_log_type_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  int v24;
  int v25;
  const char *v26;
  os_log_s *v27;
  os_log_type_t v28;
  uint32_t v29;
  char *v30;
  BOOL v31;
  int v32;
  os_log_s *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  char *v38;
  unint64_t v39;
  int8x8_t v40;
  uint8x8_t v41;
  unint64_t v42;
  void *v43;
  void *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  os_log_s *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  os_log_s *v57;
  int v58;
  int v59;
  uint64_t v60;
  os_log_s *v61;
  int v62;
  int v63;
  const char *v64;
  os_log_s *v65;
  os_log_type_t v66;
  const char *v67;
  char *backtrace_string;
  BOOL v69;
  os_log_s *v70;
  int v71;
  BOOL v72;
  os_log_s *v73;
  int v74;
  int v75;
  os_log_s *v76;
  uint64_t v77;
  os_log_s *v78;
  int v79;
  int v80;
  os_log_s *v81;
  int v82;
  int v83;
  os_log_type_t type[15];
  char v85;
  uint8_t buf[4];
  const char *v87;
  __int16 v88;
  _BYTE v89[10];
  _BYTE v90[10];
  _BYTE v91[26];
  uint64_t v92;
  uint64_t v92 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    BOOL v57 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
    {
      int v58 = *((unsigned __int8 *)a2 + 12);
      __int16 v59 = *((_DWORD *)a2 + 2);
      int v60 = *a2;
      *(_DWORD *)buf = 136446978;
      size_t v87 = "on_frame_send_callback";
      __int16 v88 = 1024;
      *(_DWORD *)uint64_t v89 = v58;
      *(_WORD *)&v89[4] = 1024;
      *(_DWORD *)&v89[6] = v59;
      *(_WORD *)uint64_t v90 = 2048;
      *(void *)&v90[2] = v60;
      _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEBUG,  "%{public}s called for frame type %u on stream %d length (no header) %zu",  buf,  0x22u);
    }
  }

  int v5 = *((unsigned __int8 *)a2 + 12);
  if (v5 == 8)
  {
    if (gLogDatapath)
    {
      int v61 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
      {
        int v62 = *((_DWORD *)a2 + 2);
        uint64_t v63 = *((_DWORD *)a2 + 4);
        *(_DWORD *)buf = 136446722;
        size_t v87 = "on_frame_send_callback";
        __int16 v88 = 1024;
        *(_DWORD *)uint64_t v89 = v62;
        *(_WORD *)&v89[4] = 1024;
        *(_DWORD *)&v89[6] = v63;
        _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_DEBUG,  "%{public}s sending window update frame for stream %d, window increment %d",  buf,  0x18u);
      }
    }

    int v5 = *((unsigned __int8 *)a2 + 12);
  }

  if (v5 > 1) {
    goto LABEL_73;
  }
  os_log_type_t v6 = *((_DWORD *)a2 + 2);
  if (!v6) {
    return 0LL;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v87 = "on_frame_send_callback";
    uint64_t v64 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    uint64_t v85 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v65 = (os_log_s *)__nwlog_obj();
      BOOL v66 = type[0];
      if (os_log_type_enabled(v65, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        size_t v87 = "on_frame_send_callback";
        BOOL v67 = "%{public}s nghttp2 user data is NULL, not http2";
LABEL_156:
        _os_log_impl(&dword_181A5C000, v65, v66, v67, buf, 0xCu);
      }

uint64_t send_callback(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (!a5)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "send_callback";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v65[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      os_log_type_t v33 = type[0];
      if (!os_log_type_enabled(v32, type[0])) {
        goto LABEL_75;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "send_callback";
      int v25 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (LOBYTE(v65[0]))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      os_log_type_t v33 = type[0];
      BOOL v42 = os_log_type_enabled(v32, type[0]);
      if (backtrace_string)
      {
        if (v42)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "send_callback";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = backtrace_string;
          uint32_t v28 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
          os_log_type_t v29 = v32;
          os_log_type_t v30 = v33;
          uint32_t v31 = 22;
          goto LABEL_51;
        }

uint64_t send_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v142 = *MEMORY[0x1895F89C0];
  if (!a6)
  {
    __nwlog_obj();
    unsigned int buf = 136446210;
    uint64_t v137 = "send_data_callback";
    char v65 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v130) = 16;
    LOBYTE(v126) = 0;
    if (v130 == 17)
    {
      BOOL v66 = (os_log_s *)__nwlog_obj();
      os_log_type_t v67 = v130;
      if (!os_log_type_enabled(v66, (os_log_type_t)v130)) {
        goto LABEL_179;
      }
      unsigned int buf = 136446210;
      uint64_t v137 = "send_data_callback";
      __int16 v68 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if ((_BYTE)v126)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v66 = (os_log_s *)__nwlog_obj();
      os_log_type_t v67 = v130;
      BOOL v76 = os_log_type_enabled(v66, (os_log_type_t)v130);
      if (backtrace_string)
      {
        if (v76)
        {
          unsigned int buf = 136446466;
          uint64_t v137 = "send_data_callback";
          __int16 v138 = 2082;
          uint64_t v139 = (uint64_t)backtrace_string;
          BOOL v77 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
          uint64_t v78 = v66;
          os_log_type_t v79 = v67;
          uint32_t v80 = 22;
LABEL_141:
          _os_log_impl(&dword_181A5C000, v78, v79, v77, (uint8_t *)&buf, v80);
        }

uint64_t on_frame_not_send_callback(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (a4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = gLogObj;
    BOOL v8 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (a2)
    {
      if (v8)
      {
        uint64_t v9 = nghttp2_strerror();
        int v10 = *((unsigned __int8 *)a2 + 12);
        int v11 = *((_DWORD *)a2 + 2);
        uint64_t v12 = *a2;
        *(_DWORD *)unsigned int buf = 136447746;
        int v26 = "on_frame_not_send_callback";
        __int16 v27 = 2082;
        uint64_t v28 = (char *)(a4 + 205);
        __int16 v29 = 1024;
        int v30 = a3;
        __int16 v31 = 2080;
        uint64_t v32 = v9;
        __int16 v33 = 1024;
        int v34 = v10;
        __int16 v35 = 1024;
        int v36 = v11;
        __int16 v37 = 2048;
        uint64_t v38 = v12;
        int v13 = "%{public}s %{public}s called with error %d (%s) for frame type %u on stream %d length (no header) %zu";
        unint64_t v14 = (os_log_s *)v7;
        uint32_t v15 = 60;
LABEL_7:
        _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
      }
    }

    else if (v8)
    {
      *(_DWORD *)unsigned int buf = 136446722;
      int v26 = "on_frame_not_send_callback";
      __int16 v27 = 2082;
      uint64_t v28 = (char *)(a4 + 205);
      __int16 v29 = 1024;
      int v30 = a3;
      int v13 = "%{public}s %{public}s called with error %d";
      unint64_t v14 = (os_log_s *)v7;
      uint32_t v15 = 28;
      goto LABEL_7;
    }

    *(_BYTE *)(a4 + 204) |= 8u;
    return 4294966394LL;
  }

  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  int v26 = "on_frame_not_send_callback";
  uint64_t v17 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v17, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v26 = "on_frame_not_send_callback";
      uint64_t v20 = "%{public}s nghttp2 user data is NULL, not http2_transport";
      goto LABEL_23;
    }

    if (!v23)
    {
      os_log_type_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v26 = "on_frame_not_send_callback";
      uint64_t v20 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
      goto LABEL_23;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v22 = os_log_type_enabled(v18, type);
    if (backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        int v26 = "on_frame_not_send_callback";
        __int16 v27 = 2082;
        uint64_t v28 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_24;
    }

    if (v22)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      int v26 = "on_frame_not_send_callback";
      uint64_t v20 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
LABEL_23:
      _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
    }
  }

{
  int v7;
  os_log_s *v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  void *v16;
  int v17;
  uint64_t v18;
  int v19;
  const char *v20;
  os_log_s *v21;
  os_log_type_t v22;
  uint64_t v23;
  int v24;
  int v25;
  os_log_s *v26;
  int v27;
  int v28;
  char *v29;
  os_log_s *v30;
  os_log_type_t v31;
  const char *v32;
  char *backtrace_string;
  BOOL v34;
  os_log_type_t type[15];
  char v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  int v50;
  __int16 v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  os_log_type_t v55 = *MEMORY[0x1895F89C0];
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v38 = "on_frame_not_send_callback";
    __int16 v29 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    int v36 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v30 = (os_log_s *)__nwlog_obj();
      __int16 v31 = type[0];
      if (!os_log_type_enabled(v30, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v38 = "on_frame_not_send_callback";
      uint64_t v32 = "%{public}s nghttp2 user data is NULL, not http2";
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v30 = (os_log_s *)__nwlog_obj();
      __int16 v31 = type[0];
      int v34 = os_log_type_enabled(v30, type[0]);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v38 = "on_frame_not_send_callback";
          uint64_t v39 = 2082;
          BOOL v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_46;
      }

      if (!v34)
      {
LABEL_46:
        if (v29) {
          free(v29);
        }
        return 4294966394LL;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v38 = "on_frame_not_send_callback";
      uint64_t v32 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }

    else
    {
      int v30 = (os_log_s *)__nwlog_obj();
      __int16 v31 = type[0];
      if (!os_log_type_enabled(v30, type[0])) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v38 = "on_frame_not_send_callback";
      uint64_t v32 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0xCu);
    goto LABEL_46;
  }

  uint64_t v7 = *(__int16 *)(a4 + 388);
  if (a2)
  {
    if ((v7 & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v8 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = *(_DWORD *)(a4 + 368);
        int v10 = nghttp2_strerror();
        int v11 = *((unsigned __int8 *)a2 + 12);
        uint64_t v12 = *((_DWORD *)a2 + 2);
        int v13 = *a2;
        *(_DWORD *)unsigned int buf = 136448258;
        uint64_t v38 = "on_frame_not_send_callback";
        uint64_t v39 = 2082;
        BOOL v40 = (char *)(a4 + 390);
        int v41 = 2080;
        int v42 = " ";
        uint64_t v43 = 1024;
        uint64_t v44 = v9;
        char v45 = 1024;
        uint64_t v46 = a3;
        os_log_type_t v47 = 2080;
        uint64_t v48 = v10;
        uint64_t v49 = 1024;
        int v50 = v11;
        int v51 = 1024;
        int v52 = v12;
        int v53 = 2048;
        char v54 = v13;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> called with error %d (%s) for frame type %u on stream %d length (no header) %zu",  buf,  0x4Cu);
      }
    }

    *(void *)os_log_type_t type = 0LL;
    uint64_t result = nw_http2_get_stream_from_id(a4, *((_DWORD *)a2 + 2), type);
    if (result)
    {
      uint32_t v15 = result;
      int v16 = *(void **)type;
      uint64_t v17 = *(unsigned __int16 *)(v15 + 188) | (*(unsigned __int8 *)(v15 + 190) << 16);
      if (*(void *)type)
      {
        if ((*(_WORD *)(v15 + 188) & 0x40) == 0)
        {
          *(_BYTE *)(v15 + 190) = BYTE2(v17);
          *(_WORD *)(v15 + 18_Block_object_dispose(va, 8) = v17 | 0x40;
          nw_protocol_error(v16, a4);
          nw_protocol_disconnected(*(void **)type, a4);
        }

        return 0LL;
      }

      if ((v17 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v26 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          uint64_t v28 = *(_DWORD *)(v15 + 176);
          __int16 v27 = *(_DWORD *)(v15 + 180);
          *(_DWORD *)unsigned int buf = 136447746;
          uint64_t v38 = "on_frame_not_send_callback";
          uint64_t v39 = 2082;
          BOOL v40 = (char *)(v15 + 191);
          int v41 = 2080;
          int v42 = " ";
          uint64_t v43 = 1024;
          uint64_t v44 = v27;
          char v45 = 1024;
          uint64_t v46 = v28;
          os_log_type_t v47 = 2048;
          uint64_t v48 = v15;
          uint64_t v49 = 1024;
          int v50 = v28;
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%d> stream (%pm %d) did not have protocol extra",  buf,  0x3Cu);
        }
      }

      return 4294966394LL;
    }

    if ((*(__int16 *)(a4 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      char v23 = gconnectionLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        int v24 = *(_DWORD *)(a4 + 368);
        uint64_t v25 = *((_DWORD *)a2 + 2);
        *(_DWORD *)unsigned int buf = 136447234;
        uint64_t v38 = "on_frame_not_send_callback";
        uint64_t v39 = 2082;
        BOOL v40 = (char *)(a4 + 390);
        int v41 = 2080;
        int v42 = " ";
        uint64_t v43 = 1024;
        uint64_t v44 = v24;
        char v45 = 1024;
        uint64_t v46 = v25;
        uint64_t v20 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
        int v21 = (os_log_s *)v23;
        BOOL v22 = OS_LOG_TYPE_DEBUG;
        goto LABEL_17;
      }
    }
  }

  else
  {
    if (v7 < 0) {
      return 0LL;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v18 = gconnectionLogObj;
    uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      os_log_type_t v19 = *(_DWORD *)(a4 + 368);
      *(_DWORD *)unsigned int buf = 136447234;
      uint64_t v38 = "on_frame_not_send_callback";
      uint64_t v39 = 2082;
      BOOL v40 = (char *)(a4 + 390);
      int v41 = 2080;
      int v42 = " ";
      uint64_t v43 = 1024;
      uint64_t v44 = v19;
      char v45 = 1024;
      uint64_t v46 = a3;
      uint64_t v20 = "%{public}s %{public}s%s<i%u> called with error %d";
      int v21 = (os_log_s *)v18;
      BOOL v22 = OS_LOG_TYPE_ERROR;
LABEL_17:
      _os_log_impl(&dword_181A5C000, v21, v22, v20, buf, 0x2Cu);
      return 0LL;
    }
  }

  return result;
}

uint64_t on_invalid_frame_recv_callback(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    char v23 = "on_invalid_frame_recv_callback";
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v23 = "on_invalid_frame_recv_callback";
      int v13 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v18 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          char v23 = "on_invalid_frame_recv_callback";
          __int16 v24 = 2082;
          uint64_t v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (!v18)
      {
LABEL_36:
        if (v10) {
          free(v10);
        }
        return 4294966394LL;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      char v23 = "on_invalid_frame_recv_callback";
      int v13 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }

    else
    {
      int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v23 = "on_invalid_frame_recv_callback";
      int v13 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_36;
  }

  if (gLogDatapath)
  {
    uint32_t v15 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446978;
      char v23 = "on_invalid_frame_recv_callback";
      __int16 v24 = 2082;
      uint64_t v25 = (char *)(a4 + 205);
      __int16 v26 = 1024;
      int v27 = a3;
      __int16 v28 = 2080;
      uint64_t v29 = nghttp2_strerror();
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called with error %d (%s)",  buf,  0x26u);
    }
  }

  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v8 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      char v23 = "on_invalid_frame_recv_callback";
      __int16 v24 = 2082;
      uint64_t v25 = (char *)(a4 + 205);
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_INFO, "%{public}s %{public}s no frame, closing", buf, 0x16u);
    }

    goto LABEL_10;
  }

  int v6 = *(_DWORD *)(a2 + 8);
  if (gLogDatapath)
  {
    int v16 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      char v23 = "on_invalid_frame_recv_callback";
      __int16 v24 = 2082;
      uint64_t v25 = (char *)(a4 + 205);
      __int16 v26 = 1024;
      int v27 = v6;
      _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s error on stream %d", buf, 0x1Cu);
    }
  }

  if (v6 == -1)
  {
    nw_http2_transport_connection_close(a4);
    return 0LL;
  }

  uint64_t stream_from_id = nw_http2_transport_get_stream_from_id(a4, v6, 0LL);
  if (stream_from_id)
  {
    nw_http2_transport_stream_close(a4, stream_from_id);
LABEL_10:
    *(_BYTE *)(a4 + 204) |= 8u;
    return 4294966394LL;
  }

  if (!gLogDatapath) {
    return 0LL;
  }
  os_log_type_t v19 = (os_log_s *)__nwlog_obj();
  uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    *(_DWORD *)unsigned int buf = 136446722;
    char v23 = "on_invalid_frame_recv_callback";
    __int16 v24 = 2082;
    uint64_t v25 = (char *)(a4 + 205);
    __int16 v26 = 1024;
    int v27 = v6;
    _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s No stream found for id %d, ignoring",  buf,  0x1Cu);
    return 0LL;
  }

  return result;
}

{
  int v6;
  uint64_t stream_from_id;
  uint64_t v8;
  os_log_s *v9;
  int v10;
  uint64_t result;
  char *v12;
  os_log_s *v13;
  os_log_type_t v14;
  const char *v15;
  os_log_s *v17;
  int v18;
  uint64_t v19;
  int v20;
  const char *v21;
  os_log_s *v22;
  uint32_t v23;
  uint64_t v24;
  int v25;
  int v26;
  char *backtrace_string;
  BOOL v28;
  os_log_s *v29;
  int v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  char v45 = *MEMORY[0x1895F89C0];
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v34 = "on_invalid_frame_recv_callback";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v13 = (os_log_s *)__nwlog_obj();
      unint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v34 = "on_invalid_frame_recv_callback";
      uint32_t v15 = "%{public}s nghttp2 user data is NULL, not http2";
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v13 = (os_log_s *)__nwlog_obj();
      unint64_t v14 = type;
      __int16 v28 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          int v34 = "on_invalid_frame_recv_callback";
          __int16 v35 = 2082;
          int v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_55;
      }

      if (!v28)
      {
LABEL_55:
        if (v12) {
          free(v12);
        }
        return 4294966394LL;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      int v34 = "on_invalid_frame_recv_callback";
      uint32_t v15 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }

    else
    {
      int v13 = (os_log_s *)__nwlog_obj();
      unint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v34 = "on_invalid_frame_recv_callback";
      uint32_t v15 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_55;
  }

  if ((*(__int16 *)(a4 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v17 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      BOOL v18 = *(_DWORD *)(a4 + 368);
      *(_DWORD *)unsigned int buf = 136447490;
      int v34 = "on_invalid_frame_recv_callback";
      __int16 v35 = 2082;
      int v36 = (char *)(a4 + 390);
      __int16 v37 = 2080;
      uint64_t v38 = " ";
      uint64_t v39 = 1024;
      BOOL v40 = v18;
      int v41 = 1024;
      int v42 = a3;
      uint64_t v43 = 2080;
      uint64_t v44 = nghttp2_strerror();
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called with error %d (%s)",  buf,  0x36u);
    }
  }

  if (!a2)
  {
    if ((*(__int16 *)(a4 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v9 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        int v10 = *(_DWORD *)(a4 + 368);
        *(_DWORD *)unsigned int buf = 136446978;
        int v34 = "on_invalid_frame_recv_callback";
        __int16 v35 = 2082;
        int v36 = (char *)(a4 + 390);
        __int16 v37 = 2080;
        uint64_t v38 = " ";
        uint64_t v39 = 1024;
        BOOL v40 = v10;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> no frame, closing",  buf,  0x26u);
      }
    }

    goto LABEL_16;
  }

  int v6 = *(_DWORD *)(a2 + 8);
  uint64_t stream_from_id = nw_http2_get_stream_from_id(a4, v6, 0LL);
  BOOL v8 = stream_from_id;
  if (stream_from_id)
  {
    if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x80000) == 0
      && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v24 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        __int16 v26 = *(_DWORD *)(v8 + 176);
        uint64_t v25 = *(_DWORD *)(v8 + 180);
        *(_DWORD *)unsigned int buf = 136447490;
        int v34 = "on_invalid_frame_recv_callback";
        __int16 v35 = 2082;
        int v36 = (char *)(v8 + 191);
        __int16 v37 = 2080;
        uint64_t v38 = " ";
        uint64_t v39 = 1024;
        BOOL v40 = v25;
        int v41 = 1024;
        int v42 = v26;
        uint64_t v43 = 1024;
        LODWORD(v44) = v6;
        int v21 = "%{public}s %{public}s%s<i%u:s%d> error on stream %d";
        BOOL v22 = (os_log_s *)v24;
        char v23 = 50;
        goto LABEL_40;
      }
    }
  }

  else if ((*(__int16 *)(a4 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v19 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      char v20 = *(_DWORD *)(a4 + 368);
      *(_DWORD *)unsigned int buf = 136447234;
      int v34 = "on_invalid_frame_recv_callback";
      __int16 v35 = 2082;
      int v36 = (char *)(a4 + 390);
      __int16 v37 = 2080;
      uint64_t v38 = " ";
      uint64_t v39 = 1024;
      BOOL v40 = v20;
      int v41 = 1024;
      int v42 = v6;
      int v21 = "%{public}s %{public}s%s<i%u> error on stream %d";
      BOOL v22 = (os_log_s *)v19;
      char v23 = 44;
LABEL_40:
      _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_DEBUG, v21, buf, v23);
    }
  }

  if (v6 == -1)
  {
    nw_http2_connection_close(a4);
    return 0LL;
  }

  else
  {
    if (v8)
    {
      nw_http2_stream_close(a4, v8);
LABEL_16:
      *(_WORD *)(a4 + 388) |= 0x10u;
      return 4294966394LL;
    }

    uint64_t result = 0LL;
    if ((*(__int16 *)(a4 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v29 = (os_log_s *)gconnectionLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        uint64_t v30 = *(_DWORD *)(a4 + 368);
        *(_DWORD *)unsigned int buf = 136447234;
        int v34 = "on_invalid_frame_recv_callback";
        __int16 v35 = 2082;
        int v36 = (char *)(a4 + 390);
        __int16 v37 = 2080;
        uint64_t v38 = " ";
        uint64_t v39 = 1024;
        BOOL v40 = v30;
        int v41 = 1024;
        int v42 = v6;
        _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> No stream found for id %d, ignoring",  buf,  0x2Cu);
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t error_callback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v8 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unsigned int buf = 136446722;
    char v20 = "error_callback";
    __int16 v21 = 1024;
    *(_DWORD *)BOOL v22 = a2;
    *(_WORD *)&uint8_t v22[4] = 2080;
    *(void *)&v22[6] = a3;
    _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s called with error %d, message %s", buf, 0x1Cu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v9 = (os_log_s *)gLogObj;
  if (a5)
  {
    uint64_t result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      *(_DWORD *)unsigned int buf = 136446978;
      char v20 = "error_callback";
      __int16 v21 = 2082;
      *(void *)BOOL v22 = a5 + 205;
      *(_WORD *)&v22[8] = 1024;
      *(_DWORD *)&v22[10] = a2;
      __int16 v23 = 2080;
      uint64_t v24 = a3;
      _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s error (%d: %s)", buf, 0x26u);
      return 0LL;
    }

    return result;
  }

  *(_DWORD *)unsigned int buf = 136446210;
  char v20 = "error_callback";
  int v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        char v20 = "error_callback";
        unint64_t v14 = "%{public}s nghttp2 user data is NULL, not http2_transport";
LABEL_20:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          char v20 = "error_callback";
          __int16 v21 = 2082;
          *(void *)BOOL v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v16)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        char v20 = "error_callback";
        unint64_t v14 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
        goto LABEL_20;
      }
    }

    else
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        char v20 = "error_callback";
        unint64_t v14 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
        goto LABEL_20;
      }
    }
  }

{
  os_log_s *v8;
  os_log_s *v9;
  uint64_t result;
  int v11;
  char *v12;
  os_log_s *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  BOOL v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  _BYTE v23[18];
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v30 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v8 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unsigned int buf = 136446722;
    __int16 v21 = "error_callback";
    BOOL v22 = 1024;
    *(_DWORD *)__int16 v23 = a2;
    *(_WORD *)&v23[4] = 2080;
    *(void *)&v23[6] = a3;
    _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s called with error %d, message %s", buf, 0x1Cu);
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v21 = "error_callback";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v18 = 0;
    if (__nwlog_fault(v12, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v13 = (os_log_s *)__nwlog_obj();
        unint64_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v21 = "error_callback";
          uint32_t v15 = "%{public}s nghttp2 user data is NULL, not http2";
LABEL_24:
          _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
        }
      }

      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v13 = (os_log_s *)__nwlog_obj();
        unint64_t v14 = type;
        char v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            __int16 v21 = "error_callback";
            BOOL v22 = 2082;
            *(void *)__int16 v23 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v17)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v21 = "error_callback";
          uint32_t v15 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
          goto LABEL_24;
        }
      }

      else
      {
        os_log_type_t v13 = (os_log_s *)__nwlog_obj();
        unint64_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v21 = "error_callback";
          uint32_t v15 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
          goto LABEL_24;
        }
      }
    }

void nghttp2_debug_logging_callback(const char *a1, va_list a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v4 = 0LL;
  vasprintf(&v4, a1, a2);
  uint64_t v2 = v4;
  if (v4)
  {
    if (!gLogDatapath) {
      goto LABEL_3;
    }
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      int v6 = "nghttp2_debug_logging_callback";
      __int16 v7 = 2082;
      BOOL v8 = v4;
      _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s", buf, 0x16u);
    }

    uint64_t v2 = v4;
    if (v4) {
LABEL_3:
    }
      free(v2);
  }

void nw_http2_transport_connection_close(uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    __int16 v35 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      int v36 = "";
      if (a1) {
        int v36 = (const char *)(a1 + 205);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      char v54 = "nw_http2_transport_connection_close";
      __int16 v55 = 2082;
      uint64_t v56 = (uint64_t)v36;
      _os_log_impl(&dword_181A5C000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    char v54 = "nw_http2_transport_connection_close";
    __int16 v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type;
      if (!os_log_type_enabled(v37, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v54 = "nw_http2_transport_connection_close";
      uint64_t v29 = "%{public}s called with null http2_transport";
    }

    else if (v51)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type;
      BOOL v42 = os_log_type_enabled(v37, type);
      if (backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          char v54 = "nw_http2_transport_connection_close";
          __int16 v55 = 2082;
          uint64_t v56 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s called with null http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_62;
      }

      if (!v42) {
        goto LABEL_62;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v54 = "nw_http2_transport_connection_close";
      uint64_t v29 = "%{public}s called with null http2_transport, no backtrace";
    }

    else
    {
      __int16 v37 = (os_log_s *)__nwlog_obj();
      os_log_type_t v38 = type;
      if (!os_log_type_enabled(v37, type)) {
        goto LABEL_62;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v54 = "nw_http2_transport_connection_close";
      uint64_t v29 = "%{public}s called with null http2_transport, backtrace limit exceeded";
    }

    uint64_t v32 = v37;
    os_log_type_t v33 = v38;
    uint32_t v34 = 12;
    goto LABEL_61;
  }

  char v2 = *(_BYTE *)(a1 + 204);
  *(_BYTE *)(a1 + 204) = v2 & 0xF9 | 4;
  uint64_t v3 = *(char **)(a1 + 120);
  uint64_t v4 = MEMORY[0x1895F87A8];
  if (v3)
  {
    v50[0] = MEMORY[0x1895F87A8];
    v50[1] = 0x40000000LL;
    v50[2] = ___ZL35nw_http2_transport_connection_closeP27nw_protocol_http2_transport_block_invoke;
    v50[3] = &__block_descriptor_tmp_17_37047;
    v50[4] = a1;
    nw_hash_table_apply(v3, (uint64_t)v50);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      char v54 = "nw_http2_transport_connection_close";
      __int16 v55 = 2082;
      uint64_t v56 = a1 + 205;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s id table is NULL, cannot close streams",  buf,  0x16u);
    }
  }

  if ((v2 & 2) == 0)
  {
    if (gLogDatapath)
    {
      int v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        char v54 = "nw_http2_transport_connection_close";
        __int16 v55 = 2082;
        uint64_t v56 = a1 + 205;
        __int16 v7 = "%{public}s %{public}s not sending GOAWAY since tunnel was not connected";
LABEL_23:
        _os_log_impl(&dword_181A5C000, v6, OS_LOG_TYPE_DEBUG, v7, buf, 0x16u);
        goto LABEL_44;
      }
    }

    goto LABEL_44;
  }

  if (gLogDatapath)
  {
    uint64_t v39 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v40 = nghttp2_http2_strerror();
      *(_DWORD *)unsigned int buf = 136446978;
      char v54 = "nw_http2_transport_send_goaway";
      __int16 v55 = 2082;
      uint64_t v56 = a1 + 205;
      __int16 v57 = 1024;
      *(_DWORD *)uint64_t v58 = 0;
      *(_WORD *)&v58[4] = 2082;
      *(void *)&v58[6] = v40;
      _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called with error %u (%{public}s)",  buf,  0x26u);
    }
  }

  if ((*(_BYTE *)(a1 + 204) & 1) == 0)
  {
    int v8 = *(_DWORD *)(a1 + 200);
    if (!v8) {
      goto LABEL_25;
    }
    if ((*(_BYTE *)(a1 + 204) & 0x10) != 0)
    {
      if ((v8 & 1) != 0) {
        goto LABEL_25;
      }
      __nwlog_obj();
      *(_DWORD *)unsigned int buf = 136446722;
      char v54 = "nw_http2_transport_send_goaway";
      __int16 v55 = 2082;
      uint64_t v56 = a1 + 205;
      __int16 v57 = 1024;
      *(_DWORD *)uint64_t v58 = v8;
      uint64_t v9 = (void *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v51 = 0;
      if (__nwlog_fault((const char *)v9, &type, &v51))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v10 = (os_log_s *)__nwlog_obj();
          os_log_type_t v11 = type;
          if (!os_log_type_enabled(v10, type)) {
            goto LABEL_111;
          }
          *(_DWORD *)unsigned int buf = 136446722;
          char v54 = "nw_http2_transport_send_goaway";
          __int16 v55 = 2082;
          uint64_t v56 = a1 + 205;
          __int16 v57 = 1024;
          *(_DWORD *)uint64_t v58 = v8;
          os_log_type_t v12 = "%{public}s %{public}s Last stream value %d is even, but we are the server";
          goto LABEL_110;
        }

        if (!v51)
        {
          int v10 = (os_log_s *)__nwlog_obj();
          os_log_type_t v11 = type;
          if (!os_log_type_enabled(v10, type)) {
            goto LABEL_111;
          }
          *(_DWORD *)unsigned int buf = 136446722;
          char v54 = "nw_http2_transport_send_goaway";
          __int16 v55 = 2082;
          uint64_t v56 = a1 + 205;
          __int16 v57 = 1024;
          *(_DWORD *)uint64_t v58 = v8;
          os_log_type_t v12 = "%{public}s %{public}s Last stream value %d is even, but we are the server, backtrace limit exceeded";
          goto LABEL_110;
        }

        os_log_type_t v47 = (char *)__nw_create_backtrace_string();
        int v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v48 = os_log_type_enabled(v10, type);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)unsigned int buf = 136446978;
            char v54 = "nw_http2_transport_send_goaway";
            __int16 v55 = 2082;
            uint64_t v56 = a1 + 205;
            __int16 v57 = 1024;
            *(_DWORD *)uint64_t v58 = v8;
            *(_WORD *)&v58[4] = 2082;
            *(void *)&v58[6] = v47;
            _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s %{public}s Last stream value %d is even, but we are the server, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(v47);
          if (!v9)
          {
LABEL_25:
            *(_BYTE *)(a1 + 204) |= 1u;
            if (!nghttp2_submit_goaway())
            {
LABEL_42:
              if (gLogDatapath)
              {
                uint64_t v43 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v44 = nghttp2_http2_strerror();
                  *(_DWORD *)unsigned int buf = 136447234;
                  char v54 = "nw_http2_transport_send_goaway";
                  __int16 v55 = 2082;
                  uint64_t v56 = a1 + 205;
                  __int16 v57 = 1024;
                  *(_DWORD *)uint64_t v58 = v8;
                  *(_WORD *)&v58[4] = 1024;
                  *(_DWORD *)&v58[6] = 0;
                  *(_WORD *)&v58[10] = 2082;
                  *(void *)&v58[12] = v44;
                  _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s submitted GOAWAY frame with last_stream %d and error %u (%{public}s)",  buf,  0x2Cu);
                }
              }

              nw_http2_transport_session_send(a1);
              goto LABEL_44;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v13 = nghttp2_strerror();
            *(_DWORD *)unsigned int buf = 136446466;
            char v54 = "nw_http2_transport_send_goaway";
            __int16 v55 = 2082;
            uint64_t v56 = v13;
            unint64_t v14 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v51 = 0;
            if (__nwlog_fault(v14, &type, &v51))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint32_t v15 = (os_log_s *)gLogObj;
                os_log_type_t v16 = type;
                if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                  goto LABEL_40;
                }
                uint64_t v17 = nghttp2_strerror();
                *(_DWORD *)unsigned int buf = 136446466;
                char v54 = "nw_http2_transport_send_goaway";
                __int16 v55 = 2082;
                uint64_t v56 = v17;
                BOOL v18 = "%{public}s nghttp2_submit_goaway: %{public}s failed";
                goto LABEL_39;
              }

              if (!v51)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint32_t v15 = (os_log_s *)gLogObj;
                os_log_type_t v16 = type;
                if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                  goto LABEL_40;
                }
                uint64_t v22 = nghttp2_strerror();
                *(_DWORD *)unsigned int buf = 136446466;
                char v54 = "nw_http2_transport_send_goaway";
                __int16 v55 = 2082;
                uint64_t v56 = v22;
                BOOL v18 = "%{public}s nghttp2_submit_goaway: %{public}s failed, backtrace limit exceeded";
                goto LABEL_39;
              }

              os_log_type_t v19 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint32_t v15 = (os_log_s *)gLogObj;
              os_log_type_t v16 = type;
              BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
              if (v19)
              {
                if (v20)
                {
                  uint64_t v21 = nghttp2_strerror();
                  *(_DWORD *)unsigned int buf = 136446722;
                  char v54 = "nw_http2_transport_send_goaway";
                  __int16 v55 = 2082;
                  uint64_t v56 = v21;
                  __int16 v57 = 2082;
                  *(void *)uint64_t v58 = v19;
                  _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s nghttp2_submit_goaway: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(v19);
                goto LABEL_40;
              }

              if (v20)
              {
                uint64_t v23 = nghttp2_strerror();
                *(_DWORD *)unsigned int buf = 136446466;
                char v54 = "nw_http2_transport_send_goaway";
                __int16 v55 = 2082;
                uint64_t v56 = v23;
                BOOL v18 = "%{public}s nghttp2_submit_goaway: %{public}s failed, no backtrace";
LABEL_39:
                _os_log_impl(&dword_181A5C000, v15, v16, v18, buf, 0x16u);
              }
            }

uint64_t nw_http2_transport_get_stream_from_id(uint64_t a1, int a2, void *a3)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (a2 <= 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
    __int16 v29 = 2082;
    uint64_t v30 = a1 + 205;
    __int16 v31 = 1024;
    LODWORD(v32) = a2;
    os_log_type_t v11 = "%{public}s %{public}s requested stream id (%d) is not valid, returning NULL stream";
    os_log_type_t v12 = (os_log_s *)v10;
    os_log_type_t v13 = OS_LOG_TYPE_ERROR;
LABEL_9:
    _os_log_impl(&dword_181A5C000, v12, v13, v11, buf, 0x1Cu);
    return 0LL;
  }

  uint64_t stream_node_from_id = nw_http2_transport_get_stream_node_from_id(a1, a2);
  if (!stream_node_from_id)
  {
    if (!gLogDatapath) {
      return 0LL;
    }
    unint64_t v14 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
      return 0LL;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
    __int16 v29 = 2082;
    uint64_t v30 = a1 + 205;
    __int16 v31 = 1024;
    LODWORD(v32) = a2;
    os_log_type_t v11 = "%{public}s %{public}s stream %d not found in id based hash table";
    os_log_type_t v12 = v14;
    os_log_type_t v13 = OS_LOG_TYPE_DEBUG;
    goto LABEL_9;
  }

  uint64_t v7 = stream_node_from_id;
  uint64_t result = *(void *)(stream_node_from_id + 16);
  if (!result)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = a1 + 205;
    *(_DWORD *)unsigned int buf = 136446722;
    os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
    __int16 v29 = 2082;
    uint64_t v30 = a1 + 205;
    __int16 v31 = 2048;
    uint64_t v32 = v7;
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)unsigned int buf = 136446722;
      os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
      __int16 v29 = 2082;
      uint64_t v30 = v15;
      __int16 v31 = 2048;
      uint64_t v32 = v7;
      os_log_type_t v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra";
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      os_log_type_t v18 = type;
      BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)unsigned int buf = 136446978;
          os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
          __int16 v29 = 2082;
          uint64_t v30 = v15;
          __int16 v31 = 2048;
          uint64_t v32 = v7;
          __int16 v33 = 2082;
          uint32_t v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s %{public}s hash node %p didn't have a stream as extra, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
        goto LABEL_31;
      }

      if (!v21)
      {
LABEL_31:
        if (v16) {
          free(v16);
        }
        return 0LL;
      }

      *(_DWORD *)unsigned int buf = 136446722;
      os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
      __int16 v29 = 2082;
      uint64_t v30 = v15;
      __int16 v31 = 2048;
      uint64_t v32 = v7;
      os_log_type_t v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_31;
      }
      *(_DWORD *)unsigned int buf = 136446722;
      os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
      __int16 v29 = 2082;
      uint64_t v30 = v15;
      __int16 v31 = 2048;
      uint64_t v32 = v7;
      os_log_type_t v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0x20u);
    goto LABEL_31;
  }

  if (a3)
  {
    uint64_t v9 = *(void *)(v7 + 32);
    if (v9)
    {
      *a3 = v9;
    }

    else if (gLogDatapath)
    {
      uint64_t v22 = result;
      uint64_t v23 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        int v24 = *(_DWORD *)(v22 + 32);
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v28 = "nw_http2_transport_get_stream_from_id";
        __int16 v29 = 2082;
        uint64_t v30 = a1 + 205;
        __int16 v31 = 1024;
        LODWORD(v32) = v24;
        _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s no input handler attached to stream %d, ignoring",  buf,  0x1Cu);
      }

      return v22;
    }
  }

  return result;
}

void nw_http2_transport_stream_close(uint64_t a1, uint64_t a2)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v43 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v44 = "";
      if (a1) {
        uint64_t v44 = (const char *)(a1 + 205);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      __int16 v64 = 2082;
      char v65 = (void *)v44;
      _os_log_impl(&dword_181A5C000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v63 = "nw_http2_transport_stream_close";
    char v45 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = type;
      if (!os_log_type_enabled(v46, type)) {
        goto LABEL_100;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      BOOL v48 = "%{public}s called with null http2_transport";
      goto LABEL_99;
    }

    if (!v60)
    {
      BOOL v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = type;
      if (!os_log_type_enabled(v46, type)) {
        goto LABEL_100;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      BOOL v48 = "%{public}s called with null http2_transport, backtrace limit exceeded";
      goto LABEL_99;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v46 = (os_log_s *)__nwlog_obj();
    os_log_type_t v47 = type;
    BOOL v54 = os_log_type_enabled(v46, type);
    if (!backtrace_string)
    {
      if (!v54) {
        goto LABEL_100;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      BOOL v48 = "%{public}s called with null http2_transport, no backtrace";
      goto LABEL_99;
    }

    if (v54)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      __int16 v64 = 2082;
      char v65 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s called with null http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_100:
    if (!v45) {
      return;
    }
    goto LABEL_101;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v63 = "nw_http2_transport_stream_close";
    char v45 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = type;
      if (!os_log_type_enabled(v46, type)) {
        goto LABEL_100;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      BOOL v48 = "%{public}s called with null stream";
      goto LABEL_99;
    }

    if (!v60)
    {
      BOOL v46 = (os_log_s *)__nwlog_obj();
      os_log_type_t v47 = type;
      if (!os_log_type_enabled(v46, type)) {
        goto LABEL_100;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      BOOL v48 = "%{public}s called with null stream, backtrace limit exceeded";
      goto LABEL_99;
    }

    __int16 v57 = (char *)__nw_create_backtrace_string();
    BOOL v46 = (os_log_s *)__nwlog_obj();
    os_log_type_t v47 = type;
    BOOL v58 = os_log_type_enabled(v46, type);
    if (v57)
    {
      if (v58)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v63 = "nw_http2_transport_stream_close";
        __int16 v64 = 2082;
        char v65 = v57;
        _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s called with null stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v57);
      if (!v45) {
        return;
      }
LABEL_101:
      free(v45);
      return;
    }

    if (v58)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v63 = "nw_http2_transport_stream_close";
      BOOL v48 = "%{public}s called with null stream, no backtrace";
LABEL_99:
      _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
      goto LABEL_100;
    }

    goto LABEL_100;
  }

  if ((*(_BYTE *)(a2 + 36) & 1) == 0)
  {
    if (gLogDatapath)
    {
      __int16 v55 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        int v56 = *(_DWORD *)(a2 + 32);
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v63 = "nw_http2_transport_stream_close";
        __int16 v64 = 2082;
        char v65 = (void *)(a1 + 205);
        __int16 v66 = 1024;
        int v67 = v56;
        _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s closing stream %d that is already closed",  buf,  0x1Cu);
      }
    }
  }

  uint64_t v4 = (int *)(a2 + 32);
  char v5 = *(_BYTE *)(a2 + 36);
  if (*(_DWORD *)(a2 + 32) != -1)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) == 0)
    {
      if (!gLogDatapath) {
        goto LABEL_27;
      }
      int v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v63 = "nw_http2_transport_stream_close";
        __int16 v64 = 2082;
        char v65 = (void *)(a1 + 205);
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s not sending RST_STREAM, since we are already closed from nghttp2's perspective",  buf,  0x16u);
      }

void nw_http2_transport_session_send(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v28 = "nw_http2_transport_session_send";
      __int16 v29 = 2082;
      *(void *)int v30 = a1 + 205;
      _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if (nghttp2_session_want_write())
  {
    if (gLogDatapath)
    {
      char v2 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 2082;
        *(void *)int v30 = a1 + 205;
        uint64_t v3 = "%{public}s %{public}s nghttp2 wants to write";
LABEL_45:
        _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEBUG, v3, buf, 0x16u);
      }
    }
  }

  else if (gLogDatapath)
  {
    char v2 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v28 = "nw_http2_transport_session_send";
      __int16 v29 = 2082;
      *(void *)int v30 = a1 + 205;
      uint64_t v3 = "%{public}s %{public}s nghttp2 does not want to write";
      goto LABEL_45;
    }
  }

  if ((*(_BYTE *)(a1 + 204) & 0x20) == 0)
  {
    stream_remote_window_size_t size = nghttp2_session_get_stream_remote_window_size();
    else {
      remote_window_size_t size = nghttp2_session_get_stream_remote_window_size();
    }
    int v7 = remote_window_size;
    if (gLogDatapath)
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 2082;
        *(void *)int v30 = a1 + 205;
        *(_WORD *)&v30[8] = 2048;
        *(void *)&v30[10] = v7;
        _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s window size that we can send is %llu bytes",  buf,  0x20u);
      }
    }

    *(_BYTE *)(a1 + 204) |= 0x20u;
    int v8 = nghttp2_session_send();
    if (!v8) {
      goto LABEL_37;
    }
    int v9 = v8;
    char v10 = *(_BYTE *)(a1 + 204);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (os_log_s *)gLogObj;
    if (v9 == -902 && (v10 & 8) != 0)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v28 = "nw_http2_transport_session_send";
        __int16 v29 = 2082;
        *(void *)int v30 = a1 + 205;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s tunnel error, send failed, closing",  buf,  0x16u);
      }

BOOL nw_http2_transport_get_stream_node_from_id(uint64_t a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  int v19 = a2;
  uint64_t v3 = *(void *)(a1 + 120);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v21 = "nw_http2_transport_get_stream_node_from_id";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "nw_http2_transport_get_stream_node_from_id";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_id";
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v21 = "nw_http2_transport_get_stream_node_from_id";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null http2_transport->http2_transport_streams_id, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (!v16)
      {
LABEL_25:
        if (v11) {
          free(v11);
        }
        return 0LL;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "nw_http2_transport_get_stream_node_from_id";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_id, no backtrace";
    }

    else
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "nw_http2_transport_get_stream_node_from_id";
      os_log_type_t v14 = "%{public}s called with null http2_transport->http2_transport_streams_id, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_25;
  }

  if (a2 <= 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v21 = "nw_http2_transport_get_stream_node_from_id";
      __int16 v22 = 2082;
      uint64_t v23 = (char *)(a1 + 205);
      __int16 v24 = 1024;
      int v25 = a2;
      int v7 = "%{public}s %{public}s requested stream id (%d) is not valid, returning NULL hash node";
      int v8 = (os_log_s *)v10;
      os_log_type_t v9 = OS_LOG_TYPE_ERROR;
      goto LABEL_8;
    }
  }

  else
  {
    BOOL result = nw_hash_table_get_node(v3, (uint64_t)&v19, 4LL);
    if (result) {
      return result;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v21 = "nw_http2_transport_get_stream_node_from_id";
      __int16 v22 = 2082;
      uint64_t v23 = (char *)(a1 + 205);
      __int16 v24 = 1024;
      int v25 = v19;
      int v7 = "%{public}s %{public}s requested stream id (%d) not found, returning NULL";
      int v8 = (os_log_s *)v6;
      os_log_type_t v9 = OS_LOG_TYPE_DEBUG;
LABEL_8:
      _os_log_impl(&dword_181A5C000, v8, v9, v7, buf, 0x1Cu);
    }
  }

  return 0LL;
}

uint64_t ___ZL35nw_http2_transport_connection_closeP27nw_protocol_http2_transport_block_invoke( uint64_t a1, uint64_t a2)
{
  void v32[2] = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v5 = object;
    uint64_t v6 = *(void *)nw_hash_node_get_extra(a2);
    int v7 = *(_DWORD *)(v5 + 32);
    if (gLogDatapath)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v21 = *(void *)(a1 + 32);
        __int16 v22 = (const char *)(v21 + 205);
        BOOL v10 = v21 == 0;
        int v23 = *(_DWORD *)(v5 + 32);
        if (v10) {
          __int16 v22 = "";
        }
        int v27 = 136446722;
        os_log_type_t v28 = "nw_http2_transport_connection_close_block_invoke";
        __int16 v29 = 2082;
        int v30 = v22;
        __int16 v31 = 1024;
        LODWORD(v32[0]) = v23;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s closing stream %d",  (uint8_t *)&v27,  0x1Cu);
      }
    }

    nw_http2_transport_stream_close(*(void *)(a1 + 32), v5);
    if (v6)
    {
      if (gLogDatapath)
      {
        int v8 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v9 = *(void *)(a1 + 32);
          BOOL v10 = v9 == 0;
          int v27 = 136446978;
          uint64_t v11 = (const char *)(v9 + 205);
          os_log_type_t v28 = "nw_http2_transport_connection_close_block_invoke";
          if (v10) {
            uint64_t v11 = "";
          }
          __int16 v29 = 2082;
          int v30 = v11;
          __int16 v31 = 1024;
          LODWORD(v32[0]) = v7;
          WORD2(v32[0]) = 2048;
          *(void *)((char *)v32 + 6) = v5;
          uint64_t v12 = "%{public}s %{public}s deferring release of stream %d (%p), has associated input handler";
          os_log_type_t v13 = v8;
          os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
          uint32_t v15 = 38;
          goto LABEL_14;
        }
      }
    }

    else
    {
      if (gLogDatapath)
      {
        __int16 v24 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v25 = *(void *)(a1 + 32);
          BOOL v10 = v25 == 0;
          int v27 = 136446978;
          uint64_t v26 = (const char *)(v25 + 205);
          os_log_type_t v28 = "nw_http2_transport_connection_close_block_invoke";
          if (v10) {
            uint64_t v26 = "";
          }
          __int16 v29 = 2082;
          int v30 = v26;
          __int16 v31 = 1024;
          LODWORD(v32[0]) = v7;
          WORD2(v32[0]) = 2048;
          *(void *)((char *)v32 + 6) = v5;
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s destroying stream %d (%p) immediately, no associated input handler",  (uint8_t *)&v27,  0x26u);
        }
      }

      nw_http2_transport_release_frame_array((nw_frame_array_s *)v5);
      nw_http2_transport_release_frame_array((nw_frame_array_s *)(v5 + 16));
      free((void *)v5);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v16 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = *(void *)(a1 + 32);
      int v27 = 136446722;
      os_log_type_t v28 = "nw_http2_transport_connection_close_block_invoke";
      if (v17) {
        int v18 = (const char *)(v17 + 205);
      }
      else {
        int v18 = "";
      }
      __int16 v29 = 2082;
      int v30 = v18;
      __int16 v31 = 2048;
      v32[0] = a2;
      uint64_t v12 = "%{public}s %{public}s stream in node %p in id table is NULL, skipping rst stream";
      os_log_type_t v13 = (os_log_s *)v16;
      os_log_type_t v14 = OS_LOG_TYPE_ERROR;
      uint32_t v15 = 32;
LABEL_14:
      _os_log_impl(&dword_181A5C000, v13, v14, v12, (uint8_t *)&v27, v15);
    }
  }

  return 1LL;
}

uint64_t ___ZL35nw_http2_transport_connection_closeP27nw_protocol_http2_transport_block_invoke_18( uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    nw_http2_transport_protocol_close(*(void *)(a1 + 32), object);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      int v9 = 136446722;
      BOOL v10 = "nw_http2_transport_connection_close_block_invoke";
      if (v6) {
        int v7 = (const char *)(v6 + 205);
      }
      else {
        int v7 = "";
      }
      __int16 v11 = 2082;
      uint64_t v12 = v7;
      __int16 v13 = 2048;
      uint64_t v14 = a2;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s input protocol in node %p in protocol table is NULL, skipping",  (uint8_t *)&v9,  0x20u);
    }
  }

  return 1LL;
}

void nw_http2_transport_protocol_close(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    int v7 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      int v8 = "";
      if (a1) {
        int v8 = (const char *)(a1 + 205);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v21 = "nw_http2_transport_protocol_close";
      __int16 v22 = 2082;
      int v23 = (void *)v8;
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v21 = "nw_http2_transport_protocol_close";
    int v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "nw_http2_transport_protocol_close";
      uint64_t v12 = "%{public}s called with null http2_transport";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v21 = "nw_http2_transport_protocol_close";
          __int16 v22 = 2082;
          int v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v9) {
          return;
        }
LABEL_46:
        free(v9);
        return;
      }

      if (!v15) {
        goto LABEL_45;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "nw_http2_transport_protocol_close";
      uint64_t v12 = "%{public}s called with null http2_transport, no backtrace";
    }

    else
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "nw_http2_transport_protocol_close";
      uint64_t v12 = "%{public}s called with null http2_transport, backtrace limit exceeded";
    }

void nw_http2_transport_release_frame_array(nw_frame_array_s *a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    char v2 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      int v7 = 136446210;
      int v8 = "nw_http2_transport_release_frame_array";
      _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v7, 0xCu);
    }
  }

  while (1)
  {
    tqh_first = a1->tqh_first;
    if (!a1->tqh_first) {
      break;
    }
    uint64_t v4 = *((void *)tqh_first + 2);
    uint64_t v5 = (nw_frame **)*((void *)tqh_first + 3);
    if (v4)
    {
      *(void *)(v4 + 24) = v5;
      uint64_t v5 = (nw_frame **)*((void *)tqh_first + 3);
    }

    else
    {
      a1->tqh_last = v5;
    }

    os_log_s *v5 = (nw_frame *)v4;
    *((void *)tqh_first + 2) = 0LL;
    *((void *)tqh_first + 3) = 0LL;
    buffer = (void *)nw_frame_get_buffer((uint64_t)tqh_first, 0LL);
    if (buffer) {
      free(buffer);
    }
    nw_frame_reset((uint64_t)tqh_first, 0LL, 0, 0LL, 0LL);
    os_release(tqh_first);
  }

uint64_t ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v85 = *MEMORY[0x1895F89C0];
  unsigned int v78 = 0;
  uint64_t v4 = (_BYTE *)nw_frame_unclaimed_bytes(a2, &v78);
  uint64_t v6 = v4;
  uint64_t v7 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v7 > 8)
  {
    LODWORD(v_Block_object_dispose(va, 8) = 0;
  }

  else
  {
    if (!v78)
    {
      LODWORD(v_Block_object_dispose(va, 8) = 0;
      goto LABEL_43;
    }

    else {
      size_t v8 = (9 - v7);
    }
    memcpy(v4, (const void *)(*(void *)(a1 + 56) + v7), v8);
    if (gLogDatapath)
    {
      char v60 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v61 = *(void *)(a1 + 64);
        *(_DWORD *)unsigned int buf = 136446722;
        uint32_t v80 = "send_data_callback_block_invoke";
        if (v61) {
          int v62 = (const char *)(v61 + 205);
        }
        else {
          int v62 = "";
        }
        __int16 v81 = 2082;
        BOOL v82 = v62;
        __int16 v83 = 1024;
        LODWORD(v84) = v8;
        _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s wrote %u bytes of frame header",  buf,  0x1Cu);
      }
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v8;
    LODWORD(v7) = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  unint64_t v9 = *(void *)(*(void *)(a1 + 72) + 16LL);
  if (v9)
  {
    if (v7 <= 9)
    {
      v6[v8] = v9 - 1;
      if (gLogDatapath)
      {
        os_log_type_t v63 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v64 = *(void *)(a1 + 64);
          *(_DWORD *)unsigned int buf = 136446722;
          uint32_t v80 = "send_data_callback_block_invoke";
          if (v64) {
            char v65 = (const char *)(v64 + 205);
          }
          else {
            char v65 = "";
          }
          __int16 v81 = 2082;
          BOOL v82 = v65;
          __int16 v83 = 1024;
          LODWORD(v84) = 1;
          _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s wrote %u byte of padding length",  buf,  0x1Cu);
        }
      }

      LODWORD(v_Block_object_dispose(va, 8) = v8 + 1;
      LODWORD(v7) = ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      unint64_t v9 = *(void *)(*(void *)(a1 + 72) + 16LL);
    }

    unsigned int v10 = v78 - v8;
    int v11 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    unsigned int v77 = 0;
    uint64_t v12 = *(void *)(a1 + 80);
    __int16 v13 = (const void *)nw_frame_unclaimed_bytes(*(void *)(a1 + 88), &v77);
    if (v13)
    {
      unsigned int v14 = v12 - v11;
      if (v14 >= v77) {
        size_t v15 = v77;
      }
      else {
        size_t v15 = v14;
      }
      memcpy(&v6[v8], v13, v15);
      if (gLogDatapath)
      {
        uint64_t v69 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v70 = *(void *)(a1 + 64);
          *(_DWORD *)unsigned int buf = 136446722;
          uint32_t v80 = "send_data_callback_block_invoke";
          if (v70) {
            os_log_type_t v71 = (const char *)(v70 + 205);
          }
          else {
            os_log_type_t v71 = "";
          }
          __int16 v81 = 2082;
          BOOL v82 = v71;
          __int16 v83 = 1024;
          LODWORD(v84) = v15;
          _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s wrote %u bytes of body data (padding)",  buf,  0x1Cu);
        }
      }

      nw_frame_claim(*(void *)(a1 + 88), v16, v15, 0);
      LODWORD(v_Block_object_dispose(va, 8) = v15 + v8;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v15;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v15;
      unint64_t v9 = *(void *)(*(void *)(a1 + 72) + 16LL);
LABEL_24:
      if (v9 >= 2)
      {
        unsigned int v17 = v78 - v8;
        if (v78 > v8)
        {
          unsigned int v18 = ~*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) + v9;
          if (v18 >= v17) {
            size_t v19 = v17;
          }
          else {
            size_t v19 = v18;
          }
          bzero(&v6[v8], v19);
          if (gLogDatapath)
          {
            __int16 v66 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v67 = *(void *)(a1 + 64);
              *(_DWORD *)unsigned int buf = 136446722;
              uint32_t v80 = "send_data_callback_block_invoke";
              if (v67) {
                __int16 v68 = (const char *)(v67 + 205);
              }
              else {
                __int16 v68 = "";
              }
              __int16 v81 = 2082;
              BOOL v82 = v68;
              __int16 v83 = 1024;
              LODWORD(v84) = v19;
              _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s wrote %u bytes of padding",  buf,  0x1Cu);
            }
          }

          LODWORD(v_Block_object_dispose(va, 8) = v19 + v8;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v19;
          uint64_t v20 = *(void *)(a1 + 48);
LABEL_41:
          *(_DWORD *)(*(void *)(v20 + 8) + 24LL) += v19;
        }
      }

void http2_transport_cache_output_frame(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    unsigned int v10 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v16 = "http2_transport_cache_output_frame";
      __int16 v17 = 2082;
      uint64_t v18 = a1 + 205;
      __int16 v19 = 2048;
      uint64_t v20 = a2;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s caching output frame %p",  buf,  0x20u);
    }
  }

  if (http2_transport_output_frame_context_reset((uint64_t)a2, 0LL, 0LL))
  {
    int v14 = 0;
    uint64_t buffer = nw_frame_get_buffer((uint64_t)a2, &v14);
    if (gLogDatapath)
    {
      int v11 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136447234;
        uint64_t v16 = "http2_transport_cache_output_frame";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 2048;
        uint64_t v20 = a2;
        __int16 v21 = 2048;
        uint64_t v22 = buffer;
        __int16 v23 = 1024;
        int v24 = v14;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s resetting output frame %p to buffer %p, length %u",  buf,  0x30u);
      }
    }

    nw_frame_reset((uint64_t)a2, buffer, v14, (uint64_t)nw_protocol_http2_transport_frame_output_finalizer, 0LL);
    int v6 = *(_DWORD *)(a1 + 196);
    uint64_t v7 = *(void *)(a1 + 176);
    a2[2] = v7;
    if (v7) {
      size_t v8 = (void *)(v7 + 24);
    }
    else {
      size_t v8 = (void *)(a1 + 184);
    }
    void *v8 = a2 + 2;
    *(void *)(a1 + 176) = a2;
    a2[3] = a1 + 176;
    *(_DWORD *)(a1 + 196) = v6 + 1;
    if (gLogDatapath)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v16 = "http2_transport_cache_output_frame";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 1024;
        LODWORD(v20) = v14;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s reset output frame of length %u, eligible for reuse",  buf,  0x1Cu);
      }
    }

    http2_transport_purge_frame_cache_if_necessary((nw_frame_array_s *)(a1 + 176), (_DWORD *)(a1 + 196), v5);
  }

  else
  {
    if (gLogDatapath)
    {
      __int16 v13 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v16 = "http2_transport_cache_output_frame";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 2048;
        uint64_t v20 = a2;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s ERROR: unable to clear metadata for output frame %p, freeing",  buf,  0x20u);
      }
    }

    unint64_t v9 = (void *)nw_frame_get_buffer((uint64_t)a2, 0LL);
    if (v9) {
      free(v9);
    }
    nw_frame_reset((uint64_t)a2, 0LL, 0, 0LL, 0LL);
    if (a2) {
      os_release(a2);
    }
  }

BOOL http2_transport_output_frame_context_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  metadata = (void *)nw_frame_get_metadata(a1);
  int v6 = metadata;
  if (metadata)
  {
    void *metadata = a2;
    metadata[1] = a3;
    return v6 != 0LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2) {
    uint64_t v7 = (const char *)(a2 + 205);
  }
  else {
    uint64_t v7 = "";
  }
  *(_DWORD *)unsigned int buf = 136446466;
  uint64_t v18 = "http2_transport_output_frame_context_reset";
  __int16 v19 = 2082;
  uint64_t v20 = v7;
  size_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v18 = "http2_transport_output_frame_context_reset";
      __int16 v19 = 2082;
      uint64_t v20 = v7;
      int v11 = "%{public}s %{public}s frame has no metadata";
      goto LABEL_19;
    }

    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v9 = (os_log_s *)gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v18 = "http2_transport_output_frame_context_reset";
      __int16 v19 = 2082;
      uint64_t v20 = v7;
      int v11 = "%{public}s %{public}s frame has no metadata, backtrace limit exceeded";
      goto LABEL_19;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v18 = "http2_transport_output_frame_context_reset";
        __int16 v19 = 2082;
        uint64_t v20 = v7;
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s %{public}s frame has no metadata, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_20;
    }

    if (v13)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v18 = "http2_transport_output_frame_context_reset";
      __int16 v19 = 2082;
      uint64_t v20 = v7;
      int v11 = "%{public}s %{public}s frame has no metadata, no backtrace";
LABEL_19:
      _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0x16u);
    }
  }

void nw_protocol_http2_transport_frame_output_finalizer(nw_frame *a1, int a2, void *a3)
{
  v58[2] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v40 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            __int16 v55 = 2082;
            uint64_t v56 = (nw_frame *)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v40)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          int v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_37;
        }
      }

      else
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          int v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_37;
        }
      }

      goto LABEL_38;
    }

    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_38;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    int v6 = "%{public}s called with null frame";
LABEL_37:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_38;
  }

  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      int v6 = "%{public}s http2_transport output frames should no longer have nonnull context";
      goto LABEL_37;
    }

    if (!v51)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      int v6 = "%{public}s http2_transport output frames should no longer have nonnull context, backtrace limit exceeded";
      goto LABEL_37;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)gLogObj;
    os_log_type_t v5 = type;
    BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v15)
    {
      if (!v16) {
        goto LABEL_38;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      int v6 = "%{public}s http2_transport output frames should no longer have nonnull context, no backtrace";
      goto LABEL_37;
    }

    if (v16)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      __int16 v55 = 2082;
      uint64_t v56 = (nw_frame *)v15;
      __int16 v17 = "%{public}s http2_transport output frames should no longer have nonnull context, dumping backtrace:%{public}s";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v4, v5, v17, buf, 0x16u);
      goto LABEL_17;
    }

    goto LABEL_17;
  }

  if (gLogDatapath)
  {
    int v41 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446978;
      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      __int16 v55 = 2048;
      uint64_t v56 = a1;
      __int16 v57 = 1024;
      LODWORD(v58[0]) = a2;
      WORD2(v58[0]) = 2048;
      *(void *)((char *)v58 + 6) = 0LL;
      _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s called with frame %p success %d context %p",  buf,  0x26u);
    }
  }

  __int16 v9 = *((_WORD *)a1 + 102);
  os_log_type_t v10 = (uint64_t *)((char *)a1 + 208);
  if ((v9 & 4) != 0)
  {
    uint64_t v11 = *v10;
    if (*v10)
    {
      uint64_t v12 = *((void *)a1 + 2);
      BOOL v13 = (void *)*((void *)a1 + 3);
      int v14 = (void *)((char *)a1 + 16);
      if (v12)
      {
        *(void *)(v12 + 24) = v13;
        BOOL v13 = (void *)*((void *)a1 + 3);
      }

      else
      {
        *(void *)(v11 + 136) = v13;
      }

      *BOOL v13 = v12;
      void *v14 = 0LL;
      *((void *)a1 + 3) = 0LL;
      if (!a2)
      {
        if (gLogDatapath)
        {
          uint64_t v23 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            __int16 v55 = 2082;
            uint64_t v56 = (nw_frame *)(v11 + 205);
            _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s disposing of output frame, finalizer called with success == false",  buf,  0x16u);
          }
        }

        goto LABEL_89;
      }

      uint64_t v18 = *((void *)a1 + 27);
      if (v18)
      {
        uint64_t v19 = *(void *)(v18 + 56);
        if (v19)
        {
          uint64_t v20 = *(void *)(v19 + 32);
          if (v20)
          {
            if ((*(_BYTE *)(v20 + 36) & 1) != 0 || *(int *)(v20 + 32) < 1)
            {
              if (*(void *)(v20 + 16))
              {
                if (gLogDatapath)
                {
                  uint64_t v44 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)unsigned int buf = 136446466;
                    uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
                    __int16 v55 = 2082;
                    uint64_t v56 = (nw_frame *)(v11 + 205);
                    _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s stream already has pending data, simply pending for future send",  buf,  0x16u);
                  }

                  int v45 = gLogDatapath;
                  *((void *)a1 + 2) = 0LL;
                  BOOL v46 = *(void **)(v20 + 24);
                  *((void *)a1 + 3) = v46;
                  *BOOL v46 = a1;
                  *(void *)(v20 + 24) = v14;
                  if (v45)
                  {
                    uint64_t v47 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)unsigned int buf = 0;
                      nw_frame_array_get_frame_count((uint64_t *)(v20 + 16), 0, buf);
                      int v48 = *(_DWORD *)buf;
                      *(_DWORD *)unsigned int buf = 136446722;
                      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
                      __int16 v55 = 2082;
                      uint64_t v56 = (nw_frame *)(v11 + 205);
                      __int16 v57 = 1024;
                      LODWORD(v58[0]) = v48;
                      _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s stream now has %u bytes pending",  buf,  0x1Cu);
                    }
                  }
                }

                else
                {
                  *((void *)a1 + 2) = 0LL;
                  uint64_t v32 = *(void **)(v20 + 24);
                  *((void *)a1 + 3) = v32;
                  *uint64_t v32 = a1;
                  *(void *)(v20 + 24) = v14;
                }
              }

              else
              {
                if (!nw_http2_transport_submit_data(v11, (uint64_t)a1))
                {
                  *((void *)a1 + 2) = 0LL;
                  os_log_type_t v38 = *(void **)(v20 + 24);
                  *((void *)a1 + 3) = v38;
                  *os_log_type_t v38 = a1;
                  *(void *)(v20 + 24) = v14;
                  if (gLogDatapath)
                  {
                    BOOL v49 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)unsigned int buf = 0;
                      nw_frame_array_get_frame_count((uint64_t *)(v20 + 16), 0, buf);
                      int v50 = *(_DWORD *)buf;
                      *(_DWORD *)unsigned int buf = 136446722;
                      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
                      __int16 v55 = 2082;
                      uint64_t v56 = (nw_frame *)(v11 + 205);
                      __int16 v57 = 1024;
                      LODWORD(v58[0]) = v50;
                      _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s stream now has %u bytes pending",  buf,  0x1Cu);
                    }
                  }
                }

                nw_http2_transport_session_send(v11);
              }

              return;
            }

            __int16 v21 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)unsigned int buf = 136446466;
              uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              __int16 v55 = 2082;
              uint64_t v56 = (nw_frame *)(v11 + 205);
              _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Cannot send data on a stream that is not open but has a greater than zero stream id",  buf,  0x16u);
            }

            uint64_t buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0LL);
            if (!buffer)
            {
LABEL_94:
              nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
              os_release(a1);
              return;
            }

void http2_transport_purge_frame_cache_if_necessary(nw_frame_array_s *a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    char v91 = "http2_transport_purge_frame_cache_if_necessary";
    unsigned int v77 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v78 = (os_log_s *)__nwlog_obj();
      os_log_type_t v79 = type;
      if (!os_log_type_enabled(v78, type)) {
        goto LABEL_140;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      uint32_t v80 = "%{public}s called with null frame_cache";
      goto LABEL_139;
    }

    if (!v88)
    {
      unsigned int v78 = (os_log_s *)__nwlog_obj();
      os_log_type_t v79 = type;
      if (!os_log_type_enabled(v78, type)) {
        goto LABEL_140;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      uint32_t v80 = "%{public}s called with null frame_cache, backtrace limit exceeded";
      goto LABEL_139;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v78 = (os_log_s *)__nwlog_obj();
    os_log_type_t v79 = type;
    BOOL v84 = os_log_type_enabled(v78, type);
    if (!backtrace_string)
    {
      if (!v84) {
        goto LABEL_140;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      uint32_t v80 = "%{public}s called with null frame_cache, no backtrace";
      goto LABEL_139;
    }

    if (v84)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      __int16 v92 = 2082;
      *(void *)os_log_type_t v93 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s called with null frame_cache, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_140:
    if (!v77) {
      return;
    }
    goto LABEL_141;
  }

  uint64_t v3 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    char v91 = "http2_transport_purge_frame_cache_if_necessary";
    unsigned int v77 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v78 = (os_log_s *)__nwlog_obj();
      os_log_type_t v79 = type;
      if (!os_log_type_enabled(v78, type)) {
        goto LABEL_140;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      uint32_t v80 = "%{public}s called with null frame_cache_count";
      goto LABEL_139;
    }

    if (!v88)
    {
      unsigned int v78 = (os_log_s *)__nwlog_obj();
      os_log_type_t v79 = type;
      if (!os_log_type_enabled(v78, type)) {
        goto LABEL_140;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      uint32_t v80 = "%{public}s called with null frame_cache_count, backtrace limit exceeded";
      goto LABEL_139;
    }

    uint64_t v85 = (char *)__nw_create_backtrace_string();
    unsigned int v78 = (os_log_s *)__nwlog_obj();
    os_log_type_t v79 = type;
    BOOL v86 = os_log_type_enabled(v78, type);
    if (v85)
    {
      if (v86)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        char v91 = "http2_transport_purge_frame_cache_if_necessary";
        __int16 v92 = 2082;
        *(void *)os_log_type_t v93 = v85;
        _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s called with null frame_cache_count, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v85);
      if (!v77) {
        return;
      }
LABEL_141:
      free(v77);
      return;
    }

    if (v86)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      uint32_t v80 = "%{public}s called with null frame_cache_count, no backtrace";
LABEL_139:
      _os_log_impl(&dword_181A5C000, v78, v79, v80, buf, 0xCu);
      goto LABEL_140;
    }

    goto LABEL_140;
  }

  os_log_type_t v5 = &qword_18C45F000;
  if (gLogDatapath)
  {
    __int16 v81 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
    {
      int v82 = *v3;
      *(_DWORD *)unsigned int buf = 136446466;
      char v91 = "http2_transport_purge_frame_cache_if_necessary";
      __int16 v92 = 1024;
      *(_DWORD *)os_log_type_t v93 = v82;
      _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_DEBUG,  "%{public}s total %u empty frames in cache (initial)",  buf,  0x12u);
    }
  }

  uint32_t v87 = v3;
  if (*v3 >= 0x15u)
  {
    int v6 = &nwlog_legacy_init(void)::init_once;
    uint64_t v7 = &qword_18C45F000;
    size_t v8 = "http2_transport_purge_frame_cache_if_necessary";
    while (1)
    {
      if (*((_BYTE *)v5 + 1537))
      {
        uint64_t v29 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          int v30 = *v3;
          *(_DWORD *)unsigned int buf = 136446722;
          char v91 = v8;
          __int16 v92 = 1024;
          *(_DWORD *)os_log_type_t v93 = v30;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = 20;
          _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s too many frames in frame cache (%u > %u), pruning",  buf,  0x18u);
        }
      }

      uint64_t v9 = **((void **)a1->tqh_last + 1);
      if (!v9)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v55 = *v3;
        *(_DWORD *)unsigned int buf = 136446466;
        char v91 = v8;
        __int16 v92 = 1024;
        *(_DWORD *)os_log_type_t v93 = v55;
        uint64_t v56 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v88 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v57 = (os_log_s *)v7[131];
          os_log_type_t v58 = type;
          if (os_log_type_enabled(v57, type))
          {
            int v59 = *v3;
            *(_DWORD *)unsigned int buf = 136446466;
            char v91 = v8;
            __int16 v92 = 1024;
            *(_DWORD *)os_log_type_t v93 = v59;
            char v60 = "%{public}s no more frames in frame cache, we thought we had %u frames";
            goto LABEL_99;
          }

          goto LABEL_100;
        }

        if (v88)
        {
          uint64_t v67 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v57 = (os_log_s *)v7[131];
          os_log_type_t v58 = type;
          BOOL v68 = os_log_type_enabled(v57, type);
          if (v67)
          {
            if (v68)
            {
              int v69 = *v3;
              *(_DWORD *)unsigned int buf = 136446722;
              char v91 = v8;
              __int16 v92 = 1024;
              *(_DWORD *)os_log_type_t v93 = v69;
              *(_WORD *)&v93[4] = 2082;
              *(void *)&v93[6] = v67;
              _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s no more frames in frame cache, we thought we had %u frames, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v67);
            goto LABEL_100;
          }

          if (!v68)
          {
LABEL_100:
            if (v56) {
              free(v56);
            }
            _DWORD *v3 = 0;
            return;
          }

          int v75 = *v3;
          *(_DWORD *)unsigned int buf = 136446466;
          char v91 = v8;
          __int16 v92 = 1024;
          *(_DWORD *)os_log_type_t v93 = v75;
          char v60 = "%{public}s no more frames in frame cache, we thought we had %u frames, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v57 = (os_log_s *)v7[131];
          os_log_type_t v58 = type;
          if (!os_log_type_enabled(v57, type)) {
            goto LABEL_100;
          }
          int v73 = *v3;
          *(_DWORD *)unsigned int buf = 136446466;
          char v91 = v8;
          __int16 v92 = 1024;
          *(_DWORD *)os_log_type_t v93 = v73;
          char v60 = "%{public}s no more frames in frame cache, we thought we had %u frames, backtrace limit exceeded";
        }

BOOL nw_http2_transport_submit_data(uint64_t a1, uint64_t a2)
{
  void v52[2] = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v48 = "__nw_frame_get_metadata";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "__nw_frame_get_metadata";
      BOOL v35 = "%{public}s called with null frame";
    }

    else if (v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      BOOL v37 = os_log_type_enabled(v33, type);
      if (backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v48 = "__nw_frame_get_metadata";
          __int16 v49 = 2082;
          uint64_t v50 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_94;
      }

      if (!v37)
      {
LABEL_94:
        if (v32) {
          free(v32);
        }
        goto LABEL_3;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "__nw_frame_get_metadata";
      BOOL v35 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      int v33 = (os_log_s *)__nwlog_obj();
      os_log_type_t v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "__nw_frame_get_metadata";
      BOOL v35 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0xCu);
    goto LABEL_94;
  }

  if ((*(_WORD *)(a2 + 204) & 4) == 0)
  {
LABEL_3:
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v48 = "nw_http2_transport_submit_data";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null output_context";
      goto LABEL_39;
    }

    if (!v45)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null output_context, backtrace limit exceeded";
      goto LABEL_39;
    }

    __int16 v17 = (char *)__nw_create_backtrace_string();
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v18 = os_log_type_enabled(v4, type);
    if (!v17)
    {
      if (!v18) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null output_context, no backtrace";
      goto LABEL_39;
    }

    if (!v18)
    {
LABEL_23:
      free(v17);
      goto LABEL_46;
    }

    *(_DWORD *)unsigned int buf = 136446466;
    os_log_type_t v48 = "nw_http2_transport_submit_data";
    __int16 v49 = 2082;
    uint64_t v50 = (uint64_t)v17;
    uint64_t v19 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
LABEL_22:
    _os_log_impl(&dword_181A5C000, v4, v5, v19, buf, 0x16u);
    goto LABEL_23;
  }

  uint64_t v7 = *(void *)(a2 + 216);
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v48 = "nw_http2_transport_submit_data";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null input_protocol";
    }

    else if (v45)
    {
      __int16 v17 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v40 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v40) {
          goto LABEL_23;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = (uint64_t)v17;
        uint64_t v19 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_22;
      }

      if (!v40) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null input_protocol, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    }

    goto LABEL_39;
  }

  uint64_t v8 = *(void *)(v7 + 56);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v48 = "nw_http2_transport_submit_data";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null node";
    }

    else if (v45)
    {
      __int16 v17 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v41 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v41) {
          goto LABEL_23;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = (uint64_t)v17;
        uint64_t v19 = "%{public}s called with null node, dumping backtrace:%{public}s";
        goto LABEL_22;
      }

      if (!v41) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null node, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null node, backtrace limit exceeded";
    }

    goto LABEL_39;
  }

  uint64_t v9 = *(void *)(v8 + 32);
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v48 = "nw_http2_transport_submit_data";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null stream";
    }

    else if (v45)
    {
      __int16 v17 = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v42 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v42) {
          goto LABEL_23;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v48 = "nw_http2_transport_submit_data";
        __int16 v49 = 2082;
        uint64_t v50 = (uint64_t)v17;
        uint64_t v19 = "%{public}s called with null stream, dumping backtrace:%{public}s";
        goto LABEL_22;
      }

      if (!v42) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null stream, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v48 = "nw_http2_transport_submit_data";
      int v6 = "%{public}s called with null stream, backtrace limit exceeded";
    }

uint64_t data_source_read_callback( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, _DWORD *a5, void *a6, uint64_t a7)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (a7)
  {
    if (gLogDatapath)
    {
      uint64_t v23 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v30 = "data_source_read_callback";
        __int16 v31 = 2082;
        uint64_t v32 = (char *)(a7 + 205);
        _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }

    int v11 = (_DWORD *)*a6;
    if (*a6)
    {
      int v12 = v11[13];
      if (v12) {
        unsigned int v13 = v12 - (v11[14] + v11[15]);
      }
      else {
        unsigned int v13 = 0;
      }
      if (v13 >= a4) {
        unsigned int v16 = a4;
      }
      else {
        unsigned int v16 = v13;
      }
      if (v16 >= 0x3FF6) {
        uint64_t v15 = 16374LL;
      }
      else {
        uint64_t v15 = v16;
      }
      if ((_DWORD)v15 == v13) {
        int v17 = 7;
      }
      else {
        int v17 = 6;
      }
      *a5 |= v17;
      if (gLogDatapath)
      {
        os_log_type_t v24 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int buf = 136446722;
          uint64_t v30 = "data_source_read_callback";
          __int16 v31 = 2082;
          uint64_t v32 = (char *)(a7 + 205);
          __int16 v33 = 1024;
          int v34 = v15;
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s skipped copying %u bytes in data_source_read_callback",  buf,  0x1Cu);
        }
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v14 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v30 = "data_source_read_callback";
        __int16 v31 = 2082;
        uint64_t v32 = (char *)(a7 + 205);
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s received unexpected NULL frame in data source",  buf,  0x16u);
      }

      uint64_t v15 = 0LL;
      *a5 |= 1u;
    }

    return v15;
  }

  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v30 = "data_source_read_callback";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (__nwlog_fault(v19, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v30 = "data_source_read_callback";
        os_log_type_t v22 = "%{public}s nghttp2 user data is NULL, not http2_transport";
LABEL_38:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v26 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v30 = "data_source_read_callback";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_39;
      }

      if (v26)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v30 = "data_source_read_callback";
        os_log_type_t v22 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
        goto LABEL_38;
      }
    }

    else
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v30 = "data_source_read_callback";
        os_log_type_t v22 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
  }

uint64_t ___ZL13send_callbackP15nghttp2_sessionPKhmiPv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  unsigned int v19 = 0;
  uint64_t v4 = (void *)nw_frame_unclaimed_bytes(a2, &v19);
  uint64_t v5 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  unsigned int v6 = *(_DWORD *)(a1 + 40) - v5;
  if (v6 >= v19) {
    size_t v7 = v19;
  }
  else {
    size_t v7 = v6;
  }
  memcpy(v4, (const void *)(*(void *)(a1 + 48) + v5), v7);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v7;
  nw_frame_claim(a2, v8, v7, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v9, v7, 0);
  uint64_t v11 = *(void *)(a2 + 32);
  int v12 = *(void **)(a2 + 40);
  uint64_t v10 = (void *)(a2 + 32);
  if (v11)
  {
    *(void *)(v11 + 40) = v12;
    int v12 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 64) + 8LL) = v12;
  }

  void *v12 = v11;
  void *v10 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  uint64_t v13 = *(void *)(a1 + 72);
  os_log_type_t v14 = *(uint64_t **)(v13 + 8);
  *(void *)(a2 + 40) = v14;
  uint64_t *v14 = a2;
  *(void *)(v13 + _Block_object_dispose(va, 8) = v10;
  if (gLogDatapath)
  {
    unsigned int v16 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v17 = *(void *)(a1 + 56);
      *(_DWORD *)unsigned int buf = 136446722;
      os_log_type_t v21 = "send_callback_block_invoke";
      if (v17) {
        BOOL v18 = (const char *)(v17 + 205);
      }
      else {
        BOOL v18 = "";
      }
      __int16 v22 = 2082;
      uint64_t v23 = v18;
      __int16 v24 = 1024;
      int v25 = v7;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s copied %u bytes into output frame",  buf,  0x1Cu);
    }
  }

  return 1LL;
}

uint64_t nw_http2_transport_drain_next_frame_for_stream(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v17 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      BOOL v18 = "";
      if (a1) {
        BOOL v18 = (const char *)(a1 + 205);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      int v52 = "nw_http2_transport_drain_next_frame_for_stream";
      __int16 v53 = 2082;
      uint64_t v54 = (void *)v18;
      _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v52 = "nw_http2_transport_drain_next_frame_for_stream";
    unsigned int v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v49)
      {
        uint64_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_89;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v52 = "nw_http2_transport_drain_next_frame_for_stream";
        __int16 v22 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_88;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v28 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (!v28) {
          goto LABEL_89;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        int v52 = "nw_http2_transport_drain_next_frame_for_stream";
        __int16 v22 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_88;
      }

      if (v28)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        int v52 = "nw_http2_transport_drain_next_frame_for_stream";
        __int16 v53 = 2082;
        uint64_t v54 = backtrace_string;
        uint32_t v29 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_55:
        _os_log_impl(&dword_181A5C000, v20, v21, v29, buf, 0x16u);
      }

void nw_http2_transport_send_end_stream(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v31 = "nw_http2_transport_send_end_stream";
      __int16 v32 = 2082;
      uint64_t v33 = a1 + 205;
      _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if ((*(_BYTE *)(a2 + 36) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v31 = "nw_http2_transport_send_end_stream";
      __int16 v32 = 2082;
      uint64_t v33 = a1 + 205;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s ERROR: Cannot send end stream on a closed stream",  buf,  0x16u);
    }

    return;
  }

  if (*(void *)(a2 + 16))
  {
    if (!gLogDatapath) {
      goto LABEL_7;
    }
    int v24 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_7;
    }
    *(_DWORD *)unsigned int buf = 0;
    nw_frame_array_get_frame_count((uint64_t *)(a2 + 16), 0, buf);
    int v25 = *(_DWORD *)buf;
    *(_DWORD *)unsigned int buf = 136446722;
    __int16 v31 = "nw_http2_transport_send_end_stream";
    __int16 v32 = 2082;
    uint64_t v33 = a1 + 205;
    __int16 v34 = 1024;
    LODWORD(v35) = v25;
    BOOL v9 = "%{public}s %{public}s deferring end stream until all pending bytes (%u) are sent";
    int v10 = v24;
    uint32_t v11 = 28;
LABEL_38:
    _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, v9, buf, v11);
LABEL_7:
    *(_BYTE *)(a2 + 36) |= 4u;
    return;
  }

  if (gLogDatapath)
  {
    int v26 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      int v27 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v31 = "nw_http2_transport_send_end_stream";
      __int16 v32 = 2082;
      uint64_t v33 = a1 + 205;
      __int16 v34 = 1024;
      LODWORD(v35) = v27;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s writing end stream on stream %d",  buf,  0x1Cu);
    }
  }

  int v5 = nghttp2_submit_data();
  if ((v5 & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v31 = "nw_http2_transport_send_end_stream";
      __int16 v32 = 2082;
      uint64_t v33 = a1 + 205;
      __int16 v34 = 1024;
      LODWORD(v35) = v7;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s submitted end stream for stream %d",  buf,  0x1Cu);
    }

    *(_BYTE *)(a2 + 36) &= ~4u;
    nw_http2_transport_session_send(a1);
    return;
  }

  if (v5 == -529)
  {
    if (!gLogDatapath) {
      goto LABEL_7;
    }
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_7;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    __int16 v31 = "nw_http2_transport_send_end_stream";
    __int16 v32 = 2082;
    uint64_t v33 = a1 + 205;
    BOOL v9 = "%{public}s %{public}s continuing (or starting) to defer end stream until all pending bytes are sent";
    int v10 = v8;
    uint32_t v11 = 22;
    goto LABEL_38;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v12 = nghttp2_strerror();
  *(_DWORD *)unsigned int buf = 136446466;
  __int16 v31 = "nw_http2_transport_send_end_stream";
  __int16 v32 = 2082;
  uint64_t v33 = v12;
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v13, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)gLogObj;
      os_log_type_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_32;
      }
      uint64_t v16 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v31 = "nw_http2_transport_send_end_stream";
      __int16 v32 = 2082;
      uint64_t v33 = v16;
      uint64_t v17 = "%{public}s nghttp2_submit_data: %{public}s failed";
      goto LABEL_31;
    }

    if (!v28)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_32;
      }
      uint64_t v21 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v31 = "nw_http2_transport_send_end_stream";
      __int16 v32 = 2082;
      uint64_t v33 = v21;
      uint64_t v17 = "%{public}s nghttp2_submit_data: %{public}s failed, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v19 = os_log_type_enabled(v14, type);
    if (backtrace_string)
    {
      if (v19)
      {
        uint64_t v20 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v31 = "nw_http2_transport_send_end_stream";
        __int16 v32 = 2082;
        uint64_t v33 = v20;
        __int16 v34 = 2082;
        uint64_t v35 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s nghttp2_submit_data: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_32;
    }

    if (v19)
    {
      uint64_t v22 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v31 = "nw_http2_transport_send_end_stream";
      __int16 v32 = 2082;
      uint64_t v33 = v22;
      uint64_t v17 = "%{public}s nghttp2_submit_data: %{public}s failed, no backtrace";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v14, v15, v17, buf, 0x16u);
    }
  }

uint64_t nw_http2_transport_empty_frame_data_source_callback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a5)
  {
    *a5 = 1;
    return 0LL;
  }

  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v15 = "nw_http2_transport_empty_frame_data_source_callback";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v15 = "nw_http2_transport_empty_frame_data_source_callback";
      BOOL v9 = "%{public}s called with null data_flags";
      goto LABEL_17;
    }

    if (!v12)
    {
      int v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v15 = "nw_http2_transport_empty_frame_data_source_callback";
      BOOL v9 = "%{public}s called with null data_flags, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v15 = "nw_http2_transport_empty_frame_data_source_callback";
        __int16 v16 = 2082;
        uint64_t v17 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null data_flags, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v11)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v15 = "nw_http2_transport_empty_frame_data_source_callback";
      BOOL v9 = "%{public}s called with null data_flags, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

BOOL http2_transport_create_input_frame(uint64_t a1, uint64_t a2, size_t __size)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v53 = "http2_transport_create_input_frame";
    int v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v51 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type[0];
      if (!os_log_type_enabled(v25, type[0])) {
        goto LABEL_93;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v53 = "http2_transport_create_input_frame";
      int v27 = "%{public}s called with null http2_transport";
LABEL_92:
      _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
      goto LABEL_93;
    }

    if (v51 == OS_LOG_TYPE_DEFAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v53 = "http2_transport_create_input_frame";
        int v27 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_92;
      }

      goto LABEL_93;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = type[0];
    BOOL v32 = os_log_type_enabled(v25, type[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v53 = "http2_transport_create_input_frame";
        int v27 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_92;
      }

      goto LABEL_93;
    }

    if (!v32) {
      goto LABEL_75;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    __int16 v53 = "http2_transport_create_input_frame";
    __int16 v54 = 2082;
    uint64_t v55 = (uint64_t)backtrace_string;
    uint64_t v33 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_74:
    _os_log_impl(&dword_181A5C000, v25, v26, v33, buf, 0x16u);
    goto LABEL_75;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v53 = "http2_transport_create_input_frame";
    int v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v51 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type[0];
      if (!os_log_type_enabled(v25, type[0])) {
        goto LABEL_93;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v53 = "http2_transport_create_input_frame";
      int v27 = "%{public}s called with null stream";
      goto LABEL_92;
    }

    if (v51 == OS_LOG_TYPE_DEFAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v53 = "http2_transport_create_input_frame";
        int v27 = "%{public}s called with null stream, backtrace limit exceeded";
        goto LABEL_92;
      }

      goto LABEL_93;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = type[0];
    BOOL v34 = os_log_type_enabled(v25, type[0]);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v53 = "http2_transport_create_input_frame";
        int v27 = "%{public}s called with null stream, no backtrace";
        goto LABEL_92;
      }

      goto LABEL_93;
    }

    if (!v34) {
      goto LABEL_75;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    __int16 v53 = "http2_transport_create_input_frame";
    __int16 v54 = 2082;
    uint64_t v55 = (uint64_t)backtrace_string;
    uint64_t v33 = "%{public}s called with null stream, dumping backtrace:%{public}s";
    goto LABEL_74;
  }

  unsigned int v4 = __size;
  if (!(_DWORD)__size)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v53 = "http2_transport_create_input_frame";
    int v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v51 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v53 = "http2_transport_create_input_frame";
        int v27 = "%{public}s called with null length";
        goto LABEL_92;
      }

uint64_t ___ZL34http2_transport_create_input_frameP27nw_protocol_http2_transportP22http2_transport_streamj_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v107 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
    {
      unsigned int v4 = 0;
      uint64_t v5 = 0LL;
    }

    else
    {
      unsigned int v4 = *(_DWORD *)(a2 + 48);
      uint64_t v5 = *(void *)(a2 + 112);
    }

    if (gLogDatapath)
    {
      __int16 v83 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v84 = *(void *)(a1 + 40);
        BOOL v85 = v84 == 0;
        *(_DWORD *)unsigned int buf = 136446978;
        BOOL v86 = (const char *)(v84 + 205);
        BOOL v101 = "http2_transport_create_input_frame_block_invoke";
        if (v85) {
          BOOL v86 = "";
        }
        __int16 v102 = 2082;
        nw_endpoint_t v103 = (void *)v86;
        __int16 v104 = 2048;
        *(void *)uint64_t v105 = v5;
        *(_WORD *)&v105[8] = 1024;
        unsigned int v106 = v4;
        _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s existing frame found, buffer %p, length %u",  buf,  0x26u);
      }
    }

    int v6 = *(_DWORD *)(a2 + 52);
    if (v6) {
      v6 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
    }
    if (v6 == v4)
    {
      if (v5 && v4)
      {
        if (http2_transport_candidate_frame_length_is_match(v4, *(_DWORD *)(a1 + 56)))
        {
          uint64_t v8 = *(void *)(a2 + 16);
          uint64_t v9 = *(void **)(a2 + 24);
          if (v8)
          {
            *(void *)(v8 + 24) = v9;
            uint64_t v9 = *(void **)(a2 + 24);
          }

          else
          {
            *(void *)(*(void *)(a1 + 40) + 168LL) = v9;
          }

          void *v9 = v8;
          *(void *)(a2 + 16) = 0LL;
          *(void *)(a2 + 24) = 0LL;
          uint64_t v65 = *(void *)(a1 + 40);
          int v66 = *(_DWORD *)(v65 + 192);
          if (v66)
          {
            *(_DWORD *)(v65 + 192) = v66 - 1;
            goto LABEL_174;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v101 = "http2_transport_create_input_frame_block_invoke";
          uint64_t v67 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v98 = 0;
          if (__nwlog_fault(v67, &type, &v98))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              BOOL v68 = (os_log_s *)__nwlog_obj();
              os_log_type_t v69 = type;
              if (!os_log_type_enabled(v68, type)) {
                goto LABEL_172;
              }
              *(_DWORD *)unsigned int buf = 136446210;
              BOOL v101 = "http2_transport_create_input_frame_block_invoke";
              uint64_t v70 = "%{public}s http2_transport count attempted to decrement below zero";
              goto LABEL_171;
            }

            if (!v98)
            {
              BOOL v68 = (os_log_s *)__nwlog_obj();
              os_log_type_t v69 = type;
              if (!os_log_type_enabled(v68, type)) {
                goto LABEL_172;
              }
              *(_DWORD *)unsigned int buf = 136446210;
              BOOL v101 = "http2_transport_create_input_frame_block_invoke";
              uint64_t v70 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
              goto LABEL_171;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            BOOL v68 = (os_log_s *)__nwlog_obj();
            os_log_type_t v69 = type;
            BOOL v80 = os_log_type_enabled(v68, type);
            if (backtrace_string)
            {
              if (v80)
              {
                *(_DWORD *)unsigned int buf = 136446466;
                BOOL v101 = "http2_transport_create_input_frame_block_invoke";
                __int16 v102 = 2082;
                nw_endpoint_t v103 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
              goto LABEL_172;
            }

            if (v80)
            {
              *(_DWORD *)unsigned int buf = 136446210;
              BOOL v101 = "http2_transport_create_input_frame_block_invoke";
              uint64_t v70 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_171:
              _os_log_impl(&dword_181A5C000, v68, v69, v70, buf, 0xCu);
            }
          }

void nw_protocol_http2_transport_frame_input_finalizer(nw_frame *a1, int a2, void *a3)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v40 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      _os_log_impl(&dword_181A5C000, v40, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    int v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v54)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v42 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v42)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            __int16 v58 = 2082;
            uint64_t v59 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v42)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
          uint64_t v9 = "%{public}s called with null frame, no backtrace";
          goto LABEL_36;
        }
      }

      else
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
          uint64_t v9 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_36;
        }
      }

      goto LABEL_37;
    }

    uint64_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_37;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    uint64_t v9 = "%{public}s called with null frame";
LABEL_36:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_37;
  }

  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    int v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      uint64_t v9 = "%{public}s http2_transport input frames should no longer have nonnull context";
      goto LABEL_36;
    }

    if (!v54)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      uint64_t v9 = "%{public}s http2_transport input frames should no longer have nonnull context, backtrace limit exceeded";
      goto LABEL_36;
    }

    uint64_t v15 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v15)
    {
      if (!v16) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      uint64_t v9 = "%{public}s http2_transport input frames should no longer have nonnull context, no backtrace";
      goto LABEL_36;
    }

    if (v16)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      __int16 v58 = 2082;
      uint64_t v59 = (uint64_t)v15;
      os_log_type_t v17 = "%{public}s http2_transport input frames should no longer have nonnull context, dumping backtrace:%{public}s";
LABEL_18:
      _os_log_impl(&dword_181A5C000, v7, v8, v17, buf, 0x16u);
      goto LABEL_19;
    }

    goto LABEL_19;
  }

  if ((*((_WORD *)a1 + 102) & 4) != 0)
  {
    uint64_t v10 = *((void *)a1 + 26);
    if (v10)
    {
      uint64_t v11 = *((void *)a1 + 27);
      if (v11)
      {
        if (gLogDatapath)
        {
          BOOL v43 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            __int16 v58 = 2082;
            uint64_t v59 = v10 + 205;
            _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s finalizing input frame",  buf,  0x16u);
          }
        }

        uint64_t v12 = *((void *)a1 + 2);
        uint64_t v13 = (void *)*((void *)a1 + 3);
        os_log_type_t v14 = (void *)((char *)a1 + 16);
        if (v12)
        {
          *(void *)(v12 + 24) = v13;
          uint64_t v13 = (void *)*((void *)a1 + 3);
        }

        else
        {
          *(void *)(v10 + 152) = v13;
        }

        *uint64_t v13 = v12;
        void *v14 = 0LL;
        *((void *)a1 + 3) = 0LL;
        if (!a2)
        {
          if (gLogDatapath)
          {
            uint64_t v45 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)unsigned int buf = 136446466;
              uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
              __int16 v58 = 2082;
              uint64_t v59 = v10 + 205;
              _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s disposing of input frame, finalizer called with success == false",  buf,  0x16u);
            }
          }

          if ((*((_WORD *)a1 + 102) & 0x100) == 0
            || !g_channel_check_validity
            || g_channel_check_validity(a1, *((void *)a1 + 11)))
          {
            uint64_t v20 = (void *)*((void *)a1 + 14);
            if (v20) {
              free(v20);
            }
          }

          nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
          os_release(a1);
          return;
        }

        int v18 = *((_DWORD *)a1 + 13);
        if (v18) {
          int v19 = v18 - (*((_DWORD *)a1 + 14) + *((_DWORD *)a1 + 15));
        }
        else {
          int v19 = 0;
        }
        if (!nghttp2_session_consume_stream())
        {
LABEL_57:
          if (gLogDatapath)
          {
            uint64_t v46 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
            {
              int v47 = *(_DWORD *)(v11 + 32);
              *(_DWORD *)unsigned int buf = 136446978;
              uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
              __int16 v58 = 2082;
              uint64_t v59 = v10 + 205;
              __int16 v60 = 1024;
              *(_DWORD *)os_log_type_t v61 = v19;
              *(_WORD *)&v61[4] = 1024;
              *(_DWORD *)&v61[6] = v47;
              _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s consumed %u bytes on stream %d",  buf,  0x22u);
            }

            if (gLogDatapath)
            {
              uint64_t v48 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)unsigned int buf = 136446722;
                uint64_t v57 = "http2_transport_cache_input_frame";
                __int16 v58 = 2082;
                uint64_t v59 = v10 + 205;
                __int16 v60 = 2048;
                *(void *)os_log_type_t v61 = a1;
                _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s caching input frame %p",  buf,  0x20u);
              }
            }
          }

          if ((http2_transport_input_frame_context_reset((uint64_t)a1, 0LL, 0LL) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v38 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)unsigned int buf = 136446722;
              uint64_t v57 = "http2_transport_cache_input_frame";
              __int16 v58 = 2082;
              uint64_t v59 = v10 + 205;
              __int16 v60 = 2048;
              *(void *)os_log_type_t v61 = a1;
              _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s ERROR: unable to clear metadata for input frame %p, freeing",  buf,  0x20u);
            }

            if ((*((_WORD *)a1 + 102) & 0x100) == 0
              || !g_channel_check_validity
              || g_channel_check_validity(a1, *((void *)a1 + 11)))
            {
              BOOL v39 = (void *)*((void *)a1 + 14);
              if (v39) {
                free(v39);
              }
            }

            nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
            os_release(a1);
            goto LABEL_76;
          }

          if ((*((_WORD *)a1 + 102) & 0x100) != 0
            && g_channel_check_validity
            && !g_channel_check_validity(a1, *((void *)a1 + 11)))
          {
            int v32 = 0;
            uint64_t v33 = 0LL;
            if (!gLogDatapath) {
              goto LABEL_63;
            }
          }

          else
          {
            int v32 = *((_DWORD *)a1 + 12);
            uint64_t v33 = *((void *)a1 + 14);
            if (!gLogDatapath)
            {
LABEL_63:
              nw_frame_reset((uint64_t)a1, v33, v32, (uint64_t)nw_protocol_http2_transport_frame_input_finalizer, 0LL);
              int v35 = *(_DWORD *)(v10 + 192);
              uint64_t v36 = *(void *)(v10 + 160);
              *((void *)a1 + 2) = v36;
              if (v36) {
                BOOL v37 = (void *)(v36 + 24);
              }
              else {
                BOOL v37 = (void *)(v10 + 168);
              }
              *BOOL v37 = v14;
              *(void *)(v10 + 160) = a1;
              *((void *)a1 + 3) = v10 + 160;
              *(_DWORD *)(v10 + 192) = v35 + 1;
              if (gLogDatapath)
              {
                os_log_type_t v51 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)unsigned int buf = 136446722;
                  uint64_t v57 = "http2_transport_cache_input_frame";
                  __int16 v58 = 2082;
                  uint64_t v59 = v10 + 205;
                  __int16 v60 = 1024;
                  *(_DWORD *)os_log_type_t v61 = v32;
                  _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s reset input frame of length %u, eligible for reuse",  buf,  0x1Cu);
                }
              }

              http2_transport_purge_frame_cache_if_necessary( (nw_frame_array_s *)(v10 + 160),  (_DWORD *)(v10 + 192),  v34);
LABEL_76:
              nw_http2_transport_session_send(v10);
              return;
            }
          }

          int v52 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)unsigned int buf = 136447234;
            uint64_t v57 = "http2_transport_cache_input_frame";
            __int16 v58 = 2082;
            uint64_t v59 = v10 + 205;
            __int16 v60 = 2048;
            *(void *)os_log_type_t v61 = a1;
            *(_WORD *)&v61[8] = 2048;
            uint64_t v62 = v33;
            __int16 v63 = 1024;
            int v64 = v32;
            _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s resetting input frame %p to buffer %p, length %u",  buf,  0x30u);
          }

          goto LABEL_63;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
        __int16 v58 = 2082;
        uint64_t v59 = v21;
        os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (__nwlog_fault(v22, &type, &v54))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v23 = (os_log_s *)gLogObj;
            os_log_type_t v24 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_55;
            }
            uint64_t v25 = nghttp2_strerror();
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            __int16 v58 = 2082;
            uint64_t v59 = v25;
            os_log_type_t v26 = "%{public}s nghttp2_session_consume_stream: %{public}s failed";
            goto LABEL_54;
          }

          if (!v54)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v23 = (os_log_s *)gLogObj;
            os_log_type_t v24 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_55;
            }
            uint64_t v30 = nghttp2_strerror();
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            __int16 v58 = 2082;
            uint64_t v59 = v30;
            os_log_type_t v26 = "%{public}s nghttp2_session_consume_stream: %{public}s failed, backtrace limit exceeded";
            goto LABEL_54;
          }

          int v53 = v19;
          BOOL v27 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v23 = (os_log_s *)gLogObj;
          os_log_type_t v24 = type;
          BOOL v28 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v27)
          {
            if (v28)
            {
              uint64_t v29 = nghttp2_strerror();
              *(_DWORD *)unsigned int buf = 136446722;
              uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
              __int16 v58 = 2082;
              uint64_t v59 = v29;
              __int16 v60 = 2082;
              *(void *)os_log_type_t v61 = v27;
              _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s nghttp2_session_consume_stream: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v27);
            int v19 = v53;
            goto LABEL_55;
          }

          int v19 = v53;
          if (v28)
          {
            uint64_t v31 = nghttp2_strerror();
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            __int16 v58 = 2082;
            uint64_t v59 = v31;
            os_log_type_t v26 = "%{public}s nghttp2_session_consume_stream: %{public}s failed, no backtrace";
LABEL_54:
            _os_log_impl(&dword_181A5C000, v23, v24, v26, buf, 0x16u);
          }
        }

uint64_t http2_transport_input_frame_context_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v21 = "__nw_frame_get_metadata";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "__nw_frame_get_metadata";
      uint64_t v15 = "%{public}s called with null frame";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v21 = "__nw_frame_get_metadata";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_39;
      }

      if (!v17)
      {
LABEL_39:
        if (v12) {
          free(v12);
        }
        goto LABEL_3;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "__nw_frame_get_metadata";
      uint64_t v15 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v21 = "__nw_frame_get_metadata";
      uint64_t v15 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_39;
  }

  if ((*(_WORD *)(a1 + 204) & 4) != 0)
  {
    *(void *)(a1 + 20_Block_object_dispose(va, 8) = a2;
    *(void *)(a1 + 216) = a3;
    return 1LL;
  }

BOOL http2_transport_candidate_frame_length_is_match(unsigned int a1, unsigned int a2)
{
  *(void *)&void v17[5] = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
      os_log_type_t v8 = "%{public}s called with null length";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
          __int16 v16 = 2082;
          *(void *)BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null length, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (!v11)
      {
LABEL_23:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
      os_log_type_t v8 = "%{public}s called with null length, no backtrace";
    }

    else
    {
      int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
      os_log_type_t v8 = "%{public}s called with null length, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_23;
  }

  if (!gLogDatapath) {
    return 0LL;
  }
  uint64_t v9 = (os_log_s *)__nwlog_obj();
  BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v15 = "http2_transport_candidate_frame_length_is_match";
    __int16 v16 = 1024;
    *(_DWORD *)BOOL v17 = a1;
    void v17[2] = 1024;
    *(_DWORD *)&v17[3] = a2;
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s candidate frame (%u bytes) is too much larger than requested (%u bytes), skipping",  buf,  0x18u);
    return 0LL;
  }

  return result;
}

uint64_t nw_http2_transport_get_protocol_from_stream_id(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a2 <= 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v16 = "nw_http2_transport_get_protocol_from_stream_id";
      __int16 v17 = 2082;
      uint64_t v18 = a1 + 205;
      __int16 v19 = 1024;
      int v20 = a2;
      uint64_t v9 = "%{public}s %{public}s requested stream id (%d) is not valid, returning NULL protocol";
      uint64_t v10 = (os_log_s *)v11;
      os_log_type_t v12 = OS_LOG_TYPE_ERROR;
LABEL_11:
      _os_log_impl(&dword_181A5C000, v10, v12, v9, buf, 0x1Cu);
    }
  }

  else
  {
    uint64_t v14 = 0LL;
    uint64_t stream_from_id = nw_http2_transport_get_stream_from_id(a1, a2, &v14);
    if (stream_from_id)
    {
      uint64_t v5 = stream_from_id;
      uint64_t result = v14;
      if (v14) {
        return result;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        int v8 = *(_DWORD *)(v5 + 32);
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v16 = "nw_http2_transport_get_protocol_from_stream_id";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 1024;
        int v20 = v8;
        uint64_t v9 = "%{public}s %{public}s no input handler attached to stream %d";
        uint64_t v10 = (os_log_s *)v7;
LABEL_10:
        os_log_type_t v12 = OS_LOG_TYPE_INFO;
        goto LABEL_11;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v16 = "nw_http2_transport_get_protocol_from_stream_id";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 1024;
        int v20 = a2;
        uint64_t v9 = "%{public}s %{public}s could not find stream for stream %d";
        uint64_t v10 = (os_log_s *)v13;
        goto LABEL_10;
      }
    }
  }

  return 0LL;
}

void nw_http2_transport_stream_init(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)a1 = 0LL;
    *(void *)(a1 + _Block_object_dispose(va, 8) = a1;
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 24) = a1 + 16;
    *(_DWORD *)(a1 + 32) = -1;
    *(_BYTE *)(a1 + 36) &= 0xF0u;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v10 = "nw_http2_transport_stream_init";
  id v1 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v7 = 0;
  if (__nwlog_fault(v1, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v2 = (os_log_s *)__nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v10 = "nw_http2_transport_stream_init";
      unsigned int v4 = "%{public}s called with null stream";
      goto LABEL_17;
    }

    if (!v7)
    {
      char v2 = (os_log_s *)__nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v10 = "nw_http2_transport_stream_init";
      unsigned int v4 = "%{public}s called with null stream, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v2 = (os_log_s *)__nwlog_obj();
    os_log_type_t v3 = type;
    BOOL v6 = os_log_type_enabled(v2, type);
    if (backtrace_string)
    {
      if (v6)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v10 = "nw_http2_transport_stream_init";
        __int16 v11 = 2082;
        os_log_type_t v12 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s called with null stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v6)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v10 = "nw_http2_transport_stream_init";
      unsigned int v4 = "%{public}s called with null stream, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v2, v3, v4, buf, 0xCu);
    }
  }

uint64_t nw_http2_transport_add_to_id_table(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v40 = "nw_http2_transport_add_to_id_table";
    __int16 v19 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t v38 = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v38 == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = v38;
      if (!os_log_type_enabled(v20, v38)) {
        goto LABEL_42;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_http2_transport_add_to_id_table";
      __int16 v22 = "%{public}s called with null stream";
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = v38;
      BOOL v34 = os_log_type_enabled(v20, v38);
      if (backtrace_string)
      {
        if (!v34) {
          goto LABEL_29;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v40 = "nw_http2_transport_add_to_id_table";
        __int16 v41 = 2082;
        BOOL v42 = backtrace_string;
        uint64_t v25 = "%{public}s called with null stream, dumping backtrace:%{public}s";
        goto LABEL_28;
      }

      if (!v34)
      {
LABEL_42:
        if (v19)
        {
          BOOL v28 = (char *)v19;
          goto LABEL_44;
        }

        return 0LL;
      }

      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_http2_transport_add_to_id_table";
      __int16 v22 = "%{public}s called with null stream, no backtrace";
    }

    else
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = v38;
      if (!os_log_type_enabled(v20, v38)) {
        goto LABEL_42;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v40 = "nw_http2_transport_add_to_id_table";
      __int16 v22 = "%{public}s called with null stream, backtrace limit exceeded";
    }

uint64_t ___ZL25on_begin_headers_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke( uint64_t a1, int a2, void *object)
{
  if (object) {
    unsigned int v4 = os_retain(object);
  }
  else {
    unsigned int v4 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return 0LL;
}

uint64_t ___ZL25on_begin_headers_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2( uint64_t a1, int a2, void *object)
{
  if (object) {
    unsigned int v4 = os_retain(object);
  }
  else {
    unsigned int v4 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return 0LL;
}

uint64_t ___ZL25on_begin_headers_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_3( uint64_t a1, int a2, void *object)
{
  if (object) {
    unsigned int v4 = os_retain(object);
  }
  else {
    unsigned int v4 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return 0LL;
}

BOOL nw_http2_transport_stream_connect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v64 = "nw_http2_transport_stream_connect";
    BOOL v37 = (char *)_os_log_send_and_compose_impl();
    v62[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v37, v62, &type))
    {
      if (v62[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v38 = (os_log_s *)__nwlog_obj();
        os_log_type_t v39 = v62[0];
        if (os_log_type_enabled(v38, v62[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          int v64 = "nw_http2_transport_stream_connect";
          uint64_t v40 = "%{public}s called with null http2_transport";
LABEL_111:
          _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, 0xCu);
        }
      }

      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v38 = (os_log_s *)__nwlog_obj();
        os_log_type_t v39 = v62[0];
        BOOL v52 = os_log_type_enabled(v38, v62[0]);
        if (backtrace_string)
        {
          if (v52)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            int v64 = "nw_http2_transport_stream_connect";
            __int16 v65 = 2082;
            uint64_t v66 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s called with null http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_112;
        }

        if (v52)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          int v64 = "nw_http2_transport_stream_connect";
          uint64_t v40 = "%{public}s called with null http2_transport, no backtrace";
          goto LABEL_111;
        }
      }

      else
      {
        os_log_type_t v38 = (os_log_s *)__nwlog_obj();
        os_log_type_t v39 = v62[0];
        if (os_log_type_enabled(v38, v62[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          int v64 = "nw_http2_transport_stream_connect";
          uint64_t v40 = "%{public}s called with null http2_transport, backtrace limit exceeded";
          goto LABEL_111;
        }
      }
    }

uint64_t stream_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 4;
  return (uint64_t)a1 + 32;
}

uint64_t stream_key_hash(unsigned int *a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a2 == 4) {
    return *a1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446466;
  os_log_type_t v13 = "stream_key_hash";
  __int16 v14 = 1024;
  int v15 = a2;
  unsigned int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        uint64_t v7 = "%{public}s stream_key_hash called with invalid key_length %u";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0x12u);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)unsigned int buf = 136446722;
          os_log_type_t v13 = "stream_key_hash";
          __int16 v14 = 1024;
          int v15 = a2;
          __int16 v16 = 2082;
          os_log_type_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s stream_key_hash called with invalid key_length %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_17;
      }

      if (v9)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        uint64_t v7 = "%{public}s stream_key_hash called with invalid key_length %u, no backtrace";
        goto LABEL_16;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        uint64_t v7 = "%{public}s stream_key_hash called with invalid key_length %u, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }

{
  char *v4;
  os_log_s *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  BOOL v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  char *v17;
  uint64_t v18;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a2 == 4) {
    return *a1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446466;
  os_log_type_t v13 = "stream_key_hash";
  __int16 v14 = 1024;
  int v15 = a2;
  unsigned int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        uint64_t v7 = "%{public}s stream_key_hash called with invalid key_length %u";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0x12u);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)unsigned int buf = 136446722;
          os_log_type_t v13 = "stream_key_hash";
          __int16 v14 = 1024;
          int v15 = a2;
          __int16 v16 = 2082;
          os_log_type_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s stream_key_hash called with invalid key_length %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_17;
      }

      if (v9)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        uint64_t v7 = "%{public}s stream_key_hash called with invalid key_length %u, no backtrace";
        goto LABEL_16;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        uint64_t v7 = "%{public}s stream_key_hash called with invalid key_length %u, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }

BOOL stream_matches_key(_DWORD *a1, _DWORD *a2)
{
  return a1[8] == *a2;
}

void nw_http2_transport_stream_connected(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v45[2] = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v22 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      int v23 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)unsigned int buf = 136446978;
      __int16 v41 = "nw_http2_transport_stream_connected";
      __int16 v42 = 2082;
      __int16 v43 = (const char *)(a1 + 205);
      __int16 v44 = 1024;
      LODWORD(v45[0]) = v23;
      WORD2(v45[0]) = 2048;
      *(void *)((char *)v45 + 6) = a2;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called for stream %d (%p)",  buf,  0x26u);
    }
  }

  *(_BYTE *)(a2 + 36) |= 1u;
  uint64_t v6 = *(void *)(a3 + 24);
  if (v6)
  {
    uint64_t v7 = *(void (**)(uint64_t, uint64_t))(v6 + 40);
    if (v7)
    {
      v7(a3, a1);
      goto LABEL_5;
    }
  }

  __nwlog_obj();
  char v10 = *(const char **)(a3 + 16);
  if (!v10) {
    char v10 = "invalid";
  }
  *(_DWORD *)unsigned int buf = 136446466;
  __int16 v41 = "nw_http2_transport_stream_connected";
  __int16 v42 = 2082;
  __int16 v43 = v10;
  int v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v38 = 0;
  if (__nwlog_fault(v11, &type, &v38))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_57;
      }
      __int16 v14 = *(const char **)(a3 + 16);
      if (!v14) {
        __int16 v14 = "invalid";
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v41 = "nw_http2_transport_stream_connected";
      __int16 v42 = 2082;
      __int16 v43 = v14;
      int v15 = "%{public}s protocol %{public}s has invalid connected callback";
      goto LABEL_56;
    }

    if (!v38)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_57;
      }
      BOOL v34 = *(const char **)(a3 + 16);
      if (!v34) {
        BOOL v34 = "invalid";
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v41 = "nw_http2_transport_stream_connected";
      __int16 v42 = 2082;
      __int16 v43 = v34;
      int v15 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v27 = os_log_type_enabled(v12, type);
    if (backtrace_string)
    {
      if (v27)
      {
        uint64_t v28 = *(const char **)(a3 + 16);
        if (!v28) {
          uint64_t v28 = "invalid";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v41 = "nw_http2_transport_stream_connected";
        __int16 v42 = 2082;
        __int16 v43 = v28;
        __int16 v44 = 2082;
        v45[0] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_57;
    }

    if (v27)
    {
      int v35 = *(const char **)(a3 + 16);
      if (!v35) {
        int v35 = "invalid";
      }
      *(_DWORD *)unsigned int buf = 136446466;
      __int16 v41 = "nw_http2_transport_stream_connected";
      __int16 v42 = 2082;
      __int16 v43 = v35;
      int v15 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_56:
      _os_log_impl(&dword_181A5C000, v12, v13, v15, buf, 0x16u);
    }
  }

uint64_t ___ZL34nw_protocol_http2_transport_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v37 = "nw_protocol_http2_transport_notify_block_invoke";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (__nwlog_fault(v9, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v37 = "nw_protocol_http2_transport_notify_block_invoke";
          __int16 v14 = "%{public}s called with null node";
LABEL_58:
          int v23 = v30;
          os_log_type_t v24 = v31;
          uint32_t v25 = 12;
          goto LABEL_36;
        }
      }

      else if (v34)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v33 = os_log_type_enabled(v30, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            BOOL v37 = "nw_protocol_http2_transport_notify_block_invoke";
            __int16 v38 = 2082;
            os_log_type_t v39 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s called with null node, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v33)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v37 = "nw_protocol_http2_transport_notify_block_invoke";
          __int16 v14 = "%{public}s called with null node, no backtrace";
          goto LABEL_58;
        }
      }

      else
      {
        int v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v37 = "nw_protocol_http2_transport_notify_block_invoke";
          __int16 v14 = "%{public}s called with null node, backtrace limit exceeded";
          goto LABEL_58;
        }
      }
    }

uint64_t ___ZL33nw_protocol_http2_transport_errorP11nw_protocolS0_i_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v5 = object;
    uint64_t v6 = *(void *)(object + 24);
    if (v6 && *(void *)(v6 + 56))
    {
      if (gLogDatapath)
      {
        BOOL v29 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v30 = *(void *)(a1 + 32);
          os_log_type_t v31 = (const char *)(v30 + 205);
          BOOL v27 = v30 == 0;
          int v32 = *(_DWORD *)(a1 + 40);
          if (v27) {
            os_log_type_t v31 = "";
          }
          *(_DWORD *)unsigned int buf = 136446978;
          int v36 = "nw_protocol_http2_transport_error_block_invoke";
          __int16 v37 = 2082;
          __int16 v38 = v31;
          __int16 v39 = 1024;
          *(_DWORD *)__int16 v40 = v32;
          *(_WORD *)&void v40[4] = 2048;
          *(void *)&v40[6] = v5;
          _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s passing error %d to input protocol %p",  buf,  0x26u);
        }
      }

      (*(void (**)(uint64_t, void, void))(*(void *)(v5 + 24) + 56LL))( v5,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 40));
    }

    else
    {
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = *(void *)(a1 + 32);
        BOOL v26 = (const char *)(v25 + 205);
        BOOL v27 = v25 == 0;
        int v28 = *(_DWORD *)(a1 + 40);
        if (v27) {
          BOOL v26 = "";
        }
        *(_DWORD *)unsigned int buf = 136446978;
        int v36 = "nw_protocol_http2_transport_error_block_invoke";
        __int16 v37 = 2082;
        __int16 v38 = v26;
        __int16 v39 = 2048;
        *(void *)__int16 v40 = v5;
        *(_WORD *)&v40[8] = 1024;
        *(_DWORD *)&v40[10] = v28;
        _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s callbacks on protocol %p not set, cannot pass error %d",  buf,  0x26u);
      }
    }

    return 1LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    uint64_t v8 = (const char *)(v7 + 205);
  }
  else {
    uint64_t v8 = "";
  }
  *(_DWORD *)unsigned int buf = 136446722;
  int v36 = "nw_protocol_http2_transport_error_block_invoke";
  __int16 v37 = 2082;
  __int16 v38 = v8;
  __int16 v39 = 2048;
  *(void *)__int16 v40 = a2;
  BOOL v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (__nwlog_fault(v9, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_35;
      }
      uint64_t v12 = *(void *)(a1 + 32);
      if (v12) {
        os_log_type_t v13 = (const char *)(v12 + 205);
      }
      else {
        os_log_type_t v13 = "";
      }
      *(_DWORD *)unsigned int buf = 136446722;
      int v36 = "nw_protocol_http2_transport_error_block_invoke";
      __int16 v37 = 2082;
      __int16 v38 = v13;
      __int16 v39 = 2048;
      *(void *)__int16 v40 = a2;
      __int16 v14 = "%{public}s %{public}s node %p did not contain protocol";
      goto LABEL_34;
    }

    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_35;
      }
      uint64_t v19 = *(void *)(a1 + 32);
      if (v19) {
        int v20 = (const char *)(v19 + 205);
      }
      else {
        int v20 = "";
      }
      *(_DWORD *)unsigned int buf = 136446722;
      int v36 = "nw_protocol_http2_transport_error_block_invoke";
      __int16 v37 = 2082;
      __int16 v38 = v20;
      __int16 v39 = 2048;
      *(void *)__int16 v40 = a2;
      __int16 v14 = "%{public}s %{public}s node %p did not contain protocol, backtrace limit exceeded";
      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v10 = (os_log_s *)gLogObj;
    os_log_type_t v11 = type;
    BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v16)
      {
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          uint64_t v18 = (const char *)(v17 + 205);
        }
        else {
          uint64_t v18 = "";
        }
        *(_DWORD *)unsigned int buf = 136446978;
        int v36 = "nw_protocol_http2_transport_error_block_invoke";
        __int16 v37 = 2082;
        __int16 v38 = v18;
        __int16 v39 = 2048;
        *(void *)__int16 v40 = a2;
        *(_WORD *)&v40[8] = 2082;
        *(void *)&v40[10] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s %{public}s node %p did not contain protocol, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(backtrace_string);
      goto LABEL_35;
    }

    if (v16)
    {
      uint64_t v21 = *(void *)(a1 + 32);
      if (v21) {
        uint64_t v22 = (const char *)(v21 + 205);
      }
      else {
        uint64_t v22 = "";
      }
      *(_DWORD *)unsigned int buf = 136446722;
      int v36 = "nw_protocol_http2_transport_error_block_invoke";
      __int16 v37 = 2082;
      __int16 v38 = v22;
      __int16 v39 = 2048;
      *(void *)__int16 v40 = a2;
      __int16 v14 = "%{public}s %{public}s node %p did not contain protocol, no backtrace";
LABEL_34:
      _os_log_impl(&dword_181A5C000, v10, v11, v14, buf, 0x20u);
    }
  }

void nw_http2_transport_send_settings(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      int v36 = "nw_http2_transport_send_settings";
      __int16 v37 = 2082;
      uint64_t v38 = a1 + 205;
      _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  id v2 = nw_parameters_copy_protocol_value(*(void **)(a1 + 88), a1, "streamReceiveWindow");
  if (v2)
  {
    os_log_type_t v3 = v2;
    int value = xpc_uint64_get_value(v2);
    xpc_release(v3);
  }

  else
  {
    int value = 0xFFFF;
  }

  id v5 = nw_parameters_copy_protocol_value(*(void **)(a1 + 88), a1, "connectionReceiveWindow");
  if (v5)
  {
    uint64_t v6 = v5;
    int v7 = xpc_uint64_get_value(v5);
    xpc_release(v6);
  }

  else
  {
    int v7 = 0xFFFF;
  }

  uint64_t v41 = 0x6400000003LL;
  int v42 = 4;
  int v43 = value;
  if (nghttp2_submit_settings())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = nghttp2_strerror();
    *(_DWORD *)unsigned int buf = 136446466;
    int v36 = "nw_http2_transport_send_settings";
    __int16 v37 = 2082;
    uint64_t v38 = v8;
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      uint64_t v12 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      int v36 = "nw_http2_transport_send_settings";
      __int16 v37 = 2082;
      uint64_t v38 = v12;
      os_log_type_t v13 = "%{public}s nghttp2_submit_settings: %{public}s failed";
    }

    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v15)
        {
          uint64_t v16 = nghttp2_strerror();
          *(_DWORD *)unsigned int buf = 136446722;
          int v36 = "nw_http2_transport_send_settings";
          __int16 v37 = 2082;
          uint64_t v38 = v16;
          __int16 v39 = 2082;
          __int16 v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s nghttp2_submit_settings: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (!v15)
      {
LABEL_23:
        if (v9) {
          free(v9);
        }
        goto LABEL_25;
      }

      uint64_t v18 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      int v36 = "nw_http2_transport_send_settings";
      __int16 v37 = 2082;
      uint64_t v38 = v18;
      os_log_type_t v13 = "%{public}s nghttp2_submit_settings: %{public}s failed, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      uint64_t v17 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      int v36 = "nw_http2_transport_send_settings";
      __int16 v37 = 2082;
      uint64_t v38 = v17;
      os_log_type_t v13 = "%{public}s nghttp2_submit_settings: %{public}s failed, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v10, v11, v13, buf, 0x16u);
    goto LABEL_23;
  }

void nw_protocol_http2_transport_process_input(uint64_t a1)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  id v2 = &qword_18C45F000;
  if (gLogDatapath)
  {
    int v43 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)char v60 = 136446466;
      *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(void *)&v60[14] = a1 + 205;
      _os_log_impl(&dword_181A5C000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", v60, 0x16u);
    }
  }

  uint64_t v3 = MEMORY[0x1895F87A8];
  while (1)
  {
    v53[0] = 0LL;
    v53[1] = v53;
    uint64_t v4 = *(void *)(a1 + 32);
    if (!v4) {
      break;
    }
    uint64_t v5 = *(void *)(v4 + 24);
    if (!v5) {
      break;
    }
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 80);
    if (!v6) {
      break;
    }
    int v7 = v6(v4, a1);
    if (!v7) {
      goto LABEL_56;
    }
    int v8 = v7;
    if (*((_BYTE *)v2 + 1537))
    {
      char v33 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)char v60 = 136446722;
        *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
        *(_WORD *)&v60[12] = 2082;
        *(void *)&v60[14] = a1 + 205;
        *(_WORD *)&v60[22] = 1024;
        LODWORD(v61) = v8;
        _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s received %u frames from output_handler",  v60,  0x1Cu);
      }
    }

    *(void *)char v60 = 0LL;
    *(void *)&v60[8] = v60;
    LODWORD(v61) = 0;
    *(void *)&v60[16] = 0x2000000000LL;
    v47[0] = v3;
    v47[1] = 0x40000000LL;
    uint64_t v48 = ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke;
    BOOL v49 = &unk_189BBCD08;
    int v50 = v60;
    uint64_t v51 = a1;
    uint64_t v9 = v53[0];
    do
    {
      if (!v9) {
        break;
      }
      uint64_t v10 = *(void *)(v9 + 32);
      char v11 = ((uint64_t (*)(void *))v48)(v47);
      uint64_t v9 = v10;
    }

    while ((v11 & 1) != 0);
    if (nghttp2_session_consume_connection())
    {
      uint64_t v12 = v2;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v55 = "nw_protocol_http2_transport_process_input";
      __int16 v56 = 2082;
      uint64_t v57 = v13;
      __int16 v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v46 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = gLogObj;
        os_log_type_t v16 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v17 = nghttp2_strerror();
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v55 = "nw_protocol_http2_transport_process_input";
          __int16 v56 = 2082;
          uint64_t v57 = v17;
          uint64_t v18 = (os_log_s *)v15;
          os_log_type_t v19 = v16;
          int v20 = "%{public}s nghttp2_session_consume_connection: %{public}s failed";
          goto LABEL_25;
        }

        goto LABEL_26;
      }

      if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v22 = (os_log_s *)gLogObj;
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v24)
          {
            uint64_t v25 = nghttp2_strerror();
            *(_DWORD *)unsigned int buf = 136446722;
            uint64_t v55 = "nw_protocol_http2_transport_process_input";
            __int16 v56 = 2082;
            uint64_t v57 = v25;
            __int16 v58 = 2082;
            uint64_t v59 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s nghttp2_session_consume_connection: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (!v24)
        {
LABEL_26:
          if (v14) {
            free(v14);
          }
          id v2 = v12;
          goto LABEL_29;
        }

        uint64_t v29 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v55 = "nw_protocol_http2_transport_process_input";
        __int16 v56 = 2082;
        uint64_t v57 = v29;
        uint64_t v18 = v22;
        os_log_type_t v19 = v23;
        int v20 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v26 = gLogObj;
        os_log_type_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_26;
        }
        uint64_t v28 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v55 = "nw_protocol_http2_transport_process_input";
        __int16 v56 = 2082;
        uint64_t v57 = v28;
        uint64_t v18 = (os_log_s *)v26;
        os_log_type_t v19 = v27;
        int v20 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, backtrace limit exceeded";
      }

uint64_t ___ZL45nw_protocol_http2_transport_process_connectedP27nw_protocol_http2_transport_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)nw_hash_node_get_extra(a2);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12) {
      uint64_t v13 = (const char *)(v12 + 205);
    }
    else {
      uint64_t v13 = "";
    }
    *(_DWORD *)unsigned int buf = 136446722;
    __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
    __int16 v59 = 2082;
    char v60 = v13;
    __int16 v61 = 2048;
    *(void *)uint64_t v62 = a2;
    __int16 v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (__nwlog_fault(v14, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = (os_log_s *)gLogObj;
        os_log_type_t v16 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_59;
        }
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          uint64_t v18 = (const char *)(v17 + 205);
        }
        else {
          uint64_t v18 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
        __int16 v59 = 2082;
        char v60 = v18;
        __int16 v61 = 2048;
        *(void *)uint64_t v62 = a2;
        os_log_type_t v19 = "%{public}s %{public}s protocol hash node %p didn't have stream extra";
        goto LABEL_58;
      }

      if (!v55)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = (os_log_s *)gLogObj;
        os_log_type_t v16 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_59;
        }
        uint64_t v30 = *(void *)(a1 + 32);
        if (v30) {
          uint64_t v31 = (const char *)(v30 + 205);
        }
        else {
          uint64_t v31 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
        __int16 v59 = 2082;
        char v60 = v31;
        __int16 v61 = 2048;
        *(void *)uint64_t v62 = a2;
        os_log_type_t v19 = "%{public}s %{public}s protocol hash node %p didn't have stream extra, backtrace limit exceeded";
        goto LABEL_58;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)gLogObj;
      os_log_type_t v16 = type;
      BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!backtrace_string)
      {
        if (!v21) {
          goto LABEL_59;
        }
        uint64_t v36 = *(void *)(a1 + 32);
        if (v36) {
          __int16 v37 = (const char *)(v36 + 205);
        }
        else {
          __int16 v37 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
        __int16 v59 = 2082;
        char v60 = v37;
        __int16 v61 = 2048;
        *(void *)uint64_t v62 = a2;
        os_log_type_t v19 = "%{public}s %{public}s protocol hash node %p didn't have stream extra, no backtrace";
        goto LABEL_58;
      }

      if (v21)
      {
        uint64_t v22 = *(void *)(a1 + 32);
        if (v22) {
          os_log_type_t v23 = (const char *)(v22 + 205);
        }
        else {
          os_log_type_t v23 = "";
        }
        *(_DWORD *)unsigned int buf = 136446978;
        __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
        __int16 v59 = 2082;
        char v60 = v23;
        __int16 v61 = 2048;
        *(void *)uint64_t v62 = a2;
        *(_WORD *)&os_log_type_t v62[8] = 2082;
        *(void *)&v62[10] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s %{public}s protocol hash node %p didn't have stream extra, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(backtrace_string);
    }

    goto LABEL_59;
  }

  if (gLogDatapath)
  {
    uint64_t v47 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v48 = *(void *)(a1 + 32);
      BOOL v49 = (const char *)(v48 + 205);
      BOOL v28 = v48 == 0;
      int v50 = *(_DWORD *)(v4 + 32);
      if (v28) {
        BOOL v49 = "";
      }
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
      __int16 v59 = 2082;
      char v60 = v49;
      __int16 v61 = 1024;
      *(_DWORD *)uint64_t v62 = v50;
      _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s checking existing stream %d to see if waiting_for_connect",  buf,  0x1Cu);
    }
  }

  if ((*(_BYTE *)(v4 + 36) & 2) == 0) {
    return 1LL;
  }
  if ((*(_BYTE *)(v4 + 36) & 8) != 0 && *(_DWORD *)(v4 + 32) == 1)
  {
    if (gLogDatapath)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        if (v6) {
          int v7 = (const char *)(v6 + 205);
        }
        else {
          int v7 = "";
        }
        *(_DWORD *)unsigned int buf = 136446466;
        __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
        __int16 v59 = 2082;
        char v60 = v7;
        int v8 = "%{public}s %{public}s deferring stream connect for initial responder stream";
        uint64_t v9 = v5;
        os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
        uint32_t v11 = 22;
LABEL_37:
        _os_log_impl(&dword_181A5C000, v9, v10, v8, buf, v11);
        return 1LL;
      }
    }

    return 1LL;
  }

  if (gLogDatapath)
  {
    uint64_t v51 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v52 = *(void *)(a1 + 32);
      int v53 = (const char *)(v52 + 205);
      BOOL v28 = v52 == 0;
      int v54 = *(_DWORD *)(v4 + 32);
      if (v28) {
        int v53 = "";
      }
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
      __int16 v59 = 2082;
      char v60 = v53;
      __int16 v61 = 1024;
      *(_DWORD *)uint64_t v62 = v54;
      _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s calling connect on waiting stream %d",  buf,  0x1Cu);
    }
  }

  uint64_t object = nw_hash_node_get_object(a2);
  if (!object)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v32 = *(void *)(a1 + 32);
    if (v32) {
      char v33 = (const char *)(v32 + 205);
    }
    else {
      char v33 = "";
    }
    *(_DWORD *)unsigned int buf = 136446722;
    __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
    __int16 v59 = 2082;
    char v60 = v33;
    __int16 v61 = 2048;
    *(void *)uint64_t v62 = a2;
    __int16 v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (__nwlog_fault(v14, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = (os_log_s *)gLogObj;
        os_log_type_t v16 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_59;
        }
        uint64_t v34 = *(void *)(a1 + 32);
        if (v34) {
          int v35 = (const char *)(v34 + 205);
        }
        else {
          int v35 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
        __int16 v59 = 2082;
        char v60 = v35;
        __int16 v61 = 2048;
        *(void *)uint64_t v62 = a2;
        os_log_type_t v19 = "%{public}s %{public}s protocol hash node %p didn't have object";
        goto LABEL_58;
      }

      if (v55)
      {
        os_log_type_t v39 = (char *)__nw_create_backtrace_string();
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v40 = os_log_type_enabled(v15, type);
        if (v39)
        {
          if (v40)
          {
            uint64_t v41 = *(void *)(a1 + 32);
            if (v41) {
              BOOL v42 = (const char *)(v41 + 205);
            }
            else {
              BOOL v42 = "";
            }
            *(_DWORD *)unsigned int buf = 136446978;
            __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
            __int16 v59 = 2082;
            char v60 = v42;
            __int16 v61 = 2048;
            *(void *)uint64_t v62 = a2;
            *(_WORD *)&os_log_type_t v62[8] = 2082;
            *(void *)&v62[10] = v39;
            _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s %{public}s protocol hash node %p didn't have object, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v39);
          if (!v14) {
            return 1LL;
          }
LABEL_60:
          free(v14);
          return 1LL;
        }

        if (v40)
        {
          uint64_t v45 = *(void *)(a1 + 32);
          if (v45) {
            char v46 = (const char *)(v45 + 205);
          }
          else {
            char v46 = "";
          }
          *(_DWORD *)unsigned int buf = 136446722;
          __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
          __int16 v59 = 2082;
          char v60 = v46;
          __int16 v61 = 2048;
          *(void *)uint64_t v62 = a2;
          os_log_type_t v19 = "%{public}s %{public}s protocol hash node %p didn't have object, no backtrace";
LABEL_58:
          _os_log_impl(&dword_181A5C000, v15, v16, v19, buf, 0x20u);
        }
      }

      else
      {
        uint64_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          uint64_t v43 = *(void *)(a1 + 32);
          if (v43) {
            uint64_t v44 = (const char *)(v43 + 205);
          }
          else {
            uint64_t v44 = "";
          }
          *(_DWORD *)unsigned int buf = 136446722;
          __int16 v58 = "nw_protocol_http2_transport_process_connected_block_invoke";
          __int16 v59 = 2082;
          char v60 = v44;
          __int16 v61 = 2048;
          *(void *)uint64_t v62 = a2;
          os_log_type_t v19 = "%{public}s %{public}s protocol hash node %p didn't have object, backtrace limit exceeded";
          goto LABEL_58;
        }
      }
    }

uint64_t ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  unsigned int v34 = 0;
  uint64_t v3 = nw_frame_unclaimed_bytes(a2, &v34);
  unsigned int v4 = v34;
  if (v3) {
    BOOL v5 = v34 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  uint64_t v6 = !v5;
  if (v5) {
    return v6;
  }
  uint64_t v7 = v3;
  unsigned int v33 = v6;
  if (!gLogDatapath) {
    goto LABEL_9;
  }
  os_log_type_t v27 = (os_log_s *)__nwlog_obj();
  BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
  unsigned int v4 = v34;
  if (v28)
  {
    uint64_t v29 = *(void *)(a1 + 40);
    uint64_t v30 = (const char *)(v29 + 205);
    BOOL v5 = v29 == 0;
    uint64_t v31 = "";
    if (!v5) {
      uint64_t v31 = v30;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v36 = "nw_protocol_http2_transport_process_input_block_invoke";
    __int16 v37 = 2082;
    uint64_t v38 = v31;
    __int16 v39 = 1024;
    int v40 = v34;
    _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s processing frame of length %u bytes",  buf,  0x1Cu);
    unsigned int v4 = v34;
  }

  if (v4)
  {
LABEL_9:
    unsigned int v8 = 0;
    while (1)
    {
      uint64_t v9 = MEMORY[0x186E10EFC](*(void *)(*(void *)(a1 + 40) + 80LL), v7 + v8, v4 - v8);
      if ((v9 & 0x8000000000000000LL) == 0) {
        goto LABEL_28;
      }
      int v10 = *(_BYTE *)(*(void *)(a1 + 40) + 204LL) & 8;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      if (v9 == -902 && v10 != 0) {
        break;
      }
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = *(void *)(a1 + 40);
        if (v13) {
          __int16 v14 = (const char *)(v13 + 205);
        }
        else {
          __int16 v14 = "";
        }
        uint64_t v15 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446978;
        uint64_t v36 = "nw_protocol_http2_transport_process_input_block_invoke";
        __int16 v37 = 2082;
        uint64_t v38 = v14;
        __int16 v39 = 1024;
        int v40 = v9;
        __int16 v41 = 2082;
        uint64_t v42 = v15;
        os_log_type_t v16 = (os_log_s *)v11;
        os_log_type_t v17 = OS_LOG_TYPE_ERROR;
        uint64_t v18 = "%{public}s %{public}s ERROR: Could not process incoming data: %d (%{public}s)";
LABEL_26:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0x26u);
      }

uint64_t ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke_23( uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)nw_hash_node_get_extra(a2);
  uint64_t object = nw_hash_node_get_object(a2);
  if ((*(_BYTE *)(v4 + 36) & 1) == 0 || !*(void *)v4) {
    return 1LL;
  }
  uint64_t v6 = object;
  if (gLogDatapath)
  {
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = (const char *)(v12 + 205);
      BOOL v14 = v12 == 0;
      int v15 = *(_DWORD *)(v4 + 32);
      if (v14) {
        uint64_t v13 = "";
      }
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      uint64_t v31 = v13;
      __int16 v32 = 1024;
      LODWORD(v33) = v15;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s calling input_available on stream %d",  buf,  0x1Cu);
    }
  }

  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 24);
    if (v7)
    {
      unsigned int v8 = *(void (**)(uint64_t, void))(v7 + 64);
      if (v8)
      {
        v8(v6, *(void *)(a1 + 32));
        return 1LL;
      }
    }

    __nwlog_obj();
    int v10 = *(const char **)(v6 + 16);
    if (!v10) {
      int v10 = "invalid";
    }
  }

  else
  {
    __nwlog_obj();
    int v10 = "invalid";
  }

  *(_DWORD *)unsigned int buf = 136446466;
  uint64_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
  __int16 v30 = 2082;
  uint64_t v31 = v10;
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v16, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_43;
      }
      os_log_type_t v19 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        os_log_type_t v19 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      uint64_t v31 = v19;
      uint64_t v20 = "%{public}s protocol %{public}s has invalid input_available callback";
      goto LABEL_42;
    }

    if (!v26)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_43;
      }
      uint64_t v24 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        uint64_t v24 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      uint64_t v31 = v24;
      uint64_t v20 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v22 = os_log_type_enabled(v17, type);
    if (backtrace_string)
    {
      if (v22)
      {
        os_log_type_t v23 = "invalid";
        if (v6 && *(void *)(v6 + 16)) {
          os_log_type_t v23 = *(const char **)(v6 + 16);
        }
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
        __int16 v30 = 2082;
        uint64_t v31 = v23;
        __int16 v32 = 2082;
        unsigned int v33 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(backtrace_string);
      goto LABEL_43;
    }

    if (v22)
    {
      uint64_t v25 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        uint64_t v25 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      uint64_t v31 = v25;
      uint64_t v20 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v17, v18, v20, buf, 0x16u);
    }
  }

uint64_t ___ZL50nw_protocol_http2_transport_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v3;
  }

  void *v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

uint64_t ___ZL35http2_transport_create_output_frameP27nw_protocol_http2_transportP11nw_protocolj_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v107 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
    {
      unsigned int v4 = 0;
      uint64_t v5 = 0LL;
    }

    else
    {
      unsigned int v4 = *(_DWORD *)(a2 + 48);
      uint64_t v5 = *(void *)(a2 + 112);
    }

    if (gLogDatapath)
    {
      __int16 v83 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v84 = *(void *)(a1 + 40);
        BOOL v85 = v84 == 0;
        *(_DWORD *)unsigned int buf = 136446978;
        BOOL v86 = (const char *)(v84 + 205);
        BOOL v101 = "http2_transport_create_output_frame_block_invoke";
        if (v85) {
          BOOL v86 = "";
        }
        __int16 v102 = 2082;
        nw_endpoint_t v103 = (void *)v86;
        __int16 v104 = 2048;
        *(void *)uint64_t v105 = v5;
        *(_WORD *)&v105[8] = 1024;
        unsigned int v106 = v4;
        _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s existing frame found, buffer %p, length %u",  buf,  0x26u);
      }
    }

    int v6 = *(_DWORD *)(a2 + 52);
    if (v6) {
      v6 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
    }
    if (v6 == v4)
    {
      if (v5 && v4)
      {
        if (http2_transport_candidate_frame_length_is_match(v4, *(_DWORD *)(a1 + 56)))
        {
          uint64_t v8 = *(void *)(a2 + 16);
          uint64_t v9 = *(void **)(a2 + 24);
          if (v8)
          {
            *(void *)(v8 + 24) = v9;
            uint64_t v9 = *(void **)(a2 + 24);
          }

          else
          {
            *(void *)(*(void *)(a1 + 40) + 184LL) = v9;
          }

          void *v9 = v8;
          *(void *)(a2 + 16) = 0LL;
          *(void *)(a2 + 24) = 0LL;
          uint64_t v65 = *(void *)(a1 + 40);
          int v66 = *(_DWORD *)(v65 + 196);
          if (v66)
          {
            *(_DWORD *)(v65 + 196) = v66 - 1;
            goto LABEL_174;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v101 = "http2_transport_create_output_frame_block_invoke";
          __int16 v67 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v98 = 0;
          if (__nwlog_fault(v67, &type, &v98))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              BOOL v68 = (os_log_s *)__nwlog_obj();
              os_log_type_t v69 = type;
              if (!os_log_type_enabled(v68, type)) {
                goto LABEL_172;
              }
              *(_DWORD *)unsigned int buf = 136446210;
              BOOL v101 = "http2_transport_create_output_frame_block_invoke";
              uint64_t v70 = "%{public}s http2_transport count attempted to decrement below zero";
              goto LABEL_171;
            }

            if (!v98)
            {
              BOOL v68 = (os_log_s *)__nwlog_obj();
              os_log_type_t v69 = type;
              if (!os_log_type_enabled(v68, type)) {
                goto LABEL_172;
              }
              *(_DWORD *)unsigned int buf = 136446210;
              BOOL v101 = "http2_transport_create_output_frame_block_invoke";
              uint64_t v70 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
              goto LABEL_171;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            BOOL v68 = (os_log_s *)__nwlog_obj();
            os_log_type_t v69 = type;
            BOOL v80 = os_log_type_enabled(v68, type);
            if (backtrace_string)
            {
              if (v80)
              {
                *(_DWORD *)unsigned int buf = 136446466;
                BOOL v101 = "http2_transport_create_output_frame_block_invoke";
                __int16 v102 = 2082;
                nw_endpoint_t v103 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
              goto LABEL_172;
            }

            if (v80)
            {
              *(_DWORD *)unsigned int buf = 136446210;
              BOOL v101 = "http2_transport_create_output_frame_block_invoke";
              uint64_t v70 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_171:
              _os_log_impl(&dword_181A5C000, v68, v69, v70, buf, 0xCu);
            }
          }

__n128 __Block_byref_object_copy__38026(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  unsigned int v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 1) <= *(_DWORD *)(a1 + 80))
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
    unsigned int v6 = *(_DWORD *)(v5 + 24);
    unsigned int v7 = *(_DWORD *)(a1 + 84);
    size_t v8 = v7 - v6;
    if (v7 > v6)
    {
      unsigned int v9 = v4;
      if (v8 >= v4)
      {
        *(_DWORD *)(v5 + 24) = v6 + v4;
        uint64_t v16 = *(void *)(a2 + 16);
        os_log_type_t v17 = *(void **)(a2 + 24);
        uint64_t v15 = (void *)(a2 + 16);
        if (v16)
        {
          *(void *)(v16 + 24) = v17;
          os_log_type_t v17 = *(void **)(a2 + 24);
        }

        else
        {
          *(void *)(*(void *)(a1 + 64) + 8LL) = v17;
        }

        void *v17 = v16;
        *uint64_t v15 = 0LL;
        *(void *)(a2 + 24) = 0LL;
        uint64_t v22 = *(void *)(*(void *)(a1 + 48) + 8LL);
        uint64_t v23 = *(uint64_t **)(v22 + 48);
        *(void *)(a2 + 24) = v23;
        uint64_t *v23 = a2;
        *(void *)(v22 + 4_Block_object_dispose(va, 8) = v15;
        if (gLogDatapath)
        {
          int v54 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v55 = *(void *)(a1 + 56);
            *(_DWORD *)unsigned int buf = 136446722;
            BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            if (v55) {
              __int16 v56 = (const char *)(v55 + 205);
            }
            else {
              __int16 v56 = "";
            }
            __int16 v65 = 2082;
            int v66 = (void *)v56;
            __int16 v67 = 1024;
            int v68 = v9;
            _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s delivering entire incoming frame (%u bytes)",  buf,  0x1Cu);
          }
        }

        uint64_t v11 = a2;
        goto LABEL_48;
      }

      if (gLogDatapath)
      {
        uint64_t v51 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v52 = *(void *)(a1 + 56);
          *(_DWORD *)unsigned int buf = 136446978;
          BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          if (v52) {
            uint64_t v53 = (const char *)(v52 + 205);
          }
          else {
            uint64_t v53 = "";
          }
          __int16 v65 = 2082;
          int v66 = (void *)v53;
          __int16 v67 = 1024;
          int v68 = v8;
          __int16 v69 = 1024;
          int v70 = v9;
          _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s remaining space %u less than frame length %u",  buf,  0x22u);
        }
      }

      input_BOOL frame = http2_transport_create_input_frame(*(void *)(a1 + 56), *(void *)(a1 + 64), v8);
      if (input_frame)
      {
        uint64_t v11 = input_frame;
        http2_transport_input_frame_context_reset(input_frame, *(void *)(a1 + 56), *(void *)(a1 + 64));
        nw_frame_inherit_metadata(a2, v11, 0);
        if (!*(void *)(v11 + 112)
          || (*(_WORD *)(v11 + 204) & 0x100) != 0
          && g_channel_check_validity
          && !g_channel_check_validity(v11, *(void *)(v11 + 88)))
        {
          int v14 = 0;
          uint64_t v24 = 0LL;
          if (!(_DWORD)v8) {
            goto LABEL_47;
          }
        }

        else
        {
          int v13 = *(_DWORD *)(v11 + 52);
          uint64_t v12 = *(unsigned int *)(v11 + 56);
          if (v13) {
            int v14 = v13 - (v12 + *(_DWORD *)(v11 + 60));
          }
          else {
            int v14 = 0;
          }
          uint64_t v24 = (void *)(*(void *)(v11 + 112) + v12);
          if (v14 == (_DWORD)v8)
          {
LABEL_47:
            BOOL v39 = (const void *)nw_frame_unclaimed_bytes(a2, 0LL);
            memcpy(v24, v39, v8);
            uint64_t v40 = *(void *)(*(void *)(a1 + 48) + 8LL);
            *(void *)(v11 + 16) = 0LL;
            __int16 v41 = *(uint64_t **)(v40 + 48);
            *(void *)(v11 + 24) = v41;
            *__int16 v41 = v11;
            *(void *)(v40 + 4_Block_object_dispose(va, 8) = v11 + 16;
            nw_frame_claim(a2, v42, v8, 0);
            *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v8;
            if (gLogDatapath)
            {
              uint64_t v57 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v58 = *(void *)(a1 + 56);
                if (v58) {
                  __int16 v59 = (const char *)(v58 + 205);
                }
                else {
                  __int16 v59 = "";
                }
                int v60 = nw_frame_unclaimed_length((_DWORD *)a2);
                *(_DWORD *)unsigned int buf = 136447234;
                BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
                __int16 v65 = 2082;
                int v66 = (void *)v59;
                __int16 v67 = 1024;
                int v68 = v8;
                __int16 v69 = 1024;
                int v70 = v9;
                __int16 v71 = 1024;
                LODWORD(v72) = v60;
                _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s delivering partial frame (%u bytes of %u, %u bytes remaining)",  buf,  0x28u);
              }
            }

uint64_t ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_37( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v3;
  }

  void *v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  return 1LL;
}

uint64_t ___ZL38nw_http2_transport_drain_output_framesP27nw_protocol_http2_transport_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  if (!object)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 1LL;
    }
    uint64_t v8 = *(void *)(a1 + 32);
    int v17 = 136446722;
    uint64_t v18 = "nw_http2_transport_drain_output_frames_block_invoke";
    if (v8) {
      unsigned int v9 = (const char *)(v8 + 205);
    }
    else {
      unsigned int v9 = "";
    }
    __int16 v19 = 2082;
    os_log_type_t v20 = v9;
    __int16 v21 = 2048;
    uint64_t v22 = a2;
    uint64_t v10 = "%{public}s %{public}s input protocol in node %p in protocol table is NULL, skipping";
    uint64_t v11 = (os_log_s *)v7;
    os_log_type_t v12 = OS_LOG_TYPE_ERROR;
LABEL_16:
    _os_log_impl(&dword_181A5C000, v11, v12, v10, (uint8_t *)&v17, 0x20u);
    return 1LL;
  }

  uint64_t v5 = object;
  uint64_t v6 = *(void *)nw_hash_node_get_extra(a2);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      return 1LL;
    }
    uint64_t v14 = *(void *)(a1 + 32);
    int v17 = 136446722;
    uint64_t v18 = "nw_http2_transport_drain_output_frames_block_invoke";
    if (v14) {
      uint64_t v15 = (const char *)(v14 + 205);
    }
    else {
      uint64_t v15 = "";
    }
    __int16 v19 = 2082;
    os_log_type_t v20 = v15;
    __int16 v21 = 2048;
    uint64_t v22 = v5;
    uint64_t v10 = "%{public}s %{public}s stream not found for input protocol %p, not draining output frames";
    uint64_t v11 = (os_log_s *)v13;
    os_log_type_t v12 = OS_LOG_TYPE_INFO;
    goto LABEL_16;
  }

  if (nw_http2_transport_drain_next_frame_for_stream(*(void *)(a1 + 32), v5, v6, 1))
  {
    while ((nw_http2_transport_drain_next_frame_for_stream(*(void *)(a1 + 32), v5, v6, 1) & 1) != 0)
      ;
  }

  return 1LL;
}

void nw_http2_transport_copy_stream(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    int v17 = "nw_http2_transport_copy_stream";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v17 = "nw_http2_transport_copy_stream";
      unsigned int v9 = "%{public}s called with null old_stream";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          int v17 = "nw_http2_transport_copy_stream";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null old_stream, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_37:
        if (!v6) {
          return;
        }
LABEL_38:
        free(v6);
        return;
      }

      if (!v11) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v17 = "nw_http2_transport_copy_stream";
      unsigned int v9 = "%{public}s called with null old_stream, no backtrace";
    }

    else
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      int v17 = "nw_http2_transport_copy_stream";
      unsigned int v9 = "%{public}s called with null old_stream, backtrace limit exceeded";
    }

BOOL nw_http2_transport_remove_from_protocol_table(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    uint64_t v16 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
      __int16 v22 = 2082;
      uint64_t v23 = a1 + 205;
      __int16 v24 = 2048;
      uint64_t v25 = a2;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called for input handler %p",  buf,  0x20u);
    }
  }

  uint64_t v4 = *(void *)(a1 + 112);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
    __int16 v22 = 2082;
    uint64_t v23 = a1 + 205;
    __int16 v24 = 2048;
    uint64_t v25 = a2;
    os_log_type_t v8 = "%{public}s %{public}s protocol based table is NULL, cannot remove protocol %p";
LABEL_11:
    _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0x20u);
    return 0LL;
  }

  BOOL node = nw_hash_table_get_node(v4, a2, 16LL);
  if (!node)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
    __int16 v22 = 2082;
    uint64_t v23 = a1 + 205;
    __int16 v24 = 2048;
    uint64_t v25 = a2;
    os_log_type_t v8 = "%{public}s %{public}s protocol %p is not present in id based table, cannot remove";
    goto LABEL_11;
  }

  if (!nw_hash_table_remove_node(*(void *)(a1 + 112), node))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = a1 + 205;
    *(_DWORD *)unsigned int buf = 136446722;
    __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
    __int16 v22 = 2082;
    uint64_t v23 = a1 + 205;
    __int16 v24 = 2048;
    uint64_t v25 = a2;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
      __int16 v22 = 2082;
      uint64_t v23 = v9;
      __int16 v24 = 2048;
      uint64_t v25 = a2;
      BOOL v13 = "%{public}s %{public}s failed to remove protocol node for protocol %p from table";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)unsigned int buf = 136446978;
          __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
          __int16 v22 = 2082;
          uint64_t v23 = v9;
          __int16 v24 = 2048;
          uint64_t v25 = a2;
          __int16 v26 = 2082;
          BOOL v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %{public}s failed to remove protocol node for protocol %p from table, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (!v15)
      {
LABEL_26:
        if (v10) {
          free(v10);
        }
        return 0LL;
      }

      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
      __int16 v22 = 2082;
      uint64_t v23 = v9;
      __int16 v24 = 2048;
      uint64_t v25 = a2;
      BOOL v13 = "%{public}s %{public}s failed to remove protocol node for protocol %p from table, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
      __int16 v22 = 2082;
      uint64_t v23 = v9;
      __int16 v24 = 2048;
      uint64_t v25 = a2;
      BOOL v13 = "%{public}s %{public}s failed to remove protocol node for protocol %p from table, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0x20u);
    goto LABEL_26;
  }

  *(void *)(a2 + 56) = 0LL;
  if (gLogDatapath)
  {
    int v17 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      __int16 v21 = "nw_http2_transport_remove_from_protocol_table";
      __int16 v22 = 2082;
      uint64_t v23 = a1 + 205;
      __int16 v24 = 2048;
      uint64_t v25 = a2;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s removed protocol %p from protocol based table",  buf,  0x20u);
    }
  }

  return 1LL;
}

void ___ZL48nw_protocol_http2_transport_remove_input_handlerP11nw_protocolS0_b_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
    uint64_t v3 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v69 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type[0];
      if (os_log_type_enabled(v30, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_destroy";
        uint64_t v20 = "%{public}s called with null protocol";
LABEL_109:
        BOOL v27 = v30;
        os_log_type_t v28 = v31;
        uint32_t v29 = 12;
        goto LABEL_44;
      }

uint64_t ___ZL48nw_protocol_http2_transport_remove_input_handlerP11nw_protocolS0_b_block_invoke_32( uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t object = nw_hash_node_get_object(a2);
  nw_protocol_set_input_handler(v3, object);
  *(_OWORD *)*(void *)(a1 + 40) = *(_OWORD *)*(void *)(*(void *)(a1 + 32) + 48LL);
  if (gLogDatapath)
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *(void *)(a1 + 40);
      if (v7) {
        os_log_type_t v8 = (const char *)(v7 + 205);
      }
      else {
        os_log_type_t v8 = "";
      }
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 48LL);
      int v10 = 136446722;
      uint64_t v11 = "nw_protocol_http2_transport_remove_input_handler_block_invoke";
      __int16 v12 = 2082;
      uint64_t v13 = v8;
      __int16 v14 = 2048;
      uint64_t v15 = v9;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s reset default input handler to %p",  (uint8_t *)&v10,  0x20u);
    }
  }

  return 0LL;
}

uint64_t ___ZL35nw_protocol_http2_transport_destroyP11nw_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v5 = object;
    if ((*(_BYTE *)(object + 36) & 1) == 0 || *(_DWORD *)(object + 32) == -1)
    {
      if (gLogDatapath)
      {
        BOOL v27 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v28 = *(void *)(a1 + 32);
          if (v28) {
            uint32_t v29 = (const char *)(v28 + 205);
          }
          else {
            uint32_t v29 = "";
          }
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v33 = "nw_protocol_http2_transport_destroy_block_invoke";
          __int16 v34 = 2082;
          uint64_t v35 = v29;
          _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s not closing already closed or invalid stream when destroying",  buf,  0x16u);
        }
      }

      *(_BYTE *)(v5 + 36) &= ~1u;
      *(_DWORD *)(v5 + 32) = -1;
      nw_hash_table_remove_node(*(void *)(*(void *)(a1 + 32) + 120LL), a2);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        os_log_type_t v8 = (const char *)(v7 + 205);
        BOOL v9 = v7 == 0;
        int v10 = *(_DWORD *)(v5 + 32);
        if (v9) {
          os_log_type_t v8 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v33 = "nw_protocol_http2_transport_destroy_block_invoke";
        __int16 v34 = 2082;
        uint64_t v35 = v8;
        __int16 v36 = 1024;
        LODWORD(v37) = v10;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s closing stream %d during destroy, did not have an active input_handler",  buf,  0x1Cu);
      }

      nw_http2_transport_stream_close(*(void *)(a1 + 32), v5);
    }

    nw_http2_transport_release_frame_array((nw_frame_array_s *)v5);
    nw_http2_transport_release_frame_array((nw_frame_array_s *)(v5 + 16));
    goto LABEL_43;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11) {
    __int16 v12 = (const char *)(v11 + 205);
  }
  else {
    __int16 v12 = "";
  }
  *(_DWORD *)unsigned int buf = 136446722;
  uint64_t v33 = "nw_protocol_http2_transport_destroy_block_invoke";
  __int16 v34 = 2082;
  uint64_t v35 = v12;
  __int16 v36 = 2048;
  uint64_t v37 = a2;
  uint64_t v5 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v30 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (os_log_s *)gLogObj;
    os_log_type_t v14 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_42;
    }
    uint64_t v15 = *(void *)(a1 + 32);
    if (v15) {
      uint64_t v16 = (const char *)(v15 + 205);
    }
    else {
      uint64_t v16 = "";
    }
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v33 = "nw_protocol_http2_transport_destroy_block_invoke";
    __int16 v34 = 2082;
    uint64_t v35 = v16;
    __int16 v36 = 2048;
    uint64_t v37 = a2;
    uint64_t v17 = "%{public}s %{public}s hash node %p didn't have a stream as extra";
    goto LABEL_41;
  }

  if (!v30)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (os_log_s *)gLogObj;
    os_log_type_t v14 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_42;
    }
    uint64_t v22 = *(void *)(a1 + 32);
    if (v22) {
      uint64_t v23 = (const char *)(v22 + 205);
    }
    else {
      uint64_t v23 = "";
    }
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v33 = "nw_protocol_http2_transport_destroy_block_invoke";
    __int16 v34 = 2082;
    uint64_t v35 = v23;
    __int16 v36 = 2048;
    uint64_t v37 = a2;
    uint64_t v17 = "%{public}s %{public}s hash node %p didn't have a stream as extra, backtrace limit exceeded";
    goto LABEL_41;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (os_log_s *)gLogObj;
  os_log_type_t v14 = type;
  BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (backtrace_string)
  {
    if (v19)
    {
      uint64_t v20 = *(void *)(a1 + 32);
      if (v20) {
        __int16 v21 = (const char *)(v20 + 205);
      }
      else {
        __int16 v21 = "";
      }
      *(_DWORD *)unsigned int buf = 136446978;
      uint64_t v33 = "nw_protocol_http2_transport_destroy_block_invoke";
      __int16 v34 = 2082;
      uint64_t v35 = v21;
      __int16 v36 = 2048;
      uint64_t v37 = a2;
      __int16 v38 = 2082;
      uint64_t v39 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s %{public}s hash node %p didn't have a stream as extra, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(backtrace_string);
    if (v5) {
      goto LABEL_43;
    }
    return 1LL;
  }

  if (v19)
  {
    uint64_t v24 = *(void *)(a1 + 32);
    if (v24) {
      os_log_type_t v25 = (const char *)(v24 + 205);
    }
    else {
      os_log_type_t v25 = "";
    }
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v33 = "nw_protocol_http2_transport_destroy_block_invoke";
    __int16 v34 = 2082;
    uint64_t v35 = v25;
    __int16 v36 = 2048;
    uint64_t v37 = a2;
    uint64_t v17 = "%{public}s %{public}s hash node %p didn't have a stream as extra, no backtrace";
LABEL_41:
    _os_log_impl(&dword_181A5C000, v13, v14, v17, buf, 0x20u);
  }

uint64_t ___ZL42nw_protocol_http2_transport_input_finishedP11nw_protocolS0__block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  uint64_t object = nw_hash_node_get_object(a2);
  if (!object)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = *(void *)(a1 + 32);
    if (v15) {
      uint64_t v16 = (const char *)(v15 + 205);
    }
    else {
      uint64_t v16 = "";
    }
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
    __int16 v61 = 2082;
    uint64_t v62 = v16;
    __int16 v63 = 2048;
    uint64_t v64 = a2;
    uint64_t v17 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (__nwlog_fault(v17, &type, &v57))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = (os_log_s *)gLogObj;
        os_log_type_t v19 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_56;
        }
        uint64_t v20 = *(void *)(a1 + 32);
        if (v20) {
          __int16 v21 = (const char *)(v20 + 205);
        }
        else {
          __int16 v21 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
        __int16 v61 = 2082;
        uint64_t v62 = v21;
        __int16 v63 = 2048;
        uint64_t v64 = a2;
        uint64_t v22 = "%{public}s %{public}s no object for hash node %p, skipping input_finished";
LABEL_55:
        _os_log_impl(&dword_181A5C000, v18, v19, v22, buf, 0x20u);
        goto LABEL_56;
      }

      if (!v57)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = (os_log_s *)gLogObj;
        os_log_type_t v19 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_56;
        }
        uint64_t v39 = *(void *)(a1 + 32);
        if (v39) {
          uint64_t v40 = (const char *)(v39 + 205);
        }
        else {
          uint64_t v40 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
        __int16 v61 = 2082;
        uint64_t v62 = v40;
        __int16 v63 = 2048;
        uint64_t v64 = a2;
        uint64_t v22 = "%{public}s %{public}s no object for hash node %p, skipping input_finished, backtrace limit exceeded";
        goto LABEL_55;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = (os_log_s *)gLogObj;
      os_log_type_t v19 = type;
      BOOL v36 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!backtrace_string)
      {
        if (!v36) {
          goto LABEL_56;
        }
        uint64_t v41 = *(void *)(a1 + 32);
        if (v41) {
          uint64_t v42 = (const char *)(v41 + 205);
        }
        else {
          uint64_t v42 = "";
        }
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
        __int16 v61 = 2082;
        uint64_t v62 = v42;
        __int16 v63 = 2048;
        uint64_t v64 = a2;
        uint64_t v22 = "%{public}s %{public}s no object for hash node %p, skipping input_finished, no backtrace";
        goto LABEL_55;
      }

      if (v36)
      {
        uint64_t v37 = *(void *)(a1 + 32);
        if (v37) {
          __int16 v38 = (const char *)(v37 + 205);
        }
        else {
          __int16 v38 = "";
        }
        *(_DWORD *)unsigned int buf = 136446978;
        uint64_t v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
        __int16 v61 = 2082;
        uint64_t v62 = v38;
        __int16 v63 = 2048;
        uint64_t v64 = a2;
        __int16 v65 = 2082;
        int v66 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s %{public}s no object for hash node %p, skipping input_finished, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(backtrace_string);
    }

void nw_protocol_http2_transport_parameters_set_stream_receive_window_size(void *a1, uint64_t value)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    xpc_object_t v3 = xpc_uint64_create(value);
    nw_parameters_set_protocol_value(a1, "streamReceiveWindow", v3);
    if (v3) {
      xpc_release(v3);
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v13 = "nw_protocol_http2_transport_parameters_set_stream_receive_window_size";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_stream_receive_window_size";
      uint64_t v7 = "%{public}s called with null protocol_parameters";
      goto LABEL_17;
    }

    if (!v10)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_stream_receive_window_size";
      uint64_t v7 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v13 = "nw_protocol_http2_transport_parameters_set_stream_receive_window_size";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v9)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_stream_receive_window_size";
      uint64_t v7 = "%{public}s called with null protocol_parameters, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

void nw_protocol_http2_transport_parameters_set_connection_receive_window_size(void *a1, uint64_t value)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    xpc_object_t v3 = xpc_uint64_create(value);
    nw_parameters_set_protocol_value(a1, "connectionReceiveWindow", v3);
    if (v3) {
      xpc_release(v3);
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v13 = "nw_protocol_http2_transport_parameters_set_connection_receive_window_size";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_connection_receive_window_size";
      uint64_t v7 = "%{public}s called with null protocol_parameters";
      goto LABEL_17;
    }

    if (!v10)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_connection_receive_window_size";
      uint64_t v7 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v13 = "nw_protocol_http2_transport_parameters_set_connection_receive_window_size";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v9)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_connection_receive_window_size";
      uint64_t v7 = "%{public}s called with null protocol_parameters, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

void nw_protocol_http2_transport_parameters_set_tunnel_teardown_delay(void *a1, uint64_t value)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    xpc_object_t v3 = xpc_uint64_create(value);
    nw_parameters_set_protocol_value(a1, "tunnelTeardownDelay", v3);
    if (v3) {
      xpc_release(v3);
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v13 = "nw_protocol_http2_transport_parameters_set_tunnel_teardown_delay";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_tunnel_teardown_delay";
      uint64_t v7 = "%{public}s called with null protocol_parameters";
      goto LABEL_17;
    }

    if (!v10)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_tunnel_teardown_delay";
      uint64_t v7 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v13 = "nw_protocol_http2_transport_parameters_set_tunnel_teardown_delay";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v9)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v13 = "nw_protocol_http2_transport_parameters_set_tunnel_teardown_delay";
      uint64_t v7 = "%{public}s called with null protocol_parameters, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

void sub_18212E500( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_18212E730( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_config *nw_proxy_config_copy(void *a1)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_proxy_config);
    xpc_object_t v3 = v2;
    if (v2)
    {
      *(_OWORD *)v2->identifier = *(_OWORD *)(v1 + 56);
      *(_OWORD *)v2->fallback_agent_uuid = *(_OWORD *)(v1 + 72);
      objc_storeStrong((id *)&v2->fallback_config, *((id *)v1 + 11));
      objc_storeStrong((id *)&v3->endpoint, *((id *)v1 + 5));
      uint64_t v4 = (OS_nw_array *)*((void *)v1 + 6);
      if (v4)
      {
        BOOL v5 = nw_array_create();
        if ((OS_nw_array *)v5 != v4)
        {
          os_log_type_t v6 = (OS_nw_array *)v5;
          std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v5 + 16,  (void **)&v4[2].super.super.isa->isa,  (void **)&v4[3].super.super.isa->isa,  v4[3].super.super.isa - v4[2].super.super.isa);
          uint64_t v4 = v6;
        }

        resolved_endpoints = v3->resolved_endpoints;
        v3->resolved_endpoints = v4;
      }

      if (*((void *)v1 + 1))
      {
        uint64_t v8 = (OS_nw_dictionary *)nw_dictionary_create();
        stacks = v3->stacks;
        v3->stacks = v8;

        uint64_t v10 = *((void *)v1 + 1);
        v47[0] = MEMORY[0x1895F87A8];
        v47[1] = 3221225472LL;
        void v47[2] = __nw_proxy_config_copy_block_invoke;
        v47[3] = &unk_189BC5058;
        uint64_t v48 = v3;
        nw_dictionary_apply(v10, (uint64_t)v47);
      }

      objc_storeStrong((id *)&v3->proxied_transports, *((id *)v1 + 2));
      objc_storeStrong((id *)&v3->required_protocols, *((id *)v1 + 3));
      objc_storeStrong((id *)&v3->remove_protocols, *((id *)v1 + 4));
      int v11 = *((unsigned __int8 *)v3 + 171);
      *(void *)&v3->unsigned int mode = *((void *)v1 + 19);
      v3->config_epoch = *((_WORD *)v1 + 84);
      int v12 = *((_BYTE *)v3 + 170) & 0xFE | v1[170] & 1;
      *((_BYTE *)v3 + 170) = v12;
      unsigned int v13 = v12 & 0xFFFFFFFD | (2 * ((v1[170] >> 1) & 1));
      *((_BYTE *)v3 + 170) = v13;
      unsigned int v14 = v13 & 0xFFFFFFFB | (4 * ((v1[170] >> 2) & 1));
      *((_BYTE *)v3 + 170) = v14;
      unsigned int v15 = v11 & 0xFFFFFFDF | (32 * ((v1[171] >> 5) & 1));
      *((_BYTE *)v3 + 171) = v15;
      unsigned int v16 = v14 & 0xFFFFFFEF | (16 * ((v1[170] >> 4) & 1));
      *((_BYTE *)v3 + 170) = v16;
      unsigned int v17 = v16 & 0xFFFFFFDF | (32 * ((v1[170] >> 5) & 1));
      *((_BYTE *)v3 + 170) = v17;
      unsigned int v18 = v17 & 0xFFFFFFF7 | (8 * ((v1[170] >> 3) & 1));
      *((_BYTE *)v3 + 170) = v18;
      unsigned int v19 = v18 & 0xFFFFFFBF | (((v1[170] >> 6) & 1) << 6);
      *((_BYTE *)v3 + 170) = v19;
      *((_BYTE *)v3 + 170) = v1[170] & 0x80 | v19 & 0x7F;
      v3->multipath_service = *((_DWORD *)v1 + 40);
      unsigned int v20 = v15 & 0xFFFFFFFD | (2 * ((v1[171] >> 1) & 1));
      *((_BYTE *)v3 + 171) = v20;
      unsigned int v21 = v20 & 0xFFFFFFFE | v1[171] & 1;
      *((_BYTE *)v3 + 171) = v21;
      unsigned int v22 = v21 & 0xFFFFFFFB | (4 * ((v1[171] >> 2) & 1));
      *((_BYTE *)v3 + 171) = v22;
      unsigned int v23 = v22 & 0xFFFFFFF7 | (8 * ((v1[171] >> 3) & 1));
      *((_BYTE *)v3 + 171) = v23;
      *((_BYTE *)v3 + 171) = v23 & 0xEF | v1[171] & 0x10;
      objc_storeStrong((id *)&v3->match_domains, *((id *)v1 + 15));
      objc_storeStrong((id *)&v3->excluded_domains, *((id *)v1 + 16));
      objc_storeStrong((id *)&v3->preferred_domains, *((id *)v1 + 17));
      objc_storeStrong((id *)&v3->alternate_agents, *((id *)v1 + 18));
      objc_storeStrong((id *)&v3->pac_script, *((id *)v1 + 14));
      char v24 = *((_BYTE *)v3 + 171) & 0xBF | (((v1[171] & 0x40) != 0) << 6);
      *((_BYTE *)v3 + 171) = v24;
      *((_BYTE *)v3 + 171) = v1[171] & 0x80 | v24 & 0x7F;
      *((_BYTE *)v3 + 172) = *((_BYTE *)v3 + 172) & 0xFD | v1[172] & 2;
      os_log_type_t v25 = (void *)*((void *)v1 + 13);
      if (v25)
      {
        uint64_t v26 = v25;
        BOOL v27 = (const char *)v26[2];

        password = (const char *)nw_authentication_credential_get_password(*((void **)v1 + 13));
        nw_proxy_config_set_username_and_password((nw_proxy_config_t)v3, v27, password);
      }

      uint32_t v29 = v3;
      goto LABEL_31;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v30 = (id)gLogObj;
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v52 = "nw_proxy_config_copy";
    os_log_type_t v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (__nwlog_fault(v31, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v32 = (os_log_s *)(id)gLogObj;
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v52 = "nw_proxy_config_copy";
          _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s [nw_proxy_config init] failed", buf, 0xCu);
        }
      }

      else if (v49)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v32 = (os_log_s *)(id)gLogObj;
        os_log_type_t v35 = type;
        BOOL v36 = os_log_type_enabled(v32, type);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v52 = "nw_proxy_config_copy";
            __int16 v53 = 2082;
            int v54 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v32,  v35,  "%{public}s [nw_proxy_config init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v31) {
            goto LABEL_31;
          }
          goto LABEL_30;
        }

        if (v36)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v52 = "nw_proxy_config_copy";
          _os_log_impl(&dword_181A5C000, v32, v35, "%{public}s [nw_proxy_config init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v32 = (os_log_s *)(id)gLogObj;
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v52 = "nw_proxy_config_copy";
          _os_log_impl( &dword_181A5C000,  v32,  v37,  "%{public}s [nw_proxy_config init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v31)
    {
LABEL_31:

      goto LABEL_32;
    }

void sub_18212EEE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_proxy_config_copy_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  BOOL v5 = nw_protocol_stack_copy(a3);
  nw_dictionary_set_value(*(void *)(*(void *)(a1 + 32) + 8LL), a2, v5);

  return 1LL;
}

void nw_proxy_config_set_username_and_password( nw_proxy_config_t proxy_config, const char *username, const char *password)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  BOOL v5 = proxy_config;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v25 = "nw_proxy_config_set_username_and_password";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v25 = "nw_proxy_config_set_username_and_password";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v25 = "nw_proxy_config_set_username_and_password";
          __int16 v26 = 2082;
          BOOL v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_40:
        free(v9);
        goto LABEL_5;
      }

      if (v16)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v25 = "nw_proxy_config_set_username_and_password";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v25 = "nw_proxy_config_set_username_and_password";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_18212F438(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_merged(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  xpc_object_t v3 = a1;
  uint64_t v4 = a2;
  id v5 = v4;
  if (v3[38] == 1)
  {
    if (v4[38] == 1)
    {
      os_log_type_t v6 = nw_proxy_config_copy(v3);
      objc_storeStrong((id *)&v6->endpoint, *((id *)v5 + 5));
      char v7 = *((_BYTE *)v6 + 171) & 0x7F;
      *((_BYTE *)v6 + 171) = v7;
      if ((*((_BYTE *)v5 + 170) & 1) != 0)
      {
        *((_BYTE *)v6 + 170) |= 1u;
        if ((*((_BYTE *)v5 + 170) & 2) == 0)
        {
LABEL_5:
          if ((*((_BYTE *)v5 + 171) & 0x20) == 0)
          {
LABEL_7:
            v6->multipath_service = *((_DWORD *)v5 + 40);
            char v8 = v7 & 0xFD | *((_BYTE *)v5 + 171) & 2;
            *((_BYTE *)v6 + 171) = v8;
            char v9 = v8 & 0x7E | *((_BYTE *)v5 + 171) & 1;
            *((_BYTE *)v6 + 171) = v9;
            char v10 = v9 & 0xFB | *((_BYTE *)v5 + 171) & 4;
            *((_BYTE *)v6 + 171) = v10;
            *((_BYTE *)v6 + 171) = v10 & 0xF7 | *((_BYTE *)v5 + 171) & 8;
            uint64_t stacks = (uint64_t)v6->stacks;
            v26[0] = MEMORY[0x1895F87A8];
            v26[1] = 3221225472LL;
            v26[2] = __nw_proxy_config_create_merged_block_invoke;
            v26[3] = &unk_189BC5058;
            id v27 = v5;
            nw_dictionary_apply(stacks, (uint64_t)v26);

            goto LABEL_8;
          }

void sub_18212FA08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_proxy_config_create_merged_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3;
  nw_protocol_options_t v5 = nw_protocol_stack_copy_transport_protocol(v4);
  nw_protocol_options_t v6 = v5;
  if (v5)
  {
    char v7 = v5;
    id v8 = v7[1];
  }

  else
  {
    id v8 = (id)g_tcp_definition;
  }

  int v37 = 0;
  char v9 = (nw_protocol_stack *)nw_proxy_config_copy_protocol_stack(*(void **)(a1 + 32), v8, &v37);
  if (v9)
  {
    uint64_t v31 = 0LL;
    __int16 v32 = &v31;
    uint64_t v33 = 0x3032000000LL;
    uint64_t v34 = __Block_byref_object_copy__38597;
    os_log_type_t v35 = __Block_byref_object_dispose__38598;
    uint64_t v10 = MEMORY[0x1895F87A8];
    id v36 = 0LL;
    iterate_block[0] = MEMORY[0x1895F87A8];
    iterate_block[1] = 3221225472LL;
    iterate_block[2] = __nw_proxy_config_create_merged_block_invoke_20;
    iterate_block[3] = &unk_189BBD000;
    iterate_void block[4] = &v31;
    nw_protocol_stack_iterate_application_protocols(v4, iterate_block);
    v28[0] = 0LL;
    v28[1] = v28;
    v28[2] = 0x3032000000LL;
    v28[3] = __Block_byref_object_copy__38597;
    v28[4] = __Block_byref_object_dispose__38598;
    id v29 = 0LL;
    os_log_type_t v11 = (void *)v32[5];
    if (v11)
    {
      id v12 = v11;
      int v13 = [v12 type];

      if (v13 == 4)
      {
        BOOL v14 = nw_endpoint_copy_host_port_endpoint_for_url((void *)v32[5]);
        os_log_type_t v15 = (void *)v32[5];
        v32[5] = v14;
      }

      if (nw_endpoint_get_type((nw_endpoint_t)v32[5]) == nw_endpoint_type_host)
      {
        hostname = nw_endpoint_get_hostname((nw_endpoint_t)v32[5]);
        size_t v17 = strlen(hostname);
        uint16_t port = nw_endpoint_get_port((nw_endpoint_t)v32[5]);
        v26[0] = v10;
        v26[1] = 3221225472LL;
        v26[2] = __nw_proxy_config_create_merged_block_invoke_2;
        v26[3] = &unk_189BBD050;
        uint16_t v27 = port;
        v26[5] = v17;
        v26[6] = hostname;
        void v26[4] = v28;
        nw_protocol_stack_iterate_application_protocols(v9, v26);
      }
    }

    if (v6 && v37 == 3) {
      nw_protocol_stack_append_application_protocol(v4, v6);
    }
    v23[0] = v10;
    v23[1] = 3221225472LL;
    v23[2] = __nw_proxy_config_create_merged_block_invoke_4;
    v23[3] = &unk_189BBD078;
    os_log_type_t v25 = v28;
    BOOL v19 = v4;
    os_log_type_t v24 = v19;
    nw_protocol_stack_iterate_application_protocols(v9, v23);
    os_log_type_t v20 = v9;
    BOOL v21 = (nw_protocol_options *)v20[3];

    nw_protocol_stack_set_transport_protocol(v19, v21);
    _Block_object_dispose(v28, 8);

    _Block_object_dispose(&v31, 8);
  }

  return 1LL;
}

void sub_18212FCE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, id a28)
{
  _Block_object_dispose((const void *)(v32 - 136), 8);
  _Unwind_Resume(a1);
}

void *nw_proxy_config_copy_protocol_stack(void *a1, void *a2, _DWORD *a3)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  char v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v45 = "nw_proxy_config_copy_protocol_stack";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v45 = "nw_proxy_config_copy_protocol_stack";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null config", buf, 0xCu);
      }

      goto LABEL_82;
    }

    if (!v42)
    {
      __nwlog_obj();
      size_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v45 = "nw_proxy_config_copy_protocol_stack";
        _os_log_impl( &dword_181A5C000,  v17,  v37,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_82;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    size_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v28 = type;
    BOOL v29 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v29)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v45 = "nw_proxy_config_copy_protocol_stack";
        _os_log_impl(&dword_181A5C000, v17, v28, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }

      goto LABEL_82;
    }

    if (v29)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      BOOL v45 = "nw_proxy_config_copy_protocol_stack";
      __int16 v46 = 2082;
      uint64_t v47 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v28,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    BOOL v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v45 = "nw_proxy_config_copy_protocol_stack";
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v20, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v45 = "nw_proxy_config_copy_protocol_stack";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null transport_protocol", buf, 0xCu);
        }
      }

      else if (v42)
      {
        id v30 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v21, type);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            BOOL v45 = "nw_proxy_config_copy_protocol_stack";
            __int16 v46 = 2082;
            uint64_t v47 = v30;
            _os_log_impl( &dword_181A5C000,  v21,  v31,  "%{public}s called with null transport_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v30);
          goto LABEL_71;
        }

        if (v32)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v45 = "nw_proxy_config_copy_protocol_stack";
          _os_log_impl( &dword_181A5C000,  v21,  v31,  "%{public}s called with null transport_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          BOOL v45 = "nw_proxy_config_copy_protocol_stack";
          _os_log_impl( &dword_181A5C000,  v21,  v38,  "%{public}s called with null transport_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1821306EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__38597(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__38598(uint64_t a1)
{
}

void __nw_proxy_config_create_merged_block_invoke_20(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v3 = nw_protocol_options_copy_proxy_endpoint(v4);
  if (v3)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), v3);
  }
}

void __nw_proxy_config_create_merged_block_invoke_2(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v9 = 0LL;
  id v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  char v12 = 0;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = __nw_proxy_config_create_merged_block_invoke_3;
  v7[3] = &unk_189BBD028;
  __int16 v8 = *(_WORD *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  void v7[4] = &v9;
  void v7[5] = v5;
  v7[6] = v6;
  nw_protocol_options_enumerate_proxy_next_hops(v4, v7);
  if (*((_BYTE *)v10 + 24)) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
  }
  _Block_object_dispose(&v9, 8);
}

void __nw_proxy_config_create_merged_block_invoke_4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v5 = *(id *)(v4 + 40);
  if (v5)
  {
    if (v5 != v3) {
      goto LABEL_7;
    }
    *(void *)(v4 + 40) = 0LL;
    id v7 = v3;

    id v3 = v7;
  }

  id v8 = v3;
  uint64_t v6 = nw_protocol_options_copy(v3);
  if (nw_protocol_options_is_masque(v6))
  {
    nw_masque_options_set_forced_protocol(v6, 0);
    nw_masque_options_set_target_endpoint(v6, 0LL);
  }

  nw_protocol_stack_append_application_protocol(*(void **)(a1 + 32), v6);

  id v3 = v8;
LABEL_7:
}

void sub_1821308F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __nw_proxy_config_create_merged_block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    endpoint = v3;
    nw_endpoint_type_t type = nw_endpoint_get_type(v3);
    uint64_t v4 = endpoint;
    if (type == nw_endpoint_type_host)
    {
      int v6 = *(unsigned __int16 *)(a1 + 56);
      int port = nw_endpoint_get_port(endpoint);
      uint64_t v4 = endpoint;
      if (v6 == port)
      {
        hostname = nw_endpoint_get_hostname(endpoint);
        size_t v9 = strlen(hostname);
        unint64_t v10 = *(void *)(a1 + 40);
        uint64_t v4 = endpoint;
        if (v9 > v10)
        {
          int v11 = strcmp(&hostname[v9 - v10], *(const char **)(a1 + 48));
          uint64_t v4 = endpoint;
          if (!v11) {
            goto LABEL_8;
          }
        }

        if (v9 == v10)
        {
          int v12 = strcmp(hostname, *(const char **)(a1 + 48));
          uint64_t v4 = endpoint;
          if (!v12) {
LABEL_8:
          }
            *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
        }
      }
    }
  }
}

void sub_1821309F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t nw_proxy_config_should_proxy_transport_at_level( NWConcrete_nw_proxy_config *a1, const char *a2, BOOL *a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  p_isa = (xpc_object_t *)&v5->super.isa;
  if (v5)
  {
    if (a2)
    {
      proxied_transports = v5->proxied_transports;
      if (!proxied_transports) {
        goto LABEL_11;
      }
      uint64_t uint64 = xpc_dictionary_get_uint64(proxied_transports, a2);
      if (!(_DWORD)uint64)
      {
        uint64_t v9 = xpc_dictionary_get_uint64(p_isa[2], "proxy-wildcard");
        uint64_t uint64 = v9;
        if (a3) {
          *a3 = 1;
        }
        if (!(_DWORD)v9) {
LABEL_11:
        }
          uint64_t uint64 = 4LL;
      }

      goto LABEL_12;
    }

    __nwlog_obj();
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    uint16_t v27 = "nw_proxy_config_should_proxy_transport_at_level";
    int v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v12, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint16_t v27 = "nw_proxy_config_should_proxy_transport_at_level";
          _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null protocol_name", buf, 0xCu);
        }

void sub_182130F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL33nw_proxy_config_default_transportv_block_invoke()
{
  id v0 = (id)g_tcp_definition;
  nw_proxy_config_default_transport(void)::default_transport_string = (uint64_t)nw_protocol_definition_get_identifier(v0);
}

uint64_t nw_proxy_config_is_equal(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = a2;
  id v5 = v4;
  if (v3 == v4)
  {
    uint64_t is_equal = 1LL;
    goto LABEL_29;
  }

  uint64_t is_equal = 0LL;
  if (v3 && v4)
  {
    uint64_t v7 = *((void *)v3 + 1);
    uint64_t v8 = *((void *)v5 + 1);
    if (v7 == v8) {
      goto LABEL_9;
    }
    uint64_t is_equal = 0LL;
    if (v7 && v8)
    {
      size_t count = nw_dictionary_get_count(v7);
      if (count != nw_dictionary_get_count(*((void *)v5 + 1))) {
        goto LABEL_27;
      }
      uint64_t v41 = 0LL;
      char v42 = &v41;
      uint64_t v43 = 0x2020000000LL;
      char v44 = 0;
      uint64_t v10 = *((void *)v3 + 1);
      v38[0] = MEMORY[0x1895F87A8];
      v38[1] = 3221225472LL;
      v38[2] = __nw_proxy_config_is_equal_block_invoke;
      v38[3] = &unk_189BC7820;
      os_log_type_t v39 = v5;
      os_log_type_t v40 = &v41;
      nw_dictionary_apply(v10, (uint64_t)v38);
      int v11 = *((unsigned __int8 *)v42 + 24);

      _Block_object_dispose(&v41, 8);
      uint64_t is_equal = 0LL;
      if (!v11)
      {
LABEL_9:
        uint64_t v12 = *((void *)v3 + 6);
        uint64_t v13 = *((void *)v5 + 6);
        if (v12 == v13) {
          goto LABEL_33;
        }
        uint64_t is_equal = 0LL;
        if (v12 && v13)
        {
          if (*(void *)(v12 + 24) - *(void *)(v12 + 16) != *(void *)(v13 + 24) - *(void *)(v13 + 16)) {
            goto LABEL_27;
          }
          uint64_t v41 = 0LL;
          char v42 = &v41;
          uint64_t v43 = 0x2020000000LL;
          char v44 = 0;
          v35[0] = MEMORY[0x1895F87A8];
          v35[1] = 3221225472LL;
          v35[2] = __nw_proxy_config_is_equal_block_invoke_2;
          v35[3] = &unk_189BC7960;
          BOOL v36 = v5;
          os_log_type_t v37 = &v41;
          nw_array_apply((unsigned __int8 *)v12, (uint64_t)v35);
          int v14 = *((unsigned __int8 *)v42 + 24);

          _Block_object_dispose(&v41, 8);
          uint64_t is_equal = 0LL;
          if (!v14)
          {
LABEL_33:
            os_log_type_t v15 = (void *)*((void *)v5 + 2);
            id v16 = *((id *)v3 + 2);
            id v17 = v15;
            os_log_type_t v18 = v17;
            BOOL v19 = v16 == v17;
            if (v16 != v17 && v16 && v17) {
              BOOL v19 = xpc_equal(v16, v17);
            }

            if (!v19) {
              goto LABEL_27;
            }
            os_log_type_t v20 = (void *)*((void *)v3 + 13);
            BOOL v21 = (void *)*((void *)v5 + 13);
            if (v20 != v21 && !nw_authentication_credential_is_equal(v20, v21)) {
              goto LABEL_27;
            }
            if (*((_DWORD *)v3 + 38) != *((_DWORD *)v5 + 38)) {
              goto LABEL_27;
            }
            if (*((_DWORD *)v3 + 39) != *((_DWORD *)v5 + 39)) {
              goto LABEL_27;
            }
            if (v3[84] != v5[84]) {
              goto LABEL_27;
            }
            unsigned int v22 = *((unsigned __int8 *)v5 + 170) ^ *((unsigned __int8 *)v3 + 170);
            if ((v22 & 7) != 0) {
              goto LABEL_27;
            }
            uint64_t is_equal = 0LL;
            if (v22 <= 0x3F)
            {
              int v24 = *((unsigned __int8 *)v5 + 171) ^ *((unsigned __int8 *)v3 + 171);
              if (!(v24 & 0x20 | v22 & 0x38))
              {
                uint64_t is_equal = 0LL;
                if ((v24 & 0xFFFFFFDF) == 0 && *((_DWORD *)v3 + 40) == *((_DWORD *)v5 + 40))
                {
                  if (((*((_BYTE *)v5 + 172) ^ *((_BYTE *)v3 + 172)) & 3) != 0
                    || uuid_compare((const unsigned __int8 *)v3 + 56, (const unsigned __int8 *)v5 + 56)
                    || uuid_compare((const unsigned __int8 *)v3 + 72, (const unsigned __int8 *)v5 + 72)
                    || !nw_proxy_config_is_equal(*((void *)v3 + 11), *((void *)v5 + 11)))
                  {
                    goto LABEL_27;
                  }

                  os_log_type_t v25 = (void *)*((void *)v3 + 15);
                  os_log_type_t v26 = (void *)*((void *)v5 + 15);
                  if (v25 != v26)
                  {
                    uint64_t is_equal = 0LL;
                    if (!v25 || !v26) {
                      goto LABEL_29;
                    }
                    if (!xpc_equal(v25, v26)) {
                      goto LABEL_27;
                    }
                  }

                  uint16_t v27 = (void *)*((void *)v3 + 16);
                  __int16 v28 = (void *)*((void *)v5 + 16);
                  if (v27 != v28)
                  {
                    uint64_t is_equal = 0LL;
                    if (!v27 || !v28) {
                      goto LABEL_29;
                    }
                    if (!xpc_equal(v27, v28)) {
                      goto LABEL_27;
                    }
                  }

                  BOOL v29 = (void *)*((void *)v3 + 17);
                  uint64_t v30 = (void *)*((void *)v5 + 17);
                  if (v29 != v30)
                  {
                    uint64_t is_equal = 0LL;
                    if (!v29 || !v30) {
                      goto LABEL_29;
                    }
                    if (!xpc_equal(v29, v30)) {
                      goto LABEL_27;
                    }
                  }

                  os_log_type_t v31 = (void *)*((void *)v3 + 18);
                  BOOL v32 = (void *)*((void *)v5 + 18);
                  if (v31 != v32)
                  {
                    uint64_t is_equal = 0LL;
                    if (!v31 || !v32) {
                      goto LABEL_29;
                    }
                    if (!xpc_equal(v31, v32)) {
                      goto LABEL_27;
                    }
                  }

                  os_log_type_t v33 = (void *)*((void *)v3 + 14);
                  BOOL v34 = (void *)*((void *)v5 + 14);
                  if (v33 == v34)
                  {
LABEL_58:
                    uint64_t is_equal = nw_endpoint_is_equal(*((void **)v3 + 5), *((void **)v5 + 5), 0LL);
                    goto LABEL_29;
                  }

                  uint64_t is_equal = 0LL;
                  if (v33 && v34)
                  {
                    if (xpc_equal(v33, v34)) {
                      goto LABEL_58;
                    }
LABEL_27:
                    uint64_t is_equal = 0LL;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

void sub_182131380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_proxy_config_is_equal_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  int v6 = nw_dictionary_copy_value(*(void *)(*(void *)(a1 + 32) + 8LL), a2);
  uint64_t is_equal = nw_protocol_stack_is_equal(v5, v6, 0);
  if ((is_equal & 1) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  return is_equal;
}

void sub_18213141C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_proxy_config_is_equal_block_invoke_2(uint64_t a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  nw_array_get_object_at_index(*(void *)(*(void *)(a1 + 32) + 48LL), a2);
  int v6 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t is_equal = nw_endpoint_is_equal(v5, v6, 0LL);
  if ((is_equal & 1) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  return is_equal;
}

void sub_1821314AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

size_t nw_proxy_config_get_hash(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v24 = 0LL;
    os_log_type_t v25 = &v24;
    uint64_t v26 = 0x2020000000LL;
    uint64_t v27 = 0LL;
    uint64_t v3 = [*((id *)v1 + 5) getHash];
    v25[3] ^= v3;
    uint64_t v4 = v2[1];
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 3221225472LL;
    v23[2] = __nw_proxy_config_get_hash_block_invoke;
    v23[3] = &unk_189BBD0A0;
    void v23[4] = &v24;
    nw_dictionary_apply(v4, (uint64_t)v23);
    id v5 = (void *)v2[2];
    if (v5)
    {
      size_t v6 = xpc_hash(v5);
      v25[3] ^= v6;
    }

    uint64_t v7 = (void *)v2[3];
    if (v7)
    {
      size_t v8 = xpc_hash(v7);
      v25[3] ^= v8;
    }

    uint64_t v9 = (void *)v2[4];
    if (v9)
    {
      size_t v10 = xpc_hash(v9);
      v25[3] ^= v10;
    }

    int v11 = (void *)v2[14];
    if (v11)
    {
      size_t v12 = xpc_hash(v11);
      v25[3] ^= v12;
    }

    uint64_t v13 = (void *)v2[15];
    if (v13)
    {
      size_t v14 = xpc_hash(v13);
      v25[3] ^= v14;
    }

    os_log_type_t v15 = (void *)v2[16];
    if (v15)
    {
      size_t v16 = xpc_hash(v15);
      v25[3] ^= v16;
    }

    id v17 = (void *)v2[17];
    if (v17)
    {
      size_t v18 = xpc_hash(v17);
      v25[3] ^= v18;
    }

    BOOL v19 = (void *)v2[18];
    if (v19)
    {
      size_t v20 = xpc_hash(v19);
      size_t v21 = v25[3] ^ v20;
      v25[3] = v21;
    }

    else
    {
      size_t v21 = v25[3];
    }

    _Block_object_dispose(&v24, 8);
  }

  else
  {
    size_t v21 = 0LL;
  }

  return v21;
}

void sub_182131660( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_proxy_config_get_hash_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) ^= nw_protocol_stack_get_hash(v4);

  return 1LL;
}

void sub_1821316C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_proxy_config_get_mode(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[38];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)unsigned int buf = 136446210;
  size_t v16 = "nw_proxy_config_get_mode";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_get_mode";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          size_t v16 = "nw_proxy_config_get_mode";
          __int16 v17 = 2082;
          size_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_get_mode";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_get_mode";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_proxy_config_get_type(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = 1LL;
    switch(v1[38])
    {
      case 1u:
        uint64_t v3 = v1[39];
        break;
      case 2u:
        uint64_t v3 = 1002LL;
        break;
      case 3u:
        uint64_t v3 = 1001LL;
        break;
      case 4u:
        goto LABEL_7;
      default:
        goto LABEL_3;
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)unsigned int buf = 136446210;
  size_t v16 = "nw_proxy_config_get_type";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_get_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          size_t v16 = "nw_proxy_config_get_type";
          __int16 v17 = 2082;
          size_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_get_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_get_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_proxy_config_set_type(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 39) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)unsigned int buf = 136446210;
  size_t v16 = "nw_proxy_config_set_type";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_set_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          size_t v16 = "nw_proxy_config_set_type";
          __int16 v17 = 2082;
          size_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_set_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        size_t v16 = "nw_proxy_config_set_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

NWConcrete_nw_proxy_config *nw_proxy_config_create(void *a1, void *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  id v4 = a1;
  id v5 = a2;
  size_t v6 = v5;
  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v40 = "nw_proxy_config_create";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v40 = "nw_proxy_config_create";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null proxy_endpoint", buf, 0xCu);
      }
    }

    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v25, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v40 = "nw_proxy_config_create";
          __int16 v41 = 2082;
          char v42 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s called with null proxy_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v24) {
          goto LABEL_63;
        }
        goto LABEL_62;
      }

      if (v31)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v40 = "nw_proxy_config_create";
        _os_log_impl(&dword_181A5C000, v25, v30, "%{public}s called with null proxy_endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v40 = "nw_proxy_config_create";
        _os_log_impl( &dword_181A5C000,  v25,  v35,  "%{public}s called with null proxy_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_60;
  }

  if (!v5)
  {
    __nwlog_obj();
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v40 = "nw_proxy_config_create";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v40 = "nw_proxy_config_create";
        _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s called with null proxy_options", buf, 0xCu);
      }
    }

    else if (v37)
    {
      BOOL v32 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type;
      BOOL v34 = os_log_type_enabled(v25, type);
      if (v32)
      {
        if (v34)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v40 = "nw_proxy_config_create";
          __int16 v41 = 2082;
          char v42 = v32;
          _os_log_impl( &dword_181A5C000,  v25,  v33,  "%{public}s called with null proxy_options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v32);
LABEL_61:
        if (!v24)
        {
LABEL_63:
          os_log_type_t v8 = 0LL;
          goto LABEL_27;
        }

void sub_18213266C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_with_stack(void *a1, void *a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v4 = a1;
  id v5 = a2;
  size_t v6 = v5;
  if (v4)
  {
    if (v5)
    {
      uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_proxy_config);
      os_log_type_t v8 = v7;
      if (v7)
      {
        v7->unsigned int mode = 1;
        objc_storeStrong((id *)&v7->endpoint, a1);
        uint64_t v9 = (OS_nw_dictionary *)nw_dictionary_create();
        uint64_t stacks = v8->stacks;
        v8->uint64_t stacks = v9;

        uint64_t v11 = (uint64_t)v8->stacks;
        nw_dictionary_set_value( v11,  (const char *)nw_proxy_config_default_transport(void)::default_transport_string,  v6);
        uint64_t v12 = v8;
        goto LABEL_26;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v38 = "nw_proxy_config_create_with_stack";
      id v14 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v35 = 0;
      if (__nwlog_fault(v14, &type, &v35))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v15 = (os_log_s *)(id)gLogObj;
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)unsigned int buf = 136446210;
            os_log_type_t v38 = "nw_proxy_config_create_with_stack";
            _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s [nw_proxy_config init] failed", buf, 0xCu);
          }
        }

        else if (v35)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v15 = (os_log_s *)(id)gLogObj;
          os_log_type_t v18 = type;
          BOOL v19 = os_log_type_enabled(v15, type);
          if (backtrace_string)
          {
            if (v19)
            {
              *(_DWORD *)unsigned int buf = 136446466;
              os_log_type_t v38 = "nw_proxy_config_create_with_stack";
              __int16 v39 = 2082;
              os_log_type_t v40 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s [nw_proxy_config init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v14) {
              goto LABEL_26;
            }
            goto LABEL_25;
          }

          if (v19)
          {
            *(_DWORD *)unsigned int buf = 136446210;
            os_log_type_t v38 = "nw_proxy_config_create_with_stack";
            _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s [nw_proxy_config init] failed, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v15 = (os_log_s *)(id)gLogObj;
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)unsigned int buf = 136446210;
            os_log_type_t v38 = "nw_proxy_config_create_with_stack";
            _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s [nw_proxy_config init] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v14)
      {
LABEL_26:

        goto LABEL_27;
      }

void sub_182132E20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_direct()
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v0 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_proxy_config);
  id v1 = v0;
  if (v0)
  {
    v0->unsigned int mode = 4;
    uint64_t v2 = v0;
    goto LABEL_10;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v15 = "nw_proxy_config_create_direct";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (os_log_s *)(id)gLogObj;
    os_log_type_t v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v15 = "nw_proxy_config_create_direct";
      _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s [nw_proxy_config init] failed", buf, 0xCu);
    }

NWConcrete_nw_proxy_config *nw_proxy_config_create_pac_url(void *a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v2 = a1;
  id v3 = v2;
  if (v2)
  {
    id v4 = v2;
    int v5 = [v4 type];

    if (v5 == 4)
    {
      os_log_type_t v6 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_proxy_config);
      uint64_t v7 = v6;
      if (v6)
      {
        v6->unsigned int mode = 2;
        objc_storeStrong((id *)&v6->endpoint, a1);
        os_log_type_t v8 = v7;
LABEL_24:

        goto LABEL_25;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (id)gLogObj;
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v34 = "nw_proxy_config_create_pac_url";
      BOOL v10 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v31 = 0;
      if (__nwlog_fault(v10, &type, &v31))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v11 = (os_log_s *)(id)gLogObj;
          os_log_type_t v12 = type;
          if (os_log_type_enabled(v11, type))
          {
            *(_DWORD *)unsigned int buf = 136446210;
            os_log_type_t v34 = "nw_proxy_config_create_pac_url";
            _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s [nw_proxy_config init] failed", buf, 0xCu);
          }
        }

        else if (v31)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v11 = (os_log_s *)(id)gLogObj;
          os_log_type_t v14 = type;
          BOOL v15 = os_log_type_enabled(v11, type);
          if (backtrace_string)
          {
            if (v15)
            {
              *(_DWORD *)unsigned int buf = 136446466;
              os_log_type_t v34 = "nw_proxy_config_create_pac_url";
              __int16 v35 = 2082;
              os_log_type_t v36 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s [nw_proxy_config init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v10) {
              goto LABEL_24;
            }
            goto LABEL_23;
          }

          if (v15)
          {
            *(_DWORD *)unsigned int buf = 136446210;
            os_log_type_t v34 = "nw_proxy_config_create_pac_url";
            _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s [nw_proxy_config init] failed, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v11 = (os_log_s *)(id)gLogObj;
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v11, type))
          {
            *(_DWORD *)unsigned int buf = 136446210;
            os_log_type_t v34 = "nw_proxy_config_create_pac_url";
            _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s [nw_proxy_config init] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v10) {
        goto LABEL_24;
      }
LABEL_23:
      free(v10);
      goto LABEL_24;
    }

    __nwlog_obj();
    unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v34 = "nw_proxy_config_create_pac_url";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v19, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v34 = "nw_proxy_config_create_pac_url";
          _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s called with null (nw_endpoint_get_type(pac_url) == nw_endpoint_type_url)",  buf,  0xCu);
        }

void sub_182133868(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_pac_script(const char *a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    id v2 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_proxy_config);
    id v3 = v2;
    if (v2)
    {
      v2->unsigned int mode = 3;
      id v4 = (OS_xpc_object *)xpc_string_create(a1);
      pac_script = v3->pac_script;
      v3->pac_script = v4;

      os_log_type_t v6 = v3;
LABEL_11:

      return v3;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v27 = "nw_proxy_config_create_pac_script";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v27 = "nw_proxy_config_create_pac_script";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s [nw_proxy_config init] failed", buf, 0xCu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            os_log_type_t v27 = "nw_proxy_config_create_pac_script";
            __int16 v28 = 2082;
            os_log_type_t v29 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v13,  "%{public}s [nw_proxy_config init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v8) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }

        if (v14)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v27 = "nw_proxy_config_create_pac_script";
          _os_log_impl(&dword_181A5C000, v9, v13, "%{public}s [nw_proxy_config init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v27 = "nw_proxy_config_create_pac_script";
          _os_log_impl( &dword_181A5C000,  v9,  v15,  "%{public}s [nw_proxy_config init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v8) {
      goto LABEL_11;
    }
LABEL_10:
    free(v8);
    goto LABEL_11;
  }

  __nwlog_obj();
  os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v27 = "nw_proxy_config_create_pac_script";
  os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v17, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v27 = "nw_proxy_config_create_pac_script";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null pac_script", buf, 0xCu);
      }
    }

    else if (v24)
    {
      os_log_type_t v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v18, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v27 = "nw_proxy_config_create_pac_script";
          __int16 v28 = 2082;
          os_log_type_t v29 = v20;
          _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s called with null pac_script, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v20);
        goto LABEL_41;
      }

      if (v22)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v27 = "nw_proxy_config_create_pac_script";
        _os_log_impl(&dword_181A5C000, v18, v21, "%{public}s called with null pac_script, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v27 = "nw_proxy_config_create_pac_script";
        _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null pac_script, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182133DA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_proxy_config_copy_endpoint(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[5];
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v16 = "nw_proxy_config_copy_endpoint";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_proxy_config_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v16 = "nw_proxy_config_copy_endpoint";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_proxy_config_copy_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_proxy_config_copy_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_proxy_config_enumerate_endpoints(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_proxy_config_enumerate_endpoints";
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_proxy_config_enumerate_endpoints";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_proxy_config_enumerate_endpoints";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_44:
        if (!v9) {
          goto LABEL_10;
        }
LABEL_45:
        free(v9);
        goto LABEL_10;
      }

      if (v16)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_proxy_config_enumerate_endpoints";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_proxy_config_enumerate_endpoints";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1821345A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_proxy_config_enumerate_endpoints_block_invoke(uint64_t a1, uint64_t a2, nw_protocol_stack *a3)
{
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __nw_proxy_config_enumerate_endpoints_block_invoke_2;
  v8[3] = &unk_189BBD0C8;
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v9 = v5;
  uint64_t v10 = v6;
  nw_protocol_stack_iterate_application_protocols(a3, v8);

  return 0LL;
}