LABEL_56:
      if (v29) {
        free(v29);
      }
      *((_WORD *)v24 + 14) = -1;
      v22 = v143;
      goto LABEL_59;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = *((unsigned int *)v3 + 11);
    *(_DWORD *)buf = 136446978;
    v147 = "nw_hash_table_apply";
    v148 = 2082;
    v149 = "table->apply_count";
    v150 = 2048;
    v151 = 1LL;
    v152 = 2048;
    v153 = v7;
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v144 = 0;
    if (__nwlog_fault(v8, &type, &v144))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_24;
        }
        v11 = *((unsigned int *)v3 + 11);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "table->apply_count";
        v150 = 2048;
        v151 = 1LL;
        v152 = 2048;
        v153 = v11;
        v12 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_22:
        v19 = (os_log_s *)v9;
        v20 = v10;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v19, v20, v12, buf, 0x2Au);
        goto LABEL_24;
      }

      if (!v144)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_24;
        }
        v18 = *((unsigned int *)v3 + 11);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "table->apply_count";
        v150 = 2048;
        v151 = 1LL;
        v152 = 2048;
        v153 = v18;
        v12 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_22;
      }

      v13 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (os_log_s *)gLogObj;
      v15 = type;
      v16 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v13)
      {
        if (v16)
        {
          v17 = *((unsigned int *)v3 + 11);
          *(_DWORD *)buf = 136447234;
          v147 = "nw_hash_table_apply";
          v148 = 2082;
          v149 = "table->apply_count";
          v150 = 2048;
          v151 = 1LL;
          v152 = 2048;
          v153 = v17;
          v154 = 2082;
          v155 = v13;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
        }

        free(v13);
      }

      else if (v16)
      {
        v124 = *((unsigned int *)v3 + 11);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "table->apply_count";
        v150 = 2048;
        v151 = 1LL;
        v152 = 2048;
        v153 = v124;
        v12 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        v19 = v14;
        v20 = v15;
        goto LABEL_23;
      }
    }

LABEL_57:
            is_selected_for_reporting = 0;
LABEL_58:

            v26 = *(id *)(a1 + 32);
            uuid_generate_random((unsigned __int8 *)v26 + 8);
            *((_BYTE *)v26 + 17) = *((_BYTE *)v26 + 17) & 0xFE | is_selected_for_reporting;
            os_unfair_lock_lock((os_unfair_lock_t)v26 + 26);
            v27 = (void *)*((void *)v26 + 11);
            if ((*((_BYTE *)v26 + 96) & 1) != 0 && v27)
            {
              *((void *)v26 + 11) = 0LL;

              v27 = (void *)*((void *)v26 + 11);
            }

            *((void *)v26 + 11) = 0LL;

            os_unfair_lock_unlock((os_unfair_lock_t)v26 + 26);
            if ((is_selected_for_reporting | nw_activity_should_log(*(void **)(a1 + 32))) == 1)
            {
              v28 = *(void *)(*(void *)(a1 + 32) + 56LL);
              if (__nwlog_activity_log::onceToken != -1) {
                dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
              }
              v29 = (os_log_s *)(id)gactivityLogObj;
              v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
              if (v28)
              {
                if (v30)
                {
                  v31 = *(void *)(a1 + 32);
                  v32 = *(id *)(v31 + 56);
                  *(_DWORD *)buf = 138543618;
                  *(void *)&buf[4] = v31;
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v32;
                  _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEFAULT,  "Activated %{public}@ with parent %{public}@",  buf,  0x16u);
                }
              }

              else if (v30)
              {
                v33 = *(void *)(a1 + 32);
                *(_DWORD *)buf = 138543362;
                *(void *)&buf[4] = v33;
                _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_DEFAULT, "Activated %{public}@", buf, 0xCu);
              }
            }

            *(_BYTE *)(*(void *)(a1 + 32) + 140LL) |= 4u;
            return;
          }

          __nwlog_obj();
          v21 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_activity_make_reporting_decision";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "Unknown reporting strategy";
          v22 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(__upper_bound[0]) = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v24 = type[0];
            if (os_log_type_enabled(v23, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_activity_make_reporting_decision";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "Unknown reporting strategy";
              _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
            }

    if (v35) {
      free(v35);
    }
    a1 = 0LL;
    goto LABEL_37;
  }

  v11 = (char *)v10;
  *((_WORD *)v11 + 160) = 16;
  v12 = calloc(0x10uLL, 0x10uLL);
  if (v12)
  {
LABEL_4:
    *((void *)v11 + 39) = v12;

    v13 = (void **)(v11 + 16);
    objc_storeStrong((id *)v11 + 2, a3);
    if (nw_endpoint_get_type((nw_endpoint_t)v8) == 4)
    {
      v14 = nw_endpoint_copy_host_port_endpoint_for_url(v8);
      v15 = (void *)*((void *)v11 + 1);
      *((void *)v11 + 1) = v14;

      nw_parameters_set_url_endpoint(*((void **)v11 + 2), v8);
    }

    else
    {
      objc_storeStrong((id *)v11 + 1, a2);
    }

    if (!nw_parameters_get_sensitive_redacted(*v13)) {
      nw_endpoint_set_do_not_redact(*((void **)v11 + 1));
    }
    *((_DWORD *)v11 + 112) = a4;
    if (!a4) {
      *((_DWORD *)v11 + 112) = nw_endpoint_handler_get_next_top_id();
    }
    v16 = nw_parameters_copy_context(*((void **)v11 + 2));
    v17 = (void *)*((void *)v11 + 3);
    *((void *)v11 + 3) = v16;

    if (nw_context_is_inline(*((void **)v11 + 3)))
    {
      v18 = (void *)*((void *)v11 + 5);
      *((void *)v11 + 5) = 0LL;
    }

    else
    {
      v19 = nw_context_copy_workloop(*((void **)v11 + 3));
      v18 = (void *)*((void *)v11 + 5);
      *((void *)v11 + 5) = v19;
    }

    memset(__str, 0, 39);
    snprintf(__str, 0x27uLL, "com.apple.network.connection-%u", *((_DWORD *)v11 + 112));
    dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v20 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
    v21 = dispatch_queue_create_with_target_V2(__str, v20, *((dispatch_queue_t *)v11 + 5));
    v22 = (void *)*((void *)v11 + 4);
    *((void *)v11 + 4) = v21;

    uuid_generate_random((unsigned __int8 *)v11 + 452);
    nw_parameters_get_pid(*v13);
    nw_parameters_get_effective_bundle_id(*v13);
    v23 = v11;
    if (_os_feature_enabled_impl())
    {
      v24 = nw_parameters_copy_url_endpoint(*v13);
      v25 = v24;
      if (v24)
      {
        v26 = v24;
        v27 = (const char *)[v26 hostname];

        url_path = nw_endpoint_get_url_path(v26);
        if (v27)
        {
          v29 = (const char *)url_path;
          if (url_path)
          {
            if (!strcmp(v27, "safebrowsing.googleapis.com")
              && (strstr(v29, "fullHashes") || strstr(v29, "threatListUpdates")))
            {
              v30 = xpc_dictionary_create(0LL, 0LL, 0LL);
              xpc_dictionary_set_BOOL(v30, "HTTPSEnable", 1);
              xpc_dictionary_set_int64(v30, "HTTPSPort", 80LL);
              xpc_dictionary_set_string(v30, "HTTPSProxy", "safebrowsing-proxy.networking.apple");
              nw_parameters_set_proxy_configuration(*v13, v30);
              if (*v13 && !nw_path_parameters_get_logging_disabled(*((void *)*v13 + 13)))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v31 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
                {
                  v32 = *((_DWORD *)v11 + 112);
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "nw_connection_apply_proxy_feature_flags";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v32;
                  _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Applying proxy to Safe Browsing URL",  buf,  0x12u);
                }
              }
            }
          }
        }
      }
    }

    *(void *)buf = 0LL;
    *(void *)&buf[8] = 0LL;
    nw_endpoint_get_agent_identifier(v23[1], buf);
    if (!uuid_is_null(buf)) {
      nw_parameters_require_netagent_uuid(*v13, buf);
    }
    *((_DWORD *)v23 + 34) = 0;
    v23[33] = 0LL;
    v23[34] = v23 + 33;
    *((_DWORD *)v23 + 126) = 0;
    a1 = v23;
    goto LABEL_37;
  }

  __nwlog_obj();
  v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__str = 136446722;
  *(void *)&__str[4] = "strict_calloc";
  *(_WORD *)&__str[12] = 2048;
  *(void *)&__str[14] = 16LL;
  *(_WORD *)&__str[22] = 2048;
  *(void *)&__str[24] = 16LL;
  v39 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v39);
  if (!result)
  {
    free(v39);
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

                                    if (v8) {
                                      free(v8);
                                    }
                                    goto LABEL_44;
                                  }

                                  v11 = 15LL;
                                  v12 = 14LL;
                                }

                                else
                                {
                                  v11 = 14LL;
                                  v12 = 13LL;
                                }
                              }

                              else
                              {
                                v11 = 13LL;
                                v12 = 12LL;
                              }
                            }

                            else
                            {
                              v11 = 12LL;
                              v12 = 11LL;
                            }
                          }

                          else
                          {
                            v11 = 11LL;
                            v12 = 10LL;
                          }
                        }

                        else
                        {
                          v11 = 10LL;
                          v12 = 9LL;
                        }
                      }

                      else
                      {
                        v11 = 9LL;
                        v12 = 8LL;
                      }
                    }

                    else
                    {
                      v11 = 8LL;
                      v12 = 7LL;
                    }
                  }

                  else
                  {
                    v11 = 7LL;
                    v12 = 6LL;
                  }
                }

                else
                {
                  v11 = 6LL;
                  v12 = 5LL;
                }
              }

              else
              {
                v11 = 5LL;
                v12 = 4LL;
              }
            }

            else
            {
              v11 = 4LL;
              v12 = 3LL;
            }
          }

          else
          {
            v11 = 3LL;
            v12 = 2LL;
          }
        }

        else
        {
          v11 = 2LL;
          v12 = 1LL;
        }
      }

      else
      {
        v12 = 0LL;
        v11 = 1LL;
      }

      memcpy(v5->id_chain, v6->id_chain, v12);
    }

    else
    {
      v11 = 0LL;
    }

    v5->id_chain[v11] = nw_endpoint_handler_get_next_id(&v6->last_child_id.__a_.__a_value);
    snprintf(v5->id_str, 0x4BuLL, "%s.%u");
    goto LABEL_44;
  }

  if (!next_top_id) {
    next_top_id = nw_endpoint_handler_get_next_top_id();
  }
  v5->top_id = next_top_id;
  snprintf(v5->id_str, 0x4BuLL, "%u");
LABEL_44:
}

    goto LABEL_57;
  }

  v30 = *(id *)(v29 + 16);

LABEL_57:
  return v30;
}

    if (!v24) {
      goto LABEL_58;
    }
LABEL_57:
    free(v24);
    goto LABEL_58;
  }

  v6 = (unsigned int *)v4;
  v7 = v6[29];

  if ((_DWORD)v7 == 5)
  {
    v8 = v6;
    v9 = v8[30];

    if (v9 == 1)
    {
      v10 = v8;
      v11 = *((_BYTE *)v10 + 268);

      if ((v11 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v12 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          v13 = v10;

          v14 = v13;
          v15 = *((_BYTE *)v10 + 268);

          if ((v15 & 1) != 0) {
            v16 = "dry-run ";
          }
          else {
            v16 = "";
          }
          v17 = nw_endpoint_handler_copy_endpoint(v14);
          logging_description = nw_endpoint_get_logging_description(v17);
          v51 = v13 + 168;
          v18 = v14;
          v19 = v18;
          v20 = v8[30];
          else {
            v21 = off_189BBBBF0[v20];
          }
          v50 = v21;

          v34 = v19;
          v35 = v34;
          v36 = v6[29];
          v37 = "path";
          switch(v36)
          {
            case 0u:
              break;
            case 1u:
              v37 = "resolver";
              break;
            case 2u:
              v37 = nw_endpoint_flow_mode_string(v34[31]);
              break;
            case 3u:
              v37 = "proxy";
              break;
            case 4u:
              v37 = "fallback";
              break;
            case 5u:
              v37 = "transform";
              break;
            default:
              v37 = "unknown-mode";
              break;
          }

          v39 = v35;
          os_unfair_lock_lock((os_unfair_lock_t)v39 + 28);
          v40 = v39[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v39 + 28);

          *(_DWORD *)buf = 136447746;
          v56 = "-[NWConcrete_nw_endpoint_transform startWithHandler:]";
          v57 = 2082;
          v58 = v51;
          v59 = 2082;
          v60 = v16;
          v61 = 2082;
          v62 = (void *)logging_description;
          v63 = 2082;
          v64 = v50;
          v65 = 2082;
          v66 = v37;
          v67 = 2114;
          v68 = v40;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);
        }
      }

      v41 = nw_endpoint_handler_copy_endpoint(v10);
      primary_endpoint = self->primary_endpoint;
      self->primary_endpoint = v41;

      v43 = v10;
      v8[30] = 2;

      v43->event = (nw_endpoint_handler_event_s)65543;
      nw_endpoint_handler_report(v43, 0LL, &v43->event.domain, 0LL);
      nw_endpoint_transform_add_children(v43);
      nw_endpoint_transform_start_next_child(v43);
    }

    goto LABEL_58;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v22 = (id)gLogObj;
  else {
    v23 = off_189BBBBC0[v7];
  }
  *(_DWORD *)buf = 136446722;
  v56 = "-[NWConcrete_nw_endpoint_transform startWithHandler:]";
  v57 = 2082;
  v58 = (void *)v23;
  v59 = 2082;
  v60 = "transform";
  v24 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v53 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = (os_log_s *)(id)gLogObj;
    v26 = type;
    if (os_log_type_enabled(v25, type))
    {
      else {
        v27 = off_189BBBBC0[v7];
      }
      *(_DWORD *)buf = 136446722;
      v56 = "-[NWConcrete_nw_endpoint_transform startWithHandler:]";
      v57 = 2082;
      v58 = (void *)v27;
      v59 = 2082;
      v60 = "transform";
      _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

    if (v22) {
      free(v22);
    }
    v12 = 0LL;
    goto LABEL_23;
  }

  if (!v4)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(void *)&length[4] = "nw_path_can_resolve_endpoint";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (__nwlog_fault(v22, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_can_resolve_endpoint";
          _os_log_impl(&dword_181A5C000, v23, v26, "%{public}s called with null endpoint", length, 0xCu);
        }

      goto LABEL_57;
    }

    if (!v27)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_parameters_copy_protocol_value";
        _os_log_impl(&dword_181A5C000, v11, v26, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v22 = type;
    v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_parameters_copy_protocol_value";
        _os_log_impl(&dword_181A5C000, v11, v22, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "nw_parameters_copy_protocol_value";
      v31 = 2082;
      v32 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_38;
  }

    if (v21) {
      free(v21);
    }
    return 0LL;
  }

  if ((*(_BYTE *)(a1 + 148) & 1) == 0) {
    return 0LL;
  }
  if ((a2 - 1) >= 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v31 = "nw_path_flow_registration_get_stats_area";
    v32 = 1024;
    *(_DWORD *)v33 = a2;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (os_log_s *)(id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_flow_registration_get_stats_area";
          v32 = 1024;
          *(_DWORD *)v33 = a2;
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s Requested unknown stats type %u", buf, 0x12u);
        }
      }

      else if (v28)
      {
        v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (os_log_s *)(id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (v14)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446722;
            v31 = "nw_path_flow_registration_get_stats_area";
            v32 = 1024;
            *(_DWORD *)v33 = a2;
            v33[2] = 2082;
            *(void *)&v33[3] = v14;
            _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s Requested unknown stats type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v14);
          if (!v11) {
            return 0LL;
          }
          goto LABEL_24;
        }

        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_flow_registration_get_stats_area";
          v32 = 1024;
          *(_DWORD *)v33 = a2;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s Requested unknown stats type %u, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (os_log_s *)(id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_flow_registration_get_stats_area";
          v32 = 1024;
          *(_DWORD *)v33 = a2;
          _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s Requested unknown stats type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (v11) {
LABEL_24:
    }
      free(v11);
    return 0LL;
  }

  result = *(int **)(a1 + 64);
  if (!result || (v5 = *result) == 0)
  {
    v17 = nw_path_flow_registration_copy_parent_evaluator((NWConcrete_nw_path_flow_registration *)a1);
    v18 = nw_parameters_copy_context(*((void **)v17 + 1));
    nw_context_assert_queue(v18);
    *(void *)(a1 + 64) = 0LL;

    return 0LL;
  }

  if ((v5 != 3 || a2 != 2) && v5 != a2)
  {
    __nwlog_obj();
    v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = *(_DWORD **)(a1 + 64);
      if (v9) {
        LODWORD(v9) = *v9;
      }
      *(_DWORD *)buf = 136446722;
      v31 = "nw_path_flow_registration_get_stats_area";
      v32 = 1024;
      *(_DWORD *)v33 = (_DWORD)v9;
      v33[2] = 1024;
      *(_DWORD *)&v33[3] = a2;
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s Requested stats type does not match allocated type (%u != %u)",  buf,  0x18u);
    }

    return 0LL;
  }

  return result;
}

    free(backtrace_string);
    goto LABEL_23;
  }

  if (*a3 <= 0x13u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = *a3;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_interface_get_ipv4_network_signature";
    v44 = 1024;
    *(_DWORD *)v45 = v8;
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v9, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (os_log_s *)(id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          v12 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv4_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v12;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN",  buf,  0x12u);
        }
      }

      else if (v40)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (os_log_s *)(id)gLogObj;
        v16 = type;
        v17 = os_log_type_enabled(v10, type);
        if (v15)
        {
          if (v17)
          {
            v18 = *a3;
            *(_DWORD *)buf = 136446722;
            v43 = "nw_interface_get_ipv4_network_signature";
            v44 = 1024;
            *(_DWORD *)v45 = v18;
            v45[2] = 2082;
            *(void *)&v45[3] = v15;
            _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v15);
          if (!v9) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }

        if (v17)
        {
          v21 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv4_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (os_log_s *)(id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          v20 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv4_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v20;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

  if (v12) {
    free(v12);
  }
  return 0LL;
}

    if (v37) {
      free(v37);
    }
    return 0LL;
  }

  if (context_identifier) {
    goto LABEL_4;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v40 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v50 = "_strict_strlcpy";
  v41 = (void *)_os_log_send_and_compose_impl();

  result = (nw_content_context_t)__nwlog_abort((uint64_t)v41);
  if (!(_DWORD)result)
  {
    free(v41);
LABEL_4:
    v4 = *(unsigned __int8 *)context_identifier;
    *((_BYTE *)v3 + 24) = v4;
    if (v4)
    {
      v5 = *((unsigned __int8 *)context_identifier + 1);
      *((_BYTE *)v3 + 25) = v5;
      if (v5)
      {
        v6 = *((unsigned __int8 *)context_identifier + 2);
        *((_BYTE *)v3 + 26) = v6;
        if (v6)
        {
          v7 = *((unsigned __int8 *)context_identifier + 3);
          *((_BYTE *)v3 + 27) = v7;
          if (v7)
          {
            v8 = *((unsigned __int8 *)context_identifier + 4);
            *((_BYTE *)v3 + 28) = v8;
            if (v8)
            {
              v9 = *((unsigned __int8 *)context_identifier + 5);
              *((_BYTE *)v3 + 29) = v9;
              if (v9)
              {
                v10 = *((unsigned __int8 *)context_identifier + 6);
                *((_BYTE *)v3 + 30) = v10;
                if (v10)
                {
                  v11 = *((unsigned __int8 *)context_identifier + 7);
                  *((_BYTE *)v3 + 31) = v11;
                  if (v11)
                  {
                    v12 = *((unsigned __int8 *)context_identifier + 8);
                    *((_BYTE *)v3 + 32) = v12;
                    if (v12)
                    {
                      v13 = *((unsigned __int8 *)context_identifier + 9);
                      *((_BYTE *)v3 + 33) = v13;
                      if (v13)
                      {
                        v14 = *((unsigned __int8 *)context_identifier + 10);
                        *((_BYTE *)v3 + 34) = v14;
                        if (v14)
                        {
                          v15 = *((unsigned __int8 *)context_identifier + 11);
                          *((_BYTE *)v3 + 35) = v15;
                          if (v15)
                          {
                            v16 = *((unsigned __int8 *)context_identifier + 12);
                            *((_BYTE *)v3 + 36) = v16;
                            if (v16)
                            {
                              v17 = *((unsigned __int8 *)context_identifier + 13);
                              *((_BYTE *)v3 + 37) = v17;
                              if (v17)
                              {
                                v18 = *((unsigned __int8 *)context_identifier + 14);
                                *((_BYTE *)v3 + 38) = v18;
                                if (v18)
                                {
                                  v19 = *((unsigned __int8 *)context_identifier + 15);
                                  *((_BYTE *)v3 + 39) = v19;
                                  if (v19)
                                  {
                                    v20 = *((unsigned __int8 *)context_identifier + 16);
                                    *((_BYTE *)v3 + 40) = v20;
                                    if (v20)
                                    {
                                      v21 = *((unsigned __int8 *)context_identifier + 17);
                                      *((_BYTE *)v3 + 41) = v21;
                                      if (v21)
                                      {
                                        v22 = *((unsigned __int8 *)context_identifier + 18);
                                        *((_BYTE *)v3 + 42) = v22;
                                        if (v22)
                                        {
                                          v23 = *((unsigned __int8 *)context_identifier + 19);
                                          *((_BYTE *)v3 + 43) = v23;
                                          if (v23)
                                          {
                                            v24 = *((unsigned __int8 *)context_identifier + 20);
                                            *((_BYTE *)v3 + 44) = v24;
                                            if (v24)
                                            {
                                              v25 = *((unsigned __int8 *)context_identifier + 21);
                                              *((_BYTE *)v3 + 45) = v25;
                                              if (v25)
                                              {
                                                v26 = *((unsigned __int8 *)context_identifier + 22);
                                                *((_BYTE *)v3 + 46) = v26;
                                                if (v26)
                                                {
                                                  v27 = *((unsigned __int8 *)context_identifier + 23);
                                                  *((_BYTE *)v3 + 47) = v27;
                                                  if (v27)
                                                  {
                                                    v28 = *((unsigned __int8 *)context_identifier + 24);
                                                    *((_BYTE *)v3 + 48) = v28;
                                                    if (v28)
                                                    {
                                                      v29 = *((unsigned __int8 *)context_identifier + 25);
                                                      *((_BYTE *)v3 + 49) = v29;
                                                      if (v29)
                                                      {
                                                        v30 = *((unsigned __int8 *)context_identifier + 26);
                                                        *((_BYTE *)v3 + 50) = v30;
                                                        if (v30)
                                                        {
                                                          v31 = *((unsigned __int8 *)context_identifier + 27);
                                                          *((_BYTE *)v3 + 51) = v31;
                                                          if (v31)
                                                          {
                                                            v32 = *((unsigned __int8 *)context_identifier + 28);
                                                            *((_BYTE *)v3 + 52) = v32;
                                                            if (v32)
                                                            {
                                                              v33 = *((unsigned __int8 *)context_identifier + 29);
                                                              *((_BYTE *)v3 + 53) = v33;
                                                              if (v33)
                                                              {
                                                                v34 = *((unsigned __int8 *)context_identifier + 30);
                                                                *((_BYTE *)v3 + 54) = v34;
                                                                if (v34) {
                                                                  *((_BYTE *)v3 + 55) = 0;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    *((void *)v3 + 10) = 0x3FE0000000000000LL;
    return (nw_content_context_t)v3;
  }

  __break(1u);
  return result;
}

      LOBYTE(v10) = 0;
LABEL_41:
      if ((_DWORD)v5) {
        LOBYTE(v7) = 0;
      }
      else {
        LOBYTE(v7) = v10;
      }
      goto LABEL_44;
    }

    __break(1u);
  }

  __break(1u);
  return result;
}

  v36 = *(void **)(a1 + 160);
  v37 = (void *)a2[20];
  *(void *)(a1 + 160) = v37;
  v38 = v37;

  v39 = *((_DWORD *)a2 + 42);
  *(_BYTE *)(a1 + 172) = *((_BYTE *)a2 + 172);
  *(_DWORD *)(a1 + 168) = v39;
  *(_BYTE *)(a1 + 173) = *((_BYTE *)a2 + 173);
  return a1;
}

    if (v25) {
      free(v25);
    }
    goto LABEL_21;
  }

  if (v4)
  {
    [v3[11] objectForKeyedSubscript:v4];
    v6 = (char *)objc_claimAutoreleasedReturnValue();
    if (v6)
    {
      [v3[11] removeObjectForKey:v5];
      if (__nwlog_candidate_manager_log::onceToken != -1) {
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      }
      v7 = (os_log_s *)(id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = (char *)v3[1];
        *(_DWORD *)buf = 136446978;
        v35 = "nw_candidate_manager_remove_hostname_resolver";
        v36 = 2048;
        v37 = v8;
        v38 = 2112;
        v39 = v6;
        v40 = 2112;
        v41 = v5;
        _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, "%{public}s [CM%zu] Removed %@ for %@", buf, 0x2Au);
      }

      nw_resolver_cancel(v6);
      goto LABEL_20;
    }

    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    }
    v9 = (id)gcandidate_managerLogObj;
    v10 = (char *)v3[1];
    *(_DWORD *)buf = 136446722;
    v35 = "nw_candidate_manager_remove_hostname_resolver";
    v36 = 2048;
    v37 = v10;
    v38 = 2112;
    v39 = v5;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v11, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_candidate_manager_log::onceToken != -1) {
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        }
        v12 = (os_log_s *)(id)gcandidate_managerLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          v14 = (char *)v3[1];
          *(_DWORD *)buf = 136446722;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          v36 = 2048;
          v37 = v14;
          v38 = 2112;
          v39 = v5;
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s [CM%zu] No resolver for %@", buf, 0x20u);
        }
      }

      else if (v32)
      {
        v15 = __nw_create_backtrace_string();
        if (v15)
        {
          v16 = (char *)v15;
          if (__nwlog_candidate_manager_log::onceToken != -1) {
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
          }
          v17 = (os_log_s *)(id)gcandidate_managerLogObj;
          v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            v19 = (char *)v3[1];
            *(_DWORD *)buf = 136446978;
            v35 = "nw_candidate_manager_remove_hostname_resolver";
            v36 = 2048;
            v37 = v19;
            v38 = 2112;
            v39 = v5;
            v40 = 2082;
            v41 = v16;
            _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s [CM%zu] No resolver for %@, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v16);
          if (!v11) {
            goto LABEL_20;
          }
          goto LABEL_19;
        }

        if (__nwlog_candidate_manager_log::onceToken != -1) {
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        }
        v12 = (os_log_s *)(id)gcandidate_managerLogObj;
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          v23 = (char *)v3[1];
          *(_DWORD *)buf = 136446722;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          v36 = 2048;
          v37 = v23;
          v38 = 2112;
          v39 = v5;
          _os_log_impl(&dword_181A5C000, v12, v22, "%{public}s [CM%zu] No resolver for %@, no backtrace", buf, 0x20u);
        }
      }

      else
      {
        if (__nwlog_candidate_manager_log::onceToken != -1) {
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        }
        v12 = (os_log_s *)(id)gcandidate_managerLogObj;
        v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          v21 = (char *)v3[1];
          *(_DWORD *)buf = 136446722;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          v36 = 2048;
          v37 = v21;
          v38 = 2112;
          v39 = v5;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s [CM%zu] No resolver for %@, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    if (!v11)
    {
LABEL_20:

      goto LABEL_21;
    }

        if (gLogDatapath)
        {
          v79 = v14;
          __nwlog_obj();
          v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            v81 = a1[4];
            if (v81) {
              v82 = (const char *)(v81 + 609);
            }
            else {
              v82 = "";
            }
            v83 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
            *(_DWORD *)buf = 136446722;
            v93 = "nw_framer_flush_output_block_invoke";
            v94 = 2080;
            v95 = (void *)v82;
            v96 = 2048;
            v97[0] = v83;
            _os_log_impl(&dword_181A5C000, v80, OS_LOG_TYPE_DEBUG, "%{public}s %s Set frame %zu bytes", buf, 0x20u);
          }

          v17 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
          v15 = v79;
        }

        nw_dispatch_data_copyout_from_offset(*(dispatch_data_s **)(*(void *)(a1[6] + 8LL) + 40LL), v15, v17, 0LL);
        if ((*(_BYTE *)(a1[4] + 607LL) & 0x20) != 0)
        {
          *(_BYTE *)(v4 + 186) |= 0x80u;
          *(_BYTE *)(a1[4] + 607LL) &= ~0x20u;
        }

        nw_frame_claim(v4, v44, *(_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL), 0);
        nw_frame_collapse(v4);
        nw_frame_unclaim(v4, v45, *(_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL), 0);
        v46 = *(void *)(a1[6] + 8LL);
        v47 = *(void **)(v46 + 40);
        *(void *)(v46 + 40) = 0LL;

        size = 0LL;
LABEL_60:
        *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = size;
        v33 = a1[5];
        if (!v33) {
          goto LABEL_55;
        }
        goto LABEL_42;
      }

      if (!v17) {
        goto LABEL_56;
      }
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        v65 = a1[4];
        if (v65) {
          v66 = (const char *)(v65 + 609);
        }
        else {
          v66 = "";
        }
        v67 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
        *(_DWORD *)buf = 136446978;
        v93 = "nw_framer_flush_output_block_invoke";
        v94 = 2080;
        v95 = (void *)v66;
        v96 = 1024;
        LODWORD(v97[0]) = offset;
        WORD2(v97[0]) = 2048;
        *(void *)((char *)v97 + 6) = v67;
        _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Dropping empty output frame %u < %zu bytes",  buf,  0x26u);
      }
    }

    goto LABEL_37;
  }

  v5 = nw_frame_unclaimed_length((_DWORD *)v4);
  v6 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
  if (v5)
  {
    v7 = v5;
    if (v6 > v5)
    {
      if (gLogDatapath)
      {
        v74 = v5;
        __nwlog_obj();
        v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
        {
          v76 = a1[4];
          if (v76) {
            v77 = (const char *)(v76 + 609);
          }
          else {
            v77 = "";
          }
          v78 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v93 = "nw_framer_flush_output_block_invoke";
          v94 = 2080;
          v95 = (void *)v77;
          v96 = 1024;
          LODWORD(v97[0]) = v74;
          WORD2(v97[0]) = 2048;
          *(void *)((char *)v97 + 6) = v78;
          _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Set partial external frame output_length %u < %zu bytes",  buf,  0x26u);
        }
      }

      v8 = dispatch_data_create_subrange(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL), 0LL, v7);
      v9 = dispatch_data_create_subrange( *(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL),  v7,  *(void *)(*(void *)(a1[7] + 8LL) + 24LL) - v7);
      v10 = *(void *)(a1[6] + 8LL);
      v11 = *(void **)(v10 + 40);
      *(void *)(v10 + 40) = v9;

      nw_frame_set_external_data(v4, v8, 0LL);
      *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL)
                                                                                               + 40LL));

LABEL_41:
      v33 = a1[5];
      if (!v33) {
        goto LABEL_55;
      }
LABEL_42:
      v36 = *(_DWORD *)(v33 + 176);
      if (!v36)
      {
LABEL_46:
        ecn_flag = nw_frame_get_ecn_flag(a1[5]);
        if (ecn_flag)
        {
          v38 = ecn_flag;
          if (gLogDatapath)
          {
            __nwlog_obj();
            v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
            {
              v56 = a1[4];
              *(_DWORD *)buf = 136446722;
              v93 = "nw_framer_flush_output_block_invoke";
              if (v56) {
                v57 = (const char *)(v56 + 609);
              }
              else {
                v57 = "";
              }
              v94 = 2080;
              v95 = (void *)v57;
              v96 = 1024;
              LODWORD(v97[0]) = v38;
              _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Setting ECN flag %u on output frame",  buf,  0x1Cu);
            }
          }

          nw_frame_set_ecn_flag(v4, v38);
        }

        expire_time = nw_frame_get_expire_time(a1[5]);
        if (expire_time)
        {
          v40 = expire_time;
          if (gLogDatapath)
          {
            __nwlog_obj();
            v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
            {
              v59 = a1[4];
              *(_DWORD *)buf = 136446722;
              v93 = "nw_framer_flush_output_block_invoke";
              if (v59) {
                v60 = (const char *)(v59 + 609);
              }
              else {
                v60 = "";
              }
              v94 = 2080;
              v95 = (void *)v60;
              v96 = 2048;
              v97[0] = v40;
              _os_log_impl( &dword_181A5C000,  v58,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Setting expire time %llu on output frame",  buf,  0x20u);
            }
          }

          nw_frame_set_expire_time(v4, v40);
        }

        packet_id = nw_frame_get_packet_id(a1[5]);
        if (packet_id)
        {
          v42 = (_OWORD *)packet_id;
          if (gLogDatapath)
          {
            __nwlog_obj();
            v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
            {
              v62 = a1[4];
              if (v62) {
                v63 = (const char *)(v62 + 609);
              }
              else {
                v63 = "";
              }
              *(_DWORD *)buf = 136446466;
              v93 = "nw_framer_flush_output_block_invoke";
              v94 = 2080;
              v95 = (void *)v63;
              _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Setting packet ID on output frame",  buf,  0x16u);
            }
          }

          nw_frame_set_packet_id(v4, v42);
        }

        goto LABEL_55;
      }

      if (gLogDatapath)
      {
        __nwlog_obj();
        v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
        {
          v49 = a1[4];
          *(_DWORD *)buf = 136446722;
          v93 = "nw_framer_flush_output_block_invoke";
          if (v49) {
            v50 = (const char *)(v49 + 609);
          }
          else {
            v50 = "";
          }
          v94 = 2080;
          v95 = (void *)v50;
          v96 = 1024;
          LODWORD(v97[0]) = v36;
          _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Setting service class 0x%x on output frame",  buf,  0x1Cu);
        }
      }

      if (v4)
      {
        *(_DWORD *)(v4 + 176) = v36;
        goto LABEL_46;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v93 = "nw_frame_set_service_class";
      v51 = (const char *)_os_log_send_and_compose_impl();
      LOBYTE(offset) = 16;
      offset_7 = 0;
      v89 = (char *)v51;
      if (__nwlog_fault(v51, &offset, &offset_7))
      {
        if (offset == 17)
        {
          v52 = (os_log_s *)__nwlog_obj();
          v53 = offset;
          if (!os_log_type_enabled(v52, (os_log_type_t)offset)) {
            goto LABEL_130;
          }
          *(_DWORD *)buf = 136446210;
          v93 = "nw_frame_set_service_class";
          v54 = "%{public}s called with null frame";
          goto LABEL_129;
        }

        if (!offset_7)
        {
          v52 = (os_log_s *)__nwlog_obj();
          v53 = offset;
          if (!os_log_type_enabled(v52, (os_log_type_t)offset)) {
            goto LABEL_130;
          }
          *(_DWORD *)buf = 136446210;
          v93 = "nw_frame_set_service_class";
          v54 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_129;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        v52 = (os_log_s *)__nwlog_obj();
        v53 = offset;
        v73 = os_log_type_enabled(v52, (os_log_type_t)offset);
        if (backtrace_string)
        {
          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_frame_set_service_class";
            v94 = 2082;
            v95 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_130;
        }

        if (v73)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_frame_set_service_class";
          v54 = "%{public}s called with null frame, no backtrace";
LABEL_129:
          _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
        }
      }

  if (v10) {
    free(v10);
  }
  return 0LL;
}

        free(v8);
        goto LABEL_57;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_57;
  }

  v9 = v7;
  v10 = *((id *)v9 + 1);

  is_framer = nw_protocol_definition_is_framer(v10);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_framer_message_set_value";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_framer_message_set_value";
        _os_log_impl( &dword_181A5C000,  v16,  v19,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message)",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (!v34)
    {
      __nwlog_obj();
      v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_framer_message_set_value";
        _os_log_impl( &dword_181A5C000,  v16,  v31,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v25 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v26 = type;
    v27 = os_log_type_enabled(v16, type);
    if (!v25)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_framer_message_set_value";
        _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v37 = "nw_framer_message_set_value";
      v38 = 2082;
      v39 = v25;
      _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  if (!key)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_framer_message_set_value";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_framer_message_set_value";
        _os_log_impl(&dword_181A5C000, v16, v21, "%{public}s called with null key", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v34)
    {
      __nwlog_obj();
      v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_framer_message_set_value";
        _os_log_impl(&dword_181A5C000, v16, v32, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    v25 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v28 = type;
    v29 = os_log_type_enabled(v16, type);
    if (!v25)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_framer_message_set_value";
        _os_log_impl(&dword_181A5C000, v16, v28, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v37 = "nw_framer_message_set_value";
      v38 = 2082;
      v39 = v25;
      _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_57;
  }

  v7 = v5;
  v8 = *((id *)v7 + 1);

  is_framer = nw_protocol_definition_is_framer(v8);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_framer_message_set_object_value";
    v13 = (char *)_os_log_send_and_compose_impl();

    v33 = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (v33 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v17 = v33;
      if (os_log_type_enabled(v14, v33))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_framer_message_set_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message)",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (!v32)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = v33;
      if (os_log_type_enabled(v14, v33))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_framer_message_set_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v24 = v33;
    v25 = os_log_type_enabled(v14, v33);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_framer_message_set_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_framer_message_set_object_value";
      v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  if (!key)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_framer_message_set_object_value";
    v13 = (char *)_os_log_send_and_compose_impl();

    v33 = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (v33 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v19 = v33;
      if (os_log_type_enabled(v14, v33))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_framer_message_set_object_value";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null key", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v32)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = v33;
      if (os_log_type_enabled(v14, v33))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_framer_message_set_object_value";
        _os_log_impl(&dword_181A5C000, v14, v30, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v26 = v33;
    v27 = os_log_type_enabled(v14, v33);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_framer_message_set_object_value";
        _os_log_impl(&dword_181A5C000, v14, v26, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_framer_message_set_object_value";
      v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

      goto LABEL_57;
    }

    if (!v31)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl(&dword_181A5C000, v14, v29, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl(&dword_181A5C000, v14, v25, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_framer_message_copy_object_value";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_38;
  }

          PBReaderRecallMark();
LABEL_57:

LABEL_58:
          v4 = *v3;
          v5 = *(void *)(a2 + v4);
          v7 = *(void *)(a2 + *v6);
          if (v5 >= v7) {
            return *(_BYTE *)(a2 + *v8) == 0;
          }
          break;
        case 5u:
          v53 = PBReaderReadData();
          v52 = *(NWPBAddressEndpoint **)(a1 + 40);
          *(void *)(a1 + 40) = v53;
          goto LABEL_57;
        default:
          if ((PBReaderSkipValueWithTag() & 1) != 0) {
            goto LABEL_58;
          }
          return 0LL;
      }
    }

    v13 = 0LL;
LABEL_36:
    *v11 = 1;
    goto LABEL_37;
  }

  return *(_BYTE *)(a2 + *v8) == 0;
}

    v29 = *(_BYTE **)(a1 + 32);
    goto LABEL_57;
  }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_application_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_received_application_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_transport_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_transport_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_received_transport_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_received_transport_duplicate_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_ip_packet_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_ip_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_received_ip_packet_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_packet_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_acked_packet_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_marked_packet_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_57:
      if (v18) {
        free(v18);
      }
LABEL_59:
      v7 = 0LL;
      goto LABEL_14;
    }

    if (!v31)
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v30,  "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
        _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_transport_ecn_capable_lost_packet_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v27,  "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s",  buf,  0x16u);
    }

        if (!v45) {
          goto LABEL_58;
        }
LABEL_57:
        free(v45);
        goto LABEL_58;
      }

      __nwlog_obj();
      v79 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)handler = 136446210;
      *(void *)&handler[4] = "nw_connection_group_set_up_and_start_listener_locked";
      v80 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      type[0] = 0;
      if (__nwlog_fault(v80, buf, type))
      {
        if (buf[0] == 17)
        {
          __nwlog_obj();
          v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v82 = buf[0];
          if (os_log_type_enabled(v81, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&handler[4] = "nw_connection_group_set_up_and_start_listener_locked";
            _os_log_impl(&dword_181A5C000, v81, v82, "%{public}s called with null group->listener", handler, 0xCu);
          }
        }

        else if (type[0])
        {
          v95 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v96 = buf[0];
          v97 = os_log_type_enabled(v81, (os_log_type_t)buf[0]);
          if (v95)
          {
            if (v97)
            {
              *(_DWORD *)handler = 136446466;
              *(void *)&handler[4] = "nw_connection_group_set_up_and_start_listener_locked";
              *(_WORD *)&handler[12] = 2082;
              *(void *)&handler[14] = v95;
              _os_log_impl( &dword_181A5C000,  v81,  v96,  "%{public}s called with null group->listener, dumping backtrace:%{public}s",  handler,  0x16u);
            }

            free(v95);
            goto LABEL_196;
          }

          if (v97)
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&handler[4] = "nw_connection_group_set_up_and_start_listener_locked";
            _os_log_impl( &dword_181A5C000,  v81,  v96,  "%{public}s called with null group->listener, no backtrace",  handler,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v116 = buf[0];
          if (os_log_type_enabled(v81, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&handler[4] = "nw_connection_group_set_up_and_start_listener_locked";
            _os_log_impl( &dword_181A5C000,  v81,  v116,  "%{public}s called with null group->listener, backtrace limit exceeded",  handler,  0xCu);
          }
        }
      }

    free(v46);
    goto LABEL_62;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v60 = "nw_protocol_definition_create_named";
  v61 = 1024;
  *(_DWORD *)v62 = a1;
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v57 = 0;
  if (__nwlog_fault(v4, &type, &v57))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (os_log_s *)(id)gLogObj;
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_definition_create_named";
        v61 = 1024;
        *(_DWORD *)v62 = a1;
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s Invalid protocol variant %u", buf, 0x12u);
      }
    }

    else if (v57)
    {
      v42 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (os_log_s *)(id)gLogObj;
      v43 = type;
      v44 = os_log_type_enabled(v5, type);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446722;
          v60 = "nw_protocol_definition_create_named";
          v61 = 1024;
          *(_DWORD *)v62 = a1;
          v62[2] = 2082;
          *(void *)&v62[3] = v42;
          _os_log_impl( &dword_181A5C000,  v5,  v43,  "%{public}s Invalid protocol variant %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v42);
        if (!v4) {
          return 0LL;
        }
        goto LABEL_8;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_definition_create_named";
        v61 = 1024;
        *(_DWORD *)v62 = a1;
        _os_log_impl(&dword_181A5C000, v5, v43, "%{public}s Invalid protocol variant %u, no backtrace", buf, 0x12u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (os_log_s *)(id)gLogObj;
      v52 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_definition_create_named";
        v61 = 1024;
        *(_DWORD *)v62 = a1;
        _os_log_impl( &dword_181A5C000,  v5,  v52,  "%{public}s Invalid protocol variant %u, backtrace limit exceeded",  buf,  0x12u);
      }
    }
  }

  if (v4) {
LABEL_8:
  }
    free(v4);
  return 0LL;
}

        free(v11);
        goto LABEL_57;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_implementation_accept";
        _os_log_impl(&dword_181A5C000, v12, v24, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_implementation_accept";
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      free(backtrace_string);
    }

    goto LABEL_57;
  }

  if (!v6)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_data_array_insert_after";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null data", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v24 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_protocol_data_array_insert_after";
      v35 = 2082;
      v36 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  if (!v7)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_data_array_insert_after";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null other_data", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null other_data, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v26 = type;
    v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_data_array_insert_after";
        _os_log_impl(&dword_181A5C000, v14, v26, "%{public}s called with null other_data, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_protocol_data_array_insert_after";
      v35 = 2082;
      v36 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null other_data, dumping backtrace:%{public}s",  buf,  0x16u);
    }
}

    if (v36) {
      free(v36);
    }
    goto LABEL_6;
  }

  v13 = *(id *)(v2 + 144);
  v14 = v13;
  if (v13)
  {
    v15 = v13;
    os_unfair_lock_lock((os_unfair_lock_t)v15 + 28);
    v16 = *((id *)v15 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v15 + 28);

    v17 = *(void *)(*(void *)(a1 + 40) + 8LL);
    v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;
  }

  else
  {
    v25 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (v25 && !nw_path_parameters_get_logging_disabled(*(void *)(v25 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v26 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v27 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)buf = 136446466;
        v48 = "nw_connection_copy_current_path_block_invoke";
        v49 = 1024;
        LODWORD(v50) = v27;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Connection has no endpoint handler",  buf,  0x12u);
      }
    }
  }
}
}

      free(v27);
      if (!v21) {
        return;
      }
LABEL_104:
      free(v21);
      return;
    }

    v22 = (os_log_s *)__nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type)) {
      goto LABEL_103;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_http_client_report_transfer_size";
    v24 = "%{public}s called with null http_client";
LABEL_102:
    _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
    goto LABEL_103;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_http_client_report_transfer_size";
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = (os_log_s *)__nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_http_client_report_transfer_size";
      v24 = "%{public}s called with null size";
      goto LABEL_102;
    }

    if (!v58)
    {
      v22 = (os_log_s *)__nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_http_client_report_transfer_size";
      v24 = "%{public}s called with null size, backtrace limit exceeded";
      goto LABEL_102;
    }

    v27 = (char *)__nw_create_backtrace_string();
    v22 = (os_log_s *)__nwlog_obj();
    v23 = type;
    v37 = os_log_type_enabled(v22, type);
    if (!v27)
    {
      if (!v37) {
        goto LABEL_103;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_http_client_report_transfer_size";
      v24 = "%{public}s called with null size, no backtrace";
      goto LABEL_102;
    }

    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_http_client_report_transfer_size";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v27;
      v29 = "%{public}s called with null size, dumping backtrace:%{public}s";
      goto LABEL_55;
    }

    goto LABEL_56;
  }

  v7 = nw_http_client_metadata_copy_current_transaction_metadata(handle[72]);
  v8 = v7;
  v9 = a3;
  if (!a4)
  {
    v16 = v7;
    v11 = v16;
    if (v8)
    {
      v17 = v16;
      v18 = *((id *)v17 + 1);

      if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_59_74543);
      }
      is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v18,  nw_protocol_copy_http_transaction_definition_definition);

      if (is_equal_unsafe)
      {
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = __nw_http_transaction_metadata_increment_outbound_body_size_block_invoke;
        v61 = &__block_descriptor_40_e9_B16__0_v8l;
        v62 = v9;
        v20 = *((void *)v17 + 4);
        if (v20) {
          __nw_http_transaction_metadata_increment_outbound_body_size_block_invoke((uint64_t)buf, v20);
        }
        goto LABEL_18;
      }

      __nwlog_obj();
      v40 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http_transaction_metadata_increment_outbound_body_size";
      v31 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v58 = 0;
      if (__nwlog_fault(v31, &type, &v58))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v41 = type;
          if (os_log_type_enabled(v35, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http_transaction_metadata_increment_outbound_body_size";
            _os_log_impl(&dword_181A5C000, v35, v41, "%{public}s metadata must be http_transaction", buf, 0xCu);
          }
        }

        else if (v58)
        {
          v51 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v52 = type;
          v53 = os_log_type_enabled(v35, type);
          if (v51)
          {
            if (v53)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_http_transaction_metadata_increment_outbound_body_size";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v51;
              _os_log_impl( &dword_181A5C000,  v35,  v52,  "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v51);
            if (!v31) {
              goto LABEL_18;
            }
            goto LABEL_133;
          }

          if (v53)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http_transaction_metadata_increment_outbound_body_size";
            _os_log_impl( &dword_181A5C000,  v35,  v52,  "%{public}s metadata must be http_transaction, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v57 = type;
          if (os_log_type_enabled(v35, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_http_transaction_metadata_increment_outbound_body_size";
            _os_log_impl( &dword_181A5C000,  v35,  v57,  "%{public}s metadata must be http_transaction, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_131;
      }

  if (v11) {
    free(v11);
  }
  return 0LL;
}

    free(v27);
    goto LABEL_57;
  }

  mode = v3->mode;

  if (mode != 1) {
    goto LABEL_38;
  }
  v6 = (id *)nw_endpoint_handler_copy_resolver(v4);
  v7 = (const unsigned __int8 *)v6[1];
  v8 = (unsigned __int8 *)v7;
  if (!v7)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_resolver_get_resolution_provider";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v16, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_resolver_get_resolution_provider";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null resolver", buf, 0xCu);
        }
      }

      else if (v36)
      {
        v22 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v23 = type;
        v24 = os_log_type_enabled(v17, type);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = "nw_resolver_get_resolution_provider";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v22;
            _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v22);
          goto LABEL_65;
        }

        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_resolver_get_resolution_provider";
          _os_log_impl(&dword_181A5C000, v17, v23, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v35 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_resolver_get_resolution_provider";
          _os_log_impl( &dword_181A5C000,  v17,  v35,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v32) {
    free(v32);
  }
  v29 = 0LL;
LABEL_29:

  return v29;
}

  *(_DWORD *)(v5 + 172) = self->_trafficClass;
  *(_WORD *)(v5 + 196) |= 0x20u;
  has = (__int16)self->_has;
  if ((has & 2) == 0)
  {
LABEL_5:
    if ((has & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_58;
  }

        free(v25);
        goto LABEL_57;
      }

      *(_DWORD *)buf = 136446210;
      v50 = "nw_socks5_server_register_udp_associate_request";
      v28 = "%{public}s called with null socks5_connection";
    }

    else
    {
      if (v47)
      {
        v35 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        log = (os_log_s *)objc_claimAutoreleasedReturnValue();
        type = v48;
        v36 = os_log_type_enabled(log, v48);
        if (v35)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            v50 = "nw_socks5_server_register_udp_associate_request";
            v51 = 2082;
            v52 = v35;
            _os_log_impl( &dword_181A5C000,  log,  type,  "%{public}s called with null socks5_connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v35);
          if (!v25) {
            goto LABEL_57;
          }
        }

        else
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446210;
            v50 = "nw_socks5_server_register_udp_associate_request";
            _os_log_impl( &dword_181A5C000,  log,  type,  "%{public}s called with null socks5_connection, no backtrace",  buf,  0xCu);
          }

          if (!v25) {
            goto LABEL_57;
          }
        }

        goto LABEL_56;
      }

      __nwlog_obj();
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      v27 = v48;
      if (!os_log_type_enabled((os_log_t)v26, v48)) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      v50 = "nw_socks5_server_register_udp_associate_request";
      v28 = "%{public}s called with null socks5_connection, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, (os_log_t)v26, v27, v28, buf, 0xCu);
    goto LABEL_54;
  }

  if (v12) {
LABEL_57:
  }
    free(v12);
}

      free(backtrace_string);
      goto LABEL_89;
    }

    v20 = (os_log_s *)__nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_89;
    }
    *(_DWORD *)buf = 136446210;
    v52 = "nw_http2_transport_drain_next_frame_for_stream";
    v22 = "%{public}s called with null http2_transport";
LABEL_88:
    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
LABEL_89:
    if (v19) {
      free(v19);
    }
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v52 = "nw_http2_transport_drain_next_frame_for_stream";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = (os_log_s *)__nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      v52 = "nw_http2_transport_drain_next_frame_for_stream";
      v22 = "%{public}s called with null input_handler";
      goto LABEL_88;
    }

    if (!v49)
    {
      v20 = (os_log_s *)__nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      v52 = "nw_http2_transport_drain_next_frame_for_stream";
      v22 = "%{public}s called with null input_handler, backtrace limit exceeded";
      goto LABEL_88;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = (os_log_s *)__nwlog_obj();
    v21 = type;
    v30 = os_log_type_enabled(v20, type);
    if (backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        v52 = "nw_http2_transport_drain_next_frame_for_stream";
        v53 = 2082;
        v54 = backtrace_string;
        v29 = "%{public}s called with null input_handler, dumping backtrace:%{public}s";
        goto LABEL_55;
      }

      goto LABEL_56;
    }

    if (!v30) {
      goto LABEL_89;
    }
    *(_DWORD *)buf = 136446210;
    v52 = "nw_http2_transport_drain_next_frame_for_stream";
    v22 = "%{public}s called with null input_handler, no backtrace";
    goto LABEL_88;
  }

  v8 = *(void *)(a3 + 16);
  if (!v8)
  {
    if (gLogDatapath)
    {
      v37 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v52 = "nw_http2_transport_drain_next_frame_for_stream";
        v53 = 2082;
        v54 = (void *)(a1 + 205);
        _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s no next frame to drain",  buf,  0x16u);
        return 0LL;
      }
    }

    return 0LL;
  }

  if (gLogDatapath)
  {
    v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      v24 = *(_DWORD *)(v8 + 52);
      if (v24) {
        v24 -= *(_DWORD *)(v8 + 56) + *(_DWORD *)(v8 + 60);
      }
      *(_DWORD *)buf = 136446722;
      v52 = "nw_http2_transport_drain_next_frame_for_stream";
      v53 = 2082;
      v54 = (void *)(a1 + 205);
      v55 = 1024;
      *(_DWORD *)v56 = v24;
      _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s draining output frame of %u bytes",  buf,  0x1Cu);
    }
  }

  v9 = nw_http2_transport_submit_data(a1, v8);
  v10 = gLogDatapath;
  if (v9)
  {
    if (gLogDatapath)
    {
      v38 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v39 = *(_DWORD *)(v8 + 52);
        if (v39) {
          v39 -= *(_DWORD *)(v8 + 56) + *(_DWORD *)(v8 + 60);
        }
        v40 = *(_DWORD *)(a3 + 32);
        *(_DWORD *)buf = 136446978;
        v52 = "nw_http2_transport_drain_next_frame_for_stream";
        v53 = 2082;
        v54 = (void *)(a1 + 205);
        v55 = 1024;
        *(_DWORD *)v56 = v39;
        *(_WORD *)&v56[4] = 1024;
        *(_DWORD *)&v56[6] = v40;
        _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s drained %u output bytes for stream %d",  buf,  0x22u);
      }
    }

    v11 = *(void *)(v8 + 16);
    v12 = *(void **)(v8 + 24);
    if (v11)
    {
      *(void *)(v11 + 24) = v12;
      v12 = *(void **)(v8 + 24);
    }

    else
    {
      *(void *)(a3 + 24) = v12;
    }

    *v12 = v11;
    *(void *)(v8 + 16) = 0LL;
    *(void *)(v8 + 24) = 0LL;
    v10 = gLogDatapath;
  }

  if (v10)
  {
    v25 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)(a3 + 16), 0, buf);
      v26 = *(_DWORD *)buf;
      *(_DWORD *)buf = 136446722;
      v52 = "nw_http2_transport_drain_next_frame_for_stream";
      v53 = 2082;
      v54 = (void *)(a1 + 205);
      v55 = 1024;
      *(_DWORD *)v56 = v26;
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s stream now has %u bytes pending",  buf,  0x1Cu);
    }
  }

  if (a4) {
    nw_http2_transport_session_send(a1);
  }
  v13 = *(void *)(a3 + 16);
  if (!v9)
  {
LABEL_23:
    if (v13) {
      return v9;
    }
    goto LABEL_24;
  }

  if (v13) {
    return 1LL;
  }
  if ((*(_BYTE *)(a3 + 36) & 4) != 0)
  {
    if (gLogDatapath)
    {
      v47 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v52 = "nw_http2_transport_drain_next_frame_for_stream";
        v53 = 2082;
        v54 = (void *)(a1 + 205);
        _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s sending deferred end stream",  buf,  0x16u);
      }
    }

    nw_http2_transport_send_end_stream(a1, a3);
    v13 = *(void *)(a3 + 16);
    goto LABEL_23;
  }

    if (v17)
    {
      v43 = (char *)v17;
LABEL_58:
      free(v43);
      return 1LL;
    }

    return 1LL;
  }

  v5 = object;
  v6 = *(void *)nw_hash_node_get_extra(a2);
  if (v6)
  {
    if ((*(_BYTE *)(v6 + 36) & 1) != 0)
    {
      v34 = *(void *)(v5 + 24);
      if (!v34 || (v27 = *(void (**)(uint64_t, void))(v34 + 184)) == 0LL)
      {
        __nwlog_obj();
        v48 = *(const char **)(v5 + 16);
        if (!v48) {
          v48 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
        v61 = 2082;
        v62 = v48;
        v29 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v57 = 0;
        if (__nwlog_fault(v29, &type, &v57))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v30 = (os_log_s *)__nwlog_obj();
            v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_100;
            }
            v49 = *(const char **)(v5 + 16);
            if (!v49) {
              v49 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
            v61 = 2082;
            v62 = v49;
            v33 = "%{public}s protocol %{public}s has invalid input_finished callback";
            goto LABEL_99;
          }

          if (!v57)
          {
            v30 = (os_log_s *)__nwlog_obj();
            v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_100;
            }
            v55 = *(const char **)(v5 + 16);
            if (!v55) {
              v55 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
            v61 = 2082;
            v62 = v55;
            v33 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
            goto LABEL_99;
          }

          v50 = (char *)__nw_create_backtrace_string();
          v30 = (os_log_s *)__nwlog_obj();
          v31 = type;
          v51 = os_log_type_enabled(v30, type);
          if (!v50)
          {
            if (!v51) {
              goto LABEL_100;
            }
            v56 = *(const char **)(v5 + 16);
            if (!v56) {
              v56 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
            v61 = 2082;
            v62 = v56;
            v33 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
            goto LABEL_99;
          }

          if (v51)
          {
            v52 = *(const char **)(v5 + 16);
            if (!v52) {
              v52 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v60 = "nw_protocol_http2_transport_input_finished_block_invoke";
            v61 = 2082;
            v62 = v52;
            v63 = 2082;
            v64 = (uint64_t)v50;
            _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v50);
        }

    free(v25);
    if (!v13) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_76;
  }

  if (*(_DWORD *)(v1 + 852))
  {
    if ((*(_BYTE *)(v1 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v17 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          v18 = *(void *)(v1 + 488);
          v19 = *(_DWORD *)(*(void *)(v1 + 480) + 372LL);
          v20 = *(_DWORD *)(v1 + 860);
          if (v18) {
            LODWORD(v18) = *(_DWORD *)(v18 + 424);
          }
          v21 = *(_DWORD *)(v1 + 852);
          v22 = *(void *)(v1 + 824);
          *(_DWORD *)buf = 136448002;
          v33 = "nw_http1_on_method_complete";
          v34 = 2082;
          v35 = (char *)(v1 + 74);
          v36 = 2080;
          v37 = " ";
          v38 = 1024;
          v39 = v19;
          v40 = 1024;
          v41 = v20;
          v42 = 1024;
          v43 = v18;
          v44 = 1040;
          v45 = v21;
          v46 = 2080;
          v47 = v22;
          _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> url complete:  %.*s",  buf,  0x42u);
        }
      }
    }
  }

  v4 = *(const char **)(v1 + 816);
  if (!v4)
  {
    *(_DWORD *)(v1 + 848) = 0;
    goto LABEL_14;
  }

  v5 = *(unsigned int *)(v1 + 848);
  v6 = v3;
  v7 = _nw_http_parsed_fields_add((uint64_t)v6, (unint64_t)":method", -1LL, v4, v5, 1);

  v8 = *(void **)(v1 + 816);
  if (!v8)
  {
    *(_DWORD *)(v1 + 848) = 0;
    if (v7) {
      goto LABEL_14;
    }
    return 0xFFFFFFFFLL;
  }

  free(v8);
  *(void *)(v1 + 816) = 0LL;
  *(_DWORD *)(v1 + 848) = 0;
  if ((v7 & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
LABEL_14:
  if ((*(_BYTE *)(*(void *)(v1 + 480) + 376LL) & 2) != 0) {
    v9 = "https";
  }
  else {
    v9 = "http";
  }
  v10 = v3;
  v11 = _nw_http_parsed_fields_add((uint64_t)v10, (unint64_t)":scheme", -1LL, v9, -1LL, 1);

  return (v11 - 1);
}

      free(backtrace_string);
      goto LABEL_76;
    }

    if (!v23) {
      goto LABEL_76;
    }
    *(_DWORD *)__str = 136446210;
    v29 = "nw_http1_on_status_complete";
    v17 = "%{public}s called with null parsed_fields, no backtrace";
LABEL_75:
    _os_log_impl(&dword_181A5C000, v15, v16, v17, (uint8_t *)__str, 0xCu);
LABEL_76:
    if (v14) {
      free(v14);
    }
    return 0xFFFFFFFFLL;
  }

  if (*(unsigned __int16 *)(a1 + 84) > 0x3E7u)
  {
    if ((*(_BYTE *)(v1 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v11 = *(void *)(v1 + 488);
        v12 = *(_DWORD *)(*(void *)(v1 + 480) + 372LL);
        v13 = *(_DWORD *)(v1 + 860);
        if (v11) {
          LODWORD(v11) = *(_DWORD *)(v11 + 424);
        }
        *(_DWORD *)__str = 136447490;
        v29 = "nw_http1_on_status_complete";
        v30 = 2082;
        v31 = (char *)(v1 + 74);
        v32 = 2080;
        v33 = " ";
        v34 = 1024;
        v35 = v12;
        v36 = 1024;
        v37 = v13;
        v38 = 1024;
        v39 = v11;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> invalid status code",  (uint8_t *)__str,  0x32u);
      }
    }

    return 0xFFFFFFFFLL;
  }

  snprintf(__str, 4uLL, "%03d", *(unsigned __int16 *)(a1 + 84));
  v4 = v3;
  _nw_http_parsed_fields_add((uint64_t)v4, (unint64_t)":status", -1LL, __str, 3LL, 1);

  v5 = *(const char **)(v1 + 832);
  if (!v5)
  {
LABEL_15:
    result = 0LL;
    *(_WORD *)(v1 + 872) |= 1u;
    return result;
  }

  v6 = strndup(v5, *(unsigned int *)(v1 + 856));
  if (v6)
  {
LABEL_8:
    v7 = *(char **)(v2 + 416);
    if (v7 != v6)
    {
      if (v7) {
        free(v7);
      }
      *(void *)(v2 + 416) = v6;
    }

    v8 = *(void **)(v1 + 832);
    if (v8)
    {
      free(v8);
      *(void *)(v1 + 832) = 0LL;
    }

    *(_DWORD *)(v1 + 856) = 0;
    goto LABEL_15;
  }

  v24 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__str = 136446210;
  v29 = "strict_strndup";
  v25 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v25);
  if (!(_DWORD)result)
  {
    free(v25);
    goto LABEL_8;
  }

  __break(1u);
  return result;
}

  if (v24) {
    free(v24);
  }
  return 0LL;
}

    goto LABEL_57;
  }

  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (os_log_s *)(id)gLogObj;
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null identifier", aBlock, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (os_log_s *)(id)gLogObj;
      v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null identifier, backtrace limit exceeded",  aBlock,  0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (os_log_s *)(id)gLogObj;
    v24 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null identifier, no backtrace", aBlock, 0xCu);
      }

      goto LABEL_56;
    }

    if (v25)
    {
      *(_DWORD *)aBlock = 136446466;
      *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
      *(_WORD *)&aBlock[12] = 2082;
      *(void *)&aBlock[14] = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  aBlock,  0x16u);
    }

    goto LABEL_37;
  }

  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (id)gLogObj;
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (os_log_s *)(id)gLogObj;
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null enumerator", aBlock, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (os_log_s *)(id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null enumerator, backtrace limit exceeded",  aBlock,  0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (os_log_s *)(id)gLogObj;
    v26 = type;
    v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_181A5C000, v14, v26, "%{public}s called with null enumerator, no backtrace", aBlock, 0xCu);
      }

      goto LABEL_56;
    }

    if (v27)
    {
      *(_DWORD *)aBlock = 136446466;
      *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
      *(_WORD *)&aBlock[12] = 2082;
      *(void *)&aBlock[14] = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  aBlock,  0x16u);
    }

  if (v13) {
    free(v13);
  }
  v9 = 0LL;
LABEL_7:

  return v9;
}

      if (v18)
      {
        v43 = *(void **)(a1 + 32);
        if (v43) {
          v43 = (void *)v43[66];
        }
        v44 = v43;
        [v44 firstObject];
        v45 = (void *)objc_claimAutoreleasedReturnValue();

        v46 = *(void *)(a1 + 32);
        if (v46) {
          v47 = *(void **)(v46 + 528);
        }
        else {
          v47 = 0LL;
        }
        objc_msgSend(v47, "removeObjectAtIndex:", 0, v59);
        v48 = *(void *)(a1 + 32);
        if (v48)
        {
          v49 = 248LL;
          if (!*(void *)(v48 + 248)) {
            v49 = 240LL;
          }
          v50 = (void **)*(id *)(v48 + v49);
        }

        else
        {
          v50 = 0LL;
        }

        v61[0] = MEMORY[0x1895F87A8];
        v61[1] = 3221225472LL;
        v61[2] = __43__NWURLSessionWebSocketTask_receiveMessage__block_invoke_511;
        v61[3] = &unk_189BC91E8;
        v63 = v45;
        v62 = v18;
        v51 = v45;
        if (v50) {
          -[NWURLSessionDelegateQueue runDelegateBlock:](v50[6], v61);
        }
      }

      v52 = *(id **)(a1 + 32);
      if (!v25) {
        goto LABEL_72;
      }
LABEL_69:
      if (!v52)
      {
        v58 = 0LL;
        if ((v17 & 1) == 0) {
          goto LABEL_73;
        }
        goto LABEL_86;
      }

      if (!v52[65])
      {
        objc_storeStrong(v52 + 65, v25);
        v52 = *(id **)(a1 + 32);
      }

    goto LABEL_57;
  }

  if (!v3->pendingUnverifiedIncomingRequests)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (!v26)
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests, no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
      v30 = 2082;
      v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  if (!v4)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null request", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v26)
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
      v30 = 2082;
      v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
    }

      v64 = v45 + 480;
      do
      {
        do
          uuid_generate_random((unsigned __int8 *)v45 + 480);
        while (!*v64);
      }

      while (!*((_DWORD *)v45 + 121) || !*((_DWORD *)v45 + 122) || !*((_DWORD *)v45 + 123));
      if ((*(_BYTE *)(*(void *)(a1 + 40) + 152LL) & 1) != 0)
      {
        __nwlog_obj();
        v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
        {
          v88 = *(void *)(a1 + 40);
          LODWORD(buf[0]) = 136446722;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          WORD6(buf[0]) = 2114;
          *(void *)((char *)buf + 14) = v88;
          WORD3(buf[1]) = 2114;
          *((void *)&buf[1] + 1) = v45;
          _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ using large TEST UUID for request: %{public}@",  (uint8_t *)buf,  0x20u);
        }

        *v64 = -1;
        if (!v36) {
          goto LABEL_107;
        }
LABEL_63:
        v45[616] |= 0x10u;
        nwsc_schedule_prexisting_connection_retry( *(NWConcrete_nw_service_connector **)(a1 + 40),  (NWConcrete_nw_unique_connection_request *)v45,  v125,  0);
      }

      else
      {
        if (v36) {
          goto LABEL_63;
        }
LABEL_107:
        v89 = *(_DWORD **)(a1 + 40);
        if (v89[4] == 1)
        {
          v45[616] |= 8u;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v90 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          {
            v91 = *(void *)(a1 + 40);
            LODWORD(buf[0]) = 136446722;
            *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
            WORD6(buf[0]) = 2114;
            *(void *)((char *)buf + 14) = v91;
            WORD3(buf[1]) = 2114;
            *((void *)&buf[1] + 1) = v45;
            _os_log_impl( &dword_181A5C000,  v90,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ holding request for listener ready: %{public}@",  (uint8_t *)buf,  0x20u);
          }
        }

        else
        {
          nwsc_request_create_and_start_connection_inner(v89, v45, 0LL);
          v92 = (void *)objc_claimAutoreleasedReturnValue();
          v93 = v92 == 0LL;

          if (v93)
          {
            nw_service_connector_cancel_request_inner(*(void **)(a1 + 40), *v48, (uint64_t)(v45 + 24), 0LL, 0);
            nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), v45, 0LL, 0LL, 12);
            goto LABEL_129;
          }
        }
      }

      v94 = (uint64_t *)*(id *)(a1 + 40);
      v83 = v45;
      if (v94)
      {
        if (v94[12])
        {
          v137 = 0;
          memset(buf, 0, sizeof(buf));
          if (nwsc_get_identifier(*v48, (uint64_t)(v45 + 24), buf))
          {
            nw_dictionary_set_value(v94[12], (const char *)buf, v83);
LABEL_138:

            goto LABEL_139;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v95 = (id)gLogObj;
          v96 = *v48;
          *(_DWORD *)type = 136446722;
          *(void *)&type[4] = "nw_service_connector_add_active_outgoing_request";
          *(_WORD *)&type[12] = 2114;
          *(void *)&type[14] = v96;
          *(_WORD *)&type[22] = 2082;
          v133 = v45 + 24;
          v97 = (void *)_os_log_send_and_compose_impl();

          v131 = OS_LOG_TYPE_ERROR;
          v130 = 0;
          if (__nwlog_fault((const char *)v97, &v131, &v130))
          {
            if (v131 == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v98 = (os_log_s *)(id)gLogObj;
              v99 = v131;
              if (os_log_type_enabled(v98, v131))
              {
                v100 = *v48;
                *(_DWORD *)type = 136446722;
                *(void *)&type[4] = "nw_service_connector_add_active_outgoing_request";
                *(_WORD *)&type[12] = 2114;
                *(void *)&type[14] = v100;
                *(_WORD *)&type[22] = 2082;
                v133 = v53;
                _os_log_impl( &dword_181A5C000,  v98,  v99,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s",  type,  0x20u);
              }

              goto LABEL_120;
            }

            if (v130)
            {
              v101 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v103 = v131;
              v104 = os_log_type_enabled(v102, v131);
              if (v101)
              {
                if (v104)
                {
                  v105 = *v48;
                  *(_DWORD *)type = 136446978;
                  *(void *)&type[4] = "nw_service_connector_add_active_outgoing_request";
                  *(_WORD *)&type[12] = 2114;
                  *(void *)&type[14] = v105;
                  *(_WORD *)&type[22] = 2082;
                  v133 = v53;
                  v134 = 2082;
                  v135 = v101;
                  _os_log_impl( &dword_181A5C000,  v102,  v103,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s",  type,  0x2Au);
                }

LABEL_126:
                free(v101);
                if (!v97) {
                  goto LABEL_138;
                }
LABEL_137:
                free(v97);
                goto LABEL_138;
              }

              if (v104)
              {
                v108 = *v48;
                *(_DWORD *)type = 136446722;
                *(void *)&type[4] = "nw_service_connector_add_active_outgoing_request";
                *(_WORD *)&type[12] = 2114;
                *(void *)&type[14] = v108;
                *(_WORD *)&type[22] = 2082;
                v133 = v53;
                _os_log_impl( &dword_181A5C000,  v102,  v103,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace",  type,  0x20u);
              }
            }

            else
            {
              __nwlog_obj();
              v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v106 = v131;
              if (os_log_type_enabled(v98, v131))
              {
                v107 = *v48;
                *(_DWORD *)type = 136446722;
                *(void *)&type[4] = "nw_service_connector_add_active_outgoing_request";
                *(_WORD *)&type[12] = 2114;
                *(void *)&type[14] = v107;
                *(_WORD *)&type[22] = 2082;
                v133 = v53;
                _os_log_impl( &dword_181A5C000,  v98,  v106,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded",  type,  0x20u);
              }

      v67 = v47 + 7;
      v68 = ((v47 + 7) & 0xF8) - v47;
      v69 = v28 << v68;
      v70 = v69 | ~(-1 << v68);
      switch(v67 >> 3)
      {
        case 2u:
          goto LABEL_63;
        case 3u:
          goto LABEL_62;
        case 4u:
          goto LABEL_61;
        case 5u:
          goto LABEL_60;
        case 6u:
          goto LABEL_59;
        case 7u:
          goto LABEL_58;
        case 8u:
          *v66++ = HIBYTE(v69);
LABEL_58:
          *v66++ = BYTE6(v69);
LABEL_59:
          *v66++ = BYTE5(v69);
LABEL_60:
          *v66++ = BYTE4(v69);
LABEL_61:
          *v66++ = HIBYTE(v70);
LABEL_62:
          *v66++ = BYTE2(v70);
LABEL_63:
          *v66++ = BYTE1(v70);
          break;
        default:
          break;
      }

      *v66 = v70;
      LODWORD(v66) = (_DWORD)v66 + 1;
      goto LABEL_65;
    }

    return 0xFFFFFFFFLL;
  }

  v29 = ~(-1LL << a1);
  v30 = vdupq_n_s64(-1LL << a1);
  else {
    v31 = 2;
  }
  v32 = (uint64x2_t)vdupq_n_s64(__n);
  v33 = (int16x8_t)vandq_s8( (int8x16_t)vuzp1q_s16( (int16x8_t)vuzp1q_s32( (int32x4_t)vcgeq_u64( v32,  (uint64x2_t)vsubq_s64((int64x2_t)xmmword_18272D7B0, v30)),  (int32x4_t)vcgeq_u64( v32,  (uint64x2_t)vsubq_s64((int64x2_t)xmmword_18272D7C0, v30))),  (int16x8_t)vuzp1q_s32( (int32x4_t)vcgeq_u64( v32,  (uint64x2_t)vsubq_s64((int64x2_t)xmmword_18272D7D0, v30)),  (int32x4_t)vcgeq_u64( v32,  (uint64x2_t)vsubq_s64((int64x2_t)xmmword_18272D7E0, v30)))),  (int8x16_t)xmmword_18272D7F0);
  v33.i32[0] = vaddvq_s16(v33);
  *(int8x8_t *)v33.i8 = vcnt_s8(*(int8x8_t *)v33.i8);
  v33.i16[0] = vaddlv_u8(*(uint8x8_t *)v33.i8);
  v34 = v31 + v33.i32[0];
  v35 = (v34 + __n);
  if (v35 > a3) {
    return 0xFFFFFFFFLL;
  }
  v36 = *a2 & (-2 << a1);
  if (v29 <= __n)
  {
    v41 = -1 << a1;
    v42 = ~v41;
    *a2 = v36 | ~(_BYTE)v41;
    v43 = a2 + 1;
    v44 = __n - v42;
    if (v44 < 0x80)
    {
      LOBYTE(v42) = __n - v42;
    }

    else
    {
      do
      {
        *v43++ = v44 | 0x80;
        v42 = v44 >> 7;
        v45 = v44 >> 14;
        v44 >>= 7;
      }

      while (v45);
    }

    *v43 = v42;
  }

  else
  {
    *a2 = v36 | __n;
  }

  memcpy(&a2[v34], __src, __n);
  return v35;
}

    goto LABEL_57;
  }

  if (!v6)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_resolver_config_watch_updates";
    v14 = (char *)_os_log_send_and_compose_impl();

    v36 = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v18 = v36;
      if (os_log_type_enabled(v15, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v35)
    {
      __nwlog_obj();
      v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = v36;
      if (os_log_type_enabled(v15, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_resolver_config_watch_updates";
        _os_log_impl( &dword_181A5C000,  v15,  v30,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v24 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v25 = v36;
    v26 = os_log_type_enabled(v15, v36);
    if (!v24)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A5C000, v15, v25, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_resolver_config_watch_updates";
      v39 = 2082;
      v40 = v24;
      _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  if (!v7)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_resolver_config_watch_updates";
    v14 = (char *)_os_log_send_and_compose_impl();

    v36 = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v20 = v36;
      if (os_log_type_enabled(v15, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s called with null update_handler", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v35)
    {
      __nwlog_obj();
      v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = v36;
      if (os_log_type_enabled(v15, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_resolver_config_watch_updates";
        _os_log_impl( &dword_181A5C000,  v15,  v31,  "%{public}s called with null update_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v24 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v27 = v36;
    v28 = os_log_type_enabled(v15, v36);
    if (!v24)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A5C000, v15, v27, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_resolver_config_watch_updates";
      v39 = 2082;
      v40 = v24;
      _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null update_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_57;
  }

  if (!v6)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v36)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v24 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  if (!v7)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null completion", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v36)
    {
      __nwlog_obj();
      v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null completion, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v26 = type;
    v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A5C000, v14, v26, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_resolver_config_cancel_updates";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null completion, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    v36 = 0LL;
LABEL_57:
    v20 += v27 + 5;
    if (v20 > a11) {
      break;
    }
    if ((_DWORD)v27) {
      v38 = v36 == 0LL;
    }
    else {
      v38 = 1;
    }
    if (!v38)
    {
      switch(v26)
      {
        case 1:
          if ((_DWORD)v27 == 16) {
            goto LABEL_64;
          }
          if (v27 >= 0x11)
          {
            __nwlog_obj();
            v434 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v434, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 1;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = 16;
              _os_log_impl( &dword_181A5C000,  v434,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_64:
            v39 = parameters;
            *(_OWORD *)(*((void *)parameters + 13) + 24LL) = *(_OWORD *)v36;
          }

          break;
        case 2:
          if ((_DWORD)v27 == 16) {
            goto LABEL_170;
          }
          if (v27 >= 0x11)
          {
            __nwlog_obj();
            v449 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v449, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 2;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = 16;
              _os_log_impl( &dword_181A5C000,  v449,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_170:
            v89 = parameters;
            *(_OWORD *)(*((void *)parameters + 13) + 8LL) = *(_OWORD *)v36;
          }

          break;
        case 3:
        case 12:
        case 13:
        case 37:
          break;
        case 4:
          if (v36[(v27 - 1)])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v90 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = "nw_path_parse_necp_parameters";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v27;
            v91 = (const char *)_os_log_send_and_compose_impl();

            uu[0] = 16;
            v561 = OS_LOG_TYPE_DEFAULT;
            if (uu[0] == 17)
            {
              __nwlog_obj();
              v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v93 = uu[0];
              if (os_log_type_enabled(v92, (os_log_type_t)uu[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v27;
                _os_log_impl( &dword_181A5C000,  v92,  v93,  "%{public}s NECP_CLIENT_PARAMETER_ACCOUNT of length %u not NULL-terminated",  buf,  0x12u);
              }

              goto LABEL_897;
            }

            if (v561)
            {
              v189 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v190 = uu[0];
              v191 = os_log_type_enabled(v92, (os_log_type_t)uu[0]);
              if (v189)
              {
                if (v191)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v27;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v189;
                  _os_log_impl( &dword_181A5C000,  v92,  v190,  "%{public}s NECP_CLIENT_PARAMETER_ACCOUNT of length %u not NULL-terminated, dumping backtrace:%{public}s",  buf,  0x1Cu);
                }

                free(v189);
                goto LABEL_898;
              }

              if (v191)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v27;
                _os_log_impl( &dword_181A5C000,  v92,  v190,  "%{public}s NECP_CLIENT_PARAMETER_ACCOUNT of length %u not NULL-terminated, no backtrace",  buf,  0x12u);
              }
            }

            else
            {
              __nwlog_obj();
              v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v210 = uu[0];
              if (os_log_type_enabled(v92, (os_log_type_t)uu[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v27;
                _os_log_impl( &dword_181A5C000,  v92,  v210,  "%{public}s NECP_CLIENT_PARAMETER_ACCOUNT of length %u not NULL-terminated, backtrace limit exceeded",  buf,  0x12u);
              }
            }

            goto LABEL_897;
          }

          nw_parameters_set_account_id(parameters, v36);
          break;
        case 6:
          if ((_DWORD)v27 == 4) {
            goto LABEL_98;
          }
          if (v27 >= 5)
          {
            __nwlog_obj();
            v441 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v441, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 6;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = 4;
              _os_log_impl( &dword_181A5C000,  v441,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_98:
            v53 = *(_DWORD *)v36;
            v54 = parameters;
            *(_DWORD *)(*((void *)parameters + 13) + 64LL) = v53;
          }

          break;
        case 7:
          if ((_DWORD)v27 == 4) {
            goto LABEL_178;
          }
          if (v27 >= 5)
          {
            __nwlog_obj();
            v450 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v450, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 7;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = 4;
              _os_log_impl( &dword_181A5C000,  v450,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_178:
            v94 = *(_DWORD *)v36;
            v95 = parameters;
            *(_DWORD *)(*((void *)parameters + 13) + 68LL) = v94;
          }

          break;
        case 9:
          if (v27 <= 0x18)
          {
            bzero(&buf[v27], 24 - v27);
            memcpy(buf, v36, v27);
            v40 = (nw_interface *)nw_interface_create_with_name((char *)buf);
            if (v40) {
              nw_parameters_require_interface(parameters, v40);
            }
            goto LABEL_417;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v155 = (id)gLogObj;
          *(_DWORD *)buf = 136447234;
          *(void *)&buf[4] = "nw_path_parse_necp_parameters";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 9;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v27;
          *(_WORD *)&buf[24] = 2080;
          *(void *)&buf[26] = "nw_path_parse_necp_parameters";
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = 3032;
          v91 = (const char *)_os_log_send_and_compose_impl();

          uu[0] = 16;
          v561 = OS_LOG_TYPE_DEFAULT;
          if (uu[0] == 17)
          {
            __nwlog_obj();
            v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v156 = uu[0];
            if (os_log_type_enabled(v92, (os_log_type_t)uu[0]))
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&buf[4] = "nw_path_parse_necp_parameters";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 9;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 2080;
              *(void *)&buf[26] = "nw_path_parse_necp_parameters";
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 3032;
              _os_log_impl( &dword_181A5C000,  v92,  v156,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
            }

            goto LABEL_897;
          }

          if (v561)
          {
            v192 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v201 = uu[0];
            v202 = os_log_type_enabled(v92, (os_log_type_t)uu[0]);
            if (v192)
            {
              if (v202)
              {
                *(_DWORD *)buf = 136447490;
                *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 9;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v27;
                *(_WORD *)&buf[24] = 2080;
                *(void *)&buf[26] = "nw_path_parse_necp_parameters";
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = 3032;
                *(_WORD *)&buf[40] = 2082;
                *(void *)&buf[42] = v192;
                _os_log_impl( &dword_181A5C000,  v92,  v201,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
              }

              goto LABEL_422;
            }

            if (v202)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&buf[4] = "nw_path_parse_necp_parameters";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 9;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 2080;
              *(void *)&buf[26] = "nw_path_parse_necp_parameters";
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 3032;
              _os_log_impl( &dword_181A5C000,  v92,  v201,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }
          }

          else
          {
            __nwlog_obj();
            v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v215 = uu[0];
            if (os_log_type_enabled(v92, (os_log_type_t)uu[0]))
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&buf[4] = "nw_path_parse_necp_parameters";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 9;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 2080;
              *(void *)&buf[26] = "nw_path_parse_necp_parameters";
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 3032;
              _os_log_impl( &dword_181A5C000,  v92,  v215,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
            }
          }

          goto LABEL_897;
        case 10:
          if ((_DWORD)v27 == 4) {
            goto LABEL_180;
          }
          if (v27 >= 5)
          {
            __nwlog_obj();
            v451 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v451, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 10;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = 4;
              _os_log_impl( &dword_181A5C000,  v451,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_180:
            v96 = *(_DWORD *)v36;
            v97 = parameters;
            *(_DWORD *)(*((void *)parameters + 13) + 72LL) = v96;
          }

          break;
        case 11:
          if ((_DWORD)v27 != 2 && (_DWORD)v27 != 1)
          {
            __nwlog_obj();
            v465 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v465, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[4] = "nw_path_verify_tlv_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 11;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v27;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = 1;
              _os_log_impl( &dword_181A5C000,  v465,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }
          }

          v98 = *v36;
          if (!*v36) {
            break;
          }
          v99 = nw_parameters_copy_default_protocol_stack(parameters);
          v100 = nw_protocol_stack_copy_transport_protocol(v99);
          v101 = v100 == 0LL;

          if (!v101) {
            goto LABEL_465;
          }
          if (v98 == 6)
          {
            options = nw_tcp_create_options();
          }

          else
          {
            if (v98 != 17) {
              goto LABEL_465;
            }
            options = nw_udp_create_options();
          }

          v222 = options;
          nw_protocol_stack_set_transport_protocol(v99, options);

LABEL_465:
          v541 = v98;
          break;
        case 33:
          v55 = (v27 - 1);
          if (v36[v55])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v56 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = "nw_path_parse_necp_parameters";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v27;
            v57 = (char *)_os_log_send_and_compose_impl();

            uu[0] = 16;
            v561 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v57, uu, &v561))
            {
              if (uu[0] == 17)
              {
                __nwlog_obj();
                v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v59 = uu[0];
                if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v27;
                  _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s NECP_CLIENT_PARAMETER_DOMAIN_OWNER of length %u not NULL-terminated",  buf,  0x12u);
                }

                goto LABEL_468;
              }

              if (v561 == OS_LOG_TYPE_DEFAULT)
              {
                __nwlog_obj();
                v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v209 = uu[0];
                if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v27;
                  _os_log_impl( &dword_181A5C000,  v58,  v209,  "%{public}s NECP_CLIENT_PARAMETER_DOMAIN_OWNER of length %u not NULL-terminated, backtrace limit exceeded",  buf,  0x12u);
                }

                goto LABEL_468;
              }

              v187 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              type = uu[0];
              v188 = os_log_type_enabled(v58, (os_log_type_t)uu[0]);
              if (!v187)
              {
                if (v188)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v27;
                  _os_log_impl( &dword_181A5C000,  v58,  type,  "%{public}s NECP_CLIENT_PARAMETER_DOMAIN_OWNER of length %u not NULL-terminated, no backtrace",  buf,  0x12u);
                }

                goto LABEL_468;
              }

              if (v188)
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&buf[4] = "nw_path_parse_necp_parameters";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v27;
                *(_WORD *)&buf[18] = 2082;
                *(void *)&buf[20] = v187;
                _os_log_impl( &dword_181A5C000,  v58,  type,  "%{public}s NECP_CLIENT_PARAMETER_DOMAIN_OWNER of length %u not NULL-terminated, dumping backtrace:%{public}s",  buf,  0x1Cu);
              }

              free(v187);
            }

            goto LABEL_469;
          }

          if (!v552) {
            goto LABEL_471;
          }
          if (*v552)
          {
            nw_endpoint_set_tracker_owner(*v552, v36);
            goto LABEL_471;
          }

          __nwlog_obj();
          v218 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = "nw_path_parse_necp_parameters";
          v57 = (char *)_os_log_send_and_compose_impl();

          uu[0] = 16;
          v561 = OS_LOG_TYPE_DEFAULT;
          if (uu[0] == 17)
          {
            __nwlog_obj();
            v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v219 = uu[0];
            if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_path_parse_necp_parameters";
              _os_log_impl( &dword_181A5C000,  v58,  v219,  "%{public}s NECP_CLIENT_PARAMETER_DOMAIN_OWNER came before NECP_CLIENT_PARAMETER_REMOTE_ENDPOINT",  buf,  0xCu);
            }

            goto LABEL_468;
          }

          if (v561 == OS_LOG_TYPE_DEFAULT)
          {
            __nwlog_obj();
            v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v316 = uu[0];
            if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = "nw_path_parse_necp_parameters";
              _os_log_impl( &dword_181A5C000,  v58,  v316,  "%{public}s NECP_CLIENT_PARAMETER_DOMAIN_OWNER came before NECP_CLIENT_PARAMETER_REMOTE_ENDPOINT, backtra ce limit exceeded",  buf,  0xCu);
            }

        goto LABEL_57;
      }

      if (!v32)
      {
        __nwlog_obj();
        v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
          v26 = "%{public}s called with null interfaceIndex, backtrace limit exceeded";
          goto LABEL_55;
        }

        goto LABEL_56;
      }

      v28 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v25 = type;
      v29 = os_log_type_enabled(v24, type);
      if (!v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
          v26 = "%{public}s called with null interfaceIndex, no backtrace";
          goto LABEL_55;
        }

        goto LABEL_56;
      }

      if (!v29) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446466;
      v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
      v36 = 2082;
      *(void *)v37 = v28;
      v30 = "%{public}s called with null interfaceIndex, dumping backtrace:%{public}s";
      goto LABEL_45;
    }
  }

          v48 = *(unsigned __int16 *)(v23 + 736);
          if ((v48 & 0x400) != 0 && !*(void *)(v23 + 528) && !*(_BYTE *)(v23 + 634) && !*(_BYTE *)(v23 + 635))
          {
            v49 = v48 & 0xFFFFFBFF | (*(unsigned __int8 *)(v23 + 738) << 16);
            *(_WORD *)(v23 + 736) = v48 & 0xFBFF;
            *(_BYTE *)(v23 + 738) = BYTE2(v49);
            v50 = *(void *)(v23 + 32);
            if (!v50
              || (v51 = *(void *)(v50 + 24)) == 0
              || (v52 = *(void (**)(uint64_t, uint64_t))(v51 + 32)) == 0LL)
            {
              __nwlog_obj();
              v53 = *(void *)(v23 + 32);
              if (v53)
              {
                v54 = *(const char **)(v53 + 16);
                if (!v54) {
                  v54 = "invalid";
                }
              }

              else
              {
                v54 = "invalid";
              }

              *(_DWORD *)buf = 136446466;
              *(void *)&buf[4] = "nw_http3_stream_encoder_stream_output_available";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v54;
              v76 = (char *)_os_log_send_and_compose_impl();
              v118[0] = OS_LOG_TYPE_ERROR;
              v122[0] = 0;
              if (v118[0] == OS_LOG_TYPE_FAULT)
              {
                v77 = (os_log_s *)__nwlog_obj();
                v78 = v118[0];
                if (os_log_type_enabled(v77, v118[0]))
                {
                  v79 = *(void *)(v23 + 32);
                  if (v79)
                  {
                    v80 = *(const char **)(v79 + 16);
                    if (!v80) {
                      v80 = "invalid";
                    }
                  }

                  else
                  {
                    v80 = "invalid";
                  }

                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v80;
                  v92 = v77;
                  v93 = v78;
                  v94 = "%{public}s protocol %{public}s has invalid disconnect callback";
                  goto LABEL_142;
                }

                goto LABEL_143;
              }

              if (v122[0])
              {
                v81 = (char *)__nw_create_backtrace_string();
                v82 = (os_log_s *)__nwlog_obj();
                v109 = v118[0];
                v83 = os_log_type_enabled(v82, v118[0]);
                if (v81)
                {
                  if (v83)
                  {
                    v84 = *(void *)(v23 + 32);
                    if (v84)
                    {
                      v85 = *(const char **)(v84 + 16);
                      if (!v85) {
                        v85 = "invalid";
                      }
                    }

                    else
                    {
                      v85 = "invalid";
                    }

                    *(_DWORD *)buf = 136446722;
                    *(void *)&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v85;
                    *(_WORD *)&buf[22] = 2082;
                    *(void *)&buf[24] = v81;
                    _os_log_impl( &dword_181A5C000,  v82,  v109,  "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x20u);
                  }

                  free(v81);
                  goto LABEL_143;
                }

                if (!v83)
                {
LABEL_143:
                  if (v76) {
                    free(v76);
                  }
                  goto LABEL_30;
                }

                v90 = *(void *)(v23 + 32);
                if (v90)
                {
                  v91 = *(const char **)(v90 + 16);
                  if (!v91) {
                    v91 = "invalid";
                  }
                }

                else
                {
                  v91 = "invalid";
                }

                *(_DWORD *)buf = 136446466;
                *(void *)&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v91;
                v92 = v82;
                v93 = v109;
                v94 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
              }

              else
              {
                v86 = (os_log_s *)__nwlog_obj();
                v87 = v118[0];
                if (!os_log_type_enabled(v86, v118[0])) {
                  goto LABEL_143;
                }
                v88 = *(void *)(v23 + 32);
                if (v88)
                {
                  v89 = *(const char **)(v88 + 16);
                  if (!v89) {
                    v89 = "invalid";
                  }
                }

                else
                {
                  v89 = "invalid";
                }

                *(_DWORD *)buf = 136446466;
                *(void *)&buf[4] = "nw_http3_stream_encoder_stream_output_available";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v89;
                v92 = v86;
                v93 = v87;
                v94 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
              }

    goto LABEL_57;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  v40 = __Block_byref_object_copy__63069;
  v41 = __Block_byref_object_dispose__63070;
  v42 = 0LL;
  v34[0] = MEMORY[0x1895F87A8];
  v34[1] = 3221225472LL;
  v34[2] = ___ZL28nw_interpose_flow_get_lockedP23NWConcrete_nw_interposePU26objcproto15OS_nw_path_flow8NSObject_block_invoke;
  v34[3] = &unk_189BC7820;
  v9 = v6;
  v35 = v9;
  v36 = buf;
  nw_dictionary_apply(v8, (uint64_t)v34);
  v10 = *(id *)(*(void *)&buf[8] + 40LL);

  _Block_object_dispose(buf, 8);
  if (v10)
  {
    [v10 resetFlow:v9];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_interpose_handle_path_update_locked_block_invoke";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v12;
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] updated flow", buf, 0x16u);
    }

    goto LABEL_62;
  }

        v24 = *(void **)(v9 + 16);
        if (v24)
        {
          free(v24);
          *(void *)(v9 + 16) = 0LL;
        }

        v25 = *(void **)(v9 + 32);
        if (v25) {
          free(v25);
        }
        goto LABEL_66;
      }
    }

    else
    {
      v8 = 0;
      v7 = 0;
      v42 = 0LL;
    }

    if (((*(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16)) & 0x20000) != 0)
    {
LABEL_67:
      if (__dst[0].sa_len)
      {
        default_input_handler = a1[2].default_input_handler;
        if (default_input_handler)
        {
          os_release(default_input_handler);
          a1[2].default_input_handler = 0LL;
        }

        a1[2].default_input_handler = (nw_protocol *)nw_endpoint_create_address(__dst);
      }

      v27 = v43;
      if (v43)
      {
        output_handler_context = a1[2].output_handler_context;
        if (output_handler_context)
        {
          os_release(output_handler_context);
          a1[2].output_handler_context = 0LL;
          v27 = v43;
        }

        if (nw_context_copy_implicit_context::onceToken != -1) {
          dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
        }
        v29 = (id)nw_context_copy_implicit_context::implicit_context;
        v30 = nw_path_copy_interface_with_generation(v29, v27, 0);

        a1[2].output_handler_context = v30;
      }

      return;
    }

    v41 = 128;
    if (getsockname(v2, __dst, &v41))
    {
      v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v13 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v45 = "nw_socket_fillout_socket_properties";
        v46 = 2080;
        *(void *)v47 = (char *)a1 + 404;
        *(_WORD *)&v47[8] = 1024;
        *(_DWORD *)&v47[10] = v12;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s %s getsockname failed %{darwin.errno}d",  buf,  0x1Cu);
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v45 = "nw_socket_fillout_socket_properties";
      v46 = 1024;
      *(_DWORD *)v47 = v12;
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v39 = 0;
      if (__nwlog_fault((const char *)v9, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (os_log_s *)gLogObj;
          v15 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_65;
          }
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v12;
          v16 = "%{public}s getsockname failed %{darwin.errno}d";
          goto LABEL_64;
        }

        if (!v39)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (os_log_s *)gLogObj;
          v15 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_65;
          }
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v12;
          v16 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_64;
        }

        v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (os_log_s *)gLogObj;
        v15 = type;
        v21 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v20)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446722;
            v45 = "nw_socket_fillout_socket_properties";
            v46 = 1024;
            *(_DWORD *)v47 = v12;
            *(_WORD *)&v47[4] = 2082;
            *(void *)&v47[6] = v20;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v20);
          if (!v9) {
            goto LABEL_67;
          }
          goto LABEL_66;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v12;
          v16 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
LABEL_64:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0x12u);
        }
      }
    }

    else
    {
      if (v7 != 30 && v7 != 2) {
        goto LABEL_67;
      }
      v41 = 4;
      v17 = v8 ? 0 : 41;
      if (!getsockopt(v2, v17, 9696, &v43, &v41)) {
        goto LABEL_67;
      }
      v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v19 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v45 = "nw_socket_fillout_socket_properties";
        v46 = 2080;
        *(void *)v47 = (char *)a1 + 404;
        *(_WORD *)&v47[8] = 1024;
        *(_DWORD *)&v47[10] = v18;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %s getsockopt OUT_IF failed %{darwin.errno}d",  buf,  0x1Cu);
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v45 = "nw_socket_fillout_socket_properties";
      v46 = 1024;
      *(_DWORD *)v47 = v18;
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v39 = 0;
      if (__nwlog_fault((const char *)v9, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (os_log_s *)gLogObj;
          v15 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_65;
          }
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          v16 = "%{public}s getsockopt OUT_IF failed %{darwin.errno}d";
          goto LABEL_64;
        }

        if (!v39)
        {
          v14 = (os_log_s *)__nwlog_obj();
          v15 = type;
          if (!os_log_type_enabled(v14, type)) {
            goto LABEL_65;
          }
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          v16 = "%{public}s getsockopt OUT_IF failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_64;
        }

        v22 = (char *)__nw_create_backtrace_string();
        v14 = (os_log_s *)__nwlog_obj();
        v15 = type;
        v23 = os_log_type_enabled(v14, type);
        if (!v22)
        {
          if (!v23) {
            goto LABEL_65;
          }
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          v16 = "%{public}s getsockopt OUT_IF failed %{darwin.errno}d, no backtrace";
          goto LABEL_64;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446722;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          *(_WORD *)&v47[4] = 2082;
          *(void *)&v47[6] = v22;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s getsockopt OUT_IF failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v22);
      }
    }

  if (v20) {
    free(v20);
  }
}

    if (v26) {
      free(v26);
    }
    if (!v31) {
      return 0LL;
    }
    v21 = v31;
    goto LABEL_60;
  }

  v39 = v31;
  *(void *)&v31[v30 - 8] ^= bswap64(a4);
  v40 = v92;
  if (!v92)
  {
    v81 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v113 = "strict_calloc";
    v82 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v82);
    if (result) {
      goto LABEL_241;
    }
    free(v82);
    v40 = 0LL;
  }

  v41 = calloc(1uLL, v40);
  v42 = a1;
  if (!v41)
  {
    v83 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v83, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v113 = "strict_calloc";
    v114 = 2048;
    v115 = 1LL;
    v116 = 2048;
    v117 = v40;
    v84 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v84);
    if (result) {
      goto LABEL_241;
    }
    free(v84);
    v42 = a1;
    v40 = v92;
  }

  memcpy(v41, (const void *)(v42 + a2 - v40), v40);
  if (a2 == v40) {
    v43 = 1LL;
  }
  else {
    v43 = a2 - v40;
  }
  if (!v43)
  {
    v85 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v85, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v113 = "strict_calloc";
    v86 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v86);
    if (result) {
      goto LABEL_241;
    }
    free(v86);
  }

  v16 = (char *)calloc(1uLL, v43);
  if (v16)
  {
LABEL_70:
    ccaes_gcm_decrypt_mode();
    v44 = ccgcm_one_shot();
    if (v26) {
      free(v26);
    }
    free(v39);
    if (v41) {
      free(v41);
    }
    if (!v44)
    {
      *a12 = a2 - v40;
      return (BOOL)v16;
    }

    v45 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      v114 = 1024;
      LODWORD(v115) = v44;
      _os_log_impl(&dword_181A5C000, v45, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", (uint8_t *)&buf, 0x12u);
    }

    goto LABEL_23;
  }

  v87 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
  buf = 136446722;
  v113 = "strict_calloc";
  v114 = 2048;
  v115 = 1LL;
  v116 = 2048;
  v117 = v43;
  v88 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v88);
  if (!result)
  {
    free(v88);
    goto LABEL_70;
  }

    free(backtrace_string);
    goto LABEL_75;
  }

  if (!a2)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_proxy_hop_create_oblivious_http";
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null oblivious_config_length", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (!v37)
    {
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl( &dword_181A5C000,  v21,  v35,  "%{public}s called with null oblivious_config_length, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v30 = type;
    v31 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null oblivious_config_length, no backtrace",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_proxy_hop_create_oblivious_http";
      v41 = 2082;
      v42 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null oblivious_config_length, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_56;
  }

  if (a3)
  {
    v6 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_proxy_hop);
    if (v6)
    {
      options = nw_oblivious_http_create_options(a1, a2, a3);
      v8 = v6->options;
      v6->options = (OS_nw_protocol_options *)options;

      v9 = v6;
LABEL_25:

      return v6;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v40 = "nw_proxy_hop_create_oblivious_http";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault(v11, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (os_log_s *)(id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }

      else if (v37)
      {
        v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (os_log_s *)(id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (v14)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_proxy_hop_create_oblivious_http";
            v41 = 2082;
            v42 = v14;
            _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v14);
          if (!v11) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }

        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (os_log_s *)(id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_proxy_hop_create_oblivious_http";
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v11) {
      goto LABEL_25;
    }
LABEL_24:
    free(v11);
    goto LABEL_25;
  }

  __nwlog_obj();
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v40 = "nw_proxy_hop_create_oblivious_http";
  v20 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v20, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_proxy_hop_create_oblivious_http";
        _os_log_impl(&dword_181A5C000, v21, v26, "%{public}s called with null request_path", buf, 0xCu);
      }

    free(backtrace_string);
    goto LABEL_75;
  }

  if (!a2)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A5C000, v23, v26, "%{public}s called with null oblivious_config_length", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (!v39)
    {
      __nwlog_obj();
      v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl( &dword_181A5C000,  v23,  v37,  "%{public}s called with null oblivious_config_length, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v32 = type;
    v33 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl( &dword_181A5C000,  v23,  v32,  "%{public}s called with null oblivious_config_length, no backtrace",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_proxy_hop_create_oblivious_http_with_context";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v23,  v32,  "%{public}s called with null oblivious_config_length, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_56;
  }

  if (a3)
  {
    v8 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_proxy_hop);
    if (v8)
    {
      options_with_context = nw_oblivious_http_create_options_with_context(a1, a2, a3, a4);
      options = v8->options;
      v8->options = (OS_nw_protocol_options *)options_with_context;

      v11 = v8;
LABEL_25:

      return v8;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v42 = "nw_proxy_hop_create_oblivious_http_with_context";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v13, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (os_log_s *)(id)gLogObj;
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s [nw_proxy_hop init] failed", buf, 0xCu);
        }
      }

      else if (v39)
      {
        v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (os_log_s *)(id)gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v14, type);
        if (v16)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_proxy_hop_create_oblivious_http_with_context";
            v43 = 2082;
            v44 = v16;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s [nw_proxy_hop init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v16);
          if (!v13) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s [nw_proxy_hop init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (os_log_s *)(id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_proxy_hop_create_oblivious_http_with_context";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s [nw_proxy_hop init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v13) {
      goto LABEL_25;
    }
LABEL_24:
    free(v13);
    goto LABEL_25;
  }

  __nwlog_obj();
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v42 = "nw_proxy_hop_create_oblivious_http_with_context";
  v22 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v22, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_proxy_hop_create_oblivious_http_with_context";
        _os_log_impl(&dword_181A5C000, v23, v28, "%{public}s called with null request_path", buf, 0xCu);
      }

  os_unfair_lock_unlock(lock);

  return v27;
}

          free(v15);
          goto LABEL_57;
        }

        v69 = 0LL;
        v68 = 0LL;
        v70 = 0;
        *(_DWORD *)buf = 139296;
        v67 = (const char *)(v71 | 0xFFFFFFF00000000LL);
        if (!connect(v12, (const sockaddr *)buf, 0x20u))
        {
          Bridge_delayInitStub = NEFlowDirectorCreateBridge_delayInitStub(v23);
          *(void *)(globals_for_path + 112) = Bridge_delayInitStub;
          if (Bridge_delayInitStub)
          {
            NEFlowDirectorStart_delayInitStub(v36);
            v9 = 1LL;
            if (a2) {
              *a2 = 1;
            }
            goto LABEL_74;
          }

          close(v12);
          goto LABEL_73;
        }

        v24 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        *(_DWORD *)type = 136446466;
        v61 = "nw_path_open_in_process_flow_divert_socket";
        v62 = 1024;
        v63 = v24;
        v26 = (char *)_os_log_send_and_compose_impl();

        v59 = OS_LOG_TYPE_ERROR;
        v58 = 0;
        if (__nwlog_fault(v26, &v59, &v58))
        {
          if (v59 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v28 = v59;
            if (os_log_type_enabled(v27, v59))
            {
              *(_DWORD *)type = 136446466;
              v61 = "nw_path_open_in_process_flow_divert_socket";
              v62 = 1024;
              v63 = v24;
              _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s connect failed on kernel control socket %{darwin.errno}d",  (uint8_t *)type,  0x12u);
            }
          }

          else if (v58)
          {
            v37 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v38 = v59;
            v39 = os_log_type_enabled(v27, v59);
            if (v37)
            {
              if (v39)
              {
                *(_DWORD *)type = 136446722;
                v61 = "nw_path_open_in_process_flow_divert_socket";
                v62 = 1024;
                v63 = v24;
                v64 = 2082;
                v65 = v37;
                _os_log_impl( &dword_181A5C000,  v27,  v38,  "%{public}s connect failed on kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)type,  0x1Cu);
              }

              free(v37);
              goto LABEL_70;
            }

            if (v39)
            {
              *(_DWORD *)type = 136446466;
              v61 = "nw_path_open_in_process_flow_divert_socket";
              v62 = 1024;
              v63 = v24;
              _os_log_impl( &dword_181A5C000,  v27,  v38,  "%{public}s connect failed on kernel control socket %{darwin.errno}d, no backtrace",  (uint8_t *)type,  0x12u);
            }
          }

          else
          {
            __nwlog_obj();
            v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v42 = v59;
            if (os_log_type_enabled(v27, v59))
            {
              *(_DWORD *)type = 136446466;
              v61 = "nw_path_open_in_process_flow_divert_socket";
              v62 = 1024;
              v63 = v24;
              _os_log_impl( &dword_181A5C000,  v27,  v42,  "%{public}s connect failed on kernel control socket %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)type,  0x12u);
            }
          }
        }

  v60 = *(void *)(a1 + 40);
  if (!v60) {
    goto LABEL_73;
  }
  [*(id *)(v60 + 24) _siteForCookies];
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v62 = v61 == 0LL;

  if (v62) {
    goto LABEL_73;
  }
  v63 = *(void *)(a1 + 40);
  if (v63)
  {
    [*(id *)(v63 + 24) _siteForCookies];
    v64 = (void *)objc_claimAutoreleasedReturnValue();
  }

  else
  {
    v64 = 0LL;
  }

  v65 = v35;
  v66 = v65;
  if (!v65)
  {
    __nwlog_obj();
    v148 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_http_cookie_options_set_site_for_cookies";
    LODWORD(v389) = 12;
    v388 = buf;
    v149 = (char *)_os_log_send_and_compose_impl();

    v427 = OS_LOG_TYPE_ERROR;
    v426 = 0;
    if (v427 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v151 = v427;
      if (os_log_type_enabled(v150, v427))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http_cookie_options_set_site_for_cookies";
        _os_log_impl(&dword_181A5C000, v150, v151, "%{public}s called with null options", buf, 0xCu);
      }

      goto LABEL_379;
    }

    if (!v426)
    {
      __nwlog_obj();
      v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v228 = v427;
      if (os_log_type_enabled(v150, v427))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http_cookie_options_set_site_for_cookies";
        _os_log_impl( &dword_181A5C000,  v150,  v228,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_379;
    }

    v182 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v183 = v427;
    v184 = os_log_type_enabled(v150, v427);
    if (!v182)
    {
      if (v184)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_http_cookie_options_set_site_for_cookies";
        _os_log_impl(&dword_181A5C000, v150, v183, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }

      goto LABEL_379;
    }

    if (v184)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_http_cookie_options_set_site_for_cookies";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v182;
      _os_log_impl( &dword_181A5C000,  v150,  v183,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v182);
LABEL_380:
    if (!v149) {
      goto LABEL_65;
    }
    goto LABEL_381;
  }

  v67 = v65;
  v68 = v67[1];

  if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
  }
  v69 = nw_protocol_definition_is_equal_unsafe( (uint64_t)v68,  nw_protocol_copy_http_cookie_definition_http_cookie_definition);

  if (v69)
  {
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = v2;
    *(void *)&buf[16] = __nw_http_cookie_options_set_site_for_cookies_block_invoke;
    *(void *)&v434 = &__block_descriptor_40_e9_B16__0_v8l;
    *((void *)&v434 + 1) = v64;
    nw_protocol_options_access_handle(v67, buf);
    goto LABEL_65;
  }

  __nwlog_obj();
  v160 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_http_cookie_options_set_site_for_cookies";
  LODWORD(v389) = 12;
  v388 = buf;
  v149 = (char *)_os_log_send_and_compose_impl();

  v427 = OS_LOG_TYPE_ERROR;
  v426 = 0;
  if (v427 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v161 = v427;
    if (os_log_type_enabled(v150, v427))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_http_cookie_options_set_site_for_cookies";
      _os_log_impl(&dword_181A5C000, v150, v161, "%{public}s protocol options are not http_cookie", buf, 0xCu);
    }

      free(backtrace_string);
    }

    goto LABEL_57;
  }

  if (!v4)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http_authentication_options_set_credential_cache";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_credential_cache";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null credential_cache", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v30)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_credential_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v26,  "%{public}s called with null credential_cache, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_credential_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null credential_cache, no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http_authentication_options_set_credential_cache";
      v34 = 2082;
      v35 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null credential_cache, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  v6 = (id *)v3;
  v7 = v6[1];

  if (nw_protocol_copy_http_authentication_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_authentication_definition_onceToken, &__block_literal_global_29_72963);
  }
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v7,  nw_protocol_copy_http_authentication_definition_http_authentication_definition);

  if (!is_equal_unsafe)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http_authentication_options_set_credential_cache";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_credential_cache";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s protocol options are not http_authentication", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v30)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_credential_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s protocol options are not http_authentication, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_credential_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s protocol options are not http_authentication, no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http_authentication_options_set_credential_cache";
      v34 = 2082;
      v35 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s protocol options are not http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_57;
  }

  if (!v4)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http_authentication_options_set_h1_fallback_cache";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_h1_fallback_cache";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null h1_fallback_cache", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v30)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_h1_fallback_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v26,  "%{public}s called with null h1_fallback_cache, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_h1_fallback_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null h1_fallback_cache, no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http_authentication_options_set_h1_fallback_cache";
      v34 = 2082;
      v35 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null h1_fallback_cache, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_37;
  }

  v6 = (id *)v3;
  v7 = v6[1];

  if (nw_protocol_copy_http_authentication_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_authentication_definition_onceToken, &__block_literal_global_29_72963);
  }
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v7,  nw_protocol_copy_http_authentication_definition_http_authentication_definition);

  if (!is_equal_unsafe)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http_authentication_options_set_h1_fallback_cache";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_h1_fallback_cache";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s protocol options are not http_authentication", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v30)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_h1_fallback_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s protocol options are not http_authentication, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_http_authentication_options_set_h1_fallback_cache";
        _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s protocol options are not http_authentication, no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_http_authentication_options_set_h1_fallback_cache";
      v34 = 2082;
      v35 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s protocol options are not http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v9) {
    free(v9);
  }
  return 0LL;
}

  if (v21) {
    free(v21);
  }
  has_proxy_child_locked = 0LL;
LABEL_20:

  return has_proxy_child_locked;
}

    if (v23) {
      free(v23);
    }
    goto LABEL_39;
  }

  nw_context_assert_queue(v9->context);
  if ((*((_BYTE *)v10 + 109) & 0x40) != 0)
  {
    v12 = (id)nw_endpoint_handler_copy_connected_path(v10->parent_endpoint_handler);
    if (v12)
    {
      if (a5) {
        v14 = 8;
      }
      else {
        v14 = 6;
      }
      if (a5) {
        v15 = 7;
      }
      else {
        v15 = 5;
      }
      if (a4) {
        v14 = v15;
      }
      if (a5) {
        v16 = 4;
      }
      else {
        v16 = 2;
      }
      if (a5) {
        v17 = 3;
      }
      else {
        v17 = 1;
      }
      if (a4) {
        v16 = v17;
      }
      if (a3) {
        v18 = v16;
      }
      else {
        v18 = v14;
      }
      nw_connection_report_symptom_internal_on_nw_queue( 421899,  v10->endpoint,  v10->parameters,  v12,  0LL,  0LL,  a2,  v18,  0,  v10->privacy_stance);
    }

    else
    {
      parameters = v10->parameters;
      if (parameters && !nw_path_parameters_get_logging_disabled(*((void *)parameters + 13)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v20 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          top_id = v10->top_id;
          *(_DWORD *)buf = 136446466;
          v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
          v34 = 1024;
          LODWORD(v35) = top_id;
          _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Not reporting estimated byte threshold change because connection has no connected path",  buf,  0x12u);
        }
      }
    }

    goto LABEL_38;
  }

  v11 = v10->parameters;
  if (v11 && !nw_path_parameters_get_logging_disabled(*((void *)v11 + 13)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v12 = (id)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_ERROR))
    {
      v13 = v10->top_id;
      *(_DWORD *)buf = 136446466;
      v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
      v34 = 1024;
      LODWORD(v35) = v13;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v12,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Not reporting estimated byte threshold change because connection has no connected endpoint handler",  buf,  0x12u);
    }

  if (v26) {
    free(v26);
  }

  v13 = 0LL;
LABEL_21:

  return v13;
}

  if (v10) {
    free(v10);
  }
  return 0LL;
}

      free(v23);
      if (!v15) {
        return;
      }
      goto LABEL_131;
    }

    v16 = (os_log_s *)__nwlog_obj();
    v17 = type;
    if (!os_log_type_enabled(v16, type)) {
      goto LABEL_130;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_http2_connected";
    v18 = "%{public}s called with null http2";
LABEL_129:
    _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
    goto LABEL_130;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_http2_connected";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null other_protocol";
      goto LABEL_129;
    }

    if (!v54)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_129;
    }

    v23 = (char *)__nw_create_backtrace_string();
    v16 = (os_log_s *)__nwlog_obj();
    v17 = type;
    v26 = os_log_type_enabled(v16, type);
    if (!v23)
    {
      if (!v26) {
        goto LABEL_130;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_129;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = "nw_protocol_http2_connected";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v23;
      v25 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_55;
    }

    goto LABEL_56;
  }

  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v19 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v20 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      *(void *)&buf[4] = "nw_protocol_http2_connected";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 390;
      *(_WORD *)&buf[22] = 2080;
      v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v20;
      _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      connected = (void (*)(void))callbacks->connected;
      if (connected) {
        connected();
      }
    }
  }

  if (a1->output_handler != a2)
  {
    if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v8 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v9 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(void *)&buf[4] = "nw_protocol_http2_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v9;
        v10 = "%{public}s %{public}s%s<i%u> connected protocol is not our output_handler, ignoring";
LABEL_69:
        _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEBUG, v10, buf, 0x26u);
        return;
      }
    }

    return;
  }

  v11 = *((__int16 *)handle + 194);
  if (v11 < 0)
  {
    if ((v11 & 0x80) == 0) {
      goto LABEL_20;
    }
  }

  else
  {
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v49 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v50 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(void *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v50;
        _os_log_impl(&dword_181A5C000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }

    LOWORD(v11) = *((_WORD *)handle + 194);
    if ((v11 & 0x80) == 0)
    {
LABEL_20:
      if ((v11 & 0x8000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v12 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v13 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_protocol_http2_process_connected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 390;
          *(_WORD *)&buf[22] = 2080;
          v57 = " ";
          LOWORD(v58) = 1024;
          *(_DWORD *)((char *)&v58 + 2) = v13;
          v14 = "%{public}s %{public}s%s<i%u> not server, processing input without waiting";
LABEL_136:
          _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, v14, buf, 0x26u);
          goto LABEL_62;
        }
      }

      goto LABEL_62;
    }
  }

  if (!*((void *)handle + 18))
  {
    if ((v11 & 0x8000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v35 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v36 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(void *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v36;
        _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> no listen handler on server, deferring processing of input and connected state un til listen handler is present",  buf,  0x26u);
      }
    }

    *((_WORD *)handle + 194) |= 0x1000u;
    return;
  }

  if ((v11 & 0x8000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v12 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v51 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      *(void *)&buf[4] = "nw_protocol_http2_process_connected";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 390;
      *(_WORD *)&buf[22] = 2080;
      v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v51;
      v14 = "%{public}s %{public}s%s<i%u> listen handler present, processing input without waiting";
      goto LABEL_136;
    }
  }

      free(v41);
      goto LABEL_57;
    }

    __nwlog_obj();
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
    v56 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v72 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
        _os_log_impl(&dword_181A5C000, v57, v58, "%{public}s [super init] failed", buf, 0xCu);
      }
    }

    else
    {
      if (v72)
      {
        v63 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v65 = type;
        v66 = os_log_type_enabled(v64, type);
        if (v63)
        {
          if (v66)
          {
            *(_DWORD *)buf = 136446466;
            v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
            v76 = 2082;
            v77 = v63;
            _os_log_impl( &dword_181A5C000,  v64,  v65,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v63);
        }

        else
        {
          if (v66)
          {
            *(_DWORD *)buf = 136446210;
            v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
            _os_log_impl(&dword_181A5C000, v64, v65, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }

        goto LABEL_95;
      }

      __nwlog_obj();
      v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v68 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
        _os_log_impl(&dword_181A5C000, v57, v68, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_95:
    if (v56) {
      free(v56);
    }
    goto LABEL_48;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
  v21 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v72 = 0;
  if (__nwlog_fault(v21, &type, &v72))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = (os_log_s *)(id)gLogObj;
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
        _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s Delegate does not conform to NWTCPListenerDelegate protocol",  buf,  0xCu);
      }

    free(v61);
    goto LABEL_57;
  }

  __nwlog_obj();
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_masque_inner_connection_start";
  v69 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(aBlock.receiver) = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (LOBYTE(aBlock.receiver) == 17)
  {
    __nwlog_obj();
    v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v73 = (os_log_type_t)aBlock.receiver;
    if (os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_masque_inner_connection_start";
      _os_log_impl(&dword_181A5C000, v70, v73, "%{public}s called with null inner_connection", buf, 0xCu);
    }

    goto LABEL_117;
  }

  if (type[0] == OS_LOG_TYPE_DEFAULT)
  {
    __nwlog_obj();
    v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v95 = (os_log_type_t)aBlock.receiver;
    if (os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_masque_inner_connection_start";
      _os_log_impl( &dword_181A5C000,  v70,  v95,  "%{public}s called with null inner_connection, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_117;
  }

  v85 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v86 = (os_log_type_t)aBlock.receiver;
  v87 = os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver);
  if (!v85)
  {
    if (v87)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = "nw_masque_inner_connection_start";
      _os_log_impl(&dword_181A5C000, v70, v86, "%{public}s called with null inner_connection, no backtrace", buf, 0xCu);
    }

    goto LABEL_117;
  }

  if (v87)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&buf[4] = "nw_masque_inner_connection_start";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v85;
    _os_log_impl( &dword_181A5C000,  v70,  v86,  "%{public}s called with null inner_connection, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v85);
  if (v69) {
    goto LABEL_119;
  }
LABEL_58:
}

    free(backtrace_string);
    goto LABEL_23;
  }

  if (*a3 <= 0x13u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = *a3;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_interface_get_ipv6_network_signature";
    v44 = 1024;
    *(_DWORD *)v45 = v8;
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v9, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (os_log_s *)(id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          v12 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv6_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v12;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN",  buf,  0x12u);
        }
      }

      else if (v40)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (os_log_s *)(id)gLogObj;
        v16 = type;
        v17 = os_log_type_enabled(v10, type);
        if (v15)
        {
          if (v17)
          {
            v18 = *a3;
            *(_DWORD *)buf = 136446722;
            v43 = "nw_interface_get_ipv6_network_signature";
            v44 = 1024;
            *(_DWORD *)v45 = v18;
            v45[2] = 2082;
            *(void *)&v45[3] = v15;
            _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v15);
          if (!v9) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }

        if (v17)
        {
          v21 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv6_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v21;
          _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (os_log_s *)(id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          v20 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv6_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v20;
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s signature length %u is less than IFNET_SIGNATURELEN, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

LABEL_214:
  if (v131) {
    free(v131);
  }
  if ((v3[48] & 2) != 0) {
LABEL_142:
  }
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 13);
}

    if (v107) {
      free(v107);
    }
    if (v80 != &nw_protocol_ref_counted_handle)
    {
LABEL_136:
      if (v69 == &nw_protocol_ref_counted_handle) {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      }
      if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v8) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v71 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
        {
          logc = nw_endpoint_handler_get_id_string(v8);
          v124 = nw_endpoint_handler_dry_run_string(v8);
          v85 = nw_endpoint_handler_copy_endpoint(v8);
          v86 = nw_endpoint_get_logging_description(v85);
          v87 = nw_endpoint_handler_state_string(v8);
          v88 = nw_endpoint_handler_mode_string(v8);
          v89 = nw_endpoint_handler_copy_current_path(v8);
          *(_DWORD *)buf = 136447746;
          *(void *)&buf[4] = "-[NWConcrete_nw_endpoint_flow cancelWithHandler:forced:]";
          v137 = 2082;
          v138 = (void *)logc;
          v139 = 2082;
          v140 = v124;
          v141 = 2082;
          v142 = (void *)v86;
          v143 = 2082;
          v144 = v87;
          v145 = 2082;
          v146 = v88;
          v147 = 2114;
          v148 = v89;
          _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removed passthrough protoco l from the stack on cancellation",  buf,  0x48u);
        }

    if (v54) {
      free(v54);
    }
    goto LABEL_142;
  }

  __nwlog_obj();
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v97 = "networkd_privileged_get_kernel_socket_internal";
  v83 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v94 = 0;
  if (__nwlog_fault(v83, &type, &v94))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v85 = type;
      if (os_log_type_enabled(v84, type))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        _os_log_impl(&dword_181A5C000, v84, v85, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
      }
    }

    else if (v94)
    {
      v86 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v87 = type;
      v88 = os_log_type_enabled(v84, type);
      if (v86)
      {
        if (v88)
        {
          *(_DWORD *)buf = 136446466;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 2082;
          *(void *)v99 = v86;
          _os_log_impl( &dword_181A5C000,  v84,  v87,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v86);
        goto LABEL_200;
      }

      if (v88)
      {
        *(_DWORD *)buf = 136446210;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        _os_log_impl(&dword_181A5C000, v84, v87, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v89 = type;
      if (os_log_type_enabled(v84, type))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        _os_log_impl( &dword_181A5C000,  v84,  v89,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v96) {
      free(v96);
    }
    v41 = 0LL;
    v9 = 0LL;
    goto LABEL_87;
  }

  if ((v5[606] & 0x10) != 0)
  {
    if (!a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v40 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = "nw_framer_prepend_application_protocol_inner";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v5 + 609;
        _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_ERROR,  "%{public}s %s Already in the ready state, cannot prepend application protocol",  buf,  0x16u);
      }

      v41 = 0LL;
      goto LABEL_87;
    }

    v5[606] &= ~0x10u;
  }

  v10 = *((void *)v5 + 42);
  v11 = v8;
  v12 = v11[1];
  v150 = v11;

  v13 = (void *)*((void *)v5 + 44);
  v14 = (void *)*((void *)v5 + 45);
  v15 = (char *)v12;
  v16 = v13;
  v17 = v14;
  v153 = v9;
  v155 = v15;
  if (v15)
  {
    v18 = v15;
    v19 = (uint64_t)(v18 + 8);

    v20 = v18;
    v21 = v20[184];

    if ((v21 & 1) != 0
      && (v22 = (uint64_t (*)(uint64_t, char *, id, char *))nw_protocol_definition_get_framer_create(v20)) != 0LL)
    {
      internal = v22(v19, v20, v16, v17);
    }

    else
    {
      internal = nw_protocol_create_internal(v19, v16, v17, 1);
    }

    v24 = internal;
    goto LABEL_13;
  }

  __nwlog_obj();
  v99 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&buf[4] = "nw_framer_create_protocol_for_definition";
  v100 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v167) = 0;
  if (__nwlog_fault(v100, type, &v167))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v102 = type[0];
      if (os_log_type_enabled(v101, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_framer_create_protocol_for_definition";
        _os_log_impl(&dword_181A5C000, v101, v102, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if ((_BYTE)v167)
    {
      v120 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v121 = type[0];
      v122 = os_log_type_enabled(v101, type[0]);
      if (v120)
      {
        if (v122)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = "nw_framer_create_protocol_for_definition";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v120;
          _os_log_impl( &dword_181A5C000,  v101,  v121,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v120);
        goto LABEL_227;
      }

      if (v122)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_framer_create_protocol_for_definition";
        _os_log_impl(&dword_181A5C000, v101, v121, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v138 = type[0];
      if (os_log_type_enabled(v101, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_framer_create_protocol_for_definition";
        _os_log_impl( &dword_181A5C000,  v101,  v138,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v186) {
      free((void *)v186);
    }
    goto LABEL_28;
  }

  v12 = (NWConcrete_nw_endpoint_handler *)v11;
  mode = v12->mode;

  if ((_DWORD)mode == 4)
  {
    v276 = v12;
    nw_endpoint_handler_report(v12, v10, a4, v281);
    v14 = nw_endpoint_handler_copy_fallback(v12);
    if ((*((_BYTE *)v14 + 108) & 0x40) == 0 && (a3 & 0xFFFFFFFE) == 4)
    {
      if (v281)
      {
        v15 = v281;
        v16 = v15[2];

        if (v16 == 1)
        {
          v17 = v15;
          v18 = v17[3];

          if (v18 == 89) {
            *((_BYTE *)v14 + 108) |= 1u;
          }
        }
      }
    }

    v20 = (os_log_s *)*((void *)v14 + 4);
    v19 = (os_log_s *)*((void *)v14 + 5);
    v279 = v14;
    if (v20 == v10)
    {
      v25 = v19;
      v277 = v25;
      v275 = a3;
      if (!nw_endpoint_handler_get_minimize_logging(v12))
      {
        v26 = v12;
        v27 = *((_BYTE *)v26 + 268);

        if ((v27 & 0x20) != 0) {
          goto LABEL_59;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v29 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          log = v29;
          v30 = v26;

          v31 = v30;
          v32 = *((_BYTE *)v26 + 268);

          if ((v32 & 1) != 0) {
            v33 = "dry-run ";
          }
          else {
            v33 = "";
          }
          v255 = nw_endpoint_handler_copy_endpoint(v31);
          logging_description = nw_endpoint_get_logging_description(v255);
          v34 = v31;
          v35 = v34;
          v36 = v34[30];
          else {
            v37 = off_189BBBBF0[v36];
          }
          v243 = v37;

          v48 = v35;
          v49 = v48;
          v50 = v12->mode;
          v270 = a4;
          v247 = v33;
          v51 = "path";
          switch(v50)
          {
            case 0:
              break;
            case 1:
              v51 = "resolver";
              break;
            case 2:
              v51 = nw_endpoint_flow_mode_string(v48[31]);
              break;
            case 3:
              v51 = "proxy";
              break;
            case 4:
              v51 = "fallback";
              break;
            case 5:
              v51 = "transform";
              break;
            default:
              v51 = "unknown-mode";
              break;
          }

          v56 = v49;
          os_unfair_lock_lock((os_unfair_lock_t)v56 + 28);
          v57 = v56[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v56 + 28);

          v58 = v57;
          id_string = nw_endpoint_handler_get_id_string(v10);
          v60 = nw_endpoint_handler_dry_run_string(v10);
          v61 = nw_endpoint_handler_copy_endpoint(v10);
          v259 = v20;
          v62 = nw_endpoint_get_logging_description(v61);
          v63 = v30 + 168;
          v64 = nw_endpoint_handler_state_string(v10);
          v65 = nw_endpoint_handler_mode_string(v280);
          v66 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = v63;
          v289 = 2082;
          v290 = v247;
          v291 = 2082;
          v292 = logging_description;
          v293 = 2082;
          v294 = v243;
          v295 = 2082;
          v296 = v51;
          v297 = 2114;
          v298 = v58;
          v299 = 2082;
          v300 = (unint64_t)id_string;
          v301 = 2082;
          v302 = v60;
          v303 = 2082;
          v304 = v62;
          v305 = 2082;
          v306 = v64;
          v307 = 2082;
          v308 = v65;
          v309 = 2114;
          v310 = v66;
          v29 = log;
          _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received primary child repo rt:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x84u);

          v20 = v259;
          a4 = v270;
        }

        goto LABEL_57;
      }

      v273 = a4;
      if ((nw_endpoint_handler_get_logging_disabled(v12) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v194 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
        {
          v195 = nw_endpoint_handler_get_id_string(v12);
          v262 = nw_endpoint_handler_dry_run_string(v12);
          logc = nw_endpoint_handler_copy_endpoint(v12);
          v257 = nw_endpoint_get_logging_description(logc);
          v253 = nw_endpoint_handler_state_string(v12);
          v249 = nw_endpoint_handler_mode_string(v12);
          v196 = nw_endpoint_handler_copy_current_path(v12);
          v245 = nw_endpoint_handler_get_id_string(v280);
          v197 = nw_endpoint_handler_dry_run_string(v280);
          v198 = nw_endpoint_handler_copy_endpoint(v280);
          v199 = nw_endpoint_get_logging_description(v198);
          v200 = nw_endpoint_handler_state_string(v280);
          v201 = nw_endpoint_handler_mode_string(v280);
          v202 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = (void *)v195;
          v289 = 2082;
          v290 = v262;
          v291 = 2082;
          v292 = v257;
          v293 = 2082;
          v294 = v253;
          v295 = 2082;
          v296 = v249;
          v297 = 2114;
          v298 = v196;
          v299 = 2082;
          v300 = (unint64_t)v245;
          v301 = 2082;
          v302 = v197;
          v303 = 2082;
          v304 = v199;
          v305 = 2082;
          v306 = v200;
          v307 = 2082;
          v308 = v201;
          v309 = 2114;
          v310 = v202;
          v29 = v194;
          _os_log_impl( &dword_181A5C000,  v194,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received primary child repo rt:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x84u);

          a4 = v273;
LABEL_57:

          v10 = v280;
          v25 = v277;
          v14 = v279;
          v12 = v276;
LABEL_58:
          a3 = v275;
LABEL_59:
          v278 = v25;
          if (a3 < 2)
          {
            if (a3 != 1) {
              goto LABEL_71;
            }
            if (v20 != v10)
            {
              v78 = (char *)v14 + 109;
              v79 = *((_BYTE *)v14 + 109);
              if ((v79 & 1) == 0) {
                goto LABEL_63;
              }
              v80 = 4;
LABEL_62:
              *v78 = v79 & 0xFA | v80;
LABEL_63:
              v82 = (_DWORD *)((char *)v14 + 48);
              v81 = *((_DWORD *)v14 + 12);
              v83 = 1;
              goto LABEL_73;
            }

            v85 = *((char *)v14 + 108);
            if ((v85 & 0x80000000) == 0)
            {
LABEL_71:
              v82 = (_DWORD *)((char *)v14 + 48);
              v81 = *((_DWORD *)v14 + 12);
              v83 = v20 != v10;
              if (v20 == v10 && v81 == 1) {
                goto LABEL_75;
              }
LABEL_73:
              if (v20 != v10 && v81 == 2)
              {
LABEL_75:
                if ((a3 - 3) <= 1)
                {
                  v86 = *((void *)v14 + 10);
                  if (v86)
                  {
                    nw_queue_cancel_source(v86, v28);
                    *((void *)v279 + 10) = 0LL;
                    v12 = v276;
                  }
                }

                v87 = v12;
                v87->state = a3;

                nw_endpoint_handler_report(v87, 0LL, a4, 0LL);
                goto LABEL_190;
              }

              v88 = v12;
              logb = v88->parameters;

              if (networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_no_fallback_full_stack))
              {
                no_fullstack_fallback = 1;
                if (a3 != 2) {
                  goto LABEL_85;
                }
              }

              else
              {
                no_fullstack_fallback = nw_parameters_get_no_fullstack_fallback(logb);
                if (a3 != 2) {
                  goto LABEL_85;
                }
              }

              if (*a4 == 3)
              {
                v91 = a4[1] == 5;
                goto LABEL_86;
              }

    goto LABEL_116;
  }

  if ((*((_BYTE *)v6 + 616) & 1) == 0)
  {
    if (*((void *)v6 + 72))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446722;
        v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        WORD5(v126[0]) = 2114;
        *(void *)((char *)v126 + 12) = v6;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ cancelling previous connection on request %{public}@",  buf,  0x20u);
      }

      nw_connection_cancel(*((nw_connection_t *)v6 + 72));
      v15 = (void *)*((void *)v6 + 72);
      *((void *)v6 + 72) = 0LL;
    }

    v13 = (void *)*((void *)v6 + 1);
    goto LABEL_14;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v27 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  v125 = "nwsc_request_create_and_start_connection_inner";
  LOWORD(v126[0]) = 2114;
  *(void *)((char *)v126 + 2) = v5;
  WORD5(v126[0]) = 2114;
  *(void *)((char *)v126 + 12) = v6;
  v10 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(error) = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)(id)gLogObj;
    v28 = type[0];
    if (os_log_type_enabled(v11, type[0]))
    {
      *(_DWORD *)buf = 136446722;
      v125 = "nwsc_request_create_and_start_connection_inner";
      LOWORD(v126[0]) = 2114;
      *(void *)((char *)v126 + 2) = v5;
      WORD5(v126[0]) = 2114;
      *(void *)((char *)v126 + 12) = v6;
      _os_log_impl( &dword_181A5C000,  v11,  v28,  "%{public}s %{public}@ tried to start connection on incoming request %{public}@",  buf,  0x20u);
    }
  }

  else if ((_BYTE)error)
  {
    v41 = __nw_create_backtrace_string();
    if (v41)
    {
      v42 = (char *)v41;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v43 = (os_log_s *)(id)gLogObj;
      v44 = type[0];
      if (os_log_type_enabled(v43, type[0]))
      {
        *(_DWORD *)buf = 136446978;
        v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        WORD5(v126[0]) = 2114;
        *(void *)((char *)v126 + 12) = v6;
        WORD2(v126[1]) = 2082;
        *(void *)((char *)&v126[1] + 6) = v42;
        _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s %{public}@ tried to start connection on incoming request %{public}@, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v42);
      if (!v10) {
        goto LABEL_103;
      }
      goto LABEL_102;
    }

    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v63 = type[0];
    if (os_log_type_enabled(v11, type[0]))
    {
      *(_DWORD *)buf = 136446722;
      v125 = "nwsc_request_create_and_start_connection_inner";
      LOWORD(v126[0]) = 2114;
      *(void *)((char *)v126 + 2) = v5;
      WORD5(v126[0]) = 2114;
      *(void *)((char *)v126 + 12) = v6;
      _os_log_impl( &dword_181A5C000,  v11,  v63,  "%{public}s %{public}@ tried to start connection on incoming request %{public}@, no backtrace",  buf,  0x20u);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)(id)gLogObj;
    v59 = type[0];
    if (os_log_type_enabled(v11, type[0]))
    {
      *(_DWORD *)buf = 136446722;
      v125 = "nwsc_request_create_and_start_connection_inner";
      LOWORD(v126[0]) = 2114;
      *(void *)((char *)v126 + 2) = v5;
      WORD5(v126[0]) = 2114;
      *(void *)((char *)v126 + 12) = v6;
      _os_log_impl( &dword_181A5C000,  v11,  v59,  "%{public}s %{public}@ tried to start connection on incoming request %{public}@, backtrace limit exceeded",  buf,  0x20u);
    }
  }

      if (v111) {
        free(v111);
      }
LABEL_51:

LABEL_52:
LABEL_53:
      v45 = *(void **)(a1 + 40);
      if (v45) {
        v45 = (void *)v45[9];
      }
      v46 = v45;
      v47 = (nw_protocol_definition *)nw_protocol_boringssl_copy_definition();
      v48 = nw_connection_copy_protocol_metadata(v46, v47);

      if (v48)
      {
        v49 = v48;
        goto LABEL_57;
      }

      v75 = *(void **)(a1 + 40);
      if (v75) {
        v75 = (void *)v75[9];
      }
      v76 = v75;
      if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
      }
      v77 = (nw_protocol_definition *)(id)nw_protocol_copy_quic_stream_definition::quic_definition;
      v78 = nw_connection_copy_protocol_metadata(v76, v77);

      if (!v78)
      {
        v50 = 0LL;
        v49 = 0LL;
LABEL_59:

        goto LABEL_60;
      }

      v49 = nw_quic_copy_sec_protocol_metadata(v78);

      if (v49)
      {
LABEL_57:
        v50 = (void *)sec_protocol_metadata_copy_sec_trust();
        v51 = *(void *)(a1 + 40);
        if (v51) {
          objc_storeStrong((id *)(v51 + 168), v50);
        }
        goto LABEL_59;
      }

          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
          if ((v51 & 1) != 0)
          {
LABEL_46:
            v52 = (void *)*((void *)v5 + 116);
            if (v52)
            {
              nw_endpoint_handler_cancel(v52, 1LL, 0);
              v53 = (void *)*((void *)v5 + 116);
              *((void *)v5 + 116) = 0LL;

              v54 = (void *)*((void *)v5 + 117);
              *((void *)v5 + 117) = 0LL;
            }

            *((void *)v5 + 94) = a2;
            if ((*((_BYTE *)v5 + 32) & 2) == 0) {
              goto LABEL_52;
            }
            v55 = (void *)*((void *)v5 + 104);
            *((void *)v5 + 104) = 0LL;

            v56 = (void *)*((void *)v5 + 2);
            *((void *)v5 + 2) = 0LL;

            if ((*((_BYTE *)v5 + 33) & 0x40) == 0) {
              goto LABEL_52;
            }
            v57 = (void *)*((void *)v5 + 113);
            *((void *)v5 + 113) = 0LL;

            *((_BYTE *)v5 + 32) &= ~0x10u;
            if ((nw_endpoint_flow_setup_channel(v7) & 1) != 0)
            {
              if (!*((void *)v5 + 104))
              {
                if ((nw_endpoint_handler_get_logging_disabled(v7) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  v94 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
                  {
                    id_string = nw_endpoint_handler_get_id_string(v7);
                    v96 = nw_endpoint_handler_dry_run_string(v7);
                    v97 = nw_endpoint_handler_copy_endpoint(v7);
                    v98 = nw_endpoint_get_logging_description(v97);
                    v99 = nw_endpoint_handler_state_string(v7);
                    v100 = nw_endpoint_handler_mode_string(v7);
                    v101 = nw_endpoint_handler_copy_current_path(v7);
                    *(_DWORD *)buf = 136447746;
                    v219 = "nw_endpoint_flow_rebuild_stack";
                    v220 = 2082;
                    v221 = (char *)id_string;
                    v222 = 2082;
                    v223 = (nw_protocol *)v96;
                    v224 = 2082;
                    v225 = (void *)v98;
                    v226 = 2082;
                    v227 = v99;
                    v228 = 2082;
                    v229 = v100;
                    v230 = 2114;
                    v231 = v101;
                    _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow_registration is NULL",  buf,  0x48u);
                  }
                }

                goto LABEL_237;
              }

      free(backtrace_string);
      goto LABEL_232;
    }

    if (!v117) {
      goto LABEL_232;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    v98 = "%{public}s called with null reassembly_count, no backtrace";
LABEL_231:
    _os_log_impl(&dword_181A5C000, v96, v97, v98, buf, 0xCu);
LABEL_232:
    if (v95) {
      free(v95);
    }
    return 0LL;
  }

  if (!*(void *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
    v16 = 0;
    v17 = 0LL;
  }

  else
  {
    v15 = *(_DWORD *)(a2 + 52);
    v14 = *(unsigned int *)(a2 + 56);
    if (v15) {
      v16 = v15 - (v14 + *(_DWORD *)(a2 + 60));
    }
    else {
      v16 = 0;
    }
    v17 = (int *)(*(void *)(a2 + 112) + v14);
  }

  if ((*(_WORD *)(a2 + 204) & 0x80) != 0) {
    v16 = *(unsigned __int16 *)(a2 + 196);
  }
  if (v17)
  {
    v18 = *(void **)(a1 + 48);
    if (v18) {
      ++*v18;
    }
    if (v16 <= 0x27)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        v100 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447234;
          *(void *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          v146 = " ";
          v147 = 2048;
          v148 = a1;
          v149 = 1024;
          LODWORD(v150) = v16;
          _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p Received IPv6 packet with incorrect length %u",  buf,  0x30u);
        }
      }

      v101 = *(void *)(a1 + 48);
      if (v101)
      {
        result = 0LL;
        ++*(void *)(v101 + 8);
        return result;
      }

      return 0LL;
    }

    if ((*(_BYTE *)v17 & 0xF0) != 0x60)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        v102 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          v146 = " ";
          v147 = 2048;
          v148 = a1;
          _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p Not an IPv6 packet",  buf,  0x2Au);
        }
      }

      v103 = *(void *)(a1 + 48);
      if (v103)
      {
        result = 0LL;
        ++*(void *)(v103 + 48);
        return result;
      }

      return 0LL;
    }

    if (*((void *)v17 + 1) != *(void *)(a1 + 72) || *((void *)v17 + 2) != *(void *)(a1 + 80))
    {
      if ((*(_BYTE *)(a1 + 158) & 1) != 0) {
        return 0LL;
      }
      v104 = (os_log_s *)__nwlog_obj();
      result = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)buf = 136446978;
      *(void *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 159;
      *(_WORD *)&buf[22] = 2080;
      v146 = " ";
      v147 = 2048;
      v148 = a1;
      v105 = "%{public}s %{public}s%s%p Received remote address that did not match";
LABEL_185:
      _os_log_impl(&dword_181A5C000, v104, OS_LOG_TYPE_ERROR, v105, buf, 0x2Au);
      return 0LL;
    }

    if (*((void *)v17 + 3) != *(void *)(a1 + 56) || *((void *)v17 + 4) != *(void *)(a1 + 64))
    {
      if ((*(_BYTE *)(a1 + 158) & 1) != 0) {
        return 0LL;
      }
      v104 = (os_log_s *)__nwlog_obj();
      result = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)buf = 136446978;
      *(void *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 159;
      *(_WORD *)&buf[22] = 2080;
      v146 = " ";
      v147 = 2048;
      v148 = a1;
      v105 = "%{public}s %{public}s%s%p Received local address that did not match";
      goto LABEL_185;
    }

    v134 = a4;
    v135 = a6;
    v21 = bswap32(*((unsigned __int16 *)v17 + 2)) >> 16;
    v22 = v21 + 40;
    if (v21 + 40 > (unint64_t)v16)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        v106 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447490;
          *(void *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          v146 = " ";
          v147 = 2048;
          v148 = a1;
          v149 = 1024;
          LODWORD(v150) = v21;
          WORD2(v150) = 1024;
          *(_DWORD *)((char *)&v150 + 6) = v16;
          _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p Received IPv6 packet with incorrect length, expected %u received %u",  buf,  0x36u);
        }
      }

      v107 = *(void *)(a1 + 48);
      if (v107)
      {
        result = 0LL;
        ++*(void *)(v107 + 16);
        return result;
      }

      return 0LL;
    }

    if (v21 + 40 != v16 && (*(_BYTE *)(a1 + 158) & 1) == 0)
    {
      v108 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        v146 = " ";
        v147 = 2048;
        v148 = a1;
        v149 = 1024;
        LODWORD(v150) = v21;
        WORD2(v150) = 1024;
        *(_DWORD *)((char *)&v150 + 6) = (unsigned __int16)(v16 - 40);
        _os_log_impl( &dword_181A5C000,  v108,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s%p Received length mismatch with IPv6 %u != %u",  buf,  0x36u);
      }
    }

    v23 = *v17;
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xFC | (*v17 >> 12) & 3;
    *(_BYTE *)(a2 + 184) = (bswap32(*v17) >> 22) & 0x3F;
    v24 = (v23 >> 12) & 3;
    switch(v24)
    {
      case 3:
        v25 = (void *)(a1 + 32);
        break;
      case 2:
        v25 = (void *)(a1 + 24);
        break;
      case 1:
        v25 = (void *)(a1 + 16);
        break;
      default:
        goto LABEL_40;
    }

    ++*v25;
LABEL_40:
    v26 = *(_BYTE *)(a1 + 158);
    if ((v26 & 4) != 0)
    {
      v109 = mach_continuous_time();
      v110 = *(_WORD *)(a2 + 204) & 0xFFEF | (*(unsigned __int8 *)(a2 + 206) << 16);
      *(_WORD *)(a2 + 204) &= ~0x10u;
      *(_BYTE *)(a2 + 206) = BYTE2(v110);
      *(void *)(a2 + 152) = v109;
      v26 = *(_BYTE *)(a1 + 158);
    }

    v131 = a3;
    v132 = a5;
    v133 = v16;
    if ((v26 & 0x10) != 0) {
      *(_BYTE *)(a2 + 185) = *((_BYTE *)v17 + 7);
    }
    if ((*(_WORD *)(a2 + 204) & 8) != 0) {
      goto LABEL_65;
    }
    v27 = a2 + 120;
    v28 = *(void **)(a2 + 168);
    if (v28)
    {
      os_release(v28);
      *(void *)(a2 + 168) = 0LL;
    }

    v29 = *(void *)(a2 + 64);
    *(_BYTE *)(a2 + 186) |= 0x40u;
    if (v29)
    {
      if (v29 != v27)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446722;
        *(void *)&buf[4] = "__nw_frame_set_metadata";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v29;
        *(_WORD *)&buf[22] = 2048;
        v146 = (const char *)(a2 + 120);
        v30 = (char *)_os_log_send_and_compose_impl();
        v144 = OS_LOG_TYPE_ERROR;
        v143 = 0;
        if (v144 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = gLogObj;
          v32 = v144;
          if (!os_log_type_enabled((os_log_t)gLogObj, v144)) {
            goto LABEL_63;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "__nw_frame_set_metadata";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2048;
          v146 = (const char *)(a2 + 120);
          v33 = "%{public}s Existing metadata %p doesn't match expected %p";
        }

        else
        {
          if (v143)
          {
            v34 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v35 = (os_log_s *)gLogObj;
            v36 = v144;
            v37 = os_log_type_enabled((os_log_t)gLogObj, v144);
            if (v34)
            {
              if (v37)
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&buf[4] = "__nw_frame_set_metadata";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v29;
                *(_WORD *)&buf[22] = 2048;
                v146 = (const char *)(a2 + 120);
                v147 = 2082;
                v148 = (uint64_t)v34;
                _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              free(v34);
              goto LABEL_63;
            }

            if (!v37)
            {
LABEL_63:
              if (v30) {
                free(v30);
              }
              goto LABEL_65;
            }

            *(_DWORD *)buf = 136446722;
            *(void *)&buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v29;
            *(_WORD *)&buf[22] = 2048;
            v146 = (const char *)(a2 + 120);
            v33 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
            v38 = v35;
            v39 = v36;
LABEL_62:
            _os_log_impl(&dword_181A5C000, v38, v39, v33, buf, 0x20u);
            goto LABEL_63;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = gLogObj;
          v32 = v144;
          if (!os_log_type_enabled((os_log_t)gLogObj, v144)) {
            goto LABEL_63;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = "__nw_frame_set_metadata";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2048;
          v146 = (const char *)(a2 + 120);
          v33 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
        }

        v38 = (os_log_s *)v31;
        v39 = v32;
        goto LABEL_62;
      }
    }

    else
    {
      *(void *)(a2 + 64) = v27;
      *(void *)(a2 + 72) = v27;
      *(void *)(a2 + 120) = 0LL;
      *(void *)(a2 + 128) = a2 + 64;
    }

uint64_t nw_hash_node_get_object(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 16);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_hash_node_get_object";
  v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_object";
        v5 = "%{public}s called with null node";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_hash_node_get_object";
          __int16 v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null node, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_object";
        v5 = "%{public}s called with null node, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_object";
        v5 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  return v6;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

    free(v6);
    goto LABEL_19;
  }

  *(_OWORD *)(v3 + 5) = *a2;
  v10 = v3 + 21;
LABEL_20:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v10;
  return 1LL;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_20;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v27 = "__nw_frame_claim_internal";
  v18 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v18, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = (os_log_s *)__nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "__nw_frame_claim_internal";
        v21 = "%{public}s called with null frame";
LABEL_39:
        _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
      }
    }

    else if (v24)
    {
      v22 = (char *)__nw_create_backtrace_string();
      v19 = (os_log_s *)__nwlog_obj();
      v20 = type;
      v23 = os_log_type_enabled(v19, type);
      if (v22)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "__nw_frame_claim_internal";
          v28 = 2082;
          *(void *)&v29 = v22;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v22);
        goto LABEL_40;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "__nw_frame_claim_internal";
        v21 = "%{public}s called with null frame, no backtrace";
        goto LABEL_39;
      }
    }

    else
    {
      v19 = (os_log_s *)__nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "__nw_frame_claim_internal";
        v21 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_39;
      }
    }
  }

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

    if (!v4 || !nw_endpoint_get_do_not_redact(v4))
    {
      v11 = 1LL;
      goto LABEL_22;
    }

    goto LABEL_20;
  }

  v11 = 0LL;
LABEL_22:

  return v11;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

LABEL_19:
    if (v4) {
      free(v4);
    }
    return 0LL;
  }

  final_read_list = a1->final_read_list;
  if (final_read_list) {
    return final_read_list[2].super.super.isa != final_read_list[3].super.super.isa;
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  sub_181BCEE10(a3);
  sub_181BCEE10(a3);
  result = swift_bridgeObjectRelease();
  __break(1u);
  return result;
}

      uint64_t v14 = v11 + v10;
      if (__OFADD__(v11, v10)) {
        goto LABEL_45;
      }
      v15 = *(void *)(v9 + 16);
      if (v11 != v14)
      {
        if (v11 >= v15) {
          goto LABEL_47;
        }
        if ((v14 & 0x8000000000000000LL) != 0) {
          goto LABEL_48;
        }
        v40 = v10;
        v16 = (uint64_t *)(v31 + (v11 << 6));
        v17 = v16[2];
        v38 = v16[1];
        v39 = *v16;
        v37 = v16[3];
        v36 = *((_BYTE *)v16 + 32);
        v34 = v16[6];
        v35 = v16[5];
        v33 = *((_WORD *)v16 + 28);
        v2 = v31 + (v14 << 6);
        v18 = *(void *)(v2 + 8);
        v19 = *(void *)(v2 + 16);
        v3 = *(void *)(v2 + 24);
        v20 = *(_BYTE *)(v2 + 32);
        v21 = *(void *)(v2 + 40);
        char v8 = *(void **)(v2 + 48);
        v22 = *(_WORD *)(v2 + 56);
        *v16 = *(void *)v2;
        v16[1] = v18;
        v16[2] = v19;
        v16[3] = v3;
        *((_BYTE *)v16 + 32) = v20;
        v16[5] = v21;
        v16[6] = (uint64_t)v8;
        *((_WORD *)v16 + 28) = v22;
        v23 = v9;
        v41 = *(void *)(v9 + 16);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v14 >= v41) {
          goto LABEL_49;
        }
        char v8 = *(void **)(v2 + 24);
        *(void *)v2 = v39;
        *(void *)(v2 + 8) = v38;
        *(void *)(v2 + 16) = v17;
        *(void *)(v2 + 24) = v37;
        *(_BYTE *)(v2 + 32) = v36;
        *(void *)(v2 + 40) = v35;
        *(void *)(v2 + 48) = v34;
        *(_WORD *)(v2 + 56) = v33;
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        result = swift_bridgeObjectRelease();
        v3 = v30;
        v9 = v23;
        __int16 v12 = v32;
        v10 = v40;
      }

      ++v11;
    }

    while (v11 != v12);
    *v27 = v9;
    if (!v10) {
      return swift_bridgeObjectRelease();
    }
    if ((v10 & 0x8000000000000000LL) != 0)
    {
      __break(1u);
    }

    else
    {
      v26 = *(void *)(v9 + 16);
      result = v26 - v10;
      if (v26 >= v10)
      {
        sub_181BF948C(result);
        return swift_bridgeObjectRelease();
      }
    }

    __break(1u);
  }

  return result;
}

    if (v2 <= v8 >> 16) {
      goto LABEL_33;
    }
    char v8 = sub_18264EB98();
LABEL_23:
    if (4 * v2 == v8 >> 14) {
      return 1LL;
    }
  }

  __break(1u);
LABEL_33:
  __break(1u);
  return result;
}

            result = sub_181C93190(v8, a2, 0);
            char v8 = __clz(__rbit64(v19)) | (v17 << 6);
          }

          if (v8 == a4) {
            return v10;
          }
          goto LABEL_31;
        }

        result = sub_181C93190(v8, a2, 0);
        char v8 = v13;
        if (v13 == a4) {
          return v10;
        }
      }

  if (v3) {
    free(v3);
  }
}

  if (v3) {
    free(v3);
  }
}

  if (v4) {
    free(v4);
  }
}

              v16 = *v11;
              if (*v11)
              {
                if (v14 == 60)
                {
                  __int16 v12 = 0LL;
                  while (1)
                  {
                    v17 = (*(_BYTE *)(v16 + v12) & *(_BYTE *)(v15 + v12));
                    v18 = v6[v12];
                    if (v17 != v18 && (v13 - 1 != v12 || v18 != 32 || v17 != 62 && v17 != 32)) {
                      break;
                    }
                    if (v13 == ++v12) {
                      return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                    }
                  }
                }

                else
                {
                  __int16 v12 = 0LL;
                  while ((*(_BYTE *)(v16 + v12) & *(_BYTE *)(v15 + v12)) == v6[v12])
                  {
                    if (v13 == ++v12) {
                      return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                    }
                  }
                }
              }

              else if (v14 == 60)
              {
                __int16 v12 = 0LL;
                while (1)
                {
                  v21 = *(unsigned __int8 *)(v15 + v12);
                  v22 = v6[v12];
                  if (v21 != v22 && (v13 - 1 != v12 || v22 != 32 || v21 != 62 && v21 != 32)) {
                    break;
                  }
                  if (v13 == ++v12) {
                    return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                  }
                }
              }

              else
              {
                __int16 v12 = 0LL;
                while (*(unsigned __int8 *)(v15 + v12) == v6[v12])
                {
                  if (v13 == ++v12) {
                    return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                  }
                }
              }

  v6[82] = v9;
  *((_BYTE *)v6 + 664) = v10 | 1;
  __int16 v12 = (dispatch_object_s *)nw_parameters_copy_context(a4);
  v13 = *((_BYTE *)v6 + 680);
  if ((v13 & 1) != 0)
  {
    uint64_t v14 = v6[84];
    if (v14)
    {
      os_release(v14);
      v13 = *((_BYTE *)v6 + 680);
    }
  }

  v6[84] = v12;
  *((_BYTE *)v6 + 680) = v13 | 1;
  *((_BYTE *)v6 + 692) = *((_BYTE *)v6 + 692) & 0xFE | nw_parameters_get_server_mode(a4) | 0x10;
  if (nw_protocol_copy_http_redirect_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_31_73205);
  }
  v15 = (id)nw_protocol_copy_http_redirect_definition_http_redirect_definition;
  v16 = nw_parameters_copy_protocol_options_for_definition(a4, v15);
  v17 = v16;
  v18 = MEMORY[0x1895F87A8];
  if (v16)
  {
    v19 = nw_protocol_options_copy_definition((nw_protocol_options_t)v16);
    if (nw_protocol_copy_http_redirect_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_31_73205);
    }
    is_equal = nw_protocol_definition_is_equal( v19,  (nw_protocol_definition_t)nw_protocol_copy_http_redirect_definition_http_redirect_definition);

    if (is_equal)
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000LL;
      v71 = (uint64_t)__Block_byref_object_copy__72694;
      v72 = __Block_byref_object_dispose__72695;
      v73 = 0LL;
      *(void *)os_log_type_t type = v18;
      v65 = 3221225472LL;
      v66 = __nw_http_redirect_options_copy_handler_block_invoke;
      v67 = &unk_189BC60A8;
      v68 = buf;
      nw_protocol_options_access_handle(v17, type);
      v21 = (dispatch_object_s *)_Block_copy(*(const void **)(*(void *)&buf[8] + 40LL));
      _Block_object_dispose(buf, 8);

      goto LABEL_28;
    }

    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_redirect_options_copy_handler";
    v63 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69 = 0;
    v38 = (char *)v63;
    if (__nwlog_fault(v63, type, &v69))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v46 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl(&dword_181A5C000, v39, v46, "%{public}s protocol options are not http redirect", buf, 0xCu);
        }
}
  }
  }
  }

    if (v5) {
      free(v5);
    }
    *(_DWORD *)(a1 + 208) = -1;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_protocol_plugin_retry_begin_async";
  v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_plugin_retry_begin_async";
      v18 = "%{public}s called with null retry";
      goto LABEL_35;
    }

    if (!v21)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_plugin_retry_begin_async";
      v18 = "%{public}s called with null retry, backtrace limit exceeded";
      goto LABEL_35;
    }

    v19 = (char *)__nw_create_backtrace_string();
    v16 = (os_log_s *)__nwlog_obj();
    v17 = type;
    v20 = os_log_type_enabled(v16, type);
    if (v19)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_plugin_retry_begin_async";
        v25 = 2082;
        v26 = v19;
        _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null retry, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v19);
      goto LABEL_36;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_plugin_retry_begin_async";
      v18 = "%{public}s called with null retry, no backtrace";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
    }
  }

      v11 = *(void *)(a1 + 48);
      v13 = *(void **)(v11 + 40);
      __int16 v12 = *(void *)(v11 + 48);
      if (v13 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = *(void *)(v11 + 88);
        if (v14) {
          *(void *)(v11 + 88) = v14 + 1;
        }
      }

      if (v12)
      {
        v15 = *(void **)(v12 + 40);
        if (v15 == &nw_protocol_ref_counted_handle)
        {
          v16 = *(void *)(v12 + 88);
          if (v16) {
            *(void *)(v12 + 88) = v16 + 1;
          }
        }

        v17 = *(void *)(v11 + 24);
        if (v17)
        {
          v18 = *(uint64_t (**)(uint64_t, uint64_t))(v17 + 24);
          if (v18)
          {
            v19 = v18(v11, v12);
            if (v15 != &nw_protocol_ref_counted_handle)
            {
LABEL_29:
              if (v13 == &nw_protocol_ref_counted_handle)
              {
                if (v11)
                {
                  if (*(_UNKNOWN **)(v11 + 40) == &nw_protocol_ref_counted_handle)
                  {
                    v31 = *(void *)(v11 + 88);
                    if (v31)
                    {
                      v32 = v31 - 1;
                      *(void *)(v11 + 88) = v32;
                      if (!v32)
                      {
                        v33 = *(void (***)(void))(v11 + 64);
                        if (v33)
                        {
                          *(void *)(v11 + 64) = 0LL;
                          v33[2](v33);
                          _Block_release(v33);
                        }

                        if ((*(_BYTE *)(v11 + 72) & 1) != 0)
                        {
                          v34 = *(const void **)(v11 + 64);
                          if (v34) {
                            _Block_release(v34);
                          }
                        }

                        free((void *)v11);
                      }
                    }
                  }
                }
              }

              if ((v19 & 1) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v20 = (os_log_s *)gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  v21 = *(const char ***)(*(void *)(a1 + 48) + 32LL);
                  v22 = "invalid";
                  if (v21)
                  {
                    if (v21[2]) {
                      v22 = v21[2];
                    }
                  }

                  buf = 136446722;
                  v113 = "nw_protocol_plugin_retry_reissue_output_frames_block_invoke";
                  v114 = 2048;
                  v115 = v21;
                  v116 = 2080;
                  v117 = (uint64_t)v22;
                  _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to connect protocol <%p:%s>",  (uint8_t *)&buf,  0x20u);
                }
              }

              return;
            }

          _Block_object_dispose(v42, 8);
          goto LABEL_19;
        }

        __nwlog_obj();
        v27 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)parse = 136446210;
        *(void *)&parse[4] = "nw_ws_parse_output";
        v28 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v44 = 0;
        if (__nwlog_fault(v28, &type, &v44))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v30 = type;
            if (os_log_type_enabled(v29, type))
            {
              *(_DWORD *)parse = 136446210;
              *(void *)&parse[4] = "nw_ws_parse_output";
              _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null framer", parse, 0xCu);
            }
          }

          else if (v44)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v32 = type;
            v33 = os_log_type_enabled(v29, type);
            if (backtrace_string)
            {
              if (v33)
              {
                *(_DWORD *)parse = 136446466;
                *(void *)&parse[4] = "nw_ws_parse_output";
                *(_WORD *)&parse[12] = 2082;
                *(void *)&parse[14] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null framer, dumping backtrace:%{public}s",  parse,  0x16u);
              }

              free(backtrace_string);
              goto LABEL_39;
            }

            if (v33)
            {
              *(_DWORD *)parse = 136446210;
              *(void *)&parse[4] = "nw_ws_parse_output";
              _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null framer, no backtrace", parse, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v34 = type;
            if (os_log_type_enabled(v29, type))
            {
              *(_DWORD *)parse = 136446210;
              *(void *)&parse[4] = "nw_ws_parse_output";
              _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null framer, backtrace limit exceeded",  parse,  0xCu);
            }
          }
        }

LABEL_19:
                if ((nw_parameters_get_prohibit_joining_protocols(v8) & 1) != 0
                  || nw_parameters_get_prohibit_joining_protocols(*(void **)(a1 + 56)))
                {
                  if (!gLogDatapath) {
                    goto LABEL_22;
                  }
                  __nwlog_obj();
                  v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                  {
                    v51 = *(void *)(a1 + 32);
                    v52 = *(void *)(a1 + 72);
                    *(_DWORD *)buf = 136446978;
                    v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                    v61 = 2112;
                    v62 = v51;
                    v63 = 2048;
                    v64 = v4;
                    v65 = 2080;
                    v66 = v52;
                    _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s not eligible, parameters prohibit joining",  buf,  0x2Au);
                  }

        v15 = 0LL;
        goto LABEL_19;
      }

      __nwlog_obj();
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v47 = "nw_framer_protocol_get_output_frames";
      v25 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      if (!__nwlog_fault((const char *)v25, &type, &v44))
      {
LABEL_81:
        if (v25) {
          free(v25);
        }
        goto LABEL_18;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_framer_protocol_get_output_frames";
          _os_log_impl(&dword_181A5C000, v26, v29, "%{public}s called with null framer->parent_definition", buf, 0xCu);
        }
}

    v9 = (os_unfair_lock_s *)a1[4];
    goto LABEL_19;
  }
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  v9 = 0LL;
LABEL_19:

  return v9;
}

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 72LL), *(id *)(*(void *)&buf[8] + 40LL));
  _Block_object_dispose(buf, 8);
}

  if (v2) {
    free(v2);
  }
}
  }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
}

LABEL_19:
    if (v4) {
      free(v4);
    }
    return 0LL;
  }

  default_input_handler = a1->default_input_handler;
  if (default_input_handler) {
    return nw_protocol_supports_external_data((uint64_t)default_input_handler);
  }
  return 0LL;
}

      v16 = 0LL;
LABEL_19:

      return v16;
    }

    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_flow_replay_remove_input_handler";
    v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault(v24, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_flow_replay_remove_input_handler";
          _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type;
        v32 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_flow_replay_remove_input_handler";
            v41 = 2082;
            v42 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v31,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_59;
        }

        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_flow_replay_remove_input_handler";
          _os_log_impl(&dword_181A5C000, v25, v31, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v34 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_flow_replay_remove_input_handler";
          _os_log_impl( &dword_181A5C000,  v25,  v34,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }
  }

  return is_equal;
}

  [MEMORY[0x189607968] numberWithBool:self->_voluntary];
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setObject:v14 forKey:@"voluntary"];

  has = (char)self->_has;
  if ((has & 2) == 0)
  {
LABEL_11:
    if ((has & 4) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  PBDataWriterWriteBOOLField();
  os_log_type_t v4 = v6;
  has = (char)self->_has;
  if ((has & 2) == 0)
  {
LABEL_11:
    if ((has & 4) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  }
  }
  }

LABEL_19:
    if (v6) {
      free(v6);
    }
    goto LABEL_21;
  }

  v3 = (const void *)*((void *)v1 + 1);
  if (!v3)
  {
LABEL_21:
    os_log_type_t v4 = 0LL;
    goto LABEL_22;
  }

  os_log_type_t v4 = CFRetain(v3);
LABEL_22:

  return v4;
}
  }
  }
  }

  if (v3) {
    free(v3);
  }
  return 1LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  return is_masque;
}

  if (v2) {
    free(v2);
  }
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
}

            v13 = v15;
            uint64_t v14 = 32;
            goto LABEL_19;
          }
        }
      }
    }

    if ((*(_BYTE *)(v5 + 348) & 1) != 0) {
      goto LABEL_20;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v5 + 349;
    *(_WORD *)&buf[22] = 2080;
    v35 = " ";
    __int16 v12 = "%{public}s %{public}s%sReceived invalid output frame";
    goto LABEL_18;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
  v27 = (char *)_os_log_send_and_compose_impl();
  uu[0] = 16;
  v33 = 0;
  if (__nwlog_fault(v27, uu, &v33))
  {
    if (uu[0] == 17)
    {
      v28 = (os_log_s *)__nwlog_obj();
      v29 = uu[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)uu[0])) {
        goto LABEL_68;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
      v30 = "%{public}s called with null ohttp";
      goto LABEL_67;
    }

    if (!v33)
    {
      v28 = (os_log_s *)__nwlog_obj();
      v29 = uu[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)uu[0])) {
        goto LABEL_68;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
      v30 = "%{public}s called with null ohttp, backtrace limit exceeded";
      goto LABEL_67;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = (os_log_s *)__nwlog_obj();
    v29 = uu[0];
    v32 = os_log_type_enabled(v28, (os_log_type_t)uu[0]);
    if (backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_68;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ohttp_context_finalize_output_frame";
      v30 = "%{public}s called with null ohttp, no backtrace";
LABEL_67:
      _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
    }
  }

    free(v6);
    goto LABEL_19;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v30 = "tcp_connection_conditions_get_unmet_reason";
  v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v11, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v12 = (os_log_s *)(id)gLogObj;
      v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      uint64_t v14 = "%{public}s called with null connection";
LABEL_39:
      v25 = v12;
      v26 = v13;
      goto LABEL_40;
    }

    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v12 = (os_log_s *)(id)gLogObj;
      v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      uint64_t v14 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_39;
    }

    v19 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    v20 = type;
    v21 = os_log_type_enabled(v12, type);
    if (!v19)
    {
      if (!v21)
      {
LABEL_41:

        if (!v11) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }

      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      uint64_t v14 = "%{public}s called with null connection, no backtrace";
      v25 = v12;
      v26 = v20;
LABEL_40:
      _os_log_impl(&dword_181A5C000, v25, v26, v14, buf, 0xCu);
      goto LABEL_41;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      v31 = 2082;
      *(void *)v32 = v19;
      _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v19);
  }

  if (v11) {
LABEL_26:
  }
    free(v11);
LABEL_27:
  v18 = 0LL;
LABEL_30:

  return v18;
}

    free(v7);
    goto LABEL_19;
  }

  os_log_type_t v4 = nw_interface_create_with_name(a2);
  v5 = v4 != 0LL;
  if (v4)
  {
    nw_parameters_require_interface(v3[6], (nw_interface_t)v4);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      __int16 v12 = (char *)v3[12];
      *(_DWORD *)buf = 136446722;
      v22 = "tcp_connection_set_interface_by_name";
      v23 = 2048;
      v24 = v12;
      v25 = 2082;
      v26 = a2;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s %llu could not set interface with name %{public}s",  buf,  0x20u);
    }
  }

LABEL_20:
  return v5;
}
}

    free(v8);
    goto LABEL_19;
  }

  v3 = (void *)*((void *)v1 + 2);
  if (v3)
  {
    os_log_type_t v4 = (nw_path *)nw_connection_copy_connected_path(v3);
    v5 = v4;
    if (v4)
    {
      v6 = nw_path_uses_interface_type(v4, nw_interface_type_cellular);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "tcp_connection_is_cellular";
        _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_ERROR, "%{public}s No connected path", buf, 0xCu);
      }

      v6 = 0LL;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "tcp_connection_is_cellular";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    v6 = 0LL;
  }

    free(v8);
    goto LABEL_19;
  }

  v3 = (void *)*((void *)v1 + 2);
  if (v3)
  {
    os_log_type_t v4 = (nw_path *)nw_connection_copy_connected_path(v3);
    v5 = v4;
    if (v4)
    {
      is_expensive = nw_path_is_expensive(v4);
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "tcp_connection_is_expensive";
        _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_ERROR, "%{public}s No connected path", buf, 0xCu);
      }

      is_expensive = 0LL;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "tcp_connection_is_expensive";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    is_expensive = 0LL;
  }
}

  v6[66] = v9;
  *((_BYTE *)v6 + 536) = v10 | 1;
  *((_WORD *)v6 + 324) = (_WORD)v6[81] & 0xFFFE | nw_parameters_get_server_mode(a4);
  v6[70] = 0LL;
  v6[71] = (char *)(v6 + 70);
  v6[72] = 0LL;
  v6[73] = (char *)(v6 + 72);
  v6[74] = 0LL;
  v6[75] = (char *)(v6 + 74);
  v6[76] = 0LL;
  v6[77] = (char *)(v6 + 76);
  v6[78] = 0LL;
  v6[79] = (char *)(v6 + 78);
  nw_frame_cache_init((uint64_t)(v6 + 54), (uint64_t)v6, 256, 0x40000, 0);
  if (nw_protocol_copy_http_encoding_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_encoding_definition_onceToken, &__block_literal_global_30_73148);
  }
  __int16 v12 = (id)nw_protocol_copy_http_encoding_definition_http_encoding_definition;
  v13 = nw_parameters_copy_protocol_options_for_definition(a4, v12);
  os_log_type_t type = nw_http_encoding_options_get_type(v13);
  *((_DWORD *)v6 + 160) = type;
  switch(type)
  {
    case 2:
      v15 = (char *)calloc(1uLL, 0x80uLL);
      if (v15) {
        goto LABEL_22;
      }
      v24 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1LL;
      v36 = 2048;
      v37 = 128LL;
      v25 = (void *)_os_log_send_and_compose_impl();
      free(v25);
LABEL_22:
      *(void *)v15 = off_189BB5640;
      *((_DWORD *)v15 + 30) = 31;
      v16 = (z_stream *)(v15 + 8);
      v17 = 31;
      goto LABEL_27;
    case 3:
      v15 = (char *)calloc(1uLL, 0x80uLL);
      if (v15) {
        goto LABEL_26;
      }
      v28 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1LL;
      v36 = 2048;
      v37 = 128LL;
      v29 = (void *)_os_log_send_and_compose_impl();
      free(v29);
LABEL_26:
      *(void *)v15 = off_189BB5640;
      *((_DWORD *)v15 + 30) = 15;
      v16 = (z_stream *)(v15 + 8);
      v17 = 15;
      goto LABEL_27;
    case 4:
      v15 = (char *)calloc(1uLL, 0x80uLL);
      if (v15) {
        goto LABEL_24;
      }
      v26 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1LL;
      v36 = 2048;
      v37 = 128LL;
      v27 = (void *)_os_log_send_and_compose_impl();
      free(v27);
LABEL_24:
      *(void *)v15 = off_189BB5640;
      *((_DWORD *)v15 + 30) = -15;
      v16 = (z_stream *)(v15 + 8);
      v17 = -15;
LABEL_27:
      deflateInit2_(v16, -1, 8, v17, 8, 0, "1.2.12", 112);
      break;
    case 5:
      v15 = (char *)calloc(1uLL, 0x30uLL);
      if (v15) {
        goto LABEL_29;
      }
      v30 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1LL;
      v36 = 2048;
      v37 = 48LL;
      v31 = (void *)_os_log_send_and_compose_impl();
      free(v31);
LABEL_29:
      *(void *)v15 = off_189BB5668;
      if (compression_stream_init( (compression_stream *)(v15 + 8),  COMPRESSION_STREAM_ENCODE,  (compression_algorithm)0xB02u))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "brotli_encoder";
          _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_ERROR, "%{public}s init failed", buf, 0xCu);
        }
      }

      break;
    default:
      v15 = 0LL;
      break;
  }

  v19 = v6[69];
  if (v19 != v15)
  {
    if (v19)
    {
      (**(void (***)(char *))v19)(v6[69]);
      free(v19);
    }

    v6[69] = v15;
  }

  v6[8] = (char *)(v6 + 13);
  nw_protocol_plugin_name_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_encoding_create::$_0::__invoke);
  v6[10] = (char *)(v6 + 25);
  nw_protocol_plugin_reset_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_encoding_create::$_1::__invoke);
  v6[11] = (char *)(v6 + 27);
  nw_protocol_plugin_retry_set_callbacks( (uint64_t)v6,  (uint64_t)nw_protocol_http_encoding_create::$_2::__invoke,  (uint64_t)nw_protocol_http_encoding_create::$_3::__invoke,  (uint64_t)nw_protocol_http_encoding_create::$_4::__invoke,  (uint64_t)nw_protocol_http_encoding_create::$_5::__invoke);
  if (v13) {
    os_release(v13);
  }
  if (v12) {
    os_release(v12);
  }
  return v6;
}
  }

  if (v4) {
    free(v4);
  }
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

    if (v5) {
      free(v5);
    }
    goto LABEL_20;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "tcp_listener_set_tfo";
  v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v12 = (os_log_s *)__nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_listener_set_tfo";
      uint64_t v14 = "%{public}s called with null listener";
      goto LABEL_35;
    }

    if (!v17)
    {
      __int16 v12 = (os_log_s *)__nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_listener_set_tfo";
      uint64_t v14 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_35;
    }

    v15 = (char *)__nw_create_backtrace_string();
    __int16 v12 = (os_log_s *)__nwlog_obj();
    v13 = type;
    v16 = os_log_type_enabled(v12, type);
    if (v15)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_listener_set_tfo";
        v21 = 2082;
        v22 = v15;
        _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v15);
      goto LABEL_36;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_listener_set_tfo";
      uint64_t v14 = "%{public}s called with null listener, no backtrace";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    }
  }

  if (v3) {
    free(v3);
  }
}

          *(_DWORD *)buf = 136446466;
          v82 = "nw_protocol_http_connect_input_finished";
          v83 = 2082;
          v84 = (void *)v15;
          v17 = "%{public}s protocol %{public}s has invalid input_finished callback";
LABEL_137:
          _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
          goto LABEL_138;
        }

        if (v79)
        {
          v52 = (char *)__nw_create_backtrace_string();
          __int16 v12 = (os_log_s *)__nwlog_obj();
          v13 = type;
          v53 = os_log_type_enabled(v12, type);
          if (v52)
          {
            if (v53)
            {
              v54 = a1->default_input_handler;
              v55 = "invalid";
              if (v54)
              {
                v56 = v54->identifier;
                if (v56) {
                  v55 = (const char *)v56;
                }
              }

              *(_DWORD *)buf = 136446722;
              v82 = "nw_protocol_http_connect_input_finished";
              v83 = 2082;
              v84 = (void *)v55;
              v85 = 2082;
              v86 = v52;
              _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v52);
            if (v11) {
              goto LABEL_139;
            }
            return;
          }

          if (v53)
          {
            v71 = a1->default_input_handler;
            v67 = "invalid";
            if (v71)
            {
              v72 = v71->identifier;
              if (v72) {
                v67 = (const char *)v72;
              }
            }

    if (v5) {
      free(v5);
    }
    *(_DWORD *)(a1 + 276) = -1;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_http_connect_start_async";
  v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v24 = "nw_http_connect_start_async";
      v18 = "%{public}s called with null http_connect";
      goto LABEL_35;
    }

    if (!v21)
    {
      v16 = (os_log_s *)__nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v24 = "nw_http_connect_start_async";
      v18 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_35;
    }

    v19 = (char *)__nw_create_backtrace_string();
    v16 = (os_log_s *)__nwlog_obj();
    v17 = type;
    v20 = os_log_type_enabled(v16, type);
    if (v19)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_http_connect_start_async";
        v25 = 2082;
        v26 = v19;
        _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null http_connect, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v19);
      goto LABEL_36;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_http_connect_start_async";
      v18 = "%{public}s called with null http_connect, no backtrace";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
    }
  }

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v168 = "nw_http_connect_append_bytes";
    v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = (os_log_s *)__nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_95;
      }
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      __int16 v12 = "%{public}s called with null new_bytes";
      goto LABEL_93;
    }

    if (v165)
    {
      v35 = (char *)__nw_create_backtrace_string();
      v10 = (os_log_s *)__nwlog_obj();
      v11 = type;
      v164 = os_log_type_enabled(v10, type);
      if (v35)
      {
        if (v164)
        {
          *(_DWORD *)buf = 136446466;
          v168 = "nw_http_connect_append_bytes";
          v169 = 2082;
          v170 = v35;
          v37 = "%{public}s called with null new_bytes, dumping backtrace:%{public}s";
          goto LABEL_62;
        }

        goto LABEL_63;
      }

      if (!v164) {
        goto LABEL_95;
      }
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      __int16 v12 = "%{public}s called with null new_bytes, no backtrace";
    }

    else
    {
      v10 = (os_log_s *)__nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_95;
      }
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      __int16 v12 = "%{public}s called with null new_bytes, backtrace limit exceeded";
    }

  if (v3) {
    free(v3);
  }
  return 0LL;
}
  }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v1) {
    free(v1);
  }
}

  if (v4) {
    free(v4);
  }
}

  if (v4) {
    free(v4);
  }
}

  if (v4) {
    free(v4);
  }
}

    free(v6);
    goto LABEL_19;
  }

  *(_OWORD *)(v3 + 5) = *a2;
  v10 = v3 + 21;
LABEL_20:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v10;
}

    if (v9) {
      free(v9);
    }
    v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
    BOOL v7 = *(_DWORD *)(v6 + 24);
    LODWORD(v8) = -1;
  }

  v15 = *(_DWORD *)(a1 + 76);
  if (v8 <= v15)
  {
    *(_DWORD *)(v6 + 24) = v7 + v5;
    if (!__CFADD__(v7, v5)) {
      goto LABEL_77;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
    v111 = 2082;
    v112 = "bytes_count";
    v113 = 2048;
    v114 = v5;
    v115 = 2048;
    *(void *)v116 = v20;
    v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v108 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v21, type, &v108))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (os_log_s *)gLogObj;
        v23 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          v24 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
          v111 = 2082;
          v112 = "bytes_count";
          v113 = 2048;
          v114 = v5;
          v115 = 2048;
          *(void *)v116 = v24;
          v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_73:
          _os_log_impl(&dword_181A5C000, v22, v23, v25, buf, 0x2Au);
        }
      }

      else if (v108)
      {
        v26 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (os_log_s *)gLogObj;
        v23 = type[0];
        v27 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v26)
        {
          if (v27)
          {
            v28 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
            *(_DWORD *)buf = 136447234;
            v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
            v111 = 2082;
            v112 = "bytes_count";
            v113 = 2048;
            v114 = v5;
            v115 = 2048;
            *(void *)v116 = v28;
            *(_WORD *)&v116[8] = 2082;
            v117 = v26;
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v26);
          goto LABEL_74;
        }

        if (v27)
        {
          v63 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
          v111 = 2082;
          v112 = "bytes_count";
          v113 = 2048;
          v114 = v5;
          v115 = 2048;
          *(void *)v116 = v63;
          v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_73;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (os_log_s *)gLogObj;
        v23 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          v54 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v110 = "nw_http1_connection_fulfill_frame_request_block_invoke";
          v111 = 2082;
          v112 = "bytes_count";
          v113 = 2048;
          v114 = v5;
          v115 = 2048;
          *(void *)v116 = v54;
          v25 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_73;
        }
      }
    }

  if (v3) {
    free(v3);
  }
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}
}
  }
  }

  v13 = xpc_dictionary_get_uint64(v2, "_State") & 1;
  if (v13 == v32) {
    goto LABEL_51;
  }
  if (sysctlbyname("kern.ipc.io_policy.throttled", 0LL, 0LL, &v32, 4uLL))
  {
    uint64_t v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (os_log_s *)(id)gLogObj;
    v16 = v15;
    if (v14 == 2)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v34 = "-[NWPrivilegedHelper startThrottlePolicyEventListener]_block_invoke";
        v35 = 2082;
        v36 = "kern.ipc.io_policy.throttled";
        v37 = 1024;
        v38 = v13;
        v39 = 1024;
        *(_DWORD *)v40 = 2;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s sysctlbyname(%{public}s) to %d failed %{darwin.errno}d",  buf,  0x22u);
      }

      goto LABEL_51;
    }

    *(_DWORD *)buf = 136446978;
    v34 = "-[NWPrivilegedHelper startThrottlePolicyEventListener]_block_invoke";
    v35 = 2082;
    v36 = "kern.ipc.io_policy.throttled";
    v37 = 1024;
    v38 = v13;
    v39 = 1024;
    *(_DWORD *)v40 = v14;
    v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (os_log_s *)(id)gLogObj;
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446978;
        v34 = "-[NWPrivilegedHelper startThrottlePolicyEventListener]_block_invoke";
        v35 = 2082;
        v36 = "kern.ipc.io_policy.throttled";
        v37 = 1024;
        v38 = v13;
        v39 = 1024;
        *(_DWORD *)v40 = v14;
        v21 = "%{public}s sysctlbyname(%{public}s) to %d failed %{darwin.errno}d";
LABEL_46:
        v27 = v19;
        v28 = v20;
LABEL_47:
        _os_log_impl(&dword_181A5C000, v27, v28, v21, buf, 0x22u);
      }
    }

    else if (v29)
    {
      v22 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (os_log_s *)(id)gLogObj;
      v23 = type;
      v24 = os_log_type_enabled(v19, type);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136447234;
          v34 = "-[NWPrivilegedHelper startThrottlePolicyEventListener]_block_invoke";
          v35 = 2082;
          v36 = "kern.ipc.io_policy.throttled";
          v37 = 1024;
          v38 = v13;
          v39 = 1024;
          *(_DWORD *)v40 = v14;
          v40[2] = 2082;
          *(void *)&v40[3] = v22;
          _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s sysctlbyname(%{public}s) to %d failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x2Cu);
        }

        free(v22);
        goto LABEL_49;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446978;
        v34 = "-[NWPrivilegedHelper startThrottlePolicyEventListener]_block_invoke";
        v35 = 2082;
        v36 = "kern.ipc.io_policy.throttled";
        v37 = 1024;
        v38 = v13;
        v39 = 1024;
        *(_DWORD *)v40 = v14;
        v21 = "%{public}s sysctlbyname(%{public}s) to %d failed %{darwin.errno}d, no backtrace";
        v27 = v19;
        v28 = v23;
        goto LABEL_47;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (os_log_s *)(id)gLogObj;
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446978;
        v34 = "-[NWPrivilegedHelper startThrottlePolicyEventListener]_block_invoke";
        v35 = 2082;
        v36 = "kern.ipc.io_policy.throttled";
        v37 = 1024;
        v38 = v13;
        v39 = 1024;
        *(_DWORD *)v40 = v14;
        v21 = "%{public}s sysctlbyname(%{public}s) to %d failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_46;
      }
    }

LABEL_49:
    if (v18) {
      free(v18);
    }
    goto LABEL_51;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446978;
    v34 = "-[NWPrivilegedHelper startThrottlePolicyEventListener]_block_invoke";
    v35 = 2082;
    v36 = "kern.ipc.io_policy.throttled";
    v37 = 1024;
    v38 = v13;
    v39 = 1024;
    *(_DWORD *)v40 = v32;
    _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s=%d (old=%d)", buf, 0x22u);
  }

LABEL_51:
}

LABEL_19:
    if (v15) {
      free(v15);
    }
    goto LABEL_21;
  }

  v9->_internalMTU = 1500LL;
  objc_storeStrong((id *)&v9->_endpoint, a3);
  [v8 setDataMode:1];
  objc_storeStrong((id *)&v10->_parameters, a4);
  v11 = +[NWConnection connectionWithEndpoint:parameters:]( &OBJC_CLASS___NWDatagramConnection,  "connectionWithEndpoint:parameters:",  v7,  v8);
  connection = v10->_connection;
  v10->_connection = (NWDatagramConnection *)v11;

  if (!v10->_connection)
  {
LABEL_21:
    v13 = 0LL;
    goto LABEL_22;
  }

  -[NWUDPSession setupEventHandler](v10, "setupEventHandler");
  v13 = v10;
LABEL_22:

  return v13;
}

  if (v7) {
    free(v7);
  }
}
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
}

    __int16 v12 = *(void **)(v2 + 264);
    goto LABEL_19;
  }

  if (v2)
  {
LABEL_5:
    os_log_type_t v4 = 248LL;
    if (!*(void *)(v2 + 248)) {
      os_log_type_t v4 = 240LL;
    }
    v5 = (void **)*(id *)(v2 + v4);
    goto LABEL_8;
  }

  v5 = 0LL;
LABEL_8:
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3221225472LL;
  v24[2] = __82__NWURLSessionStreamTask_readDataOfMinLength_maxLength_timeout_completionHandler___block_invoke_2;
  v24[3] = &unk_189BC91E8;
  v6 = (dispatch_source_s *)*(id *)(a1 + 40);
  v24[4] = *(void *)(a1 + 32);
  v25 = v6;
  if (v5) {
    -[NWURLSessionDelegateQueue runDelegateBlock:](v5[6], v24);
  }

  BOOL v7 = v25;
LABEL_20:
}

  __break(1u);
}

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
}

  if (v4) {
    free(v4);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
}

    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    goto LABEL_19;
  }

  if ((*(_WORD *)(a1 + 204) & 0x40) == 0)
  {
    *(_DWORD *)(a1 + 192) = a2;
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v13 = "__nw_frame_set_compression_generation_count";
  v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10))
  {
LABEL_19:
    if (!v2) {
      return;
    }
    goto LABEL_20;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_set_compression_generation_count";
    v5 = "%{public}s Attempt to set generation-count on a chain-member";
    goto LABEL_18;
  }

  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_set_compression_generation_count";
    v5 = "%{public}s Attempt to set generation-count on a chain-member, backtrace limit exceeded";
    goto LABEL_18;
  }

  v6 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (os_log_s *)gLogObj;
  os_log_type_t v4 = type;
  BOOL v7 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v6)
  {
    if (!v7) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_set_compression_generation_count";
    v5 = "%{public}s Attempt to set generation-count on a chain-member, no backtrace";
    goto LABEL_18;
  }

  if (v7)
  {
    *(_DWORD *)buf = 136446466;
    v13 = "__nw_frame_set_compression_generation_count";
    uint64_t v14 = 2082;
    v15 = v6;
    _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s Attempt to set generation-count on a chain-member, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v6);
  if (v2) {
LABEL_20:
  }
    free(v2);
}

                    a4 = *(unsigned __int8 *)(a1 + 72);
                    if (a4 == 1) {
                      goto LABEL_67;
                    }
                    if (a4 == 2)
                    {
LABEL_20:
                      if (a2 == a3) {
                        return 227LL;
                      }
                      v17 = *(_DWORD *)a1;
                      while (1)
                      {
                        v18 = *a2;
                        v19 = llparse_blob58[v17];
                        if (v17 == 4)
                        {
                          a4 = 0;
                          v20 = 5;
                        }

                        else
                        {
                          v20 = 0;
                        }

                        if (v18 != v19)
                        {
                          a4 = 2;
                          v20 = 5;
                        }

                        if (v20) {
                          break;
                        }
                        if (v18 == v19) {
                          ++v17;
                        }
                        if (++a2 == a3)
                        {
                          a4 = 1;
                          a2 = a3;
                          goto LABEL_33;
                        }
                      }

                      v17 = 0;
LABEL_33:
                      *(_DWORD *)a1 = v17;
                      if (a4)
                      {
                        if (a4 == 1) {
                          return 227LL;
                        }
                        goto LABEL_1308;
                      }

                      ++a2;
                    }

                    else
                    {
LABEL_35:
                      if (a2 == a3) {
                        return 235LL;
                      }
                      if (*a2 != 72)
                      {
                        *(_BYTE *)(a1 + 72) = 1;
LABEL_67:
                        if (a2 == a3) {
                          return 209LL;
                        }
                        *(void *)(a1 + 8) = a2;
                        *(void *)(a1 + 16) = llhttp__on_method;
LABEL_69:
                        if (a2 != a3)
                        {
                          a4 = *a2 - 65;
                          switch(*a2)
                          {
                            case 'A':
                              ++a2;
                              goto LABEL_72;
                            case 'B':
                              ++a2;
                              goto LABEL_212;
                            case 'C':
                              ++a2;
                              goto LABEL_230;
                            case 'D':
                              ++a2;
                              goto LABEL_278;
                            case 'F':
                              ++a2;
                              goto LABEL_321;
                            case 'G':
                              ++a2;
                              goto LABEL_339;
                            case 'H':
                              ++a2;
                              goto LABEL_377;
                            case 'L':
                              ++a2;
                              goto LABEL_395;
                            case 'M':
                              ++a2;
                              goto LABEL_435;
                            case 'N':
                              ++a2;
                              goto LABEL_540;
                            case 'O':
                              ++a2;
                              goto LABEL_558;
                            case 'P':
                              ++a2;
                              goto LABEL_576;
                            case 'Q':
                              ++a2;
                              goto LABEL_726;
                            case 'R':
                              ++a2;
                              goto LABEL_744;
                            case 'S':
                              ++a2;
                              goto LABEL_822;
                            case 'T':
                              ++a2;
                              goto LABEL_911;
                            case 'U':
                              ++a2;
                              goto LABEL_951;
                            default:
                              goto LABEL_1301;
                          }
                        }

                        return 208LL;
                      }

  if (v3) {
    free(v3);
  }
  return 0LL;
}
  }

                if ((objc_opt_respondsToSelector() & 1) != 0) {
                  [(id)v7 setSpecificUseOnly:1];
                }
                goto LABEL_20;
              }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

LABEL_19:
    if (!v27) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }

  if (!v50)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = (os_log_s *)(id)gLogObj;
    v41 = type;
    if (os_log_type_enabled(v28, type))
    {
      v43 = *(void **)(a1 + 48);
      v42 = *(void *)(a1 + 56);
      v45 = *(void *)(a1 + 32);
      v44 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v42;
      *(_WORD *)&buf[22] = 2114;
      v53 = v43;
      *(_WORD *)v54 = 2114;
      *(void *)&v54[2] = v44;
      v55 = 2114;
      v56 = v45;
      _os_log_impl( &dword_181A5C000,  v28,  v41,  "%{public}s %{public}@ tried to call missing request completion block with connection %{public}@ error %{public}@ for %{public}@, backtrace limit exceeded",  buf,  0x34u);
    }

    goto LABEL_18;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v28 = (os_log_s *)(id)gLogObj;
  v35 = type;
  v36 = os_log_type_enabled(v28, type);
  if (!backtrace_string)
  {
    if (v36)
    {
      v47 = *(void **)(a1 + 48);
      v46 = *(void *)(a1 + 56);
      v49 = *(void *)(a1 + 32);
      v48 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v46;
      *(_WORD *)&buf[22] = 2114;
      v53 = v47;
      *(_WORD *)v54 = 2114;
      *(void *)&v54[2] = v48;
      v55 = 2114;
      v56 = v49;
      _os_log_impl( &dword_181A5C000,  v28,  v35,  "%{public}s %{public}@ tried to call missing request completion block with connection %{public}@ error %{public}@ for %{public}@, no backtrace",  buf,  0x34u);
    }

    goto LABEL_18;
  }

  if (v36)
  {
    v38 = *(void **)(a1 + 48);
    v37 = *(void *)(a1 + 56);
    v40 = *(void *)(a1 + 32);
    v39 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v37;
    *(_WORD *)&buf[22] = 2114;
    v53 = v38;
    *(_WORD *)v54 = 2114;
    *(void *)&v54[2] = v39;
    v55 = 2114;
    v56 = v40;
    v57 = 2082;
    v58 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v28,  v35,  "%{public}s %{public}@ tried to call missing request completion block with connection %{public}@ error %{public}@ f or %{public}@, dumping backtrace:%{public}s",  buf,  0x3Eu);
  }

  free(backtrace_string);
  if (v27) {
LABEL_20:
  }
    free(v27);
LABEL_21:
  if (v10) {
    CFRelease(v10);
  }
}

          v17 = *(_DWORD *)(a1 + 20);
          v18 = (2 * v17);
          if (v6 > v18) {
            return 3LL;
          }
          if (v17) {
            v19 = (v6 + v18 - 2) % v18;
          }
          else {
            v19 = 0;
          }
          *(_DWORD *)(a2 + 64) = v19;
          *(_DWORD *)(a2 + 104) |= 3u;
          *(_DWORD *)(a2 + 136) = 2;
          v26 = *(_DWORD *)(a1 + 20);
          v27 = *(_DWORD *)(a1 + 32);
          v28 = v27 - v26;
          if (v27 >= v26)
          {
            v22 = 1LL;
            if (v27 < v19 || v28 + 1 > v19) {
              return v22;
            }
          }

          else if (v27 < v19 && v27 + v26 >= v19)
          {
            return 1LL;
          }

          goto LABEL_22;
        }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 1LL;
}

  char v8 = *(void ***)(a1 + 24);
  if (v5 != v8)
  {
    v9 = *(void ***)(a1 + 24);
    do
    {
      v11 = *--v9;
      v10 = v11;
      if (v11) {
        os_release(v10);
      }
      *(v8 - 1) = 0LL;
      char v8 = v9;
    }

    while (v9 != v5);
    *(void *)(a1 + 24) = v5;
  }

  do
    __int16 v12 = __ldxr(v4);
  while (__stlxr(0, v4));
  if (v12 != 255)
  {
    v18 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v28 = "nw_array_remove_objects";
    v13 = (char *)_os_log_send_and_compose_impl();
    goto LABEL_40;
  }

  v23.receiver = self;
  v23.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_nat64_prefixes_resolver;
  -[NWConcrete_nw_nat64_prefixes_resolver dealloc](&v23, sel_dealloc, v21, v22);
}

        if (++v15 == 6) {
          goto LABEL_10;
        }
      }
    }

    v11 = inet_ntop(30, (const void *)(a1 + 16 * v8), v76, 0x2Eu);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = v10[8];
      uint64_t v14 = v76;
      if (!v11) {
        uint64_t v14 = "?";
      }
      *(_DWORD *)buf = 136446979;
      v69 = "nw_nat64_copy_prefixes_from_ipv4only_records";
      v70 = 1024;
      v71 = v8;
      v72 = 2085;
      v73 = v14;
      v74 = 1024;
      v75 = v13;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s v6res[%u] %{sensitive}s has non zero bits 64-71: 0x%x",  buf,  0x22u);
    }

LABEL_10:
    ++v8;
  }

  while (v8 != a2);
  if (!(v9 | v65))
  {
    if (v6) {
      free(v6);
    }
    if (v7)
    {
      v21 = v7;
      goto LABEL_69;
    }

    return 0LL;
  }

  if (v9 <= v65) {
    v22 = v65;
  }
  else {
    v22 = v9;
  }
  if (!(_DWORD)v22)
  {
    __nwlog_obj();
    v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v76 = 136446210;
    *(void *)&v76[4] = "strict_calloc";
    v55 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v55);
    if (!(_DWORD)result)
    {
      free(v55);
      goto LABEL_43;
    }

    goto LABEL_127;
  }
}

LABEL_35:
    v5 = 0;
    goto LABEL_10;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v4 + 8);
  if (*((void *)v4 + 2) == 1LL)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v4 + 8);
    v5 = 0;
  }

  else
  {
    *(void *)__dst = 0LL;
    start_of_key_locked = nw_txt_record_find_start_of_key_locked(v4, key, __dst, 0LL, 0LL, 0LL);
    v5 = start_of_key_locked != 1;
    if (start_of_key_locked != 1)
    {
      BOOL v7 = **(_BYTE **)__dst + 1LL;
      memmove( *(void **)__dst,  (const void *)(*(void *)__dst + v7),  *((void *)v4 + 1) + *((void *)v4 + 2) - (*(void *)__dst + v7));
      char v8 = *((void *)v4 + 2) - v7;
      *((void *)v4 + 2) = v8;
      if (!v8)
      {
        **((_BYTE **)v4 + 1) = 0;
        *((void *)v4 + 2) = 1LL;
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)v4 + 8);
  }
  }

    free(v8);
    goto LABEL_19;
  }

  os_log_type_t v4 = a3;
  v5 = nw_interface_create_with_index(a3);
  if (v5)
  {
    self = -[NWInterface initWithInterface:](self, "initWithInterface:", v5);
    v6 = self;
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v22 = "-[NWInterface initWithInterfaceIndex:]";
      v23 = 1024;
      LODWORD(v24) = v4;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s nw_interface_create_with_index(%u) failed",  buf,  0x12u);
    }

    v6 = 0LL;
  }

LABEL_20:
  return v6;
}

    if (v2) {
      free(v2);
    }
LABEL_20:
    (*(void (**)(void, void))(*(void *)(v1 + 96) + 16LL))(*(void *)(v1 + 96), 0LL);
    char v8 = *(const void **)(v1 + 96);
    if (v8) {
      _Block_release(v8);
    }
    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_http3_uni_stream_destroy";
  v1 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = (os_log_s *)__nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_40;
    }
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream";
    goto LABEL_39;
  }

  if (!v15)
  {
    v9 = (os_log_s *)__nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_40;
    }
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    goto LABEL_39;
  }

  v13 = (char *)__nw_create_backtrace_string();
  v9 = (os_log_s *)__nwlog_obj();
  v10 = type;
  uint64_t v14 = os_log_type_enabled(v9, type);
  if (v13)
  {
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v18 = "nw_protocol_http3_uni_stream_destroy";
      v19 = 2082;
      v20 = (uint64_t)v13;
      _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null http3_stream, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v13);
    if (v1) {
      goto LABEL_22;
    }
    return;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream, no backtrace";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
  }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    if (v4) {
      free(v4);
    }
    return 1LL;
  }

  *(_DWORD *)buf = 136446210;
  v23 = "nw_protocol_http3_connect";
  v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v20)
    {
      __int16 v12 = (os_log_s *)__nwlog_obj();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        uint64_t v14 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v12 = (os_log_s *)__nwlog_obj();
    v13 = type;
    v19 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_http3_connect";
        uint64_t v14 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_60;
      }

      goto LABEL_61;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_http3_connect";
      v24 = 2082;
      v25 = backtrace_string;
      v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }

      goto LABEL_19;
    }

    if (!v16)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v4 = (os_log_s *)(id)gLogObj;
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s nw_queue_register_dispatch_queue is deprecated, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_18;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v4 = (os_log_s *)(id)gLogObj;
    BOOL v7 = type;
    char v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_queue_register_dispatch_queue";
        _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s nw_queue_register_dispatch_queue is deprecated, no backtrace",  buf,  0xCu);
      }

      goto LABEL_18;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_queue_register_dispatch_queue";
      v20 = 2082;
      v21 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s nw_queue_register_dispatch_queue is deprecated, dumping backtrace:%{public}s",  buf,  0x16u);
    }
  }

      v22 = *(void **)(v21 + 72);
LABEL_19:
      id = nw_connection_get_id(v22);
      *(_DWORD *)buf = 68289538;
      v46 = 16;
      v47 = 2098;
      v48 = &v42;
      v49 = 1024;
      v50 = v20;
      v51 = 2048;
      v52 = id;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v13,  OS_LOG_TYPE_DEFAULT,  "Task <%{public,uuid_t}.16P>.<%u> created [C%llu]",  buf,  0x22u);

      goto LABEL_20;
    }

  if (v3) {
    free(v3);
  }
}
  }

  if (v10) {
    free(v10);
  }
}
  }

  if (v7) {
    free(v7);
  }
}
  }

  if (v5) {
    free(v5);
  }
}
  }
  }

  if (v5) {
    free(v5);
  }
}
  }

  if (v10) {
    free(v10);
  }
}
  }

  if (v3) {
    free(v3);
  }
}
  }

  if (v6) {
    free(v6);
  }
}
  }

  if (v3) {
    free(v3);
  }
}
  }

  if (v7) {
    free(v7);
  }
}
  }

  if (v3) {
    free(v3);
  }
}
  }

  if (v3) {
    free(v3);
  }
}
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }

  if (v6) {
    free(v6);
  }
}
  }

  if (v3) {
    free(v3);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}
  }
  }
  }

      free(v15);
      goto LABEL_19;
    }

    __nwlog_obj();
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
    v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
        v34 = "%{public}s [super init] failed";
LABEL_61:
        _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
      }
    }

    else if (v41)
    {
      v37 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v33 = type;
      v38 = os_log_type_enabled(v32, type);
      if (v37)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
          v45 = 2082;
          v46 = v37;
          _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v37);
        goto LABEL_63;
      }

      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
        v34 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_61;
      }
    }

    else
    {
      __nwlog_obj();
      v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
        v34 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_61;
      }
    }

LABEL_63:
    if (v31) {
      free(v31);
    }
    v13 = 0LL;
    goto LABEL_21;
  }

  __nwlog_obj();
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
  v26 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v26, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
        v29 = "%{public}s called with null encodedData";
LABEL_54:
        _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
      }
    }

    else
    {
      if (v41)
      {
        v35 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v28 = type;
        v36 = os_log_type_enabled(v27, type);
        if (v35)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
            v45 = 2082;
            v46 = v35;
            _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s called with null encodedData, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v35);
          goto LABEL_56;
        }

        if (!v36) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
        v29 = "%{public}s called with null encodedData, no backtrace";
        goto LABEL_54;
      }

      __nwlog_obj();
      v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "-[NWBrowseDescriptor initWithEncodedData:]";
        v29 = "%{public}s called with null encodedData, backtrace limit exceeded";
        goto LABEL_54;
      }
    }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
}

  if (v4) {
    free(v4);
  }
}

  if (v10) {
    free(v10);
  }
}

        v16 = 0LL;
LABEL_19:

LABEL_20:
        goto LABEL_21;
      }

      __nwlog_obj();
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v54 = "nw_connection_create_interface_status_monitor";
      v32 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (__nwlog_fault(v32, &type, &v51))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v54 = "nw_connection_create_interface_status_monitor";
            _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s called with null monitor", buf, 0xCu);
          }
        }

        else if (v51)
        {
          v44 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v45 = type;
          v46 = os_log_type_enabled(v33, type);
          if (v44)
          {
            if (v46)
            {
              *(_DWORD *)buf = 136446466;
              v54 = "nw_connection_create_interface_status_monitor";
              v55 = 2082;
              v56 = v44;
              _os_log_impl( &dword_181A5C000,  v33,  v45,  "%{public}s called with null monitor, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v44);
            goto LABEL_93;
          }

          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            v54 = "nw_connection_create_interface_status_monitor";
            _os_log_impl(&dword_181A5C000, v33, v45, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v50 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v54 = "nw_connection_create_interface_status_monitor";
            _os_log_impl( &dword_181A5C000,  v33,  v50,  "%{public}s called with null monitor, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }
  }
  }

  if (v1) {
    free(v1);
  }
}

          if (!v2) {
            return;
          }
        }

        if (nw_link_set_flow_control_status(*(void **)(v3 + 72), 0))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v6 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = (const char *)(v3 + 84);
            _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s Flow resumed for flow id %{public}s",  buf,  0x16u);
          }
        }

        if (v4)
        {
          BOOL v7 = *(void *)(v4 + 24);
          if (v7)
          {
            char v8 = *(void (**)(uint64_t, uint64_t, void))(v7 + 104);
            if (v8)
            {
              v8(v4, v1 + 24, *(void *)(v3 + 72));
LABEL_14:
              v9 = *(void *)(v3 + 56);
              v10 = *(void **)(v3 + 64);
              if (v9)
              {
                *(void *)(v9 + 64) = v10;
                v10 = *(void **)(v3 + 64);
              }

              else
              {
                *(void *)(v1 + 392) = v10;
              }

              *v10 = v9;
              *(_BYTE *)(v3 + 121) &= ~2u;
              goto LABEL_18;
            }
          }

          __nwlog_obj();
          v11 = *(const char **)(v4 + 16);
          if (!v11) {
            v11 = "invalid";
          }
        }

        else
        {
          __nwlog_obj();
          v11 = "invalid";
        }

        *(_DWORD *)buf = 136446466;
        v52 = "nw_channel_check_flows_allowed";
        v53 = 2082;
        v54 = v11;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v49 = 0;
        v47 = (char *)v14;
        if (__nwlog_fault(v14, &type, &v49))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v15 = (os_log_s *)__nwlog_obj();
            v16 = type;
            log = v15;
            if (!os_log_type_enabled(v15, type)) {
              goto LABEL_63;
            }
            if (v4)
            {
              v17 = *(const char **)(v4 + 16);
              if (!v17) {
                v17 = "invalid";
              }
            }

            else
            {
              v17 = "invalid";
            }

            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = v17;
            v25 = log;
            v26 = v16;
            v27 = "%{public}s protocol %{public}s has invalid link_state callback";
            goto LABEL_62;
          }

          if (!v49)
          {
            v21 = (os_log_s *)__nwlog_obj();
            v22 = type;
            logb = v21;
            if (!os_log_type_enabled(v21, type)) {
              goto LABEL_63;
            }
            if (v4)
            {
              v23 = *(const char **)(v4 + 16);
              if (!v23) {
                v23 = "invalid";
              }
            }

            else
            {
              v23 = "invalid";
            }

            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = v23;
            v25 = logb;
            v26 = v22;
            v27 = "%{public}s protocol %{public}s has invalid link_state callback, backtrace limit exceeded";
            goto LABEL_62;
          }

          v18 = (char *)__nw_create_backtrace_string();
          loga = (os_log_s *)__nwlog_obj();
          v40 = type;
          v19 = os_log_type_enabled(loga, type);
          if (v18)
          {
            if (v19)
            {
              if (v4)
              {
                v20 = *(const char **)(v4 + 16);
                if (!v20) {
                  v20 = "invalid";
                }
              }

              else
              {
                v20 = "invalid";
              }

              *(_DWORD *)buf = 136446722;
              v52 = "nw_channel_check_flows_allowed";
              v53 = 2082;
              v54 = v20;
              v55 = 2082;
              v56[0] = v18;
              _os_log_impl( &dword_181A5C000,  loga,  v40,  "%{public}s protocol %{public}s has invalid link_state callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v18);
            goto LABEL_63;
          }

          if (v19)
          {
            if (v4)
            {
              v24 = *(const char **)(v4 + 16);
              if (!v24) {
                v24 = "invalid";
              }
            }

            else
            {
              v24 = "invalid";
            }

            v25 = loga;
            v26 = v40;
            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = v24;
            v27 = "%{public}s protocol %{public}s has invalid link_state callback, no backtrace";
LABEL_62:
            _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0x16u);
          }
        }

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

uint64_t nw_endpoint_is_active(void *a1, int a2)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  os_log_type_t v4 = v3;
  if (v3)
  {
    if (!a2) {
      goto LABEL_6;
    }
    v5 = (os_unfair_lock_s *)v3;
    *(void *)v63 = 0LL;
    *(void *)&v63[8] = v63;
    *(void *)&v63[16] = 0x2020000000LL;
    char v64 = 0;
    *(void *)os_log_type_t type = 0LL;
    uint64_t v57 = (uint64_t)type;
    uint64_t v58 = 0x2020000000LL;
    LOBYTE(v59) = 0;
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke;
    v66 = &unk_189BC9210;
    v67 = v5;
    v68 = type;
    nw_endpoint_locked(v5, buf);
    char v6 = *(_BYTE *)(v57 + 24);

    _Block_object_dispose(type, 8);
    *(_BYTE *)(*(void *)&v63[8] + 24LL) = v6;
    _Block_object_dispose(v63, 8);
    if (v6)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          logging_description = nw_endpoint_get_logging_description(v5);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = logging_description;
          _os_log_impl(&dword_181A5C000, v46, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s has active edges", buf, 0x16u);
        }
      }

      int v7 = 1;
    }

    else
    {
LABEL_6:
      int v7 = 0;
    }

    char v8 = v4;
    v9 = (void *)v8[26];
    if (v9)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          v38 = nw_endpoint_get_logging_description(v8);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v38;
          _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %s before cleanup, has registrar",  buf,  0x16u);
        }

        v9 = (void *)v8[26];
      }

      if (!nw_protocol_instance_registrar_get_instance_count(v9))
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            v51 = nw_endpoint_get_logging_description(v8);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v51;
            _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %s registrar empty, removing",  buf,  0x16u);
          }
        }

        v10 = (os_log_s *)v8[26];
        v8[26] = 0LL;
        goto LABEL_19;
      }

      if (!gLogDatapath) {
        goto LABEL_20;
      }
      __nwlog_obj();
      v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_19;
      }
      v11 = nw_endpoint_get_logging_description(v8);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v11;
      __int16 v12 = "%{public}s endpoint %s registrar not empty, keeping";
    }

    else
    {
      if (!gLogDatapath) {
        goto LABEL_20;
      }
      __nwlog_obj();
      v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
LABEL_19:

LABEL_20:
        uint64_t v14 = (void *)v8[26];
        if (v14)
        {
          BOOL v15 = nw_protocol_instance_registrar_get_instance_count(v14) == 0;

          if (v15)
          {
            int v16 = 0;
LABEL_27:
            v18 = v8;
            v19 = (void *)v18[1];
            if (v19)
            {
              v20 = v19;
              v21 = v20;
              if (((_BYTE)v20[17] & 8) == 0) {
                dispatch_assert_queue_V2(v20[1]);
              }

              uint64_t v22 = v18[25];
              if (v22 && *(_DWORD *)(v22 + 40))
              {
                uint64_t v23 = MEMORY[0x1895F87A8];
                *(void *)buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = __nw_endpoint_has_associations_block_invoke;
                v66 = &unk_189BC86F0;
                v24 = v18;
                v67 = v24;
                nw_hash_table_apply((char *)v22, (uint64_t)buf);
                *(void *)os_log_type_t type = v23;
                uint64_t v57 = 3221225472LL;
                uint64_t v58 = (uint64_t)__nw_endpoint_has_associations_block_invoke_34;
                v59 = &unk_189BC93A0;
                v25 = v24;
                v60 = v25;
                os_unfair_lock_lock(v24 + 45);
                __nw_endpoint_has_associations_block_invoke_34((uint64_t)type);
                os_unfair_lock_unlock(v24 + 45);
                BOOL v27 = nw_hash_table_count(v18[25], v26) == 0;

                if (!v27)
                {
                  if (gLogDatapath)
                  {
                    __nwlog_obj();
                    v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
                    {
                      v49 = nw_endpoint_get_logging_description(v25);
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = v49;
                      _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %s has associations",  buf,  0x16u);
                    }
                  }

                  int v28 = 1;
                  goto LABEL_89;
                }

LABEL_88:
                int v28 = 0;
LABEL_89:
                uint64_t v54 = v7 | v16 | v28;
                goto LABEL_90;
              }

      goto LABEL_89;
    }

    if (!v62)
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v35, type))
      {
        uint64_t v57 = (const char *)*((void *)v3 + 2);
        if (!v57) {
          uint64_t v57 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v69 = "__nw_protocol_connect";
        v70 = 2082;
        v71 = (void *)v57;
        v72 = 2048;
        v73 = v3;
        _os_log_impl( &dword_181A5C000,  v35,  v56,  "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded",  buf,  0x20u);
      }

      goto LABEL_88;
    }

    v42 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v43 = type;
    BOOL v44 = os_log_type_enabled(v35, type);
    if (!v42)
    {
      if (v44)
      {
        v59 = (const char *)*((void *)v3 + 2);
        if (!v59) {
          v59 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v69 = "__nw_protocol_connect";
        v70 = 2082;
        v71 = (void *)v59;
        v72 = 2048;
        v73 = v3;
        _os_log_impl( &dword_181A5C000,  v35,  v43,  "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace",  buf,  0x20u);
      }

      goto LABEL_88;
    }

    if (v44)
    {
      v45 = (const char *)*((void *)v3 + 2);
      if (!v45) {
        v45 = "invalid";
      }
      *(_DWORD *)buf = 136446978;
      uint64_t v69 = "__nw_protocol_connect";
      v70 = 2082;
      v71 = (void *)v45;
      v72 = 2048;
      v73 = v3;
      v74 = 2082;
      v75 = v42;
      _os_log_impl( &dword_181A5C000,  v35,  v43,  "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v42);
  }

    free(v26);
    goto LABEL_89;
  }

  objc_storeStrong((id *)v19 + 25, a4);
  v29 = v19[25];
  if (v29)
  {
    v30 = v29;
    else {
      v31 = (nw_endpoint *)nw_path_copy_scoped_interface(v30);
    }

    v38 = v19[26];
    v19[26] = v31;
  }

  v39 = nw_array_create();
  os_log_type_t v40 = v19[18];
  v19[18] = (nw_endpoint_t)v39;

  BOOL v41 = *((_BYTE *)v19 + 346) & 0xFE | v17;
  *((_BYTE *)v19 + 346) = v41;
  v42 = v19[25];
  if (v42)
  {
    *((_DWORD *)v19 + 14) = nw_path_get_dns_service_id(v42, 1);
    else {
      os_log_type_t v43 = 0;
    }
    *((_BYTE *)v19 + 346) = *((_BYTE *)v19 + 346) & 0xEF | v43;
    if (nw_path_has_ipv4(v19[25])) {
      BOOL v44 = 64;
    }
    else {
      BOOL v44 = 0;
    }
    *((_BYTE *)v19 + 346) = *((_BYTE *)v19 + 346) & 0xBF | v44;
    if (nw_path_has_ipv6(v19[25])) {
      v45 = 0x80;
    }
    else {
      v45 = 0;
    }
    *((_BYTE *)v19 + 346) = v45 & 0x80 | *((_BYTE *)v19 + 346) & 0x7F;
    *((_BYTE *)v19 + 347) = *((_BYTE *)v19 + 347) & 0xFE | nw_path_has_nat64_prefixes(v19[25]);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    *(void *)&_BYTE buf[24] = __Block_byref_object_copy__5627;
    *(void *)&buf[32] = __Block_byref_object_dispose__5628;
    *(void *)&buf[40] = 0LL;
    *(void *)os_log_type_t type = 0LL;
    v74 = type;
    v76 = 0;
    v75 = 0x2020000000LL;
    v46 = v19[25];
    v72[0] = MEMORY[0x1895F87A8];
    v72[1] = 3221225472LL;
    v72[2] = __67__NWConcrete_nw_resolver_initWithEndpoint_parameters_path_log_str___block_invoke;
    v72[3] = &unk_189BB6860;
    v72[4] = type;
    v72[5] = buf;
    nw_path_enumerate_resolver_configs(v46, v72);
    v47 = *(void *)&buf[8];
    v48 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v48)
    {
      if (*((_DWORD *)v74 + 6) == 4)
      {
        *((_BYTE *)v19 + 347) |= 0x20u;
        v48 = *(void **)(v47 + 40);
      }

      if (nw_resolver_config_get_allow_failover(v48)) {
        v49 = 64;
      }
      else {
        v49 = 0;
      }
      *((_BYTE *)v19 + 347) = *((_BYTE *)v19 + 347) & 0xBF | v49;
      nw_resolver_config_get_identifier(*(void **)(*(void *)&buf[8] + 40LL), v19 + 29);
    }

    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);
  }

  else
  {
    *((_BYTE *)v19 + 346) = v41 | 0xC0;
    *((_BYTE *)v19 + 347) &= ~1u;
  }

  *((_DWORD *)v19 + 62) = 0;
  else {
    v50 = 0;
  }
  *((_BYTE *)v19 + 346) = *((_BYTE *)v19 + 346) & 0xDF | v50;
  *((_BYTE *)v19 + 348) = *((_BYTE *)v19 + 348) & 0xFD | (2
                                                        * (nw_parameters_get_expired_dns_behavior(v19[2]) == (nw_parameters_expired_dns_behavior_prohibit|nw_parameters_expired_dns_behavior_allow)));
  if (a5)
  {
    v51 = 0LL;
    os_log_type_t v52 = (char *)(v19 + 32);
    os_log_type_t v53 = 84LL;
    while (1)
    {
      uint64_t v54 = *(unsigned __int8 *)(a5 + v51);
      v52[v51] = v54;
      if (!v54) {
        break;
      }
      --v53;
      ++v51;
      if (v53 <= 1)
      {
        v52[v51] = 0;
        break;
      }
    }
  }

  else
  {
    if (!nw_parameters_get_sensitive_redacted(v19[2])) {
      nw_endpoint_set_do_not_redact(*v20);
    }
    *((_DWORD *)v19 + 85) = nw_resolver_get_next_log_id();
    *((_BYTE *)v19 + 347) |= 0x10u;
    if ((*((_BYTE *)v19 + 346) & 0x20) == 0)
    {
      if (*((_BYTE *)v19 + 256))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v55 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          logging_description = nw_endpoint_get_logging_description(*v20);
          uint64_t v57 = v19[2];
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v19 + 32;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&_BYTE buf[24] = logging_description;
          *(_WORD *)&buf[32] = 2112;
          *(void *)&buf[34] = v57;
          _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s] created for %{public}s using: %@",  buf,  0x2Au);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v59 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          v60 = *((_DWORD *)v19 + 85);
          char v61 = nw_endpoint_get_logging_description(v19[3]);
          os_log_type_t v62 = v19[2];
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:]";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v60;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v61;
          *(_WORD *)&buf[28] = 2112;
          *(void *)&buf[30] = v62;
          _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEFAULT,  "%{public}s [R%u] created for %{public}s using: %@",  buf,  0x26u);
        }
      }
    }
  }

        if (state == 3)
        {
          *uint64_t v26 = v27 | 0xC;
          v90 = v24;
          v91 = v90->association;

          if (v91) {
            nw_association_mark_flow_connected(v91, v90);
          }
          v90->event = (nw_endpoint_handler_event_s)393219;
          nw_endpoint_handler_report(v90, 0LL, &v90->event.domain, 0LL);
          if (*((void *)v4 + 127)) {
            nw_endpoint_handler_register_adaptive_read_handler(v90);
          }
          if (*((void *)v4 + 128)) {
            nw_endpoint_handler_register_adaptive_write_handler(v90);
          }
          if (*((void *)v4 + 129)) {
            nw_endpoint_handler_register_keepalive_handler(v90);
          }
          if (*((void *)v4 + 130)) {
            nw_endpoint_handler_register_metadata_changed_handler(v90);
          }
        }

        goto LABEL_100;
      }

      goto LABEL_85;
    }

    if ((*((_BYTE *)v4 + 32) & 2) != 0) {
      goto LABEL_47;
    }
    if ((*((_BYTE *)v4 + 33) & 1) == 0)
    {
      int v28 = (void *)*((void *)v4 + 117);
      if (v28)
      {
        is_viable = nw_endpoint_handler_is_viable(v28);
        minimize_logging = nw_endpoint_handler_get_minimize_logging(v24);
        logging_disabled = nw_endpoint_handler_get_logging_disabled(v24);
        v159 = is_viable;
        if (!minimize_logging)
        {
          if ((logging_disabled & 1) != 0) {
            goto LABEL_81;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v32 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
          {
            id_string = nw_endpoint_handler_get_id_string(v24);
            loga = nw_endpoint_handler_dry_run_string(v24);
            v34 = id_string;
            v35 = nw_endpoint_handler_copy_endpoint(v24);
            os_log_type_t v36 = nw_endpoint_get_logging_description(v35);
            v37 = nw_endpoint_handler_state_string(v24);
            v38 = nw_endpoint_handler_mode_string(v24);
            v39 = nw_endpoint_handler_copy_current_path(v24);
            os_log_type_t v40 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            BOOL v41 = "not ";
            v168 = (void *)v34;
            v167 = 2082;
            if (v159) {
              BOOL v41 = "";
            }
            v169 = 2082;
            v170 = loga;
            v171 = 2082;
            v172 = (void *)v36;
            v173 = 2082;
            v174 = (void *)v37;
            v175 = 2082;
            v176 = v38;
            v177 = 2114;
            v178 = v39;
            v179 = 2082;
            v180 = v40;
            v181 = 2082;
            v182 = v41;
            _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{publi c}s, child is %{public}sviable",  buf,  0x5Cu);
          }

          goto LABEL_80;
        }

        if ((logging_disabled & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v32 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            v122 = nw_endpoint_handler_get_id_string(v24);
            loge = nw_endpoint_handler_dry_run_string(v24);
            v123 = nw_endpoint_handler_copy_endpoint(v24);
            v124 = nw_endpoint_get_logging_description(v123);
            v125 = nw_endpoint_handler_state_string(v24);
            v126 = nw_endpoint_handler_mode_string(v24);
            v127 = nw_endpoint_handler_copy_current_path(v24);
            v128 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            v129 = "not ";
            v168 = (void *)v122;
            v167 = 2082;
            if (v159) {
              v129 = "";
            }
            v169 = 2082;
            v170 = loge;
            v171 = 2082;
            v172 = (void *)v124;
            v173 = 2082;
            v174 = (void *)v125;
            v175 = 2082;
            v176 = v126;
            v177 = 2114;
            v178 = v127;
            v179 = 2082;
            v180 = v128;
            v181 = 2082;
            v182 = v129;
            _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{publi c}s, child is %{public}sviable",  buf,  0x5Cu);
          }

          goto LABEL_80;
        }

    if (!v28)
    {
LABEL_90:
      v48 = v2[2];
      if (v48 && !nw_path_parameters_get_logging_disabled(v48[13]))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v49 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          v50 = v7->top_id;
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
          *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v50;
          _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] End of report",  (uint8_t *)&buf,  0x12u);
        }
      }

      goto LABEL_97;
    }

            __break(1u);
LABEL_89:
            __break(1u);
            goto LABEL_90;
          }
        }

        if ((v15 & 0x2000000000000000LL) != 0)
        {
          v70 = v14;
          v71 = v15 & 0xFFFFFFFFFFFFFFLL;
          v31 = *((_BYTE *)&v70 + v29);
          if (v27 == v25) {
            goto LABEL_31;
          }
          goto LABEL_26;
        }

        v30 = (v15 & 0xFFFFFFFFFFFFFFFLL) + 32;
        if ((v14 & 0x1000000000000000LL) == 0) {
          v30 = sub_18264F228();
        }
        v31 = *(_BYTE *)(v30 + v29);
        if (v27 != v25) {
          goto LABEL_26;
        }
LABEL_31:
        uint64_t v26 = sub_181C23710(v26, v14, v15);
        if ((v15 & 0x1000000000000000LL) != 0) {
          goto LABEL_27;
        }
LABEL_14:
        uint64_t v26 = (v26 & 0xFFFFFFFFFFFF0000LL) + 65540;
        if (v31 < 0) {
          goto LABEL_67;
        }
      }
    }

    v60 = v55;
    v70 = v9;
    v71 = v10 & 0xFFFFFFFFFFFFFFLL;
    MEMORY[0x1895F8858](v19);
    v59 = &v55[-8];
    v55[-6] = sub_181C86F80;
    v55[-5] = v32;
    v55[-4] = &v70;
    v55[-3] = v9;
    v55[-2] = v10;
    v55[-1] = v72;
    if ((v15 & 0x2000000000000000LL) != 0) {
      v33 = HIBYTE(v15) & 0xF;
    }
    else {
      v33 = v14 & 0xFFFFFFFFFFFFLL;
    }
    if ((v15 & 0x1000000000000000LL) != 0) {
      v34 = (v14 >> 59) & 1;
    }
    else {
      v34 = 1LL;
    }
    uint64_t v58 = v34;
    v35 = 4LL << v34;
    os_log_type_t v36 = 15LL;
    do
    {
      while (1)
      {
        if (4 * v33 == v36 >> 14)
        {
LABEL_59:
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          v42 = v61;
          os_log_type_t v43 = sub_181C7CBF8((void (*)(char *__return_ptr, void *))sub_181C86FC0, (uint64_t)v59, v14, v15);
          char v61 = v42;
          os_log_type_t v4 = v66;
          goto LABEL_76;
        }

        v37 = v36 & 0xC;
        v38 = v36;
        if (v37 == v35) {
          v38 = sub_181C23710(v36, v14, v15);
        }
        v39 = v38 >> 16;
        if (v38 >> 16 >= v33)
        {
          __break(1u);
LABEL_83:
          __break(1u);
LABEL_84:
          __break(1u);
LABEL_85:
          __break(1u);
LABEL_86:
          __break(1u);
LABEL_87:
          __break(1u);
          goto LABEL_88;
        }

        if ((v15 & 0x1000000000000000LL) == 0) {
          break;
        }
        BOOL v41 = sub_18264EBC8();
        if (v37 == v35) {
          goto LABEL_57;
        }
LABEL_52:
        if ((v15 & 0x1000000000000000LL) != 0) {
          goto LABEL_53;
        }
LABEL_40:
        os_log_type_t v36 = (v36 & 0xFFFFFFFFFFFF0000LL) + 65540;
        if (v41 < 0) {
          goto LABEL_60;
        }
      }

      if ((v15 & 0x2000000000000000LL) != 0)
      {
        v69[0] = v14;
        v69[1] = v15 & 0xFFFFFFFFFFFFFFLL;
        BOOL v41 = *((_BYTE *)v69 + v39);
        if (v37 == v35) {
          goto LABEL_57;
        }
        goto LABEL_52;
      }

      os_log_type_t v40 = (v15 & 0xFFFFFFFFFFFFFFFLL) + 32;
      if ((v14 & 0x1000000000000000LL) == 0) {
        os_log_type_t v40 = sub_18264F228();
      }
      BOOL v41 = *(_BYTE *)(v40 + v39);
      if (v37 != v35) {
        goto LABEL_52;
      }
LABEL_57:
      os_log_type_t v36 = sub_181C23710(v36, v14, v15);
      if ((v15 & 0x1000000000000000LL) == 0) {
        goto LABEL_40;
      }
LABEL_53:
      if (v33 <= v36 >> 16) {
        goto LABEL_84;
      }
      os_log_type_t v36 = sub_18264EB98();
    }

    while ((v41 & 0x80) == 0);
LABEL_60:
    BOOL v44 = 11LL;
    if ((_DWORD)v58) {
      BOOL v44 = 7LL;
    }
    v45 = sub_181C86740(0xFuLL, v44 | (v33 << 16), v14, v15);
    v46 = v45 + 1;
    if (__OFADD__(v45, 1LL)) {
      goto LABEL_87;
    }
    if (v46 < 0) {
      goto LABEL_89;
    }
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    isStackAllocationSafe = swift_bridgeObjectRetain();
    if (v46 >= 1025)
    {
      isStackAllocationSafe = swift_stdlib_isStackAllocationSafe();
      if ((isStackAllocationSafe & 1) == 0) {
        goto LABEL_74;
      }
    }

          free(v49);
          if (!v23) {
            goto LABEL_142;
          }
LABEL_140:
          v74 = (char *)v23;
LABEL_141:
          free(v74);
          goto LABEL_142;
        }

        value = xpc_int64_get_value(v21);
        v42 = value;
        if (!value)
        {
          v48 = 0;
LABEL_143:

          goto LABEL_179;
        }

        if (!(value >> 31))
        {
          __nwlog_obj();
          os_log_type_t v43 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446466;
          v105 = "networkd_privileged_set_settings";
          v106 = 1024;
          *(_DWORD *)v107 = v42;
          BOOL v44 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v102 = 0;
          if (__nwlog_fault(v44, &type, &v102))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v46 = type;
              if (os_log_type_enabled(v45, type))
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 1024;
                *(_DWORD *)v107 = v42;
                _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
              }
            }

            else if (v102)
            {
              v75 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v76 = type;
              v77 = os_log_type_enabled(v45, type);
              if (v75)
              {
                if (v77)
                {
                  *(_DWORD *)buf = 136446722;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 1024;
                  *(_DWORD *)v107 = v42;
                  *(_WORD *)&v107[4] = 2082;
                  *(void *)&v107[6] = v75;
                  _os_log_impl( &dword_181A5C000,  v45,  v76,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
                }

                free(v75);
                if (!v44) {
                  goto LABEL_142;
                }
LABEL_190:
                v74 = (char *)v44;
                goto LABEL_141;
              }

              if (v77)
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 1024;
                *(_DWORD *)v107 = v42;
                _os_log_impl( &dword_181A5C000,  v45,  v76,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
              }
            }

            else
            {
              __nwlog_obj();
              v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v82 = type;
              if (os_log_type_enabled(v45, type))
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 1024;
                *(_DWORD *)v107 = v42;
                _os_log_impl( &dword_181A5C000,  v45,  v82,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
              }
            }
          }

    if (v41) {
      free(v41);
    }
    goto LABEL_90;
  }

  __int16 v12 = (nw_parameters *)[v10 copyCParameters];
  v13 = nw_parameters_copy_default_protocol_stack(v12);
  uint64_t v14 = nw_protocol_stack_copy_transport_protocol(v13);
  BOOL v15 = v14 == 0LL;

  if (v15)
  {
    options = nw_protocol_create_options((void *)g_tcp_definition);
    nw_protocol_stack_set_transport_protocol(v13, (nw_protocol_options_t)options);
  }

  nw_parameters_set_indefinite(v12, 1);
  nw_parameters_set_no_opaque_proxy(v12, 1);
  [v9 internalEndpoint];
  v17 = (nw_endpoint *)objc_claimAutoreleasedReturnValue();
  v18 = nw_connection_create(v17, v12);

  if (v18)
  {
    if (NWCopyInternalQueue_init_once != -1) {
      dispatch_once(&NWCopyInternalQueue_init_once, &__block_literal_global_62911);
    }
    v19 = (dispatch_queue_s *)(id)NWCopyInternalQueue_nwQueue;
    nw_connection_set_queue(v18, v19);

    objc_storeStrong((id *)&v11->_endpoint, a3);
    v20 = -[NWParameters initWithParameters:](objc_alloc(&OBJC_CLASS___NWParameters), "initWithParameters:", v12);
    parameters = v11->_parameters;
    v11->_parameters = v20;

    objc_storeStrong((id *)&v11->_internalConnection, v18);
    objc_storeWeak((id *)&v11->_delegate, obj);
    v11->_state = 1LL;
    -[NWTCPConnection startInternal](v11, "startInternal");
    uint64_t v22 = v11;
    goto LABEL_32;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v23 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  char v61 = "-[NWTCPConnection initWithEndpoint:parameters:delegate:]";
  v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v58 = 0;
  if (__nwlog_fault(v24, &type, &v58))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = (os_log_s *)(id)gLogObj;
      uint64_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "-[NWTCPConnection initWithEndpoint:parameters:delegate:]";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s nw_connection_create failed", buf, 0xCu);
      }
    }

    else if (v58)
    {
      BOOL v27 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = (os_log_s *)(id)gLogObj;
      int v28 = type;
      v29 = os_log_type_enabled(v25, type);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          char v61 = "-[NWTCPConnection initWithEndpoint:parameters:delegate:]";
          os_log_type_t v62 = 2082;
          v63 = v27;
          _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s nw_connection_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v27);
        if (!v24) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "-[NWTCPConnection initWithEndpoint:parameters:delegate:]";
        _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s nw_connection_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = (os_log_s *)(id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "-[NWTCPConnection initWithEndpoint:parameters:delegate:]";
        _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s nw_connection_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v24) {
LABEL_30:
  }
    free(v24);
LABEL_31:
  uint64_t v22 = 0LL;
LABEL_32:

LABEL_33:
  return v22;
}

      if (gLogDatapath)
      {
        os_log_type_t v43 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v9;
          _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s sending %u frames to the below protocol",  buf,  0x12u);
        }
      }

      int v28 = *(void *)(a1 + 32);
      if (v28)
      {
        v29 = *(void **)(v28 + 40);
        if (v29 == &nw_protocol_ref_counted_handle)
        {
          v30 = *(void *)(v28 + 88);
          if (v30) {
            *(void *)(v28 + 88) = v30 + 1;
          }
        }

        v31 = *(void *)(v28 + 24);
        if (v31)
        {
          os_log_type_t v32 = *(void (**)(uint64_t, void *))(v31 + 96);
          if (v32)
          {
            v32(v28, v57);
LABEL_96:
            if (v29 != &nw_protocol_ref_counted_handle) {
              goto LABEL_98;
            }
            if (*(_UNKNOWN **)(v28 + 40) != &nw_protocol_ref_counted_handle) {
              goto LABEL_98;
            }
            v33 = *(void *)(v28 + 88);
            if (!v33) {
              goto LABEL_98;
            }
            v34 = v33 - 1;
            *(void *)(v28 + 88) = v34;
            if (v34) {
              goto LABEL_98;
            }
            v35 = *(void (***)(void))(v28 + 64);
            if (v35)
            {
              *(void *)(v28 + 64) = 0LL;
              v35[2](v35);
              _Block_release(v35);
            }

            if ((*(_BYTE *)(v28 + 72) & 1) != 0)
            {
              os_log_type_t v36 = *(const void **)(v28 + 64);
              if (v36) {
                _Block_release(v36);
              }
            }

            goto LABEL_106;
          }
        }

        __nwlog_obj();
        v37 = *(const char **)(v28 + 16);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
        if (!v37) {
          v37 = "invalid";
        }
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2048;
        v65 = (void *)v28;
        v38 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v56) = 0;
        if (__nwlog_fault(v38, type, &v56))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v39 = (os_log_s *)__nwlog_obj();
            os_log_type_t v40 = type[0];
            if (!os_log_type_enabled(v39, type[0])) {
              goto LABEL_143;
            }
            BOOL v41 = *(const char **)(v28 + 16);
            if (!v41) {
              BOOL v41 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v41;
            *(_WORD *)&buf[22] = 2048;
            v65 = (void *)v28;
            v42 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
            goto LABEL_142;
          }

          if (!(_BYTE)v56)
          {
            v39 = (os_log_s *)__nwlog_obj();
            os_log_type_t v40 = type[0];
            if (!os_log_type_enabled(v39, type[0])) {
              goto LABEL_143;
            }
            os_log_type_t v52 = *(const char **)(v28 + 16);
            if (!v52) {
              os_log_type_t v52 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v52;
            *(_WORD *)&buf[22] = 2048;
            v65 = (void *)v28;
            v42 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
            goto LABEL_142;
          }

          v47 = (char *)__nw_create_backtrace_string();
          v39 = (os_log_s *)__nwlog_obj();
          os_log_type_t v40 = type[0];
          v48 = os_log_type_enabled(v39, type[0]);
          if (v47)
          {
            if (v48)
            {
              v49 = *(const char **)(v28 + 16);
              if (!v49) {
                v49 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v49;
              *(_WORD *)&buf[22] = 2048;
              v65 = (void *)v28;
              LOWORD(v66) = 2082;
              *(void *)((char *)&v66 + 2) = v47;
              _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v47);
            goto LABEL_143;
          }

          if (v48)
          {
            os_log_type_t v53 = *(const char **)(v28 + 16);
            if (!v53) {
              os_log_type_t v53 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v53;
            *(_WORD *)&buf[22] = 2048;
            v65 = (void *)v28;
            v42 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_142:
            _os_log_impl(&dword_181A5C000, v39, v40, v42, buf, 0x20u);
          }
        }

    _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
    goto LABEL_89;
  }

  handle = a1->handle;
  if (handle)
  {
    if (a2)
    {
      if (gLogDatapath)
      {
        int v28 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          identifier = a1->identifier;
          if (!identifier) {
            identifier = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugins_handle_disconnected";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = identifier;
          *(_WORD *)&buf[22] = 2048;
          v46 = a1;
          _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
        }
      }

      v5 = handle[11];
      if (v5 && (*(_BYTE *)(v5 + 212) & 0x20) != 0) {
        goto LABEL_22;
      }
      char v6 = handle[9];
      if (v6)
      {
        int v7 = *(_BYTE *)(v6 + 142);
        if ((v7 & 2) == 0)
        {
          if (nw_protocol_plugin_metadata_handle_eof(handle[9], a1))
          {
            v5 = handle[11];
            goto LABEL_11;
          }

          int v7 = *(_BYTE *)(v6 + 142);
        }

        v10 = 0;
        *(_BYTE *)(v6 + 142) = v7 | 8;
        goto LABEL_23;
      }

    free(v30);
    *(void *)(v12 + 136) = 0LL;
    goto LABEL_89;
  }

  __break(1u);
  return result;
}

    goto LABEL_89;
  }

  if (!v10)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_framer_deliver_input";
    v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v23 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null message", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (!v47)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl( &dword_181A5C000,  v20,  v43,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v34 = type;
    v35 = os_log_type_enabled(v20, type);
    if (!v33)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v34, "%{public}s called with null message, no backtrace", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v50 = "nw_framer_deliver_input";
      v51 = 2082;
      os_log_type_t v52 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v34,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_57;
  }

  __int16 v12 = v10;
  v13 = v12[1];

  is_framer = nw_protocol_definition_is_framer(v13);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_framer_deliver_input";
    v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message)",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    if (!v47)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl( &dword_181A5C000,  v20,  v44,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v36 = type;
    v37 = os_log_type_enabled(v20, type);
    if (!v33)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl( &dword_181A5C000,  v20,  v36,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), no backtrace",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      v50 = "nw_framer_deliver_input";
      v51 = 2082;
      os_log_type_t v52 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v36,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_57;
  }

  if (!input_buffer)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_framer_deliver_input";
    v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v27, "%{public}s called with null input_buffer", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (!v47)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v45 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl( &dword_181A5C000,  v20,  v45,  "%{public}s called with null input_buffer, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v38 = type;
    v39 = os_log_type_enabled(v20, type);
    if (!v33)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v38, "%{public}s called with null input_buffer, no backtrace", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v50 = "nw_framer_deliver_input";
      v51 = 2082;
      os_log_type_t v52 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v38,  "%{public}s called with null input_buffer, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_57;
  }

  if (!input_length)
  {
    __nwlog_obj();
    int v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_framer_deliver_input";
    v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v29, "%{public}s called with null input_length", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (!v47)
    {
      __nwlog_obj();
      v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl( &dword_181A5C000,  v20,  v46,  "%{public}s called with null input_length, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v40 = type;
    BOOL v41 = os_log_type_enabled(v20, type);
    if (!v33)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_framer_deliver_input";
        _os_log_impl(&dword_181A5C000, v20, v40, "%{public}s called with null input_length, no backtrace", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      v50 = "nw_framer_deliver_input";
      v51 = 2082;
      os_log_type_t v52 = v33;
      _os_log_impl( &dword_181A5C000,  v20,  v40,  "%{public}s called with null input_length, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (v13[17])
    {
      if ((v3[346] & 0x20) != 0)
      {

        goto LABEL_135;
      }

      if (*((_BYTE *)v13 + 256))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v32 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_116;
        }
        logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 3));
        *(_DWORD *)buf = 136446722;
        v77 = "nw_resolver_start_delayed_reporting_timer";
        v78 = 2082;
        *(void *)v79 = v13 + 32;
        *(_WORD *)&v79[8] = 2082;
        *(void *)&v79[10] = logging_description;
        v34 = "%{public}s [C%{public}s] Delayed reporting timer already running for %{public}s";
        v35 = v32;
        os_log_type_t v36 = 32;
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
LABEL_116:

LABEL_135:
          v11 = 1;
          goto LABEL_49;
        }

        v47 = *((_DWORD *)v13 + 85);
        v48 = nw_endpoint_get_logging_description(*((void **)v3 + 3));
        *(_DWORD *)buf = 136446722;
        v77 = "nw_resolver_start_delayed_reporting_timer";
        v78 = 1024;
        *(_DWORD *)v79 = v47;
        *(_WORD *)&v79[4] = 2082;
        *(void *)&v79[6] = v48;
        v34 = "%{public}s [R%u] Delayed reporting timer already running for %{public}s";
        v35 = v32;
        os_log_type_t v36 = 28;
      }

      _os_log_impl(&dword_181A5C000, v35, OS_LOG_TYPE_DEBUG, v34, buf, v36);
      goto LABEL_116;
    }

    if ((v3[346] & 0x20) != 0)
    {
LABEL_133:
      v56 = (void *)v13[4];
      v74[0] = MEMORY[0x1895F87A8];
      v74[1] = 3221225472LL;
      v74[2] = ___ZL41nw_resolver_start_delayed_reporting_timerP22NWConcrete_nw_resolverbbb_block_invoke;
      v74[3] = &unk_189BC93A0;
      uint64_t v57 = v13;
      v75 = v57;
      source = nw_queue_context_create_source(v56, 2, 3, 0, v74, 0LL);
      v13[17] = source;
      if (source)
      {
        v59 = dispatch_time(0x8000000000000000LL, 1000000 * v15);
        nw_queue_set_timer_values(source, v59, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        nw_queue_activate_source(v13[17], v60);

        goto LABEL_135;
      }

      __nwlog_obj();
      char v61 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v77 = "nw_resolver_start_delayed_reporting_timer";
      os_log_type_t v62 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v64 = type;
        if (os_log_type_enabled(v63, type))
        {
          *(_DWORD *)buf = 136446210;
          v77 = "nw_resolver_start_delayed_reporting_timer";
          _os_log_impl(&dword_181A5C000, v63, v64, "%{public}s nw_queue_context_create_source failed", buf, 0xCu);
        }
      }

      else if (v72)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v66 = type;
        v67 = os_log_type_enabled(v63, type);
        if (backtrace_string)
        {
          if (v67)
          {
            *(_DWORD *)buf = 136446466;
            v77 = "nw_resolver_start_delayed_reporting_timer";
            v78 = 2082;
            *(void *)v79 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v63,  v66,  "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_152;
        }

        if (v67)
        {
          *(_DWORD *)buf = 136446210;
          v77 = "nw_resolver_start_delayed_reporting_timer";
          _os_log_impl( &dword_181A5C000,  v63,  v66,  "%{public}s nw_queue_context_create_source failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v68 = type;
        if (os_log_type_enabled(v63, type))
        {
          *(_DWORD *)buf = 136446210;
          v77 = "nw_resolver_start_delayed_reporting_timer";
          _os_log_impl( &dword_181A5C000,  v63,  v68,  "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }

LABEL_152:
      if (v62) {
        free(v62);
      }

      goto LABEL_155;
    }

    if (*((_BYTE *)v13 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v37 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_132;
      }
      v38 = nw_endpoint_get_logging_description(*((void **)v3 + 3));
      *(_DWORD *)buf = 136448258;
      v77 = "nw_resolver_start_delayed_reporting_timer";
      v39 = " SVCB";
      v78 = 2082;
      os_log_type_t v40 = "";
      *(void *)v79 = v13 + 32;
      if ((v5 & 0x80) != 0) {
        BOOL v41 = "";
      }
      else {
        BOOL v41 = " SVCB";
      }
      *(_WORD *)&v79[8] = 2082;
      v42 = " IPv6";
      if ((v5 & 0x80) == 0) {
        v39 = "";
      }
      if ((v5 & 0x20A) != 0) {
        os_log_type_t v43 = "";
      }
      else {
        os_log_type_t v43 = " IPv6";
      }
      if ((v5 & 0x20A) == 0) {
        v42 = "";
      }
      if ((v5 & 0x105) != 0) {
        os_log_type_t v40 = " IPv4";
      }
      *(void *)&v79[10] = v40;
      *(_WORD *)&v79[18] = 2082;
      *(void *)&v79[20] = v42;
      *(_WORD *)&v79[28] = 2082;
      *(void *)&v79[30] = v39;
      *(_WORD *)&v79[38] = 2048;
      *(void *)&v79[40] = v15;
      *(_WORD *)&v79[48] = 2082;
      *(void *)&v79[50] = v43;
      *(_WORD *)&v79[58] = 2082;
      *(void *)&v79[60] = v41;
      *(_WORD *)&v79[68] = 2082;
      *(void *)&v79[70] = v38;
      BOOL v44 = "%{public}s [C%{public}s] Received%{public}s%{public}s%{public}s result, delaying reporting: waiting %llums o"
            "n%{public}s%{public}s for %{public}s";
      v45 = v37;
      v46 = 92;
    }

    else
    {
      __nwlog_obj();
      v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
LABEL_132:

        goto LABEL_133;
      }

      v49 = *((_DWORD *)v13 + 85);
      v50 = nw_endpoint_get_logging_description(*((void **)v3 + 3));
      v51 = " SVCB";
      *(_DWORD *)buf = 136448258;
      v77 = "nw_resolver_start_delayed_reporting_timer";
      os_log_type_t v52 = "";
      v78 = 1024;
      *(_DWORD *)v79 = v49;
      if ((v5 & 0x80) != 0) {
        os_log_type_t v53 = "";
      }
      else {
        os_log_type_t v53 = " SVCB";
      }
      *(_WORD *)&v79[4] = 2082;
      uint64_t v54 = " IPv6";
      if ((v5 & 0x80) == 0) {
        v51 = "";
      }
      if ((v5 & 0x20A) != 0) {
        v55 = "";
      }
      else {
        v55 = " IPv6";
      }
      if ((v5 & 0x20A) == 0) {
        uint64_t v54 = "";
      }
      if ((v5 & 0x105) != 0) {
        os_log_type_t v52 = " IPv4";
      }
      *(void *)&v79[6] = v52;
      *(_WORD *)&v79[14] = 2082;
      *(void *)&v79[16] = v54;
      *(_WORD *)&v79[24] = 2082;
      *(void *)&v79[26] = v51;
      *(_WORD *)&v79[34] = 2048;
      *(void *)&v79[36] = v15;
      *(_WORD *)&v79[44] = 2082;
      *(void *)&v79[46] = v55;
      *(_WORD *)&v79[54] = 2082;
      *(void *)&v79[56] = v53;
      *(_WORD *)&v79[64] = 2082;
      *(void *)&v79[66] = v50;
      BOOL v44 = "%{public}s [R%u] Received%{public}s%{public}s%{public}s result, delaying reporting: waiting %llums on%{publi"
            "c}s%{public}s for %{public}s";
      v45 = v37;
      v46 = 88;
    }

    _os_log_impl(&dword_181A5C000, v45, OS_LOG_TYPE_DEBUG, v44, buf, v46);
    goto LABEL_132;
  }

        goto LABEL_89;
      }

      if (!v59)
      {
        __nwlog_obj();
        BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v41 = v60;
        if (os_log_type_enabled(v27, v60))
        {
          v42 = (const char *)*((void *)v7 + 2);
          if (!v42) {
            v42 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v42;
          *(_WORD *)&buf[22] = 2048;
          v66 = v7;
          _os_log_impl( &dword_181A5C000,  v27,  v41,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded",  buf,  0x20u);
        }

        goto LABEL_88;
      }

      os_log_type_t v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v58 = v60;
      v37 = os_log_type_enabled(v27, v60);
      if (!v36)
      {
        if (v37)
        {
          os_log_type_t v43 = (const char *)*((void *)v7 + 2);
          if (!v43) {
            os_log_type_t v43 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v43;
          *(_WORD *)&buf[22] = 2048;
          v66 = v7;
          _os_log_impl( &dword_181A5C000,  v27,  v58,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace",  buf,  0x20u);
        }

        goto LABEL_88;
      }

      if (v37)
      {
        v38 = (const char *)*((void *)v7 + 2);
        if (!v38) {
          v38 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v38;
        *(_WORD *)&buf[22] = 2048;
        v66 = v7;
        *(_WORD *)v67 = 2082;
        *(void *)&v67[2] = v36;
        _os_log_impl( &dword_181A5C000,  v27,  v58,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v36);
    }

        free(v41);
        goto LABEL_126;
      }

      goto LABEL_126;
    }

    __nwlog_obj();
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v73 = "__nw_protocol_get_message_properties";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v68) = 0;
    if (__nwlog_fault(v23, type, &v68))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v40 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v73 = "__nw_protocol_get_message_properties";
          _os_log_impl(&dword_181A5C000, v24, v40, "%{public}s called with null protocol", buf, 0xCu);
        }

    goto LABEL_89;
  }

  if (!v8)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_data_finalizer";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_data_finalizer";
        _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null frame", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (!v43)
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v41 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_data_finalizer";
        _os_log_impl( &dword_181A5C000,  v24,  v41,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v34 = type;
    v35 = os_log_type_enabled(v24, type);
    if (!v33)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_data_finalizer";
        _os_log_impl(&dword_181A5C000, v24, v34, "%{public}s called with null frame, no backtrace", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_data_finalizer";
      v47 = 2082;
      v48 = v33;
      _os_log_impl( &dword_181A5C000,  v24,  v34,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_65;
  }

  if (!a4)
  {
    __nwlog_obj();
    int v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_data_finalizer";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_data_finalizer";
        _os_log_impl(&dword_181A5C000, v24, v29, "%{public}s called with null existing_master_array", buf, 0xCu);
      }

      goto LABEL_88;
    }

    if (!v43)
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v42 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_data_finalizer";
        _os_log_impl( &dword_181A5C000,  v24,  v42,  "%{public}s called with null existing_master_array, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v36 = type;
    v37 = os_log_type_enabled(v24, type);
    if (!v33)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_data_finalizer";
        _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s called with null existing_master_array, no backtrace",  buf,  0xCu);
      }

      goto LABEL_88;
    }

    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_data_finalizer";
      v47 = 2082;
      v48 = v33;
      _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s called with null existing_master_array, dumping backtrace:%{public}s",  buf,  0x16u);
    }
    }

    v101 = 0LL;
    uint64_t v57 = 0LL;
    uint64_t v58 = 0;
  }

      free(backtrace_string);
      if (!v29) {
        goto LABEL_8;
      }
      goto LABEL_114;
    }
  }

  else
  {
    __nwlog_obj();
    int v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_parameters_create_quic";
    v29 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_parameters_create_quic";
        _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s called with null configure_quic", buf, 0xCu);
      }

      goto LABEL_112;
    }

    if (!v55)
    {
      __nwlog_obj();
      v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_parameters_create_quic";
        _os_log_impl( &dword_181A5C000,  v30,  v48,  "%{public}s called with null configure_quic, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_112;
    }

    os_log_type_t v36 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v37 = type;
    v38 = os_log_type_enabled(v30, type);
    if (!v36)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_parameters_create_quic";
        _os_log_impl(&dword_181A5C000, v30, v37, "%{public}s called with null configure_quic, no backtrace", buf, 0xCu);
      }

      goto LABEL_112;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_parameters_create_quic";
      v59 = 2082;
      v60 = v36;
      _os_log_impl( &dword_181A5C000,  v30,  v37,  "%{public}s called with null configure_quic, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v36);
  }

        free(v24);
        goto LABEL_89;
      }

      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl( &dword_181A5C000,  v25,  v33,  "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl( &dword_181A5C000,  v25,  v36,  "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded",  buf,  0xCu);
      }
    }

      free(v14);
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v45 = "nw_parameters_copy_application_service_identity_block_invoke";
    v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (__nwlog_fault(v21, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        uint64_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_parameters_copy_application_service_identity_block_invoke";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s SecGenerateSelfSignedCertificate failed", buf, 0xCu);
        }
      }

      else if (v41)
      {
        BOOL v27 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        int v28 = type;
        v29 = os_log_type_enabled(v22, type);
        if (v27)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v45 = "nw_parameters_copy_application_service_identity_block_invoke";
            v46 = 2082;
            v47 = (CFErrorRef)v27;
            _os_log_impl( &dword_181A5C000,  v22,  v28,  "%{public}s SecGenerateSelfSignedCertificate failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v27);
          if (!v21) {
            goto LABEL_53;
          }
          goto LABEL_73;
        }

        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_parameters_copy_application_service_identity_block_invoke";
          _os_log_impl( &dword_181A5C000,  v22,  v28,  "%{public}s SecGenerateSelfSignedCertificate failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        v37 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_parameters_copy_application_service_identity_block_invoke";
          _os_log_impl( &dword_181A5C000,  v22,  v37,  "%{public}s SecGenerateSelfSignedCertificate failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v21)
    {
LABEL_53:
      CFRelease(v2);
      return;
    }

      *((void *)handle + 24) = v37;
      v48 = (void *)nw_protocol_get_parameters((uint64_t)v38);
      if (nw_protocol_http_client_bottom_accept((uint64_t)handle, *((void **)handle + 15), v48)
        && (nw_http_client_bottom_add_to_messaging((uint64_t)handle, (uint64_t)v38) & 1) != 0)
      {
        if (v39 == 1) {
          nw_protocol_connect(v38[4], (uint64_t)v38);
        }
      }

      else
      {
        if ((handle[294] & 4) == 0)
        {
          v49 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446722;
            v77 = v34;
            v78 = 2082;
            v79 = handle + 208;
            v80 = 2080;
            v81 = " ";
            _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sMessaging cannot accept stream",  buf,  0x20u);
          }
        }

        v51 = (char *)*((void *)handle + 24);
        v50 = *((void *)handle + 25);
        if ((unint64_t)v51 >= v50)
        {
          os_log_type_t v53 = (char *)*((void *)handle + 23);
          uint64_t v54 = (v51 - v53) >> 4;
          v55 = v54 + 1;
          v56 = v50 - (void)v53;
          if (v56 >> 3 > v55) {
            v55 = v56 >> 3;
          }
          uint64_t v57 = (unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0LL;
          uint64_t v58 = 0xFFFFFFFFFFFFFFFLL;
          if (!v57) {
            uint64_t v58 = v55;
          }
          if (v58 >> 60) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          v59 = v34;
          v60 = 16 * v58;
          char v61 = (char *)operator new(16 * v58);
          os_log_type_t v62 = &v61[16 * v54];
          *(void *)os_log_type_t v62 = v38;
          *((_DWORD *)v62 + 2) = 2;
          if (v51 == v53)
          {
            char v64 = &v61[16 * v54];
          }

          else
          {
            v63 = &v61[16 * v54];
            do
            {
              char v64 = v63 - 16;
              *((_OWORD *)v63 - 1) = *((_OWORD *)v51 - 1);
              v51 -= 16;
              v63 -= 16;
            }

            while (v51 != v53);
          }

          os_log_type_t v52 = v62 + 16;
          *((void *)handle + 23) = v64;
          *((void *)handle + 24) = v62 + 16;
          *((void *)handle + 25) = &v61[v60];
          if (v53) {
            operator delete(v53);
          }
          v34 = v59;
        }

        else
        {
          *(void *)v51 = v38;
          *((_DWORD *)v51 + 2) = 2;
          os_log_type_t v52 = v51 + 16;
        }

        *((void *)handle + 24) = v52;
        nw_protocol_error(v38, (uint64_t)handle);
        nw_protocol_disconnected(v38, (uint64_t)handle);
      }
    }
  }

            goto LABEL_89;
          }

          minimize_logging = nw_endpoint_handler_get_minimize_logging(v10);
          logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
          if (minimize_logging)
          {
            if ((logging_disabled & 1) != 0) {
              goto LABEL_40;
            }
            v99 = v9;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v48 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
            {
              logc = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
              v100 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
              v101 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
              v102 = nw_endpoint_get_logging_description(v101);
              v103 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
              v104 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
              v105 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
              *(_DWORD *)bytes = 136447746;
              *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke_3";
              *(_WORD *)&bytes[12] = 2082;
              *(void *)&bytes[14] = logc;
              *(_WORD *)&bytes[22] = 2082;
              *(void *)&bytes[24] = v100;
              v133 = 2082;
              v134 = v102;
              v135 = 2082;
              v136 = v103;
              v137 = 2082;
              v138 = v104;
              v139 = 2114;
              v140 = v105;
              _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No URL, treating proxy as resolved",  bytes,  0x48u);

              v9 = v99;
            }
          }

          else
          {
            if ((logging_disabled & 1) != 0)
            {
LABEL_40:
              v56 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
              if (!v56)
              {
                uint64_t v57 = nw_array_copy(*(void *)(*(void *)(a1 + 40) + 56LL));
                uint64_t v58 = *(void *)(*(void *)(a1 + 48) + 8LL);
                v59 = *(void **)(v58 + 40);
                *(void *)(v58 + 40) = v57;

                v56 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
              }

              nw_array_remove_object(v56, (uint64_t)v4);
              v25 = 0LL;
              *(_BYTE *)(*(void *)(a1 + 40) + 96LL) |= 0x80u;
              goto LABEL_69;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v48 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
            {
              v49 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
              v50 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
              v51 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
              loga = v9;
              os_log_type_t v52 = nw_endpoint_get_logging_description(v51);
              os_log_type_t v53 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
              uint64_t v54 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
              v55 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
              *(_DWORD *)bytes = 136447746;
              *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
              *(_WORD *)&bytes[12] = 2082;
              *(void *)&bytes[14] = v49;
              *(_WORD *)&bytes[22] = 2082;
              *(void *)&bytes[24] = v50;
              v133 = 2082;
              v134 = v52;
              v135 = 2082;
              v136 = v53;
              v137 = 2082;
              v138 = v54;
              v139 = 2114;
              v140 = v55;
              _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No URL, treating proxy as resolved",  bytes,  0x48u);

              v9 = loga;
            }
          }

          goto LABEL_40;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v26 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)bytes = 136446466;
          *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
          *(_WORD *)&bytes[12] = 2112;
          *(void *)&bytes[14] = v8;
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s nw_endpoint_copy_cfurl(%@) failed",  bytes,  0x16u);
        }

  [MEMORY[0x189607968] numberWithUnsignedInt:self->_trafficClass];
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  [v4 setObject:v59 forKey:@"trafficClass"];

  has = (__int16)self->_has;
  if ((has & 2) == 0)
  {
LABEL_15:
    if ((has & 0x10) == 0) {
      goto LABEL_16;
    }
    goto LABEL_93;
  }

      free(v67);
    }
  }

    if (v30) {
      free(v30);
    }
    int v16 = 0LL;
    goto LABEL_11;
  }

  iterate_block[0] = MEMORY[0x1895F87A8];
  iterate_block[1] = 3221225472LL;
  iterate_block[2] = __nw_proxy_config_copy_parameters_to_proxy_block_invoke;
  iterate_block[3] = &unk_189BBD118;
  v51 = v2;
  v9 = v5;
  os_log_type_t v52 = v9;
  v10 = v6;
  os_log_type_t v53 = v10;
  nw_protocol_stack_iterate_application_protocols(v8, iterate_block);
  v11 = v8;
  __int16 v12 = (void *)*((void *)v11 + 3);
  v13 = v12;

  if (v13)
  {
    uint64_t v14 = (id *)v10;
    BOOL v15 = v13;
    objc_storeStrong(v14 + 3, v12);
  }

  int v16 = v9;

LABEL_11:
LABEL_12:

LABEL_13:
LABEL_63:

  return v16;
}

    if (!v21) {
      goto LABEL_31;
    }
    v19 = (char *)v21;
    goto LABEL_30;
  }

  int v7 = *(void *)(a1 + 40);
  if (!v7)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_necp_append_tlv";
    v21 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (__nwlog_fault(v21, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null beyond", buf, 0xCu);
        }

    if (!v21) {
      goto LABEL_31;
    }
    v19 = (char *)v21;
    goto LABEL_30;
  }

  int v7 = *(void *)(a1 + 40);
  if (!v7)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_necp_append_tlv";
    v21 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (__nwlog_fault(v21, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null beyond", buf, 0xCu);
        }

    goto LABEL_19;
  }

    goto LABEL_19;
  }

    goto LABEL_19;
  }

  uint64_t v58 = *(unsigned int *)(v9 + 336) + 1LL;
  v59 = v58 << 31 >> 31;
  *(_DWORD *)(v9 + 336) = v58;
  if (v59 == v58 && (v59 & 0x8000000000000000LL) == 0) {
    goto LABEL_107;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v60 = *(unsigned int *)(v9 + 336);
  *(_DWORD *)buf = 136446978;
  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = "http1->connections_count";
  *(_WORD *)&buf[22] = 2048;
  v268 = 1LL;
  v269 = 2048;
  *(void *)v270 = v60;
  char v61 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(aBlock[0]) = 0;
  if (__nwlog_fault(v61, type, aBlock))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v62 = (os_log_s *)gLogObj;
      v63 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        char v64 = *(unsigned int *)(v9 + 336);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "http1->connections_count";
        *(_WORD *)&buf[22] = 2048;
        v268 = 1LL;
        v269 = 2048;
        *(void *)v270 = v64;
        v65 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_103:
        _os_log_impl(&dword_181A5C000, v62, v63, v65, buf, 0x2Au);
      }
    }

    else if (LOBYTE(aBlock[0]))
    {
      v66 = (char *)__nw_create_backtrace_string();
      os_log_type_t v62 = (os_log_s *)__nwlog_obj();
      v63 = type[0];
      v67 = os_log_type_enabled(v62, type[0]);
      if (v66)
      {
        if (v67)
        {
          v68 = *(unsigned int *)(v9 + 336);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->connections_count";
          *(_WORD *)&buf[22] = 2048;
          v268 = 1LL;
          v269 = 2048;
          *(void *)v270 = v68;
          *(_WORD *)&v270[8] = 2082;
          v271 = v66;
          _os_log_impl( &dword_181A5C000,  v62,  v63,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
        }

        free(v66);
        goto LABEL_104;
      }

      if (v67)
      {
        v70 = *(unsigned int *)(v9 + 336);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "http1->connections_count";
        *(_WORD *)&buf[22] = 2048;
        v268 = 1LL;
        v269 = 2048;
        *(void *)v270 = v70;
        v65 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_103;
      }
    }

    else
    {
      os_log_type_t v62 = (os_log_s *)__nwlog_obj();
      v63 = type[0];
      if (os_log_type_enabled(v62, type[0]))
      {
        uint64_t v69 = *(unsigned int *)(v9 + 336);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "http1->connections_count";
        *(_WORD *)&buf[22] = 2048;
        v268 = 1LL;
        v269 = 2048;
        *(void *)v270 = v69;
        v65 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_103;
      }
    }
  }

      free(backtrace_string);
      goto LABEL_98;
    }

    v38 = (os_log_s *)__nwlog_obj();
    v39 = type[0];
    if (!os_log_type_enabled(v38, type[0])) {
      goto LABEL_98;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v40 = "%{public}s called with null protocol";
LABEL_97:
    _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, 0xCu);
LABEL_98:
    if (v37) {
      free(v37);
    }
    return 0LL;
  }

  id v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    v37 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v77[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v38 = (os_log_s *)__nwlog_obj();
      v39 = type[0];
      if (!os_log_type_enabled(v38, type[0])) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      os_log_type_t v40 = "%{public}s called with null http_retry";
      goto LABEL_97;
    }

    if (!v77[0])
    {
      v38 = (os_log_s *)__nwlog_obj();
      v39 = type[0];
      if (!os_log_type_enabled(v38, type[0])) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      os_log_type_t v40 = "%{public}s called with null http_retry, backtrace limit exceeded";
      goto LABEL_97;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = (os_log_s *)__nwlog_obj();
    v39 = type[0];
    BOOL v44 = os_log_type_enabled(v38, type[0]);
    if (backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "operator()";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        os_log_type_t v43 = "%{public}s called with null http_retry, dumping backtrace:%{public}s";
        goto LABEL_87;
      }

      goto LABEL_88;
    }

    if (!v44) {
      goto LABEL_98;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    os_log_type_t v40 = "%{public}s called with null http_retry, no backtrace";
    goto LABEL_97;
  }

  if ((*(_BYTE *)(v3 + 676) & 8) == 0)
  {
    if ((*(_BYTE *)(v3 + 676) & 5) == 0 && *(_DWORD *)(v3 + 672))
    {
      result = *(void *)(v3 + 576);
      if (!result) {
        return result;
      }
      v5 = *(void *)(v3 + 592);
      result = (uint64_t)nw_http_metadata_copy_request((void *)result);
      if (v5 || !result)
      {
        if (!result) {
          return result;
        }
      }

      else
      {
        char v6 = (id)result;
        has_method = _nw_http_request_has_method((uint64_t)v6);

        if ((has_method & 1) != 0
          || (char v8 = v6, v9 = _nw_http_request_has_method((uint64_t)v8), v8, v9))
        {
          if ((*(_BYTE *)(v3 + 198) & 1) == 0)
          {
            if (gLogDatapath)
            {
              v21 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_http_retry_can_retry";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v3 + 114;
                *(_WORD *)&buf[22] = 2080;
                v83 = (uint64_t)" ";
                uint64_t v22 = "%{public}s %{public}s%sidempotent request has not received any response, able to retry";
                goto LABEL_106;
              }
            }
          }

        free(v49);
        goto LABEL_55;
      }

      if (!(_BYTE)v79)
      {
        __nwlog_obj();
        v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v67 = type[0];
        if (os_log_type_enabled(v50, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "nw_remote_director_write_one";
          os_log_type_t v52 = v50;
          os_log_type_t v53 = v67;
          uint64_t v54 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_85;
        }

        goto LABEL_86;
      }

      uint64_t v57 = v11;
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v60 = type[0];
      char v61 = os_log_type_enabled(v59, type[0]);
      if (backtrace_string)
      {
        if (!v61) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446466;
        v84 = "nw_remote_director_write_one";
        v85 = 2082;
        v86[0] = backtrace_string;
        os_log_type_t v62 = v59;
        v63 = v60;
        char v64 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_78;
      }

      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        v84 = "nw_remote_director_write_one";
        uint64_t v69 = v59;
        v70 = v60;
        v71 = "%{public}s called with null protocol, no backtrace";
LABEL_93:
        _os_log_impl(&dword_181A5C000, v69, v70, v71, buf, 0xCu);
      }

    if (v15) {
      free(v15);
    }
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v27 = "nw_utf8_validator_parse";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v15, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v27 = "nw_utf8_validator_parse";
          v18 = "%{public}s called with null buffer";
          goto LABEL_86;
        }

        goto LABEL_87;
      }

      if (!v24)
      {
        __nwlog_obj();
        int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v27 = "nw_utf8_validator_parse";
          v18 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_86;
        }

        goto LABEL_87;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v17 = type;
      uint64_t v23 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v27 = "nw_utf8_validator_parse";
          v18 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_86;
        }

        goto LABEL_87;
      }

      if (!v23) {
        goto LABEL_77;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v27 = "nw_utf8_validator_parse";
      int v28 = 2082;
      v29 = backtrace_string;
      uint64_t v22 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_76:
      _os_log_impl(&dword_181A5C000, v16, v17, v22, buf, 0x16u);
LABEL_77:

      free(backtrace_string);
      goto LABEL_88;
    }

    goto LABEL_88;
  }

  os_log_type_t v4 = *a1;
  if ((v4 & 0x80000000) == 0 && a3)
  {
    v5 = 0LL;
    while (!(_BYTE)v4)
    {
      v9 = *(char *)(a2 + v5);
      if ((v9 & 0x80000000) == 0)
      {
        LOBYTE(v4) = 0;
        goto LABEL_48;
      }

      a1[1] = v9;
      v10 = *(_BYTE *)(a2 + v5);
      if ((v10 + 62) > 0x1Du)
      {
        if ((v10 & 0xF0) == 0xE0)
        {
          LOBYTE(v4) = 2;
        }

        else
        {
          if ((v10 + 16) > 4u)
          {
LABEL_53:
            LOBYTE(v4) = -1;
            *a1 = -1;
LABEL_54:
            LODWORD(v12) = a4 ^ 1;
            else {
              __int16 v12 = 0LL;
            }
            if (a4) {
              goto LABEL_58;
            }
LABEL_52:
            a1[2] = 1;
            return v12;
          }

          LOBYTE(v4) = 3;
        }
      }

      else
      {
        LOBYTE(v4) = 1;
      }

    free(v42);
    goto LABEL_89;
  }

  v34 = (NWConcrete_nw_unique_connection *)nw_service_connector_copy_active_connection_with_endpoint_and_service( v9,  v10,  a3);
  v31 = v34;
  if (v34)
  {
    connection = v34->connection;
    if (!connection) {
      goto LABEL_50;
    }
    os_log_type_t v36 = connection;
    *(void *)os_log_type_t type = 0LL;
    v56 = (uint64_t)type;
    uint64_t v57 = 0x2020000000LL;
    LOBYTE(v58) = 0;
    v37 = v36 + 34;
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
    char v64 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BC9210;
    *(void *)&v65[8] = type;
    v38 = v36;
    *(void *)v65 = v38;
    os_unfair_lock_lock(v37);
    __nw_connection_is_cancelled_or_failed_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v37);
    LODWORD(v37) = *(unsigned __int8 *)(v56 + 24);

    _Block_object_dispose(type, 8);
    if ((_DWORD)v37)
    {
      nw_service_connector_remove_active_connection(v9, v31);
    }

    else
    {
LABEL_50:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        os_log_type_t v40 = (uint64_t (*)(uint64_t, uint64_t))v31->connection;
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v9;
        *(_WORD *)&buf[22] = 2114;
        char v64 = v40;
        _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ did not remove connection %{public}@ as it is active",  buf,  0x20u);
      }
    }
  }

  if (v50)
  {
LABEL_89:
    if (v10 != v50)
    {
      v65 = v10;
      do
      {
        v67 = *--v65;
        v66 = v67;
        if (v67) {
          os_release(v66);
        }
        *(v10 - 1) = 0LL;
        v10 = v65;
      }

      while (v65 != v50);
      v10 = v79;
    }

    operator delete(v10);
  }

  if (v8)
  {
    if (v9 != v8)
    {
      v68 = v9;
      do
      {
        v70 = (void *)*((void *)v68 - 1);
        v68 -= 8;
        uint64_t v69 = v70;
        if (v70) {
          os_release(v69);
        }
        *((void *)v9 - 1) = 0LL;
        v9 = v68;
      }

      while (v68 != v8);
    }

    operator delete(v8);
  }

      v21 = 0LL;
      goto LABEL_89;
    }

    BOOL v15 = nw_browse_result_create(v10);
    nw_browse_result_set_discovered_from_path(v15, a5);
    if (!v11 || nw_browse_result_insert_interface(v15, v11))
    {
      nw_array_append(*((void *)v9 + 18), v15);
      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        v17 = (os_log_s *)(id)gbrowserLogObj;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          v18 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446722;
          char v64 = "nw_browser_add_result_locked";
          v65 = 1024;
          *(_DWORD *)v66 = v18;
          *(_WORD *)&v66[4] = 2112;
          *(void *)&v66[6] = v15;
          _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] new: added %@ to new_results",  buf,  0x1Cu);
        }
      }

      xpc_dictionary_set_uint64(*((xpc_object_t *)v9 + 20), a2, 2uLL);
      if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        v19 = (os_log_s *)(id)gbrowserLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          v20 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446978;
          char v64 = "nw_browser_add_result_locked";
          v65 = 1024;
          *(_DWORD *)v66 = v20;
          *(_WORD *)&v66[4] = 2080;
          *(void *)&v66[6] = a2;
          v67 = 1024;
          LODWORD(v68) = 2;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s [B%u] changes_map: %s = result_added(%d)",  buf,  0x22u);
        }
      }

      goto LABEL_25;
    }

    if (!nw_parameters_get_logging_disabled(*((void *)v9 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
      }
      int v28 = (id)gbrowserLogObj;
      v29 = *((_DWORD *)v9 + 48);
      *(_DWORD *)buf = 136446978;
      char v64 = "nw_browser_add_result_locked";
      v65 = 1024;
      *(_DWORD *)v66 = v29;
      *(_WORD *)&v66[4] = 2112;
      *(void *)&v66[6] = v11;
      v67 = 2080;
      v68 = a2;
      v30 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v61 = 0;
      if (__nwlog_fault(v30, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          v31 = (os_log_s *)(id)gbrowserLogObj;
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            v33 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            char v64 = "nw_browser_add_result_locked";
            v65 = 1024;
            *(_DWORD *)v66 = v33;
            *(_WORD *)&v66[4] = 2112;
            *(void *)&v66[6] = v11;
            v67 = 2080;
            v68 = a2;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s",  buf,  0x26u);
          }
        }

        else if (v61)
        {
          v39 = __nw_create_backtrace_string();
          if (v39)
          {
            os_log_type_t v40 = (char *)v39;
            if (__nwlog_browser_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
            }
            BOOL v41 = (os_log_s *)(id)gbrowserLogObj;
            v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              os_log_type_t v43 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136447234;
              char v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v43;
              *(_WORD *)&v66[4] = 2112;
              *(void *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              uint64_t v69 = 2082;
              v70 = v40;
              _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s",  buf,  0x30u);
            }

            free(v40);
            if (!v30) {
              goto LABEL_87;
            }
            goto LABEL_86;
          }

          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          v31 = (os_log_s *)(id)gbrowserLogObj;
          v50 = type;
          if (os_log_type_enabled(v31, type))
          {
            v51 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            char v64 = "nw_browser_add_result_locked";
            v65 = 1024;
            *(_DWORD *)v66 = v51;
            *(_WORD *)&v66[4] = 2112;
            *(void *)&v66[6] = v11;
            v67 = 2080;
            v68 = a2;
            _os_log_impl( &dword_181A5C000,  v31,  v50,  "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, no backtrace",  buf,  0x26u);
          }
        }

        else
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
          }
          v31 = (os_log_s *)(id)gbrowserLogObj;
          v48 = type;
          if (os_log_type_enabled(v31, type))
          {
            v49 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            char v64 = "nw_browser_add_result_locked";
            v65 = 1024;
            *(_DWORD *)v66 = v49;
            *(_WORD *)&v66[4] = 2112;
            *(void *)&v66[6] = v11;
            v67 = 2080;
            v68 = a2;
            _os_log_impl( &dword_181A5C000,  v31,  v48,  "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, backtrace limit exceeded",  buf,  0x26u);
          }
        }
      }

      if (v30) {
LABEL_86:
      }
        free(v30);
    }

  if (v42) {
    free(v42);
  }
}

  if (v29) {
    free(v29);
  }
LABEL_90:
  maximum_segment_size = nw_tcp_options_get_maximum_segment_size(a2);
  if (maximum_segment_size) {
    nw_socket_set_maximum_segment_size(a1, maximum_segment_size);
  }
  *(_DWORD *)os_log_type_t type = nw_tcp_options_get_retransmit_connection_drop_time(a2);
  if (*(_DWORD *)type && setsockopt(*(_DWORD *)(a1 + 172), 6, 128, type, 4u))
  {
    os_log_type_t v36 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v37 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 2080;
      *(void *)v109 = a1 + 308;
      *(_WORD *)&v109[8] = 1024;
      *(_DWORD *)&v109[10] = v36;
      _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d",  buf,  0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = (os_log_s *)gLogObj;
    if (v36 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_socket_set_bidirectional_tcp_sockopts";
        v108 = 1024;
        *(_DWORD *)v109 = 22;
        _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d",  buf,  0x12u);
      }

      goto LABEL_117;
    }

    *(_DWORD *)buf = 136446466;
    v107 = "nw_socket_set_bidirectional_tcp_sockopts";
    v108 = 1024;
    *(_DWORD *)v109 = v36;
    v39 = (char *)_os_log_send_and_compose_impl();
    v103[0] = OS_LOG_TYPE_ERROR;
    v102[0] = OS_LOG_TYPE_DEFAULT;
    if (v103[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v40 = (os_log_s *)gLogObj;
      BOOL v41 = v103[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v103[0])) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)v109 = v36;
      v42 = "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d";
    }

    else if (v102[0])
    {
      os_log_type_t v43 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v40 = (os_log_s *)gLogObj;
      BOOL v41 = v103[0];
      BOOL v44 = os_log_type_enabled((os_log_t)gLogObj, v103[0]);
      if (v43)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446722;
          v107 = "nw_socket_set_bidirectional_tcp_sockopts";
          v108 = 1024;
          *(_DWORD *)v109 = v36;
          *(_WORD *)&v109[4] = 2082;
          *(void *)&v109[6] = v43;
          _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v43);
        goto LABEL_115;
      }

      if (!v44)
      {
LABEL_115:
        if (v39) {
          free(v39);
        }
        goto LABEL_117;
      }

      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)v109 = v36;
      v42 = "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, no backtrace";
    }

    else
    {
      os_log_type_t v40 = (os_log_s *)__nwlog_obj();
      BOOL v41 = v103[0];
      if (!os_log_type_enabled(v40, v103[0])) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)v109 = v36;
      v42 = "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v40, v41, v42, buf, 0x12u);
    goto LABEL_115;
  }

  LOBYTE(v95) = *((_BYTE *)a3 + *v9) == 0;
  return v95;
}

        if (v55) {
          free(v55);
        }
        goto LABEL_75;
      }

      __nwlog_obj();
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
      v35 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v62 = 0;
      if ((__nwlog_fault(v35, &type, &v62) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v37 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            _os_log_impl(&dword_181A5C000, v36, v37, "%{public}s [super init] failed", buf, 0xCu);
          }
        }

        else if (v62)
        {
          v45 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v46 = type;
          v47 = os_log_type_enabled(v36, type);
          if (v45)
          {
            if (v47)
            {
              *(_DWORD *)buf = 136446466;
              v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
              v67 = 2082;
              v68 = v45;
              _os_log_impl( &dword_181A5C000,  v36,  v46,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v45);
            goto LABEL_63;
          }

          if (v47)
          {
            *(_DWORD *)buf = 136446210;
            v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            _os_log_impl(&dword_181A5C000, v36, v46, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v52 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            _os_log_impl( &dword_181A5C000,  v36,  v52,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    if (!v42) {
      return 4294966394LL;
    }
    os_log_type_t v40 = (char *)v42;
    goto LABEL_66;
  }

  *(void *)os_log_type_t v52 = 0LL;
  stream_from_id = nw_http2_get_stream_from_id(a4, a2, v52);
  if (stream_from_id)
  {
    int v7 = stream_from_id;
    if (*(void *)v52)
    {
      if (!*(void *)(*(void *)v52 + 24LL))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v9 = *(_DWORD *)(v7 + 176);
        char v8 = *(_DWORD *)(v7 + 180);
        *(_DWORD *)buf = 136447234;
        v55 = "on_stream_close_callback";
        v56 = 2082;
        uint64_t v57 = (char *)(v7 + 191);
        uint64_t v58 = 2080;
        v59 = " ";
        v60 = 1024;
        char v61 = v8;
        os_log_type_t v62 = 1024;
        *(_DWORD *)v63 = v9;
        v10 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v51 = 0;
        if (__nwlog_fault(v10, &type, &v51))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v11 = (os_log_s *)gconnectionLogObj;
            __int16 v12 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              uint64_t v14 = *(_DWORD *)(v7 + 176);
              v13 = *(_DWORD *)(v7 + 180);
              *(_DWORD *)buf = 136447234;
              v55 = "on_stream_close_callback";
              v56 = 2082;
              uint64_t v57 = (char *)(v7 + 191);
              uint64_t v58 = 2080;
              v59 = " ";
              v60 = 1024;
              char v61 = v13;
              os_log_type_t v62 = 1024;
              *(_DWORD *)v63 = v14;
              BOOL v15 = "%{public}s %{public}s%s<i%u:s%d> protocol has null callbacks";
LABEL_63:
              _os_log_impl(&dword_181A5C000, v11, v12, v15, buf, 0x2Cu);
            }
          }

          else if (v51)
          {
            v29 = (char *)__nw_create_backtrace_string();
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v11 = (os_log_s *)gconnectionLogObj;
            __int16 v12 = type;
            v30 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
            if (!v29)
            {
              if (!v30) {
                goto LABEL_64;
              }
              v39 = *(_DWORD *)(v7 + 176);
              v38 = *(_DWORD *)(v7 + 180);
              *(_DWORD *)buf = 136447234;
              v55 = "on_stream_close_callback";
              v56 = 2082;
              uint64_t v57 = (char *)(v7 + 191);
              uint64_t v58 = 2080;
              v59 = " ";
              v60 = 1024;
              char v61 = v38;
              os_log_type_t v62 = 1024;
              *(_DWORD *)v63 = v39;
              BOOL v15 = "%{public}s %{public}s%s<i%u:s%d> protocol has null callbacks, no backtrace";
              goto LABEL_63;
            }

            if (v30)
            {
              os_log_type_t v32 = *(_DWORD *)(v7 + 176);
              v31 = *(_DWORD *)(v7 + 180);
              *(_DWORD *)buf = 136447490;
              v55 = "on_stream_close_callback";
              v56 = 2082;
              uint64_t v57 = (char *)(v7 + 191);
              uint64_t v58 = 2080;
              v59 = " ";
              v60 = 1024;
              char v61 = v31;
              os_log_type_t v62 = 1024;
              *(_DWORD *)v63 = v32;
              *(_WORD *)&v63[4] = 2082;
              *(void *)&v63[6] = v29;
              _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %{public}s%s<i%u:s%d> protocol has null callbacks, dumping backtrace:%{public}s",  buf,  0x36u);
            }

            free(v29);
          }

          else
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v11 = (os_log_s *)gconnectionLogObj;
            __int16 v12 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              v37 = *(_DWORD *)(v7 + 176);
              os_log_type_t v36 = *(_DWORD *)(v7 + 180);
              *(_DWORD *)buf = 136447234;
              v55 = "on_stream_close_callback";
              v56 = 2082;
              uint64_t v57 = (char *)(v7 + 191);
              uint64_t v58 = 2080;
              v59 = " ";
              v60 = 1024;
              char v61 = v36;
              os_log_type_t v62 = 1024;
              *(_DWORD *)v63 = v37;
              BOOL v15 = "%{public}s %{public}s%s<i%u:s%d> protocol has null callbacks, backtrace limit exceeded";
              goto LABEL_63;
            }
          }
        }

    if (v16)
    {
      os_log_type_t v53 = (char *)v16;
LABEL_90:
      free(v53);
    }

    return 4294966775LL;
  }

  v21 = *a5;
  if (!*a5)
  {
    if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v39 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v40 = *(_DWORD *)(a6 + 368);
        buf = 136446978;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = a6 + 390;
        v234 = 2080;
        v235 = " ";
        v236 = 1024;
        v237 = v40;
        _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Received unexpected NULL frame from data source",  (uint8_t *)&buf,  0x26u);
        return 4294966394LL;
      }
    }

    return 4294966394LL;
  }

  uint64_t v22 = v21[13];
  if (v22) {
    v22 -= v21[14] + v21[15];
  }
  if (v22 != (_DWORD)a4 && (*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v120 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v121 = *(_DWORD *)(a6 + 368);
      v122 = v21[13];
      if (v122) {
        v122 -= v21[14] + v21[15];
      }
      buf = 136447746;
      v231 = "send_data_callback";
      v232 = 2082;
      v233 = a6 + 390;
      v234 = 2080;
      v235 = " ";
      v236 = 1024;
      v237 = v121;
      v238 = 2048;
      *(void *)v239 = v21;
      *(_WORD *)&v239[8] = 1024;
      v240 = v122;
      v241 = 1024;
      v242 = a4;
      _os_log_impl( &dword_181A5C000,  v120,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> source frame %p has length %u, asked to send %u",  (uint8_t *)&buf,  0x3Cu);
    }
  }

  v229[0] = 0LL;
  v229[1] = (uint64_t)v229;
  v228[0] = 0LL;
  v228[1] = v228;
  if (*(void *)(a6 + 240)) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = (*(_WORD *)(a6 + 388) & 0x100) == 0;
  }
  if (v23) {
    v24 = v228;
  }
  else {
    v24 = (void *)(a6 + 240);
  }
  v25 = *(void *)(a6 + 32);
  if (!v25
    || (uint64_t v26 = *(void *)(v25 + 24)) == 0
    || (BOOL v27 = *(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t *))(v26 + 88)) == 0LL)
  {
    if ((*(_WORD *)(a6 + 388) & 0x8000) != 0) {
      return 4294966394LL;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v103 = *(_DWORD *)(a6 + 368);
    buf = 136446978;
    v231 = "send_data_callback";
    v232 = 2082;
    v233 = a6 + 390;
    v234 = 2080;
    v235 = " ";
    v236 = 1024;
    v237 = v103;
    v104 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(v224) = 16;
    LOBYTE(v220) = 0;
    if (v224 == 17)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v105 = (os_log_s *)gconnectionLogObj;
      v106 = v224;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v224))
      {
        v107 = *(_DWORD *)(a6 + 368);
        buf = 136446978;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = a6 + 390;
        v234 = 2080;
        v235 = " ";
        v236 = 1024;
        v237 = v107;
        v108 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback";
LABEL_278:
        _os_log_impl(&dword_181A5C000, v105, v106, v108, (uint8_t *)&buf, 0x26u);
      }
    }

    else if ((_BYTE)v220)
    {
      v116 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v105 = (os_log_s *)gconnectionLogObj;
      v106 = v224;
      v117 = os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v224);
      if (!v116)
      {
        if (!v117) {
          goto LABEL_279;
        }
        v127 = *(_DWORD *)(a6 + 368);
        buf = 136446978;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = a6 + 390;
        v234 = 2080;
        v235 = " ";
        v236 = 1024;
        v237 = v127;
        v108 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, no backtrace";
        goto LABEL_278;
      }

      if (v117)
      {
        v118 = *(_DWORD *)(a6 + 368);
        buf = 136447234;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = a6 + 390;
        v234 = 2080;
        v235 = " ";
        v236 = 1024;
        v237 = v118;
        v238 = 2082;
        *(void *)v239 = v116;
        _os_log_impl( &dword_181A5C000,  v105,  v106,  "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x30u);
      }

      free(v116);
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v105 = (os_log_s *)gconnectionLogObj;
      v106 = v224;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v224))
      {
        v119 = *(_DWORD *)(a6 + 368);
        buf = 136446978;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = a6 + 390;
        v234 = 2080;
        v235 = " ";
        v236 = 1024;
        v237 = v119;
        v108 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, backtrace limit exceeded";
        goto LABEL_278;
      }
    }

    free(v26);
    goto LABEL_89;
  }

  __nwlog_obj();
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v54 = "nw_connection_create_interface_status_monitor";
  uint64_t v22 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (__nwlog_fault(v22, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_connection_create_interface_status_monitor";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v51)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      v37 = os_log_type_enabled(v23, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v54 = "nw_connection_create_interface_status_monitor";
          v55 = 2082;
          v56 = v35;
          _os_log_impl( &dword_181A5C000,  v23,  v36,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v35);
        goto LABEL_78;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_connection_create_interface_status_monitor";
        _os_log_impl(&dword_181A5C000, v23, v36, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_connection_create_interface_status_monitor";
        _os_log_impl( &dword_181A5C000,  v23,  v47,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_87:
              goto LABEL_88;
            }

            __nwlog_obj();
            v33 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)v63 = 136446210;
            *(void *)&v63[4] = "nw_endpoint_has_associations";
            v34 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v62 = OS_LOG_TYPE_ERROR;
            char v61 = 0;
            if (__nwlog_fault(v34, &v62, &v61))
            {
              if (v62 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v36 = v62;
                if (os_log_type_enabled(v35, v62))
                {
                  *(_DWORD *)v63 = 136446210;
                  *(void *)&v63[4] = "nw_endpoint_has_associations";
                  _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s called with null endpoint->context", v63, 0xCu);
                }
              }

              else if (v61)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v43 = v62;
                BOOL v44 = os_log_type_enabled(v35, v62);
                if (backtrace_string)
                {
                  if (v44)
                  {
                    *(_DWORD *)v63 = 136446466;
                    *(void *)&v63[4] = "nw_endpoint_has_associations";
                    *(_WORD *)&v63[12] = 2082;
                    *(void *)&v63[14] = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v35,  v43,  "%{public}s called with null endpoint->context, dumping backtrace:%{public}s",  v63,  0x16u);
                  }

                  free(backtrace_string);
                  goto LABEL_85;
                }

                if (v44)
                {
                  *(_DWORD *)v63 = 136446210;
                  *(void *)&v63[4] = "nw_endpoint_has_associations";
                  _os_log_impl( &dword_181A5C000,  v35,  v43,  "%{public}s called with null endpoint->context, no backtrace",  v63,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v53 = v62;
                if (os_log_type_enabled(v35, v62))
                {
                  *(_DWORD *)v63 = 136446210;
                  *(void *)&v63[4] = "nw_endpoint_has_associations";
                  _os_log_impl( &dword_181A5C000,  v35,  v53,  "%{public}s called with null endpoint->context, backtrace limit exceeded",  v63,  0xCu);
                }
              }
            }

        v83 = v73;
        v84 = (void *)[v83 copyEndpoint];
        nw_endpoint_copy_properties(v83, v84);

        v85 = a1[25];
        a1[25] = v84;

        goto LABEL_88;
      }
    }

    else
    {
      char v61 = (unsigned __int8 **)(v7 + 168);
      os_log_type_t v62 = (void ***)*((void *)v7 + 21);
      if (!v62)
      {
LABEL_85:
        v73 = (void *)*((void *)v7 + 25);
        if (!v73)
        {
          v86 = (void *)*((void *)v7 + 26);
          if (!v86) {
            goto LABEL_98;
          }
          if (!a4)
          {
LABEL_92:
            v87 = v86;
            v88 = (void *)[v87 copyEndpoint];
            nw_endpoint_copy_properties(v87, v88);

            v89 = a1[26];
            a1[26] = v88;
LABEL_97:

            goto LABEL_98;
          }

LABEL_88:
        char v6 = v229;
        goto LABEL_89;
      }

      if (*((void *)v229 + 6)) {
        goto LABEL_87;
      }
      if (v24 == 3)
      {
        v81 = nw_endpoint_handler_copy_context(v57);
        v232[0] = MEMORY[0x1895F87A8];
        v232[1] = 3221225472LL;
        v232[2] = ___ZL38nw_endpoint_transform_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke_102;
        v232[3] = &unk_189BC93A0;
        v233 = v57;
        nw_queue_context_async(v81, v232);

        BOOL v27 = v233;
        goto LABEL_86;
      }

      if (v24 != 2) {
        goto LABEL_87;
      }
      v59 = v57;
      v230 = v230;
      v60 = 100 * networkd_settings_get_int64_with_default((const char *)nw_setting_transform_rtt_delay_factor, 2LL);
      char v61 = nw_endpoint_handler_get_mode(v59);
      v228 = v59;
      if (v61 != 5)
      {
        v82 = v61;
        os_log_type_t v62 = __nwlog_obj();
        if (os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_DEFAULT))
        {
          if (v82 > 5) {
            v83 = "unknown-mode";
          }
          else {
            v83 = off_189BBBBC0[v82];
          }
          *(_DWORD *)buf = 136446722;
          v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
          v240 = 2082;
          id_str = (char *)v83;
          v242 = 2082;
          v243 = "transform";
          _os_log_impl( &dword_181A5C000,  (os_log_t)v62,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }

        goto LABEL_154;
      }

      os_log_type_t v62 = (uint64_t)nw_endpoint_handler_copy_transform(v59);
      v63 = *(unsigned int *)(v62 + 40);
      char v64 = v59;
      v65 = nw_endpoint_handler_get_mode(v64);
      if (v65 != 5)
      {
        v88 = v65;
        __nwlog_obj();
        v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          if (v88 > 5) {
            v90 = "unknown-mode";
          }
          else {
            v90 = off_189BBBBC0[v88];
          }
          *(_DWORD *)buf = 136446722;
          v239 = "nw_endpoint_transform_get_child_at_index";
          v240 = 2082;
          id_str = (char *)v90;
          v242 = 2082;
          v243 = "transform";
          _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }

LABEL_126:
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v64) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v69 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
          {
            v215 = nw_endpoint_handler_get_id_string(v64);
            v210 = nw_endpoint_handler_dry_run_string(v64);
            v223 = nw_endpoint_handler_copy_endpoint(v64);
            v101 = nw_endpoint_get_logging_description(v223);
            v102 = nw_endpoint_handler_state_string(v64);
            v103 = nw_endpoint_handler_mode_string(v64);
            v104 = nw_endpoint_handler_copy_current_path(v64);
            *(_DWORD *)buf = 136448002;
            v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
            v240 = 2082;
            id_str = (char *)v215;
            v242 = 2082;
            v243 = v210;
            v244 = 2082;
            v245 = v101;
            v246 = 2082;
            v247 = v102;
            v248 = 2082;
            v249 = v103;
            v250 = 2114;
            v251 = v104;
            v252 = 1024;
            LODWORD(v253) = v63;
            _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no child at index %u",  buf,  0x4Eu);
          }

          goto LABEL_153;
        }
            }
          }

          if (v62) {
            free(v62);
          }
          goto LABEL_48;
        }

        *((_BYTE *)v15 + 176) |= 4u;
        v37 = v36[2];
        if (v37 && !nw_path_parameters_get_logging_disabled(*(void *)(v37 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v38 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
          {
            v39 = *((_DWORD *)v15[7] + 112);
            os_log_type_t v40 = v15[12];
            *(_DWORD *)buf = 136446722;
            v123 = "nw_read_request_start_file_updates";
            v124 = 1024;
            *(_DWORD *)v125 = v39;
            *(_WORD *)&v125[4] = 2112;
            *(void *)&v125[6] = v40;
            _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Activating progress updates on read request on %@",  buf,  0x1Cu);
          }
        }

        BOOL v41 = (uint64_t)v15[13];
        if (v41)
        {
          nw_queue_cancel_source(v41, v34);
          v15[13] = 0LL;
        }

        objc_initWeak(&location, v35);
        v42 = (void *)*((void *)v15[7] + 3);
        *(void *)v119 = MEMORY[0x1895F87A8];
        *(void *)&v119[8] = 3221225472LL;
        *(void *)&v119[16] = ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke;
        v120 = &unk_189BC0AE8;
        objc_copyWeak(v121, &location);
        source = nw_queue_context_create_source(v42, 2, 3, 0, v119, 0LL);
        v15[13] = (id)source;
        if (source)
        {
          BOOL v44 = dispatch_time(0x8000000000000000LL, 1000000LL);
          v45 = 1000000LL * *((unsigned int *)v15 + 28);
          if (*(void *)source)
          {
            dispatch_source_set_timer(*(dispatch_source_t *)source, v44, v45, 0x3E8uLL);
          }

          else
          {
            *(void *)(source + 32) = v44;
            *(void *)(source + 40) = v45;
            if (*(_BYTE *)(source + 48) && *(_BYTE *)(source + 49)) {
              nw_queue_source_run_timer(source, v44);
            }
          }

          nw_queue_activate_source((uint64_t)v15[13], v44);
          goto LABEL_47;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v46 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v123 = "nw_read_request_start_file_updates";
        v47 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v105 = 0;
        if (__nwlog_fault((const char *)v47, &type, &v105))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = (os_log_s *)(id)gLogObj;
            v49 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              v123 = "nw_read_request_start_file_updates";
              _os_log_impl( &dword_181A5C000,  v48,  v49,  "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed",  buf,  0xCu);
            }

        goto LABEL_88;
      }

      if (!v70)
      {
        __nwlog_obj();
        v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = type[0];
        if (os_log_type_enabled(v33, (os_log_type_t)type[0]))
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v33,  v47,  "%{public}s netcore_stats_tcp_report_copy_description failed, backtrace limit exceeded",  (uint8_t *)&buf,  0xCu);
        }

        goto LABEL_87;
      }

      os_log_type_t v40 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v41 = type[0];
      v42 = os_log_type_enabled(v33, (os_log_type_t)type[0]);
      if (!v40)
      {
        if (v42)
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v33,  v41,  "%{public}s netcore_stats_tcp_report_copy_description failed, no backtrace",  (uint8_t *)&buf,  0xCu);
        }

        goto LABEL_87;
      }

      if (v42)
      {
        LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
        *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
        WORD2(buf.u.nw_connection_report.bytes_out) = 2082;
        *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = (unint64_t)v40;
        _os_log_impl( &dword_181A5C000,  v33,  v41,  "%{public}s netcore_stats_tcp_report_copy_description failed, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x16u);
      }

      free(v40);
    }

    if (v36) {
      free(v36);
    }
    goto LABEL_48;
  }

  os_unfair_lock_lock(v1 + 28);
  if (v2[29]._os_unfair_lock_opaque == 2)
  {
    id v3 = v2;
    os_unfair_lock_opaque = v2[29]._os_unfair_lock_opaque;

    if ((_DWORD)os_unfair_lock_opaque == 2)
    {
      v5 = nw_endpoint_handler_copy_flow(v3);
      os_unfair_lock_lock((os_unfair_lock_t)v5 + 220);
      if ((*((_BYTE *)v5 + 32) & 2) != 0 || (*((_BYTE *)v5 + 33) & 1) != 0)
      {
        int v16 = v3;
        v17 = v16[4];

        if (v17) {
          tls = nw_parameters_get_tls(v17);
        }
        else {
          tls = 0LL;
        }
      }

      else if (*((void *)v5 + 117))
      {
        tls = nw_endpoint_handler_stack_uses_tls();
      }

      else
      {
        tls = 0LL;
      }

      os_unfair_lock_unlock((os_unfair_lock_t)v5 + 220);

      goto LABEL_69;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (id)gLogObj;
    else {
      BOOL v15 = off_189BBBBC0[os_unfair_lock_opaque];
    }
    *(_DWORD *)buf = 136446722;
    v47 = "nw_endpoint_flow_stack_uses_tls";
    v48 = 2082;
    v49 = (os_unfair_lock_s *)v15;
    v50 = 2082;
    v51 = "flow";
    v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (__nwlog_fault(v18, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          else {
            v21 = off_189BBBBC0[os_unfair_lock_opaque];
          }
          *(_DWORD *)buf = 136446722;
          v47 = "nw_endpoint_flow_stack_uses_tls";
          v48 = 2082;
          v49 = (os_unfair_lock_s *)v21;
          v50 = 2082;
          v51 = "flow";
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v44)
      {
        uint64_t v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        uint64_t v23 = type;
        v24 = os_log_type_enabled(v19, type);
        if (v22)
        {
          if (v24)
          {
            else {
              v25 = off_189BBBBC0[os_unfair_lock_opaque];
            }
            *(_DWORD *)buf = 136446978;
            v47 = "nw_endpoint_flow_stack_uses_tls";
            v48 = 2082;
            v49 = (os_unfair_lock_s *)v25;
            v50 = 2082;
            v51 = "flow";
            os_log_type_t v52 = 2082;
            os_log_type_t v53 = v22;
            _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v22);
          if (!v18) {
            goto LABEL_68;
          }
          goto LABEL_67;
        }

        if (v24)
        {
          else {
            v33 = off_189BBBBC0[os_unfair_lock_opaque];
          }
          *(_DWORD *)buf = 136446722;
          v47 = "nw_endpoint_flow_stack_uses_tls";
          v48 = 2082;
          v49 = (os_unfair_lock_s *)v33;
          v50 = 2082;
          v51 = "flow";
          _os_log_impl( &dword_181A5C000,  v19,  v23,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (os_log_s *)(id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v19, type))
        {
          else {
            v30 = off_189BBBBC0[os_unfair_lock_opaque];
          }
          *(_DWORD *)buf = 136446722;
          v47 = "nw_endpoint_flow_stack_uses_tls";
          v48 = 2082;
          v49 = (os_unfair_lock_s *)v30;
          v50 = 2082;
          v51 = "flow";
          _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    if (!v18)
    {
LABEL_68:
      tls = 0LL;
LABEL_69:

      os_unfair_lock_unlock(v2 + 28);
      goto LABEL_70;
    }

    goto LABEL_88;
  }

  if ((v1[148] & 1) == 0) {
    goto LABEL_46;
  }
  id v3 = *((void *)v1 + 1);
  if (v3)
  {
    os_log_type_t v4 = nw_parameters_copy_context(*(void **)(v3 + 8));
    v5 = nw_path_shared_necp_fd(v4);

    if (v5 < 0 || uuid_is_null(v2 + 32)) {
      goto LABEL_6;
    }
    *((void *)v2 + 8) = 0LL;
    if (necp_client_action())
    {
      __int16 v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v48 = "nw_path_flow_registration_close";
      v49 = 1024;
      *(_DWORD *)v50 = v12;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v45 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v15 = (os_log_s *)(id)gLogObj;
        int v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_path_flow_registration_close";
          v49 = 1024;
          *(_DWORD *)v50 = v12;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s NECP_CLIENT_ACTION_REMOVE_FLOW error %{darwin.errno}d",  buf,  0x12u);
        }

            __break(1u);
LABEL_88:
            __break(1u);
            goto LABEL_89;
          }
        }

        if ((v19 & 0x2000000000000000LL) != 0)
        {
          uint64_t v69 = v20;
          v70 = v19 & 0xFFFFFFFFFFFFFFLL;
          v31 = *((_BYTE *)&v69 + v29);
          if (v27 == v25) {
            goto LABEL_30;
          }
          goto LABEL_25;
        }

        v30 = (v19 & 0xFFFFFFFFFFFFFFFLL) + 32;
        if ((v20 & 0x1000000000000000LL) == 0) {
          v30 = sub_18264F228();
        }
        v31 = *(_BYTE *)(v30 + v29);
        if (v27 != v25) {
          goto LABEL_25;
        }
LABEL_30:
        uint64_t v26 = sub_181C23710(v26, v20, v19);
        if ((v19 & 0x1000000000000000LL) != 0) {
          goto LABEL_26;
        }
LABEL_13:
        uint64_t v26 = (v26 & 0xFFFFFFFFFFFF0000LL) + 65540;
        if (v31 < 0) {
          goto LABEL_66;
        }
      }
    }

    v60 = v55;
    uint64_t v69 = v13;
    v70 = *((void *)&v13 + 1) & 0xFFFFFFFFFFFFFFLL;
    MEMORY[0x1895F8858](v17);
    v59 = &v55[-8];
    v55[-6] = sub_181C87638;
    v55[-5] = v32;
    v55[-4] = &v69;
    *(_OWORD *)&v55[-3] = v13;
    v55[-1] = &v71;
    if ((v19 & 0x2000000000000000LL) != 0) {
      v33 = HIBYTE(v19) & 0xF;
    }
    else {
      v33 = v20 & 0xFFFFFFFFFFFFLL;
    }
    if ((v19 & 0x1000000000000000LL) != 0) {
      v34 = (v20 >> 59) & 1;
    }
    else {
      v34 = 1LL;
    }
    uint64_t v58 = v34;
    v35 = 4LL << v34;
    os_log_type_t v36 = 15LL;
    do
    {
      while (1)
      {
        if (4 * v33 == v36 >> 14)
        {
LABEL_58:
          sub_181BCEDC8((uint64_t)&v71);
          v42 = v63;
          os_log_type_t v43 = sub_181C7CBF8((void (*)(char *__return_ptr, void *))sub_181C86FC0, (uint64_t)v59, v20, v19);
          v63 = v42;
          goto LABEL_74;
        }

        v37 = v36 & 0xC;
        v38 = v36;
        if (v37 == v35) {
          v38 = sub_181C23710(v36, v20, v19);
        }
        v39 = v38 >> 16;
        if (v38 >> 16 >= v33)
        {
          __break(1u);
LABEL_83:
          __break(1u);
LABEL_84:
          __break(1u);
LABEL_85:
          __break(1u);
LABEL_86:
          __break(1u);
          goto LABEL_87;
        }

        if ((v19 & 0x1000000000000000LL) == 0) {
          break;
        }
        BOOL v41 = sub_18264EBC8();
        if (v37 == v35) {
          goto LABEL_56;
        }
LABEL_51:
        if ((v19 & 0x1000000000000000LL) != 0) {
          goto LABEL_52;
        }
LABEL_39:
        os_log_type_t v36 = (v36 & 0xFFFFFFFFFFFF0000LL) + 65540;
        if (v41 < 0) {
          goto LABEL_59;
        }
      }

      if ((v19 & 0x2000000000000000LL) != 0)
      {
        v68[0] = v20;
        v68[1] = v19 & 0xFFFFFFFFFFFFFFLL;
        BOOL v41 = *((_BYTE *)v68 + v39);
        if (v37 == v35) {
          goto LABEL_56;
        }
        goto LABEL_51;
      }

      os_log_type_t v40 = (v19 & 0xFFFFFFFFFFFFFFFLL) + 32;
      if ((v20 & 0x1000000000000000LL) == 0) {
        os_log_type_t v40 = sub_18264F228();
      }
      BOOL v41 = *(_BYTE *)(v40 + v39);
      if (v37 != v35) {
        goto LABEL_51;
      }
LABEL_56:
      os_log_type_t v36 = sub_181C23710(v36, v20, v19);
      if ((v19 & 0x1000000000000000LL) == 0) {
        goto LABEL_39;
      }
LABEL_52:
      if (v33 <= v36 >> 16) {
        goto LABEL_84;
      }
      os_log_type_t v36 = sub_18264EB98();
    }

    while ((v41 & 0x80) == 0);
LABEL_59:
    BOOL v44 = 11LL;
    if ((_DWORD)v58) {
      BOOL v44 = 7LL;
    }
    v45 = sub_181C86740(0xFuLL, v44 | (v33 << 16), v20, v19);
    v46 = v45 + 1;
    if (__OFADD__(v45, 1LL)) {
      goto LABEL_86;
    }
    if (v46 < 0) {
      goto LABEL_88;
    }
    isStackAllocationSafe = sub_181BCEDC8((uint64_t)&v71);
    if (v46 >= 1025)
    {
      isStackAllocationSafe = swift_stdlib_isStackAllocationSafe();
      if ((isStackAllocationSafe & 1) == 0) {
        goto LABEL_73;
      }
    }

          free(v50);
          if (!v26) {
            goto LABEL_141;
          }
LABEL_139:
          v76 = (char *)v26;
LABEL_140:
          free(v76);
          goto LABEL_141;
        }

        value = xpc_int64_get_value(v24);
        v45 = value;
        if (!value)
        {
          v49 = 0;
LABEL_142:

          goto LABEL_180;
        }

        if (!(value >> 31))
        {
          __nwlog_obj();
          v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v47 = v46;
          if ((_DWORD)v45 == 6)
          {
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              v110 = 1024;
              *(_DWORD *)v111 = 6;
              _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_ERROR,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
            }

            goto LABEL_141;
          }

          *(_DWORD *)buf = 136446466;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          v110 = 1024;
          *(_DWORD *)v111 = v45;
          v67 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v106 = 0;
          if (__nwlog_fault(v67, &type, &v106))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v78 = type;
              if (os_log_type_enabled(v77, type))
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 1024;
                *(_DWORD *)v111 = v45;
                _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
              }
            }

            else if (v106)
            {
              v83 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v84 = type;
              v85 = os_log_type_enabled(v77, type);
              if (v83)
              {
                if (v85)
                {
                  *(_DWORD *)buf = 136446722;
                  v109 = "networkd_privileged_set_agent_on_interface_internal";
                  v110 = 1024;
                  *(_DWORD *)v111 = v45;
                  *(_WORD *)&v111[4] = 2082;
                  *(void *)&v111[6] = v83;
                  _os_log_impl( &dword_181A5C000,  v77,  v84,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
                }

                free(v83);
                if (!v67) {
                  goto LABEL_141;
                }
LABEL_194:
                v76 = (char *)v67;
                goto LABEL_140;
              }

              if (v85)
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 1024;
                *(_DWORD *)v111 = v45;
                _os_log_impl( &dword_181A5C000,  v77,  v84,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
              }
            }

            else
            {
              __nwlog_obj();
              v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v89 = type;
              if (os_log_type_enabled(v77, type))
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 1024;
                *(_DWORD *)v111 = v45;
                _os_log_impl( &dword_181A5C000,  v77,  v89,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
              }
            }
          }

      v21 = a1[4];
LABEL_88:
      if (*(void *)(v21 + 48) == a1[6]) {
        nw_resolver_cancel_query_locked((NWConcrete_nw_resolver *)v21, 0);
      }
      break;
    case 2:
      if (a1[5]) {
        break;
      }
      BOOL v15 = a1[4];
      if (v15)
      {
        if ((*(_BYTE *)(v15 + 346) & 0x20) != 0)
        {
LABEL_64:
          v42 = nw_array_create();
          os_log_type_t v43 = a1[4];
          BOOL v44 = *(void **)(v43 + 144);
          *(void *)(v43 + 144) = v42;

          nw_resolver_update_status_locked(a1[4], 0LL);
          break;
        }

        if (*(_BYTE *)(v15 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          int v16 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_INFO)) {
            goto LABEL_63;
          }
          v17 = a1[4] + 256LL;
          os_log_type_t v52 = 136446466;
          os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          uint64_t v54 = 2082;
          *(void *)v55 = v17;
          v18 = "%{public}s [C%{public}s] Removing all results for DNS";
          v19 = v16;
          v20 = 22;
          goto LABEL_62;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v16 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          BOOL v41 = *(_DWORD *)(a1[4] + 340LL);
          os_log_type_t v52 = 136446466;
          os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          uint64_t v54 = 1024;
          *(_DWORD *)v55 = v41;
          v18 = "%{public}s [R%u] Removing all results for DNS";
          v19 = v16;
          v20 = 18;
          goto LABEL_62;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v16 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v52 = 136446210;
          os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
          v18 = "%{public}s Removing all results for DNS";
          v19 = v16;
          v20 = 12;
LABEL_62:
          _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_INFO, v18, (uint8_t *)&v52, v20);
        }
      }

        free(v18);
        goto LABEL_88;
      }
    }

    v13 = [v11 countByEnumeratingWithState:&v71 objects:v83 count:16];
    if (v13) {
      continue;
    }
    break;
  }

          protocol_handler = (const char *)nw_channel_get_protocol_handler(*(void *)(a3 + 48));
          if (protocol_handler)
          {
            v78 = protocol_handler;
            v79 = (void *)*((void *)protocol_handler + 5);
            if (v79 == &nw_protocol_ref_counted_handle)
            {
              v81 = *((void *)protocol_handler + 11);
              if (v81) {
                *((void *)protocol_handler + 11) = v81 + 1;
              }
              v80 = -1;
            }

            else
            {
              v80 = 0;
            }

            *(void *)v244 = protocol_handler;
            v244[8] = v80;
            if (v45)
            {
              v82 = *(void **)(v45 + 40);
              if (v82 == &nw_protocol_ref_counted_handle)
              {
                v84 = *(void *)(v45 + 88);
                if (v84) {
                  *(void *)(v45 + 88) = v84 + 1;
                }
                v83 = -1;
              }

              else
              {
                v83 = 0;
              }

              *(void *)v235 = v45;
              v236 = v83;
              v85 = (uint64_t (**)(const char *, uint64_t))*((void *)protocol_handler + 3);
              if (v85)
              {
                v86 = *v85;
                if (v86)
                {
                  v87 = v86(protocol_handler, v45);
                  if (v82 != &nw_protocol_ref_counted_handle) {
                    goto LABEL_103;
                  }
                  goto LABEL_102;
                }
              }

              __nwlog_obj();
              v126 = (void *)objc_claimAutoreleasedReturnValue();
              v127 = (const char *)*((void *)v78 + 2);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
              if (!v127) {
                v127 = "invalid";
              }
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v127;
              *(_WORD *)&buf[22] = 2048;
              v239 = v78;
              v187 = (char *)_os_log_send_and_compose_impl();

              v237 = OS_LOG_TYPE_ERROR;
              v234 = 0;
              if (v237 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v129 = v237;
                if (os_log_type_enabled(v128, v237))
                {
                  v130 = (const char *)*((void *)v78 + 2);
                  if (!v130) {
                    v130 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v130;
                  *(_WORD *)&buf[22] = 2048;
                  v239 = v78;
                  _os_log_impl( &dword_181A5C000,  v128,  v129,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback",  buf,  0x20u);
                }
              }

              else
              {
                if (v234)
                {
                  v142 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v143 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v186 = v237;
                  v144 = os_log_type_enabled(v143, v237);
                  if (v142)
                  {
                    if (v144)
                    {
                      v145 = (const char *)*((void *)v78 + 2);
                      if (!v145) {
                        v145 = "invalid";
                      }
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v145;
                      *(_WORD *)&buf[22] = 2048;
                      v239 = v78;
                      v240 = 2082;
                      v241 = v142;
                      _os_log_impl( &dword_181A5C000,  v143,  v186,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    free(v142);
                  }

                  else
                  {
                    if (v144)
                    {
                      v170 = (const char *)*((void *)v78 + 2);
                      if (!v170) {
                        v170 = "invalid";
                      }
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_add_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v170;
                      *(_WORD *)&buf[22] = 2048;
                      v239 = v78;
                      _os_log_impl( &dword_181A5C000,  v143,  v186,  "%{public}s protocol %{public}s (%p) has invalid add_input_handler callback, no backtrace",  buf,  0x20u);
                    }
                  }

    free(backtrace_string);
    goto LABEL_127;
  }

  if (!*((void *)v7 + 37))
  {
    if ((v7[403] & 4) != 0)
    {
      v21 = 0LL;
      v7[403] |= 8u;
LABEL_160:
      v7[405] |= 2u;
      goto LABEL_161;
    }

    v77[0] = 0LL;
    v77[1] = v77;
    v17 = (const char *)*((void *)v7 - 8);
    if (v17)
    {
      v18 = (void *)*((void *)v17 + 5);
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        v24 = *((void *)v17 + 11);
        if (v24) {
          *((void *)v17 + 11) = v24 + 1;
        }
        v19 = -1;
      }

      else
      {
        v19 = 0;
      }

      *(void *)os_log_type_t type = v17;
      v84 = v19;
      v25 = (void *)*((void *)v7 - 7);
      if (v25 == &nw_protocol_ref_counted_handle)
      {
        BOOL v27 = *((void *)v7 - 1);
        if (v27) {
          *((void *)v7 - 1) = v27 + 1;
        }
        uint64_t v26 = -1;
      }

      else
      {
        uint64_t v26 = 0;
      }

      v81 = v7 - 96;
      LOBYTE(v82) = v26;
      int v28 = *((void *)v17 + 3);
      if (v28)
      {
        v29 = *(uint64_t (**)(const char *, _BYTE *, uint64_t, uint64_t, uint64_t, id *))(v28 + 88);
        if (v29)
        {
          v30 = v29(v17, v7 - 96, a3, a3, 1LL, v77);
          if (v25 != &nw_protocol_ref_counted_handle) {
            goto LABEL_40;
          }
          goto LABEL_147;
        }
      }

      __nwlog_obj();
      v51 = (void *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = (const char *)*((void *)v17 + 2);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
      if (!v52) {
        os_log_type_t v52 = "invalid";
      }
      v86 = 2082;
      v87 = (char *)v52;
      v88 = 2048;
      v89 = v17;
      os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

      v80 = OS_LOG_TYPE_ERROR;
      v79 = 0;
      if (__nwlog_fault(v53, &v80, &v79))
      {
        if (v80 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v55 = v80;
          if (os_log_type_enabled(v54, v80))
          {
            v56 = (const char *)*((void *)v17 + 2);
            if (!v56) {
              v56 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_frames";
            v86 = 2082;
            v87 = (char *)v56;
            v88 = 2048;
            v89 = v17;
            _os_log_impl( &dword_181A5C000,  v54,  v55,  "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback",  buf,  0x20u);
          }

          [*v11 mainDocumentURL];
          v65 = (void *)objc_claimAutoreleasedReturnValue();
          v66 = v65 == 0LL;

          if (v66) {
            goto LABEL_100;
          }
          if (v40 && v127) {
            v67 = [v40 isEqualToString:v127];
          }
          else {
            v67 = [v21 isEqualToString:v24];
          }
          if ((v67 & 1) == 0) {
            nw_parameters_set_is_third_party_web_content(v4, 1);
          }
          [*v11 mainDocumentURL];
          v68 = (const __CFURL *)objc_claimAutoreleasedReturnValue();
          uint64_t v69 = v4;
          v70 = v69;
          if (v69)
          {
            if (v68)
            {
              v71 = -[NWConcrete_nw_url_endpoint initWithURL:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_url_endpoint),  v68);
              v72 = (void *)v70[26];
              v70[26] = v71;
            }

            else
            {
              v72 = (void *)v69[26];
              v69[26] = 0LL;
            }

LABEL_99:
LABEL_100:
            objc_msgSend(*v11, "boundInterfaceIdentifier", v115, v118);
            v73 = (void *)objc_claimAutoreleasedReturnValue();
            v74 = v73 == 0LL;

            if (!v74)
            {
              [*v11 boundInterfaceIdentifier];
              v75 = (void *)objc_claimAutoreleasedReturnValue();
              v76 = nw_interface_create_with_name((char *)[v75 UTF8String]);
              nw_parameters_require_interface((nw_parameters_t)v4, (nw_interface_t)v76);
            }

            v77 = [*v11 _privacyProxyFailClosedForUnreachableNonMainHosts];
            if (v21) {
              v78 = v77;
            }
            else {
              v78 = 0;
            }
            if (v78 == 1 && [v21 caseInsensitiveCompare:v24]) {
              nw_parameters_set_privacy_proxy_fail_closed_for_unreachable_hosts(v4, 1);
            }
            if (![*v11 _allowPrivateAccessTokensForThirdParty])
            {
LABEL_126:
              if (!objc_msgSend(*v13, "_inPrivateBrowsing", v116, v119))
              {
LABEL_130:

                goto LABEL_131;
              }

              v81 = v4;
              v82 = v81;
              if (v81)
              {
                *((void *)v81 + 12) |= 0x40000000000uLL;
LABEL_129:

                goto LABEL_130;
              }

              __nwlog_obj();
              v96 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)objects = 136446210;
              *(void *)&objects[4] = "nw_parameters_set_using_ephemeral_configuration";
              v97 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              v128 = 0;
              if (__nwlog_fault(v97, &type, &v128))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v99 = type;
                  if (os_log_type_enabled(v98, type))
                  {
                    *(_DWORD *)objects = 136446210;
                    *(void *)&objects[4] = "nw_parameters_set_using_ephemeral_configuration";
                    _os_log_impl(&dword_181A5C000, v98, v99, "%{public}s called with null parameters", objects, 0xCu);
                  }
                }

                else if (v128)
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v124 = type;
                  v110 = os_log_type_enabled(v98, type);
                  if (backtrace_string)
                  {
                    if (v110)
                    {
                      *(_DWORD *)objects = 136446466;
                      *(void *)&objects[4] = "nw_parameters_set_using_ephemeral_configuration";
                      *(_WORD *)&objects[12] = 2082;
                      *(void *)&objects[14] = backtrace_string;
                      _os_log_impl( &dword_181A5C000,  v98,  v124,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  objects,  0x16u);
                    }

                    free(backtrace_string);
                    goto LABEL_221;
                  }

                  if (v110)
                  {
                    *(_DWORD *)objects = 136446210;
                    *(void *)&objects[4] = "nw_parameters_set_using_ephemeral_configuration";
                    _os_log_impl( &dword_181A5C000,  v98,  v124,  "%{public}s called with null parameters, no backtrace",  objects,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v113 = type;
                  if (os_log_type_enabled(v98, type))
                  {
                    *(_DWORD *)objects = 136446210;
                    *(void *)&objects[4] = "nw_parameters_set_using_ephemeral_configuration";
                    _os_log_impl( &dword_181A5C000,  v98,  v113,  "%{public}s called with null parameters, backtrace limit exceeded",  objects,  0xCu);
                  }
                }
              }

    free(backtrace_string);
    goto LABEL_103;
  }

  memset(v53, 0, 19);
  os_log_type_t v52 = 0u;
  v51 = 0u;
  char v8 = v7;
  v9 = v8;
  v10 = 0LL;
  memset(v50, 0, sizeof(v50));
  while (1)
  {
    v11 = v8[v10 + 48];
    v50[v10] = v11;
    if (!v11) {
      break;
    }
    if (++v10 == 83)
    {
      v53[18] = 0;
      break;
    }
  }

  if (handle[6])
  {
    v13 = (char *)handle[24];
    __int16 v12 = handle[25];
    if ((unint64_t)v13 >= v12)
    {
      v17 = (char *)handle[23];
      v18 = (v13 - v17) >> 4;
      v19 = v18 + 1;
      v20 = v12 - (void)v17;
      if (v20 >> 3 > v19) {
        v19 = v20 >> 3;
      }
      v21 = (unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0LL;
      uint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
      if (!v21) {
        uint64_t v22 = v19;
      }
      if (v22 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v23 = 16 * v22;
      v24 = (char *)operator new(16 * v22);
      v25 = &v24[16 * v18];
      uint64_t v26 = &v24[v23];
      *(void *)v25 = a2;
      *((_DWORD *)v25 + 2) = 0;
      uint64_t v14 = v25 + 16;
      if (v13 == v17)
      {
        BOOL v27 = &v24[16 * v18];
      }

      else
      {
        do
        {
          BOOL v27 = v25 - 16;
          *((_OWORD *)v25 - 1) = *((_OWORD *)v13 - 1);
          v13 -= 16;
          v25 -= 16;
        }

        while (v13 != v17);
      }

      handle[23] = v27;
      handle[24] = v14;
      handle[25] = v26;
      if (v17) {
        operator delete(v17);
      }
    }

    else
    {
      *(void *)v13 = a2;
      *((_DWORD *)v13 + 2) = 0;
      uint64_t v14 = v13 + 16;
    }

    handle[24] = v14;
    if ((*((_BYTE *)handle + 294) & 4) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v28 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v43 = "nw_protocol_http_client_bottom_add_input_handler";
        BOOL v44 = 2082;
        v45 = (char *)(handle + 26);
        v46 = 2080;
        v47 = " ";
        v48 = 2082;
        v49 = v50;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%sjoined by %{public}s",  buf,  0x2Au);
      }
    }
  }

  else
  {
    nw_protocol_set_input_handler((uint64_t)handle, (uint64_t)a2);
    BOOL v15 = 0LL;
    *(_OWORD *)handle = *(_OWORD *)a2->flow_id;
    while (1)
    {
      int v16 = v50[v15];
      *((_BYTE *)handle + v15 + 208) = v16;
      if (!v16) {
        break;
      }
      if (++v15 == 83)
      {
        *((_BYTE *)handle + 291) = 0;
        break;
      }
    }
  }

  if (a2->output_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v43 = "nw_protocol_http_client_bottom_add_input_handler";
      _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s Output handler already exists for protocol being added as input handler",  buf,  0xCu);
    }
  }

  else
  {
    nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
  }

  os_release(v9);
  return 1LL;
}

          free(v31);
          goto LABEL_88;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v58 = "nwphRunProbe";
          v34 = "%{public}s called with null probeTarget, no backtrace";
          goto LABEL_84;
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v58 = "nwphRunProbe";
          v34 = "%{public}s called with null probeTarget, backtrace limit exceeded";
          goto LABEL_84;
        }
      }

      goto LABEL_85;
    }

    __nwlog_obj();
    os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_85;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nwphRunProbe";
    v34 = "%{public}s called with null probeTarget";
    goto LABEL_84;
  }

  if (!v10)
  {
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nwphRunProbe";
    v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v55)
      {
        __nwlog_obj();
        os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v58 = "nwphRunProbe";
          v34 = "%{public}s called with null parent_activity, backtrace limit exceeded";
          goto LABEL_84;
        }

        goto LABEL_85;
      }

      BOOL v44 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v33 = type;
      v45 = os_log_type_enabled(v32, type);
      if (!v44)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v58 = "nwphRunProbe";
          v34 = "%{public}s called with null parent_activity, no backtrace";
          goto LABEL_84;
        }

        goto LABEL_85;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v58 = "nwphRunProbe";
        v59 = 2082;
        v60 = v44;
        v46 = "%{public}s called with null parent_activity, dumping backtrace:%{public}s";
LABEL_62:
        _os_log_impl(&dword_181A5C000, v32, v33, v46, buf, 0x16u);
      }
}

  if (v21) {
LABEL_88:
  }
    free(v21);
LABEL_12:

  return 1LL;
}

  if (v27) {
    free(v27);
  }
}

          if (!v25) {
            goto LABEL_89;
          }
          goto LABEL_88;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = (nw_frame *)(v11 + 205);
        *(_DWORD *)buf = 136446466;
        uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = (nw_frame *)(v11 + 205);
        v25 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v51 = 0;
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v51)
          {
            uint64_t v26 = (os_log_s *)__nwlog_obj();
            BOOL v27 = type;
            if (!os_log_type_enabled(v26, type)) {
              goto LABEL_87;
            }
            *(_DWORD *)buf = 136446466;
            uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v29;
            int v28 = "%{public}s %{public}s node not found, backtrace limit exceeded";
            goto LABEL_86;
          }

          v34 = (char *)__nw_create_backtrace_string();
          uint64_t v26 = (os_log_s *)__nwlog_obj();
          BOOL v27 = type;
          v35 = os_log_type_enabled(v26, type);
          if (!v34)
          {
            if (!v35) {
              goto LABEL_87;
            }
            *(_DWORD *)buf = 136446466;
            uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v29;
            int v28 = "%{public}s %{public}s node not found, no backtrace";
            goto LABEL_86;
          }

          if (!v35) {
            goto LABEL_69;
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v55 = 2082;
          v56 = v29;
          uint64_t v57 = 2082;
          v58[0] = v34;
          os_log_type_t v36 = "%{public}s %{public}s node not found, dumping backtrace:%{public}s";
LABEL_68:
          _os_log_impl(&dword_181A5C000, v26, v27, v36, buf, 0x20u);
LABEL_69:
          free(v34);
          if (v25) {
LABEL_88:
          }
            free(v25);
LABEL_89:
          if ((*((_WORD *)a1 + 102) & 0x100) != 0
            && g_channel_check_validity
            && !g_channel_check_validity(a1, *((void *)a1 + 11)))
          {
            goto LABEL_94;
          }

          buffer = (void *)*((void *)a1 + 14);
          if (!buffer) {
            goto LABEL_94;
          }
          goto LABEL_93;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v26 = (os_log_s *)gLogObj;
        BOOL v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_87;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = v29;
        int v28 = "%{public}s %{public}s node not found";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (nw_frame *)(v11 + 205);
        *(_DWORD *)buf = 136446466;
        uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = (nw_frame *)(v11 + 205);
        v25 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v51 = 0;
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v51)
          {
            uint64_t v26 = (os_log_s *)__nwlog_obj();
            BOOL v27 = type;
            if (!os_log_type_enabled(v26, type)) {
              goto LABEL_87;
            }
            *(_DWORD *)buf = 136446466;
            uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v24;
            int v28 = "%{public}s %{public}s input_protocol not found, backtrace limit exceeded";
            goto LABEL_86;
          }

          v30 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v26 = (os_log_s *)gLogObj;
          BOOL v27 = type;
          v31 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (!v30)
          {
            if (!v31) {
              goto LABEL_87;
            }
            *(_DWORD *)buf = 136446466;
            uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v24;
            int v28 = "%{public}s %{public}s input_protocol not found, no backtrace";
            goto LABEL_86;
          }

          if (v31)
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v24;
            uint64_t v57 = 2082;
            v58[0] = v30;
            _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s %{public}s input_protocol not found, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v30);
          goto LABEL_87;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v26 = (os_log_s *)gLogObj;
        BOOL v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_87;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = v24;
        int v28 = "%{public}s %{public}s input_protocol not found";
      }

      v60 = 0LL;
      goto LABEL_88;
    }
  }

        goto LABEL_88;
      }

      if (!v44)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v39 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_necp_append_tlv";
          _os_log_impl( &dword_181A5C000,  v22,  v39,  "%{public}s called with null beyond, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_87;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = type;
      os_log_type_t v32 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v22, v31, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
        }

        goto LABEL_87;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "nw_necp_append_tlv";
        v48 = 2082;
        *(void *)v49 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_57;
    }

    goto LABEL_88;
  }

  char v8 = (v5 + 1);
  if (v6 >= v7)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v47 = "nw_necp_append_tlv";
    v48 = 2048;
    *(void *)v49 = v6;
    *(_WORD *)&v49[8] = 2048;
    *(void *)v50 = v7;
    *(_WORD *)&v50[8] = 1024;
    *(_DWORD *)v51 = 8;
    *(_WORD *)&v51[4] = 1024;
    *(_DWORD *)&v51[6] = v8;
    v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447234;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v7;
        *(_WORD *)&v50[8] = 1024;
        *(_DWORD *)v51 = 8;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  buf,  0x2Cu);
      }

      goto LABEL_27;
    }

    if (!v44)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447234;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v7;
        *(_WORD *)&v50[8] = 1024;
        *(_DWORD *)v51 = 8;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v40,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  buf,  0x2Cu);
      }

      goto LABEL_27;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v34 = type;
    v35 = os_log_type_enabled(v11, type);
    if (!v33)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136447234;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v7;
        *(_WORD *)&v50[8] = 1024;
        *(_DWORD *)v51 = 8;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v34,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  buf,  0x2Cu);
      }

      goto LABEL_27;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136447490;
      v47 = "nw_necp_append_tlv";
      v48 = 2048;
      *(void *)v49 = v6;
      *(_WORD *)&v49[8] = 2048;
      *(void *)v50 = v7;
      *(_WORD *)&v50[8] = 1024;
      *(_DWORD *)v51 = 8;
      *(_WORD *)&v51[4] = 1024;
      *(_DWORD *)&v51[6] = v8;
      *(_WORD *)os_log_type_t v52 = 2082;
      *(void *)&v52[2] = v33;
      _os_log_impl( &dword_181A5C000,  v11,  v34,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
    }

    goto LABEL_81;
  }

  if (v7 - v6 < v8 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    v47 = "nw_necp_append_tlv";
    v48 = 2048;
    *(void *)v49 = v6;
    *(_WORD *)&v49[8] = 2048;
    *(void *)v50 = v8 + 5;
    *(_WORD *)&v50[8] = 2048;
    *(void *)v51 = v7;
    *(_WORD *)&v51[8] = 1024;
    *(_DWORD *)os_log_type_t v52 = 8;
    *(_WORD *)&v52[4] = 1024;
    *(_DWORD *)&v52[6] = v8;
    v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (os_log_s *)(id)gLogObj;
      __int16 v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447490;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v8 + 5;
        *(_WORD *)&v50[8] = 2048;
        *(void *)v51 = v7;
        *(_WORD *)&v51[8] = 1024;
        *(_DWORD *)os_log_type_t v52 = 8;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
      }
    }

    else if (v44)
    {
      BOOL v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (os_log_s *)(id)gLogObj;
      int v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136447746;
          v47 = "nw_necp_append_tlv";
          v48 = 2048;
          *(void *)v49 = v6;
          *(_WORD *)&v49[8] = 2048;
          *(void *)v50 = v8 + 5;
          *(_WORD *)&v50[8] = 2048;
          *(void *)v51 = v7;
          *(_WORD *)&v51[8] = 1024;
          *(_DWORD *)os_log_type_t v52 = 8;
          *(_WORD *)&v52[4] = 1024;
          *(_DWORD *)&v52[6] = v8;
          os_log_type_t v53 = 2082;
          uint64_t v54 = v15;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
        }

        free(v15);
        if (!v10) {
          goto LABEL_31;
        }
LABEL_29:
        v19 = (char *)v10;
LABEL_30:
        free(v19);
        goto LABEL_31;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136447490;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v8 + 5;
        *(_WORD *)&v50[8] = 2048;
        *(void *)v51 = v7;
        *(_WORD *)&v51[8] = 1024;
        *(_DWORD *)os_log_type_t v52 = 8;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (os_log_s *)(id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447490;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v8 + 5;
        *(_WORD *)&v50[8] = 2048;
        *(void *)v51 = v7;
        *(_WORD *)&v51[8] = 1024;
        *(_DWORD *)os_log_type_t v52 = 8;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
      }
    }

    goto LABEL_27;
  }

  *(_BYTE *)char v6 = 8;
  *(_DWORD *)(v6 + 1) = v8;
  if ((_DWORD)v5 != -1)
  {
    if (string_ptr)
    {
      memcpy((void *)(v6 + 5), string_ptr, v8);
      goto LABEL_15;
    }

    __nwlog_obj();
    os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v47 = "nw_necp_append_tlv";
    v48 = 1024;
    *(_DWORD *)v49 = 8;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v8;
    v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (!__nwlog_fault(v10, &type, &v44))
    {
LABEL_28:
      if (!v10)
      {
LABEL_31:
        uint64_t v14 = 0LL;
        goto LABEL_32;
      }

      goto LABEL_29;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446722;
        v47 = "nw_necp_append_tlv";
        v48 = 1024;
        *(_DWORD *)v49 = 8;
        *(_WORD *)&v49[4] = 1024;
        *(_DWORD *)&v49[6] = v8;
        _os_log_impl(&dword_181A5C000, v11, v37, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
      }

        goto LABEL_88;
      }

      if (!v44)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v39 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_necp_append_tlv";
          _os_log_impl( &dword_181A5C000,  v22,  v39,  "%{public}s called with null beyond, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_87;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = type;
      os_log_type_t v32 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v22, v31, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
        }

        goto LABEL_87;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "nw_necp_append_tlv";
        v48 = 2082;
        *(void *)v49 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_57;
    }

    goto LABEL_88;
  }

  char v8 = (v5 + 1);
  if (v6 >= v7)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v47 = "nw_necp_append_tlv";
    v48 = 2048;
    *(void *)v49 = v6;
    *(_WORD *)&v49[8] = 2048;
    *(void *)v50 = v7;
    *(_WORD *)&v50[8] = 1024;
    *(_DWORD *)v51 = 9;
    *(_WORD *)&v51[4] = 1024;
    *(_DWORD *)&v51[6] = v8;
    v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447234;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v7;
        *(_WORD *)&v50[8] = 1024;
        *(_DWORD *)v51 = 9;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  buf,  0x2Cu);
      }

      goto LABEL_27;
    }

    if (!v44)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447234;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v7;
        *(_WORD *)&v50[8] = 1024;
        *(_DWORD *)v51 = 9;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v40,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  buf,  0x2Cu);
      }

      goto LABEL_27;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v34 = type;
    v35 = os_log_type_enabled(v11, type);
    if (!v33)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136447234;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v7;
        *(_WORD *)&v50[8] = 1024;
        *(_DWORD *)v51 = 9;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v34,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  buf,  0x2Cu);
      }

      goto LABEL_27;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136447490;
      v47 = "nw_necp_append_tlv";
      v48 = 2048;
      *(void *)v49 = v6;
      *(_WORD *)&v49[8] = 2048;
      *(void *)v50 = v7;
      *(_WORD *)&v50[8] = 1024;
      *(_DWORD *)v51 = 9;
      *(_WORD *)&v51[4] = 1024;
      *(_DWORD *)&v51[6] = v8;
      *(_WORD *)os_log_type_t v52 = 2082;
      *(void *)&v52[2] = v33;
      _os_log_impl( &dword_181A5C000,  v11,  v34,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
    }

    goto LABEL_81;
  }

  if (v7 - v6 < v8 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    v47 = "nw_necp_append_tlv";
    v48 = 2048;
    *(void *)v49 = v6;
    *(_WORD *)&v49[8] = 2048;
    *(void *)v50 = v8 + 5;
    *(_WORD *)&v50[8] = 2048;
    *(void *)v51 = v7;
    *(_WORD *)&v51[8] = 1024;
    *(_DWORD *)os_log_type_t v52 = 9;
    *(_WORD *)&v52[4] = 1024;
    *(_DWORD *)&v52[6] = v8;
    v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (os_log_s *)(id)gLogObj;
      __int16 v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447490;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v8 + 5;
        *(_WORD *)&v50[8] = 2048;
        *(void *)v51 = v7;
        *(_WORD *)&v51[8] = 1024;
        *(_DWORD *)os_log_type_t v52 = 9;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
      }
    }

    else if (v44)
    {
      BOOL v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (os_log_s *)(id)gLogObj;
      int v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136447746;
          v47 = "nw_necp_append_tlv";
          v48 = 2048;
          *(void *)v49 = v6;
          *(_WORD *)&v49[8] = 2048;
          *(void *)v50 = v8 + 5;
          *(_WORD *)&v50[8] = 2048;
          *(void *)v51 = v7;
          *(_WORD *)&v51[8] = 1024;
          *(_DWORD *)os_log_type_t v52 = 9;
          *(_WORD *)&v52[4] = 1024;
          *(_DWORD *)&v52[6] = v8;
          os_log_type_t v53 = 2082;
          uint64_t v54 = v15;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
        }

        free(v15);
        if (!v10) {
          goto LABEL_31;
        }
LABEL_29:
        v19 = (char *)v10;
LABEL_30:
        free(v19);
        goto LABEL_31;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136447490;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v8 + 5;
        *(_WORD *)&v50[8] = 2048;
        *(void *)v51 = v7;
        *(_WORD *)&v51[8] = 1024;
        *(_DWORD *)os_log_type_t v52 = 9;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (os_log_s *)(id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136447490;
        v47 = "nw_necp_append_tlv";
        v48 = 2048;
        *(void *)v49 = v6;
        *(_WORD *)&v49[8] = 2048;
        *(void *)v50 = v8 + 5;
        *(_WORD *)&v50[8] = 2048;
        *(void *)v51 = v7;
        *(_WORD *)&v51[8] = 1024;
        *(_DWORD *)os_log_type_t v52 = 9;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = v8;
        _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
      }
    }

    goto LABEL_27;
  }

  *(_BYTE *)char v6 = 9;
  *(_DWORD *)(v6 + 1) = v8;
  if ((_DWORD)v5 != -1)
  {
    if (string_ptr)
    {
      memcpy((void *)(v6 + 5), string_ptr, v8);
      goto LABEL_15;
    }

    __nwlog_obj();
    os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v47 = "nw_necp_append_tlv";
    v48 = 1024;
    *(_DWORD *)v49 = 9;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v8;
    v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v44 = 0;
    if (!__nwlog_fault(v10, &type, &v44))
    {
LABEL_28:
      if (!v10)
      {
LABEL_31:
        uint64_t v14 = 0LL;
        goto LABEL_32;
      }

      goto LABEL_29;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446722;
        v47 = "nw_necp_append_tlv";
        v48 = 1024;
        *(_DWORD *)v49 = 9;
        *(_WORD *)&v49[4] = 1024;
        *(_DWORD *)&v49[6] = v8;
        _os_log_impl(&dword_181A5C000, v11, v37, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
      }

  if (v52) {
    free(v52);
  }
  return 0LL;
}

    if (v48) {
      free(v48);
    }
    goto LABEL_89;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (id)gLogObj;
  v19 = v11;
  v20 = [v19 type];

  *(_DWORD *)buf = 136446466;
  char v64 = "nw_endpoint_host_endpoint_matches_hostname";
  v65 = 1024;
  *(_DWORD *)v66 = v20;
  LODWORD(v60) = 18;
  v21 = (const char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v61 = 0;
  if (__nwlog_fault(v21, &type, &v61))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      uint64_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        v24 = v19;
        v25 = objc_msgSend(v24, "type", buf, v60);

        *(_DWORD *)buf = 136446466;
        char v64 = "nw_endpoint_host_endpoint_matches_hostname";
        v65 = 1024;
        *(_DWORD *)v66 = v25;
        _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s incorrect endpoint type %u", buf, 0x12u);
      }
    }

    else if (v61)
    {
      uint64_t v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      BOOL v27 = type;
      int v28 = os_log_type_enabled(v22, type);
      if (v26)
      {
        if (v28)
        {
          v29 = v19;
          v30 = objc_msgSend(v29, "type", buf, v60);

          *(_DWORD *)buf = 136446722;
          char v64 = "nw_endpoint_host_endpoint_matches_hostname";
          v65 = 1024;
          *(_DWORD *)v66 = v30;
          v66[2] = 2082;
          *(void *)&v66[3] = v26;
          _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v26);
        if (!v21) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }

      if (v28)
      {
        v35 = v19;
        os_log_type_t v36 = objc_msgSend(v35, "type", buf, v60);

        *(_DWORD *)buf = 136446466;
        char v64 = "nw_endpoint_host_endpoint_matches_hostname";
        v65 = 1024;
        *(_DWORD *)v66 = v36;
        _os_log_impl(&dword_181A5C000, v22, v27, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v22, type))
      {
        v33 = v19;
        v34 = objc_msgSend(v33, "type", buf, v60);

        *(_DWORD *)buf = 136446466;
        char v64 = "nw_endpoint_host_endpoint_matches_hostname";
        v65 = 1024;
        *(_DWORD *)v66 = v34;
        _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
      }
    }
  }

  if (v21)
  {
LABEL_34:
    v37 = (char *)v21;
LABEL_35:
    free(v37);
  }

        if (!v29) {
          goto LABEL_89;
        }
        goto LABEL_88;
      }

      os_log_type_t v40 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v41 = (id)gLogObj;
      *(_DWORD *)v70 = 136446978;
      v71 = "createKernelSocket";
      v72 = 2082;
      *(void *)v73 = &buf[4];
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v5;
      *(_WORD *)&v73[14] = 1024;
      *(_DWORD *)&v73[16] = v40;
      v29 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v65 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v42 = (os_log_s *)(id)gLogObj;
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)v70 = 136446978;
          v71 = "createKernelSocket";
          v72 = 2082;
          *(void *)v73 = &buf[4];
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v5;
          *(_WORD *)&v73[14] = 1024;
          *(_DWORD *)&v73[16] = v40;
          BOOL v44 = "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d";
LABEL_85:
          _os_log_impl(&dword_181A5C000, v42, v43, v44, (uint8_t *)v70, 0x22u);
        }
      }

      else
      {
        if (v65)
        {
          v48 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v43 = type;
          v49 = os_log_type_enabled(v42, type);
          if (v48)
          {
            if (v49)
            {
              *(_DWORD *)v70 = 136447234;
              v71 = "createKernelSocket";
              v72 = 2082;
              *(void *)v73 = &buf[4];
              *(_WORD *)&v73[8] = 1024;
              *(_DWORD *)&v73[10] = v5;
              *(_WORD *)&v73[14] = 1024;
              *(_DWORD *)&v73[16] = v40;
              v74 = 2082;
              v75[0] = v48;
              _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)v70,  0x2Cu);
            }

            free(v48);
            if (v29) {
              goto LABEL_88;
            }
            goto LABEL_89;
          }

          if (!v49) {
            goto LABEL_86;
          }
          *(_DWORD *)v70 = 136446978;
          v71 = "createKernelSocket";
          v72 = 2082;
          *(void *)v73 = &buf[4];
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v5;
          *(_WORD *)&v73[14] = 1024;
          *(_DWORD *)&v73[16] = v40;
          BOOL v44 = "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d, no backtrace";
          goto LABEL_85;
        }

        __nwlog_obj();
        v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)v70 = 136446978;
          v71 = "createKernelSocket";
          v72 = 2082;
          *(void *)v73 = &buf[4];
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v5;
          *(_WORD *)&v73[14] = 1024;
          *(_DWORD *)&v73[16] = v40;
          BOOL v44 = "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_85;
        }
      }

        goto LABEL_88;
      }

      if (!v24)
      {
        __nwlog_obj();
        int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v27 = "nw_utf8_validator_parse";
          v18 = "%{public}s called with null state, backtrace limit exceeded";
          goto LABEL_86;
        }

        goto LABEL_87;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v17 = type;
      v21 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v27 = "nw_utf8_validator_parse";
          v18 = "%{public}s called with null state, no backtrace";
          goto LABEL_86;
        }

        goto LABEL_87;
      }

      if (!v21) {
        goto LABEL_77;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v27 = "nw_utf8_validator_parse";
      int v28 = 2082;
      v29 = backtrace_string;
      uint64_t v22 = "%{public}s called with null state, dumping backtrace:%{public}s";
      goto LABEL_76;
    }

    if (!v42)
    {
LABEL_89:

      v31 = 0LL;
LABEL_39:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v32 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        v33 = "";
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
        *(void *)&buf[14] = v26;
        *(_WORD *)&buf[12] = 2114;
        if (a5) {
          v33 = "force-";
        }
        *(_WORD *)&buf[22] = 2082;
        char v64 = (uint64_t (*)(uint64_t, uint64_t))v33;
        *(_WORD *)v65 = 2114;
        *(void *)&v65[2] = v28;
        *(_WORD *)&v65[10] = 2114;
        *(void *)&v65[12] = v12;
        _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ %{public}scancelling connection %{public}@ for request %{public}@",  buf,  0x34u);
      }

      if (a5) {
        nw_connection_cancel_current_endpoint(v28);
      }
      else {
        nw_connection_cancel(v28);
      }
      goto LABEL_53;
    }

    goto LABEL_88;
  }

  __nwlog_obj();
  os_log_type_t v53 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v64 = "nw_browser_add_result_locked";
  uint64_t v54 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v61 = 0;
  if (__nwlog_fault(v54, &type, &v61))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        char v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s called with null browser", buf, 0xCu);
      }
    }

    else if (v61)
    {
      uint64_t v57 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v58 = type;
      v59 = os_log_type_enabled(v55, type);
      if (v57)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          char v64 = "nw_browser_add_result_locked";
          v65 = 2082;
          *(void *)v66 = v57;
          _os_log_impl( &dword_181A5C000,  v55,  v58,  "%{public}s called with null browser, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v57);
        goto LABEL_107;
      }

      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        char v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_181A5C000, v55, v58, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v60 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        char v64 = "nw_browser_add_result_locked";
        _os_log_impl( &dword_181A5C000,  v55,  v60,  "%{public}s called with null browser, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v39) {
      free(v39);
    }
    goto LABEL_89;
  }

  __nwlog_obj();
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v54 = "nw_activity_create_retry";
  v35 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v52.receiver) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v35, &v52, &type))
  {
    if (LOBYTE(v52.receiver) == 17)
    {
      __nwlog_obj();
      os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)v52.receiver;
      if (os_log_type_enabled(v36, (os_log_type_t)v52.receiver))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_activity_create_retry";
        _os_log_impl(&dword_181A5C000, v36, receiver, "%{public}s called with null original", buf, 0xCu);
      }
    }

    else if (type)
    {
      v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = (os_log_type_t)v52.receiver;
      BOOL v44 = os_log_type_enabled(v36, (os_log_type_t)v52.receiver);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v54 = "nw_activity_create_retry";
          v55 = 2082;
          *(void *)v56 = v42;
          _os_log_impl( &dword_181A5C000,  v36,  v43,  "%{public}s called with null original, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v42);
        goto LABEL_81;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_activity_create_retry";
        _os_log_impl(&dword_181A5C000, v36, v43, "%{public}s called with null original, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = (os_log_type_t)v52.receiver;
      if (os_log_type_enabled(v36, (os_log_type_t)v52.receiver))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_activity_create_retry";
        _os_log_impl( &dword_181A5C000,  v36,  v48,  "%{public}s called with null original, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        free(v23);
        goto LABEL_88;
      }

      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v24, v33, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v45 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl( &dword_181A5C000,  v24,  v45,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v11 == 4287504053) {
      goto LABEL_88;
    }
    v71 = v9;
    if ((v19 & 1) != 0)
    {
      v20 = &qword_18C45F000;
    }

    else
    {
      v20 = &qword_18C45F000;
      if ((*(_WORD *)(v10 + 736) & 0x800) != 0)
      {
LABEL_93:
        nw_frame_finalize(a2);
        v9 = v71;
        goto LABEL_94;
      }
    }

    if (*((_BYTE *)v20 + 1537))
    {
      v104 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
      {
        v105 = (const char *)(v10 + 636);
        v106 = "";
        v107 = *(_DWORD *)(*(void *)(v10 + 336) + 1280LL);
        v108 = *(void *)(v10 + 240);
        if (v19) {
          v105 = "";
        }
        else {
          v106 = " ";
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v105;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&_BYTE buf[24] = v106;
        LOWORD(v130) = 1024;
        *(_DWORD *)((char *)&v130 + 2) = v107;
        HIWORD(v130) = 2048;
        v131 = v108;
        _os_log_impl( &dword_181A5C000,  v104,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> dropping unknown frame type",  buf,  0x30u);
      }
    }

    goto LABEL_93;
  }

  BOOL v27 = *(_DWORD *)(v10 + 372);
  v20 = &qword_18C45F000;
  if (v27 > 8)
  {
LABEL_94:
    v47 = 0;
    goto LABEL_95;
  }

  if (((1 << v27) & 0x1EE) == 0)
  {
    v125 = v9;
    if (!v27)
    {
      nw_http3_fail_all_streams(*(void *)(v10 + 336), 261LL);
LABEL_73:
      v47 = 2;
      v9 = v125;
      goto LABEL_95;
    }

    v123 = v16;
    objectb = *(nw_protocol_metadata **)(v10 + 400);
    v120 = v12;
    uint64_t v54 = nw_frame_is_metadata_complete(a2);
    nw_frame_set_metadata(a2, objectb, 1, v54);
    if ((*(_WORD *)(v10 + 736) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        objecta = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(objecta, OS_LOG_TYPE_DEBUG))
        {
          v111 = v19 == 0;
          if (v19) {
            v112 = "";
          }
          else {
            v112 = (const char *)(v10 + 636);
          }
          if (v111) {
            v113 = " ";
          }
          else {
            v113 = "";
          }
          v115 = *(_DWORD *)(*(void *)(v10 + 336) + 1280LL);
          v116 = *(void *)(v10 + 240);
          v114 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v112;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&_BYTE buf[24] = v113;
          v20 = &qword_18C45F000;
          LOWORD(v130) = 1024;
          *(_DWORD *)((char *)&v130 + 2) = v115;
          HIWORD(v130) = 2048;
          v131 = v116;
          v132 = 1024;
          *(_DWORD *)v133 = v114;
          _os_log_impl( &dword_181A5C000,  objecta,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> received %u data bytes",  buf,  0x36u);
        }
      }
    }

    *(void *)(a2 + 32) = 0LL;
    v55 = *(uint64_t **)(v15 + 8);
    *(void *)(a2 + 40) = v55;
    *v55 = a2;
    *(void *)(v15 + 8) = v7;
    ++*v17;
    v9 = v125;
    if (v18)
    {
      nw_http_transaction_metadata_increment_inbound_body_transfer_size(*(void **)(v10 + 392), v120 + v123);
      nw::http::content_length_manager::increment_inbound_body_size( (nw::http::content_length_manager *)(v10 + 272),  v120);
      v9 = v125;
    }

    goto LABEL_94;
  }

  int v28 = v9;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v29 = *(_DWORD *)(v10 + 372);
  *(_DWORD *)buf = 136446466;
  *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
  *(_WORD *)&buf[12] = 1024;
  *(_DWORD *)&buf[14] = v29;
  v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v127 = 0;
  if (__nwlog_fault(v30, &type, &v127))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (os_log_s *)gLogObj;
      os_log_type_t v32 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v33 = *(_DWORD *)(v10 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v33;
        v34 = "%{public}s Unexpected input state %d";
LABEL_64:
        _os_log_impl(&dword_181A5C000, v31, v32, v34, buf, 0x12u);
      }
    }

    else if (v127)
    {
      v35 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (os_log_s *)gLogObj;
      os_log_type_t v32 = type;
      os_log_type_t v36 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v35)
      {
        if (v36)
        {
          v37 = *(_DWORD *)(v10 + 372);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v37;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v35;
          _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s Unexpected input state %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v35);
        v20 = &qword_18C45F000;
        goto LABEL_65;
      }

      v20 = &qword_18C45F000;
      if (v36)
      {
        uint64_t v57 = *(_DWORD *)(v10 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v57;
        v34 = "%{public}s Unexpected input state %d, no backtrace";
        goto LABEL_64;
      }
    }

    else
    {
      v31 = (os_log_s *)__nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        BOOL v41 = *(_DWORD *)(v10 + 372);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_frame_received";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v41;
        v34 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
        goto LABEL_64;
      }
    }
  }

          if (v48) {
            free(v48);
          }
          LODWORD(v21) = v88;
LABEL_90:
          v59 = *(_DWORD *)(v18 + 184);
          *(_DWORD *)(v18 + 184) = v59 + v41;
          if (!__OFADD__(v59, v41)) {
            goto LABEL_111;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v60 = (char *)v41;
          char v61 = *(int *)(v18 + 184);
          *(_DWORD *)buf = 136446978;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v94 = 2082;
          v95 = "stream->window_remaining";
          v96 = 2048;
          v97 = (char *)v41;
          v98 = 2048;
          *(void *)v99 = v61;
          os_log_type_t v62 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v90 = 0;
          if (__nwlog_fault(v62, &type, &v90))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v63 = (os_log_s *)gLogObj;
              char v64 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                v65 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136446978;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = "stream->window_remaining";
                v96 = 2048;
                v97 = v60;
                v98 = 2048;
                *(void *)v99 = v65;
                v66 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_107:
                _os_log_impl(&dword_181A5C000, v63, v64, v66, buf, 0x2Au);
              }
            }

            else if (v90)
            {
              v89 = (int)v21;
              v21 = (char *)__nw_create_backtrace_string();
              v63 = (os_log_s *)__nwlog_obj();
              char v64 = type;
              v67 = os_log_type_enabled(v63, type);
              if (v21)
              {
                if (v67)
                {
                  v68 = *(int *)(v18 + 184);
                  *(_DWORD *)buf = 136447234;
                  v93 = "nw_protocol_http2_frame_input_finalizer";
                  v94 = 2082;
                  v95 = "stream->window_remaining";
                  v96 = 2048;
                  v97 = v60;
                  v98 = 2048;
                  *(void *)v99 = v68;
                  *(_WORD *)&v99[8] = 2082;
                  *(void *)&v99[10] = v21;
                  _os_log_impl( &dword_181A5C000,  v63,  v64,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v21);
                LODWORD(v21) = v89;
                goto LABEL_108;
              }

              LODWORD(v21) = v89;
              if (v67)
              {
                v71 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136446978;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = "stream->window_remaining";
                v96 = 2048;
                v97 = v60;
                v98 = 2048;
                *(void *)v99 = v71;
                v66 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_107;
              }
            }

            else
            {
              v63 = (os_log_s *)__nwlog_obj();
              char v64 = type;
              if (os_log_type_enabled(v63, type))
              {
                uint64_t v69 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136446978;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = "stream->window_remaining";
                v96 = 2048;
                v97 = v60;
                v98 = 2048;
                *(void *)v99 = v69;
                v66 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_107;
              }
            }
          }

    if (!v26)
    {
LABEL_89:
      int v16 = 0LL;
      goto LABEL_20;
    }

                  _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0x1Cu);
                  goto LABEL_88;
                }

                nw_channel_handle_defunct(v1);
              }
            }
          }

LABEL_85:
            if (v34) {
              free(v34);
            }
            goto LABEL_87;
          }

          if (!gLogDatapath)
          {
            int v16 = 1;
            goto LABEL_27;
          }

          __nwlog_obj();
          v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            v45 = nw_endpoint_get_logging_description(v8);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v45;
            _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %s has active protocol registrars",  buf,  0x16u);
          }

          int v16 = 1;
        }

        else
        {
          int v16 = 0;
          v17 = (os_log_s *)v8;
        }

        goto LABEL_27;
      }

      v13 = nw_endpoint_get_logging_description(v8);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v13;
      __int16 v12 = "%{public}s endpoint %s has nothing to cleanup, no protocol instance registrars";
    }

    _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, v12, buf, 0x16u);
    goto LABEL_19;
  }

  __nwlog_obj();
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
  v30 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v63[0] = 0;
  if (__nwlog_fault(v30, type, v63))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v63[0])
    {
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type[0];
      BOOL v41 = os_log_type_enabled(v31, type[0]);
      if (v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v39;
          _os_log_impl( &dword_181A5C000,  v31,  v40,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v39);
        goto LABEL_79;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_181A5C000, v31, v40, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
        _os_log_impl( &dword_181A5C000,  v31,  v52,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    goto LABEL_86;
  }

  if (!v6)
  {
    __nwlog_obj();
    int v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_transform_append_protocol";
    v25 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl(&dword_181A5C000, v26, v29, "%{public}s called with null protocol_parameters", buf, 0xCu);
      }

      goto LABEL_85;
    }

    if (!v43)
    {
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v39 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl( &dword_181A5C000,  v26,  v39,  "%{public}s called with null protocol_parameters, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_85;
    }

    v33 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v34 = type;
    v35 = os_log_type_enabled(v26, type);
    if (!v33)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_protocol_transform_append_protocol";
        _os_log_impl( &dword_181A5C000,  v26,  v34,  "%{public}s called with null protocol_parameters, no backtrace",  buf,  0xCu);
      }

      goto LABEL_85;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_transform_append_protocol";
      v47 = 2082;
      *(void *)v48 = v33;
      _os_log_impl( &dword_181A5C000,  v26,  v34,  "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_72;
  }

  char v8 = (void *)v5[7];
  if (!v8)
  {
    v9 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
    if (v9)
    {
      options = nw_protocol_create_options((void *)g_ip_definition);
      internet_protocol = v9->internet_protocol;
      v9->internet_protocol = (OS_nw_protocol_options *)options;
    }

    __int16 v12 = (void *)v5[7];
    v5[7] = v9;

    char v8 = (void *)v5[7];
    if (!v8)
    {
      __nwlog_obj();
      os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_transform_append_protocol";
      v25 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v43 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v46 = "nw_protocol_transform_append_protocol";
          _os_log_impl(&dword_181A5C000, v26, v37, "%{public}s called with null transform->transform_stack", buf, 0xCu);
        }

        goto LABEL_85;
      }

      if (!v43)
      {
        __nwlog_obj();
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v46 = "nw_protocol_transform_append_protocol";
          _os_log_impl( &dword_181A5C000,  v26,  v42,  "%{public}s called with null transform->transform_stack, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_85;
      }

      v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      BOOL v41 = os_log_type_enabled(v26, type);
      if (!v33)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v46 = "nw_protocol_transform_append_protocol";
          _os_log_impl( &dword_181A5C000,  v26,  v40,  "%{public}s called with null transform->transform_stack, no backtrace",  buf,  0xCu);
        }

        goto LABEL_85;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        v46 = "nw_protocol_transform_append_protocol";
        v47 = 2082;
        *(void *)v48 = v33;
        _os_log_impl( &dword_181A5C000,  v26,  v40,  "%{public}s called with null transform->transform_stack, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    BOOL v27 = 1LL;
    goto LABEL_86;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v26 = off_189BBBBC0[v12];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_transform_receive_report";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v26;
    *(_WORD *)&buf[22] = 2082;
    v143 = "transform";
    _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_18:
  BOOL v27 = 0LL;
LABEL_86:

  return v27;
}

        goto LABEL_86;
      }

      if (!v54)
      {
        __nwlog_obj();
        v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v52 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
          _os_log_impl( &dword_181A5C000,  v42,  v52,  "%{public}s called with null addr, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_85;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v49 = type;
      v50 = os_log_type_enabled(v42, type);
      if (!backtrace_string)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
          _os_log_impl(&dword_181A5C000, v42, v49, "%{public}s called with null addr, no backtrace", buf, 0xCu);
        }

        goto LABEL_85;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v42,  v49,  "%{public}s called with null addr, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_73;
    }

    goto LABEL_86;
  }

  v9 = v7;
  v10 = [v9 type];

  if (v10 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v16 = (id)gLogObj;
    v17 = v9;
    v18 = [v17 type];

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v18;
    LODWORD(v53) = 18;
    v19 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v54 = 0;
    if (__nwlog_fault(v19, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (os_log_s *)(id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          uint64_t v22 = v17;
          uint64_t v23 = objc_msgSend(v22, "type", buf, v53);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v23;
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v54)
      {
        v24 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (os_log_s *)(id)gLogObj;
        v25 = type;
        uint64_t v26 = os_log_type_enabled(v20, type);
        if (v24)
        {
          if (v26)
          {
            BOOL v27 = v17;
            int v28 = objc_msgSend(v27, "type", buf, v53);

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v28;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v24;
            _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v24);
          if (!v19) {
            goto LABEL_52;
          }
LABEL_50:
          v38 = (char *)v19;
LABEL_51:
          free(v38);
          goto LABEL_52;
        }

        if (v26)
        {
          os_log_type_t v36 = v17;
          v37 = objc_msgSend(v36, "type", buf, v53);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v37;
          _os_log_impl(&dword_181A5C000, v20, v25, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (os_log_s *)(id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v20, type))
        {
          v34 = v17;
          v35 = objc_msgSend(v34, "type", buf, v53);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_address_endpoint_matches_address";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v35;
          _os_log_impl( &dword_181A5C000,  v20,  v33,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v19)
    {
LABEL_52:
      os_log_type_t v32 = 0LL;
      goto LABEL_53;
    }

    goto LABEL_50;
  }

  v11 = (char *)v9;
  __int16 v12 = v11;
  if (a4)
  {
    v13 = v11;
    uint64_t v14 = v13[2];

    if (v14) {
      BOOL v15 = v14[2];
    }
    else {
      BOOL v15 = 0;
    }
  }

  else
  {
    BOOL v15 = 0;
  }

  if (a2[1] == 30)
  {
    v29 = *a2;
    if (v29 == 28)
    {
      v30 = v12 + 232;
      if (v12[233] == 2 && !*((_DWORD *)a2 + 2) && !*((_DWORD *)a2 + 3) && *((_DWORD *)a2 + 4) == -65536)
      {
        *(_WORD *)buf = 528;
        *(_WORD *)&buf[2] = *((_WORD *)a2 + 1);
        *(_DWORD *)&uint8_t buf[4] = *((_DWORD *)a2 + 5);
        *(void *)&buf[8] = 0LL;
        if (*v30 != 16) {
          goto LABEL_38;
        }
        if (*(void *)v30 != *(void *)buf || *((void *)v12 + 30) != *(void *)&buf[8]) {
          goto LABEL_38;
        }
LABEL_40:
        if (v15 == a3) {
          os_log_type_t v32 = 1LL;
        }
        else {
          os_log_type_t v32 = a4 ^ 1u;
        }
        goto LABEL_39;
      }

      v29 = 28;
    }
  }

  else
  {
    v29 = *a2;
  }

        os_log_type_t v62 = (char *)v31;
LABEL_86:
        free(v62);
        goto LABEL_87;
      }

      v50 = v33 - 1;
      v29 = (char *)malloc(v33 - 1);
      if (v29) {
        goto LABEL_51;
      }
      __nwlog_obj();
      v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136446466;
      v91 = "strict_malloc";
      v92 = 2048;
      v93[0] = v50;
      v73 = (void *)_os_log_send_and_compose_impl();

      result = (char *)__nwlog_abort((uint64_t)v73);
      if (!(_DWORD)result)
      {
        free(v73);
LABEL_51:
        memcpy(v29, (char *)v5 + 234, v34);
        v29[v34] = 0;
        goto LABEL_88;
      }

      goto LABEL_109;
    case 2:
    case 18:
    case 30:
      int v7 = getnameinfo( (const sockaddr *)((char *)v5 + 232),  *((unsigned __int8 *)v5 + 232),  (char *)v90,  0x46u,  0LL,  0,  2);
      if (v7)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v8 = (id)gLogObj;
        v9 = *((unsigned __int8 *)v5 + 232);
        v10 = gai_strerror(v7);
        *(_DWORD *)buf = 136447235;
        v79 = "nw_endpoint_copy_address_string";
        v80 = 1040;
        v81 = v9;
        v82 = 2101;
        v83 = (char *)v5 + 232;
        v84 = 1024;
        v85 = v7;
        v86 = 2082;
        v87 = v10;
        v11 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v76 = 0;
        if (__nwlog_fault(v11, &type, &v76))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v12 = (os_log_s *)(id)gLogObj;
            v13 = type;
            if (os_log_type_enabled(v12, type))
            {
              uint64_t v14 = *((unsigned __int8 *)v5 + 232);
              BOOL v15 = gai_strerror(v7);
              *(_DWORD *)buf = 136447235;
              v79 = "nw_endpoint_copy_address_string";
              v80 = 1040;
              v81 = v14;
              v82 = 2101;
              v83 = (char *)v5 + 232;
              v84 = 1024;
              v85 = v7;
              v86 = 2082;
              v87 = v15;
              _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s getnameinfo(%{sensitive}.*P}): [%d] %{public}s failed",  buf,  0x2Cu);
            }
          }

          else if (v76)
          {
            BOOL v44 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v12 = (os_log_s *)(id)gLogObj;
            v45 = type;
            v46 = os_log_type_enabled(v12, type);
            if (v44)
            {
              if (v46)
              {
                v75 = *((unsigned __int8 *)v5 + 232);
                v47 = gai_strerror(v7);
                *(_DWORD *)buf = 136447491;
                v79 = "nw_endpoint_copy_address_string";
                v80 = 1040;
                v81 = v75;
                v82 = 2101;
                v83 = (char *)v5 + 232;
                v84 = 1024;
                v85 = v7;
                v86 = 2082;
                v87 = v47;
                v88 = 2082;
                v89 = v44;
                _os_log_impl( &dword_181A5C000,  v12,  v45,  "%{public}s getnameinfo(%{sensitive}.*P}): [%d] %{public}s failed, dumping backtrace:%{public}s",  buf,  0x36u);
              }

              free(v44);
              if (!v11) {
                goto LABEL_87;
              }
LABEL_71:
              os_log_type_t v62 = (char *)v11;
              goto LABEL_86;
            }

            if (v46)
            {
              v60 = *((unsigned __int8 *)v5 + 232);
              char v61 = gai_strerror(v7);
              *(_DWORD *)buf = 136447235;
              v79 = "nw_endpoint_copy_address_string";
              v80 = 1040;
              v81 = v60;
              v82 = 2101;
              v83 = (char *)v5 + 232;
              v84 = 1024;
              v85 = v7;
              v86 = 2082;
              v87 = v61;
              _os_log_impl( &dword_181A5C000,  v12,  v45,  "%{public}s getnameinfo(%{sensitive}.*P}): [%d] %{public}s failed, no backtrace",  buf,  0x2Cu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v12 = (os_log_s *)(id)gLogObj;
            uint64_t v54 = type;
            if (os_log_type_enabled(v12, type))
            {
              v55 = *((unsigned __int8 *)v5 + 232);
              v56 = gai_strerror(v7);
              *(_DWORD *)buf = 136447235;
              v79 = "nw_endpoint_copy_address_string";
              v80 = 1040;
              v81 = v55;
              v82 = 2101;
              v83 = (char *)v5 + 232;
              v84 = 1024;
              v85 = v7;
              v86 = 2082;
              v87 = v56;
              _os_log_impl( &dword_181A5C000,  v12,  v54,  "%{public}s getnameinfo(%{sensitive}.*P}): [%d] %{public}s failed, backtrace limit exceeded",  buf,  0x2Cu);
            }
          }
        }

        if (!v11) {
          goto LABEL_87;
        }
        goto LABEL_71;
      }

      v29 = strdup((const char *)v90);
      if (v29) {
        goto LABEL_88;
      }
      __nwlog_obj();
      v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v79 = "strict_strdup";
      v31 = (const char *)_os_log_send_and_compose_impl();

      result = (char *)__nwlog_abort((uint64_t)v31);
      if (!(_DWORD)result) {
        goto LABEL_85;
      }
LABEL_109:
      __break(1u);
      return result;
    default:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v38 = (id)gLogObj;
      *(_DWORD *)v90 = 136446466;
      v91 = "nw_endpoint_copy_address_string";
      v92 = 1024;
      LODWORD(v93[0]) = address_family;
      v31 = (const char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v39 = (os_log_s *)(id)gLogObj;
        os_log_type_t v40 = buf[0];
        if (os_log_type_enabled(v39, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v90 = 136446466;
          v91 = "nw_endpoint_copy_address_string";
          v92 = 1024;
          LODWORD(v93[0]) = address_family;
          _os_log_impl(&dword_181A5C000, v39, v40, "%{public}s endpoint has unknown address family %d", v90, 0x12u);
        }
      }

      else if (type)
      {
        v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v52 = buf[0];
        os_log_type_t v53 = os_log_type_enabled(v39, (os_log_type_t)buf[0]);
        if (v51)
        {
          if (v53)
          {
            *(_DWORD *)v90 = 136446722;
            v91 = "nw_endpoint_copy_address_string";
            v92 = 1024;
            LODWORD(v93[0]) = address_family;
            WORD2(v93[0]) = 2082;
            *(void *)((char *)v93 + 6) = v51;
            _os_log_impl( &dword_181A5C000,  v39,  v52,  "%{public}s endpoint has unknown address family %d, dumping backtrace:%{public}s",  v90,  0x1Cu);
          }

          free(v51);
          if (!v31) {
            goto LABEL_87;
          }
          goto LABEL_85;
        }

        if (v53)
        {
          *(_DWORD *)v90 = 136446466;
          v91 = "nw_endpoint_copy_address_string";
          v92 = 1024;
          LODWORD(v93[0]) = address_family;
          _os_log_impl( &dword_181A5C000,  v39,  v52,  "%{public}s endpoint has unknown address family %d, no backtrace",  v90,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v63 = buf[0];
        if (os_log_type_enabled(v39, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v90 = 136446466;
          v91 = "nw_endpoint_copy_address_string";
          v92 = 1024;
          LODWORD(v93[0]) = address_family;
          _os_log_impl( &dword_181A5C000,  v39,  v63,  "%{public}s endpoint has unknown address family %d, backtrace limit exceeded",  v90,  0x12u);
        }
      }

      goto LABEL_84;
  }

  if (!a5) {
    goto LABEL_86;
  }
  return v12;
}

        v89 = 2;
        goto LABEL_87;
      }

      free(v40);
      goto LABEL_86;
    }

    free(v47);
    if (!v38) {
      goto LABEL_130;
    }
    goto LABEL_121;
  }

    if (v15) {
      free(v15);
    }
    goto LABEL_87;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
  v10 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v57[0]) = 0;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!LOBYTE(v57[0]))
    {
      v11 = (os_log_s *)__nwlog_obj();
      __int16 v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null frames, backtrace limit exceeded";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = (os_log_s *)__nwlog_obj();
    __int16 v12 = type[0];
    v24 = os_log_type_enabled(v11, type[0]);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null frames, no backtrace";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      v21 = "%{public}s called with null frames, dumping backtrace:%{public}s";
      goto LABEL_53;
    }

        v9 = 0LL;
        goto LABEL_30;
      }

      __nwlog_obj();
      BOOL v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v43 = "nw_framer_protocol_copy_info";
      v24 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v40 = 0;
      if (!__nwlog_fault((const char *)v24, &type, &v40))
      {
LABEL_83:
        if (v24) {
          free(v24);
        }
        goto LABEL_85;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v28 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v43 = "nw_framer_protocol_copy_info";
          _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s called with null framer->parent_definition", buf, 0xCu);
        }
}

  if (v26) {
    free(v26);
  }
  return 0LL;
}

  if (v26) {
    free(v26);
  }
  return 0LL;
}

  if (v26) {
    free(v26);
  }
  return 0LL;
}

  if (v26) {
    free(v26);
  }
  return 0LL;
}

  if (v26) {
    free(v26);
  }
  return 0LL;
}

LABEL_86:
        if (!v18)
        {
LABEL_88:
          uint64_t v26 = 0LL;
          goto LABEL_111;
        }

                  if (!v45) {
                    goto LABEL_42;
                  }
LABEL_86:
                  free(v45);
                  goto LABEL_42;
                }
              }

              __nwlog_obj();
              v63 = (void *)objc_claimAutoreleasedReturnValue();
              char v64 = default_input_handler->identifier->name;
              *(_DWORD *)buf = 136446722;
              v135 = "__nw_protocol_connected";
              if (!v64) {
                char v64 = "invalid";
              }
              v136 = 2082;
              v137 = (void *)v64;
              v138 = 2048;
              v139 = (const char *)default_input_handler;
              v124 = (const char *)_os_log_send_and_compose_impl();

              v131 = OS_LOG_TYPE_ERROR;
              v128 = 0;
              v65 = (char *)v124;
              if (!__nwlog_fault(v124, &v131, &v128))
              {
LABEL_209:
                if (v65) {
                  free(v65);
                }
                goto LABEL_37;
              }

              if (v131 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v67 = v131;
                if (os_log_type_enabled(v66, v131))
                {
                  v68 = default_input_handler->identifier->name;
                  if (!v68) {
                    v68 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v135 = "__nw_protocol_connected";
                  v136 = 2082;
                  v137 = (void *)v68;
                  v138 = 2048;
                  v139 = (const char *)default_input_handler;
                  _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s protocol %{public}s (%p) has invalid connected callback",  buf,  0x20u);
                }
              }

              else if (v128)
              {
                v87 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v123 = v131;
                v88 = os_log_type_enabled(v66, v131);
                if (v87)
                {
                  if (v88)
                  {
                    v89 = default_input_handler->identifier->name;
                    if (!v89) {
                      v89 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    v135 = "__nw_protocol_connected";
                    v136 = 2082;
                    v137 = (void *)v89;
                    v138 = 2048;
                    v139 = (const char *)default_input_handler;
                    v140 = 2082;
                    v141 = v87;
                    _os_log_impl( &dword_181A5C000,  v66,  v123,  "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                  }

                  free(v87);
                  goto LABEL_208;
                }

                if (v88)
                {
                  v108 = default_input_handler->identifier->name;
                  if (!v108) {
                    v108 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v135 = "__nw_protocol_connected";
                  v136 = 2082;
                  v137 = (void *)v108;
                  v138 = 2048;
                  v139 = (const char *)default_input_handler;
                  _os_log_impl( &dword_181A5C000,  v66,  v123,  "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace",  buf,  0x20u);
                }
              }

              else
              {
                __nwlog_obj();
                v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v106 = v131;
                if (os_log_type_enabled(v66, v131))
                {
                  v107 = default_input_handler->identifier->name;
                  if (!v107) {
                    v107 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v135 = "__nw_protocol_connected";
                  v136 = 2082;
                  v137 = (void *)v107;
                  v138 = 2048;
                  v139 = (const char *)default_input_handler;
                  _os_log_impl( &dword_181A5C000,  v66,  v106,  "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded",  buf,  0x20u);
                }
              }

LABEL_208:
              v65 = (char *)v124;
              goto LABEL_209;
            }

            __nwlog_obj();
            v83 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v135 = "__nw_protocol_connected";
            v84 = (char *)_os_log_send_and_compose_impl();

            v129[0] = OS_LOG_TYPE_ERROR;
            v131 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v84, v129, &v131))
            {
              if (v129[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v86 = v129[0];
                if (os_log_type_enabled(v85, v129[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v135 = "__nw_protocol_connected";
                  _os_log_impl(&dword_181A5C000, v85, v86, "%{public}s called with null other_protocol", buf, 0xCu);
                }
              }

              else if (v131)
              {
                v93 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v94 = v129[0];
                v95 = os_log_type_enabled(v85, v129[0]);
                if (v93)
                {
                  if (v95)
                  {
                    *(_DWORD *)buf = 136446466;
                    v135 = "__nw_protocol_connected";
                    v136 = 2082;
                    v137 = v93;
                    _os_log_impl( &dword_181A5C000,  v85,  v94,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v93);
                  goto LABEL_237;
                }

                if (v95)
                {
                  *(_DWORD *)buf = 136446210;
                  v135 = "__nw_protocol_connected";
                  _os_log_impl( &dword_181A5C000,  v85,  v94,  "%{public}s called with null other_protocol, no backtrace",  buf,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v112 = v129[0];
                if (os_log_type_enabled(v85, v129[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v135 = "__nw_protocol_connected";
                  _os_log_impl( &dword_181A5C000,  v85,  v112,  "%{public}s called with null other_protocol, backtrace limit exceeded",  buf,  0xCu);
                }
              }
            }

            CFRelease(v17);
            goto LABEL_86;
          }

          goto LABEL_84;
        }

        __nwlog_obj();
        *(_DWORD *)os_log_type_t type = 136446210;
        *(void *)&type[4] = "nw_http_authentication_copy_pat_timestamps_array";
        v31 = (char *)_os_log_send_and_compose_impl();
        v64[0] = 16;
        v56 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v31, v64, &v56))
        {
          if (v64[0] == 17)
          {
            os_log_type_t v32 = (os_log_s *)__nwlog_obj();
            v33 = v64[0];
            if (!os_log_type_enabled(v32, (os_log_type_t)v64[0])) {
              goto LABEL_67;
            }
            *(_DWORD *)os_log_type_t type = 136446210;
            *(void *)&type[4] = "nw_http_authentication_copy_pat_timestamps_array";
            v34 = "%{public}s called with null http_authentication";
            goto LABEL_66;
          }

          if (v56 == OS_LOG_TYPE_DEFAULT)
          {
            os_log_type_t v32 = (os_log_s *)__nwlog_obj();
            v33 = v64[0];
            if (!os_log_type_enabled(v32, (os_log_type_t)v64[0])) {
              goto LABEL_67;
            }
            *(_DWORD *)os_log_type_t type = 136446210;
            *(void *)&type[4] = "nw_http_authentication_copy_pat_timestamps_array";
            v34 = "%{public}s called with null http_authentication, backtrace limit exceeded";
            goto LABEL_66;
          }

          v37 = (char *)__nw_create_backtrace_string();
          os_log_type_t v32 = (os_log_s *)__nwlog_obj();
          v33 = v64[0];
          v38 = os_log_type_enabled(v32, (os_log_type_t)v64[0]);
          if (v37)
          {
            if (v38)
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              *(void *)&type[4] = "nw_http_authentication_copy_pat_timestamps_array";
              *(_WORD *)&type[12] = 2082;
              *(void *)&type[14] = v37;
              _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null http_authentication, dumping backtrace:%{public}s",  type,  0x16u);
            }

            free(v37);
            goto LABEL_67;
          }

          if (v38)
          {
            *(_DWORD *)os_log_type_t type = 136446210;
            *(void *)&type[4] = "nw_http_authentication_copy_pat_timestamps_array";
            v34 = "%{public}s called with null http_authentication, no backtrace";
LABEL_66:
            _os_log_impl(&dword_181A5C000, v32, v33, v34, type, 0xCu);
          }
        }

LABEL_59:
      if (v15) {
        free(v15);
      }
      return 0LL;
    }

    if (!v43)
    {
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v42 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "-[NWConcrete_nw_ids_info initWithSessionId:pseudonym:pushToken:]";
        _os_log_impl(&dword_181A5C000, v22, v42, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_85;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v37 = type;
    v38 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "-[NWConcrete_nw_ids_info initWithSessionId:pseudonym:pushToken:]";
        _os_log_impl(&dword_181A5C000, v22, v37, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }

      goto LABEL_85;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      v47 = "-[NWConcrete_nw_ids_info initWithSessionId:pseudonym:pushToken:]";
      v48 = 2082;
      v49 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v22,  v37,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_58:
    free(backtrace_string);
    goto LABEL_59;
  }

  v10 = strdup(a1);
  if (!v10)
  {
    __nwlog_obj();
    v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v47 = "strict_strdup";
    v25 = (void *)_os_log_send_and_compose_impl();

    result = (id)__nwlog_abort((uint64_t)v25);
    if ((_DWORD)result) {
      goto LABEL_86;
    }
    free(v25);
  }

  v9[1] = v10;
  v11 = strdup(a2);
  if (v11)
  {
LABEL_10:
    v9[2] = v11;
    __int16 v12 = strdup(a3);
    if (v12)
    {
LABEL_11:
      v9[3] = v12;
      return v9;
    }

    __nwlog_obj();
    int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v47 = "strict_strdup";
    v29 = (void *)_os_log_send_and_compose_impl();

    result = (id)__nwlog_abort((uint64_t)v29);
    if (!(_DWORD)result)
    {
      free(v29);
      goto LABEL_11;
    }

    goto LABEL_86;
  }

  __nwlog_obj();
  uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v47 = "strict_strdup";
  BOOL v27 = (void *)_os_log_send_and_compose_impl();

  result = (id)__nwlog_abort((uint64_t)v27);
  if (!(_DWORD)result)
  {
    free(v27);
    goto LABEL_10;
  }

              if (!v35)
              {
LABEL_87:
                v33 = 0LL;
LABEL_155:

                v89 = v146;
                goto LABEL_156;
              }

      goto LABEL_86;
    }

    if (!v55)
    {
      __nwlog_obj();
      os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nwphRunProbe";
        v34 = "%{public}s called with null label, backtrace limit exceeded";
        goto LABEL_84;
      }

      goto LABEL_85;
    }

    BOOL v44 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v33 = type;
    v47 = os_log_type_enabled(v32, type);
    if (!v44)
    {
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nwphRunProbe";
        v34 = "%{public}s called with null label, no backtrace";
        goto LABEL_84;
      }

      goto LABEL_85;
    }

    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nwphRunProbe";
      v59 = 2082;
      v60 = v44;
      v46 = "%{public}s called with null label, dumping backtrace:%{public}s";
      goto LABEL_62;
    }

    goto LABEL_63;
  }

  if (v11)
  {
    [MEMORY[0x189601F00] ephemeralSessionConfiguration];
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    [v13 setHTTPCookieStorage:0];
    [v13 setURLCache:0];
    if (a2) {
      objc_msgSend(v13, "set_allowsTLSECH:", 1);
    }
    [MEMORY[0x189601EF8] sessionWithConfiguration:v13];
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    [MEMORY[0x189604030] URLWithString:v9];
    BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
    if (v15)
    {
      int v16 = nw_activity_create(40, a4);
      nw_activity_set_parent_activity(v16, v10);
      nw_activity_activate(v16);
      v51[0] = MEMORY[0x1895F87A8];
      v51[1] = 3221225472LL;
      v51[2] = __nwphRunProbe_block_invoke;
      v51[3] = &unk_189BB93D0;
      v17 = v16;
      os_log_type_t v52 = v17;
      uint64_t v54 = v12;
      os_log_type_t v53 = v14;
      [v53 dataTaskWithURL:v15 completionHandler:v51];
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v18, "set_nw_activity:", v17);
      [v18 resume];
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v58 = "nwphRunProbe";
        v59 = 2112;
        v60 = v9;
        _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, "%{public}s started probe to %@", buf, 0x16u);
      }

      goto LABEL_23;
    }

    v50 = v10;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    uint64_t v58 = "nwphRunProbe";
    v59 = 2112;
    v60 = v9;
    v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (__nwlog_fault(v21, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        uint64_t v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v58 = "nwphRunProbe";
        v59 = 2112;
        v60 = v9;
        v24 = "%{public}s URLWithString %@ failed";
LABEL_27:
        int v28 = v22;
        v29 = v23;
        goto LABEL_28;
      }

      if (!v55)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        uint64_t v23 = type;
        if (!os_log_type_enabled(v22, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v58 = "nwphRunProbe";
        v59 = 2112;
        v60 = v9;
        v24 = "%{public}s URLWithString %@ failed, backtrace limit exceeded";
        goto LABEL_27;
      }

      v25 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (os_log_s *)(id)gLogObj;
      uint64_t v26 = type;
      BOOL v27 = os_log_type_enabled(v22, type);
      if (!v25)
      {
        if (!v27)
        {
LABEL_29:

          if (!v21) {
            goto LABEL_22;
          }
          goto LABEL_21;
        }

        *(_DWORD *)buf = 136446466;
        uint64_t v58 = "nwphRunProbe";
        v59 = 2112;
        v60 = v9;
        v24 = "%{public}s URLWithString %@ failed, no backtrace";
        int v28 = v22;
        v29 = v26;
LABEL_28:
        _os_log_impl(&dword_181A5C000, v28, v29, v24, buf, 0x16u);
        goto LABEL_29;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v58 = "nwphRunProbe";
        v59 = 2112;
        v60 = v9;
        char v61 = 2082;
        os_log_type_t v62 = v25;
        _os_log_impl( &dword_181A5C000,  v22,  v26,  "%{public}s URLWithString %@ failed, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v25);
    }

    if (!v21)
    {
LABEL_22:
      v12[2](v12, 0LL);
      v10 = v50;
LABEL_23:

      goto LABEL_24;
    }

          free(v43);
          goto LABEL_86;
        }

        __nwlog_obj();
        v70 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v94 = "nw_read_request_create_with_buffer";
        v18 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v91 = 0;
        if (__nwlog_fault(v18, &type, &v91))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v72 = type;
            if (os_log_type_enabled(v71, type))
            {
              *(_DWORD *)buf = 136446210;
              v94 = "nw_read_request_create_with_buffer";
              _os_log_impl(&dword_181A5C000, v71, v72, "%{public}s called with null buffer", buf, 0xCu);
            }
      }

    if (!v22) {
      goto LABEL_87;
    }
    goto LABEL_86;
  }

  char v8 = v6;
  v9 = (os_unfair_lock_s *)(v8 + 28);
  os_unfair_lock_lock((os_unfair_lock_t)v8 + 28);
  v10 = *((id *)v8 + 8);
  os_unfair_lock_unlock((os_unfair_lock_t)v8 + 28);

  should_use_proxy = nw_endpoint_proxy_unsatisfied_handler_should_use_proxy(v10);
  if (!should_use_proxy)
  {
    if (nw_endpoint_handler_get_minimize_logging(v8))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v28 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v8);
        v81 = nw_endpoint_handler_dry_run_string(v8);
        v82 = nw_endpoint_handler_copy_endpoint(v8);
        logging_description = nw_endpoint_get_logging_description(v82);
        v84 = nw_endpoint_handler_state_string(v8);
        v85 = nw_endpoint_handler_mode_string(v8);
        v86 = nw_endpoint_handler_copy_current_path(v8);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = id_string;
        *(_WORD *)&buf[22] = 2082;
        v116 = v81;
        *(_WORD *)v117 = 2082;
        *(void *)&v117[2] = logging_description;
        *(_WORD *)&v117[10] = 2082;
        *(void *)&v117[12] = v84;
        v118 = 2082;
        v119 = v85;
        v120 = 2114;
        v121 = v86;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resetting due to disallowed proxy settings",  buf,  0x48u);
      }
    }

    else
    {
      uint64_t v26 = v8;
      BOOL v27 = *((_BYTE *)v26 + 268);

      if ((v27 & 0x20) != 0)
      {
LABEL_70:
        nw_endpoint_handler_reset_mode(v8, 1);
        goto LABEL_87;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v28 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
      {
        v29 = v26;

        v30 = v29;
        v31 = *((_BYTE *)v26 + 268);

        if ((v31 & 1) != 0) {
          os_log_type_t v32 = "dry-run ";
        }
        else {
          os_log_type_t v32 = "";
        }
        v33 = nw_endpoint_handler_copy_endpoint(v30);
        v107 = nw_endpoint_get_logging_description(v33);
        log = (os_log_t)v32;
        v34 = v29 + 168;
        v35 = v30;
        os_log_type_t v36 = v35;
        v37 = v35[30];
        else {
          v38 = off_189BBBBF0[v37];
        }

        v45 = v36;
        v46 = v45;
        v47 = v6[29];
        v48 = "path";
        switch(v47)
        {
          case 0u:
            break;
          case 1u:
            v48 = "resolver";
            break;
          case 2u:
            v48 = nw_endpoint_flow_mode_string(v45[31]);
            break;
          case 3u:
            v48 = "proxy";
            break;
          case 4u:
            v48 = "fallback";
            break;
          case 5u:
            v48 = "transform";
            break;
          default:
            v48 = "unknown-mode";
            break;
        }

        char v61 = v46;
        os_unfair_lock_lock(v9);
        os_log_type_t v62 = *((id *)v8 + 8);
        os_unfair_lock_unlock(v9);

        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v34;
        *(_WORD *)&buf[22] = 2082;
        v116 = (const char *)log;
        *(_WORD *)v117 = 2082;
        *(void *)&v117[2] = v107;
        *(_WORD *)&v117[10] = 2082;
        *(void *)&v117[12] = v38;
        v118 = 2082;
        v119 = v48;
        v120 = 2114;
        v121 = v62;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resetting due to disallowed proxy settings",  buf,  0x48u);
      }
    }

    goto LABEL_70;
  }

  if ((*((_BYTE *)self + 97) & 8) == 0 && (*((_BYTE *)self + 97) & 0x20) == 0 && !self->connected_child)
  {
    __int16 v12 = v8;
    os_unfair_lock_lock(v9);
    v13 = *((id *)v8 + 8);
    os_unfair_lock_unlock(v9);

    uint64_t v14 = nw_path_copy_proxy_configs(v13);
    if (v14)
    {
      BOOL v15 = self->path_proxy_configs;
      int v16 = (OS_nw_array *)v14;
      v17 = v16;
      if (v15 == v16)
      {

        goto LABEL_81;
      }

      if (!v15
        || (char *)v15[3].super.super.isa - (char *)v15[2].super.super.isa != (char *)v16[3].super.super.isa
                                                                            - (char *)v16[2].super.super.isa)
      {

        goto LABEL_72;
      }

      *(void *)os_log_type_t type = 0LL;
      v112 = type;
      v113 = 0x2020000000LL;
      v114 = 1;
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL35nw_endpoint_proxy_configs_are_equalPU22objcproto11OS_nw_array8NSObjectS1__block_invoke;
      v116 = (const char *)&unk_189BC7960;
      v18 = v16;
      *(void *)v117 = v18;
      *(void *)&v117[8] = type;
      nw_array_apply((unsigned __int8 *)v15, (uint64_t)buf);
      v19 = *((_BYTE *)v112 + 24) == 0;

      _Block_object_dispose(type, 8);
      if (v19)
      {
LABEL_72:
        v63 = v12;
        v63[66] = 0;

        v63[20] = 393220;
        nw_endpoint_handler_report(v63, 0LL, (_WORD *)v63 + 40, 0LL);
        minimize_logging = nw_endpoint_handler_get_minimize_logging(v63);
        logging_disabled = nw_endpoint_handler_get_logging_disabled(v63);
        if (minimize_logging)
        {
          if ((logging_disabled & 1) != 0) {
            goto LABEL_79;
          }
          v109 = v14;
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v94 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
          {
            logd = nw_endpoint_handler_get_id_string(v63);
            v101 = nw_endpoint_handler_dry_run_string(v63);
            v95 = nw_endpoint_handler_copy_endpoint(v63);
            v96 = nw_endpoint_get_logging_description(v95);
            v97 = nw_endpoint_handler_state_string(v63);
            v98 = nw_endpoint_handler_mode_string(v63);
            v99 = nw_endpoint_handler_copy_current_path(v63);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = logd;
            *(_WORD *)&buf[22] = 2082;
            v116 = v101;
            *(_WORD *)v117 = 2082;
            *(void *)&v117[2] = v96;
            *(_WORD *)&v117[10] = 2082;
            *(void *)&v117[12] = v97;
            v118 = 2082;
            v119 = v98;
            v120 = 2114;
            v121 = v99;
            v66 = v94;
            _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] restarting due to changin g proxy settings",  buf,  0x48u);

            uint64_t v14 = v109;
          }

          else
          {
            v66 = v94;
          }
        }

        else
        {
          if ((logging_disabled & 1) != 0)
          {
LABEL_79:
            v74 = v63;
            v74[30] = 1;

            -[NWConcrete_nw_endpoint_proxy cancelWithHandler:forced:](self, "cancelWithHandler:forced:", v74, 1LL);
            -[NWConcrete_nw_endpoint_proxy startWithHandler:](self, "startWithHandler:", v74);
            goto LABEL_81;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v66 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v66, OS_LOG_TYPE_INFO))
          {
            v67 = nw_endpoint_handler_get_id_string(v63);
            v68 = nw_endpoint_handler_dry_run_string(v63);
            logb = v66;
            v108 = v14;
            uint64_t v69 = v67;
            v100 = nw_endpoint_handler_copy_endpoint(v63);
            v70 = nw_endpoint_get_logging_description(v100);
            v71 = nw_endpoint_handler_state_string(v63);
            v72 = nw_endpoint_handler_mode_string(v63);
            v73 = nw_endpoint_handler_copy_current_path(v63);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v69;
            *(_WORD *)&buf[22] = 2082;
            v116 = v68;
            *(_WORD *)v117 = 2082;
            *(void *)&v117[2] = v70;
            *(_WORD *)&v117[10] = 2082;
            *(void *)&v117[12] = v71;
            v118 = 2082;
            v119 = v72;
            v120 = 2114;
            v121 = v73;
            v66 = logb;
            _os_log_impl( &dword_181A5C000,  logb,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] restarting due to changin g proxy settings",  buf,  0x48u);

            uint64_t v14 = v108;
          }
        }

        goto LABEL_79;
      }

  if (v18) {
    free(v18);
  }
LABEL_10:
  if (gLogDatapath)
  {
    uint64_t v22 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_master_frame_array";
      _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  *(void *)buf = v2;
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33155;
  v48 = (const char *)&__block_descriptor_tmp_56_33156;
  v49 = 0;
  char v6 = *(void *)(v1 + 576);
  do
  {
    if (!v6) {
      break;
    }
    int v7 = *(void *)(v6 + 16);
    char v8 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    char v6 = v7;
  }

  while ((v8 & 1) != 0);
  if (*(void *)(v1 + 576))
  {
    __nwlog_obj();
    *(_DWORD *)os_log_type_t v43 = 136446210;
    BOOL v44 = "nw_protocol_finalize_master_frame_array";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = (os_log_s *)__nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)os_log_type_t v43 = 136446210;
      BOOL v44 = "nw_protocol_finalize_master_frame_array";
      uint64_t v26 = "%{public}s frame array is not empty after finalize";
    }

    else if (v41)
    {
      v37 = (char *)__nw_create_backtrace_string();
      v24 = (os_log_s *)__nwlog_obj();
      v25 = type;
      v38 = os_log_type_enabled(v24, type);
      if (v37)
      {
        if (v38)
        {
          *(_DWORD *)os_log_type_t v43 = 136446466;
          BOOL v44 = "nw_protocol_finalize_master_frame_array";
          v45 = 2082;
          v46 = v37;
          _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s",  v43,  0x16u);
        }

        free(v37);
        goto LABEL_90;
      }

      if (!v38)
      {
LABEL_90:
        if (v23) {
          free(v23);
        }
        goto LABEL_15;
      }

      *(_DWORD *)os_log_type_t v43 = 136446210;
      BOOL v44 = "nw_protocol_finalize_master_frame_array";
      uint64_t v26 = "%{public}s frame array is not empty after finalize, no backtrace";
    }

    else
    {
      v24 = (os_log_s *)__nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)os_log_type_t v43 = 136446210;
      BOOL v44 = "nw_protocol_finalize_master_frame_array";
      uint64_t v26 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v24, v25, v26, v43, 0xCu);
    goto LABEL_90;
  }

      free(v49);
      if (!v38) {
        return;
      }
LABEL_133:
      v71 = (char *)v38;
LABEL_142:
      free(v71);
      return;
    }

    v39 = (os_log_s *)__nwlog_obj();
    os_log_type_t v40 = type;
    if (!os_log_type_enabled(v39, type)) {
      goto LABEL_132;
    }
    *(_DWORD *)buf = 136446210;
    v83 = "nw_protocol_http_connect_disconnected";
    BOOL v41 = "%{public}s called with null http_connect";
LABEL_131:
    _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0xCu);
    goto LABEL_132;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v83 = "nw_protocol_http_connect_disconnected";
    v38 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      BOOL v41 = "%{public}s called with null other_protocol";
      goto LABEL_131;
    }

    if (!v80)
    {
      v39 = (os_log_s *)__nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      BOOL v41 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_131;
    }

    v49 = (char *)__nw_create_backtrace_string();
    v39 = (os_log_s *)__nwlog_obj();
    os_log_type_t v40 = type;
    os_log_type_t v52 = os_log_type_enabled(v39, type);
    if (!v49)
    {
      if (!v52) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      BOOL v41 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_131;
    }

    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      v83 = "nw_protocol_http_connect_disconnected";
      v84 = 2082;
      v85 = v49;
      v51 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_84;
    }

    goto LABEL_85;
  }

  if (*((_DWORD *)handle + 70) == 1)
  {
    if (a1->output_handler != a2)
    {
      default_input_handler = a1->default_input_handler;
      if (!default_input_handler
        || (callbacks = default_input_handler->callbacks) == 0LL
        || (disconnected = (void (*)(void))callbacks->disconnected) == 0LL)
      {
        __nwlog_obj();
        char v8 = a1->default_input_handler;
        v9 = "invalid";
        if (v8)
        {
          identifier = v8->identifier;
          if (identifier) {
            v9 = (const char *)identifier;
          }
        }

        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v9;
        v11 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v80 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v12 = (os_log_s *)__nwlog_obj();
          v13 = type;
          if (!os_log_type_enabled(v12, type)) {
            goto LABEL_140;
          }
          uint64_t v14 = a1->default_input_handler;
          BOOL v15 = "invalid";
          if (v14)
          {
            int v16 = v14->identifier;
            if (v16) {
              BOOL v15 = (const char *)v16;
            }
          }

              v91 = 0;
LABEL_86:
              v92 = a3 == 3;
              if (no_fullstack_fallback) {
                v92 = v91;
              }
              if (a3 != 3 && !v92)
              {
                if (a3 == 4
                  || (v20 != v280 ? (v93 = 4) : (v93 = 2), (*((_BYTE *)v279 + 109) & v93) != 0))
                {
                  if (!v25) {
                    goto LABEL_170;
                  }
                  v94 = v25;
                  v95 = *((_DWORD *)v94 + 30);

                  if ((v95 & 0xFFFFFFFE) == 4) {
                    goto LABEL_170;
                  }
                  if (v20 != v280)
                  {
                    if ((*((_BYTE *)v279 + 109) & 2) == 0)
                    {
LABEL_178:
                      v176 = 4;
LABEL_188:
                      v88->event.domain = 5;
                      v88->event.event = v176;
                      nw_endpoint_handler_report(v88, 0LL, &v88->event.domain, 0LL);
                      goto LABEL_189;
                    }

  if (v12) {
    free(v12);
  }
  return 0LL;
}

  if (v12) {
    free(v12);
  }
  return 0LL;
}

    if (v34) {
      free(v34);
    }
    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v50 = "nw_relay_hop_create";
  int v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v47 = 0;
  if (__nwlog_fault(v16, &type, &v47))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_relay_hop_create";
        _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null (http3_relay_endpoint || http2_relay_endpoint)",  buf,  0xCu);
      }
    }

    else if (v47)
    {
      uint64_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v17, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v50 = "nw_relay_hop_create";
          v51 = 2082;
          os_log_type_t v52 = v23;
          _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null (http3_relay_endpoint || http2_relay_endpoint), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
        goto LABEL_63;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_relay_hop_create";
        _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null (http3_relay_endpoint || http2_relay_endpoint), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_relay_hop_create";
        _os_log_impl( &dword_181A5C000,  v17,  v40,  "%{public}s called with null (http3_relay_endpoint || http2_relay_endpoint), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

          *(void *)buf = v4;
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_39794;
          v140 = (uint64_t)&__block_descriptor_tmp_57_39795;
          v141[0] = 0;
          v51 = *(void *)(v2 + 680);
          do
          {
            if (!v51) {
              break;
            }
            os_log_type_t v52 = *(void *)(v51 + 16);
            os_log_type_t v53 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            v51 = v52;
          }

          while ((v53 & 1) != 0);
          if (!*(void *)(v2 + 680))
          {
            if (!gLogDatapath) {
              goto LABEL_90;
            }
            goto LABEL_192;
          }

          v70 = v14;
          __nwlog_obj();
          v144 = 136446210;
          v145 = "nw_protocol_finalize_master_frame_array";
          v71 = (char *)_os_log_send_and_compose_impl();
          v134 = OS_LOG_TYPE_ERROR;
          v133 = 0;
          if (__nwlog_fault(v71, &v134, &v133))
          {
            if (v134 == OS_LOG_TYPE_FAULT)
            {
              v72 = (os_log_s *)__nwlog_obj();
              v73 = v134;
              if (!os_log_type_enabled(v72, v134)) {
                goto LABEL_189;
              }
              v144 = 136446210;
              v145 = "nw_protocol_finalize_master_frame_array";
              v74 = "%{public}s frame array is not empty after finalize";
LABEL_187:
              v127 = v72;
LABEL_188:
              _os_log_impl(&dword_181A5C000, v127, v73, v74, (uint8_t *)&v144, 0xCu);
              goto LABEL_189;
            }

            if (!v133)
            {
              v72 = (os_log_s *)__nwlog_obj();
              v73 = v134;
              if (!os_log_type_enabled(v72, v134)) {
                goto LABEL_189;
              }
              v144 = 136446210;
              v145 = "nw_protocol_finalize_master_frame_array";
              v74 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
              goto LABEL_187;
            }

            v116 = (char *)__nw_create_backtrace_string();
            v117 = (os_log_s *)__nwlog_obj();
            v73 = v134;
            log = v117;
            v118 = os_log_type_enabled(v117, v134);
            if (v116)
            {
              if (v118)
              {
                v144 = 136446466;
                v145 = "nw_protocol_finalize_master_frame_array";
                v146 = 2082;
                v147 = v116;
                _os_log_impl( &dword_181A5C000,  log,  v73,  "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s",  (uint8_t *)&v144,  0x16u);
              }

              free(v116);
            }

            else if (v118)
            {
              v144 = 136446210;
              v145 = "nw_protocol_finalize_master_frame_array";
              v74 = "%{public}s frame array is not empty after finalize, no backtrace";
              v127 = log;
              goto LABEL_188;
            }
          }

            CFRelease(v7);
            goto LABEL_86;
          }

          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            v51 = "nw_utilities_copy_local_entitlement_value";
            os_log_type_t v52 = 2114;
            os_log_type_t v53 = error;
            _os_log_impl( &dword_181A5C000,  v10,  v23,  "%{public}s SecTaskCopyValueForEntitlement %{public}@ failed, no backtrace",  buf,  0x16u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (os_log_s *)(id)gLogObj;
          v29 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v51 = "nw_utilities_copy_local_entitlement_value";
            os_log_type_t v52 = 2114;
            os_log_type_t v53 = error;
            _os_log_impl( &dword_181A5C000,  v10,  v29,  "%{public}s SecTaskCopyValueForEntitlement %{public}@ failed, backtrace limit exceeded",  buf,  0x16u);
          }
        }
      }

      if (!v9) {
        goto LABEL_55;
      }
      goto LABEL_54;
    }

    CFRelease(v4);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v16 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v51 = "nw_utilities_copy_local_entitlement_value";
    v13 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v13, &error, &type))
    {
      if (error == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (os_log_s *)(id)gLogObj;
        v18 = error;
        if (os_log_type_enabled(v17, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_utilities_copy_local_entitlement_value";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s SecTaskCreateFromSelf failed", buf, 0xCu);
        }
      }

      else if (type)
      {
        v25 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (os_log_s *)(id)gLogObj;
        uint64_t v26 = error;
        BOOL v27 = os_log_type_enabled(v17, (os_log_type_t)error);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            v51 = "nw_utilities_copy_local_entitlement_value";
            os_log_type_t v52 = 2082;
            os_log_type_t v53 = (CFErrorRef)v25;
            _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s SecTaskCreateFromSelf failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v25);
          if (!v13) {
            return 0LL;
          }
          goto LABEL_75;
        }

        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_utilities_copy_local_entitlement_value";
          _os_log_impl(&dword_181A5C000, v17, v26, "%{public}s SecTaskCreateFromSelf failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (os_log_s *)(id)gLogObj;
        v30 = error;
        if (os_log_type_enabled(v17, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_utilities_copy_local_entitlement_value";
          _os_log_impl( &dword_181A5C000,  v17,  v30,  "%{public}s SecTaskCreateFromSelf failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      goto LABEL_73;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v51 = "nw_utilities_copy_local_entitlement_value";
    os_log_type_t v52 = 2082;
    os_log_type_t v53 = (CFErrorRef)cStr;
    v13 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v13, &error, &type))
    {
      if (error == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (os_log_s *)(id)gLogObj;
        BOOL v15 = error;
        if (os_log_type_enabled(v14, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_utilities_copy_local_entitlement_value";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = (CFErrorRef)cStr;
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s CFStringCreateWithCString(%{public}s) failed",  buf,  0x16u);
        }
      }

      else if (type)
      {
        v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (os_log_s *)(id)gLogObj;
        v20 = error;
        v21 = os_log_type_enabled(v14, (os_log_type_t)error);
        if (v19)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446722;
            v51 = "nw_utilities_copy_local_entitlement_value";
            os_log_type_t v52 = 2082;
            os_log_type_t v53 = (CFErrorRef)cStr;
            uint64_t v54 = 2082;
            v55 = v19;
            _os_log_impl( &dword_181A5C000,  v14,  v20,  "%{public}s CFStringCreateWithCString(%{public}s) failed, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v19);
          if (!v13) {
            return 0LL;
          }
          goto LABEL_75;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_utilities_copy_local_entitlement_value";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = (CFErrorRef)cStr;
          _os_log_impl( &dword_181A5C000,  v14,  v20,  "%{public}s CFStringCreateWithCString(%{public}s) failed, no backtrace",  buf,  0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (os_log_s *)(id)gLogObj;
        int v28 = error;
        if (os_log_type_enabled(v14, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_utilities_copy_local_entitlement_value";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = (CFErrorRef)cStr;
          _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s CFStringCreateWithCString(%{public}s) failed, backtrace limit exceeded",  buf,  0x16u);
        }
      }
    }
  }

        free(v23);
        goto LABEL_86;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        v34 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          char v61 = "nw_ws_write_server_response";
          _os_log_impl(&dword_181A5C000, v24, v34, "%{public}s CFHTTPMessageCreateResponse failed", buf, 0xCu);
        }

        goto LABEL_83;
      }

      if (!v54)
      {
        __nwlog_obj();
        v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          char v61 = "nw_ws_write_server_response";
          _os_log_impl( &dword_181A5C000,  v24,  v42,  "%{public}s CFHTTPMessageCreateResponse failed, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_83;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      v37 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446210;
          char v61 = "nw_ws_write_server_response";
          _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s CFHTTPMessageCreateResponse failed, no backtrace",  buf,  0xCu);
        }

        goto LABEL_83;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        char v61 = "nw_ws_write_server_response";
        os_log_type_t v62 = 2082;
        v63 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s CFHTTPMessageCreateResponse failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_45;
    }
  }

  v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  v10 = CFHTTPMessageCreateResponse( (CFAllocatorRef)*MEMORY[0x189604DB0],  101LL,  @"Switching Protocols",  (CFStringRef)*MEMORY[0x1896020E0]);
  v57[3] = (uint64_t)v10;
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v61 = "nw_ws_write_server_response";
    uint64_t v23 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v54 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (os_log_s *)(id)gLogObj;
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_ws_write_server_response";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s CFHTTPMessageCreateResponse failed", buf, 0xCu);
      }

        goto LABEL_31;
      }

      if (!v83)
      {
        __nwlog_obj();
        os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v72 = v84;
        if (os_log_type_enabled(v53, v84))
        {
          v73 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 136446466;
          v86 = "nw_service_connector_cancel_block_invoke";
          v87 = 2114;
          v88 = v73;
          _os_log_impl( &dword_181A5C000,  v53,  v72,  "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, backtrace limit exceeded",  buf,  0x16u);
        }

        goto LABEL_85;
      }

      char v64 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v65 = v84;
      v66 = os_log_type_enabled(v53, v84);
      if (!v64)
      {
        if (v66)
        {
          v76 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 136446466;
          v86 = "nw_service_connector_cancel_block_invoke";
          v87 = 2114;
          v88 = v76;
          _os_log_impl( &dword_181A5C000,  v53,  v65,  "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, no backtrace",  buf,  0x16u);
        }

        goto LABEL_85;
      }

      if (v66)
      {
        v67 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 136446722;
        v86 = "nw_service_connector_cancel_block_invoke";
        v87 = 2114;
        v88 = v67;
        v89 = 2082;
        v90 = v64;
        _os_log_impl( &dword_181A5C000,  v53,  v65,  "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v64);
    }

  __break(1u);
  return result;
}

  LOBYTE(v93) = *((_BYTE *)a3 + *v9) == 0;
  return v93;
}

    free(v32);
    *(void *)&v81[16] = 0LL;
    goto LABEL_86;
  }

  v71 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v77 = "strict_calloc";
  v78 = 2048;
  *(void *)v79 = 1LL;
  *(_WORD *)&v79[8] = 2048;
  v80[0] = 40LL;
  v72 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v72);
  if (!(_DWORD)result)
  {
    free(v72);
    if (LODWORD(__size[1])) {
      goto LABEL_54;
    }
    goto LABEL_52;
  }

    if (v22) {
      free(v22);
    }
    id v3 = 0LL;
    goto LABEL_29;
  }

  *(_OWORD *)v3->token = *(_OWORD *)xpc_dictionary_get_uuid(v4, "token");
  v3->investigation_identifier = xpc_dictionary_get_uint64(v4, "investigation_identifier");
  v3->start_time = xpc_dictionary_get_uint64(v4, "start_time");
  v3->end_time = xpc_dictionary_get_uint64(v4, "end_time");
  v3->fragments_quenched = xpc_dictionary_get_uint64(v4, "fragments_quenched");
  m_obj = v3->parent.m_obj;
  if ((*((_BYTE *)&v3->parent + 8) & 1) != 0 && m_obj)
  {
    v3->parent.m_obj = 0LL;

    m_obj = v3->parent.m_obj;
  }

  v3->parent.m_obj = 0LL;

  char v6 = v3->parent.m_obj;
  v3->parent.m_obj = 0LL;

  *((_BYTE *)&v3->parent + 8) |= 1u;
  os_unfair_lock_lock(&v3->description_cache.mutex.m_mutex);
  int v7 = v3->description_cache.description.m_obj;
  if ((*((_BYTE *)&v3->description_cache.description + 8) & 1) != 0 && v7)
  {
    v3->description_cache.description.m_obj = 0LL;

    int v7 = v3->description_cache.description.m_obj;
  }

  v3->description_cache.description.m_obj = 0LL;

  os_unfair_lock_unlock(&v3->description_cache.mutex.m_mutex);
  v3->label = xpc_dictionary_get_uint64(v4, "label");
  v3->domain = xpc_dictionary_get_uint64(v4, "domain");
  v3->client_metric_count = 0;
  v3->underlying_error_domain = xpc_dictionary_get_int64(v4, "underlying_error_domain");
  v3->underlying_error_code = xpc_dictionary_get_int64(v4, "underlying_error_code");
  v3->reporting_strategy = xpc_dictionary_get_uint64(v4, "reporting_strategy");
  v3->completion_reason = xpc_dictionary_get_uint64(v4, "completion_reason");
  *((_BYTE *)v3 + 140) = *((_BYTE *)v3 + 140) & 0xFE | xpc_dictionary_get_BOOL(v4, "is_retry");
  if (xpc_dictionary_get_BOOL(v4, "is_lightweight")) {
    char v8 = 2;
  }
  else {
    char v8 = 0;
  }
  *((_BYTE *)v3 + 140) = *((_BYTE *)v3 + 140) & 0xFD | v8;
  if (xpc_dictionary_get_BOOL(v4, "activated")) {
    v9 = 4;
  }
  else {
    v9 = 0;
  }
  *((_BYTE *)v3 + 140) = *((_BYTE *)v3 + 140) & 0xFB | v9;
  if (xpc_dictionary_get_BOOL(v4, "completed")) {
    v10 = 8;
  }
  else {
    v10 = 0;
  }
  *((_BYTE *)v3 + 140) = *((_BYTE *)v3 + 140) & 0xF7 | v10;
  string = xpc_dictionary_get_string(v4, "underlying_error_domain_string");
  if (!string) {
    goto LABEL_23;
  }
  __int16 v12 = strndup(string, 0x100uLL);
  if (v12)
  {
LABEL_22:
    v3->underlying_error_domain_string = v12;
LABEL_23:
    if (nw_activity_should_log(v3))
    {
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
      }
      v13 = (os_log_s *)(id)gactivityLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        os_log_type_t v43 = (const char *)v3;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEFAULT,  "Create activity from XPC object %{public}@",  buf,  0xCu);
      }
    }

    goto LABEL_29;
  }

  __nwlog_obj();
  v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v43 = "strict_strndup";
  uint64_t v26 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    goto LABEL_22;
  }

  __break(1u);
  return result;
}

    goto LABEL_86;
  }

  char v8 = *(void *)(a1 + 40);
  if (!v8)
  {
    v20 = a1;
    v21 = v4;
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_necp_append_tlv";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null beyond", buf, 0xCu);
      }
    }

    else if (v52)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      v37 = os_log_type_enabled(v24, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v55 = "nw_necp_append_tlv";
          v56 = 2082;
          *(void *)uint64_t v57 = v35;
          _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v35);
        if (!v23) {
          goto LABEL_88;
        }
        goto LABEL_87;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v24, v36, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl( &dword_181A5C000,  v24,  v46,  "%{public}s called with null beyond, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_85;
  }

  if (v7 < v8)
  {
    v9 = length + 5LL;
    if (v8 - v7 < v9)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      *(_DWORD *)buf = 136447490;
      v55 = "nw_necp_append_tlv";
      v56 = 2048;
      *(void *)uint64_t v57 = v7;
      *(_WORD *)&v57[8] = 2048;
      *(void *)uint64_t v58 = length + 5LL;
      *(_WORD *)&v58[8] = 2048;
      *(void *)v59 = v8;
      *(_WORD *)&v59[8] = 1024;
      *(_DWORD *)v60 = 222;
      *(_WORD *)&v60[4] = 1024;
      *(_DWORD *)&v60[6] = length;
      v11 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v52 = 0;
      if (__nwlog_fault(v11, &type, &v52))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v12 = (os_log_s *)(id)gLogObj;
          v13 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447490;
            v55 = "nw_necp_append_tlv";
            v56 = 2048;
            *(void *)uint64_t v57 = v7;
            *(_WORD *)&v57[8] = 2048;
            *(void *)uint64_t v58 = length + 5LL;
            *(_WORD *)&v58[8] = 2048;
            *(void *)v59 = v8;
            *(_WORD *)&v59[8] = 1024;
            *(_DWORD *)v60 = 222;
            *(_WORD *)&v60[4] = 1024;
            *(_DWORD *)&v60[6] = length;
            _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
          }
        }

        else if (v52)
        {
          BOOL v15 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v12 = (os_log_s *)(id)gLogObj;
          int v16 = type;
          v17 = os_log_type_enabled(v12, type);
          if (v15)
          {
            if (v17)
            {
              *(_DWORD *)buf = 136447746;
              v55 = "nw_necp_append_tlv";
              v56 = 2048;
              *(void *)uint64_t v57 = v7;
              *(_WORD *)&v57[8] = 2048;
              *(void *)uint64_t v58 = length + 5LL;
              *(_WORD *)&v58[8] = 2048;
              *(void *)v59 = v8;
              *(_WORD *)&v59[8] = 1024;
              *(_DWORD *)v60 = 222;
              *(_WORD *)&v60[4] = 1024;
              *(_DWORD *)&v60[6] = length;
              char v61 = 2082;
              os_log_type_t v62 = v15;
              _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
            }

            free(v15);
            if (!v11) {
              goto LABEL_28;
            }
            goto LABEL_27;
          }

          if (v17)
          {
            *(_DWORD *)buf = 136447490;
            v55 = "nw_necp_append_tlv";
            v56 = 2048;
            *(void *)uint64_t v57 = v7;
            *(_WORD *)&v57[8] = 2048;
            *(void *)uint64_t v58 = length + 5LL;
            *(_WORD *)&v58[8] = 2048;
            *(void *)v59 = v8;
            *(_WORD *)&v59[8] = 1024;
            *(_DWORD *)v60 = 222;
            *(_WORD *)&v60[4] = 1024;
            *(_DWORD *)&v60[6] = length;
            _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v12 = (os_log_s *)(id)gLogObj;
          v18 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447490;
            v55 = "nw_necp_append_tlv";
            v56 = 2048;
            *(void *)uint64_t v57 = v7;
            *(_WORD *)&v57[8] = 2048;
            *(void *)uint64_t v58 = length + 5LL;
            *(_WORD *)&v58[8] = 2048;
            *(void *)v59 = v8;
            *(_WORD *)&v59[8] = 1024;
            *(_DWORD *)v60 = 222;
            *(_WORD *)&v60[4] = 1024;
            *(_DWORD *)&v60[6] = length;
            _os_log_impl( &dword_181A5C000,  v12,  v18,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
          }
        }
      }

      if (!v11)
      {
LABEL_28:
        uint64_t v14 = 0LL;
        goto LABEL_29;
      }

    free(v36);
    if (!v15) {
      return 0LL;
    }
    goto LABEL_112;
  }

  bonjour_service = nw_advertise_descriptor_create_bonjour_service(v4, v8, v10);
  v13 = bonjour_service;
  if (v6 > v11 + 1) {
    nw_advertise_descriptor_set_txt_record(bonjour_service, &v4[v11 + 1], v6 - (v11 + 1));
  }
  return v13;
}

  if (v14)
  {
    os_log_type_t v43 = (char *)v14;
LABEL_96:
    free(v43);
  }

    if (v39) {
      free(v39);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v47 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "nw_path_report_error_to_agent";
    int v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    uint64_t v54 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, type, &v54))
    {
LABEL_28:
      if (v7) {
LABEL_29:
      }
        free(v7);
LABEL_30:
      BOOL v15 = 0LL;
LABEL_50:

      return v15;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = (os_log_s *)(id)gLogObj;
      v49 = type[0];
      if (os_log_type_enabled(v48, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "nw_path_report_error_to_agent";
        _os_log_impl(&dword_181A5C000, v48, v49, "%{public}s nw_path_create_necp_agent_error failed", buf, 0xCu);
      }

    if (v30) {
      free(v30);
    }
    BOOL v15 = 0LL;
    v49[3] = 0LL;
    goto LABEL_32;
  }

                            if (*((_BYTE *)a3 + *v9)) {
                              char v61 = 0;
                            }
                            goto LABEL_87;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        *((_BYTE *)a3 + *v9) = 1;
        goto LABEL_85;
      }

      if ((_DWORD)v56 == 2)
      {
        PBReaderReadData();
        __int16 v12 = (objc_class *)objc_claimAutoreleasedReturnValue();
        v13 = 2LL;
LABEL_4:
        uint64_t v14 = (&self->super.super.isa)[v13];
        (&self->super.super.isa)[v13] = v12;

        goto LABEL_5;
      }

      if ((_DWORD)v56 == 1)
      {
        PBReaderReadString();
        __int16 v12 = (objc_class *)objc_claimAutoreleasedReturnValue();
        v13 = 1LL;
        goto LABEL_4;
      }

      v95 = PBReaderSkipValueWithTag();
      if (!v95) {
        return v95;
      }
LABEL_5:
      v5 = *v4;
      char v6 = *(void *)((char *)a3 + v5);
      char v8 = *(void *)((char *)a3 + *v7);
      if (v6 >= v8) {
        goto LABEL_88;
      }
    }

    v17 = 0LL;
LABEL_39:
    *BOOL v15 = 1;
    goto LABEL_40;
  }

      goto LABEL_86;
    }

    if (!uu[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (os_log_s *)(id)gLogObj;
      uint64_t v58 = v80[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v80[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v30, v58, "%{public}s symptom_new failed, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_85;
    }

    uint64_t v54 = __nw_create_backtrace_string();
    if (!v54)
    {
      __nwlog_obj();
      v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v59 = v80[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v80[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v30, v59, "%{public}s symptom_new failed, no backtrace", buf, 0xCu);
      }

      goto LABEL_85;
    }

    v39 = (char *)v54;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v40 = (os_log_s *)(id)gLogObj;
    v55 = v80[0];
    if (os_log_type_enabled(v40, (os_log_type_t)v80[0]))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_report_symptom_internal_on_nw_queue";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v39;
      _os_log_impl( &dword_181A5C000,  v40,  v55,  "%{public}s symptom_new failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  return v47;
}

  return v47;
}

    goto LABEL_86;
  }

  int v7 = (NWConcrete_nw_endpoint_handler *)v5;
  mode = v7->mode;

  if ((_DWORD)mode == 2)
  {
    v9 = nw_endpoint_handler_copy_flow(v7);
    v10 = v9;
    if (v9)
    {
      if ((*((_BYTE *)v9 + 33) & 4) != 0)
      {
        v11 = (char *)v9 + 376;
        if (a2)
        {
          __int16 v12 = (char *)*((void *)v9 + 51);
          if (!v12)
          {
LABEL_21:
            v24 = v7;
            v25 = *((_BYTE *)v24 + 268);

            if ((v25 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v26 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                BOOL v27 = v24;

                int v28 = v27;
                v29 = *((_BYTE *)v24 + 268);

                if ((v29 & 1) != 0) {
                  v30 = "dry-run ";
                }
                else {
                  v30 = "";
                }
                v31 = nw_endpoint_handler_copy_endpoint(v28);
                logging_description = nw_endpoint_get_logging_description(v31);
                id_str = v27->id_str;
                v33 = v28;
                v34 = v33;
                v35 = v33[30];
                else {
                  os_log_type_t v36 = off_189BBBBF0[v35];
                }
                v70 = v36;

                uint64_t v58 = v34;
                v59 = v58;
                v60 = v7->mode;
                char v61 = "path";
                switch(v60)
                {
                  case 0:
                    break;
                  case 1:
                    char v61 = "resolver";
                    break;
                  case 2:
                    char v61 = nw_endpoint_flow_mode_string(v58[31]);
                    break;
                  case 3:
                    char v61 = "proxy";
                    break;
                  case 4:
                    char v61 = "fallback";
                    break;
                  case 5:
                    char v61 = "transform";
                    break;
                  default:
                    char v61 = "unknown-mode";
                    break;
                }

                os_log_type_t v62 = v59;
                os_unfair_lock_lock((os_unfair_lock_t)v62 + 28);
                v63 = v62[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v62 + 28);

                *(_DWORD *)buf = 136448002;
                v75 = "nw_endpoint_handler_inject_disconnect_error";
                v76 = 2082;
                v77 = id_str;
                v78 = 2082;
                v79 = v30;
                v80 = 2082;
                v81 = (void *)logging_description;
                v82 = 2082;
                v83 = v70;
                v84 = 2082;
                v85 = v61;
                v86 = 2114;
                v87 = v63;
                v88 = 1024;
                v89 = a3;
                _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Inject disconnect err or %d failed, could not locate protocol",  buf,  0x4Eu);
              }
            }

            goto LABEL_95;
          }

          while (1)
          {
            v13 = v12;
            uint64_t v14 = (uint64_t *)*((void *)v12 + 2);
            BOOL v15 = *v14;
            int v16 = v14[1];
            v17 = v14[2];
            v18 = v14[3];
            v19 = v14[4];
            v20 = *a2 == v15 && a2[1] == v16;
            v21 = v20 && a2[2] == v17;
            uint64_t v22 = v21 && a2[3] == v18;
            if (v22 && a2[4] == v19) {
              break;
            }
            __int16 v12 = (char *)*((void *)v13 + 4);
            v11 = v13;
            if (!v12) {
              goto LABEL_21;
            }
          }
        }

        else
        {
          v13 = 0LL;
        }

        (*(void (**)(char *, char *, uint64_t))(*((void *)v11 + 3) + 56LL))(v11, v13, a3);
        (*(void (**)(char *, char *))(*((void *)v11 + 3) + 48LL))(v11, v13);
        (*(void (**)(char *, char *))(*((void *)v11 + 3) + 184LL))(v11, v13);
      }

      v37(v5, *(void *)(a1 + 32));
      return 1LL;
    }

    if ((v8 & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v44 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v46 = *(_DWORD *)(v6 + 176);
        v45 = *(_DWORD *)(v6 + 180);
        *(_DWORD *)buf = 136447234;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = (const char *)(v6 + 191);
        v103 = 2080;
        v104 = " ";
        v105 = 1024;
        v106 = v45;
        v107 = 1024;
        *(_DWORD *)v108 = v46;
        _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%d> input finished before a complete message",  buf,  0x2Cu);
      }
    }

    v47 = *(unsigned __int16 *)(v6 + 188);
    v48 = v47 | (*(unsigned __int8 *)(v6 + 190) << 16);
    if ((v47 & 0x40) != 0) {
      return 1LL;
    }
    *(_BYTE *)(v6 + 190) = BYTE2(v48);
    *(_WORD *)(v6 + 188) = v48 | 0x40;
    v49 = *(void *)(v5 + 24);
    if (v49)
    {
      v50 = *(void (**)(uint64_t, void, uint64_t))(v49 + 56);
      if (v50)
      {
        v50(v5, *(void *)(a1 + 32), 57LL);
        goto LABEL_61;
      }
    }

    __nwlog_obj();
    v79 = *(const char **)(v5 + 16);
    if (!v79) {
      v79 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    v100 = "nw_protocol_http2_input_finished_block_invoke";
    v101 = 2082;
    v102 = v79;
    v80 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v97 = 0;
    if (__nwlog_fault(v80, &type, &v97))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v81 = (os_log_s *)__nwlog_obj();
        v82 = type;
        if (!os_log_type_enabled(v81, type)) {
          goto LABEL_187;
        }
        v83 = *(const char **)(v5 + 16);
        if (!v83) {
          v83 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v83;
        v84 = "%{public}s protocol %{public}s has invalid error callback";
        goto LABEL_186;
      }

      if (!v97)
      {
        v81 = (os_log_s *)__nwlog_obj();
        v82 = type;
        if (!os_log_type_enabled(v81, type)) {
          goto LABEL_187;
        }
        v95 = *(const char **)(v5 + 16);
        if (!v95) {
          v95 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v95;
        v84 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_186;
      }

      v90 = (char *)__nw_create_backtrace_string();
      v81 = (os_log_s *)__nwlog_obj();
      v82 = type;
      v91 = os_log_type_enabled(v81, type);
      if (v90)
      {
        if (v91)
        {
          v92 = *(const char **)(v5 + 16);
          if (!v92) {
            v92 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v100 = "nw_protocol_http2_input_finished_block_invoke";
          v101 = 2082;
          v102 = v92;
          v103 = 2082;
          v104 = v90;
          _os_log_impl( &dword_181A5C000,  v81,  v82,  "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v90);
        goto LABEL_187;
      }

      if (v91)
      {
        v96 = *(const char **)(v5 + 16);
        if (!v96) {
          v96 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v96;
        v84 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
LABEL_186:
        _os_log_impl(&dword_181A5C000, v81, v82, v84, buf, 0x16u);
      }
    }

                    os_release(v8);
                    os_release(v10);
                    return is_test_protocol;
                  }

                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_test_mode";
                  v56 = (char *)_os_log_send_and_compose_impl();
                  type[0] = OS_LOG_TYPE_ERROR;
                  v66 = 0;
                  if (__nwlog_fault(v56, type, &v66))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      uint64_t v57 = (os_log_s *)__nwlog_obj();
                      uint64_t v58 = type[0];
                      if (os_log_type_enabled(v57, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_test_mode";
                        v59 = "%{public}s protocol options are not test protocol";
LABEL_175:
                        _os_log_impl(&dword_181A5C000, v57, v58, v59, buf, 0xCu);
                      }
                    }

                    else if (v66)
                    {
                      v60 = (char *)__nw_create_backtrace_string();
                      uint64_t v57 = (os_log_s *)__nwlog_obj();
                      uint64_t v58 = type[0];
                      char v61 = os_log_type_enabled(v57, type[0]);
                      if (v60)
                      {
                        if (v61)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_test_mode";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v60;
                          _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                        }

                        free(v60);
                        goto LABEL_176;
                      }

                      if (v61)
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_test_mode";
                        v59 = "%{public}s protocol options are not test protocol, no backtrace";
                        goto LABEL_175;
                      }
                    }

                    else
                    {
                      uint64_t v57 = (os_log_s *)__nwlog_obj();
                      uint64_t v58 = type[0];
                      if (os_log_type_enabled(v57, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_test_mode";
                        v59 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
                        goto LABEL_175;
                      }
                    }
                  }

LABEL_79:
  if (v30) {
    free(v30);
  }
  uint64_t v54 = 0LL;
LABEL_90:

  return v54;
}

              free(v70);
              goto LABEL_80;
            }

            __nwlog_obj();
            v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v79 = v153;
            if (os_log_type_enabled(v71, v153))
            {
              *(_DWORD *)buf = 136446210;
              v155 = "nw_protocol_stack_shallow_copy";
              _os_log_impl( &dword_181A5C000,  v71,  v79,  "%{public}s [[nw_protocol_stack alloc] init] failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v71 = (os_log_s *)(id)gLogObj;
            v78 = v153;
            if (os_log_type_enabled(v71, v153))
            {
              *(_DWORD *)buf = 136446210;
              v155 = "nw_protocol_stack_shallow_copy";
              _os_log_impl( &dword_181A5C000,  v71,  v78,  "%{public}s [[nw_protocol_stack alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v70) {
          goto LABEL_80;
        }
        goto LABEL_79;
      }

      v63 = nw_protocol_stack_copy(v49);
      char v64 = a1[19];
      a1[19] = v63;

      char v61 = (unsigned __int8 **)(v7 + 168);
      if (!*((void *)v7 + 21))
      {
        v73 = (void *)*((void *)v7 + 25);
        if (!v73)
        {
LABEL_88:
          v86 = (void *)*((void *)v7 + 26);
          if (!v86)
          {
LABEL_98:
            v91 = (void *)*((void *)v7 + 27);
            if (v91)
            {
              if (a4) {
                v92 = v91;
              }
              else {
                v92 = xpc_copy(v91);
              }
              v93 = a1[27];
              a1[27] = v92;
            }

            goto LABEL_103;
          }

          goto LABEL_92;
        }

    goto LABEL_80;
  }

  id v3 = (unsigned int *)v233;
  os_log_type_t v4 = v3[29];

  if ((_DWORD)v4 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    else {
      uint64_t v14 = off_189BBBBC0[v4];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow startWithHandler:]";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v14;
    *(_WORD *)&buf[22] = 2082;
    v240 = "flow";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v234 = 0;
    if (__nwlog_fault(v15, type, &v234))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v16 = (os_log_s *)(id)gLogObj;
        v17 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          else {
            v18 = off_189BBBBC0[v4];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v18;
          *(_WORD *)&buf[22] = 2082;
          v240 = "flow";
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v234)
      {
        v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v16 = (os_log_s *)(id)gLogObj;
        v20 = type[0];
        v21 = os_log_type_enabled(v16, type[0]);
        if (v19)
        {
          if (v21)
          {
            else {
              uint64_t v22 = off_189BBBBC0[v4];
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow startWithHandler:]";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v22;
            *(_WORD *)&buf[22] = 2082;
            v240 = "flow";
            *(_WORD *)v241 = 2082;
            *(void *)&v241[2] = v19;
            _os_log_impl( &dword_181A5C000,  v16,  v20,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v19);
          if (!v15) {
            goto LABEL_233;
          }
LABEL_81:
          free(v15);
          goto LABEL_233;
        }

        if (v21)
        {
          else {
            v48 = off_189BBBBC0[v4];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v48;
          *(_WORD *)&buf[22] = 2082;
          v240 = "flow";
          _os_log_impl( &dword_181A5C000,  v16,  v20,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v36 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          else {
            v37 = off_189BBBBC0[v4];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v37;
          *(_WORD *)&buf[22] = 2082;
          v240 = "flow";
          _os_log_impl( &dword_181A5C000,  v16,  v36,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }

      goto LABEL_79;
    }

      if ((v28 & 0x40) == 0)
      {
        if (*((_DWORD *)a1 + 48)) {
          os_packet_set_compression_generation_count();
        }
        goto LABEL_127;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
      v29 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v223) = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v29, &v223, type))
      {
        if (v223 == 17)
        {
          v30 = (os_log_s *)__nwlog_obj();
          v31 = v223;
          if (!os_log_type_enabled(v30, (os_log_type_t)v223)) {
            goto LABEL_125;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          os_log_type_t v32 = "%{public}s Attempt to get generation-count on a chain-member";
          goto LABEL_124;
        }

        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          v30 = (os_log_s *)__nwlog_obj();
          v31 = v223;
          if (!os_log_type_enabled(v30, (os_log_type_t)v223)) {
            goto LABEL_125;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          os_log_type_t v32 = "%{public}s Attempt to get generation-count on a chain-member, backtrace limit exceeded";
          goto LABEL_124;
        }

        v45 = (char *)__nw_create_backtrace_string();
        v30 = (os_log_s *)__nwlog_obj();
        v31 = v223;
        v46 = os_log_type_enabled(v30, (os_log_type_t)v223);
        if (v45)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
            v221 = 2082;
            *(void *)v222 = v45;
            _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s Attempt to get generation-count on a chain-member, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v45);
          goto LABEL_125;
        }

        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          os_log_type_t v32 = "%{public}s Attempt to get generation-count on a chain-member, no backtrace";
LABEL_124:
          _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0xCu);
        }
      }

      if (v28) {
        free(v28);
      }
      int v7 = v34;
      goto LABEL_18;
    }
  }

    goto LABEL_80;
  }

  if (!v70)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v23 = (os_log_s *)(id)gconnectionLogObj;
    os_log_type_t v43 = type[0];
    if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
    {
      BOOL v44 = *((_DWORD *)v2 + 112);
      LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
      *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_sta"
                                                                                                  "ts_report_on_nw_queue";
      WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
      *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v44;
      _os_log_impl( &dword_181A5C000,  v23,  v43,  "%{public}s [C%u] Unexpected NULL stats report, backtrace limit exceeded",  (uint8_t *)&buf,  0x12u);
    }

    goto LABEL_79;
  }

  v35 = __nw_create_backtrace_string();
  if (!v35)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v23 = (os_log_s *)(id)gconnectionLogObj;
    v45 = type[0];
    if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
    {
      v46 = *((_DWORD *)v2 + 112);
      LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
      *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_sta"
                                                                                                  "ts_report_on_nw_queue";
      WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
      *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v46;
      _os_log_impl( &dword_181A5C000,  v23,  v45,  "%{public}s [C%u] Unexpected NULL stats report, no backtrace",  (uint8_t *)&buf,  0x12u);
    }

    goto LABEL_79;
  }

  os_log_type_t v36 = (char *)v35;
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v37 = (os_log_s *)(id)gconnectionLogObj;
  v38 = type[0];
  if (os_log_type_enabled(v37, (os_log_type_t)type[0]))
  {
    v39 = *((_DWORD *)v2 + 112);
    LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446722;
    *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats"
                                                                                                "_report_on_nw_queue";
    WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
    *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v39;
    WORD1(buf.u.nw_connection_report.bytes_duplicate) = 2082;
    *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_duplicate + 4) = (unint64_t)v36;
    _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s [C%u] Unexpected NULL stats report, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x1Cu);
  }

  free(v36);
  if (v22) {
    goto LABEL_81;
  }
LABEL_129:
}

    if (v43) {
      free(v43);
    }
    goto LABEL_11;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v26 = (id)gLogObj;
  else {
    BOOL v27 = off_189BBBB90[mode];
  }
  *(_DWORD *)buf = 136446722;
  os_log_type_t v62 = "nw_endpoint_handler_cancel_read_write_requests";
  v63 = 2082;
  char v64 = (void *)v27;
  v65 = 2082;
  v66 = "flow";
  int v28 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v59 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = (os_log_s *)(id)gLogObj;
    v30 = type;
    if (os_log_type_enabled(v29, type))
    {
      else {
        v31 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v62 = "nw_endpoint_handler_cancel_read_write_requests";
      v63 = 2082;
      char v64 = (void *)v31;
      v65 = 2082;
      v66 = "flow";
      _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

  __break(1u);
LABEL_80:
  result = sub_18264F5C4();
  __break(1u);
  return result;
}

  id v3 = 1;
  if ((a1 & 8) == 0)
  {
LABEL_7:
    if ((a1 & 0x10) == 0) {
      goto LABEL_8;
    }
LABEL_119:
    if ((v3 & 1) != 0)
    {
      if (!v2)
      {
        __nwlog_obj();
        v131 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v131, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v140 = "_strict_strlcat";
        v132 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v132);
        if (result) {
          goto LABEL_268;
        }
        free(v132);
      }

      v55 = 0LL;
      v56 = 107LL;
      while (1)
      {
        uint64_t v57 = &v2[v55];
        if (!v2[v55]) {
          break;
        }
        ++v55;
        if (!--v56) {
          goto LABEL_145;
        }
      }

      if (v56 >= 2)
      {
        v60 = v56 - 2;
        char v61 = 106 - v55;
        os_log_type_t v62 = 105 - v55;
        if (v62 >= 2) {
          os_log_type_t v62 = 2LL;
        }
        memcpy(v57, ", ", v62 + 1);
        uint64_t v57 = v2 + 106;
        while (v60 <= 1)
        {
          if (!--v61) {
            goto LABEL_144;
          }
        }

        goto LABEL_145;
      }
    }

    else
    {
      if (!v2)
      {
        __nwlog_obj();
        v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v133, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v140 = "_strict_strlcat";
        v134 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v134);
        if (result) {
          goto LABEL_268;
        }
        free(v134);
      }

      uint64_t v58 = 0LL;
      v59 = 107LL;
      while (1)
      {
        uint64_t v57 = &v2[v58];
        if (!v2[v58]) {
          break;
        }
        ++v58;
        if (!--v59) {
          goto LABEL_145;
        }
      }

      if (v59 >= 2)
      {
        v63 = v59 - 2;
        char v64 = 106 - v58;
        if (v58 == 105) {
          v65 = 1LL;
        }
        else {
          v65 = 2LL;
        }
        memcpy(v57, "<", v65);
        uint64_t v57 = v2 + 106;
        while (!v63)
        {
          if (!--v64) {
            goto LABEL_144;
          }
        }

      free(v38);
      if (!v17) {
        goto LABEL_137;
      }
LABEL_135:
      char v64 = (char *)v17;
LABEL_136:
      free(v64);
      goto LABEL_137;
    }

    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_constrained);
        string = xpc_dictionary_get_string( *(xpc_object_t *)(a1 + 32),  (const char *)networkd_privileged_key_interface_name);
        v50 = "Cleared";
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2082;
        if (v48) {
          v50 = "Set";
        }
        *(void *)v82 = v50;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = string;
        _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s constrained on %{public}s",  buf,  0x20u);
      }

      goto LABEL_83;
    }

    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
        }

        goto LABEL_137;
      }

      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
          }
        }

        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_constrained_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(void *)&v82[6] = v71;
              _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v71);
            if (!v56) {
              goto LABEL_137;
            }
LABEL_183:
            char v64 = (char *)v56;
            goto LABEL_136;
          }

          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v76,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      free(v38);
      if (!v17) {
        goto LABEL_137;
      }
LABEL_135:
      char v64 = (char *)v17;
LABEL_136:
      free(v64);
      goto LABEL_137;
    }

    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_constrained);
        string = xpc_dictionary_get_string( *(xpc_object_t *)(a1 + 32),  (const char *)networkd_privileged_key_interface_name);
        v50 = "Cleared";
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2082;
        if (v48) {
          v50 = "Set";
        }
        *(void *)v82 = v50;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = string;
        _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s ultra constrained on %{public}s",  buf,  0x20u);
      }

      goto LABEL_83;
    }

    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
        }

        goto LABEL_137;
      }

      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
          }
        }

        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(void *)&v82[6] = v71;
              _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v71);
            if (!v56) {
              goto LABEL_137;
            }
LABEL_183:
            char v64 = (char *)v56;
            goto LABEL_136;
          }

          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v76,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      free(v38);
      if (!v17) {
        goto LABEL_137;
      }
LABEL_135:
      char v64 = (char *)v17;
LABEL_136:
      free(v64);
      goto LABEL_137;
    }

    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_expensive);
        string = xpc_dictionary_get_string( *(xpc_object_t *)(a1 + 32),  (const char *)networkd_privileged_key_interface_name);
        v50 = "Cleared";
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2082;
        if (v48) {
          v50 = "Set";
        }
        *(void *)v82 = v50;
        *(_WORD *)&v82[8] = 2082;
        *(void *)&v82[10] = string;
        _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s expensive on %{public}s",  buf,  0x20u);
      }

      goto LABEL_83;
    }

    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
        }

        goto LABEL_137;
      }

      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
          }
        }

        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_expensive_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(void *)&v82[6] = v71;
              _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v71);
            if (!v56) {
              goto LABEL_137;
            }
LABEL_183:
            char v64 = (char *)v56;
            goto LABEL_136;
          }

          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v76,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      free(v38);
      if (!v17) {
        goto LABEL_135;
      }
LABEL_133:
      char v64 = (char *)v17;
LABEL_134:
      free(v64);
      goto LABEL_135;
    }

    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      {
        v48 = *(unsigned __int8 *)(a1 + 40);
        v49 = *(unsigned __int8 *)(a1 + 41);
        string = xpc_dictionary_get_string( *(xpc_object_t *)(a1 + 32),  (const char *)networkd_privileged_key_interface_name);
        *(_DWORD *)buf = 136446978;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 1024;
        *(_DWORD *)v82 = v48;
        *(_WORD *)&v82[4] = 1024;
        *(_DWORD *)&v82[6] = v49;
        *(_WORD *)&v82[10] = 2082;
        *(void *)&v82[12] = string;
        _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_INFO,  "%{public}s Set estimated throughput buckets up: %u, down: %u on %{public}s",  buf,  0x22u);
      }

      goto LABEL_83;
    }

    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
        }

        goto LABEL_135;
      }

      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
          }
        }

        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(void *)&v82[6] = v71;
              _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v71);
            if (!v56) {
              goto LABEL_135;
            }
LABEL_181:
            char v64 = (char *)v56;
            goto LABEL_134;
          }

          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v76,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      free(v38);
      if (!v17) {
        goto LABEL_135;
      }
LABEL_133:
      char v64 = (char *)v17;
LABEL_134:
      free(v64);
      goto LABEL_135;
    }

    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = *(unsigned __int8 *)(a1 + 40);
        v49 = *(unsigned __int8 *)(a1 + 41);
        string = xpc_dictionary_get_string( *(xpc_object_t *)(a1 + 32),  (const char *)networkd_privileged_key_interface_name);
        *(_DWORD *)buf = 136447234;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2082;
        *(void *)v82 = nw_interface_radio_type_to_string(v48);
        *(_WORD *)&v82[8] = 1024;
        *(_DWORD *)&v82[10] = v48;
        *(_WORD *)&v82[14] = 1024;
        *(_DWORD *)&v82[16] = v49;
        v83[0] = 2082;
        *(void *)&v83[1] = string;
        _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}s Set radio type to: %{public}s (%u), channel: %u on %{public}s",  buf,  0x2Cu);
      }

      goto LABEL_83;
    }

    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
        }

        goto LABEL_135;
      }

      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
          }
        }

        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_radio_type_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(void *)&v82[6] = v71;
              _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v71);
            if (!v56) {
              goto LABEL_135;
            }
LABEL_181:
            char v64 = (char *)v56;
            goto LABEL_134;
          }

          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v72,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl( &dword_181A5C000,  v65,  v76,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      goto LABEL_80;
    }

    if (!v53)
    {
      __nwlog_obj();
      v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "-[NWTCPConnection initWithUpgradeForConnection:]";
        v37 = "%{public}s called with null connection.parameters, backtrace limit exceeded";
        goto LABEL_78;
      }

      goto LABEL_79;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v36 = type;
    v49 = os_log_type_enabled(v35, type);
    if (!backtrace_string)
    {
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        v56 = "-[NWTCPConnection initWithUpgradeForConnection:]";
        v37 = "%{public}s called with null connection.parameters, no backtrace";
        goto LABEL_78;
      }

      goto LABEL_79;
    }

    if (!v49) {
      goto LABEL_60;
    }
    *(_DWORD *)buf = 136446466;
    v56 = "-[NWTCPConnection initWithUpgradeForConnection:]";
    uint64_t v57 = 2082;
    uint64_t v58 = backtrace_string;
    v47 = "%{public}s called with null connection.parameters, dumping backtrace:%{public}s";
    goto LABEL_59;
  }

        if (v39) {
          free(v39);
        }
        **(_DWORD **)(a1 + 104) = 0;
        goto LABEL_82;
      }

      if (*(_BYTE *)(a1 + 120))
      {
        if (gLogDatapath)
        {
          v137 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v137, OS_LOG_TYPE_DEBUG))
          {
            v138 = *(void *)(a1 + 56);
            v139 = **(_DWORD **)(a1 + 72);
            *(_DWORD *)buf = 136446722;
            v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            v149 = 2048;
            *(void *)v150 = v138;
            *(_WORD *)&v150[8] = 1024;
            LODWORD(v151) = v139;
            _os_log_impl( &dword_181A5C000,  v137,  OS_LOG_TYPE_DEBUG,  "%{public}s splitting frame %p by offset %d",  buf,  0x1Cu);
          }
        }

        __int16 v12 = *(void *)(a1 + 56);
        v13 = *(void *)(v12 + 32);
        uint64_t v14 = *(void **)(v12 + 40);
        if (v13)
        {
          *(void *)(v13 + 40) = v14;
          uint64_t v14 = *(void **)(v12 + 40);
        }

        else
        {
          *(void *)(*(void *)(a1 + 80) + 8LL) = v14;
        }

        *uint64_t v14 = v13;
        *(void *)(v12 + 32) = 0LL;
        *(void *)(v12 + 40) = 0LL;
        *(void *)os_log_type_t type = *(void *)(a1 + 56);
        BOOL v44 = nw_frame_split((uint64_t *)type, **(_DWORD **)(a1 + 72));
        v45 = *(uint64_t **)(a1 + 80);
        v46 = *(void *)type;
        v47 = *v45;
        v48 = *(void *)type;
        *(void *)(*(void *)type + 32LL) = *v45;
        v49 = v48 + 32;
        if (v47) {
          v50 = (void *)(v47 + 40);
        }
        else {
          v50 = v45 + 1;
        }
        os_log_s *v50 = v49;
        const char *v45 = v46;
        *(void *)(v46 + 40) = v45;
        v51 = *(void *)(a1 + 88);
        *(void *)(v44 + 32) = 0LL;
        os_log_type_t v52 = *(uint64_t **)(v51 + 8);
        *(void *)(v44 + 40) = v52;
        *os_log_type_t v52 = v44;
        *(void *)(v51 + 8) = v44 + 32;
        **(_DWORD **)(a1 + 96) = 0;
        **(_DWORD **)(a1 + 72) = 0;
        os_log_type_t v53 = *(_DWORD **)(a1 + 104);
        if ((*v53)--)
        {
LABEL_130:
          v98 = *(_DWORD **)(a1 + 112);
          v99 = **(_DWORD **)(a1 + 72);
          v34 = __CFADD__(*v98, v99);
          *v98 += v99;
          if (!v34) {
            goto LABEL_149;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v100 = **(unsigned int **)(a1 + 72);
          v101 = (const char *)**(unsigned int **)(a1 + 112);
          *(_DWORD *)buf = 136446978;
          v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v149 = 2082;
          *(void *)v150 = "moved_bytes";
          *(_WORD *)&v150[8] = 2048;
          v151 = v100;
          v152 = 2048;
          v153 = v101;
          v102 = (char *)_os_log_send_and_compose_impl();
          v146 = OS_LOG_TYPE_ERROR;
          v144 = 0;
          if (__nwlog_fault(v102, &v146, &v144))
          {
            if (v146 == OS_LOG_TYPE_FAULT)
            {
              v103 = (os_log_s *)__nwlog_obj();
              v104 = v146;
              if (os_log_type_enabled(v103, v146))
              {
                v105 = **(unsigned int **)(a1 + 72);
                v106 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v105;
                v152 = 2048;
                v153 = v106;
                v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_145:
                _os_log_impl(&dword_181A5C000, v103, v104, v107, buf, 0x2Au);
              }
            }

            else if (v144)
            {
              v108 = (char *)__nw_create_backtrace_string();
              v103 = (os_log_s *)__nwlog_obj();
              v104 = v146;
              v109 = os_log_type_enabled(v103, v146);
              if (v108)
              {
                if (v109)
                {
                  v110 = **(unsigned int **)(a1 + 72);
                  v111 = (const char *)**(unsigned int **)(a1 + 112);
                  *(_DWORD *)buf = 136447234;
                  v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  v149 = 2082;
                  *(void *)v150 = "moved_bytes";
                  *(_WORD *)&v150[8] = 2048;
                  v151 = v110;
                  v152 = 2048;
                  v153 = v111;
                  v154 = 2082;
                  v155 = v108;
                  _os_log_impl( &dword_181A5C000,  v103,  v104,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v108);
                goto LABEL_146;
              }

              if (v109)
              {
                v114 = **(unsigned int **)(a1 + 72);
                v115 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v114;
                v152 = 2048;
                v153 = v115;
                v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_145;
              }
            }

            else
            {
              v103 = (os_log_s *)__nwlog_obj();
              v104 = v146;
              if (os_log_type_enabled(v103, v146))
              {
                v112 = **(unsigned int **)(a1 + 72);
                v113 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v112;
                v152 = 2048;
                v153 = v113;
                v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_145;
              }
            }
          }

    free(backtrace_string);
    if (!v6) {
      return;
    }
LABEL_36:
    free((void *)v6);
    return;
  }

  if (gLogDatapath)
  {
    v30 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      v31 = off_189BB6470[(a2 - 1)];
      *(_DWORD *)buf = 136446466;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v46 = 2080;
      v47 = v31;
      _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_DEBUG, "%{public}s resuming input with result: %s", buf, 0x16u);
    }
  }

  *(_BYTE *)(a1 + 140) = a2;
  if (a2 == 3)
  {
    os_log_type_t v4 = *(_BYTE *)(a1 + 142);
    *(_DWORD *)(a1 + 136) = 0;
    *(_BYTE *)(a1 + 142) = v4 & 0xE3;
  }

  v5 = *(void *)(a1 + 128);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_plugin_metadata_resume_input";
    char v6 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v27 = (os_log_s *)__nwlog_obj();
      int v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin->protocol";
      goto LABEL_104;
    }

    if (!v42)
    {
      BOOL v27 = (os_log_s *)__nwlog_obj();
      int v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin->protocol, backtrace limit exceeded";
      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v27 = (os_log_s *)__nwlog_obj();
    int v28 = type;
    v38 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v38) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin->protocol, no backtrace";
      goto LABEL_104;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v46 = 2082;
      v47 = backtrace_string;
      v37 = "%{public}s called with null metadata_plugin->protocol, dumping backtrace:%{public}s";
      goto LABEL_78;
    }

    goto LABEL_79;
  }

  char v6 = *(void *)(v5 + 48);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "__nw_protocol_input_available";
    char v6 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v27 = (os_log_s *)__nwlog_obj();
      int v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "__nw_protocol_input_available";
      v29 = "%{public}s called with null protocol";
      goto LABEL_104;
    }

    if (!v42)
    {
      BOOL v27 = (os_log_s *)__nwlog_obj();
      int v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "__nw_protocol_input_available";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v27 = (os_log_s *)__nwlog_obj();
    int v28 = type;
    v39 = os_log_type_enabled(v27, type);
    if (backtrace_string)
    {
      if (!v39) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446466;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = backtrace_string;
      v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_78;
    }

    if (!v39) {
      goto LABEL_105;
    }
    *(_DWORD *)buf = 136446210;
    v45 = "__nw_protocol_input_available";
    v29 = "%{public}s called with null protocol, no backtrace";
LABEL_104:
    _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
LABEL_105:
    if (!v6) {
      return;
    }
    goto LABEL_36;
  }

  int v7 = *(void **)(v6 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    char v8 = *(void *)(v6 + 88);
    if (v8) {
      *(void *)(v6 + 88) = v8 + 1;
    }
  }

  v9 = *(void **)(v5 + 40);
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    v10 = *(void *)(v5 + 88);
    if (v10) {
      *(void *)(v5 + 88) = v10 + 1;
    }
  }

  v11 = *(void *)(v6 + 24);
  if (v11)
  {
    __int16 v12 = *(void (**)(uint64_t, uint64_t))(v11 + 64);
    if (v12)
    {
      v12(v6, v5);
      goto LABEL_16;
    }
  }

  __nwlog_obj();
  v21 = *(const char **)(v6 + 16);
  *(_DWORD *)buf = 136446722;
  v45 = "__nw_protocol_input_available";
  if (!v21) {
    v21 = "invalid";
  }
  v46 = 2082;
  v47 = (void *)v21;
  v48 = 2048;
  v49 = v6;
  uint64_t v22 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v22, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v23 = (os_log_s *)__nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_90;
      }
      v25 = *(const char **)(v6 + 16);
      if (!v25) {
        v25 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = (void *)v25;
      v48 = 2048;
      v49 = v6;
      uint64_t v26 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
      goto LABEL_89;
    }

    if (!v42)
    {
      uint64_t v23 = (os_log_s *)__nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_90;
      }
      os_log_type_t v40 = *(const char **)(v6 + 16);
      if (!v40) {
        os_log_type_t v40 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = (void *)v40;
      v48 = 2048;
      v49 = v6;
      uint64_t v26 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_89;
    }

    os_log_type_t v32 = (char *)__nw_create_backtrace_string();
    uint64_t v23 = (os_log_s *)__nwlog_obj();
    v24 = type;
    v33 = os_log_type_enabled(v23, type);
    if (v32)
    {
      if (v33)
      {
        v34 = *(const char **)(v6 + 16);
        if (!v34) {
          v34 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        v45 = "__nw_protocol_input_available";
        v46 = 2082;
        v47 = (void *)v34;
        v48 = 2048;
        v49 = v6;
        v50 = 2082;
        v51 = v32;
        _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v32);
      goto LABEL_90;
    }

    if (v33)
    {
      BOOL v41 = *(const char **)(v6 + 16);
      if (!v41) {
        BOOL v41 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = (void *)v41;
      v48 = 2048;
      v49 = v6;
      uint64_t v26 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
LABEL_89:
      _os_log_impl(&dword_181A5C000, v23, v24, v26, buf, 0x20u);
    }
  }

    if (v52) {
      free(v52);
    }
    goto LABEL_81;
  }

  v20 = v19;
  v21 = v19[231];

  if ((v21 & 4) != 0)
  {
    uint64_t v22 = nw_endpoint_copy_registrar_for_identifier(v20, (__int128 *)a1, 0);
    v71 = v22;
    if (v22)
    {
      instance_to_join = nw_protocol_instance_registrar_find_instance_to_join( v22,  (void *)a1,  a2,  a7,  0,  0,  v75,  v76,  v77,  v18);
      if (instance_to_join)
      {
LABEL_33:

        goto LABEL_34;
      }
    }

    else if (gLogDatapath)
    {
      __nwlog_obj();
      v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v20;
        *(_WORD *)&buf[22] = 2080;
        v84 = (void *)a1;
        LOWORD(v85) = 2048;
        *(void *)((char *)&v85 + 2) = a1;
        _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ does not have registrar for protocol %s (%p), continuing",  buf,  0x2Au);
      }
    }

    v24 = v75;
    v25 = v20;
    uint64_t v26 = v76;
    BOOL v27 = v77;
    int v28 = v24;
    v29 = v25;
    v30 = v26;
    v31 = v27;
    if (gLogDatapath)
    {
      __nwlog_obj();
      v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_edges_for_instance_to_join_inner";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "non-";
        *(_WORD *)&buf[22] = 2112;
        v84 = v29;
        LOWORD(v85) = 2112;
        *(void *)((char *)&v85 + 2) = v30;
        _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s checking %swildcard edges from %@ for destination %@",  buf,  0x2Au);
      }
    }

    *(void *)os_log_type_t type = 0LL;
    v80 = type;
    v81 = 0x2020000000LL;
    v82 = 0LL;
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL70nw_protocol_instance_registrar_search_edges_for_instance_to_join_innerPK22nw_protocol_identifiermPU25objcproto14OS_nw_endpoint8NSObjectS4_S4_PU27objcproto16OS_nw_parametersS2_bb_block_invoke;
    v84 = &unk_189BB6748;
    v90 = 0;
    v87 = type;
    v88 = a1;
    v89 = a2;
    v91 = a7;
    v72 = v28;
    *(void *)&v85 = v72;
    os_log_type_t v32 = v30;
    *((void *)&v85 + 1) = v32;
    v33 = v31;
    v86 = v33;
    v73 = v29;
    nw_endpoint_enumerate_edges(v29, a1, buf);
    instance_to_join = *((void *)v80 + 3);

    _Block_object_dispose(type, 8);
    if (!instance_to_join)
    {
      v34 = v72;
      v35 = v29;
      os_log_type_t v36 = v32;
      v37 = v33;
      v38 = v37;
      if (gLogDatapath)
      {
        v70 = v37;
        __nwlog_obj();
        v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_edges_for_instance_to_join_inner";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&buf[22] = 2112;
          v84 = v35;
          LOWORD(v85) = 2112;
          *(void *)((char *)&v85 + 2) = v36;
          _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_DEBUG,  "%{public}s checking %swildcard edges from %@ for destination %@",  buf,  0x2Au);
        }

        v38 = v70;
      }

      *(void *)os_log_type_t type = 0LL;
      v80 = type;
      v81 = 0x2020000000LL;
      v82 = 0LL;
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL70nw_protocol_instance_registrar_search_edges_for_instance_to_join_innerPK22nw_protocol_identifiermPU25objcproto14OS_nw_endpoint8NSObjectS4_S4_PU27objcproto16OS_nw_parametersS2_bb_block_invoke;
      v84 = &unk_189BB6748;
      v90 = 1;
      v87 = type;
      v88 = a1;
      v89 = a2;
      v91 = a7;
      v39 = v34;
      *(void *)&v85 = v39;
      os_log_type_t v40 = v36;
      *((void *)&v85 + 1) = v40;
      BOOL v41 = v38;
      v86 = v41;
      v42 = v35;
      nw_endpoint_enumerate_edges(v35, a1, buf);
      instance_to_join = *((void *)v80 + 3);

      _Block_object_dispose(type, 8);
    }

    goto LABEL_33;
  }

    goto LABEL_80;
  }

  __nwlog_obj();
  BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v41 = "nw_framer_protocol_connected";
  int v16 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v16, type, &v39))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v41 = "nw_framer_protocol_connected";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v39)
    {
      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v26 = type[0];
      BOOL v27 = os_log_type_enabled(v17, type[0]);
      if (v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v41 = "nw_framer_protocol_connected";
          v42 = 2082;
          os_log_type_t v43 = v25;
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v25);
        goto LABEL_72;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v41 = "nw_framer_protocol_connected";
        _os_log_impl(&dword_181A5C000, v17, v26, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v34 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v41 = "nw_framer_protocol_connected";
        _os_log_impl( &dword_181A5C000,  v17,  v34,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    goto LABEL_80;
  }

  v5 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_establishment_report);
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_establishment_report_create_from_dictionary";
    v33 = (char *)_os_log_send_and_compose_impl();

    uint64_t v57 = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (__nwlog_fault(v33, &v57, &v56))
    {
      if (v57 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v35 = v57;
        if (os_log_type_enabled(v34, v57))
        {
          *(_DWORD *)buf = 136446210;
          v59 = "nw_establishment_report_create_from_dictionary";
          _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s called with null report", buf, 0xCu);
        }
      }

      else if (v56)
      {
        v42 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = v57;
        BOOL v44 = os_log_type_enabled(v34, v57);
        if (v42)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            v59 = "nw_establishment_report_create_from_dictionary";
            v60 = 2082;
            char v61 = v42;
            _os_log_impl( &dword_181A5C000,  v34,  v43,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v42);
          goto LABEL_86;
        }

        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v59 = "nw_establishment_report_create_from_dictionary";
          _os_log_impl(&dword_181A5C000, v34, v43, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = v57;
        if (os_log_type_enabled(v34, v57))
        {
          *(_DWORD *)buf = 136446210;
          v59 = "nw_establishment_report_create_from_dictionary";
          _os_log_impl( &dword_181A5C000,  v34,  v47,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        free(v18);
        goto LABEL_80;
      }

      if (v31)
      {
        *(_DWORD *)v56 = 136446210;
        *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v30, "%{public}s called with null group, no backtrace", v56, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)v56 = 136446210;
        *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl( &dword_181A5C000,  v19,  v43,  "%{public}s called with null group, backtrace limit exceeded",  v56,  0xCu);
      }
    }

    free(v41);
    if (!v28) {
      goto LABEL_31;
    }
    goto LABEL_112;
  }

  v7->preferred_ipv6_address = (OS_nw_endpoint *)a4;
  handle = a3->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = a3[1].callbacks;
    if (callbacks) {
      a3[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
    v10 = -1;
  }

  else
  {
    v10 = 0;
  }

  *(void *)uint64_t v57 = a3;
  uint64_t v58 = v10;
  __int16 v12 = a2->handle;
  if (v12 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v14 = a2[1].callbacks;
    if (v14) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v14->add_input_handler + 1);
    }
    v13 = -1;
  }

  else
  {
    v13 = 0;
  }

  v55 = a2;
  v56 = v13;
  BOOL v15 = a3->callbacks;
  if (v15)
  {
    connected = (void (*)(nw_protocol *, nw_protocol *))v15->connected;
    if (connected)
    {
      connected(a3, a2);
      goto LABEL_17;
    }
  }

  __nwlog_obj();
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  identifier = a3->identifier;
  *(_DWORD *)buf = 136446722;
  v60 = "__nw_protocol_connected";
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  char v61 = 2082;
  os_log_type_t v62 = identifier;
  v63 = 2048;
  char v64 = a3;
  uint64_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v53 = 0;
  if (__nwlog_fault(v23, &type, &v53))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        uint64_t v26 = a3->identifier;
        if (!v26) {
          uint64_t v26 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        v60 = "__nw_protocol_connected";
        char v61 = 2082;
        os_log_type_t v62 = v26;
        v63 = 2048;
        char v64 = a3;
        _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s protocol %{public}s (%p) has invalid connected callback",  buf,  0x20u);
      }
    }

    else if (v53)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      os_log_type_t v36 = os_log_type_enabled(v24, type);
      if (v35)
      {
        if (v36)
        {
          v37 = a3->identifier;
          if (!v37) {
            v37 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446978;
          v60 = "__nw_protocol_connected";
          char v61 = 2082;
          os_log_type_t v62 = v37;
          v63 = 2048;
          char v64 = a3;
          v65 = 2082;
          v66 = (nw_protocol *)v35;
          _os_log_impl( &dword_181A5C000,  v24,  v52,  "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v35);
        goto LABEL_91;
      }

      if (v36)
      {
        v48 = a3->identifier;
        if (!v48) {
          v48 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        v60 = "__nw_protocol_connected";
        char v61 = 2082;
        os_log_type_t v62 = v48;
        v63 = 2048;
        char v64 = a3;
        _os_log_impl( &dword_181A5C000,  v24,  v52,  "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v24, type))
      {
        v47 = a3->identifier;
        if (!v47) {
          v47 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        v60 = "__nw_protocol_connected";
        char v61 = 2082;
        os_log_type_t v62 = v47;
        v63 = 2048;
        char v64 = a3;
        _os_log_impl( &dword_181A5C000,  v24,  v46,  "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v13) {
    free(v13);
  }
}

          goto LABEL_80;
        }

        if (!v37)
        {
          __nwlog_obj();
          v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v36 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl( &dword_181A5C000,  v17,  v36,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_79;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type;
        os_log_type_t v32 = os_log_type_enabled(v17, type);
        if (!backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl( &dword_181A5C000,  v17,  v31,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_79;
        }

        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
          BOOL v41 = 2082;
          v42 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v31,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
        int v16 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v37 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v20 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_79;
        }

        if (!v37)
        {
          __nwlog_obj();
          v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v35 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl( &dword_181A5C000,  v17,  v35,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_79;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v29 = type;
        v30 = os_log_type_enabled(v17, type);
        if (!backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl( &dword_181A5C000,  v17,  v29,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_79;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
          BOOL v41 = 2082;
          v42 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v29,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
      int v16 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_79;
      }

      if (!v37)
      {
        __nwlog_obj();
        v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v34 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
          _os_log_impl( &dword_181A5C000,  v17,  v34,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_79;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = type;
      int v28 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
          _os_log_impl(&dword_181A5C000, v17, v27, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_79;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
        BOOL v41 = 2082;
        v42 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v17,  v27,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_80;
  }

  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
  __int16 v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v12, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v37)
    {
      uint64_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v13, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
          BOOL v41 = 2082;
          v42 = v23;
          _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
        goto LABEL_68;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
        _os_log_impl(&dword_181A5C000, v13, v24, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_implementation_waiting_for_output";
        _os_log_impl( &dword_181A5C000,  v13,  v33,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(v26);
    goto LABEL_99;
  }

  if (v8[2] == &nw_string::_class(void)::instance)
  {
    v10 = objc_getClass((const char *)nw_string::_class(void)::instance);
    if (v10)
    {
      objc_constructInstance(v10, v8);
      return v8;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "operator new";
    v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = (os_log_s *)__nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "operator new";
        v20 = "%{public}s called with null objc_cls";
        goto LABEL_98;
      }

      goto LABEL_99;
    }

    if (!v37)
    {
      v18 = (os_log_s *)__nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "operator new";
        v20 = "%{public}s called with null objc_cls, backtrace limit exceeded";
        goto LABEL_98;
      }

      goto LABEL_99;
    }

    uint64_t v26 = (char *)__nw_create_backtrace_string();
    v18 = (os_log_s *)__nwlog_obj();
    v19 = type;
    v29 = os_log_type_enabled(v18, type);
    if (!v26)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "operator new";
        v20 = "%{public}s called with null objc_cls, no backtrace";
        goto LABEL_98;
      }

      goto LABEL_99;
    }

    if (v29) {
      goto LABEL_44;
    }
    goto LABEL_79;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "operator new";
  v17 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v37)
    {
      v18 = (os_log_s *)__nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "operator new";
        v20 = "%{public}s called with null (obj->m_cls == cls), backtrace limit exceeded";
        goto LABEL_98;
      }

      goto LABEL_99;
    }

    uint64_t v26 = (char *)__nw_create_backtrace_string();
    v18 = (os_log_s *)__nwlog_obj();
    v19 = type;
    BOOL v27 = os_log_type_enabled(v18, type);
    if (!v26)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "operator new";
        v20 = "%{public}s called with null (obj->m_cls == cls), no backtrace";
        goto LABEL_98;
      }

      goto LABEL_99;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "operator new";
      BOOL v41 = 2082;
      v42 = v26;
      int v28 = "%{public}s called with null (obj->m_cls == cls), dumping backtrace:%{public}s";
LABEL_78:
      _os_log_impl(&dword_181A5C000, v18, v19, v28, buf, 0x16u);
      goto LABEL_79;
    }

    goto LABEL_79;
  }

  v18 = (os_log_s *)__nwlog_obj();
  v19 = type;
  if (os_log_type_enabled(v18, type))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "operator new";
    v20 = "%{public}s called with null (obj->m_cls == cls)";
LABEL_98:
    _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
  }

    goto LABEL_80;
  }

  v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    int v7 = nw_endpoint_handler_copy_flow(v5);
    char v8 = (uint64_t *)v7;
    if ((*((_BYTE *)v7 + 35) & 2) != 0)
    {
      v29 = *((void *)v7 + 117);
      if (v29)
      {
        nw_endpoint_handler_unregister_context(v29, v4);
      }

      else
      {
        v34 = v5;
        v35 = *((_BYTE *)v34 + 268);

        if ((v35 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v36 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            v37 = v34;

            v38 = v37;
            v39 = *((_BYTE *)v34 + 268);

            if ((v39 & 1) != 0) {
              os_log_type_t v40 = "dry-run ";
            }
            else {
              os_log_type_t v40 = "";
            }
            BOOL v41 = nw_endpoint_handler_copy_endpoint(v38);
            logging_description = nw_endpoint_get_logging_description(v41);
            id_str = v37->id_str;
            os_log_type_t v43 = v38;
            BOOL v44 = v43;
            v45 = v43[30];
            else {
              v46 = off_189BBBBF0[v45];
            }
            v91 = v46;

            uint64_t v69 = v44;
            v70 = v69;
            v71 = v5->mode;
            v72 = "path";
            switch(v71)
            {
              case 0:
                break;
              case 1:
                v72 = "resolver";
                break;
              case 2:
                v72 = nw_endpoint_flow_mode_string(v69[31]);
                break;
              case 3:
                v72 = "proxy";
                break;
              case 4:
                v72 = "fallback";
                break;
              case 5:
                v72 = "transform";
                break;
              default:
                v72 = "unknown-mode";
                break;
            }

            v77 = v70;
            os_unfair_lock_lock((os_unfair_lock_t)v77 + 28);
            v78 = v77[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v77 + 28);

            *(_DWORD *)buf = 136447746;
            v102 = "nw_endpoint_handler_unregister_context";
            v103 = 2082;
            v104 = id_str;
            v105 = 2082;
            v106 = v40;
            v107 = 2082;
            v108 = (void *)logging_description;
            v109 = 2082;
            v110 = v91;
            v111 = 2082;
            v112 = v72;
            v113 = 2114;
            v114 = v78;
            _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot unregister, no connected handler",  buf,  0x48u);
          }

          goto LABEL_97;
        }
      }
    }

    else if (*((void *)v7 + 96))
    {
      v9 = *((void *)v7 + 108);
      if (v9)
      {
        node = nw_hash_table_get_node(v9, (uint64_t)v4, 0LL);
        if (node)
        {
          v11 = node;
          __int16 v12 = *(void *)(node + 16);
          v13 = *(_WORD *)(v12 + 332);
          *(_WORD *)(v12 + 332) = v13 | 0x100;
          if ((v13 & 0x200) == 0
            && (uint64_t v14 = *(void *)(v12 + 32)) != 0
            && (BOOL v15 = *(void *)(v14 + 24)) != 0
            && *(void *)(v15 + 32))
          {
            int v16 = v5;
            v17 = *((_BYTE *)v16 + 268);

            if ((v17 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v18 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
              {
                id_string = nw_endpoint_handler_get_id_string(v16);
                v89 = nw_endpoint_handler_dry_run_string(v16);
                v93 = id_string;
                v97 = nw_endpoint_handler_copy_endpoint(v16);
                v87 = nw_endpoint_get_logging_description(v97);
                v20 = nw_endpoint_handler_state_string(v16);
                v21 = nw_endpoint_handler_mode_string(v16);
                uint64_t v22 = nw_endpoint_handler_copy_current_path(v16);
                *(_DWORD *)buf = 136448002;
                v102 = "nw_endpoint_handler_unregister_context";
                v103 = 2082;
                v104 = (void *)v93;
                v105 = 2082;
                v106 = v89;
                v107 = 2082;
                v108 = (void *)v87;
                v109 = 2082;
                v110 = v20;
                v111 = 2082;
                v112 = v21;
                v113 = 2114;
                v114 = v22;
                v115 = 2048;
                v116 = v12;
                _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Unregistering protoco l %p by disconnecting",  buf,  0x52u);
              }
            }

            (*(void (**)(uint64_t, uint64_t))(*(void *)(v14 + 24) + 32LL))(v14, v12);
          }

          else
          {
            os_log_type_t v62 = v5;
            v63 = *((_BYTE *)v62 + 268);

            if ((v63 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              char v64 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
              {
                v65 = nw_endpoint_handler_get_id_string(v62);
                v90 = nw_endpoint_handler_dry_run_string(v62);
                v96 = v65;
                v98 = nw_endpoint_handler_copy_endpoint(v62);
                v88 = nw_endpoint_get_logging_description(v98);
                v66 = nw_endpoint_handler_state_string(v62);
                v67 = nw_endpoint_handler_mode_string(v62);
                v68 = nw_endpoint_handler_copy_current_path(v62);
                *(_DWORD *)buf = 136448002;
                v102 = "nw_endpoint_handler_unregister_context";
                v103 = 2082;
                v104 = (void *)v96;
                v105 = 2082;
                v106 = v90;
                v107 = 2082;
                v108 = (void *)v88;
                v109 = 2082;
                v110 = v66;
                v111 = 2082;
                v112 = v67;
                v113 = 2114;
                v114 = v68;
                v115 = 2048;
                v116 = v12;
                _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Unregistering protoco l %p immediately",  buf,  0x52u);
              }
            }

            nw_hash_table_remove_node(v8[108], v11);
          }
        }

        goto LABEL_98;
      }

      v49 = v5;
      v50 = *((_BYTE *)v49 + 268);

      if ((v50 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v36 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          v51 = v49;

          os_log_type_t v52 = v51;
          os_log_type_t v53 = *((_BYTE *)v49 + 268);

          if ((v53 & 1) != 0) {
            uint64_t v54 = "dry-run ";
          }
          else {
            uint64_t v54 = "";
          }
          v55 = nw_endpoint_handler_copy_endpoint(v52);
          v56 = nw_endpoint_get_logging_description(v55);
          v95 = v51->id_str;
          uint64_t v57 = v52;
          uint64_t v58 = v57;
          v59 = v57[30];
          else {
            v60 = off_189BBBBF0[v59];
          }
          v92 = v60;

          v73 = v58;
          v74 = v73;
          v75 = v5->mode;
          v76 = "path";
          switch(v75)
          {
            case 0:
              break;
            case 1:
              v76 = "resolver";
              break;
            case 2:
              v76 = nw_endpoint_flow_mode_string(v73[31]);
              break;
            case 3:
              v76 = "proxy";
              break;
            case 4:
              v76 = "fallback";
              break;
            case 5:
              v76 = "transform";
              break;
            default:
              v76 = "unknown-mode";
              break;
          }

          v79 = v74;
          os_unfair_lock_lock((os_unfair_lock_t)v79 + 28);
          v80 = v79[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v79 + 28);

          *(_DWORD *)buf = 136447746;
          v102 = "nw_endpoint_handler_unregister_context";
          v103 = 2082;
          v104 = v95;
          v105 = 2082;
          v106 = v54;
          v107 = 2082;
          v108 = (void *)v56;
          v109 = 2082;
          v110 = v92;
          v111 = 2082;
          v112 = v76;
          v113 = 2114;
          v114 = v80;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot unregister after flo w table is released",  buf,  0x48u);
        }

          v10 = 0LL;
LABEL_80:

          goto LABEL_81;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_tcp";
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (os_log_s *)(id)gLogObj;
            v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s nw_tcp_create_options failed", buf, 0xCu);
            }
          }

          else if (v59)
          {
            v31 = __nw_create_backtrace_string();
            if (v31)
            {
              os_log_type_t v32 = (char *)v31;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v33 = (os_log_s *)(id)gLogObj;
              v34 = type;
              if (os_log_type_enabled(v33, type))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v62 = "nw_parameters_create_secure_tcp";
                v63 = 2082;
                char v64 = v32;
                _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s nw_tcp_create_options failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v32);
              if (!v23) {
                goto LABEL_79;
              }
              goto LABEL_78;
            }

            __nwlog_obj();
            v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v38 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl( &dword_181A5C000,  v24,  v38,  "%{public}s nw_tcp_create_options failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (os_log_s *)(id)gLogObj;
            os_log_type_t v36 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s nw_tcp_create_options failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v23) {
          goto LABEL_79;
        }
LABEL_78:
        free(v23);
        goto LABEL_79;
      }

      goto LABEL_72;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v62 = "nw_parameters_create_secure_tcp";
    v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (__nwlog_fault(v19, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (os_log_s *)(id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s nw_tls_create_options failed", buf, 0xCu);
        }
      }

      else if (v59)
      {
        uint64_t v26 = __nw_create_backtrace_string();
        if (v26)
        {
          BOOL v27 = (char *)v26;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v28 = (os_log_s *)(id)gLogObj;
          v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v62 = "nw_parameters_create_secure_tcp";
            v63 = 2082;
            char v64 = v27;
            _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s nw_tls_create_options failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v27);
          if (!v19) {
            goto LABEL_72;
          }
          goto LABEL_71;
        }

        __nwlog_obj();
        v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_181A5C000, v20, v37, "%{public}s nw_tls_create_options failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (os_log_s *)(id)gLogObj;
        v35 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl( &dword_181A5C000,  v20,  v35,  "%{public}s nw_tls_create_options failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v19)
    {
LABEL_72:

      goto LABEL_73;
    }

LABEL_80:
      v76 = *(void **)(*(void *)(a1 + 32) + 168LL);
      v77 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
      nw_read_request_report_error_with_override(v76, 0LL, v77);

      v78 = *(void *)(a1 + 32);
      v79 = *(void **)(v78 + 168);
      *(void *)(v78 + 168) = 0LL;

      v80 = *(void **)(*(void *)(a1 + 32) + 160LL);
      v81 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
      nw_write_request_report_error_with_override(v80, 0LL, v81);

      v82 = *(void *)(a1 + 32);
      v83 = *(void **)(v82 + 160);
      *(void *)(v82 + 160) = 0LL;

      v84 = *(void **)(a1 + 32);
      v85 = (void *)v84[18];
      if (v85)
      {
        nw_endpoint_handler_cancel(v85, *(unsigned __int8 *)(a1 + 40), 0);
        v84 = *(void **)(a1 + 32);
      }

      v86 = (void *)v84[22];
      if (v86)
      {
        nw_endpoint_handler_cancel(v86, *(unsigned __int8 *)(a1 + 40), 0);
        v84 = *(void **)(a1 + 32);
      }

      v87 = (void *)v84[7];
      if (v87)
      {
        nw_candidate_manager_cancel(v87);
        v88 = *(void *)(a1 + 32);
        v89 = *(void **)(v88 + 56);
        *(void *)(v88 + 56) = 0LL;

        v84 = *(void **)(a1 + 32);
      }

      v90 = (void *)v84[8];
      v84[8] = 0LL;

      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000LL;
      *(void *)&_BYTE buf[24] = __Block_byref_object_copy__8;
      *(void *)&buf[32] = __Block_byref_object_dispose__9;
      *(void *)&buf[40] = 0LL;
      *(void *)os_log_type_t type = 0LL;
      v142 = (uint64_t)type;
      v143 = 0x3032000000LL;
      v144 = __Block_byref_object_copy__24148;
      v145 = __Block_byref_object_dispose__24149;
      v146 = 0LL;
      v139[0] = 0LL;
      v139[1] = v139;
      v139[2] = 0x3032000000LL;
      v139[3] = __Block_byref_object_copy__24148;
      v139[4] = __Block_byref_object_dispose__24149;
      v140 = 0LL;
      v133 = 0LL;
      v134 = &v133;
      v135 = 0x3032000000LL;
      v136 = __Block_byref_object_copy__24148;
      v137 = __Block_byref_object_dispose__24149;
      v138 = 0LL;
      v131[0] = 0LL;
      v131[1] = v131;
      v131[2] = 0x3032000000LL;
      v131[3] = __Block_byref_object_copy__8;
      v131[4] = __Block_byref_object_dispose__9;
      v132 = 0LL;
      v91 = *(os_unfair_lock_s **)(a1 + 32);
      v92 = v91 + 34;
      v124[0] = v20;
      v124[1] = 3221225472LL;
      v124[2] = ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_233;
      v124[3] = &unk_189BB9B48;
      v126 = buf;
      v125 = v91;
      v127 = type;
      v128 = v139;
      v129 = &v133;
      v130 = v131;
      os_unfair_lock_lock(v92);
      ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_233(v124);
      os_unfair_lock_unlock(v92);
      nw_connection_cancel_update_handler(*(NWConcrete_nw_connection **)(a1 + 32));
      aBlock[0] = v20;
      aBlock[1] = 3221225472LL;
      aBlock[2] = ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_2;
      aBlock[3] = &unk_189BB9B70;
      v120 = *(id *)(a1 + 32);
      v121 = v131;
      v122 = v139;
      v123 = buf;
      v93 = (void (**)(void))_Block_copy(aBlock);
      v94 = *(dispatch_group_s **)(v142 + 40);
      if (v94) {
        dispatch_group_notify(v94, (dispatch_queue_t)v134[5], v93);
      }
      else {
        v93[2](v93);
      }

      _Block_object_dispose(v131, 8);
      _Block_object_dispose(&v133, 8);

      _Block_object_dispose(v139, 8);
      _Block_object_dispose(type, 8);

      _Block_object_dispose(buf, 8);
      v5 = (os_log_s *)v149;
      goto LABEL_90;
    }

    __nwlog_obj();
    v109 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_report_error_to_proxy_agent_on_nw_queue";
    v110 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v139[0]) = 0;
    if (__nwlog_fault(v110, type, v139))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v112 = type[0];
        if (os_log_type_enabled(v111, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_report_error_to_proxy_agent_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v111, v112, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (LOBYTE(v139[0]))
      {
        v115 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v116 = type[0];
        v117 = os_log_type_enabled(v111, type[0]);
        if (v115)
        {
          if (v117)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_report_error_to_proxy_agent_on_nw_queue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v115;
            _os_log_impl( &dword_181A5C000,  v111,  v116,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v115);
          goto LABEL_145;
        }

        if (v117)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_report_error_to_proxy_agent_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v111, v116, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v118 = type[0];
        if (os_log_type_enabled(v111, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_report_error_to_proxy_agent_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v111,  v118,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      free(v45);
    }
  }

    if (v26) {
      free(v26);
    }
    return 0LL;
  }

  if (handle + 192 == (char *)a1)
  {
    if ((handle[529] & 2) != 0) {
      return *((void *)handle + 40);
    }
    char v6 = (nw_protocol *)*((void *)handle + 54);
    if (!v6) {
      return *((void *)handle + 40);
    }
    if (nw_protocol_demux_copy_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
    }
    if (nw_protocol_demux_copy_definition::definition) {
      int v7 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
    }
    else {
      int v7 = 0LL;
    }
    v20 = nw_parameters_copy_protocol_options_legacy(*((void **)handle + 40), v6);
    v21 = v20;
    if (!v20)
    {
      v21 = nw_parameters_copy_protocol_options_for_definition(*((void **)handle + 40), v7);
      if (!v21)
      {
LABEL_112:
        if (v7) {
          os_release(v7);
        }
        return *((void *)handle + 40);
      }
    }

    if (nw_protocol_demux_copy_definition::onceToken == -1)
    {
      uint64_t v22 = (void *)nw_protocol_demux_copy_definition::definition;
      if (nw_protocol_demux_copy_definition::definition) {
        goto LABEL_41;
      }
    }

    else
    {
      dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
      uint64_t v22 = (void *)nw_protocol_demux_copy_definition::definition;
      if (nw_protocol_demux_copy_definition::definition)
      {
LABEL_41:
        uint64_t v23 = os_retain(v22);
        v24 = nw_protocol_options_matches_definition(v21, v23);
        v25 = v24;
        if (v23)
        {
          os_release(v23);
          if (!v25) {
            goto LABEL_111;
          }
        }

        else if (!v24)
        {
          goto LABEL_111;
        }

        goto LABEL_104;
      }
    }

    if (!nw_protocol_options_matches_definition(v21, 0LL))
    {
LABEL_111:
      os_release(v21);
      goto LABEL_112;
    }

      free(backtrace_string);
      goto LABEL_163;
    }

    v19 = v18;
    v20 = v19;
    handle[349] = 0;
    v21 = 84LL;
    uint64_t v22 = 349LL;
    while (1)
    {
      uint64_t v23 = v19[v22 - 301];
      handle[v22] = v23;
      if (!v23) {
        break;
      }
      --v21;
      ++v22;
      if (v21 <= 1)
      {
        handle[v22] = 0;
        break;
      }
    }

    else {
      v24 = 0;
    }
    handle[348] = handle[348] & 0xFD | v24;
    else {
      v25 = 0;
    }
    handle[348] = handle[348] & 0xFB | v25;
    *((void *)handle + 19) = nw_oblivious_http_copy_config(v20);
    *((void *)handle + 8) = nw_oblivious_http_get_context_id(v20);
    handle[292] = handle[292] & 0xFE | nw_oblivious_http_get_config_is_standalone_aead(v20);
    media_os_log_type_t type = (const char *)nw_oblivious_http_get_media_type(v20);
    if (media_type)
    {
      BOOL v27 = strdup(media_type);
      if (!v27)
      {
        os_log_type_t v52 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "strict_strdup";
        os_log_type_t v53 = (void *)_os_log_send_and_compose_impl();
        result = __nwlog_abort((uint64_t)v53);
        if (result) {
          goto LABEL_167;
        }
        free(v53);
      }

      *((void *)handle + 35) = v27;
    }

    request_path = nw_oblivious_http_get_request_path(v20);
    v29 = (void *)_nw_http_request_create("POST", 0LL, 0LL, request_path);
    v30 = v29;
    if ((handle[348] & 2) != 0) {
      v31 = "message/ohttp-chunked-req";
    }
    else {
      v31 = "message/ohttp-req";
    }
    nw_http_fields_append(v29, (uint64_t)"Content-Type", (uint64_t)v31);
    *((void *)handle + 38) = nw_http_create_metadata_for_request(v30);
    if (v30) {
      os_release(v30);
    }
    os_release(v20);
    if (!*((void *)handle + 19))
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      BOOL v44 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v62 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v45 = (os_log_s *)__nwlog_obj();
        v46 = type[0];
        if (!os_log_type_enabled(v45, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        v47 = "%{public}s called with null ohttp->default_context.config";
        goto LABEL_162;
      }

      if (!v62)
      {
        v45 = (os_log_s *)__nwlog_obj();
        v46 = type[0];
        if (!os_log_type_enabled(v45, type[0])) {
          goto LABEL_163;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        v47 = "%{public}s called with null ohttp->default_context.config, backtrace limit exceeded";
        goto LABEL_162;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      v45 = (os_log_s *)__nwlog_obj();
      v46 = type[0];
      uint64_t v58 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (!v58) {
          goto LABEL_163;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        v47 = "%{public}s called with null ohttp->default_context.config, no backtrace";
        goto LABEL_162;
      }

      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v50 = "%{public}s called with null ohttp->default_context.config, dumping backtrace:%{public}s";
        goto LABEL_78;
      }

      goto LABEL_79;
    }

    if (*((void *)handle + 38)) {
      return 1LL;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v62 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v45 = (os_log_s *)__nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null ohttp->oblivious_request_metadata";
      goto LABEL_162;
    }

    if (!v62)
    {
      v45 = (os_log_s *)__nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null ohttp->oblivious_request_metadata, backtrace limit exceeded";
      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v45 = (os_log_s *)__nwlog_obj();
    v46 = type[0];
    v59 = os_log_type_enabled(v45, type[0]);
    if (backtrace_string)
    {
      if (!v59) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      v50 = "%{public}s called with null ohttp->oblivious_request_metadata, dumping backtrace:%{public}s";
      goto LABEL_78;
    }

    if (!v59) {
      goto LABEL_163;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    v47 = "%{public}s called with null ohttp->oblivious_request_metadata, no backtrace";
LABEL_162:
    _os_log_impl(&dword_181A5C000, v45, v46, v47, buf, 0xCu);
LABEL_163:
    if (v44) {
      free(v44);
    }
    return 0LL;
  }

  char v6 = (void *)nw_protocol_get_parameters((uint64_t)a2);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v62 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v45 = (os_log_s *)__nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null parameters";
      goto LABEL_162;
    }

    if (!v62)
    {
      v45 = (os_log_s *)__nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v45 = (os_log_s *)__nwlog_obj();
    v46 = type[0];
    uint64_t v54 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (!v54) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_162;
    }

    if (!v54) {
      goto LABEL_79;
    }
    goto LABEL_117;
  }

  int v7 = nw_parameters_copy_protocol_options_legacy(v6, a1);
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v62 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v45 = (os_log_s *)__nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null ohttp_options";
      goto LABEL_162;
    }

    if (!v62)
    {
      v45 = (os_log_s *)__nwlog_obj();
      v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null ohttp_options, backtrace limit exceeded";
      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v45 = (os_log_s *)__nwlog_obj();
    v46 = type[0];
    v55 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (!v55) {
        goto LABEL_163;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
      v47 = "%{public}s called with null ohttp_options, no backtrace";
      goto LABEL_162;
    }

    if (v55) {
      goto LABEL_121;
    }
    goto LABEL_79;
  }

  char v8 = v7;
  if ((nw_oblivious_http_get_use_context_ids(v7) & 1) == 0)
  {
    if ((handle[348] & 1) != 0) {
      goto LABEL_46;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = handle + 349;
    *(_WORD *)&buf[22] = 2080;
    v68 = " ";
    v13 = "%{public}s %{public}s%sOptions do not enable using context IDs";
    uint64_t v14 = (os_log_s *)v34;
    BOOL v15 = 32;
    goto LABEL_45;
  }

  context_id = nw_oblivious_http_get_context_id(v8);
  if (*((void *)handle + 8) == context_id)
  {
LABEL_12:
    if ((handle[348] & 1) != 0) {
      goto LABEL_46;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = handle + 349;
    *(_WORD *)&buf[22] = 2080;
    v68 = " ";
    LOWORD(v69) = 2048;
    *(void *)((char *)&v69 + 2) = context_id;
    v13 = "%{public}s %{public}s%sContext already added for ID %llu";
    uint64_t v14 = (os_log_s *)v12;
    BOOL v15 = 42;
LABEL_45:
    _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
LABEL_46:
    os_release(v8);
    return 0LL;
  }

  v10 = (char *)*((void *)handle + 37);
  if (!v10) {
    goto LABEL_50;
  }
  *(void *)os_log_type_t type = 0LL;
  char v64 = type;
  v65 = 0x2000000000LL;
  v66 = 0LL;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL44nw_protocol_ohttp_get_context_for_context_idP17nw_protocol_ohttpy_block_invoke;
  v68 = (const char *)&unk_189BBB270;
  *(void *)&uint64_t v69 = type;
  *((void *)&v69 + 1) = context_id;
  nw_hash_table_apply(v10, (uint64_t)buf);
  v11 = *((void *)v64 + 3);
  _Block_object_dispose(type, 8);
  if (v11) {
    goto LABEL_12;
  }
  internal = *((void *)handle + 37);
  if (!internal)
  {
LABEL_50:
    internal = nw_hash_table_create_internal( 5u,  232,  (const void *(*)(const void *, unsigned int *))nw_protocol_get_key,  (unsigned int (*)(const void *, unsigned int))nw_protocol_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_matches_key,  0LL);
    *((void *)handle + 37) = internal;
  }

  type[0] = OS_LOG_TYPE_DEFAULT;
  v37 = nw_hash_table_add_object(internal, (uint64_t)a2, (char *)type);
  os_log_type_t v32 = type[0] != OS_LOG_TYPE_DEFAULT;
  if (type[0] == OS_LOG_TYPE_DEFAULT)
  {
    if ((handle[348] & 1) == 0)
    {
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 349;
        *(_WORD *)&buf[22] = 2080;
        v68 = " ";
        LOWORD(v69) = 1042;
        *(_DWORD *)((char *)&v69 + 2) = 16;
        WORD3(v69) = 2098;
        *((void *)&v69 + 1) = a2;
        _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sInput handler already registered for %{public,uuid_t}.16P",  buf,  0x30u);
      }
    }

    os_release(v8);
    return v32;
  }

  v38 = (void *)v37;
  extra = nw_hash_node_get_extra(v37);
  *(_DWORD *)(extra + 224) = 0;
  *(void *)(extra + 88) = nw_oblivious_http_copy_config(v8);
  *(_BYTE *)(extra + 228) = *(_BYTE *)(extra + 228) & 0xFE | nw_oblivious_http_get_config_is_standalone_aead(v8);
  *(void *)extra = context_id;
  os_log_type_t v40 = (const char *)nw_oblivious_http_get_media_type(v8);
  if (!v40)
  {
LABEL_57:
    *(void *)(extra + 8) = 0LL;
    v42 = (void *)(extra + 8);
    v42[2] = 0LL;
    v42[1] = v42;
    v42[3] = v42 + 2;
    v42[4] = 0LL;
    v42[5] = v42 + 4;
    os_release(v8);
    a2->output_handler_context = v38;
    nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
    return v32;
  }

  BOOL v41 = strdup(v40);
  if (v41)
  {
LABEL_56:
    *(void *)(extra + 216) = v41;
    goto LABEL_57;
  }

  v60 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v60, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  char v61 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v61);
  if (!result)
  {
    free(v61);
    goto LABEL_56;
  }

      goto LABEL_80;
    }

    if (!v45)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_pac_resolver_start";
        _os_log_impl( &dword_181A5C000,  v10,  v32,  "%{public}s CFNetworkExecuteProxyAutoConfigurationURL failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_79;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (os_log_s *)(id)gLogObj;
    v25 = type;
    uint64_t v26 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_pac_resolver_start";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s CFNetworkExecuteProxyAutoConfigurationURL failed, no backtrace",  buf,  0xCu);
      }

      goto LABEL_79;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v49 = "nw_pac_resolver_start";
      v50 = 2082;
      v51 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s CFNetworkExecuteProxyAutoConfigurationURL failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  char v6 = (const __CFString *)*((void *)v1 + 5);
  if (v6)
  {
    clientContext.version = 0LL;
    clientContext.info = v2;
    clientContext.retain = nw_pac_resolver_retain;
    clientContext.release = nw_pac_resolver_release;
    clientContext.copyDescription = 0LL;
    int v7 = CFNetworkExecuteProxyAutoConfigurationScript( v6,  *((CFURLRef *)v2 + 3),  (CFProxyAutoConfigurationResultCallback)nw_pac_resolver_callback,  &clientContext);
    if (v7)
    {
LABEL_73:
      aBlock[0] = MEMORY[0x1895F87A8];
      aBlock[1] = 3221225472LL;
      aBlock[2] = __nw_pac_resolver_start_block_invoke;
      aBlock[3] = &unk_189BC66E8;
      BOOL v44 = v7;
      os_log_type_t v43 = v2;
      v34 = (void (**)(void))_Block_copy(aBlock);
      os_unfair_lock_lock((os_unfair_lock_t)v2 + 20);
      v34[2](v34);
      os_unfair_lock_unlock((os_unfair_lock_t)v2 + 20);

      goto LABEL_82;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_pac_resolver_start";
    v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)(id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_pac_resolver_start";
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s CFNetworkExecuteProxyAutoConfigurationScript failed",  buf,  0xCu);
      }

      goto LABEL_79;
    }

    if (!v45)
    {
      __nwlog_obj();
      v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_pac_resolver_start";
        _os_log_impl( &dword_181A5C000,  v10,  v35,  "%{public}s CFNetworkExecuteProxyAutoConfigurationScript failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_79;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v30 = type;
    v31 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_pac_resolver_start";
        _os_log_impl( &dword_181A5C000,  v10,  v30,  "%{public}s CFNetworkExecuteProxyAutoConfigurationScript failed, no backtrace",  buf,  0xCu);
      }

      goto LABEL_79;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v49 = "nw_pac_resolver_start";
      v50 = 2082;
      v51 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v30,  "%{public}s CFNetworkExecuteProxyAutoConfigurationScript failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  *((void *)handle + 11) = 0LL;
  v49 = v171;
  if (*(_DWORD *)(v171 + 444))
  {
    v50 = *(void *)(v171 + 424);
    if (v50)
    {
LABEL_82:
      nw_protocol_set_input_handler(v49, v50);
      if ((*(_BYTE *)(v49 + 548) & 2) != 0) {
        goto LABEL_86;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = (os_log_s *)v5[131];
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO)) {
        goto LABEL_86;
      }
      os_log_type_t v52 = *(_DWORD *)(v49 + 460);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v49 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v52;
      os_log_type_t v53 = "%{public}s %{public}s%s<i%u> not destroying, still have datagram stream";
      goto LABEL_85;
    }
  }

  else
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v61 = (os_log_s *)v5[131];
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v62 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v62;
        _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> first input handler bailed, closing",  buf,  0x26u);
      }
    }

    v49 = v171;
    v63 = *(void *)(v171 + 432);
    char v64 = *(void **)(v171 + 392);
    v172[0] = MEMORY[0x1895F87A8];
    v172[1] = 0x40000000LL;
    v172[2] = ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke;
    v172[3] = &unk_189BBC460;
    v172[4] = v63;
    nw_queue_context_async(v64, v172);
    v50 = *(void *)(v171 + 424);
    if (v50) {
      goto LABEL_82;
    }
  }

  v65 = *(os_unfair_lock_s **)(v49 + 184);
  if (v65 && v65[10]._os_unfair_lock_opaque)
  {
    some_node = nw_hash_table_get_some_node(v65);
    object = nw_hash_node_get_object(some_node);
    nw_protocol_set_input_handler(v171, object);
    if ((*(_BYTE *)(v171 + 548) & 2) != 0) {
      goto LABEL_86;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (os_log_s *)v5[131];
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO)) {
      goto LABEL_86;
    }
    v68 = *(_DWORD *)(v171 + 460);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
    v186 = 2082;
    v187 = (const char *)(v171 + 464);
    v188 = 2080;
    v189 = (uint64_t)" ";
    v190 = 1024;
    *(_DWORD *)v191 = v68;
    os_log_type_t v53 = "%{public}s %{public}s%s<i%u> not destroying, still have active streams";
    goto LABEL_85;
  }

  v76 = v171;
  if (!*(_DWORD *)(v171 + 456))
  {
    v79 = *(void *)(v171 + 416);
    if (v79)
    {
      nw_protocol_set_input_handler(v171, v79);
      if ((*(_BYTE *)(v171 + 548) & 2) != 0) {
        goto LABEL_86;
      }
      v51 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO)) {
        goto LABEL_86;
      }
      v80 = *(_DWORD *)(v171 + 460);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v171 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v80;
      os_log_type_t v53 = "%{public}s %{public}s%s<i%u> not destroying, still have placeholder stream";
      goto LABEL_85;
    }

    nw_protocol_set_input_handler(v171, 0LL);
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      v81 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
      {
        v82 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v82;
        _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> called, destroying session",  buf,  0x26u);
      }
    }

    *(void *)buf = 0LL;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 344, buf);
    *(void *)buf = 0LL;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 360, buf);
    *(void *)buf = 0LL;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 376, buf);
    nw_http_capsule_framer_cleanup((void *)(v171 + 96), v83);
    v84 = *(void *)(v171 + 400);
    if (v84) {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v84 + 8LL))(v84, v171, 0LL);
    }
    if ((*(_BYTE *)(v171 + 548) & 4) != 0)
    {
      if ((nw_protocol_remove_listen_handler(*(void *)(v171 + 408), v171 + 64) & 1) == 0
        && (*(_BYTE *)(v171 + 548) & 2) == 0)
      {
        v85 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
        {
          v86 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v86;
          _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> failed to remove listen handler",  buf,  0x26u);
        }
      }

      *(void *)(v171 + 408) = 0LL;
    }

    v87 = *(void *)(v171 + 32);
    if (v87) {
      nw_protocol_remove_input_handler(v87, v171);
    }
    v179 = 0LL;
    v180 = &v179;
    v181 = 0x2000000000LL;
    v182 = 0LL;
    v88 = *(char **)(v171 + 184);
    if (v88)
    {
      *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
      v174 = 0x40000000LL;
      v175 = ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke;
      v176 = &unk_189BBC4A8;
      v177 = &v179;
      v178 = v171;
      nw_hash_table_apply(v88, (uint64_t)type);
      v90 = *(os_unfair_lock_s **)(v171 + 184);
      if (v90)
      {
        _nw_hash_table_release(v90, v89);
        *(void *)(v171 + 184) = 0LL;
      }
    }

    v91 = *(void *)(v171 + 328);
    v180[3] = v91;
    if (!v91)
    {
      (*(void (**)(void, void))(*(void *)(v171 + 432) + 16LL))(*(void *)(v171 + 432), 0LL);
      v136 = *(const void **)(v171 + 432);
      if (v136)
      {
        _Block_release(v136);
        *(void *)(v171 + 432) = 0LL;
      }

      std::destroy_at[abi:nn180100]<nw_webtransport_session,0>(v171);
      free((void *)v171);
      _Block_object_dispose(&v179, 8);
      goto LABEL_86;
    }

    while (1)
    {
      v91 = *(void *)(v91 + 112);
      if ((*(_BYTE *)(v76 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v92 = (os_log_s *)v5[131];
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          v93 = *(_DWORD *)(v76 + 460);
          v94 = v180[3];
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v93;
          *(_WORD *)&v191[4] = 2048;
          *(void *)&v191[6] = v94;
          _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways",  buf,  0x30u);
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
      v95 = (char *)_os_log_send_and_compose_impl();
      v184 = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (__nwlog_fault(v95, &v184, &v183))
      {
        if (v184 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v96 = gLogObj;
          v97 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184)) {
            goto LABEL_167;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v98 = (os_log_s *)v96;
          v99 = v97;
          v100 = "%{public}s should not have streams left when destroying";
LABEL_166:
          _os_log_impl(&dword_181A5C000, v98, v99, v100, buf, 0xCu);
          goto LABEL_167;
        }

        if (!v183)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v105 = gLogObj;
          v106 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184)) {
            goto LABEL_167;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v98 = (os_log_s *)v105;
          v99 = v106;
          v100 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
          goto LABEL_166;
        }

        v101 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v102 = (os_log_s *)gLogObj;
        v103 = v184;
        v104 = os_log_type_enabled((os_log_t)gLogObj, v184);
        if (!v101)
        {
          if (!v104) {
            goto LABEL_167;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v98 = v102;
          v99 = v103;
          v100 = "%{public}s should not have streams left when destroying, no backtrace";
          goto LABEL_166;
        }

        if (v104)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = v101;
          _os_log_impl( &dword_181A5C000,  v102,  v103,  "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v101);
      }

  *((void *)handle + 11) = 0LL;
  v49 = v171;
  if (*(_DWORD *)(v171 + 444))
  {
    v50 = *(void *)(v171 + 424);
    if (v50)
    {
LABEL_82:
      nw_protocol_set_input_handler(v49, v50);
      if ((*(_BYTE *)(v49 + 548) & 2) != 0) {
        goto LABEL_86;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = (os_log_s *)v5[131];
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO)) {
        goto LABEL_86;
      }
      os_log_type_t v52 = *(_DWORD *)(v49 + 460);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v49 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v52;
      os_log_type_t v53 = "%{public}s %{public}s%s<i%u> not destroying, still have datagram stream";
      goto LABEL_85;
    }
  }

  else
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v61 = (os_log_s *)v5[131];
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v62 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v62;
        _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> first input handler bailed, closing",  buf,  0x26u);
      }
    }

    v49 = v171;
    v63 = *(void *)(v171 + 432);
    char v64 = *(void **)(v171 + 392);
    v172[0] = MEMORY[0x1895F87A8];
    v172[1] = 0x40000000LL;
    v172[2] = ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke;
    v172[3] = &unk_189BBC460;
    v172[4] = v63;
    nw_queue_context_async(v64, v172);
    v50 = *(void *)(v171 + 424);
    if (v50) {
      goto LABEL_82;
    }
  }

  v65 = *(os_unfair_lock_s **)(v49 + 184);
  if (v65 && v65[10]._os_unfair_lock_opaque)
  {
    some_node = nw_hash_table_get_some_node(v65);
    object = nw_hash_node_get_object(some_node);
    nw_protocol_set_input_handler(v171, object);
    if ((*(_BYTE *)(v171 + 548) & 2) != 0) {
      goto LABEL_86;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (os_log_s *)v5[131];
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO)) {
      goto LABEL_86;
    }
    v68 = *(_DWORD *)(v171 + 460);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
    v186 = 2082;
    v187 = (const char *)(v171 + 464);
    v188 = 2080;
    v189 = (uint64_t)" ";
    v190 = 1024;
    *(_DWORD *)v191 = v68;
    os_log_type_t v53 = "%{public}s %{public}s%s<i%u> not destroying, still have active streams";
    goto LABEL_85;
  }

  v76 = v171;
  if (!*(_DWORD *)(v171 + 456))
  {
    v79 = *(void *)(v171 + 416);
    if (v79)
    {
      nw_protocol_set_input_handler(v171, v79);
      if ((*(_BYTE *)(v171 + 548) & 2) != 0) {
        goto LABEL_86;
      }
      v51 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO)) {
        goto LABEL_86;
      }
      v80 = *(_DWORD *)(v171 + 460);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v171 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v80;
      os_log_type_t v53 = "%{public}s %{public}s%s<i%u> not destroying, still have placeholder stream";
      goto LABEL_85;
    }

    nw_protocol_set_input_handler(v171, 0LL);
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      v81 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
      {
        v82 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v82;
        _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> called, destroying session",  buf,  0x26u);
      }
    }

    *(void *)buf = 0LL;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 344, buf);
    *(void *)buf = 0LL;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 360, buf);
    *(void *)buf = 0LL;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 376, buf);
    nw_http_capsule_framer_cleanup((void *)(v171 + 96), v83);
    v84 = *(void *)(v171 + 400);
    if (v84) {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v84 + 8LL))(v84, v171, 0LL);
    }
    if ((*(_BYTE *)(v171 + 548) & 4) != 0)
    {
      if ((nw_protocol_remove_listen_handler(*(void *)(v171 + 408), v171 + 64) & 1) == 0
        && (*(_BYTE *)(v171 + 548) & 2) == 0)
      {
        v85 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
        {
          v86 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v86;
          _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> failed to remove listen handler",  buf,  0x26u);
        }
      }

      *(void *)(v171 + 408) = 0LL;
    }

    v87 = *(void *)(v171 + 32);
    if (v87) {
      nw_protocol_remove_input_handler(v87, v171);
    }
    v179 = 0LL;
    v180 = &v179;
    v181 = 0x2000000000LL;
    v182 = 0LL;
    v88 = *(char **)(v171 + 184);
    if (v88)
    {
      *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
      v174 = 0x40000000LL;
      v175 = ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke;
      v176 = &unk_189BBC4A8;
      v177 = &v179;
      v178 = v171;
      nw_hash_table_apply(v88, (uint64_t)type);
      v90 = *(os_unfair_lock_s **)(v171 + 184);
      if (v90)
      {
        _nw_hash_table_release(v90, v89);
        *(void *)(v171 + 184) = 0LL;
      }
    }

    v91 = *(void *)(v171 + 328);
    v180[3] = v91;
    if (!v91)
    {
      (*(void (**)(void, void))(*(void *)(v171 + 432) + 16LL))(*(void *)(v171 + 432), 0LL);
      v136 = *(const void **)(v171 + 432);
      if (v136)
      {
        _Block_release(v136);
        *(void *)(v171 + 432) = 0LL;
      }

      std::destroy_at[abi:nn180100]<nw_webtransport_session,0>(v171);
      free((void *)v171);
      _Block_object_dispose(&v179, 8);
      goto LABEL_86;
    }

    while (1)
    {
      v91 = *(void *)(v91 + 112);
      if ((*(_BYTE *)(v76 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v92 = (os_log_s *)v5[131];
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          v93 = *(_DWORD *)(v76 + 460);
          v94 = v180[3];
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v93;
          *(_WORD *)&v191[4] = 2048;
          *(void *)&v191[6] = v94;
          _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways",  buf,  0x30u);
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
      v95 = (char *)_os_log_send_and_compose_impl();
      v184 = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (__nwlog_fault(v95, &v184, &v183))
      {
        if (v184 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v96 = gLogObj;
          v97 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184)) {
            goto LABEL_167;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v98 = (os_log_s *)v96;
          v99 = v97;
          v100 = "%{public}s should not have streams left when destroying";
LABEL_166:
          _os_log_impl(&dword_181A5C000, v98, v99, v100, buf, 0xCu);
          goto LABEL_167;
        }

        if (!v183)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v105 = gLogObj;
          v106 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184)) {
            goto LABEL_167;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v98 = (os_log_s *)v105;
          v99 = v106;
          v100 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
          goto LABEL_166;
        }

        v101 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v102 = (os_log_s *)gLogObj;
        v103 = v184;
        v104 = os_log_type_enabled((os_log_t)gLogObj, v184);
        if (!v101)
        {
          if (!v104) {
            goto LABEL_167;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v98 = v102;
          v99 = v103;
          v100 = "%{public}s should not have streams left when destroying, no backtrace";
          goto LABEL_166;
        }

        if (v104)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = v101;
          _os_log_impl( &dword_181A5C000,  v102,  v103,  "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v101);
      }

          v46 = mach_continuous_time();
          if (v46 <= 1) {
            v47 = 1LL;
          }
          else {
            v47 = v46;
          }
          *(void *)handle = v47;
          *((_DWORD *)handle + 70) = 1;
          v25 = (uint64_t)handle;
          uint64_t v22 = 0LL;
          goto LABEL_83;
        }

        if ((*((_WORD *)handle + 184) & 0x80) != 0) {
          goto LABEL_79;
        }
        v37 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446722;
        v117 = "nw_http_connect_keep_path_flow_registration_open";
        v118 = 2082;
        v119 = handle + 284;
        v120 = 2080;
        v121 = " ";
        v38 = "%{public}s %{public}s%sUnable to get parameters";
      }

      else
      {
        if ((*((_WORD *)handle + 184) & 0x80) != 0) {
          goto LABEL_79;
        }
        v37 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446722;
        v117 = "nw_http_connect_keep_path_flow_registration_open";
        v118 = 2082;
        v119 = handle + 284;
        v120 = 2080;
        v121 = " ";
        v38 = "%{public}s %{public}s%sUnable to get path";
      }

  PBDataWriterWriteBOOLField();
  has = (__int16)self->_has;
  if ((has & 0x200) == 0)
  {
LABEL_24:
    if ((has & 8) == 0) {
      goto LABEL_25;
    }
    goto LABEL_81;
  }

  if (nw_proxy_config_get_int64(v5, (uint64_t)@"TransportConverterEnable", 0LL))
  {
    nw_proxy_config_get_array(v5);
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    if (v59)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_proxy_configs_create_with_schema_array_block_invoke_90;
      applier[3] = &unk_189BC5120;
      v78 = v5;
      v79 = *(id *)(a1 + 32);
      xpc_array_apply(v59, applier);
    }
  }

  v60 = 1LL;
LABEL_88:

  return v60;
}

      free(v22);
      if (!v12) {
        goto LABEL_100;
      }
      goto LABEL_99;
    }

    v13 = (os_log_s *)__nwlog_obj();
    uint64_t v14 = type;
    if (!os_log_type_enabled(v13, type)) {
      goto LABEL_98;
    }
    *(_DWORD *)buf = 136446210;
    v38 = "nw_http1_get_http1_protocol";
    BOOL v15 = "%{public}s called with null handle";
LABEL_97:
    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_98;
  }

  v5 = *((_DWORD *)v3 + 6);
  if (v5 == 1) {
    goto LABEL_10;
  }
  if (v5 != 2)
  {
    if (v5 != 3)
    {
LABEL_100:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_http1_accept";
      int v16 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v35 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (os_log_s *)gLogObj;
        v18 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_115;
        }
        *(_DWORD *)buf = 136446210;
        v38 = "nw_protocol_http1_accept";
        v19 = "%{public}s called with null http1";
        goto LABEL_114;
      }

      if (!v35)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (os_log_s *)gLogObj;
        v18 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_115;
        }
        *(_DWORD *)buf = 136446210;
        v38 = "nw_protocol_http1_accept";
        v19 = "%{public}s called with null http1, backtrace limit exceeded";
        goto LABEL_114;
      }

      v25 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (os_log_s *)gLogObj;
      v18 = type;
      v34 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v25)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v38 = "nw_protocol_http1_accept";
          v39 = 2082;
          os_log_type_t v40 = v25;
          BOOL v27 = "%{public}s called with null http1, dumping backtrace:%{public}s";
          goto LABEL_108;
        }

        goto LABEL_109;
      }

      if (!v34) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_http1_accept";
      v19 = "%{public}s called with null http1, no backtrace";
      goto LABEL_114;
    }

    char v6 = v3[2];
    if (v6)
    {
      id v3 = (uint64_t *)(v6 + 480);
      goto LABEL_10;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_http1_get_http1_protocol";
    __int16 v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = (os_log_s *)__nwlog_obj();
      uint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_http1_get_http1_protocol";
      BOOL v15 = "%{public}s called with null handle->http1_connection";
      goto LABEL_97;
    }

    if (!v35)
    {
      v13 = (os_log_s *)__nwlog_obj();
      uint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_http1_get_http1_protocol";
      BOOL v15 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
      goto LABEL_97;
    }

    uint64_t v22 = (char *)__nw_create_backtrace_string();
    v13 = (os_log_s *)__nwlog_obj();
    uint64_t v14 = type;
    os_log_type_t v32 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (!v32) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_http1_get_http1_protocol";
      BOOL v15 = "%{public}s called with null handle->http1_connection, no backtrace";
      goto LABEL_97;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_http1_get_http1_protocol";
      v39 = 2082;
      os_log_type_t v40 = v22;
      v24 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
      goto LABEL_78;
    }

    goto LABEL_79;
  }

  int v7 = v3[1];
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_http1_get_http1_protocol";
    __int16 v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = (os_log_s *)__nwlog_obj();
      uint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_http1_get_http1_protocol";
      BOOL v15 = "%{public}s called with null handle->http1_stream";
      goto LABEL_97;
    }

    if (!v35)
    {
      v13 = (os_log_s *)__nwlog_obj();
      uint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_http1_get_http1_protocol";
      BOOL v15 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_97;
    }

    uint64_t v22 = (char *)__nw_create_backtrace_string();
    v13 = (os_log_s *)__nwlog_obj();
    uint64_t v14 = type;
    v33 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (!v33) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      v38 = "nw_http1_get_http1_protocol";
      BOOL v15 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_97;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_http1_get_http1_protocol";
      v39 = 2082;
      os_log_type_t v40 = v22;
      v24 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_78;
    }

    goto LABEL_79;
  }

  id v3 = (uint64_t *)(v7 + 248);
LABEL_10:
  char v8 = *v3;
  if (!*v3) {
    goto LABEL_100;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_http1_accept";
    int v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        v17 = (os_log_s *)__nwlog_obj();
        v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_115;
        }
        *(_DWORD *)buf = 136446210;
        v38 = "nw_protocol_http1_accept";
        v19 = "%{public}s called with null endpoint, backtrace limit exceeded";
        goto LABEL_114;
      }

      v25 = (char *)__nw_create_backtrace_string();
      v17 = (os_log_s *)__nwlog_obj();
      v18 = type;
      uint64_t v26 = os_log_type_enabled(v17, type);
      if (!v25)
      {
        if (!v26) {
          goto LABEL_115;
        }
        *(_DWORD *)buf = 136446210;
        v38 = "nw_protocol_http1_accept";
        v19 = "%{public}s called with null endpoint, no backtrace";
        goto LABEL_114;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v38 = "nw_protocol_http1_accept";
        v39 = 2082;
        os_log_type_t v40 = v25;
        BOOL v27 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
LABEL_108:
        _os_log_impl(&dword_181A5C000, v17, v18, v27, buf, 0x16u);
      }

    if (!v39) {
      goto LABEL_36;
    }
    v37 = (char *)v39;
    goto LABEL_35;
  }

  if (!a2)
  {
    __nwlog_obj();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v64 = "nw_endpoint_host_endpoint_matches_hostname";
    v39 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault(v39, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)buf = 136446210;
          char v64 = "nw_endpoint_host_endpoint_matches_hostname";
          _os_log_impl(&dword_181A5C000, v40, v43, "%{public}s called with null hostname", buf, 0xCu);
        }

    goto LABEL_44;
  }

  if (!v39)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)(id)gLogObj;
    v25 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v42 = "nw_utilities_get_c_string_from_cfstring";
      _os_log_impl( &dword_181A5C000,  v12,  v25,  "%{public}s CFStringGetMaximumSizeForEncoding failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_79;
  }

  v18 = __nw_create_backtrace_string();
  if (!v18)
  {
    __nwlog_obj();
    __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v26 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v42 = "nw_utilities_get_c_string_from_cfstring";
      _os_log_impl( &dword_181A5C000,  v12,  v26,  "%{public}s CFStringGetMaximumSizeForEncoding failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_79;
  }

  v19 = (char *)v18;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = (os_log_s *)(id)gLogObj;
  v21 = type;
  if (os_log_type_enabled(v20, type))
  {
    *(_DWORD *)buf = 136446466;
    v42 = "nw_utilities_get_c_string_from_cfstring";
    os_log_type_t v43 = 2082;
    BOOL v44 = v19;
    _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s CFStringGetMaximumSizeForEncoding failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v19);
  if (v10) {
    goto LABEL_45;
  }
LABEL_46:
}

        if (v27) {
          free(v27);
        }
LABEL_81:
        LODWORD(v19) = 0;
        goto LABEL_82;
      }

      LODWORD(v68) = 0x10000000;
      if (!*(void *)v3) {
        goto LABEL_52;
      }
      int v16 = xpc_string_get_string_ptr(*(xpc_object_t *)v3);
      if (!v16) {
        goto LABEL_52;
      }
      v17 = v16;
      v18 = strlen(v16);
      v19 = v18;
      if (v18)
      {
        if (v18 >= 0xFF)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446466;
          os_log_type_t v62 = "nw_socksv4_send_connect";
          v63 = 2048;
          char v64 = v19;
          v20 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v59 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v21 = (os_log_s *)gLogObj;
            uint64_t v22 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_50;
            }
            *(_DWORD *)buf = 136446466;
            os_log_type_t v62 = "nw_socksv4_send_connect";
            v63 = 2048;
            char v64 = v19;
            uint64_t v23 = "%{public}s SOCKS (by host) username has invalid length %zu";
          }

          else if (v59)
          {
            v31 = (char *)__nw_create_backtrace_string();
            v21 = (os_log_s *)__nwlog_obj();
            uint64_t v22 = type;
            os_log_type_t v32 = os_log_type_enabled(v21, type);
            if (v31)
            {
              if (v32)
              {
                *(_DWORD *)buf = 136446722;
                os_log_type_t v62 = "nw_socksv4_send_connect";
                v63 = 2048;
                char v64 = v19;
                v65 = 2082;
                v66 = v31;
                _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s SOCKS (by host) username has invalid length %zu, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v31);
              goto LABEL_50;
            }

            if (!v32)
            {
LABEL_50:
              if (v20) {
                free(v20);
              }
LABEL_52:
              LODWORD(v19) = 0;
              goto LABEL_53;
            }

            *(_DWORD *)buf = 136446466;
            os_log_type_t v62 = "nw_socksv4_send_connect";
            v63 = 2048;
            char v64 = v19;
            uint64_t v23 = "%{public}s SOCKS (by host) username has invalid length %zu, no backtrace";
          }

          else
          {
            v21 = (os_log_s *)__nwlog_obj();
            uint64_t v22 = type;
            if (!os_log_type_enabled(v21, type)) {
              goto LABEL_50;
            }
            *(_DWORD *)buf = 136446466;
            os_log_type_t v62 = "nw_socksv4_send_connect";
            v63 = 2048;
            char v64 = v19;
            uint64_t v23 = "%{public}s SOCKS (by host) username has invalid length %zu, backtrace limit exceeded";
          }

          _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0x16u);
          goto LABEL_50;
        }

        memcpy((char *)&v68 + 4, v17, v18);
      }

    free(backtrace_string);
    goto LABEL_80;
  }

  if (!a2)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v21 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s called with null max_stream_data_bidirectional_local",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    if (!v55)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v48,  "%{public}s called with null max_stream_data_bidirectional_local, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v35 = v56;
    os_log_type_t v36 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v35,  "%{public}s called with null max_stream_data_bidirectional_local, no backtrace",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v18,  v35,  "%{public}s called with null max_stream_data_bidirectional_local, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_79;
  }

  if (!a3)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v23 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null max_stream_data_bidirectional_remote",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    if (!v55)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v49 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v49,  "%{public}s called with null max_stream_data_bidirectional_remote, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v37 = v56;
    v38 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v37,  "%{public}s called with null max_stream_data_bidirectional_remote, no backtrace",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v18,  v37,  "%{public}s called with null max_stream_data_bidirectional_remote, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_79;
  }

  if (!a4)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v25 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_181A5C000, v18, v25, "%{public}s called with null max_data", buf, 0xCu);
      }

      goto LABEL_124;
    }

    if (!v55)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v50 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v50,  "%{public}s called with null max_data, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v39 = v56;
    os_log_type_t v40 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_181A5C000, v18, v39, "%{public}s called with null max_data, no backtrace", buf, 0xCu);
      }

      goto LABEL_124;
    }

    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v18,  v39,  "%{public}s called with null max_data, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_79;
  }

  if (!a5)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_181A5C000, v18, v27, "%{public}s called with null max_data_unidirectional", buf, 0xCu);
      }

      goto LABEL_124;
    }

    if (!v55)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v51,  "%{public}s called with null max_data_unidirectional, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v41 = v56;
    v42 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v41,  "%{public}s called with null max_data_unidirectional, no backtrace",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v18,  v41,  "%{public}s called with null max_data_unidirectional, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_79;
  }

  if (!a6)
  {
    __nwlog_obj();
    int v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v29 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_181A5C000, v18, v29, "%{public}s called with null max_streams_bidirectional", buf, 0xCu);
      }

      goto LABEL_124;
    }

    if (!v55)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v52,  "%{public}s called with null max_streams_bidirectional, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v43 = v56;
    BOOL v44 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl( &dword_181A5C000,  v18,  v43,  "%{public}s called with null max_streams_bidirectional, no backtrace",  buf,  0xCu);
      }

      goto LABEL_124;
    }

    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v18,  v43,  "%{public}s called with null max_streams_bidirectional, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_79;
  }

  if (a7)
  {
    v54[0] = MEMORY[0x1895F87A8];
    v54[1] = 3221225472LL;
    v54[2] = __nw_quic_get_remote_transport_parameters_block_invoke;
    v54[3] = &__block_descriptor_80_e9_B16__0_v8l;
    v54[4] = a2;
    v54[5] = a3;
    v54[6] = a4;
    v54[7] = a5;
    v54[8] = a6;
    v54[9] = a7;
    uint64_t v14 = nw_protocol_options_access_handle(v13, v54);
    goto LABEL_9;
  }

  __nwlog_obj();
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v58 = "nw_quic_get_remote_transport_parameters";
  v17 = (char *)_os_log_send_and_compose_impl();

  v56 = OS_LOG_TYPE_ERROR;
  v55 = 0;
  if (__nwlog_fault(v17, &v56, &v55))
  {
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_181A5C000, v18, v31, "%{public}s called with null max_streams_unidirectional", buf, 0xCu);
      }

          nw_protocol_set_flow_id_from_protocol(a1, a2);
          a1[2].identifier = a2;
          if (nw_socket_initialize_socket(a1))
          {
            a1[3].output_handler_context = (void *)0x100000001LL;
            if (!*(void *)&a2->level)
            {
              *(void *)&a2->level = a1;
              if (a1->handle == &nw_protocol_ref_counted_handle)
              {
                callbacks = a1[1].callbacks;
                if (callbacks) {
                  a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                }
              }
            }

            return 1LL;
          }

          if ((*(_WORD *)v33 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            BOOL v44 = gconnectionLogObj;
            result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
            if (result)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v69 = "nw_socket_add_input_handler";
              v70 = 2082;
              v71 = v20;
              uint64_t v26 = "%{public}s %{public}s Failed to initialize socket";
              BOOL v27 = (os_log_s *)v44;
              goto LABEL_90;
            }

            return result;
          }

          return 0LL;
        }
      }
    }
  }

  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) != 0) {
    return 0LL;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v24 = gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v69 = "nw_socket_add_input_handler";
    v70 = 2082;
    v71 = (char *)&a1[6].identifier + 4;
    uint64_t v26 = "%{public}s %{public}s Parameters are NULL when adding input_handler";
    BOOL v27 = (os_log_s *)v24;
LABEL_90:
    _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_ERROR, v26, buf, 0x16u);
    return 0LL;
  }

  return result;
}

        goto LABEL_80;
      }

      if (!v283.sa_len)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v48 = (os_log_s *)(id)gLogObj;
        v55 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          v56 = v7->sa_len;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v13;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v16;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = v305;
          *(_WORD *)&buf[38] = 1040;
          *(_DWORD *)v297 = v56;
          *(_WORD *)&v297[4] = 2098;
          *(void *)&v297[6] = v7;
          v298 = 1040;
          v299 = address[0];
          v300 = 2098;
          v301 = address;
          _os_log_impl( &dword_181A5C000,  v48,  v55,  "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{publi c,network:sockaddr}.*P, backtrace limit exceeded",  buf,  0x46u);
        }

        goto LABEL_79;
      }

      v51 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = (os_log_s *)(id)gLogObj;
      os_log_type_t v52 = type[0];
      os_log_type_t v53 = os_log_type_enabled(v48, type[0]);
      if (!v51)
      {
        if (v53)
        {
          char v61 = v7->sa_len;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v13;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v16;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = v305;
          *(_WORD *)&buf[38] = 1040;
          *(_DWORD *)v297 = v61;
          *(_WORD *)&v297[4] = 2098;
          *(void *)&v297[6] = v7;
          v298 = 1040;
          v299 = address[0];
          v300 = 2098;
          v301 = address;
          _os_log_impl( &dword_181A5C000,  v48,  v52,  "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{publi c,network:sockaddr}.*P, no backtrace",  buf,  0x46u);
        }

        goto LABEL_79;
      }

      if (v53)
      {
        uint64_t v54 = v7->sa_len;
        *(_DWORD *)buf = 136448258;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v13;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v16;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v305;
        *(_WORD *)&buf[38] = 1040;
        *(_DWORD *)v297 = v54;
        *(_WORD *)&v297[4] = 2098;
        *(void *)&v297[6] = v7;
        v298 = 1040;
        v299 = address[0];
        v300 = 2098;
        v301 = address;
        v302 = 2082;
        v303 = v51;
        _os_log_impl( &dword_181A5C000,  v48,  v52,  "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{public, network:sockaddr}.*P, dumping backtrace:%{public}s",  buf,  0x50u);
      }

      free(v51);
      if (!v47) {
        goto LABEL_82;
      }
LABEL_81:
      free(v47);
      goto LABEL_82;
    }

    if (v22) {
      free(v22);
    }
    BOOL v15 = 0LL;
    goto LABEL_33;
  }

  v59 = 0LL;
  v60 = &v59;
  char v61 = 0x2020000000LL;
  id v3 = 13LL;
  os_log_type_t v62 = 13LL;
  *(void *)os_log_type_t type = 0LL;
  uint64_t v54 = type;
  v55 = 0x3032000000LL;
  v56 = __Block_byref_object_copy__67543;
  uint64_t v57 = __Block_byref_object_dispose__67544;
  uint64_t v58 = 0LL;
  os_log_type_t v4 = (unsigned __int8 *)*((void *)v1 + 2);
  if (v4)
  {
    v52[0] = MEMORY[0x1895F87A8];
    v52[1] = 3221225472LL;
    v52[2] = __nw_path_override_info_copy_data_block_invoke;
    v52[3] = &unk_189BC52F8;
    v52[4] = type;
    v52[5] = &v59;
    nw_array_apply(v4, (uint64_t)v52);
    id v3 = v60[3];
    if (!v3)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v66 = "strict_malloc";
      uint64_t v26 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v26);
      if (result) {
        goto LABEL_91;
      }
      free(v26);
      id v3 = 0LL;
    }
  }

  v5 = (char *)malloc(v3);
  if (v5)
  {
    char v6 = v5;
    v48 = 0LL;
    v49 = &v48;
    v50 = 0x2020000000LL;
    v51 = v5;
    int v7 = v60;
    char v8 = v60[3];
    v9 = &v5[v8];
    if (v8 > 0)
    {
      if ((unint64_t)v8 > 0xC)
      {
        os_unfair_lock_s *v5 = 1;
        *(_DWORD *)(v5 + 1) = 8;
        *(void *)(v5 + 5) = v2[1];
        v51 = v5 + 13;
        uint64_t v14 = (unsigned __int8 *)*((void *)v54 + 5);
        if (v14)
        {
          v47[0] = MEMORY[0x1895F87A8];
          v47[1] = 3221225472LL;
          v47[2] = __nw_path_override_info_copy_data_block_invoke_2;
          v47[3] = &unk_189BC5320;
          v47[4] = &v48;
          v47[5] = &v59;
          v47[6] = v6;
          nw_array_apply(v14, (uint64_t)v47);
          if (!v49[3])
          {
LABEL_31:
            free(v6);
            BOOL v15 = 0LL;
            goto LABEL_32;
          }

          int v7 = v60;
        }

        BOOL v15 = dispatch_data_create(v6, v7[3], 0LL, 0LL);
        free(v6);
LABEL_32:
        _Block_object_dispose(&v48, 8);
        _Block_object_dispose(type, 8);

        _Block_object_dispose(&v59, 8);
LABEL_33:

        return (BOOL)v15;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      *(_DWORD *)buf = 136447490;
      v66 = "nw_necp_append_tlv";
      v67 = 2048;
      v68 = (size_t)v6;
      uint64_t v69 = 2048;
      v70 = 13LL;
      v71 = 2048;
      *(void *)v72 = v9;
      *(_WORD *)&v72[8] = 1024;
      *(_DWORD *)v73 = 1;
      *(_WORD *)&v73[4] = 1024;
      *(_DWORD *)&v73[6] = 8;
      v11 = (char *)_os_log_send_and_compose_impl();

      char v64 = OS_LOG_TYPE_ERROR;
      v63 = 0;
      if (__nwlog_fault(v11, &v64, &v63))
      {
        if (v64 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v12 = (os_log_s *)(id)gLogObj;
          v13 = v64;
          if (os_log_type_enabled(v12, v64))
          {
            *(_DWORD *)buf = 136447490;
            v66 = "nw_necp_append_tlv";
            v67 = 2048;
            v68 = (size_t)v6;
            uint64_t v69 = 2048;
            v70 = 13LL;
            v71 = 2048;
            *(void *)v72 = v9;
            *(_WORD *)&v72[8] = 1024;
            *(_DWORD *)v73 = 1;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = 8;
            _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
          }
        }

        else if (v63)
        {
          int v16 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v12 = (os_log_s *)(id)gLogObj;
          v17 = v64;
          v18 = os_log_type_enabled(v12, v64);
          if (v16)
          {
            if (v18)
            {
              *(_DWORD *)buf = 136447746;
              v66 = "nw_necp_append_tlv";
              v67 = 2048;
              v68 = (size_t)v6;
              uint64_t v69 = 2048;
              v70 = 13LL;
              v71 = 2048;
              *(void *)v72 = v9;
              *(_WORD *)&v72[8] = 1024;
              *(_DWORD *)v73 = 1;
              *(_WORD *)&v73[4] = 1024;
              *(_DWORD *)&v73[6] = 8;
              v74 = 2082;
              v75 = v16;
              _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
            }

            free(v16);
            if (!v11) {
              goto LABEL_30;
            }
            goto LABEL_29;
          }

          if (v18)
          {
            *(_DWORD *)buf = 136447490;
            v66 = "nw_necp_append_tlv";
            v67 = 2048;
            v68 = (size_t)v6;
            uint64_t v69 = 2048;
            v70 = 13LL;
            v71 = 2048;
            *(void *)v72 = v9;
            *(_WORD *)&v72[8] = 1024;
            *(_DWORD *)v73 = 1;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = 8;
            _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v12 = (os_log_s *)(id)gLogObj;
          v19 = v64;
          if (os_log_type_enabled(v12, v64))
          {
            *(_DWORD *)buf = 136447490;
            v66 = "nw_necp_append_tlv";
            v67 = 2048;
            v68 = (size_t)v6;
            uint64_t v69 = 2048;
            v70 = 13LL;
            v71 = 2048;
            *(void *)v72 = v9;
            *(_WORD *)&v72[8] = 1024;
            *(_DWORD *)v73 = 1;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = 8;
            _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
          }
        }

        goto LABEL_27;
      }

    free(v45);
    goto LABEL_80;
  }

  if (!identifier)
  {
    __nwlog_obj();
    v108 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v150 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v109 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v106, v109, "%{public}s called with null identifier", buf, 0xCu);
      }

      goto LABEL_203;
    }

    if (!v150)
    {
      __nwlog_obj();
      v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v124 = type;
      if (os_log_type_enabled(v106, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl( &dword_181A5C000,  v106,  v124,  "%{public}s called with null identifier, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_203;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v117 = type;
    v118 = os_log_type_enabled(v46, type);
    if (!backtrace_string)
    {
      if (v118)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_181A5C000, v46, v117, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }

      goto LABEL_220;
    }

    if (v118)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v153 = 2082;
      v154 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v46,  v117,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
    }

      goto LABEL_120;
    }

    __int16 v12 = (void *)v5[5];
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      v34 = v5[11];
      if (v34) {
        v5[11] = v34 + 1;
      }
      v13 = -1;
    }

    else
    {
      v13 = 0;
    }

    *(void *)buf = v5;
    buf[8] = v13;
    v35 = (void *)*((void *)v4 + 52);
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      v37 = *((void *)v4 + 58);
      if (v37) {
        *((void *)v4 + 58) = v37 + 1;
      }
      os_log_type_t v36 = -1;
    }

    else
    {
      os_log_type_t v36 = 0;
    }

    *(void *)os_log_type_t type = (char *)v4 + 376;
    v87 = v36;
    v38 = v11();
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v12 != &nw_protocol_ref_counted_handle)
      {
LABEL_50:
        if ((v38 & 1) != 0) {
          goto LABEL_79;
        }
        goto LABEL_54;
      }
    }

    else if (v12 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_50;
    }

    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if ((v38 & 1) != 0) {
      goto LABEL_79;
    }
    goto LABEL_54;
  }

      goto LABEL_120;
    }

    __int16 v12 = (void *)v5[5];
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      v34 = v5[11];
      if (v34) {
        v5[11] = v34 + 1;
      }
      v13 = -1;
    }

    else
    {
      v13 = 0;
    }

    *(void *)buf = v5;
    buf[8] = v13;
    v35 = (void *)*((void *)v4 + 52);
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      v37 = *((void *)v4 + 58);
      if (v37) {
        *((void *)v4 + 58) = v37 + 1;
      }
      os_log_type_t v36 = -1;
    }

    else
    {
      os_log_type_t v36 = 0;
    }

    *(void *)os_log_type_t type = (char *)v4 + 376;
    v87 = v36;
    v38 = v11();
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v12 != &nw_protocol_ref_counted_handle)
      {
LABEL_50:
        if ((v38 & 1) != 0) {
          goto LABEL_79;
        }
        goto LABEL_54;
      }
    }

    else if (v12 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_50;
    }

    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if ((v38 & 1) != 0) {
      goto LABEL_79;
    }
    goto LABEL_54;
  }

    if (v23) {
      free(v23);
    }
    goto LABEL_81;
  }

  v9 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v35 = "nw_network_agent_add_to_interface_internal";
  os_log_type_t v36 = 1024;
  *(_DWORD *)v37 = v9;
  v18 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v33 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v18, type, &v33))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (os_log_s *)gLogObj;
      v20 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446466;
      v35 = "nw_network_agent_add_to_interface_internal";
      os_log_type_t v36 = 1024;
      *(_DWORD *)v37 = v9;
      v21 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
      goto LABEL_71;
    }

    if (v33 == OS_LOG_TYPE_DEFAULT)
    {
      v19 = (os_log_s *)__nwlog_obj();
      v20 = type[0];
      if (!os_log_type_enabled(v19, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446466;
      v35 = "nw_network_agent_add_to_interface_internal";
      os_log_type_t v36 = 1024;
      *(_DWORD *)v37 = v9;
      v21 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_71;
    }

    BOOL v27 = (char *)__nw_create_backtrace_string();
    v19 = (os_log_s *)__nwlog_obj();
    v20 = type[0];
    int v28 = os_log_type_enabled(v19, type[0]);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446722;
        v35 = "nw_network_agent_add_to_interface_internal";
        os_log_type_t v36 = 1024;
        *(_DWORD *)v37 = v9;
        *(_WORD *)&v37[4] = 2082;
        *(void *)&v37[6] = v27;
        _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v27);
      goto LABEL_72;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_network_agent_add_to_interface_internal";
      os_log_type_t v36 = 1024;
      *(_DWORD *)v37 = v9;
      v21 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
LABEL_71:
      _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0x12u);
    }
  }

      free(v35);
      if (!v25) {
        return;
      }
LABEL_106:
      v18 = (nw_protocol *)v25;
LABEL_35:
      free(v18);
      return;
    }

    uint64_t v26 = (os_log_s *)__nwlog_obj();
    BOOL v27 = type;
    if (!os_log_type_enabled(v26, type)) {
      goto LABEL_105;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "nw_protocol_test_disconnected";
    int v28 = "%{public}s called with null test";
LABEL_104:
    _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
    goto LABEL_105;
  }

  if (gLogDatapath)
  {
    v29 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "nw_protocol_test_disconnected";
      v45 = 2082;
      v46 = a1 + 2;
      _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s disconnected", buf, 0x16u);
    }
  }

  BYTE5(a1[3].identifier) |= 2u;
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "__nw_protocol_disconnected";
    v25 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      BOOL v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "__nw_protocol_disconnected";
      int v28 = "%{public}s called with null protocol";
      goto LABEL_104;
    }

    if (!v41)
    {
      uint64_t v26 = (os_log_s *)__nwlog_obj();
      BOOL v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "__nw_protocol_disconnected";
      int v28 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_104;
    }

    v35 = (char *)__nw_create_backtrace_string();
    uint64_t v26 = (os_log_s *)__nwlog_obj();
    BOOL v27 = type;
    v38 = os_log_type_enabled(v26, type);
    if (!v35)
    {
      if (!v38) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "__nw_protocol_disconnected";
      int v28 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_104;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v35;
      v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_78;
    }

    goto LABEL_79;
  }

  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = default_input_handler[1].callbacks;
    if (callbacks) {
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
  }

  char v6 = a1->handle;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    int v7 = a1[1].callbacks;
    if (v7) {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
    }
  }

  char v8 = default_input_handler->callbacks;
  if (v8)
  {
    disconnected = (void (*)(nw_protocol *, nw_protocol *))v8->disconnected;
    if (disconnected)
    {
      disconnected(default_input_handler, a1);
      goto LABEL_14;
    }
  }

  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  BOOL v44 = "__nw_protocol_disconnected";
  if (!name) {
    name = "invalid";
  }
  v45 = 2082;
  v46 = (nw_protocol *)name;
  v47 = 2048;
  v48 = default_input_handler;
  v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v41 = 0;
  if (__nwlog_fault(v20, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_90;
      }
      uint64_t v23 = default_input_handler->identifier->name;
      if (!v23) {
        uint64_t v23 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      BOOL v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v23;
      v47 = 2048;
      v48 = default_input_handler;
      v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
      goto LABEL_89;
    }

    if (!v41)
    {
      v21 = (os_log_s *)__nwlog_obj();
      uint64_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_90;
      }
      v39 = default_input_handler->identifier->name;
      if (!v39) {
        v39 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      BOOL v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v39;
      v47 = 2048;
      v48 = default_input_handler;
      v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_89;
    }

    v30 = (char *)__nw_create_backtrace_string();
    v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    v31 = os_log_type_enabled(v21, type);
    if (v30)
    {
      if (v31)
      {
        os_log_type_t v32 = default_input_handler->identifier->name;
        if (!v32) {
          os_log_type_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        BOOL v44 = "__nw_protocol_disconnected";
        v45 = 2082;
        v46 = (nw_protocol *)v32;
        v47 = 2048;
        v48 = default_input_handler;
        v49 = 2082;
        v50 = v30;
        _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_90;
    }

    if (v31)
    {
      os_log_type_t v40 = default_input_handler->identifier->name;
      if (!v40) {
        os_log_type_t v40 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      BOOL v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v40;
      v47 = 2048;
      v48 = default_input_handler;
      v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_89:
      _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x20u);
    }
  }

void sub_181A63C9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_locked(void *a1, void *a2)
{
  os_log_type_t v4 = a1;
  id v3 = a2;
  os_unfair_lock_lock(v4 + 44);
  v3[2](v3);

  os_unfair_lock_unlock(v4 + 44);
}

void sub_181A63DB8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_has_associations_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  object = (void *)nw_hash_node_get_object(a2);
  if (!nw_association_is_empty(object) || nw_hash_table_remove_node(*(void *)(*(void *)(a1 + 32) + 200LL), a2)) {
    return 1LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  logging_description = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
  *(_DWORD *)buf = 136446722;
  uint64_t v22 = "nw_endpoint_has_associations_block_invoke";
  __int16 v23 = 2082;
  v24 = logging_description;
  __int16 v25 = 2048;
  uint64_t v26 = a2;
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v7, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        v10 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446722;
        uint64_t v22 = "nw_endpoint_has_associations_block_invoke";
        __int16 v23 = 2082;
        v24 = v10;
        __int16 v25 = 2048;
        uint64_t v26 = a2;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s %{public}s failed to remove association for node %p",  buf,  0x20u);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          BOOL v15 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
          *(_DWORD *)buf = 136446978;
          uint64_t v22 = "nw_endpoint_has_associations_block_invoke";
          __int16 v23 = 2082;
          v24 = v15;
          __int16 v25 = 2048;
          uint64_t v26 = a2;
          __int16 v27 = 2082;
          int v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s %{public}s failed to remove association for node %p, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
        if (v7) {
          goto LABEL_9;
        }
        return 1LL;
      }

      if (v14)
      {
        v18 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446722;
        uint64_t v22 = "nw_endpoint_has_associations_block_invoke";
        __int16 v23 = 2082;
        v24 = v18;
        __int16 v25 = 2048;
        uint64_t v26 = a2;
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s %{public}s failed to remove association for node %p, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v8, type))
      {
        v17 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446722;
        uint64_t v22 = "nw_endpoint_has_associations_block_invoke";
        __int16 v23 = 2082;
        v24 = v17;
        __int16 v25 = 2048;
        uint64_t v26 = a2;
        _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s %{public}s failed to remove association for node %p, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v7) {
LABEL_9:
  }
    free(v7);
  return 1LL;
}

void sub_181A6416C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_association_is_empty(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    id v3 = nw_path_parameters_copy_context(v1[2]);
    nw_context_assert_queue(v3);
    os_log_type_t v4 = v2[7];
    if (v4 && v4[10])
    {
      time_t v5 = time(0LL);
      char v6 = (char *)v2[7];
      v18[0] = MEMORY[0x1895F87A8];
      v18[1] = 3221225472LL;
      v18[2] = __nw_association_is_empty_block_invoke;
      v18[3] = &unk_189BC86A0;
      time_t v21 = v5;
      id v19 = v3;
      v20 = v2;
      nw_hash_table_apply(v6, (uint64_t)v18);
    }

    if ((*((_BYTE *)v2 + 76) & 1) != 0)
    {
      char v8 = v2[7];
      if (v8) {
        BOOL v7 = v8[10] == 0;
      }
      else {
        BOOL v7 = 1LL;
      }
    }

    else
    {
      BOOL v7 = 0LL;
    }

    goto LABEL_11;
  }

  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v25 = "nw_association_is_empty";
  v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v23 = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v11, &v23, &v22))
  {
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v23;
      if (os_log_type_enabled(v12, v23))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_association_is_empty";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null association", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v23;
      BOOL v16 = os_log_type_enabled(v12, v23);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v25 = "nw_association_is_empty";
          __int16 v26 = 2082;
          __int16 v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null association, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_association_is_empty";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = v23;
      if (os_log_type_enabled(v12, v23))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_association_is_empty";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null association, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_28:
  if (v11) {
    free(v11);
  }
  BOOL v7 = 0LL;
LABEL_11:

  return v7;
}

    free(v23);
    goto LABEL_29;
  }

  __nwlog_obj();
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v42 = "nw_protocol_transform_copy";
  os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v32, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s called with null transform", buf, 0xCu);
      }
    }

    else if (v39)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      v37 = os_log_type_enabled(v33, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v42 = "nw_protocol_transform_copy";
          os_log_type_t v43 = 2082;
          BOOL v44 = v35;
          _os_log_impl( &dword_181A5C000,  v33,  v36,  "%{public}s called with null transform, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v35);
        goto LABEL_47;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_181A5C000, v33, v36, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_transform_copy";
        _os_log_impl( &dword_181A5C000,  v33,  v38,  "%{public}s called with null transform, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  __break(1u);
  return result;
}

    if (v12) {
      free(v12);
    }
    goto LABEL_7;
  }

  *((_WORD *)v4 + 114) = *((_WORD *)v3 + 114);
  objc_storeStrong(v4 + 2, *((id *)v3 + 2));
  *((_DWORD *)v5 + 6) = *((_DWORD *)v3 + 6);
  objc_storeStrong(v5 + 23, *((id *)v3 + 23));
  objc_storeStrong(v5 + 24, *((id *)v3 + 24));
  *(_OWORD *)((char *)v5 + 28) = *(_OWORD *)(v3 + 28);
  objc_storeStrong(v5 + 1, *((id *)v3 + 1));
  char v6 = v3[231] & 1 | *((_BYTE *)v5 + 231);
  *((_BYTE *)v5 + 231) = v6;
  *((_BYTE *)v5 + 231) = v3[231] & 2 | v6 & 0xFD;
  objc_storeStrong(v5 + 14, *((id *)v3 + 14));
  *((_BYTE *)v5 + 231) = *((_BYTE *)v5 + 231) & 0xDF | v3[231] & 0x20;
  objc_storeStrong(v5 + 15, *((id *)v3 + 15));
  *((_DWORD *)v5 + 56) = *((_DWORD *)v3 + 56);
  BOOL v7 = (char *)*((void *)v3 + 11);
  if (v7)
  {
    BOOL v7 = strdup(v7);
    if (!v7)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "strict_strdup";
      BOOL v16 = (void *)_os_log_send_and_compose_impl();

      free(v16);
      BOOL v7 = 0LL;
    }
  }

  v5[11] = v7;
  char v8 = (char *)*((void *)v3 + 12);
  if (!v8) {
    goto LABEL_6;
  }
  char v8 = strdup(v8);
  if (v8) {
    goto LABEL_6;
  }
  __nwlog_obj();
  os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v28 = "strict_strdup";
  v18 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v18))
  {
    free(v18);
    char v8 = 0LL;
LABEL_6:
    v5[12] = v8;
    os_log_type_t v9 = *((_BYTE *)v5 + 231) & 0xBF | (((v3[231] >> 6) & 1) << 6);
    *((_BYTE *)v5 + 231) = *((_BYTE *)v5 + 231) & 0xBF | (((v3[231] & 0x40) != 0) << 6);
    *((_BYTE *)v5 + 231) = v3[231] & 0x80 | v9 & 0x7F;
    *(_OWORD *)((char *)v5 + 28) = *(_OWORD *)(v3 + 28);
    nw_endpoint_set_device_id(v5, *((const char **)v3 + 13));
    v10 = nw_endpoint_copy_public_keys(v3);
    nw_endpoint_set_public_keys(v5, v10);

    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 3221225472LL;
    v23[2] = __nw_endpoint_copy_properties_block_invoke;
    v23[3] = &unk_189BB6E70;
    v24 = v5;
    nw_endpoint_enumerate_alternatives(v3, v23);

LABEL_7:
    return;
  }

  if (v9) {
    free(v9);
  }
  time_t v5 = 0LL;
LABEL_10:

  return v5;
}

      goto LABEL_29;
    }

    v66 = v16;
    __nwlog_obj();
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
    uint64_t v57 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (__nwlog_fault(v57, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_181A5C000, v58, v59, "%{public}s called with null association", buf, 0xCu);
        }
      }

      else if (v68)
      {
        v60 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v61 = type;
        os_log_type_t v62 = os_log_type_enabled(v58, type);
        if (v60)
        {
          if (v62)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v60;
            _os_log_impl( &dword_181A5C000,  v58,  v61,  "%{public}s called with null association, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v60);
          goto LABEL_83;
        }

        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_181A5C000, v58, v61, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl( &dword_181A5C000,  v58,  v63,  "%{public}s called with null association, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v19) {
    free(v19);
  }
  BOOL v16 = 0LL;
LABEL_11:

  return v16;
}

    free(v10);
    goto LABEL_29;
  }

  sa_family = address->sa_family;
  char v8 = sa_family != 2 && sa_family != 30;
LABEL_30:

  return v8;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_30;
  }

  id v3 = *(void *)(v1[13] + 176LL);
  if (!v3)
  {
LABEL_30:
    time_t v5 = 0LL;
    goto LABEL_31;
  }

  os_log_type_t v4 = *(void **)(v3 + 8);
  if (v4 && xpc_array_get_count(v4))
  {
    time_t v5 = 1LL;
  }

  else
  {
    char v6 = v2;
    BOOL v7 = v2[13];
    time_t v5 = (*(_WORD *)(v7 + 108) & 8) == 0 && !*(_DWORD *)(v7 + 80) && !*(void *)(v7 + 168) && (v6[97] & 0x80) == 0;
  }

    if (*(_DWORD *)(v2 + 116) == 2 && nw_endpoint_flow_should_ignore_path_result(*(void **)(v2 + 248)))
    {
      v24 = 0;
      v432 = 0LL;
      v433 = &v432;
      v434 = 0x2020000000LL;
      v435 = 0;
      time_t v5 = 1;
LABEL_58:
      if (nw_parameters_get_attribution(*(nw_parameters_t *)(v2 + 32)) == nw_parameters_attribution_developer
        && nw_endpoint_get_type(*(nw_endpoint_t *)(v2 + 24)) == nw_endpoint_type_host)
      {
        memset(buf, 0, 88);
        nw_parameters_to_ne_app_context(*(void **)(v2 + 32), (uint64_t)buf);
        nw_endpoint_get_hostname(*(nw_endpoint_t *)(v2 + 24));
        if (ne_tracker_check_is_hostname_blocked() == 1)
        {
          if ((*(_BYTE *)(v2 + 268) & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v51 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              if ((*((_BYTE *)v424 + 268) & 1) != 0) {
                os_log_type_t v52 = "dry-run ";
              }
              else {
                os_log_type_t v52 = "";
              }
              os_log_type_t v53 = nw_endpoint_handler_copy_endpoint(v424);
              uint64_t v54 = nw_endpoint_get_logging_description(v53);
              v55 = v424->state;
              else {
                v56 = off_189BBBBF0[v55];
              }
              v167 = v424;
              v168 = (os_unfair_lock_s *)v167;
              v169 = "path";
              switch(v424->mode)
              {
                case 0:
                  break;
                case 1:
                  v169 = "resolver";
                  break;
                case 2:
                  v169 = nw_endpoint_flow_mode_string(v167->mode_handler);
                  break;
                case 3:
                  v169 = "proxy";
                  break;
                case 4:
                  v169 = "fallback";
                  break;
                case 5:
                  v169 = "transform";
                  break;
                default:
                  v169 = "unknown-mode";
                  break;
              }

              v203 = v168 + 28;
              v204 = v168;
              os_unfair_lock_lock(v168 + 28);
              v205 = v424->current_path;
              os_unfair_lock_unlock(v203);

              LODWORD(v436[0]) = 136447746;
              *(void *)((char *)v436 + 4) = "nw_endpoint_handler_path_change";
              WORD2(v436[1]) = 2082;
              *(void *)((char *)&v436[1] + 6) = v424->id_str;
              HIWORD(v436[2]) = 2082;
              v437 = v52;
              v438 = 2082;
              v439 = v54;
              v440 = 2082;
              v441 = v56;
              v442 = 2082;
              v443 = v169;
              v444 = 2114;
              v445 = v205;
              _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] blocked tracker",  (uint8_t *)v436,  0x48u);
            }

            v2 = (uint64_t)v424;
          }

          goto LABEL_271;
        }
      }

      if (nw_parameters_get_block_trackers(*(void **)(v2 + 32))
        && nw_parameters_get_is_known_tracker(*(void **)(v2 + 32))
        && nw_endpoint_get_can_block_request(*(void **)(v2 + 24))
        && !nw_endpoint_hostname_matches_tracker(*(void **)(v2 + 24)))
      {
LABEL_271:
        nw_endpoint_handler_handle_failure(v2);
        v206 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 50);
        *(_DWORD *)(v2 + 80) = 589825;
        nw_endpoint_handler_report((void *)v2, 0LL, (_WORD *)(v2 + 80), v206);

LABEL_440:
        v2 = (uint64_t)v424;
        goto LABEL_441;
      }

      has_custom_proxy_configs = nw_parameters_has_custom_proxy_configs(*(void **)(v2 + 32));
      if (v5 == 3)
      {
        if (nw_endpoint_handler_triggered_agents_updated((NWConcrete_nw_endpoint_handler *)v2))
        {
          uint64_t v58 = (char *)(id)v2;
          v59 = v58;
          v60 = *(void **)(v2 + 32);
          if (v60)
          {
            char v61 = v60;
            os_log_type_t v62 = (v61[12] & 0x4000000000LL) == 0;

            if (!v62)
            {
              v2 = (uint64_t)v424;
              if ((nw_endpoint_handler_get_logging_disabled(v59) & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v63 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
                {
                  id_string = nw_endpoint_handler_get_id_string(v59);
                  v65 = nw_endpoint_handler_dry_run_string(v59);
                  v66 = nw_endpoint_handler_copy_endpoint(v59);
                  v67 = nw_endpoint_get_logging_description(v66);
                  v68 = nw_endpoint_handler_state_string(v59);
                  uint64_t v69 = nw_endpoint_handler_mode_string(v59);
                  v70 = nw_endpoint_handler_copy_current_path(v59);
                  LODWORD(buf[0]) = 136447746;
                  *(void *)((char *)buf + 4) = "nw_endpoint_handler_path_change";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = id_string;
                  HIWORD(buf[2]) = 2082;
                  buf[3] = v65;
                  LOWORD(buf[4]) = 2082;
                  *(void *)((char *)&buf[4] + 2) = v67;
                  WORD1(buf[5]) = 2082;
                  *(void *)((char *)&buf[5] + 4) = v68;
                  WORD2(buf[6]) = 2082;
                  *(void *)((char *)&buf[6] + 6) = v69;
                  HIWORD(buf[7]) = 2114;
                  buf[8] = v70;
                  _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] agents failed to become active",  (uint8_t *)buf,  0x48u);
                }

      hostname = 0LL;
    }
  }

    if (v10) {
      free(v10);
    }
    time_t v5 = 0LL;
    goto LABEL_11;
  }

  id v3 = v1[136];
  if ((v3 & 0x48) != 0x40) {
    goto LABEL_5;
  }
  if (dispatch_workloop_is_current())
  {
    id v3 = v2[136];
LABEL_5:
    if (v3 < 0)
    {
      time_t v5 = 1LL;
    }

    else
    {
      os_log_type_t v4 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
      time_t v5 = *(char *)(v4 + 136) < 0;
    }

    goto LABEL_11;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v2 + 20);
  char v6 = (char)v2[136];
  if ((v6 & 0x80000000) == 0)
  {
    BOOL v7 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
    LOBYTE(v6) = *(_BYTE *)(v7 + 136);
  }

  time_t v5 = (v6 & 0x80u) != 0;
  os_unfair_lock_unlock((os_unfair_lock_t)v2 + 20);
LABEL_11:

  return v5;
}

  if (*a1 >= 0x1Du)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    time_t v21 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      char v22 = *a1;
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "sa_dst_cache_create";
      v45 = 1024;
      LODWORD(v46) = v22;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s (dst_sa->sa_len %u > sizeof(cache_entry->dce_entry.d_dst.addr))",  buf,  0x12u);
    }

    goto LABEL_31;
  }

  os_log_type_t v23 = (char *)calloc(1uLL, 0x70uLL);
  if (v23)
  {
    v24 = (uint64_t)v23;
    __int16 v25 = (unsigned __int8 *)(v23 + 16);
    memcpy(v23 + 16, a1, *a1);
    *(_DWORD *)(v24 + 88) = a2;
    sa_dst_fill_netsrc(v25);
    __int16 v26 = *(_OWORD *)(v24 + 32);
    *a3 = *(_OWORD *)(v24 + 16);
    a3[1] = v26;
    __int16 v27 = *(_OWORD *)(v24 + 48);
    uint64_t v28 = *(_OWORD *)(v24 + 64);
    uint64_t v29 = *(_OWORD *)(v24 + 96);
    a3[4] = *(_OWORD *)(v24 + 80);
    a3[5] = v29;
    a3[2] = v27;
    a3[3] = v28;
    v30 = mach_absolute_time();
    v31 = cache;
    *(void *)v24 = v30;
    *(void *)(v24 + 8) = v31;
    cache = v24;
    v20 = 2LL;
    goto LABEL_34;
  }

  v33 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  BOOL v44 = "strict_calloc";
  v45 = 2048;
  v46 = 1LL;
  v47 = 2048;
  v48 = 112LL;
  v34 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v34);
  if (result)
  {
    __break(1u);
  }

  else
  {
    free(v34);
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    BOOL v44 = "sa_dst_cache_create";
    v45 = 2048;
    v46 = 112LL;
    v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v41)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v36 = (os_log_s *)__nwlog_obj();
        v37 = type;
        os_log_type_t v40 = os_log_type_enabled(v36, type);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446722;
            BOOL v44 = "sa_dst_cache_create";
            v45 = 2048;
            v46 = 112LL;
            v47 = 2082;
            v48 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s malloc(%zu) failed, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }

        if (!v40) {
          goto LABEL_50;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v44 = "sa_dst_cache_create";
        v45 = 2048;
        v46 = 112LL;
        v38 = "%{public}s malloc(%zu) failed, no backtrace";
      }

      else
      {
        os_log_type_t v36 = (os_log_s *)__nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v44 = "sa_dst_cache_create";
        v45 = 2048;
        v46 = 112LL;
        v38 = "%{public}s malloc(%zu) failed, backtrace limit exceeded";
      }

            if ((nw_endpoint_handler_get_logging_disabled(v13) & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v18 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              {
                id_string = nw_endpoint_handler_get_id_string(v13);
                v34 = nw_endpoint_handler_dry_run_string(v13);
                v35 = nw_endpoint_handler_copy_endpoint(v13);
                logging_description = nw_endpoint_get_logging_description(v35);
                v37 = nw_endpoint_handler_state_string(v13);
                v38 = nw_endpoint_handler_mode_string(v13);
                v39 = nw_endpoint_handler_copy_current_path(v13);
                *(_DWORD *)buf = 136448002;
                v63 = "nw_endpoint_flow_add_one_protocol";
                char v64 = 2082;
                v65 = (uint64_t)id_string;
                v66 = 2082;
                v67 = (void *)v34;
                v68 = 2082;
                uint64_t v69 = logging_description;
                v70 = 2082;
                v71 = v37;
                v72 = 2082;
                v73 = v38;
                v74 = 2114;
                v75 = v39;
                v76 = 2082;
                v77 = v55;
                _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach protocol %{public}s",  buf,  0x52u);
              }

    if (v10) {
      free(v10);
    }
    goto LABEL_10;
  }

  id v3 = (unsigned int *)v1;
  os_log_type_t v4 = v3[29];

  if ((_DWORD)v4 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      else {
        BOOL v7 = off_189BBBBC0[v4];
      }
      *(_DWORD *)buf = 136446722;
      v20 = "nw_flow_get_path";
      time_t v21 = 2082;
      char v22 = (void *)v7;
      os_log_type_t v23 = 2082;
      v24 = "flow";
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

LABEL_10:
    time_t v5 = 0LL;
    goto LABEL_11;
  }

  time_t v5 = nw_endpoint_flow_copy_path(v3);
LABEL_11:

  return v5;
}

  if (v11) {
    free(v11);
  }
  os_log_type_t v4 = 0LL;
LABEL_11:

  return v4;
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_11:

  return v6;
}

  return v5;
}

  result = (char *)sub_18264F360();
  __break(1u);
  return result;
}

  result = sub_18264F360();
  __break(1u);
  return result;
}

      v55 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C45E5A0);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v55 - 8) + 56LL))(v12, 1LL, 1LL, v55);
      os_log_type_t v40 = 0LL;
    }

    os_log_type_t v53 = *(void *)(v66 + 8 * v54);
    if (v53)
    {
LABEL_17:
      os_log_type_t v52 = v54;
LABEL_14:
      os_log_type_t v40 = (v53 - 1) & v53;
      v47 = __clz(__rbit64(v53)) + (v52 << 6);
      v42 = v52;
      continue;
    }

    break;
  }

  while (1)
  {
    os_log_type_t v52 = v54 + 1;
    if (__OFADD__(v54, 1LL)) {
      break;
    }
    if (v52 >= (uint64_t)v67)
    {
      v42 = (uint64_t)v65;
      goto LABEL_28;
    }

    os_log_type_t v53 = *(void *)(v66 + 8 * v52);
    ++v54;
    if (v53) {
      goto LABEL_14;
    }
  }

    *(_OWORD *)(a1 + 48) = *((_OWORD *)a2 + 3);
    goto LABEL_29;
  }

  if (!v13)
  {
    swift_release();
    goto LABEL_28;
  }

  BOOL v14 = a2[7];
  *(void *)(a1 + 48) = v13;
  *(void *)(a1 + 56) = v14;
  swift_retain();
  swift_release();
LABEL_29:
  BOOL v16 = *(void **)(a1 + 64);
  os_log_type_t v17 = (void *)a2[8];
  *(void *)(a1 + 64) = v17;
  v18 = v17;

  id v19 = *((_DWORD *)a2 + 18);
  *(_BYTE *)(a1 + 76) = *((_BYTE *)a2 + 76);
  *(_DWORD *)(a1 + 72) = v19;
  *(_BYTE *)(a1 + 77) = *((_BYTE *)a2 + 77);
  return a1;
}

    *(_OWORD *)(a1 + 48) = *((_OWORD *)a2 + 3);
    goto LABEL_29;
  }

  if (!v13)
  {
    swift_release();
    goto LABEL_28;
  }

  BOOL v14 = a2[7];
  *(void *)(a1 + 48) = v13;
  *(void *)(a1 + 56) = v14;
  swift_release();
LABEL_29:
  BOOL v16 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = a2[8];

  *(_DWORD *)(a1 + 72) = *((_DWORD *)a2 + 18);
  *(_BYTE *)(a1 + 76) = *((_BYTE *)a2 + 76);
  *(_BYTE *)(a1 + 77) = *((_BYTE *)a2 + 77);
  return a1;
}

    os_log_type_t v9 = sub_181C23710(v9, v5, v6);
    if ((v6 & 0x1000000000000000LL) == 0) {
      goto LABEL_26;
    }
LABEL_29:
    if (v7 > v9 >> 16)
    {
      os_log_type_t v9 = sub_18264EB98();
      goto LABEL_31;
    }

    __break(1u);
    goto LABEL_63;
  }

  __break(1u);
LABEL_56:
  __break(1u);
LABEL_57:
  __break(1u);
LABEL_58:
  BOOL v14 = sub_181C23710(v9, v5, v6);
  while (1)
  {
    os_log_type_t v15 = v14 >> 16;
    if (v14 >> 16 >= v7)
    {
      __break(1u);
LABEL_60:
      __break(1u);
LABEL_61:
      char v8 = *(_BYTE *)sub_18264F228();
      goto LABEL_13;
    }

    if ((v6 & 0x1000000000000000LL) != 0)
    {
      __int16 v12 = sub_18264EBC8();
      if (v2 != v3) {
        goto LABEL_42;
      }
    }

    else if ((v6 & 0x2000000000000000LL) != 0)
    {
      v20 = v5;
      time_t v21 = v6 & 0xFFFFFFFFFFFFFFLL;
      __int16 v12 = *((unsigned __int8 *)&v20 + v15);
      if (v2 != v3) {
        goto LABEL_42;
      }
    }

    else
    {
      if ((v5 & 0x1000000000000000LL) != 0) {
        BOOL v16 = (v6 & 0xFFFFFFFFFFFFFFFLL) + 32;
      }
      else {
        BOOL v16 = sub_18264F228();
      }
      __int16 v12 = *(unsigned __int8 *)(v16 + v15);
      if (v2 != v3)
      {
LABEL_42:
        v2 = v19;
        if ((v6 & 0x1000000000000000LL) == 0) {
          goto LABEL_45;
        }
        goto LABEL_43;
      }
    }

    os_log_type_t v9 = sub_181C23710(v9, v5, v6);
    v2 = v19;
    if ((v6 & 0x1000000000000000LL) == 0) {
      goto LABEL_45;
    }
LABEL_43:
    if (v7 > v9 >> 16) {
      break;
    }
LABEL_63:
    __break(1u);
LABEL_64:
    os_log_type_t v13 = sub_18264F228();
LABEL_22:
    LOBYTE(v12) = *(_BYTE *)(v13 + v12);
    if (v1 == v3) {
      goto LABEL_28;
    }
LABEL_25:
    if ((v6 & 0x1000000000000000LL) != 0) {
      goto LABEL_29;
    }
LABEL_26:
    os_log_type_t v9 = (v9 & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_31:
    v1 = v12 - 48;
    if ((v1 & 0xFFFFFF00) != 0) {
      goto LABEL_56;
    }
    if (v2 == v9 >> 14) {
      goto LABEL_57;
    }
    v2 = v9 & 0xC;
    BOOL v14 = v9;
    if (v2 == v3) {
      goto LABEL_58;
    }
  }

  sub_18264EB98();
LABEL_45:
  *a1 = 100LL * v10 + 10LL * v1 + (v12 - 48);
  a1[1] = v18;
  a1[2] = v2;
  return swift_bridgeObjectRetain();
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  if (v11) {
    free(v11);
  }
  return 0LL;
}

  if (v8 - v9 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96LL))(v7, v9, v8 - v9) != v8 - v9)
  {
    goto LABEL_31;
  }

  *((void *)v6 + 3) = 0LL;
LABEL_32:
  MEMORY[0x186E0FF78](v23);
  return a1;
}

  free(backtrace_string);
LABEL_34:
  if (v21) {
    free(v21);
  }
  return 0LL;
}

  if (v14) {
    free(v14);
  }
  os_log_type_t v4 = 0LL;
LABEL_11:

  return v4;
}

  if (!v2)
  {
    __nwlog_obj();
    v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v114 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v114);
    if (result) {
      goto LABEL_268;
    }
    free(v114);
  }

  os_log_type_t v15 = 0LL;
  BOOL v16 = 107LL;
  while (1)
  {
    os_log_type_t v17 = &v2[v15];
    if (!v2[v15]) {
      break;
    }
    ++v15;
    if (!--v16) {
      goto LABEL_40;
    }
  }

  if (v16 < 2)
  {
LABEL_39:
    const char *v17 = 0;
  }

  else
  {
    v18 = v16 - 2;
    id v19 = 106 - v15;
    v20 = 105 - v15;
    if (v20 >= 0xC) {
      v20 = 12LL;
    }
    memcpy(v17, "result_added", v20 + 1);
    os_log_type_t v17 = v2 + 106;
    while (v18 <= 0xB)
    {
      if (!--v19) {
        goto LABEL_39;
      }
    }
  }

      operator delete(v13[0]);
      goto LABEL_16;
    }

        free(v23);
        if (!v9) {
          goto LABEL_136;
        }
        goto LABEL_78;
      }

      xpc_dictionary_get_value(v7, (const char *)networkd_privileged_key_result);
      os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = v17;
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v31 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        v20 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v98 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          time_t v21 = (os_log_s *)(id)gLogObj;
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_181A5C000, v21, v32, "%{public}s received response without result code", buf, 0xCu);
          }

          goto LABEL_131;
        }

        if (!v98)
        {
          __nwlog_obj();
          time_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v61 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl( &dword_181A5C000,  v21,  v61,  "%{public}s received response without result code, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_131;
        }

        os_log_type_t v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        time_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v46 = type;
        v47 = os_log_type_enabled(v21, type);
        if (!v43)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl( &dword_181A5C000,  v21,  v46,  "%{public}s received response without result code, no backtrace",  buf,  0xCu);
          }

          goto LABEL_131;
        }

        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(void *)v103 = v43;
          _os_log_impl( &dword_181A5C000,  v21,  v46,  "%{public}s received response without result code, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_83;
      }

      if (object_getClass(v17) != (Class)MEMORY[0x1895F9280])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        v20 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v98 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          time_t v21 = (os_log_s *)(id)gLogObj;
          char v22 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s received invalid result type", buf, 0xCu);
          }

            if (*(_UNKNOWN **)(v12 + 40) == &nw_protocol_ref_counted_handle)
            {
              os_log_type_t v43 = *(void *)(v12 + 88);
              if (v43)
              {
                BOOL v44 = v43 - 1;
                *(void *)(v12 + 88) = v44;
                if (!v44)
                {
                  v45 = *(void (***)(void))(v12 + 64);
                  if (v45)
                  {
                    *(void *)(v12 + 64) = 0LL;
                    v45[2](v45);
                    _Block_release(v45);
                  }

                  if ((*(_BYTE *)(v12 + 72) & 1) != 0)
                  {
                    v46 = *(const void **)(v12 + 64);
                    if (v46) {
                      _Block_release(v46);
                    }
                  }

                  free((void *)v12);
                }
              }
            }

            goto LABEL_29;
          }
        }

        __nwlog_obj();
        char v61 = *(const char **)(v11 + 16);
        buf = 136446722;
        v113 = "__nw_protocol_connect";
        if (!v61) {
          char v61 = "invalid";
        }
        v114 = 2082;
        v115 = (void *)v61;
        v116 = 2048;
        v117 = v11;
        os_log_type_t v62 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v110 = 0;
        if (__nwlog_fault(v62, type, &v110))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v63 = (os_log_s *)__nwlog_obj();
            char v64 = type[0];
            if (!os_log_type_enabled(v63, type[0])) {
              goto LABEL_190;
            }
            v65 = *(const char **)(v11 + 16);
            if (!v65) {
              v65 = "invalid";
            }
            buf = 136446722;
            v113 = "__nw_protocol_connect";
            v114 = 2082;
            v115 = (void *)v65;
            v116 = 2048;
            v117 = v11;
            v66 = "%{public}s protocol %{public}s (%p) has invalid connect callback";
LABEL_188:
            v103 = v63;
LABEL_189:
            _os_log_impl(&dword_181A5C000, v103, v64, v66, (uint8_t *)&buf, 0x20u);
            goto LABEL_190;
          }

          if (!v110)
          {
            v63 = (os_log_s *)__nwlog_obj();
            char v64 = type[0];
            if (!os_log_type_enabled(v63, type[0])) {
              goto LABEL_190;
            }
            v102 = *(const char **)(v11 + 16);
            if (!v102) {
              v102 = "invalid";
            }
            buf = 136446722;
            v113 = "__nw_protocol_connect";
            v114 = 2082;
            v115 = (void *)v102;
            v116 = 2048;
            v117 = v11;
            v66 = "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded";
            goto LABEL_188;
          }

          v87 = (char *)__nw_create_backtrace_string();
          v88 = (os_log_s *)__nwlog_obj();
          char v64 = type[0];
          loga = v88;
          v89 = os_log_type_enabled(v88, type[0]);
          if (v87)
          {
            if (v89)
            {
              v90 = *(const char **)(v11 + 16);
              if (!v90) {
                v90 = "invalid";
              }
              buf = 136446978;
              v113 = "__nw_protocol_connect";
              v114 = 2082;
              v115 = (void *)v90;
              v116 = 2048;
              v117 = v11;
              v118 = 2082;
              v119 = v87;
              _os_log_impl( &dword_181A5C000,  loga,  v64,  "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x2Au);
            }

            free(v87);
          }

          else if (v89)
          {
            v106 = *(const char **)(v11 + 16);
            if (!v106) {
              v106 = "invalid";
            }
            buf = 136446722;
            v113 = "__nw_protocol_connect";
            v114 = 2082;
            v115 = (void *)v106;
            v116 = 2048;
            v117 = v11;
            v66 = "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace";
            v103 = loga;
            goto LABEL_189;
          }
        }

    goto LABEL_29;
  }

  if ((*(_BYTE *)(v15 + 346) & 0x20) == 0)
  {
    if (*(_BYTE *)(v15 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v16 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_28;
      }
      os_log_type_t v17 = *(void *)(a1 + 32) + 256LL;
      *(_DWORD *)buf = 136446466;
      __int16 v25 = "nw_resolver_bonjour_resolve_callback_block_invoke";
      __int16 v26 = 2082;
      __int16 v27 = v17;
      v18 = "%{public}s [C%{public}s] Marking preferred weighting as completed";
      id v19 = v16;
      v20 = 22;
      goto LABEL_27;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v16 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      time_t v21 = *(_DWORD *)(*(void *)(a1 + 32) + 340LL);
      *(_DWORD *)buf = 136446466;
      __int16 v25 = "nw_resolver_bonjour_resolve_callback_block_invoke";
      __int16 v26 = 1024;
      LODWORD(v27) = v21;
      v18 = "%{public}s [R%u] Marking preferred weighting as completed";
      id v19 = v16;
      v20 = 18;
      goto LABEL_27;
    }

    goto LABEL_28;
  }

    if (v19) {
      free(v19);
    }
    BOOL v16 = 0LL;
    goto LABEL_11;
  }

  id v3 = v1;
  os_log_type_t v4 = (void *)[v3 copyEndpoint];
  nw_endpoint_copy_properties(v3, v4);

  time_t v5 = (void *)v4[14];
  v4[14] = 0LL;

  char v6 = v4;
  BOOL v7 = (char *)v3;
  char v8 = v7;
  os_log_type_t v9 = (id *)(v7 + 112);
  if (*((void *)v7 + 14))
  {
    v10 = (id *)(v7 + 112);
    v11 = v6;
    while ((v8[231] & 2) == 0)
    {
      __int16 v12 = [*v9 copyEndpoint];
      os_log_type_t v13 = v11[14];
      v11[14] = (id)v12;

      BOOL v14 = *v10;
      os_log_type_t v15 = (id *)v11[14];

      v10 = (id *)(v14 + 14);
      char v8 = v14;
      v11 = v15;
      if (!v14[14]) {
        goto LABEL_10;
      }
    }

    os_log_type_t v15 = v11;
  }

  else
  {
    os_log_type_t v15 = v6;
  }

  BOOL v14 = v8;
LABEL_10:
  BOOL v16 = v6;

LABEL_11:
  return v16;
}

  _Block_object_dispose(&v90, 8);
  _Block_object_dispose(&v96, 8);

LABEL_29:
}

    free(backtrace_string);
    if (!v16) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }

  char v8 = (void *)*((void *)v4 - 6);
  if (!v8) {
    goto LABEL_50;
  }
  os_log_type_t v9 = v8[3];
  if (!v9) {
    goto LABEL_50;
  }
  v10 = *(void (**)(void))(v9 + 120);
  if (!v10) {
    goto LABEL_50;
  }
  v11 = (void *)v8[5];
  if (v11 == &nw_protocol_ref_counted_handle)
  {
    char v22 = v8[11];
    if (v22) {
      v8[11] = v22 + 1;
    }
    __int16 v12 = -1;
  }

  else
  {
    __int16 v12 = 0;
  }

    goto LABEL_29;
  }

  BOOL v7 = *(unsigned int *)(*((void *)v6[1] + 10) + 256LL);
  if (!(_DWORD)v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)v6 + 407;
      os_log_type_t v52 = 2080;
      os_log_type_t v53 = " ";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sThe size of the key data in the protocol definition must be specified before using the cu stom flow map. See nw_protocol_definition_set_custom_flow_map_key_size.",  buf,  0x20u);
    }

    goto LABEL_28;
  }

  if (v6[30]) {
    goto LABEL_9;
  }
  internal = nw_hash_table_create_internal( 0x1Fu,  8,  (const void *(*)(const void *, unsigned int *))nw_protocol_custom_mapping_get_key,  (unsigned int (*)(const void *, unsigned int))nw_protocol_custom_mapping_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_custom_mapping_matches_key,  nw_protocol_custom_mapping_release_object);
  if (!internal)
  {
    v6[30] = 0LL;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    time_t v21 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_instance_set_flow_for_key";
    char v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (os_log_s *)(id)gLogObj;
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s nw_hash_table_create_no_lock failed", buf, 0xCu);
      }

    time_t v21 = 0LL;
    goto LABEL_161;
  }

  time_t v21 = 0LL;
  char v22 = *(_BYTE *)(v10 + 137) | 5;
LABEL_22:
  *(_BYTE *)(v11 + 137) = v22;
LABEL_161:

  return v21;
}

    free(backtrace_string);
    goto LABEL_41;
  }

  if (a2)
  {
    time_t v5 = *((void *)v3 + 5);
    if (v5) {
      time_t v5 = *(void *)(v5 + 16);
    }
    *a2 = v5;
  }

  char v6 = *((void *)v3 + 5);
  if (!v6)
  {
LABEL_43:
    BOOL v7 = 0LL;
    goto LABEL_44;
  }

  BOOL v7 = *(void *)(v6 + 8);
LABEL_44:

  return v7;
}

  time_t v21 = *(void *)(a1 + 32);
  if (*(char *)(v21 + 160) < 0 && *(void *)(a1 + 40))
  {
    *(_BYTE *)(v21 + 56) = 103;
    *(_WORD *)(*(void *)(a1 + 32) + 104LL) = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 40));
    __nwlog_obj();
    char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      os_log_type_t v23 = *(void *)(a1 + 32);
      v24 = *(unsigned __int16 *)(v23 + 104);
      __int16 v25 = 136446722;
      __int16 v26 = "nw_socks5_connection_start_on_queue_block_invoke";
      __int16 v27 = 2114;
      uint64_t v28 = v23;
      uint64_t v29 = 1024;
      LODWORD(v30) = v24;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ connection shoes got length %u",  (uint8_t *)&v25,  0x1Cu);
    }

    nw_socks5_connection_inner_connection_read_handler_on_queue( *(void **)(a1 + 32),  *(void **)(a1 + 40),  0,  0,  *(unsigned __int16 *)(*(void *)(a1 + 32) + 104LL));
  }

  else
  {
    nw_socks5_connection_inner_connection_read_range_on_queue((NWConcrete_nw_socks5_connection *)v21, 2u, 2u);
  }

  if (v11) {
    free(v11);
  }
}

  if (v8) {
    free(v8);
  }
}

LABEL_29:
  if (v13) {
    goto LABEL_30;
  }
LABEL_31:
}

    if (v16) {
      free(v16);
    }
    goto LABEL_11;
  }

  time_t v5 = -[NWRemotePacketProxy outputHandlerForPacket:inbound:](self, "outputHandlerForPacket:inbound:", v4, 1LL);
  -[NWRemotePacketProxy writeRequests](self, "writeRequests");
  char v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_sync_enter(v6);
  while (1)
  {
    -[NWRemotePacketProxy writeRequests](self, "writeRequests");
    BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
    char v8 = [v7 count];

    if (!v8) {
      break;
    }
    -[NWRemotePacketProxy writeRequests](self, "writeRequests");
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    [v9 firstObject];
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    if (!nw_remote_director_write_request( (uint64_t)-[NWRemotePacketProxy packetProtocol](self, "packetProtocol"),  (uint64_t)v5,  v10))
    {

      break;
    }
    v11 = -[NWRemotePacketProxy writeRequests](self, "writeRequests");
    [v11 removeObjectAtIndex:0];
  }

  __int16 v12 = -[NWRemoteConnectionWriteRequest initWithData:clientID:]( objc_alloc(&OBJC_CLASS___NWRemoteConnectionWriteRequest),  "initWithData:clientID:",  v4,  0LL);
  if (v8
    || !nw_remote_director_write_request( (uint64_t)-[NWRemotePacketProxy packetProtocol](self, "packetProtocol"),  (uint64_t)v5,  v12))
  {
    -[NWRemotePacketProxy writeRequests](self, "writeRequests");
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    [v13 addObject:v12];
  }

  objc_sync_exit(v6);
LABEL_11:

  return v4 != 0LL;
}

      v220[0] = 0;
      goto LABEL_39;
    }

    if (v9) {
      free(v9);
    }
    goto LABEL_30;
  }

  id v3 = *(void **)(v1[13] + 176LL);
  if (!v3) {
    goto LABEL_30;
  }
  os_log_type_t v4 = (void *)v3[5];
  if (!v4)
  {
LABEL_6:
    time_t v5 = (void *)v3[4];
    if (v5)
    {
      if (xpc_array_get_count(v5)) {
        goto LABEL_8;
      }
      id v3 = *(void **)(v2[13] + 176LL);
    }

    BOOL v7 = (void *)v3[6];
    if (v7)
    {
      char v6 = xpc_array_get_count(v7) != 0;
      goto LABEL_31;
    }

    if (v9) {
      free(v9);
    }
    goto LABEL_30;
  }

  id v3 = *(void **)(v1[13] + 176LL);
  if (!v3) {
    goto LABEL_30;
  }
  os_log_type_t v4 = (void *)v3[8];
  if (!v4)
  {
LABEL_6:
    time_t v5 = (void *)v3[7];
    if (v5)
    {
      if (xpc_array_get_count(v5)) {
        goto LABEL_8;
      }
      id v3 = *(void **)(v2[13] + 176LL);
    }

    BOOL v7 = (void *)v3[9];
    if (v7)
    {
      char v6 = xpc_array_get_count(v7) != 0;
      goto LABEL_31;
    }

      goto LABEL_115;
    }

    if (!v160)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (os_log_s *)(id)gLogObj;
      uint64_t v54 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v163 = "nw_parameters_create_secure_http_messaging";
        _os_log_impl( &dword_181A5C000,  v24,  v54,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_28;
    }

    v33 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = (os_log_s *)(id)gLogObj;
    v35 = type;
    os_log_type_t v36 = os_log_type_enabled(v34, type);
    if (v33)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v163 = "nw_parameters_create_secure_http_messaging";
        v164 = 2082;
        v165 = v33;
        _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v33);
      if (!v23) {
        goto LABEL_117;
      }
      goto LABEL_116;
    }

    if (v36)
    {
      *(_DWORD *)buf = 136446210;
      v163 = "nw_parameters_create_secure_http_messaging";
      _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
    }
  }

  if (v9)
  {
    os_log_type_t v15 = (char *)v9;
LABEL_30:
    free(v15);
  }

  return 0LL;
}
}

    if (v14) {
      free(v14);
    }
    goto LABEL_30;
  }

  nw_context_assert_queue(v5[3]);
  BOOL v7 = v3 + 33;
  while (1)
  {
    BOOL v7 = (void *)*v7;
    if (!v7) {
      break;
    }
    if (nw_protocol_definition_is_equal_unsafe(v7[2], (uint64_t)v6))
    {

      char v8 = *(const void **)(a1 + 48);
      if (v8)
      {
        if (v8 != (const void *)v7[3])
        {
          os_log_type_t v9 = _Block_copy(v8);
          v10 = (void *)v7[3];
          v7[3] = v9;
        }
      }

      else
      {
        v11 = (void *)*v7;
        __int16 v12 = (void *)v7[1];
        if (*v7)
        {
          v11[1] = v12;
          __int16 v12 = (void *)v7[1];
        }

        else
        {
          *(void *)(*(void *)(a1 + 32) + 272LL) = v12;
        }

        *__int16 v12 = v11;
        *BOOL v7 = 0LL;
        v7[1] = 0LL;
      }

      goto LABEL_32;
    }
  }

  return v7;
}

  if (v14) {
    free(v14);
  }
LABEL_11:
}

  if (v14) {
    free(v14);
  }
LABEL_11:
}

    if (v13) {
      free(v13);
    }
    return 0;
  }

  BOOL v7 = __n + 3;
  char v8 = (unsigned __int16)(__n + 3);
  if (v8 > a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (a3 > 9) {
        v10 = "unknown";
      }
      else {
        v10 = off_189BB5958[a3];
      }
      *(_DWORD *)buf = 136446978;
      os_log_type_t v23 = "nw_shoes_add_tlv";
      v24 = 2082;
      __int16 v25 = (void *)v10;
      __int16 v26 = 1024;
      __int16 v27 = a2;
      uint64_t v28 = 1024;
      uint64_t v29 = v8;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Insufficient buffer length to write tlv %{public}s (%u < %u)",  buf,  0x22u);
    }

    return 0;
  }

  *(_BYTE *)a1 = a3;
  *(_WORD *)(a1 + 1) = __rev16(__n);
  memcpy((void *)(a1 + 3), __src, __n);
  return v7;
}

    if (v8) {
      free(v8);
    }
    return 0LL;
  }

  id v3 = calloc(1uLL, 0x28uLL);
  if (v3)
  {
    os_log_type_t v4 = (void *)*a2;
    if (!*a2)
    {
LABEL_5:
      void *v3 = v4;
      time_t v5 = (void *)a2[1];
      if (v5) {
        v3[1] = xpc_copy(v5);
      }
      char v6 = (void *)a2[2];
      if (v6) {
        v3[2] = xpc_copy(v6);
      }
      v3[3] = a2[3];
      *((_WORD *)v3 + 16) = *((_WORD *)a2 + 16);
      return (BOOL)v3;
    }

    __break(1u);
    return result;
  }

  id v19 = v11;
  os_log_type_t v13 = 1LL;
LABEL_21:
  alloc = (dispatch_object_s *)dispatch_data_create_alloc();
  memcpy(0LL, &__src, v8);
  __int16 v25 = 0LL;
  __int16 v26 = &v25;
  __int16 v27 = 0x2000000000LL;
  uint64_t v28 = 0LL;
  time_t v21 = 0LL;
  char v22 = &v21;
  os_log_type_t v23 = 0x2000000000LL;
  BOOL v16 = MEMORY[0x1895F87A8];
  v24 = (char *)v8;
  if (a1)
  {
    *(void *)applier = MEMORY[0x1895F87A8];
    *(void *)&applier[8] = 0x40000000LL;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    v30 = &unk_189BBF598;
    os_log_type_t v32 = &v21;
    v33 = v7;
    v31 = &v25;
    dispatch_data_apply(a1, applier);
  }

  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  os_log_type_t v17 = (char *)(v8 + v7);
  memcpy(v17, &v19, v13);
  __int16 v25 = 0LL;
  __int16 v26 = &v25;
  __int16 v27 = 0x2000000000LL;
  uint64_t v28 = 0LL;
  time_t v21 = 0LL;
  char v22 = &v21;
  os_log_type_t v23 = 0x2000000000LL;
  v24 = &v17[v13];
  if (a2)
  {
    *(void *)applier = v16;
    *(void *)&applier[8] = 0x40000000LL;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    v30 = &unk_189BBF598;
    os_log_type_t v32 = &v21;
    v33 = v12;
    v31 = &v25;
    dispatch_data_apply(a2, applier);
  }

  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  v17[v13 + v12] = 0;
  metadata_for_capsule = nw_http_create_metadata_for_capsule(16770048LL, alloc);
  if (alloc) {
    dispatch_release(alloc);
  }
  return (BOOL)metadata_for_capsule;
}

  *(_DWORD *)(*(void *)(*((void *)v3 + 6) + 8LL) + 24LL) = v5;
  __int16 v12 = strstr(__big, "error=dns_error") && !*(_DWORD *)(*(void *)(*((void *)v3 + 6) + 8LL) + 24LL)
     || strstr(__big, "error=destination_ip_prohibited")
     || strstr(__big, "error=destination_ip_unroutable")
     || strstr(__big, "error=destination_not_found")
     || strstr(__big, "error=destination_unavailable") != 0LL;
  *(_BYTE *)(*(void *)(*((void *)v3 + 7) + 8LL) + 24LL) = v12;
  *(_BYTE *)(*(void *)(*((void *)v3 + 8) + 8LL) + 24LL) = strstr(__big, "error=resource_uses_reverse_proxy") != 0LL;
  result = strstr(__big, "error=connection_refused");
  if (result)
  {
    os_log_type_t v13 = v3 + 72;
  }

  else
  {
    result = strstr(__big, "error=connection_timeout");
    if (!result) {
      return result;
    }
    result = (char *)nw_endpoint_get_type(*(nw_endpoint_t *)(*((void *)v3 + 10) + 312LL));
    os_log_type_t v13 = v3 + 72;
    if ((_DWORD)result == 1) {
      os_log_type_t v13 = v3 + 56;
    }
  }

  *(_BYTE *)(*(void *)(*(void *)v13 + 8LL) + 24LL) = 1;
  return result;
}

LABEL_37:
        goto LABEL_38;
      }

      v48 = 0LL;
      v49 = &v48;
      v50 = 0x2020000000LL;
      v51 = 0;
      v18 = *(void *)(a1 + 32);
      id v19 = MEMORY[0x1895F87A8];
      if (*(void *)(v18 + 48) && *(void *)(v18 + 40))
      {
        v20 = nw_endpoint_copy_address_string(v13);
        time_t v21 = nw_dictionary_copy_value(*(void *)(*(void *)(a1 + 32) + 40LL), (uint64_t)v20);
        if (v20) {
          free(v20);
        }
        if (gLogDatapath)
        {
          __nwlog_obj();
          BOOL v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            v42 = *(void *)(*(void *)(a1 + 32) + 16LL);
            *(_DWORD *)buffer = 136446722;
            *(void *)&buffer[4] = "nw_masque_listener_pair_read_outer_datagrams_block_invoke";
            *(_WORD *)&buffer[12] = 2114;
            *(void *)&buffer[14] = v42;
            os_log_type_t v53 = 2112;
            size = (size_t)v7;
            _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Received content %@",  buffer,  0x20u);
          }
        }

        if (v21)
        {
          applier[0] = MEMORY[0x1895F87A8];
          applier[1] = 3221225472LL;
          applier[2] = ___ZL44nw_masque_listener_pair_read_outer_datagramsP34NWConcrete_nw_masque_listener_pair_block_invoke_315;
          applier[3] = &unk_189BBB6F8;
          v46 = v21;
          v47 = &v48;
          dispatch_data_apply(v7, applier);
        }

        id v19 = MEMORY[0x1895F87A8];
      }

      if (gLogDatapath)
      {
        os_log_type_t v36 = v19;
        __nwlog_obj();
        v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          v38 = *(void *)(*(void *)(a1 + 32) + 16LL);
          v39 = dispatch_data_get_size(v7);
          v10 = *((_BYTE *)v49 + 24) == 0;
          *(_DWORD *)buffer = 136447234;
          *(void *)&buffer[4] = "nw_masque_listener_pair_read_outer_datagrams_block_invoke_2";
          if (v10) {
            os_log_type_t v40 = "";
          }
          else {
            os_log_type_t v40 = " directly";
          }
          *(_WORD *)&buffer[12] = 2114;
          *(void *)&buffer[14] = v38;
          os_log_type_t v53 = 2048;
          size = v39;
          v55 = 2112;
          v56 = v13;
          uint64_t v57 = 2080;
          uint64_t v58 = v40;
          _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ Proxying %zu bytes from %@%s to client",  buffer,  0x34u);
        }

        id v19 = v36;
      }

      if (!*((_BYTE *)v49 + 24))
      {
        char v22 = address->sa_family;
        if (v22 == 30)
        {
          os_log_type_t v23 = v19;
          buffer[0] = 6;
          *(sockaddr *)&buffer[1] = *(sockaddr *)&address->sa_data[6];
          *(_WORD *)&buffer[17] = *(_WORD *)address->sa_data;
          os_log_type_t v32 = dispatch_data_create(buffer, 0x13uLL, 0LL, 0LL);
          concat = dispatch_data_create_concat(v32, v7);

          goto LABEL_33;
        }

        if (v22 == 2)
        {
          os_log_type_t v23 = v19;
          buffer[0] = 4;
          *(_DWORD *)&buffer[1] = *(_DWORD *)&address->sa_data[2];
          *(_WORD *)&buffer[5] = *(_WORD *)address->sa_data;
          v24 = dispatch_data_create(buffer, 7uLL, 0LL, 0LL);
          concat = dispatch_data_create_concat(v24, v7);

LABEL_33:
          BOOL v7 = concat;
          id v19 = v23;
        }
      }

      dispatch_group_enter(*(dispatch_group_t *)(*(void *)(a1 + 32) + 96LL));
      v33 = *(void **)(a1 + 32);
      v34 = v33;
      if (!*((_BYTE *)v49 + 24)) {
        v34 = (void *)v33[2];
      }
      v35 = (nw_connection *)v34[6];
      completion[0] = v19;
      completion[1] = 3221225472LL;
      completion[2] = ___ZL44nw_masque_listener_pair_read_outer_datagramsP34NWConcrete_nw_masque_listener_pair_block_invoke_317;
      completion[3] = &unk_189BC5E68;
      BOOL v44 = v33;
      nw_connection_send(v35, v7, (nw_content_context_t)&__block_literal_global_41831, 1, completion);

      _Block_object_dispose(&v48, 8);
      goto LABEL_37;
    }
  }

    free(backtrace_string);
    goto LABEL_40;
  }

  BOOL v16 = (os_log_s *)__nwlog_obj();
  os_log_type_t v17 = type[0];
  if (os_log_type_enabled(v16, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ethernet_get_input_frames";
    v18 = "%{public}s called with null protocol";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
  }
}

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    BOOL v41 = "tcp_connection_set_persistent";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (os_log_s *)(id)gLogObj;
      __int16 v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v41 = "tcp_connection_set_persistent";
        __int16 v26 = "%{public}s xpc_array_create failed";
LABEL_47:
        os_log_type_t v32 = v24;
        v33 = v25;
LABEL_48:
        _os_log_impl(&dword_181A5C000, v32, v33, v26, buf, 0xCu);
      }
    }

    else
    {
      if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (os_log_s *)(id)gLogObj;
        uint64_t v28 = type;
        uint64_t v29 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v41 = "tcp_connection_set_persistent";
            v42 = 2082;
            os_log_type_t v43 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v28,  "%{public}s xpc_array_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }

        if (!v29) {
          goto LABEL_49;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v41 = "tcp_connection_set_persistent";
        __int16 v26 = "%{public}s xpc_array_create failed, no backtrace";
        os_log_type_t v32 = v24;
        v33 = v28;
        goto LABEL_48;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (os_log_s *)(id)gLogObj;
      __int16 v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v41 = "tcp_connection_set_persistent";
        __int16 v26 = "%{public}s xpc_array_create failed, backtrace limit exceeded";
        goto LABEL_47;
      }
    }

  os_log_type_t v23 = *(void *)(a2 + 112);
  if (!v23) {
    goto LABEL_57;
  }
  if ((*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
    LODWORD(v23) = 0;
LABEL_57:
    __int16 v25 = 0LL;
    __int16 v26 = *(void *)(a2 + 64);
    if (v26) {
      goto LABEL_35;
    }
LABEL_58:
    uint64_t v29 = a1 + 7;
    uint64_t v28 = a1[7];
    if (*(void *)(v28 + 544)) {
      os_log_type_t v40 = (_DWORD)v23 == 0;
    }
    else {
      os_log_type_t v40 = 1;
    }
    if (!v40)
    {
      v206 = a1;
      v207 = v5;
      v208 = 0;
      goto LABEL_65;
    }

    if (v17) {
      free(v17);
    }
    *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) = -1;
  }

  return 1LL;
}

  BOOL v14 = *(void **)(v5 + 16);
  if (nw_protocol_http_messaging_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_76181);
  }
  os_log_type_t v15 = nw_protocols_are_equal(v14, nw_protocol_http_messaging_identifier::protocol_identifier);
  BOOL v16 = handle[548];
  if (v15)
  {
    v16 |= 0x40u;
    handle[548] = v16;
  }

  if ((v16 & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v18 = *((_DWORD *)handle + 115);
      if (v12 == 4) {
        id v19 = 2;
      }
      else {
        id v19 = 3;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_establish";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v18;
      HIWORD(v109) = 1024;
      LODWORD(v110) = v19;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Establishing webtransport session for HTTP/%u",  buf,  0x2Cu);
    }
  }

  if (v9) {
    os_release(v9);
  }
LABEL_40:
  v20 = *((_DWORD *)handle + 112);
  if (v20 <= 1)
  {
    time_t v21 = *((_DWORD *)handle + 111);
    if ((handle[548] & 1) == 0)
    {
      if (v21) {
        return;
      }
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v86 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
          {
            v87 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_webtransport_http_send_connect";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            v108 = " ";
            LOWORD(v109) = 1024;
            *(_DWORD *)((char *)&v109 + 2) = v87;
            _os_log_impl(&dword_181A5C000, v86, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }

      if ((handle[548] & 1) != 0)
      {
LABEL_119:
        *((_DWORD *)handle + 111) = 1;
        return;
      }

      char v22 = (nw_endpoint *)*((void *)handle + 45);
      v105 = 0LL;
      hostname = nw_endpoint_get_hostname(v22);
      port = nw_endpoint_get_port(v22);
      asprintf(&v105, "%s:%u", hostname, port);
      url_path = nw_parameters_copy_url_endpoint(*((void **)handle + 43));
      __int16 v26 = url_path;
      if (url_path) {
        url_path = (void *)nw_endpoint_get_url_path(url_path);
      }
      if (url_path) {
        __int16 v27 = (const char *)url_path;
      }
      else {
        __int16 v27 = "/";
      }
      uint64_t v28 = (void *)_nw_http_request_create("CONNECT", "https", v105, v27);
      if (v105)
      {
        free(v105);
        v105 = 0LL;
      }

      nw_http_request_set_extended_connect_protocol(v28, (uint64_t)"webtransport");
      metadata_for_request = nw_http_create_metadata_for_request(v28);
      v30 = *((void *)handle + 4);
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v88 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
          {
            v89 = *((_DWORD *)handle + 115);
            *(_DWORD *)v112 = 136446978;
            *(void *)&v112[4] = "nw_webtransport_session_send_metadata";
            *(_WORD *)&v112[12] = 2082;
            *(void *)&v112[14] = handle + 464;
            *(_WORD *)&v112[22] = 2080;
            v113 = " ";
            v114 = 1024;
            v115 = v89;
            _os_log_impl(&dword_181A5C000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", v112, 0x26u);
          }
        }
      }

      v106[0] = 0LL;
      v106[1] = v106;
      output_frames = nw_protocol_get_output_frames(v30, (uint64_t)handle, 0LL, 0LL, 1LL, (uint64_t)v106);
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v90 = output_frames;
          v91 = (os_log_s *)__nwlog_obj();
          v92 = os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG);
          output_frames = v90;
          if (v92)
          {
            v93 = *((_DWORD *)handle + 115);
            *(_DWORD *)v112 = 136447234;
            *(void *)&v112[4] = "nw_webtransport_session_send_metadata";
            *(_WORD *)&v112[12] = 2082;
            *(void *)&v112[14] = handle + 464;
            *(_WORD *)&v112[22] = 2080;
            v113 = " ";
            v114 = 1024;
            v115 = v93;
            v116 = 1024;
            v117 = v90;
            _os_log_impl( &dword_181A5C000,  v91,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Got %u output frames",  v112,  0x2Cu);
            output_frames = v90;
          }
        }
      }

      if (output_frames)
      {
        *(void *)v112 = 0LL;
        *(void *)&v112[8] = v112;
        *(void *)&v112[16] = 0x2000000000LL;
        LOBYTE(v113) = 0;
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke;
        v108 = (const char *)&unk_189BBC690;
        v109 = v112;
        v110 = (nw_protocol *)v106;
        *(void *)&v111 = handle;
        *((void *)&v111 + 1) = metadata_for_request;
        os_log_type_t v32 = v106[0];
        do
        {
          if (!v32) {
            break;
          }
          v33 = *(void *)(v32 + 32);
          v34 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          os_log_type_t v32 = v33;
        }

        while ((v34 & 1) != 0);
        v35 = nw_protocol_finalize_output_frames(v30, (uint64_t)v106);
        _Block_object_dispose(v112, 8);
        os_log_type_t v36 = handle[548];
        if ((v35 & 1) != 0)
        {
          if ((handle[548] & 2) != 0) {
            goto LABEL_113;
          }
          v37 = (os_log_s *)__nwlog_obj();
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_113;
          }
          v38 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http_send_connect";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v108 = " ";
          LOWORD(v109) = 1024;
          *(_DWORD *)((char *)&v109 + 2) = v38;
          v39 = "%{public}s %{public}s%s<i%u> Sent CONNECT request to WebTransport server";
          os_log_type_t v40 = v37;
          BOOL v41 = OS_LOG_TYPE_DEBUG;
          goto LABEL_99;
        }
      }

      else
      {
        os_log_type_t v36 = handle[548];
      }

      if (*((_DWORD *)handle + 111) != 5)
      {
        if ((v36 & 2) == 0)
        {
          os_log_type_t v62 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
          {
            v63 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            v108 = " ";
            LOWORD(v109) = 1024;
            *(_DWORD *)((char *)&v109 + 2) = v63;
            HIWORD(v109) = 1024;
            LODWORD(v110) = 12;
            _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d",  buf,  0x2Cu);
          }
        }

        *((_DWORD *)handle + 111) = 5;
        char v64 = (char *)*((void *)handle + 23);
        if (v64)
        {
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
          v108 = (const char *)&__block_descriptor_tmp_22_33505;
          LODWORD(v109) = 12;
          nw_hash_table_apply(v64, (uint64_t)buf);
        }

        v65 = *((void *)handle + 53);
        if (v65)
        {
          v66 = *(void **)(v65 + 48);
          nw_protocol_error(v66, *((void *)handle + 53));
          nw_protocol_disconnected(v66, v65);
        }

        v67 = *((void *)handle + 41);
        if (v67)
        {
          do
          {
            v68 = *(void *)(v67 + 112);
            uint64_t v69 = *(void **)(v67 + 48);
            nw_protocol_error(v69, v67);
            nw_protocol_disconnected(v69, v67);
            v67 = v68;
          }

          while (v68);
        }

        v70 = *((void *)handle + 52);
        if (v70)
        {
          v71 = *(void **)(v70 + 48);
          nw_protocol_error(v71, *((void *)handle + 52));
          nw_protocol_disconnected(v71, v70);
        }

        if (*((void *)handle + 4))
        {
          nw_protocol_remove_instance((uint64_t)handle);
          nw_protocol_disconnect(*((void **)handle + 4), (uint64_t)handle);
        }

        goto LABEL_113;
      }

      if ((v36 & 2) != 0 || (v60 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v60, OS_LOG_TYPE_INFO)))
      {
LABEL_113:
        if (metadata_for_request) {
          os_release(metadata_for_request);
        }
        if (v28) {
          os_release(v28);
        }
        if (v26) {
          os_release(v26);
        }
        goto LABEL_119;
      }

      char v61 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v61;
      v39 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
      os_log_type_t v40 = v60;
      BOOL v41 = OS_LOG_TYPE_INFO;
LABEL_99:
      _os_log_impl(&dword_181A5C000, v40, v41, v39, buf, 0x26u);
      goto LABEL_113;
    }

    if (v21) {
      return;
    }
    if (v20 == 1)
    {
      v56 = *((void *)handle + 6);
      if (v56)
      {
        uint64_t v57 = *(void *)(v56 + 40);
        if (v57)
        {
          nw_protocol_replace_input_handler(*((void *)handle + 4), (uint64_t)handle, *(void *)(v56 + 40));
          *((void *)handle + 52) = v57;
          nw_protocol_set_output_handler((uint64_t)handle, 0LL);
          nw_protocol_set_input_handler((uint64_t)handle, 0LL);
LABEL_90:
          *((_DWORD *)handle + 111) = 2;
          return;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
        v94 = (char *)_os_log_send_and_compose_impl();
        v112[0] = 16;
        LOBYTE(v106[0]) = 0;
        if (v112[0] == 17)
        {
          v95 = (os_log_s *)__nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream";
          goto LABEL_210;
        }

        if (!LOBYTE(v106[0]))
        {
          v95 = (os_log_s *)__nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_210;
        }

        v100 = (char *)__nw_create_backtrace_string();
        v95 = (os_log_s *)__nwlog_obj();
        v96 = v112[0];
        v101 = os_log_type_enabled(v95, (os_log_type_t)v112[0]);
        if (v100)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v100;
            _os_log_impl( &dword_181A5C000,  v95,  v96,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v100);
          if (!v94) {
            goto LABEL_90;
          }
          goto LABEL_212;
        }

        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_210:
          _os_log_impl(&dword_181A5C000, v95, v96, v97, buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
        v94 = (char *)_os_log_send_and_compose_impl();
        v112[0] = 16;
        LOBYTE(v106[0]) = 0;
        if (v112[0] == 17)
        {
          v95 = (os_log_s *)__nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol";
          goto LABEL_210;
        }

        if (!LOBYTE(v106[0]))
        {
          v95 = (os_log_s *)__nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0])) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_210;
        }

        v98 = (char *)__nw_create_backtrace_string();
        v95 = (os_log_s *)__nwlog_obj();
        v96 = v112[0];
        v99 = os_log_type_enabled(v95, (os_log_type_t)v112[0]);
        if (!v98)
        {
          if (!v99) {
            goto LABEL_211;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_210;
        }

        if (v99)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v98;
          _os_log_impl( &dword_181A5C000,  v95,  v96,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v98);
      }

    char v6 = 0LL;
  }

  v20 = 0LL;
  if ((*(_WORD *)&self->_has & 0x200) != 0)
  {
LABEL_14:
    time_t v21 = 2654435761LL * self->_noFallback;
    if ((has & 8) != 0) {
      goto LABEL_15;
    }
LABEL_30:
    char v22 = 0LL;
    if ((has & 0x80) != 0) {
      goto LABEL_16;
    }
LABEL_31:
    os_log_type_t v23 = 0LL;
    goto LABEL_32;
  }

    if (v12) {
      free(v12);
    }
    id v3 = v87;
    goto LABEL_31;
  }

        goto LABEL_29;
      }

      if (!v26)
      {
        __nwlog_obj();
        __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v25 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_proxy_config_get_int64";
          _os_log_impl( &dword_181A5C000,  v12,  v25,  "%{public}s called with null key_string, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_28;
      }

      char v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      v24 = os_log_type_enabled(v12, type);
      if (!v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v29 = "nw_proxy_config_get_int64";
          _os_log_impl(&dword_181A5C000, v12, v23, "%{public}s called with null key_string, no backtrace", buf, 0xCu);
        }

        goto LABEL_28;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v29 = "nw_proxy_config_get_int64";
        v30 = 2082;
        v31 = v22;
        _os_log_impl( &dword_181A5C000,  v12,  v23,  "%{public}s called with null key_string, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v22);
    }

  if (v15) {
    free(v15);
  }
  time_t v5 = 0LL;
LABEL_11:

  return v5;
}

    free(v19);
    goto LABEL_29;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v36 = "-[NWNetworkAgentRegistration createReadSourceWithRegistrationSocket:]";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v7, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "-[NWNetworkAgentRegistration createReadSourceWithRegistrationSocket:]";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null registrationSocket", buf, 0xCu);
      }
    }

    else if (v33)
    {
      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)(id)gLogObj;
      BOOL v16 = type;
      os_log_type_t v17 = os_log_type_enabled(v8, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v36 = "-[NWNetworkAgentRegistration createReadSourceWithRegistrationSocket:]";
          v37 = 2082;
          v38 = v15;
          _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null registrationSocket, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        if (!v7) {
          return 0;
        }
        goto LABEL_12;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "-[NWNetworkAgentRegistration createReadSourceWithRegistrationSocket:]";
        _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null registrationSocket, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "-[NWNetworkAgentRegistration createReadSourceWithRegistrationSocket:]";
        _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s called with null registrationSocket, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v7) {
LABEL_12:
  }
    free(v7);
  return 0;
}
}

  if (v12) {
LABEL_29:
  }
    free(v12);
LABEL_40:
}

    if (v25) {
      free(v25);
    }
    return 0LL;
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v7;
  *(void *)(a2 + 32) = 0LL;
  time_t v21 = *(uint64_t **)(v8 + 24);
  *(void *)(a2 + 40) = v21;
  dispatch_queue_t *v21 = a2;
  *(void *)(v8 + 24) = v6;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  char v22 = *(void *)(a1 + 48);
  result = 1LL;
  v24 = *(void *)(v22 + 40) - v10;
  *(void *)(v22 + 40) = v24;
  if (v24) {
    return result;
  }
  **(_BYTE **)(a1 + 56) = 1;
  return 0LL;
}

    free(v17);
    goto LABEL_29;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v9;
    *(_WORD *)&buf[22] = 2114;
    char v64 = (uint64_t (*)(uint64_t, uint64_t))v10;
    *(_WORD *)v65 = 2082;
    *(void *)&v65[2] = a3;
    *(_WORD *)&v65[10] = 2114;
    *(void *)&v65[12] = v11;
    _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ no active request to cancel for %{public}@ %{public}s %{public}@",  buf,  0x34u);
  }

LABEL_34:
  if (v11)
  {
    __int16 v26 = v9;
    __int16 v27 = v11;
    uint64_t v28 = v27;
    if (!v26)
    {
      __nwlog_obj();
      BOOL v41 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_connection_for_connection";
      v42 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v62 = OS_LOG_TYPE_ERROR;
      char v61 = 0;
      if (v62 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v44 = v62;
        if (os_log_type_enabled(v43, v62))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_connection_for_connection";
          _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null serviceConnector", buf, 0xCu);
        }
      }

      else if (v61)
      {
        v47 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v53 = v62;
        v48 = os_log_type_enabled(v43, v62);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_connection_for_connection";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v47;
            _os_log_impl( &dword_181A5C000,  v43,  v53,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v47);
          if (!v42) {
            goto LABEL_89;
          }
          goto LABEL_88;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_connection_for_connection";
          _os_log_impl( &dword_181A5C000,  v43,  v53,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v51 = v62;
        if (os_log_type_enabled(v43, v62))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_connection_for_connection";
          _os_log_impl( &dword_181A5C000,  v43,  v51,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      goto LABEL_86;
    }

    activeConnections = (uint64_t)v26->activeConnections;
    if (activeConnections)
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000LL;
      char v64 = __Block_byref_object_copy__49049;
      *(void *)v65 = __Block_byref_object_dispose__49050;
      *(void *)&v65[8] = 0LL;
      *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
      v56 = 3221225472LL;
      uint64_t v57 = (uint64_t)___ZL58nw_service_connector_copy_active_connection_for_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connection_block_invoke;
      uint64_t v58 = &unk_189BC7820;
      v30 = v27;
      v59 = v30;
      v60 = buf;
      nw_dictionary_apply(activeConnections, (uint64_t)type);
      v31 = (NWConcrete_nw_unique_connection *)*(id *)(*(void *)&buf[8] + 40LL);

      _Block_object_dispose(buf, 8);
      if (v31) {
        nw_service_connector_remove_active_connection(v26, v31);
      }
      goto LABEL_39;
    }

    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_connection_for_connection";
    v42 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v62 = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault(v42, &v62, &v61))
    {
      if (v62 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v46 = v62;
        if (os_log_type_enabled(v43, v62))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_connection_for_connection";
          _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s called with null serviceConnector->activeConnections",  buf,  0xCu);
        }

  return v5;
}

      free(backtrace_string);
    }
  }

      free(backtrace_string);
    }
  }

    free(v13);
    goto LABEL_29;
  }

  BOOL v16 = nw_parameters_copy_required_interface((nw_parameters_t)v6[2]);
  os_log_type_t v17 = v16;
  if (v16) {
    *((_DWORD *)v6 + 3) = *((_DWORD *)v16 + 2);
  }
  id v3 = v6;

LABEL_31:
  return v3;
}

    __int16 v25 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    CFDictionaryAddValue(v25, (const void *)*MEMORY[0x18960BE30], (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryAddValue(v25, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB50]);
    CFDictionaryAddValue(v25, (const void *)*MEMORY[0x18960BE80], v23);
    result = 0LL;
    __int16 v26 = SecItemCopyMatching(v25, &result);
    if (v25) {
      CFRelease(v25);
    }
    if (v26)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v27 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_quic_connection_set_client_identity_reference_internal";
        v38 = 1024;
        v39 = v26;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s Failed to retrieve identity (%d)",  buf,  0x12u);
      }
    }

    if (result)
    {
      if (v12) {
        uint64_t v28 = sec_identity_create_with_certificates((SecIdentityRef)result, v12);
      }
      else {
        uint64_t v28 = sec_identity_create((SecIdentityRef)result);
      }
      uint64_t v29 = v28;
      sec_protocol_options_set_local_identity(*(sec_protocol_options_t *)(v32 + 96), v28);

      if (result) {
        CFRelease(result);
      }
    }

    goto LABEL_40;
  }

  if (a2) {
    *(void *)(a1 + 112) = CFRetain(a2);
  }
}

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v23;
  *(_WORD *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 4LL) = *(_WORD *)(a2 + 204);
  **(_DWORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 192);
  *(_WORD *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 6LL) = *(_WORD *)(a2 + 206);
  *(_WORD *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 8LL) = *(_WORD *)(a2 + 208);
  *(_WORD *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 10LL) = *(_WORD *)(a2 + 210);
  v24 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v24 + 16) = *(_WORD *)(v24 + 16) & 0xFFFE | (*(_WORD *)(a2 + 215) >> 2) & 1;
  __int16 v25 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v25 + 16) = *(_WORD *)(v25 + 16) & 0xFF7F | *(_BYTE *)(a2 + 216) & 0x80;
  __int16 v26 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v26 + 16) = *(_WORD *)(v26 + 16) & 0xFFFD | (*(_WORD *)(a2 + 215) >> 4) & 2;
  __int16 v27 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v27 + 16) = *(_WORD *)(v27 + 16) & 0xFFFB | (*(_WORD *)(a2 + 215) >> 4) & 4;
  uint64_t v28 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v28 + 16) = *(_WORD *)(v28 + 16) & 0xFFF7 | (*(_WORD *)(a2 + 215) >> 4) & 8;
  uint64_t v29 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v29 + 16) = *(_WORD *)(v29 + 16) & 0xFFEF | (*(_WORD *)(a2 + 215) >> 6) & 0x10;
  v30 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v30 + 16) = *(_WORD *)(v30 + 16) & 0xFFDF | (*(_WORD *)(a2 + 215) >> 6) & 0x20;
  v31 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v31 + 16) = *(_WORD *)(v31 + 16) & 0xFFBF | (*(_WORD *)(a2 + 215) >> 6) & 0x40;
  os_log_type_t v32 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v32 + 16) = *(_WORD *)(v32 + 16) & 0xEFFF | (*(_WORD *)(a2 + 215) >> 2) & 0x1000;
  v33 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v33 + 16) = *(_WORD *)(v33 + 16) & 0xDFFF | *(_WORD *)(a2 + 215) & 0x2000;
  v34 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v34 + 16) = *(_WORD *)(v34 + 16) & 0xFBFF | (*(unsigned __int8 *)(a2 + 217) << 6) & 0x400;
  *(_BYTE *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 14LL) = *(_DWORD *)(a2 + 200);
  v35 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v35 + 16) = *(_WORD *)(v35 + 16) & 0xFEFF | ((*(_BYTE *)(*(void *)(a1 + 48) + 24LL) & 1) << 8);
  os_log_type_t v36 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(_WORD *)(v36 + 16) = *(_WORD *)(v36 + 16) & 0xFDFF | (((*(_BYTE *)(*(void *)(a1 + 48) + 24LL) & 2) != 0) << 9);
  *(_BYTE *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 12LL) = v12;
  *(_BYTE *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 13LL) = v16;
  v37 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  v38 = (char *)(v37 + 18);
  if (v16)
  {
    v39 = *(const __CFData **)(a2 + 112);
    if (v39)
    {
      Length = CFDataGetLength(*(CFDataRef *)(a2 + 112));
      BytePtr = CFDataGetBytePtr(v39);
      *(_WORD *)(v37 + 18) = Length;
      memcpy((void *)(v37 + 20), BytePtr, Length);
      v38 = (char *)(v37 + 20 + Length);
    }

    if (v16 != 1)
    {
      v56 = v16 - 1LL;
      uint64_t v57 = 0;
      do
      {
        uint64_t v58 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), v57);
        if (v58)
        {
          v59 = v58;
          v60 = CFDataGetLength(v58);
          char v61 = CFDataGetBytePtr(v59);
          *(_WORD *)v38 = v60;
          os_log_type_t v62 = v38 + 2;
          memcpy(v62, v61, v60);
          v38 = &v62[v60];
        }

        ++v57;
        --v56;
      }

      while (v56);
    }
  }

  if (v20)
  {
    v42 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    *(_WORD *)(v42 + 16) |= 0x800u;
    os_log_type_t v43 = CFDataGetLength(*(CFDataRef *)(a2 + 128));
    *(_WORD *)v38 = v43;
    BOOL v44 = v38 + 2;
    v45 = CFDataGetBytePtr(*(CFDataRef *)(a2 + 128));
    memcpy(v44, v45, v43);
    v38 = &v44[v43];
  }

  v46 = *(const __CFArray **)(a2 + 104);
  if (v46)
  {
    v47 = CFArrayGetCount(v46);
    if (v47)
    {
      v48 = v47;
      for (j = 0LL; j != v48; ++j)
      {
        v50 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 104), j);
        if (v50)
        {
          v51 = v50;
          os_log_type_t v52 = CFDataGetLength(v50);
          os_log_type_t v53 = CFDataGetBytePtr(v51);
          *(_WORD *)v38 = v52;
          uint64_t v54 = v38 + 2;
          memcpy(v54, v53, v52);
          v38 = &v54[v52];
        }
      }
    }
  }

  return 1LL;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_30;
  }

  if ((*((_BYTE *)v3 + 36) & 1) == 0)
  {
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      id v19 = "nw_txt_record_find_key";
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s txt_record is not of type dictionary",  buf,  0xCu);
    }

    goto LABEL_13;
  }

  if ((nw_txt_record_key_is_valid((uint64_t)key) & 1) == 0)
  {
    __nwlog_obj();
    v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      id v19 = "nw_txt_record_find_key";
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, "%{public}s invalid key", buf, 0xCu);
    }

    free(backtrace_string);
    goto LABEL_41;
  }

  if ((*((_BYTE *)v3 + 36) & 1) == 0)
  {
    __nwlog_obj();
    BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_txt_record_apply";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s txt_record is not of type dictionary",  buf,  0xCu);
    }

LABEL_43:
    char v6 = 0;
    goto LABEL_5;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v3 + 8);
  char v6 = nw_txt_record_apply_internal_locked(v3, &__block_literal_global_57260, v5);
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 8);
LABEL_5:

  return v6;
}

  if (v12) {
LABEL_29:
  }
    free(v12);
LABEL_40:
}

  if (v10) {
    free(v10);
  }
  routed_interface_index = 0LL;
LABEL_11:

  return routed_interface_index;
}

  time_t v21 = *(void *)(a2 + 32);
  char v22 = *(void **)(a2 + 40);
  if (v21)
  {
    *(void *)(v21 + 40) = v22;
    char v22 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(v5 + 56) = v22;
  }

  *char v22 = v21;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  v20 = 1LL;
  nw_frame_finalize(a2);
  return v20;
}

              if (a4 >= 0x4000)
              {
                if (a4 >> 30) {
                  v51 = 9;
                }
                else {
                  v51 = 5;
                }
                uint64_t v28 = __CFADD__(a4, v51);
                v30 = a4 + v51;
                if (!v28)
                {
LABEL_68:
                  v11 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))(*(void *)(v26 + 24) + 88LL))( v26,  *((void *)handle + 19),  v29,  v30,  a5,  a6);
                  if ((_DWORD)v11)
                  {
                    *(void *)buf = MEMORY[0x1895F87A8];
                    *(void *)&buf[8] = 0x40000000LL;
                    *(void *)&buf[16] = ___ZL59nw_http3_framer_get_output_frames_for_multiple_http3_framesP15nw_http3_frameryjjjP16nw_frame_array_s_block_invoke;
                    *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_155;
                    *(void *)&v91 = 0LL;
                    *((void *)&v91 + 1) = handle + 128;
                    tqh_first = a6->tqh_first;
                    do
                    {
                      if (!tqh_first) {
                        break;
                      }
                      uint64_t v54 = (nw_frame *)*((void *)tqh_first + 4);
                      v55 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                      tqh_first = v54;
                    }

                    while ((v55 & 1) != 0);
                  }

                  return v11;
                }
              }

              else
              {
                uint64_t v28 = __CFADD__(a4, 3);
                v30 = a4 + 3;
                if (!v28) {
                  goto LABEL_68;
                }
              }

    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  time_t v5 = calloc(1uLL, 0x108uLL);
  if (v5) {
    goto LABEL_3;
  }
  os_log_type_t v13 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  time_t v21 = "strict_calloc";
  char v22 = 2048;
  os_log_type_t v23 = 1LL;
  v24 = 2048;
  __int16 v25 = 264LL;
  BOOL v14 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
LABEL_3:
    v5[32] = 0LL;
    *((_OWORD *)v5 + 14) = 0u;
    *((_OWORD *)v5 + 15) = 0u;
    *((_OWORD *)v5 + 12) = 0u;
    *((_OWORD *)v5 + 13) = 0u;
    *((_OWORD *)v5 + 10) = 0u;
    *((_OWORD *)v5 + 11) = 0u;
    *((_OWORD *)v5 + 8) = 0u;
    *((_OWORD *)v5 + 9) = 0u;
    *((_OWORD *)v5 + 6) = 0u;
    *((_OWORD *)v5 + 7) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *(_OWORD *)time_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    if (gLogDatapath)
    {
      os_log_type_t v15 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        time_t v21 = "nw_protocol_http_early_data_create";
        char v22 = 2082;
        os_log_type_t v23 = (uint64_t)v5 + 114;
        v24 = 2080;
        __int16 v25 = (uint64_t)" ";
        _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }

    if (nw_protocol_http_early_data_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http_early_data_identifier::onceToken, &__block_literal_global_63649);
    }
    v5[2] = &nw_protocol_http_early_data_identifier::protocol_identifier;
    v5[3] = &nw_protocol_http_early_data_get_callbacks(void)::protocol_callbacks;
    v5[5] = v5;
    char v6 = a4;
    BOOL v7 = v6[12];

    *((_BYTE *)v5 + 256) = v5[32] & 0xFE | ((v7 & 0x8000) != 0);
    v5[8] = v5 + 13;
    nw_protocol_plugin_name_set_callbacks((uint64_t)v5, (uint64_t)nw_protocol_http_early_data_create::$_0::__invoke);
    return (BOOL)v5;
  }

  __break(1u);
  return result;
}

    if (v12) {
      free(v12);
    }
    nw_frame_claim(a2, v13, 0, *((_DWORD *)v49 + 6));
    goto LABEL_31;
  }

  buf = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(*(void *)(a1 + 32) + 232LL), &buf);
  time_t v5 = *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 40) == buf)
  {
    char v6 = *(_BYTE *)(v5 + 240);
    if ((v6 & 1) != 0)
    {
      BOOL v7 = *(dispatch_object_s **)(v5 + 232);
      if (v7)
      {
        dispatch_release(v7);
        char v6 = *(_BYTE *)(v5 + 240);
      }
    }

    *(void *)(v5 + 232) = 0LL;
    *(_BYTE *)(v5 + 240) = v6 | 1;
    os_log_type_t v4 = *(void *)(a1 + 32);
    goto LABEL_8;
  }

  id v19 = dispatch_data_create_subrange(*(dispatch_data_t *)(v5 + 232), buf, 0xFFFFFFFFFFFFFFFFLL);
  v20 = *(void *)(a1 + 32);
  time_t v21 = *(_BYTE *)(v20 + 240);
  if ((v21 & 1) != 0)
  {
    char v22 = *(dispatch_object_s **)(v20 + 232);
    if (v22)
    {
      dispatch_release(v22);
      time_t v21 = *(_BYTE *)(v20 + 240);
    }
  }

  char v8 = 0;
  *(void *)(v20 + 232) = v19;
  *(_BYTE *)(v20 + 240) = v21 | 1;
LABEL_41:
  nw_frame_set_metadata(a2, *(nw_protocol_metadata **)(*(void *)(a1 + 32) + 200LL), 0, v8);
  return 1LL;
}

      os_log_type_t v23 = *(unsigned __int16 *)v10;
      v11 = v23 | (a1[6].flow_id[15] << 16);
      if ((v23 & 0x8000) != 0 && (_DWORD)v12)
      {
        *(_WORD *)v10 = v23;
        a1[6].flow_id[15] = (v11 | 0x10000u) >> 16;
        return v12;
      }

      if ((_DWORD)v12) {
        return v12;
      }
      goto LABEL_42;
    }

    if (a4 <= 0x10000)
    {
      v31 = 0x10000;
      goto LABEL_81;
    }

    v68 = 4;
    *(_DWORD *)uint64_t v69 = 0;
    if (!getsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4132, v69, &v68))
    {
LABEL_58:
      v66 = 4;
      *(_DWORD *)os_log_type_t type = 0x10000;
      if (!getsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4097, type, &v66))
      {
        v42 = *(_DWORD *)type;
LABEL_80:
        v31 = v42 - *(_DWORD *)v69;
LABEL_81:
        v47 = 0;
        __int16 v12 = 0LL;
        if (a3) {
          goto LABEL_84;
        }
LABEL_82:
        if (!(_DWORD)v12)
        {
          do
          {
            if (v31 == v47) {
              break;
            }
            v49 = a4 - v47 >= v31 - v47 ? v31 - v47 : a4 - v47;
            if (!(_DWORD)v49 && (_DWORD)v12) {
              break;
            }
            v50 = nw_socket_allocate_output_frame((uint64_t)p_output_handler, v49);
            if (!v50) {
              break;
            }
            *(void *)(v50 + 16) = 0LL;
            v51 = *(uint64_t **)a1[5].flow_id;
            *(void *)(v50 + 24) = v51;
            const char *v51 = v50;
            *(void *)a1[5].flow_id = v50 + 16;
            *(void *)(v50 + 32) = 0LL;
            os_log_type_t v52 = a6->tqh_last;
            *(void *)(v50 + 40) = v52;
            *os_log_type_t v52 = (nw_frame *)v50;
            a6->tqh_last = (nw_frame **)(v50 + 32);
            __int16 v12 = (v12 + 1);
            v47 += v49;
            if (v47 >= a3) {
              goto LABEL_82;
            }
LABEL_84:
            ;
          }

          while (!(_DWORD)v12 || a4 > v47);
        }

        goto LABEL_28;
      }

      os_log_type_t v36 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v37 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v71 = "nw_socket_get_output_frames";
        v72 = 2080;
        *(void *)v73 = (char *)a1 + 404;
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v36;
        _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_ERROR,  "%{public}s %s getsockopt SO_SNDBUF failed %{darwin.errno}d",  buf,  0x1Cu);
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v71 = "nw_socket_get_output_frames";
      v72 = 1024;
      *(_DWORD *)v73 = v36;
      v38 = (char *)_os_log_send_and_compose_impl();
      v65 = OS_LOG_TYPE_ERROR;
      char v64 = 0;
      if (__nwlog_fault(v38, &v65, &v64))
      {
        if (v65 == OS_LOG_TYPE_FAULT)
        {
          v39 = (os_log_s *)__nwlog_obj();
          os_log_type_t v40 = v65;
          if (os_log_type_enabled(v39, v65))
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_socket_get_output_frames";
            v72 = 1024;
            *(_DWORD *)v73 = v36;
            BOOL v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d";
LABEL_75:
            v46 = v39;
LABEL_76:
            _os_log_impl(&dword_181A5C000, v46, v40, v41, buf, 0x12u);
          }
        }

        else if (v64)
        {
          os_log_type_t v43 = (char *)__nw_create_backtrace_string();
          BOOL v44 = (os_log_s *)__nwlog_obj();
          os_log_type_t v40 = v65;
          loga = v44;
          v45 = os_log_type_enabled(v44, v65);
          if (v43)
          {
            if (v45)
            {
              *(_DWORD *)buf = 136446722;
              v71 = "nw_socket_get_output_frames";
              v72 = 1024;
              *(_DWORD *)v73 = v36;
              *(_WORD *)&v73[4] = 2082;
              *(void *)&v73[6] = v43;
              _os_log_impl( &dword_181A5C000,  loga,  v40,  "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v43);
            goto LABEL_77;
          }

          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_socket_get_output_frames";
            v72 = 1024;
            *(_DWORD *)v73 = v36;
            BOOL v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, no backtrace";
            v46 = loga;
            goto LABEL_76;
          }
        }

        else
        {
          v39 = (os_log_s *)__nwlog_obj();
          os_log_type_t v40 = v65;
          if (os_log_type_enabled(v39, v65))
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_socket_get_output_frames";
            v72 = 1024;
            *(_DWORD *)v73 = v36;
            BOOL v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_75;
          }
        }
      }

    free(v11);
    goto LABEL_29;
  }

  __nwlog_obj();
  id v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_proxy_hop_create_masque";
  v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v27 = 0;
  if (__nwlog_fault(v20, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      time_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null proxy_endpoint", buf, 0xCu);
      }
    }

    else if (v27)
    {
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      time_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v24 = type;
      __int16 v25 = os_log_type_enabled(v21, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_proxy_hop_create_masque";
          v31 = 2082;
          os_log_type_t v32 = v23;
          _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s called with null proxy_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
        goto LABEL_47;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_proxy_hop_create_masque";
        _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null proxy_endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      time_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_proxy_hop_create_masque";
        _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s called with null proxy_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(v9);
    goto LABEL_29;
  }

  char v6 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_evaluator);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "nw_path_create_evaluator_for_advertise";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)(id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed",  buf,  0xCu);
      }
    }

    else if (v25)
    {
      BOOL v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (v14)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v28 = "nw_path_create_evaluator_for_advertise";
          uint64_t v29 = 2082;
          v30 = v14;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v14);
        if (!v9) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "nw_path_create_evaluator_for_advertise";
        _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_26;
  }

  if (v5) {
    BOOL v7 = (nw_parameters_t)v5;
  }
  else {
    BOOL v7 = nw_parameters_create();
  }
  __int16 v12 = (void *)*((void *)v6 + 1);
  *((void *)v6 + 1) = v7;

  objc_storeStrong((id *)v6 + 5, a1);
  if ((nw_path_evaluator_evaluate(v6, 0LL) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v13 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "nw_path_create_evaluator_for_advertise";
      _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    goto LABEL_29;
  }

  __int16 v25 = 60LL;
  if (!v17) {
    goto LABEL_38;
  }
LABEL_29:
  __int16 v27 = v17;
  uint64_t v28 = [v27 type];

  if (v28 == 1)
  {
    address = nw_endpoint_get_address((nw_endpoint_t)v27);
    v30 = address;
    if (address)
    {
      sa_family = address->sa_family;
      if (sa_family == 30 || sa_family == 2)
      {
        sa_len = address->sa_len;
        if (sa_len <= 0x1C)
        {
          v25 += sa_len;
          v23 |= 0x10u;
          LOWORD(v61) = v23;
          if (gLogDatapath)
          {
            __nwlog_obj();
            log = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              uint64_t v57 = "nw_path_evaluator_create_flow_inner";
              uint64_t v58 = 2112;
              *(void *)v59 = v27;
              *(_WORD *)&v59[8] = 1024;
              *(_DWORD *)&v59[10] = v23;
              *(_WORD *)&v59[14] = 2048;
              *(void *)&v59[16] = v25;
              _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s Adding override endpoint %@, flags %x, length %zu",  buf,  0x26u);
            }

            sa_len = v30->sa_len;
          }

          v33 = 36LL;
          if (a2) {
            v33 = 60LL;
          }
          memcpy(&out[v33], v30, sa_len);
        }
      }
    }
  }

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_11:

  return v6;
}

    free(backtrace_string);
    goto LABEL_41;
  }

  char v6 = (nw_interface *)v3[14];
  if (!v6)
  {
    char v8 = (void *)v3[21];
    if (v8)
    {
      os_log_type_t v9 = (void *)v3[22];
      if (v9)
      {
        nw_parameters_set_required_netagent_classes(v4, v8, v9);
        goto LABEL_5;
      }
    }

      if (!v11)
      {
LABEL_30:
        v49[3] = 0LL;
        goto LABEL_31;
      }

    v31 = 0LL;
LABEL_46:

    goto LABEL_47;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v9 = (id)gLogObj;
  v10 = v5;
  v11 = [v10 type];

  *(_DWORD *)buf = 136446466;
  os_log_type_t v53 = "nw_endpoint_is_broadcast";
  uint64_t v54 = 1024;
  *(_DWORD *)v55 = v11;
  LODWORD(v49) = 18;
  __int16 v12 = (const char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v50 = 0;
  if (__nwlog_fault(v12, &type, &v50))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (os_log_s *)(id)gLogObj;
      BOOL v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        os_log_type_t v15 = v10;
        BOOL v16 = objc_msgSend(v15, "type", buf, v49);

        *(_DWORD *)buf = 136446466;
        os_log_type_t v53 = "nw_endpoint_is_broadcast";
        uint64_t v54 = 1024;
        *(_DWORD *)v55 = v16;
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s incorrect endpoint type %u", buf, 0x12u);
      }
    }

    else if (v50)
    {
      os_log_type_t v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (os_log_s *)(id)gLogObj;
      v18 = type;
      id v19 = os_log_type_enabled(v13, type);
      if (v17)
      {
        if (v19)
        {
          v20 = v10;
          time_t v21 = objc_msgSend(v20, "type", buf, v49);

          *(_DWORD *)buf = 136446722;
          os_log_type_t v53 = "nw_endpoint_is_broadcast";
          uint64_t v54 = 1024;
          *(_DWORD *)v55 = v21;
          v55[2] = 2082;
          *(void *)&v55[3] = v17;
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v17);
        if (!v12) {
          goto LABEL_38;
        }
        goto LABEL_36;
      }

      if (v19)
      {
        v35 = v10;
        os_log_type_t v36 = objc_msgSend(v35, "type", buf, v49);

        *(_DWORD *)buf = 136446466;
        os_log_type_t v53 = "nw_endpoint_is_broadcast";
        uint64_t v54 = 1024;
        *(_DWORD *)v55 = v36;
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v13, type))
      {
        v33 = v10;
        v34 = objc_msgSend(v33, "type", buf, v49);

        *(_DWORD *)buf = 136446466;
        os_log_type_t v53 = "nw_endpoint_is_broadcast";
        uint64_t v54 = 1024;
        *(_DWORD *)v55 = v34;
        _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
      }
    }
  }

  if (v12)
  {
LABEL_36:
    v37 = (char *)v12;
LABEL_37:
    free(v37);
  }

  if (v14) {
    free(v14);
  }
  return 0LL;
}

  if (v9)
  {
    os_log_type_t v15 = (char *)v9;
LABEL_30:
    free(v15);
  }

  return 0LL;
}

    if (v11) {
      free(v11);
    }
    goto LABEL_10;
  }

  os_log_type_t v4 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v4->mode;

  if ((_DWORD)mode != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      else {
        os_log_type_t v9 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      char v22 = "nw_endpoint_handler_get_proxy_result";
      os_log_type_t v23 = 2082;
      v24 = (void *)v9;
      __int16 v25 = 2082;
      __int16 v26 = "proxy";
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

LABEL_10:
    BOOL v7 = 0;
    goto LABEL_11;
  }

  char v6 = nw_endpoint_handler_copy_proxy(v4);
  BOOL v7 = *((_BYTE *)v6 + 99);

LABEL_11:
  *(_BYTE *)(*(void *)(a1 + 32) + 1704LL) = v7;
}

      free(v21);
      goto LABEL_29;
    }
  }

  else
  {
    os_log_type_t v9 = v2[2];
    if (v9 && !nw_path_parameters_get_logging_disabled(*(void *)(v9 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v10 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        v11 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)&buf.var0 = 136446466;
        *(void *)&buf.var4 = "nw_connection_copy_tcp_info_block_invoke";
        LOWORD(buf.var6) = 1024;
        *(unsigned int *)((char *)&buf.var6 + 2) = v11;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] No parent endpoint handler",  &buf.var0,  0x12u);
      }
    }
  }

      _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0x16u);
      goto LABEL_29;
    }

void sub_181A644E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_parameters_copy_context(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    id v3 = v1[17];
    goto LABEL_3;
  }

  __nwlog_obj();
  time_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_path_parameters_copy_context";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_path_parameters_copy_context";
          __int16 v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_parameters_copy_context";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  BOOL v7 = 1LL;
LABEL_21:

  return v7;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v11) {
    free(v11);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_endpoint_type_invalid;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  options = 0LL;
LABEL_3:

  return options;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:
  _Block_object_dispose(&v18, 8);

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

    if (v4) {
      free(v4);
    }
    return 0LL;
  }

  v1 = *(void *)(a1 + 136);
  if (v1) {
    return *(_DWORD *)(v1 + 124) == 4;
  }
  return 0LL;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

        if (v14 >= 1)
        {
          os_log_type_t v23 = *(_DWORD **)(a1 + 32);
          v24 = v23[20];
          __int16 v25 = v23;
          nw_context_assert_queue(v25[3]);
          nw_connection_report_state_with_handler_on_nw_queue(v25, v24, v25[26], v25[25]);
        }

        nw_endpoint_handler_start(*(void **)(*(void *)(a1 + 32) + 144LL));
        os_log_type_t v12 = v45;
        goto LABEL_33;
      }

      __nwlog_obj();
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
      os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v43 = v14;
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (__nwlog_fault(v36, &type, &v48))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v38 = type;
          if (os_log_type_enabled(v37, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_181A5C000, v37, v38, "%{public}s called with null parameters", buf, 0xCu);
          }
        }

        else if (v48)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v40 = type;
          BOOL v41 = os_log_type_enabled(v37, type);
          if (backtrace_string)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v37,  v40,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_50;
          }

          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_181A5C000, v37, v40, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v42 = type;
          if (os_log_type_enabled(v37, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl( &dword_181A5C000,  v37,  v42,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 1LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = "";
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    objc_storeStrong((id *)v7 + 2, a1);
    if (v4 == 0LL && v5 == 0LL) {
      *((_BYTE *)v7 + 107) |= 1u;
    }
    goto LABEL_22;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v32 = "nw_path_create_evaluator_for_endpoint_no_evaluate";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v29 = 0;
  if (__nwlog_fault(v12, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)(id)gLogObj;
      BOOL v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_path_create_evaluator_for_endpoint_no_evaluate";
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed",  buf,  0xCu);
      }
    }

    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)(id)gLogObj;
      __int16 v26 = type;
      __int16 v27 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v32 = "nw_path_create_evaluator_for_endpoint_no_evaluate";
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v12) {
          goto LABEL_16;
        }
        goto LABEL_23;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_path_create_evaluator_for_endpoint_no_evaluate";
        _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)(id)gLogObj;
      uint64_t v28 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_path_create_evaluator_for_endpoint_no_evaluate";
        _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v12) {
LABEL_16:
  }
    free(v12);
LABEL_23:

  return v7;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 24);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_interface_type_other;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(id **)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *v3;
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 8);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 16);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 48);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 32);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 40);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 72);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 56);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 64);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 96);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 120);
LABEL_23:

  return v4;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 176LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(id *)(v3 + 128);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *((void *)v1 + 13);
  if (!*(_BYTE *)(v3 + 102))
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(void *)(v3 + 120);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v11) {
    free(v11);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}
          }

          break;
        case 2:
          os_log_type_t v52 = v160;
          v160->policy_result.routing_result = 0;
          if ((_DWORD)v20 == 4) {
            goto LABEL_93;
          }
          v71 = v14;
          __nwlog_obj();
          v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
            v164 = 1024;
            *(_DWORD *)v165 = 2;
            *(_WORD *)&v165[4] = 1024;
            *(_DWORD *)&v165[6] = v20;
            *(_WORD *)&v165[10] = 1024;
            *(_DWORD *)&v165[12] = 4;
            _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
          }

          os_log_type_t v52 = v160;
LABEL_93:
          v52->policy_result.routing_result = *(_DWORD *)v27;
          break;
        case 3:
          v46 = v160;
          v160->policy_result.routing_result_parameter.tunnel_interface_index = 0;
          if ((_DWORD)v20 == 4) {
            goto LABEL_81;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 3;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

            v46 = v160;
LABEL_81:
            v46->policy_result.routing_result_parameter.tunnel_interface_index = *(_DWORD *)v27;
          }

          break;
        case 4:
          uint64_t v57 = v160;
          v160->policy_result.filter_control_unit = 0;
          if ((_DWORD)v20 == 4) {
            goto LABEL_116;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 4;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

            uint64_t v57 = v160;
LABEL_116:
            v57->policy_result.filter_control_unit = *(_DWORD *)v27;
          }

          break;
        case 5:
          if ((_DWORD)v20 == 4) {
            goto LABEL_118;
          }
          if (v20 >= 5)
          {
            __nwlog_obj();
            v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
              v164 = 1024;
              *(_DWORD *)v165 = 5;
              *(_WORD *)&v165[4] = 1024;
              *(_DWORD *)&v165[6] = v20;
              *(_WORD *)&v165[10] = 1024;
              *(_DWORD *)&v165[12] = 4;
              _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
            }

LABEL_118:
            v160->policy_result.routed_interface_index = *(_DWORD *)v27;
          }

          break;
        case 6:
          v47 = v155;
          if (HIDWORD(v158) < v155) {
            goto LABEL_86;
          }
          v48 = v155 + 8;
          if (v155 != -8) {
            goto LABEL_84;
          }
          v88 = v14;
          __nwlog_obj();
          v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v89, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "_strict_reallocf";
          v153 = buf;
          v90 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v90);
          if (result) {
            goto LABEL_375;
          }
          free(v90);
          BOOL v14 = v88;
LABEL_84:
          v47 = v155 + 8;
          v49 = (necp_client_result_netagent *)reallocf(v14, 20LL * v48);
          if (v49)
          {
            BOOL v14 = v49;
          }

          else
          {
            __nwlog_obj();
            v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "_strict_reallocf";
            v164 = 2048;
            *(void *)v165 = 20LL * v48;
            v153 = buf;
            v93 = (void *)_os_log_send_and_compose_impl();

            result = __nwlog_abort((uint64_t)v93);
            if (result) {
              goto LABEL_375;
            }
            free(v93);
            BOOL v14 = 0LL;
          }

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *(void *)(*((void *)v1 + 13) + 168LL);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(unsigned int *)(v3 + 8);
LABEL_23:

  return v4;
}

    if (v5) {
      free(v5);
    }
    goto LABEL_22;
  }

  if (!nw_path_network_is_satisfied_update_reason(v1, 0LL))
  {
LABEL_22:
    id v3 = 0LL;
    goto LABEL_23;
  }

  id v3 = v2[80];
LABEL_23:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v4 != 0LL;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_22;
  }

  id v3 = v1;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke;
  uint64_t v19 = &unk_189BC93A0;
  os_log_type_t v4 = v3;
  v20 = v4;
  os_unfair_lock_lock(v4 + 2);
  ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v4 + 2);

  time_t v5 = *(void *)&v4[46]._os_unfair_lock_opaque;
  if (!v5)
  {
LABEL_22:
    char v6 = 0;
    goto LABEL_23;
  }

  char v6 = *(void *)(v5 + 24) != *(void *)(v5 + 16);
LABEL_23:

  return v6;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v10) {
    free(v10);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  BOOL v14 = *(void **)(*(void *)(a1 + 32) + 16LL);
  if (!v14)
  {
    uint64_t v28 = 0LL;
    uint64_t v29 = 0;
    goto LABEL_113;
  }

  os_log_type_t v15 = v14;
  BOOL v16 = v15[23];

  if (!v16)
  {
    uint64_t v29 = 0;
    goto LABEL_72;
  }

  __int16 v17 = (id *)v16;
  v18 = v17[5];

  if (v18)
  {
    uint64_t v19 = v18;
    v20 = [v19 type];
  }

  time_t v21 = v17;
  char v22 = *((_DWORD *)v21 + 38);
  if (v22 == 1)
  {
    v30 = *((_DWORD *)v21 + 39);

    if (v30 != 1) {
      goto LABEL_43;
    }
LABEL_39:
    *(void *)v99 = 0LL;
    *(void *)&v99[8] = v99;
    *(void *)&v99[16] = 0x2020000000LL;
    v100 = 0;
    *(void *)v98 = 0LL;
    *(void *)&v98[8] = v98;
    *(void *)&v98[16] = 0x2020000000LL;
    v98[24] = 0;
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    v95 = __Block_byref_object_copy__5627;
    v96 = __Block_byref_object_dispose__5628;
    v97 = 0LL;
    v84[0] = MEMORY[0x1895F87A8];
    v84[1] = 3221225472LL;
    v84[2] = __nw_resolver_set_update_handler_block_invoke_73;
    v84[3] = &unk_189BB68A8;
    v89 = required_address_family;
    v86 = v99;
    v87 = buf;
    v85 = *(id *)(a1 + 32);
    v88 = v98;
    nw_proxy_config_enumerate_resolved_endpoints(v17, v84);
    v83 = 0;
    scoped_interface_index = nw_resolver_get_scoped_interface_index(*(NWConcrete_nw_resolver **)(a1 + 32), &v83);
    os_log_type_t v32 = *(void **)(*(void *)(a1 + 32) + 200LL);
    if (v32)
    {
      v33 = (nw_interface *)nw_path_copy_interface(v32);
      v34 = v33;
      if (v33) {
        LODWORD(v32) = nw_interface_get_type(v33);
      }
      else {
        LODWORD(v32) = 0;
      }
    }

    else
    {
      v34 = 0LL;
    }

    v35 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v35 && v35[3] != v35[2])
    {
      os_log_type_t v36 = *(void *)(a1 + 32);
      if (scoped_interface_index == -1 || (_DWORD)v32 == 4)
      {
        if (!v36)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            v39 = *(void *)(*(void *)&buf[8] + 40LL);
            *(_DWORD *)v90 = 136446466;
            v91 = "nw_resolver_set_update_handler_block_invoke_2";
            v92 = 2112;
            *(void *)v93 = v39;
            os_log_type_t v40 = "%{public}s found proxy resolved endpoints %@";
            BOOL v41 = v38;
            v42 = 22;
LABEL_67:
            _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_INFO, v40, v90, v42);
          }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_parameters_expired_dns_behavior_default;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

    if (v5) {
      free(v5);
    }
    return nw_copy_current_audit_token::valid != 0;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_copy_current_audit_token";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      char v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_copy_current_audit_token";
        BOOL v14 = "%{public}s called with null audit_token";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
      }
    }

    else if (v17)
    {
      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      char v13 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (v15)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_copy_current_audit_token";
          time_t v21 = 2082;
          *(void *)char v22 = v15;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null audit_token, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        goto LABEL_37;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_copy_current_audit_token";
        BOOL v14 = "%{public}s called with null audit_token, no backtrace";
        goto LABEL_36;
      }
    }

    else
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      char v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_copy_current_audit_token";
        BOOL v14 = "%{public}s called with null audit_token, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
  }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_interface_type_other;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  *(_WORD *)(a1 + 196) += a3;
LABEL_21:
  char v13 = *(_DWORD *)(a1 + 56);
  BOOL v14 = v13 >= a3;
  os_log_type_t v15 = v13 - a3;
  if (v14)
  {
    time_t v21 = *(_DWORD *)(a1 + 60);
    BOOL v14 = v21 >= a4;
    char v22 = v21 - a4;
    if (v14)
    {
      *(_DWORD *)(a1 + 56) = v15;
      *(_DWORD *)(a1 + 60) = v22;
      return 1LL;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        v24 = *(_DWORD *)(a1 + 60);
        *(_DWORD *)buf = 136446722;
        v34 = "__nw_frame_unclaim_internal";
        v35 = 1024;
        *(_DWORD *)os_log_type_t v36 = a4;
        v36[2] = 1024;
        *(_DWORD *)&v36[3] = v24;
        uint64_t v19 = "%{public}s Frame cannot unclaim %u end bytes (has %u left)";
        v20 = (os_log_s *)v23;
        goto LABEL_27;
      }
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v16 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v18 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136446722;
      v34 = "__nw_frame_unclaim_internal";
      v35 = 1024;
      *(_DWORD *)os_log_type_t v36 = a3;
      v36[2] = 1024;
      *(_DWORD *)&v36[3] = v18;
      uint64_t v19 = "%{public}s Frame cannot unclaim %u start bytes (has %u left)";
      v20 = (os_log_s *)v16;
LABEL_27:
      _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_ERROR, v19, buf, 0x18u);
      return 0LL;
    }
  }

  return result;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
}

  __break(1u);
  return result;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

    if (v12) {
      free(v12);
    }
    goto LABEL_22;
  }

  mode = v7->mode;

  if (mode == 1)
  {
    os_log_type_t v10 = (void **)nw_endpoint_handler_copy_resolver(v8);
    nw_resolver_get_svcb_report(v10[1], a2, a3, a4);

    goto LABEL_29;
  }

  if (v6) {
    free(v6);
  }
  id v3 = nw_multipath_service_disabled;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v10) {
    free(v10);
  }
  BOOL v7 = 0LL;
LABEL_3:

  return v7;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v9) {
    free(v9);
  }
  is_equal_unsafe = 0;
LABEL_3:

  return is_equal_unsafe;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:
  _Block_object_dispose(&v18, 8);

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  __int16 v26 = (void *)*((void *)handle + 27);
  if (v26) {
    __int16 v27 = v12 == 0LL;
  }
  else {
    __int16 v27 = 1;
  }
  if (v27)
  {
    data1 = 0LL;
    goto LABEL_347;
  }

  v238 = v16;
  data1 = 0LL;
  v252 = 0;
  os_log_type_t v36 = (id *)(handle + 264);
  v221 = (dispatch_block_t)*MEMORY[0x1895F8A88];
  v37 = (uint64_t)v12;
  v234 = (id *)(handle + 264);
  while (1)
  {
    v38 = *(void **)(v37 + 32);
    v236 = (void *)(v37 + 32);
    if (!v38 && !*(void *)(v37 + 40)) {
      v38 = 0LL;
    }
    v246 = v38;
    if (!*(void *)(v37 + 112)
      || (*(_WORD *)(v37 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v37, *(void *)(v37 + 88)))
    {
      BOOL v41 = 0;
      buffer = 0LL;
    }

    else
    {
      os_log_type_t v40 = *(_DWORD *)(v37 + 52);
      v39 = *(unsigned int *)(v37 + 56);
      BOOL v41 = v40 ? v40 - (v39 + *(_DWORD *)(v37 + 60)) : 0;
      buffer = (char *)(*(void *)(v37 + 112) + v39);
    }

    memset(uu, 0, sizeof(uu));
    memset(out, 0, sizeof(out));
    v42 = *(_WORD *)(v37 + 204);
    os_log_type_t v43 = *(void *)(v37 + 64);
    data = (dispatch_data_t)alloc;
    v249 = v41;
    if (v43)
    {
      v243 = (*(unsigned __int8 *)(v43 + 66) >> 6) & 1;
      if (*(void *)(v43 + 48))
      {
        *(_OWORD *)uu = *(_OWORD *)(v43 + 16);
LABEL_57:
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v136 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v229);
            v138 = nw_endpoint_handler_dry_run_string(v229);
            v139 = nw_endpoint_handler_copy_endpoint(v229);
            logging_description = nw_endpoint_get_logging_description(v139);
            v141 = nw_endpoint_handler_state_string(v229);
            v142 = nw_endpoint_handler_mode_string(v229);
            v143 = nw_endpoint_handler_copy_current_path(v229);
            v144 = v143;
            *(_DWORD *)buf = 136448770;
            v145 = ", complete";
            if (!v243) {
              v145 = "";
            }
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            v146 = ", wake_packet";
            if ((v42 & 0x4000) == 0) {
              v146 = "";
            }
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = id_string;
            *(_WORD *)&buf[22] = 2082;
            v273 = (uint64_t (*)(uint64_t, uint64_t))v138;
            *(_WORD *)v274 = 2082;
            *(void *)&v274[2] = logging_description;
            *(_WORD *)&v274[10] = 2082;
            *(void *)&v274[12] = v141;
            v275 = 2082;
            v276 = v142;
            v277 = 2114;
            v278 = v143;
            v279 = 1042;
            *(_DWORD *)v280 = 16;
            *(_WORD *)&v280[4] = 2098;
            *(void *)&v280[6] = uu;
            *(_WORD *)&v280[14] = 2080;
            *(void *)&v280[16] = v145;
            *(_WORD *)&v280[24] = 2080;
            *(void *)&v280[26] = v146;
            _os_log_impl( &dword_181A5C000,  v136,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Found frame with context %{public,uuid_t}.16P%s%s",  buf,  0x6Cu);
          }

          handle = v251;
          os_log_type_t v36 = v234;
        }

        if ((a6 & 1) != 0 || v248->multiplexed_message_definition)
        {
          v45 = *v36;
          if (v45)
          {
LABEL_61:
            v46 = (nw_content_context *)v45;
            v47 = v46;
            goto LABEL_64;
          }

          v47 = nw_content_context_create(*(const char **)(*((void *)handle + 4) + 16LL));
          nw_content_context_set_is_final(v47, 1);
          objc_storeStrong(v36, v47);
        }

        else
        {
          if (!*((void *)handle + 32))
          {
            v116 = nw_dictionary_create();
            v117 = (void *)*((void *)handle + 32);
            *((void *)handle + 32) = v116;

            handle = v251;
          }

          uuid_unparse_upper(uu, out);
          v45 = nw_dictionary_copy_value(*((void *)handle + 32), (uint64_t)out);
          if (v45) {
            goto LABEL_61;
          }
          v47 = nw_content_context_create(*(const char **)(*((void *)handle + 4) + 16LL));
          nw_dictionary_set_value(*((void *)handle + 32), out, v47);
        }

        v46 = 0LL;
LABEL_64:

        v263[0] = MEMORY[0x1895F87A8];
        v263[1] = 3221225472LL;
        v263[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_79;
        v263[3] = &unk_189BB84B0;
        v266 = v251;
        v264 = v248;
        v48 = v47;
        v265 = v48;
        nw_frame_foreach_protocol_metadata(v37, a5, (uint64_t)v263);
        v49 = v48;
        if ((v42 & 0x4000) == 0) {
          goto LABEL_78;
        }
        v50 = v48;
        v51 = v50;
        if (v50)
        {
          if (v50 != (nw_content_context *)&__block_literal_global_5_41854
            && v50 != (nw_content_context *)&__block_literal_global_4
            && v50 != (nw_content_context *)&__block_literal_global_3_41839
            && v50 != (nw_content_context *)&__block_literal_global_41831)
          {
            *((_BYTE *)v50 + 118) |= 0x80u;
          }
  }
  }

    if (!v3) {
      return;
    }
    goto LABEL_21;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v14 = "nw_frame_will_free_buffer_externally";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v11 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    time_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_20;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v14 = "nw_frame_will_free_buffer_externally";
    char v6 = "%{public}s called with null frame";
    goto LABEL_19;
  }

  if (!v11)
  {
    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    time_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_20;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v14 = "nw_frame_will_free_buffer_externally";
    char v6 = "%{public}s called with null frame, backtrace limit exceeded";
    goto LABEL_19;
  }

  os_log_type_t v9 = (char *)__nw_create_backtrace_string();
  os_log_type_t v4 = (os_log_s *)__nwlog_obj();
  time_t v5 = type;
  os_log_type_t v10 = os_log_type_enabled(v4, type);
  if (!v9)
  {
    if (!v10) {
      goto LABEL_20;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v14 = "nw_frame_will_free_buffer_externally";
    char v6 = "%{public}s called with null frame, no backtrace";
LABEL_19:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_20;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v14 = "nw_frame_will_free_buffer_externally";
    os_log_type_t v15 = 2082;
    BOOL v16 = v9;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v3) {
LABEL_21:
  }
    free(v3);
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v10) {
    free(v10);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
}

  if (v5) {
    free(v5);
  }
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
}

  if (v8) {
    free(v8);
  }
LABEL_3:

  return (nw_data_transfer_report_t)v5;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = nw_data_transfer_report_state_collecting;
LABEL_3:

  return v4;
}

        v37 = v6[12];
        v38 = (void *)(a1 + v37);
        v39 = (void *)(a2 + v37);
        os_log_type_t v40 = v23((void *)(a1 + v37), 1LL, v22);
        BOOL v41 = v23(v39, 1LL, v22);
        if (v40)
        {
          if (!v41)
          {
            v42 = (char *)&loc_181C17434 + 4 * byte_18265F5B8[swift_getEnumCaseMultiPayload()];
            __asm { BR              X10 }
          }
        }

        else
        {
          if (!v41)
          {
            if (a1 != a2)
            {
              sub_181BC920C((uint64_t)v38, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
              BOOL v44 = (char *)&loc_181C174EC + 4 * byte_18265F5BD[swift_getEnumCaseMultiPayload()];
              __asm { BR              X10 }
            }

            goto LABEL_28;
          }

          sub_181BC920C((uint64_t)v38, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
        }

        os_log_type_t v43 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C45E580);
        memcpy(v38, v39, *(void *)(*(void *)(v43 - 8) + 64LL));
LABEL_28:
        *(void *)(a1 + v6[13]) = *(void *)(a2 + v6[13]);
        swift_unknownObjectRetain();
        swift_unknownObjectRelease();
        goto LABEL_29;
      }

      sub_181BC920C((uint64_t)v20, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    }

    uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C45E580);
    memcpy(v20, v21, *(void *)(*(void *)(v28 - 8) + 64LL));
    goto LABEL_20;
  }

  if (v10)
  {
LABEL_7:
    v18 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_18C45E6E8);
    memcpy((void *)a1, (const void *)a2, *(void *)(*(void *)(v18 - 8) + 64LL));
    goto LABEL_29;
  }

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  *(_BYTE *)(a1 + 18) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(a1 + 19) = *(_BYTE *)(a2 + 19);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v57 = v6;
  BOOL v11 = v6[11];
  os_log_type_t v12 = (void *)(a1 + v11);
  char v13 = (const void *)(a2 + v11);
  BOOL v14 = type metadata accessor for NWEndpoint();
  os_log_type_t v15 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v14 - 8) + 48LL);
  swift_bridgeObjectRetain();
  BOOL v16 = v15;
  swift_bridgeObjectRetain();
  if (!v15((uint64_t)v13, 1LL, v14))
  {
    __int16 v27 = (char *)&loc_181C16F54 + 4 * byte_18265F59A[swift_getEnumCaseMultiPayload()];
    __asm { BR              X10 }
  }

  __int16 v17 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C45E580);
  memcpy(v12, v13, *(void *)(*(void *)(v17 - 8) + 64LL));
  v30 = v57[12];
  v31 = (void *)(a1 + v30);
  os_log_type_t v32 = (const void *)(a2 + v30);
  if (!v16(a2 + v30, 1LL, v14))
  {
    v35 = (char *)&loc_181C171B0 + 4 * byte_18265F59F[swift_getEnumCaseMultiPayload()];
    __asm { BR              X10 }
  }

  v34 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C45E580);
  memcpy(v31, v32, *(void *)(*(void *)(v34 - 8) + 64LL));
  *(void *)(a1 + v57[13]) = *(void *)(a2 + v57[13]);
  os_log_type_t v36 = *(void (**)(uint64_t, void, uint64_t, int *))(v7 + 56);
  swift_unknownObjectRetain();
  v36(a1, 0LL, 1LL, v57);
LABEL_29:
  v45 = a3[5];
  v46 = (void *)(a1 + v45);
  v47 = a2 + v45;
  v48 = *(void *)(a1 + v45);
  v49 = *(void *)(a2 + v45);
  if (!v48)
  {
    if (v49)
    {
      v51 = *(void *)(v47 + 8);
      os_log_s *v46 = v49;
      v46[1] = v51;
      swift_retain();
      goto LABEL_36;
    }

  result = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 56))(v6, 1LL, 1LL, v7);
LABEL_21:
  __break(1u);
  return result;
}

        sub_181BE61DC(&v126, (uint64_t)&v129);
        v63 = v131;
        char v64 = v132;
        __swift_project_boxed_opaque_existential_2(&v129, v131);
        (*(void (**)(uint64_t, uint64_t))(v64 + 8))(v63, v64);
        __swift_destroy_boxed_opaque_existential_2((uint64_t)&v129);
LABEL_21:
        v65 = v54;
        if (qword_18C58B1C8 != -1) {
          swift_once();
        }
        v66 = sub_18264E934();
        __swift_project_value_buffer(v66, (uint64_t)qword_18C58D4B0);
        v116 = *(void (**)(char *, char *, uint64_t))(v55 + 16);
        v116(v21, v56, v13);
        v67 = (os_log_s *)sub_18264E91C();
        v68 = sub_18264F018();
        if (os_log_type_enabled(v67, v68))
        {
          uint64_t v69 = (uint8_t *)swift_slowAlloc();
          v70 = swift_slowAlloc();
          v129 = v70;
          *(_DWORD *)uint64_t v69 = 136315138;
          v104[0] = v69 + 4;
          sub_181BD67D4(&qword_18C58C0E0, (uint64_t (*)(uint64_t))MEMORY[0x189606A90], MEMORY[0x189606AD0]);
          v71 = sub_18264F480();
          *(void *)&v126 = sub_181BF7900(v71, v72, &v129);
          sub_18264F0CC();
          swift_bridgeObjectRelease();
          v73 = *(void (**)(char *, uint64_t))(v55 + 8);
          os_log_type_t v53 = v121;
          v73(v21, v13);
          _os_log_impl(&dword_181A5C000, v67, v68, "Setting receive file transfer directory to %s", v69, 0xCu);
          swift_arrayDestroy();
          v74 = v70;
          v56 = v117;
          uint64_t v54 = v118;
          MEMORY[0x186E12168](v74, -1LL, -1LL);
          MEMORY[0x186E12168](v69, -1LL, -1LL);
        }

        else
        {
          v73 = *(void (**)(char *, uint64_t))(v55 + 8);
          v73(v21, v13);

          uint64_t v54 = v65;
        }

        v75 = v106;
        v116((char *)v106, v56, v13);
        v120(v75, 0LL, 1LL, v13);
        v76 = *(void **)(v54 + 32);
        v77 = (uint64_t)v105;
        sub_181BE48BC(v75, (uint64_t)v105, &qword_18C58B040);
        if (v119((char *)v77, 1LL, v13) == 1)
        {
          v78 = 0LL;
        }

        else
        {
          v78 = (void *)sub_18264E520();
          v73((char *)v77, v13);
        }

        objc_msgSend(v76, sel_setTemporaryDirectoryURL_, v78);

        sub_181BDA0F0(v75, &qword_18C58B040);
        sub_181C0A3A4();
        v73(v56, v13);
        goto LABEL_30;
      }
    }

    else
    {
      char v61 = v54;
      sub_181BC920C((uint64_t)v12, (uint64_t (*)(void))type metadata accessor for NWActorID);
      swift_endAccess();
    }

    v128 = 0LL;
    v126 = 0u;
    v127 = 0u;
    v56 = v117;
    goto LABEL_19;
  }

    __break(1u);
  }

    BOOL v11 = (v18 - 1) & v18;
LABEL_5:
    os_log_type_t v15 = (const char *)(sub_18264EACC() + 32);
    BOOL v16 = sub_18264EACC();
    nw_relay_hop_add_additional_http_header_field(v7, v15, (const char *)(v16 + 32));
    swift_release();
    result = swift_release();
  }

  uint64_t v19 = v17 + 3;
  if (v19 >= v12)
  {
LABEL_21:
    swift_release();
    swift_unknownObjectRelease();
    sub_181BC920C(a1, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    result = swift_release();
    *a4 = v7;
    return result;
  }

  v18 = *(void *)(v8 + 8 * v19);
  if (v18)
  {
    BOOL v14 = v19;
    goto LABEL_20;
  }

  while (1)
  {
    BOOL v14 = v19 + 1;
    if (__OFADD__(v19, 1LL)) {
      break;
    }
    if (v14 >= v12) {
      goto LABEL_21;
    }
    v18 = *(void *)(v8 + 8 * v14);
    ++v19;
    if (v18) {
      goto LABEL_20;
    }
  }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v4) {
      free(v4);
    }
    return 0LL;
  }

  v1 = *((void *)result + 2);
  if (v1) {
    return (uint64_t)(*(void *)(v1 + 24) - *(void *)(v1 + 16)) >> 3;
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_21;
  }

  if (nw_shoes_get_network_usage_policy_client(void)::shared_policy_client)
  {
    perform_first_network_use_flow_delayInitStub(client);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_shoes_notify_interface_denied";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
  {
LABEL_21:
    if (!v4) {
      return;
    }
    goto LABEL_22;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    time_t v5 = (os_log_s *)gLogObj;
    char v6 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_shoes_notify_interface_denied";
    BOOL v7 = "%{public}s network_usage_policy_create_client failed";
    goto LABEL_20;
  }

  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    time_t v5 = (os_log_s *)gLogObj;
    char v6 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_shoes_notify_interface_denied";
    BOOL v7 = "%{public}s network_usage_policy_create_client failed, backtrace limit exceeded";
    goto LABEL_20;
  }

  os_log_type_t v8 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  time_t v5 = (os_log_s *)gLogObj;
  char v6 = type;
  os_log_type_t v9 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v8)
  {
    if (!v9) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_shoes_notify_interface_denied";
    BOOL v7 = "%{public}s network_usage_policy_create_client failed, no backtrace";
    goto LABEL_20;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v15 = "nw_shoes_notify_interface_denied";
    BOOL v16 = 2082;
    __int16 v17 = v8;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s network_usage_policy_create_client failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v8);
  if (v4) {
LABEL_22:
  }
    free(v4);
}

        v149.__r_.__value_.__s.__size_ = 0;
        v149.__r_.__value_.__s.__data_[0] = 0;
        goto LABEL_21;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
      v109 = (char *)_os_log_send_and_compose_impl();
      type.__r_.__value_.__s.__data_[0] = 16;
      LOBYTE(v151[0]) = 0;
      if (__nwlog_fault(v109, &type, v151))
      {
        if (type.__r_.__value_.__s.__data_[0] == 17)
        {
          v110 = (os_log_s *)__nwlog_obj();
          v111 = type.__r_.__value_.__s.__data_[0];
          if (!os_log_type_enabled(v110, (os_log_type_t)type.__r_.__value_.__s.__data_[0])) {
            goto LABEL_247;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
          v112 = "%{public}s called with null header_fields";
          goto LABEL_245;
        }

        if (!LOBYTE(v151[0]))
        {
          v110 = (os_log_s *)__nwlog_obj();
          v111 = type.__r_.__value_.__s.__data_[0];
          if (!os_log_type_enabled(v110, (os_log_type_t)type.__r_.__value_.__s.__data_[0])) {
            goto LABEL_247;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
          v112 = "%{public}s called with null header_fields, backtrace limit exceeded";
          goto LABEL_245;
        }

        v121 = (char *)__nw_create_backtrace_string();
        v116 = (os_log_s *)__nwlog_obj();
        v146 = type.__r_.__value_.__s.__data_[0];
        v122 = os_log_type_enabled(v116, (os_log_type_t)type.__r_.__value_.__s.__data_[0]);
        if (v121)
        {
          if (v122)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v121;
            _os_log_impl( &dword_181A5C000,  v116,  v146,  "%{public}s called with null header_fields, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v121);
          if (!v109) {
            goto LABEL_249;
          }
          goto LABEL_248;
        }

        if (v122)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
          v112 = "%{public}s called with null header_fields, no backtrace";
          goto LABEL_269;
        }
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
      v109 = (char *)_os_log_send_and_compose_impl();
      type.__r_.__value_.__s.__data_[0] = 16;
      LOBYTE(v151[0]) = 0;
      if (type.__r_.__value_.__s.__data_[0] == 17)
      {
        v110 = (os_log_s *)__nwlog_obj();
        v111 = type.__r_.__value_.__s.__data_[0];
        if (!os_log_type_enabled(v110, (os_log_type_t)type.__r_.__value_.__s.__data_[0])) {
          goto LABEL_247;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
        v112 = "%{public}s called with null http_metadata";
LABEL_245:
        v138 = v110;
        v139 = v111;
LABEL_246:
        _os_log_impl(&dword_181A5C000, v138, v139, v112, buf, 0xCu);
        goto LABEL_247;
      }

      if (!LOBYTE(v151[0]))
      {
        v110 = (os_log_s *)__nwlog_obj();
        v111 = type.__r_.__value_.__s.__data_[0];
        if (!os_log_type_enabled(v110, (os_log_type_t)type.__r_.__value_.__s.__data_[0])) {
          goto LABEL_247;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
        v112 = "%{public}s called with null http_metadata, backtrace limit exceeded";
        goto LABEL_245;
      }

      v115 = (char *)__nw_create_backtrace_string();
      v116 = (os_log_s *)__nwlog_obj();
      v146 = type.__r_.__value_.__s.__data_[0];
      v117 = os_log_type_enabled(v116, (os_log_type_t)type.__r_.__value_.__s.__data_[0]);
      if (v115)
      {
        if (v117)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v115;
          _os_log_impl( &dword_181A5C000,  v116,  v146,  "%{public}s called with null http_metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v115);
      }

      else if (v117)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_sniffing_get_media_type";
        v112 = "%{public}s called with null http_metadata, no backtrace";
LABEL_269:
        v138 = v116;
        v139 = v146;
        goto LABEL_246;
      }
    }

    operator delete(v29[0]);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_9:
      if ((v26 & 0x80000000) == 0) {
        goto LABEL_10;
      }
      goto LABEL_22;
    }

  if (v9 || !v8) {
    goto LABEL_24;
  }
  if (*(_DWORD *)v2 == 1179011410)
  {
    if (*((_DWORD *)v2 + 2) == 1163280727)
    {
      char v6 = 9;
      *(_BYTE *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 118;
      BOOL v14 = "audio/wav";
    }

    else
    {
      if (*((_DWORD *)v2 + 2) != 541677121) {
        goto LABEL_23;
      }
      char v6 = 9;
      *(_BYTE *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 105;
      BOOL v14 = "video/avi";
    }

    if (v8) {
      free(v8);
    }
    goto LABEL_22;
  }

  time_t v5 = (void *)*((void *)v3 + 26);
  if (!v5)
  {
LABEL_22:
    instance_count = 0LL;
    goto LABEL_23;
  }

  instance_count = nw_protocol_instance_registrar_get_instance_count(v5);
LABEL_23:

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += instance_count;
  return 1LL;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v14) {
    free(v14);
  }
LABEL_3:
}
}
}
}

      os_log_type_t v10 = 1;
      goto LABEL_23;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugins_handle_disconnected";
    v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (__nwlog_fault(v24, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v25 = (os_log_s *)__nwlog_obj();
        __int16 v26 = type;
        if (!os_log_type_enabled(v25, type)) {
          goto LABEL_94;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugins_handle_disconnected";
        __int16 v27 = "%{public}s called with null other_protocol";
        goto LABEL_93;
      }

      if (!v43)
      {
        __int16 v25 = (os_log_s *)__nwlog_obj();
        __int16 v26 = type;
        if (!os_log_type_enabled(v25, type)) {
          goto LABEL_94;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugins_handle_disconnected";
        __int16 v27 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_93;
      }

      v34 = (char *)__nw_create_backtrace_string();
      __int16 v25 = (os_log_s *)__nwlog_obj();
      __int16 v26 = type;
      v35 = os_log_type_enabled(v25, type);
      if (v34)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugins_handle_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v34;
          _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v34);
        goto LABEL_94;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugins_handle_disconnected";
        __int16 v27 = "%{public}s called with null other_protocol, no backtrace";
LABEL_93:
        _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
      }
    }

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  is_framer = 0;
LABEL_3:

  return is_framer;
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  singleton = 0LL;
LABEL_3:

  return (nw_framer_message_t)singleton;
}

  if (v8) {
    free(v8);
  }
  is_framer = 0LL;
LABEL_3:

  return is_framer;
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

    uint64_t v28 = -1;
    if ((v15[346] & 0x20) != 0) {
      goto LABEL_30;
    }
    goto LABEL_21;
  }

  __break(1u);
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  port = 0LL;
LABEL_3:

  return port;
}

  if (v6) {
    free(v6);
  }
  port = 0LL;
LABEL_3:

  return port;
}

  if (v6) {
    free(v6);
  }
  os_unfair_lock_opaque = 0LL;
LABEL_3:

  return os_unfair_lock_opaque;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v12) {
    free(v12);
  }
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_report_resolution_source_query;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_report_resolution_protocol_unknown;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

      goto LABEL_21;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)(id)gLogObj;
    os_log_type_t v12 = type;
    char v13 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
      os_log_type_t v10 = "%{public}s Report's (not in progress) associated connection unexpectedly nil, no backtrace";
      BOOL v14 = v8;
      os_log_type_t v15 = v12;
      goto LABEL_19;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_data_transfer_report_collect_inner_block_invoke";
      v20 = 2082;
      time_t v21 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s Report's (not in progress) associated connection unexpectedly nil, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
  }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}
}

    if (v7) {
      free(v7);
    }
    goto LABEL_22;
  }

  id v3 = (void *)*((void *)v1 + 8);
  if (!v3)
  {
LABEL_22:
    time_t v5 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = v3;
  time_t v5 = v4[2];

LABEL_23:
  return v5;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return (nw_group_descriptor_t)v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return (nw_group_descriptor_t)v2;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

    goto LABEL_21;
  }

  if (!v17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    time_t v5 = (os_log_s *)(id)gLogObj;
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      v20 = "nw_privacy_context_disable_logging";
      _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s Logging cannot be disabled for the default privacy context, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  BOOL v7 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  time_t v5 = (os_log_s *)(id)gLogObj;
  os_log_type_t v8 = type;
  os_log_type_t v9 = os_log_type_enabled(v5, type);
  if (!v7)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      v20 = "nw_privacy_context_disable_logging";
      _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s Logging cannot be disabled for the default privacy context, no backtrace",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    v20 = "nw_privacy_context_disable_logging";
    time_t v21 = 2082;
    char v22 = v7;
    _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s Logging cannot be disabled for the default privacy context, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v7);
  if (v4) {
    goto LABEL_22;
  }
LABEL_23:
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v5) {
      free(v5);
    }
    goto LABEL_22;
  }

  nw_context_assert_queue(*((void **)v1 + 15));
  if (!*((void *)v2 - 6))
  {
LABEL_22:
    id v3 = 0LL;
    goto LABEL_23;
  }

  v2[405] |= 8u;
  id v3 = 1LL;
LABEL_23:

  return v3;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_22;
  }

  id v3 = (void *)*((void *)v1 + 6);
  if (!v3)
  {
LABEL_22:
    time_t v5 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = v3;
  time_t v5 = *(unsigned int *)(v4[13] + 103LL);

LABEL_23:
  return v5;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = v1[13];
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = (v3 - (v1[14] + v1[15]));
LABEL_23:

  return v4;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v10) {
    free(v10);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

    if (v5) {
      free(v5);
    }
    goto LABEL_22;
  }

  if (!*((void *)v1 + 3))
  {
LABEL_22:
    id v3 = 0LL;
    goto LABEL_23;
  }

  id v3 = *((_BYTE *)v1 + 152) != 0;
LABEL_23:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    free(v10);
    goto LABEL_21;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    time_t v5 = 1;
  }

  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0) {
      time_t v5 = 2;
    }
    else {
      time_t v5 = 0;
    }
  }

  char v6 = nw_connection_create_with_connected_socket(a3, v5);
  -[NWConnection setInternalConnection:](v4, "setInternalConnection:", v6);

  -[NWConnection internalConnection](v4, "internalConnection");
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v31 = "-[NWConnection initWithConnectedSocket:]";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      v31 = "-[NWConnection initWithConnectedSocket:]";
      char v13 = "%{public}s nw_connection_create_with_connected_socket failed";
LABEL_25:
      uint64_t v19 = v11;
      v20 = v12;
      goto LABEL_26;
    }

    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      v31 = "-[NWConnection initWithConnectedSocket:]";
      char v13 = "%{public}s nw_connection_create_with_connected_socket failed, backtrace limit exceeded";
      goto LABEL_25;
    }

    BOOL v14 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = (os_log_s *)(id)gLogObj;
    os_log_type_t v15 = type;
    BOOL v16 = os_log_type_enabled(v11, type);
    if (!v14)
    {
      if (!v16)
      {
LABEL_27:

        if (!v10) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }

      *(_DWORD *)buf = 136446210;
      v31 = "-[NWConnection initWithConnectedSocket:]";
      char v13 = "%{public}s nw_connection_create_with_connected_socket failed, no backtrace";
      uint64_t v19 = v11;
      v20 = v15;
LABEL_26:
      _os_log_impl(&dword_181A5C000, v19, v20, v13, buf, 0xCu);
      goto LABEL_27;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "-[NWConnection initWithConnectedSocket:]";
      os_log_type_t v32 = 2082;
      v33 = v14;
      _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s nw_connection_create_with_connected_socket failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    __int16 v17 = (char *)v14;
    goto LABEL_18;
  }

  -[NWConnection setInternalConnectionState:](v4, "setInternalConnectionState:", 2LL);
  -[NWConnection start](v4, "start");
  os_log_type_t v8 = v4;
LABEL_22:

  return v8;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_advertise_descriptor_get_invitation_scope";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_advertise_descriptor_get_invitation_scope";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_advertise_descriptor_get_invitation_scope";
        os_log_type_t v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_advertise_descriptor_get_invitation_route";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_advertise_descriptor_get_invitation_route";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_advertise_descriptor_get_invitation_route";
        os_log_type_t v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    goto LABEL_21;
  }

  if (!v21)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    BOOL v14 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_advertise_descriptor_set_invitation";
      _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s Advertise descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  BOOL v11 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v9 = (os_log_s *)(id)gLogObj;
  os_log_type_t v12 = type;
  char v13 = os_log_type_enabled(v9, type);
  if (!v11)
  {
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_advertise_descriptor_set_invitation";
      _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s Advertise descriptor not of type application service, no backtrace",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_advertise_descriptor_set_invitation";
    __int16 v25 = 2082;
    __int16 v26 = v11;
    _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s Advertise descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v8) {
    goto LABEL_22;
  }
LABEL_23:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_error_domain_invalid;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
}

  if (v5) {
    free(v5);
  }
}
}
  }

  if (v6) {
    free(v6);
  }
  id v3 = "";
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return (nw_listener_t)v5;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0;
LABEL_3:

  return v4;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

    if (v8) {
      free(v8);
    }
    goto LABEL_22;
  }

  if (!(v3[5] | v3[6] | v3[7] | v3[8]))
  {
LABEL_22:
    char v6 = 0LL;
    goto LABEL_23;
  }

  time_t v5 = *(_OWORD *)(v3 + 7);
  *a2 = *(_OWORD *)(v3 + 5);
  a2[1] = v5;
  char v6 = 1LL;
LABEL_23:

  return v6;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = v1[25];
  if (!v3)
  {
LABEL_22:
    url = 0LL;
    goto LABEL_23;
  }

  url = nw_endpoint_get_url(v3);
LABEL_23:

  return url;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = (void *)*((void *)v1 + 25);
  if (!v3)
  {
LABEL_22:
    sanitized_url = 0LL;
    goto LABEL_23;
  }

  sanitized_url = nw_endpoint_get_sanitized_url(v3);
LABEL_23:

  return sanitized_url;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = v1[26];
  if (!v3)
  {
LABEL_22:
    url = 0LL;
    goto LABEL_23;
  }

  url = nw_endpoint_get_url(v3);
LABEL_23:

  return url;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = (void *)*((void *)v1 + 26);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = nw_endpoint_copy_cfurl(v3);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_service_class_best_effort;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  identifier = 0LL;
LABEL_3:

  return identifier;
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

    if (v4) {
      free(v4);
    }
    goto LABEL_22;
  }

  if (!os_variant_allows_internal_security_policies())
  {
LABEL_22:
    v2 = 0LL;
    goto LABEL_23;
  }

  v2 = (v1[101] >> 5) & 1;
LABEL_23:

  return v2;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

LABEL_21:
    if (!v13) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }

  if (!v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = (os_log_s *)(id)gLogObj;
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v14, type))
    {
      v24 = v11;
      __int16 v25 = objc_msgSend(v24, "type", buf, v37);

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_color";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v25;
      _os_log_impl( &dword_181A5C000,  v14,  v23,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_20;
  }

  v18 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v14 = (os_log_s *)(id)gLogObj;
  uint64_t v19 = type;
  v20 = os_log_type_enabled(v14, type);
  if (!v18)
  {
    if (v20)
    {
      __int16 v26 = v11;
      __int16 v27 = objc_msgSend(v26, "type", buf, v37);

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_color";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v27;
      _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_20;
  }

  if (v20)
  {
    time_t v21 = v11;
    char v22 = objc_msgSend(v21, "type", buf, v37);

    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_color";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v22;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v18;
    _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v18);
  if (v13)
  {
LABEL_22:
    uint64_t v28 = (char *)v13;
LABEL_23:
    free(v28);
  }

LABEL_21:
    if (!v13) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }

  if (!v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = (os_log_s *)(id)gLogObj;
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v14, type))
    {
      v24 = v11;
      __int16 v25 = objc_msgSend(v24, "type", buf, v37);

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_set_advertised_route";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v25;
      _os_log_impl( &dword_181A5C000,  v14,  v23,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_20;
  }

  v18 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v14 = (os_log_s *)(id)gLogObj;
  uint64_t v19 = type;
  v20 = os_log_type_enabled(v14, type);
  if (!v18)
  {
    if (v20)
    {
      __int16 v26 = v11;
      __int16 v27 = objc_msgSend(v26, "type", buf, v37);

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_set_advertised_route";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v27;
      _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_20;
  }

  if (v20)
  {
    time_t v21 = v11;
    char v22 = objc_msgSend(v21, "type", buf, v37);

    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_advertised_route";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v22;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v18;
    _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v18);
  if (v13)
  {
LABEL_22:
    uint64_t v28 = (char *)v13;
LABEL_23:
    free(v28);
  }

LABEL_21:
    if (!v10) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }

  if (!v35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = (os_log_s *)(id)gLogObj;
    v20 = type;
    if (os_log_type_enabled(v11, type))
    {
      time_t v21 = v8;
      char v22 = objc_msgSend(v21, "type", buf, v34);

      *(_DWORD *)buf = 136446466;
      v38 = "nw_endpoint_get_service_identifier";
      v39 = 1024;
      *(_DWORD *)os_log_type_t v40 = v22;
      _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_20;
  }

  os_log_type_t v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v11 = (os_log_s *)(id)gLogObj;
  BOOL v16 = type;
  __int16 v17 = os_log_type_enabled(v11, type);
  if (!v15)
  {
    if (v17)
    {
      os_log_type_t v23 = v8;
      v24 = objc_msgSend(v23, "type", buf, v34);

      *(_DWORD *)buf = 136446466;
      v38 = "nw_endpoint_get_service_identifier";
      v39 = 1024;
      *(_DWORD *)os_log_type_t v40 = v24;
      _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_20;
  }

  if (v17)
  {
    v18 = v8;
    uint64_t v19 = objc_msgSend(v18, "type", buf, v34);

    *(_DWORD *)buf = 136446722;
    v38 = "nw_endpoint_get_service_identifier";
    v39 = 1024;
    *(_DWORD *)os_log_type_t v40 = v19;
    v40[2] = 2082;
    *(void *)&v40[3] = v15;
    _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v15);
  if (v10)
  {
LABEL_22:
    __int16 v25 = (char *)v10;
LABEL_23:
    free(v25);
  }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v10) {
    free(v10);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v12) {
      free(v12);
    }
    goto LABEL_22;
  }

  if (!nw_connection_should_run_probe_locked((NWConcrete_nw_connection *)v3))
  {
LABEL_22:
    os_log_type_t v10 = 0LL;
    goto LABEL_23;
  }

  time_t v5 = v4;
  v5[12] = v5[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;

  char v6 = v5;
  v5[12] |= 0x400uLL;

  BOOL v7 = nw_connection_create(*((nw_endpoint_t *)v3 + 1), (nw_parameters_t)v6);
  *((_BYTE *)v7 + 108) |= 0x80u;
  v3[108] |= 0x40u;
  v3[109] |= 1u;
  *(_OWORD *)((char *)v7 + 468) = *(_OWORD *)(v3 + 452);
  handler[0] = MEMORY[0x1895F87A8];
  handler[1] = 3221225472LL;
  handler[2] = ___ZL33nw_connection_create_probe_lockedP24NWConcrete_nw_connectionPU27objcproto16OS_nw_parameters8NSObject_block_invoke;
  handler[3] = &unk_189BC9490;
  time_t v21 = v3;
  os_log_type_t v8 = v7;
  char v22 = v8;
  nw_connection_set_state_changed_handler(v8, handler);
  os_log_type_t v9 = v22;
  os_log_type_t v10 = v8;

LABEL_23:
  return v10;
}

  if (v11) {
    free(v11);
  }
  os_log_type_t v8 = 0LL;
LABEL_3:

  return v8;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0xFFFFFFFFLL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  return listener_protocol_on_nw_queue;
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  flow_id = 0LL;
LABEL_3:

  return flow_id;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v13) {
    free(v13);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
LABEL_21:
  }
    free(v7);
LABEL_22:
}

LABEL_21:
    if (!v9) {
      return;
    }
    goto LABEL_22;
  }

  if (!v33)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
    char v22 = type;
    if (os_log_type_enabled(v10, type))
    {
      os_log_type_t v23 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
      v37 = 1024;
      *(_DWORD *)v38 = v23;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s [C%u] Connection is not ready, cannot add new protocol, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_20;
  }

  v18 = (char *)__nw_create_backtrace_string();
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
  uint64_t v19 = type;
  v20 = os_log_type_enabled(v10, type);
  if (!v18)
  {
    if (v20)
    {
      v24 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
      v37 = 1024;
      *(_DWORD *)v38 = v24;
      _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s [C%u] Connection is not ready, cannot add new protocol, no backtrace",  buf,  0x12u);
    }

    goto LABEL_20;
  }

  if (v20)
  {
    time_t v21 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v36 = "nw_connection_append_and_start_application_protocol_block_invoke";
    v37 = 1024;
    *(_DWORD *)v38 = v21;
    v38[2] = 2082;
    *(void *)&v38[3] = v18;
    _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s [C%u] Connection is not ready, cannot add new protocol, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(v18);
  if (v9)
  {
LABEL_22:
    char v13 = (char *)v9;
    goto LABEL_23;
  }

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v10) {
    free(v10);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

        goto LABEL_21;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_endpoint_copy_custom_data";
          _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v18 = type;
      uint64_t v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_endpoint_copy_custom_data";
          _os_log_impl(&dword_181A5C000, v8, v18, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_endpoint_copy_custom_data";
        __int16 v25 = 2082;
        __int16 v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

        goto LABEL_21;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_endpoint_copy_custom_resolver_block";
          _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v18 = type;
      uint64_t v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_endpoint_copy_custom_resolver_block";
          _os_log_impl(&dword_181A5C000, v8, v18, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_endpoint_copy_custom_resolver_block";
        __int16 v25 = 2082;
        __int16 v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

        goto LABEL_21;
      }

      if (!v22)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        time_t v21 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = type;
      v20 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          _os_log_impl(&dword_181A5C000, v9, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        __int16 v26 = 2082;
        __int16 v27 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (v5) {
      free(v5);
    }
    goto LABEL_22;
  }

  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
LABEL_22:
    id v3 = 0LL;
    goto LABEL_23;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  __int16 v17 = 0;
  mode_handler = v1->mode_handler;
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  v13[2] = ___ZL41nw_endpoint_handler_has_fallback_childrenP30NWConcrete_nw_endpoint_handler_block_invoke;
  v13[3] = &unk_189BBBB48;
  v13[4] = buf;
  -[NWConcrete_nw_endpoint_mode_handler applyWithHandler:toChildren:]( mode_handler,  "applyWithHandler:toChildren:",  v1,  v13);
  id v3 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
  _Block_object_dispose(buf, 8);
LABEL_23:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}
}
}

    free(v21);
    goto LABEL_21;
  }

  __nwlog_obj();
  BOOL v44 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v55 = "-[NWEndpoint initWithCoder:]";
  v45 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (__nwlog_fault(v45, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWEndpoint initWithCoder:]";
        v48 = "%{public}s [super init] failed";
LABEL_76:
        _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
      }
    }

    else
    {
      if (v51)
      {
        v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = type;
        v50 = os_log_type_enabled(v46, type);
        if (v49)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            v55 = "-[NWEndpoint initWithCoder:]";
            v56 = 2082;
            uint64_t v57 = v49;
            _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v49);
          goto LABEL_78;
        }

        if (!v50) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWEndpoint initWithCoder:]";
        v48 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_76;
      }

      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWEndpoint initWithCoder:]";
        v48 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_76;
      }
    }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v6) {
    free(v6);
  }
  id v3 = 1LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  return 1LL;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = (const void *)*((void *)v1 + 2);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = CFRetain(v3);
LABEL_23:

  return v4;
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  os_log_type_t v12 = 0LL;
  if ((has & 0x10) != 0)
  {
LABEL_6:
    char v13 = 2654435761LL * self->_requiredInterfaceType;
    if ((*(_WORD *)&self->_has & 0x400) != 0) {
      goto LABEL_7;
    }
    goto LABEL_22;
  }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
LABEL_3:

  return 1LL;
}

  if (v10) {
    free(v10);
  }
LABEL_4:
}
  }

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  os_log_type_t v12 = *((_BYTE *)handle + 204);
  *((_BYTE *)handle + 204) = v12 & 0xBF;
  if ((v12 & 6) != 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)handle + 205;
        os_log_type_t v9 = "%{public}s %{public}s tunnel already connected or closed, ignoring connected event";
        goto LABEL_24;
      }
    }
  }

  else
  {
    nw_http2_transport_send_settings((uint64_t)handle);
    *((_BYTE *)handle + 204) |= 2u;
    if (gLogDatapath)
    {
      v34 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)handle + 205;
        _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s http2 tunnel is now connected",  buf,  0x16u);
      }
    }

    nw_protocol_http2_transport_process_input((uint64_t)handle);
    char v13 = (char *)handle[14];
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL45nw_protocol_http2_transport_process_connectedP27nw_protocol_http2_transport_block_invoke;
    v38 = (char *)&__block_descriptor_tmp_20_37842;
    v39 = handle;
    nw_hash_table_apply(v13, (uint64_t)buf);
  }

  if (v8) {
    free(v8);
  }
  return v6 != 0LL;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = (void *)*((void *)v1 + 18);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = xpc_array_get_count(v3) != 0;
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = v1[1];
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  v18 = 0;
  v14[0] = MEMORY[0x1895F87A8];
  v14[1] = 3221225472LL;
  v14[2] = __nw_proxy_config_supports_listeners_block_invoke;
  v14[3] = &unk_189BBD0A0;
  v14[4] = buf;
  nw_dictionary_apply(v3, (uint64_t)v14);
  os_log_type_t v4 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
  _Block_object_dispose(buf, 8);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

        goto LABEL_21;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_proxy_config_get_string";
          _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null key_string, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      __int16 v17 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v18 = type;
      uint64_t v19 = os_log_type_enabled(v8, type);
      if (!v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_proxy_config_get_string";
          _os_log_impl(&dword_181A5C000, v8, v18, "%{public}s called with null key_string, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_proxy_config_get_string";
        __int16 v25 = 2082;
        __int16 v26 = v17;
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null key_string, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v17);
    }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

        goto LABEL_21;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_proxy_config_create_relay";
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s Second hop proxy does not support HTTP/3",  buf,  0xCu);
      }

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_5:

  return 0LL;
}

      os_log_type_t v15 = 0;
      goto LABEL_21;
    }

    -[NWRemoteConnectionDirector delegate](self, "delegate");
    BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if ((*(_BYTE *)&v6->_has & 1) == 0)
    {
LABEL_10:
      __nwlog_obj();
      BOOL v11 = (id *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v73 = "-[NWRemoteConnectionDirector receiveRemoteReply:]";
        os_log_type_t v12 = "%{public}s Invalid command sent to connection receiver";
LABEL_12:
        char v13 = (os_log_s *)v11;
        BOOL v14 = 12;
LABEL_13:
        _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
      }
  }

  if (v7) {
    free(v7);
  }
  id v3 = 0LL;
LABEL_4:

  return v3;
}

  if (v10) {
    free(v10);
  }
  BOOL v7 = 0LL;
LABEL_3:

  return v7;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

    free(v21);
    goto LABEL_21;
  }

  __nwlog_obj();
  BOOL v44 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v55 = "-[NWParameters initWithCoder:]";
  v45 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (__nwlog_fault(v45, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWParameters initWithCoder:]";
        v48 = "%{public}s [super init] failed";
LABEL_76:
        _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
      }
    }

    else
    {
      if (v51)
      {
        v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = type;
        v50 = os_log_type_enabled(v46, type);
        if (v49)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            v55 = "-[NWParameters initWithCoder:]";
            v56 = 2082;
            uint64_t v57 = v49;
            _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v49);
          goto LABEL_78;
        }

        if (!v50) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWParameters initWithCoder:]";
        v48 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_76;
      }

      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWParameters initWithCoder:]";
        v48 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_76;
      }
    }

    free(v24);
    goto LABEL_21;
  }

  os_log_type_t v4 = v3;
  time_t v5 = objc_alloc(&OBJC_CLASS___NWParameters);
  char v6 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters);
  BOOL v7 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
  os_log_type_t v8 = -[NWConcrete_nw_parameters initWithStack:]((id *)&v6->super.isa, v7);

  os_log_type_t v9 = -[NWParameters initWithParameters:](v5, "initWithParameters:", v8);
  if (v4->_effectiveProcessUUID)
  {
    os_log_type_t v10 = objc_alloc(MEMORY[0x189607AB8]);
    BOOL v11 = v4->_effectiveProcessUUID;
    os_log_type_t v12 = (void *)[v10 initWithUUIDString:v11];
    -[NWParameters setEffectiveProcessUUID:](v9, "setEffectiveProcessUUID:", v12);
  }

  if (v4->_realProcessUUID)
  {
    char v13 = objc_alloc(MEMORY[0x189607AB8]);
    BOOL v14 = v4->_realProcessUUID;
    os_log_type_t v15 = (void *)[v13 initWithUUIDString:v14];
    -[NWParameters setProcessUUID:](v9, "setProcessUUID:", v15);
  }

  localEndpoint = v4->_localEndpoint;
  if (localEndpoint)
  {
    __int16 v17 = localEndpoint;
    v18 = -[PBCodable data](v17, "data");
    +[NWEndpoint endpointWithProtocolBufferData:](&OBJC_CLASS___NWEndpoint, "endpointWithProtocolBufferData:", v18);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0) {
      -[NWParameters setLocalAddress:](v9, "setLocalAddress:", v19);
    }

    os_log_type_t v4 = v81;
  }

  v20 = v4->_account;
  -[NWParameters setAccount:](v9, "setAccount:", v20);

  has = (__int16)v4->_has;
  if ((has & 1) != 0)
  {
    -[NWParameters setRequiredAddressFamily:](v9, "setRequiredAddressFamily:", LOBYTE(v4->_addressFamily));
    has = (__int16)v4->_has;
  }

  if ((has & 2) != 0) {
    dataMode = v4->_dataMode;
  }
  else {
    dataMode = 0LL;
  }
  -[NWParameters setDataMode:](v9, "setDataMode:", dataMode);
  uint64_t v29 = v4->_effectiveBundleID;
  -[NWParameters setEffectiveBundleID:](v9, "setEffectiveBundleID:", v29);

  v30 = v4->_metadata;
  -[NWParameters setMetadata:](v9, "setMetadata:", v30);

  requiredInterface = v4->_requiredInterface;
  if (requiredInterface)
  {
    os_log_type_t v32 = requiredInterface;
    v33 = -[PBCodable data](v32, "data");
    v34 = +[NWInterface interfaceWithProtocolBufferData:](&OBJC_CLASS___NWInterface, "interfaceWithProtocolBufferData:", v33);
    -[NWParameters setRequiredInterface:](v9, "setRequiredInterface:", v34);

    os_log_type_t v4 = v81;
  }

  if ((*(_WORD *)&v4->_has & 0x10) != 0) {
    requiredInterfaceType = v4->_requiredInterfaceType;
  }
  else {
    requiredInterfaceType = 0LL;
  }
  -[NWParameters setRequiredInterfaceType:](v9, "setRequiredInterfaceType:", requiredInterfaceType);
  -[NWParameters setTrafficClass:](v9, "setTrafficClass:", v4->_trafficClass);
  url = v4->_url;
  if (url)
  {
    v37 = (void *)MEMORY[0x189604030];
    v38 = url;
    [v37 URLWithString:v38];
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    -[NWParameters setUrl:](v9, "setUrl:", v39);

    os_log_type_t v4 = v81;
  }

  os_log_type_t v40 = (__int16)v4->_has;
  if ((v40 & 0x40) != 0)
  {
    -[NWParameters setEnableTFO:](v9, "setEnableTFO:", v4->_fastOpen);
    os_log_type_t v40 = (__int16)v4->_has;
  }

  if ((v40 & 0x80) != 0) {
    -[NWParameters setKeepAlive:](v9, "setKeepAlive:", v4->_keepalive);
  }
  -[NWParameters setUseLongOutstandingQueries:](v9, "setUseLongOutstandingQueries:", v4->_longOutstandingQueries);
  -[NWParameters setMultipathService:](v9, "setMultipathService:", v4->_multipathService);
  -[NWParameters setProhibitFallback:](v9, "setProhibitFallback:", v4->_noFallback);
  -[NWParameters setProhibitExpensivePaths:](v9, "setProhibitExpensivePaths:", v4->_prohibitExpensive);
  -[NWParameters setReuseLocalAddress:](v9, "setReuseLocalAddress:", v4->_reuseLocalAddress);
  -[NWParameters setUseAWDL:](v9, "setUseAWDL:", v4->_useAWDL);
  -[NWParameters setUseP2P:](v9, "setUseP2P:", v4->_useP2P);
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  BOOL v41 = v4->_requiredAgents;
  v42 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v41,  "countByEnumeratingWithState:objects:count:",  &v94,  v103,  16LL);
  if (v42)
  {
    os_log_type_t v43 = *(void *)v95;
    do
    {
      BOOL v44 = 0LL;
      do
      {
        if (*(void *)v95 != v43) {
          objc_enumerationMutation(v41);
        }
        v45 = *(void *)(*((void *)&v94 + 1) + 8 * v44);
        if (v45)
        {
          v46 = *(id *)(v45 + 8);
          v47 = *(void **)(v45 + 16);
        }

        else
        {
          v46 = 0LL;
          v47 = 0LL;
        }

        v48 = v47;
        -[NWParameters requireNetworkAgentWithDomain:type:](v9, "requireNetworkAgentWithDomain:type:", v46, v48);

        ++v44;
      }

      while (v42 != v44);
      v49 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v41,  "countByEnumeratingWithState:objects:count:",  &v94,  v103,  16LL);
      v42 = v49;
    }

    while (v49);
  }

  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v50 = v81->_preferredAgents;
  v51 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v50,  "countByEnumeratingWithState:objects:count:",  &v90,  v102,  16LL);
  if (v51)
  {
    os_log_type_t v52 = *(void *)v91;
    do
    {
      os_log_type_t v53 = 0LL;
      do
      {
        if (*(void *)v91 != v52) {
          objc_enumerationMutation(v50);
        }
        uint64_t v54 = *(void *)(*((void *)&v90 + 1) + 8 * v53);
        if (v54)
        {
          v55 = *(id *)(v54 + 8);
          v56 = *(void **)(v54 + 16);
        }

        else
        {
          v55 = 0LL;
          v56 = 0LL;
        }

        uint64_t v57 = v56;
        -[NWParameters preferNetworkAgentWithDomain:type:](v9, "preferNetworkAgentWithDomain:type:", v55, v57);

        ++v53;
      }

      while (v51 != v53);
      uint64_t v58 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v50,  "countByEnumeratingWithState:objects:count:",  &v90,  v102,  16LL);
      v51 = v58;
    }

    while (v58);
  }

  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  v59 = v81->_prohibitedAgents;
  v60 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v59,  "countByEnumeratingWithState:objects:count:",  &v86,  v101,  16LL);
  if (v60)
  {
    char v61 = *(void *)v87;
    do
    {
      os_log_type_t v62 = 0LL;
      do
      {
        if (*(void *)v87 != v61) {
          objc_enumerationMutation(v59);
        }
        v63 = *(void *)(*((void *)&v86 + 1) + 8 * v62);
        if (v63)
        {
          char v64 = *(id *)(v63 + 8);
          v65 = *(void **)(v63 + 16);
        }

        else
        {
          char v64 = 0LL;
          v65 = 0LL;
        }

        v66 = v65;
        -[NWParameters prohibitNetworkAgentsWithDomain:type:](v9, "prohibitNetworkAgentsWithDomain:type:", v64, v66);

        ++v62;
      }

      while (v60 != v62);
      v67 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v59,  "countByEnumeratingWithState:objects:count:",  &v86,  v101,  16LL);
      v60 = v67;
    }

    while (v67);
  }

  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v68 = v81->_prohibitedInterfaces;
  uint64_t v69 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v68,  "countByEnumeratingWithState:objects:count:",  &v82,  v100,  16LL);
  if (v69)
  {
    v70 = *(void *)v83;
    do
    {
      for (i = 0LL; i != v69; ++i)
      {
        if (*(void *)v83 != v70) {
          objc_enumerationMutation(v68);
        }
        [*(id *)(*((void *)&v82 + 1) + 8 * i) data];
        v72 = (void *)objc_claimAutoreleasedReturnValue();
        v73 = +[NWInterface interfaceWithProtocolBufferData:]( &OBJC_CLASS___NWInterface,  "interfaceWithProtocolBufferData:",  v72);
        -[NWParameters prohibitInterface:](v9, "prohibitInterface:", v73);
      }

      uint64_t v69 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v68,  "countByEnumeratingWithState:objects:count:",  &v82,  v100,  16LL);
    }

    while (v69);
  }

  v74 = 0LL;
  __int16 v27 = v81;
  while (v74 < v81->_prohibitedInterfaceTypes.count)
  {
    -[NWParameters prohibitInterfaceType:](v9, "prohibitInterfaceType:", v27->_prohibitedInterfaceTypes.list[v74++]);
    __int16 v27 = v81;
  }

  for (j = 0LL; j < v81->_prohibitedInterfaceSubTypes.count; ++j)
  {
    -[NWParameters prohibitInterfaceSubtype:]( v9,  "prohibitInterfaceSubtype:",  v27->_prohibitedInterfaceSubTypes.list[j]);
    __int16 v27 = v81;
  }

  if (v2) {
    free(v2);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

      _Block_object_dispose(&v44, 8);
      os_log_type_t v10 = &v48;
LABEL_21:
      _Block_object_dispose(v10, 8);
      return 0LL;
    }

    v18 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)os_log_type_t v52 = 136446466;
      os_log_type_t v53 = "nw_tcpconverter_parse_response";
      uint64_t v54 = 2080;
      v55 = (char *)(v3 + 1);
      uint64_t v19 = "%{public}s %s Received unexpected response - we remained in 'connect_sent' state";
      v20 = v52;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  __break(1u);
  return result;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

    if (a6)
    {
      os_log_type_t v9 = 3LL;
      if (*(_BYTE *)(a5 + 5)) {
        os_log_type_t v9 = 0LL;
      }
    }

    else
    {
      os_log_type_t v9 = 1LL;
      *(_DWORD *)a5 = 1;
    }

    a4 = ((_DWORD)v8 - (_DWORD)a3);
  }

  else
  {
    os_log_type_t v9 = 2LL;
  }

  return v9 | (a4 << 32);
}

  if (v9) {
    -[NWURLSessionResponseConsumerDownload deliverCompletionForTask:]((uint64_t)self, v12);
  }
  if (self) {
    error = self->_error;
  }
  else {
    error = 0LL;
  }
  (*((void (**)(id, NWURLError *))v15 + 2))(v15, error);
LABEL_14:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = nw_ws_opcode_invalid;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = nw_ws_close_code_no_status_received;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

    if (v9) {
      free(v9);
    }
    goto LABEL_22;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = 0LL;
  if (*a2 == 0LL)
  {
LABEL_22:
    BOOL v7 = 0LL;
    goto LABEL_23;
  }

  BOOL v7 = nw_ip_copy_options(v5, a2);
  *a3 = 16LL;
LABEL_23:

  return v7;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  os_log_type_t v12 = 0;
  char v13 = *(const __CFData **)(a2 + 112);
  if (!v13) {
    goto LABEL_21;
  }
LABEL_13:
  BOOL v14 = CFDataGetLength(v13) + 2;
  os_log_type_t v15 = *(const __CFArray **)(a2 + 120);
  if (!v15)
  {
    BOOL v16 = 1;
    uint64_t v19 = *(const __CFData **)(a2 + 128);
    if (v19) {
      goto LABEL_23;
    }
    goto LABEL_25;
  }

  BOOL v16 = CFArrayGetCount(v15) + 1;
  if (v16 >= 2u)
  {
    __int16 v17 = 0LL;
    do
    {
      v18 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), v17);
      if (v18) {
        v14 += CFDataGetLength(v18) + 2;
      }
      ++v17;
    }

    while (v16 - 1 != v17);
  }

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v11) {
    free(v11);
  }
  os_log_type_t v8 = 0LL;
LABEL_3:

  return v8;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v15) {
    free(v15);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v14) {
    free(v14);
  }
  BOOL v11 = 0LL;
LABEL_3:

  return v11;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}
        }

        else if (v18 < 0x2A)
        {
          __nwlog_obj();
          v80 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          char v64 = (char *)_os_log_send_and_compose_impl();

          v178[0] = 16;
          v177 = 0;
          if (v178[0] == 17)
          {
            __nwlog_obj();
            v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v81 = v178[0];
            if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              _os_log_impl( &dword_181A5C000,  v65,  v81,  "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad length %u",  buf,  0x12u);
            }

            goto LABEL_217;
          }

          if (!v177)
          {
            __nwlog_obj();
            v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v96 = v178[0];
            if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              _os_log_impl( &dword_181A5C000,  v65,  v96,  "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad length %u, backtrace limit exceeded",  buf,  0x12u);
            }

    free(v21);
    goto LABEL_21;
  }

  __nwlog_obj();
  BOOL v44 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v55 = "-[NWInterface initWithCoder:]";
  v45 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (__nwlog_fault(v45, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWInterface initWithCoder:]";
        v48 = "%{public}s [super init] failed";
LABEL_76:
        _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
      }
    }

    else
    {
      if (v51)
      {
        v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = type;
        v50 = os_log_type_enabled(v46, type);
        if (v49)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            v55 = "-[NWInterface initWithCoder:]";
            v56 = 2082;
            uint64_t v57 = v49;
            _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v49);
          goto LABEL_78;
        }

        if (!v50) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWInterface initWithCoder:]";
        v48 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_76;
      }

      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "-[NWInterface initWithCoder:]";
        v48 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_76;
      }
    }

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v9) {
    free(v9);
  }
  options = 0LL;
LABEL_3:

  return options;
}

  uint64_t v19 = *((void *)handle + 42);
  if (!v19) {
    goto LABEL_56;
  }
  v20 = (void *)(v19 + 576);
  while (1)
  {
    v20 = (void *)*v20;
    if (!v20) {
      break;
    }
    if ((char *)v20[4] == handle)
    {
      time_t v21 = *(FILE **)(v19 + 544);
      if (v21)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v21);
        fprintf(*(FILE **)(v19 + 544), "unreffed header block for stream %llu", v20[5]);
        fputc(10, *(FILE **)(v19 + 544));
      }

      char v22 = (void *)*v20;
      os_log_type_t v23 = (void *)v20[1];
      if (*v20)
      {
        v22[1] = v23;
        os_log_type_t v23 = (void *)v20[1];
      }

      else
      {
        *(void *)(v19 + 584) = v23;
      }

      *os_log_type_t v23 = v22;
      if ((v20[13] & 4) != 0)
      {
        __int16 v25 = v20[2];
        if (v25) {
          *(void *)(v25 + 24) = v20[3];
        }
        else {
          *(void *)(v19 + 16LL * (v20[8] & 7) + 600) = v20[3];
        }
        *(void *)v20[3] = v25;
        --*(_DWORD *)(v19 + 720);
      }

      free(v20);
      goto LABEL_37;
    }
  }

  v24 = *(FILE **)(v19 + 544);
  if (v24)
  {
    fwrite("qdec: info: ", 0xCuLL, 1uLL, v24);
    fwrite("could not find header block to unref", 0x24uLL, 1uLL, *(FILE **)(v19 + 544));
    fputc(10, *(FILE **)(v19 + 544));
  }

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  client_id = 0LL;
LABEL_3:

  return client_id;
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
  v2 = 0;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0;
LABEL_3:

  return v2;
}

  if (v13) {
    free(v13);
  }
  os_log_type_t v10 = 22LL;
LABEL_3:

  return v10;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 22LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 22LL;
LABEL_3:

  return v4;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

  if (v4)
  {
    v18 = CFGetTypeID(v4);
    uint64_t v19 = v18 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)v4) != 0;
    CFRelease(v4);
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  CFRelease(v3);
LABEL_35:

  return v19;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  BOOL v14 = *(_WORD *)v10->sa_data;

LABEL_21:
  if (required_address_family) {
    os_log_type_t v15 = required_address_family;
  }
  else {
    os_log_type_t v15 = 30;
  }
  if (v15 == 30)
  {
    memset(&address[2], 0, 24);
    address[0] = 7708;
    address[1] = v14;
    BOOL v16 = nw_endpoint_create_address((const sockaddr *)address);
  }

  else
  {
    if (v15 != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
        _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s listener created without a local address specified",  (uint8_t *)address,  0xCu);
      }

      v24 = (nw_error *)-[NWConcrete_nw_error initWithDomain:code:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_error),  1,  22);
      os_log_type_t v8 = 0LL;
      goto LABEL_110;
    }

    address[0] = 528;
    address[1] = v14;
    *(_DWORD *)&address[2] = 0;
    *(void *)&address[4] = 0LL;
    BOOL v16 = nw_endpoint_create_address((const sockaddr *)address);
  }

  os_log_type_t v8 = v16;
  if (!v16) {
    goto LABEL_34;
  }
LABEL_29:
  __int16 v17 = nw_endpoint_get_address(v8);
  v18 = v17;
  if (!v17)
  {
LABEL_34:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v22 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)address = 136446210;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s listener created without a local address specified",  (uint8_t *)address,  0xCu);
    }

    goto LABEL_59;
  }

  if (required_address_family && v17->sa_family != required_address_family)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v22 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)address = 136446210;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s Required address family doesn't match local address",  (uint8_t *)address,  0xCu);
    }
  }

  else
  {
    ip_protocol = nw_parameters_get_ip_protocol(v7);
    v20 = ip_protocol;
    if (ip_protocol == 6)
    {
      time_t v21 = 1;
      goto LABEL_42;
    }

    if (ip_protocol == 17)
    {
      time_t v21 = 2;
LABEL_42:
      __int16 v25 = socket(v18->sa_family, v21, 0);
      __int16 v26 = v25;
      if ((v25 & 0x80000000) == 0)
      {
        v282 = 1;
        v281 = 0;
        v274 = v25;
        v273 = a3;
        if (setsockopt(v25, 0xFFFF, 4, &v282, 4u))
        {
          posix_error = (nw_error *)nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3))
                                                                            + 8));
          error_code = nw_error_get_error_code(posix_error);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v29 = (id)gLogObj;
          *(_DWORD *)address = 136446466;
          *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
          address[6] = 1024;
          *(_DWORD *)&address[7] = error_code;
          v30 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v280) = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v31 = (os_log_s *)(id)gLogObj;
            os_log_type_t v32 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)address = 136446466;
              *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
              address[6] = 1024;
              *(_DWORD *)&address[7] = error_code;
              _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s SO_REUSEADDR failed %{darwin.errno}d",  (uint8_t *)address,  0x12u);
            }

LABEL_21:
          if (!v12) {
            goto LABEL_23;
          }
LABEL_22:
          free(v12);
          goto LABEL_23;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (os_log_s *)(id)gLogObj;
        __int16 v17 = type;
        v18 = os_log_type_enabled(v16, type);
        if (!backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v28 = "nw_listener_inbox_socket_handle_accept_event";
            uint64_t v29 = 1024;
            v30 = v25;
            v31 = 1024;
            sa_len = address.sa_len;
            _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Bad sockaddr length from kernel: slen = %u, ss.ss_len = %u, no backtrace",  buf,  0x18u);
          }

          goto LABEL_21;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v28 = "nw_listener_inbox_socket_handle_accept_event";
          uint64_t v29 = 1024;
          v30 = v25;
          v31 = 1024;
          sa_len = address.sa_len;
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Bad sockaddr length from kernel: slen = %u, ss.ss_len = %u, dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(backtrace_string);
        if (v12) {
          goto LABEL_22;
        }
LABEL_23:
        close(v5);
        __int16 v26 = -1;
      }
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)&address.sa_len = 136446210;
    *(void *)&address.sa_data[2] = "nw_listener_inbox_socket_handle_accept_event";
    _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_INFO,  "%{public}s exceeded new connection limit",  &address.sa_len,  0xCu);
  }

LABEL_39:
}

  if (v11) {
    free(v11);
  }
LABEL_3:

  return v7;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v9) {
    free(v9);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v4 != 0LL;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v4 != 0LL;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = nw_path_status_invalid;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  char v13 = calloc(1uLL, 0x158uLL);
  if (!v13)
  {
    __nwlog_obj();
    v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v103, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v109 = "strict_calloc";
    v110 = 2048;
    *(void *)v111 = 1LL;
    *(_WORD *)&v111[8] = 2048;
    *(void *)&v111[10] = 344LL;
    v104 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v104))
    {
      __break(1u);
      return;
    }

    free(v104);
  }

  nw_path_get_sysctls_region::sysctls_region = (uint64_t)v13;
  const char *v13 = 3;
  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.bg_target_qdelay", v13 + 1, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v14 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.bg_target_qdelay failed. Using default value: 40",  buf,  0xCu);
    }

    v13[1] = 40;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.bg_allowed_increase", v13 + 2, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.bg_allowed_increase failed. Using default value: 8",  buf,  0xCu);
    }

    v13[2] = 8;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.bg_tether_shift", v13 + 3, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v16 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.bg_tether_shift failed. Using default value: 1",  buf,  0xCu);
    }

    v13[3] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.bg_ss_fltsz", v13 + 4, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.bg_ss_fltsz failed. Using default value: 2",  buf,  0xCu);
    }

    v13[4] = 2;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.use_newreno", v13 + 5, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.use_newreno failed. Using default value: 0",  buf,  0xCu);
    }

    v13[5] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.cubic_tcp_friendliness", v13 + 6, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.cubic_tcp_friendliness failed. Using default value: 0",  buf,  0xCu);
    }

    v13[6] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.cubic_fast_convergence", v13 + 7, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.cubic_fast_convergence failed. Using default value: 0",  buf,  0xCu);
    }

    v13[7] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.cubic_use_minrtt", v13 + 8, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    time_t v21 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.cubic_use_minrtt failed. Using default value: 0",  buf,  0xCu);
    }

    v13[8] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.delayed_ack", v13 + 9, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v22 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.delayed_ack failed. Using default value: 3",  buf,  0xCu);
    }

    v13[9] = 3;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.recvbg", v13 + 10, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v23 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.recvbg failed. Using default value: 0",  buf,  0xCu);
    }

    v13[10] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.drop_synfin", v13 + 11, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.drop_synfin failed. Using default value: 1",  buf,  0xCu);
    }

    v13[11] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.slowlink_wsize", v13 + 12, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v25 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.slowlink_wsize failed. Using default value: 8192",  buf,  0xCu);
    }

    v13[12] = 0x2000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.maxseg_unacked", v13 + 13, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v26 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.maxseg_unacked failed. Using default value: 8",  buf,  0xCu);
    }

    v13[13] = 8;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rfc3465", v13 + 14, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v27 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rfc3465 failed. Using default value: 1",  buf,  0xCu);
    }

    v13[14] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rfc3465_lim2", v13 + 15, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v28 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rfc3465_lim2 failed. Using default value: 1",  buf,  0xCu);
    }

    v13[15] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.recv_allowed_iaj", v13 + 16, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v29 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.recv_allowed_iaj failed. Using default value: 5",  buf,  0xCu);
    }

    v13[16] = 5;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.doautorcvbuf", v13 + 17, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.doautorcvbuf failed. Using default value: 1",  buf,  0xCu);
    }

    v13[17] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.autorcvbufmax", v13 + 18, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v31 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.autorcvbufmax failed. Using default value: 2 * 1024 * 1024",  buf,  0xCu);
    }

    v13[18] = 0x200000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rcvsspktcnt", v13 + 19, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v32 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rcvsspktcnt failed. Using default value: 512",  buf,  0xCu);
    }

    v13[19] = 512;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.path_mtu_discovery", v13 + 20, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v33 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.path_mtu_discovery failed. Using default value: 1",  buf,  0xCu);
    }

    v13[20] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.local_slowstart_flightsize", v13 + 21, (size_t *)type, 0LL, 0LL)
    || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.local_slowstart_flightsize failed. Using default value: 8",  buf,  0xCu);
    }

    v13[21] = 8;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.ecn_setup_percentage", v13 + 22, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v35 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.ecn_setup_percentage failed. Using default value: 50",  buf,  0xCu);
    }

    v13[22] = 50;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.ecn_initiate_out", v13 + 23, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v36 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.ecn_initiate_out failed. Using default value: 0",  buf,  0xCu);
    }

    v13[23] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.ecn_negotiate_in", v13 + 24, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v37 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.ecn_negotiate_in failed. Using default value: 0",  buf,  0xCu);
    }

    v13[24] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.packetchain", v13 + 25, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.packetchain failed. Using default value: 50",  buf,  0xCu);
    }

    v13[25] = 50;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.socket_unlocked_on_output", v13 + 26, (size_t *)type, 0LL, 0LL)
    || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.socket_unlocked_on_output failed. Using default value: 1",  buf,  0xCu);
    }

    v13[26] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.min_iaj_win", v13 + 27, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v40 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.min_iaj_win failed. Using default value: 16",  buf,  0xCu);
    }

    v13[27] = 16;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.acc_iaj_react_limit", v13 + 28, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v41 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.acc_iaj_react_limit failed. Using default value: 200",  buf,  0xCu);
    }

    v13[28] = 200;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.autosndbufinc", v13 + 29, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v42 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.autosndbufinc failed. Using default value: 8 * 1024",  buf,  0xCu);
    }

    v13[29] = 0x2000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.autosndbufmax", v13 + 30, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v43 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.autosndbufmax failed. Using default value: 2 * 1024 * 1024",  buf,  0xCu);
    }

    v13[30] = 0x200000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rtt_recvbg", v13 + 31, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v44 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rtt_recvbg failed. Using default value: 1",  buf,  0xCu);
    }

    v13[31] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.recv_throttle_minwin", v13 + 32, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v45 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.recv_throttle_minwin failed. Using default value: 16 * 1024",  buf,  0xCu);
    }

    v13[32] = 0x4000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.enable_tlp", v13 + 33, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v46 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.enable_tlp failed. Using default value: 1",  buf,  0xCu);
    }

    v13[33] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.sack", v13 + 34, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v47 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.sack failed. Using default value: 1",  buf,  0xCu);
    }

    v13[34] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.sack_maxholes", v13 + 35, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v48 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.sack_maxholes failed. Using default value: 128",  buf,  0xCu);
    }

    v13[35] = 128;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.sack_globalmaxholes", v13 + 36, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v49 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.sack_globalmaxholes failed. Using default value: 65536",  buf,  0xCu);
    }

    v13[36] = 0x10000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.mssdflt", v13 + 37, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v50 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.mssdflt failed. Using default value: 512",  buf,  0xCu);
    }

    v13[37] = 512;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.v6mssdflt", v13 + 38, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.v6mssdflt failed. Using default value: 1024",  buf,  0xCu);
    }

    v13[38] = 1024;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.fastopen_backlog", v13 + 39, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v52 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.fastopen_backlog failed. Using default value: 10",  buf,  0xCu);
    }

    v13[39] = 10;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.fastopen", v13 + 40, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v53 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.fastopen failed. Using default value: 0x3",  buf,  0xCu);
    }

    v13[40] = 3;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.minmss", v13 + 41, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v54 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.minmss failed. Using default value: 216",  buf,  0xCu);
    }

    v13[41] = 216;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.icmp_may_rst", v13 + 42, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v55 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.icmp_may_rst failed. Using default value: 1",  buf,  0xCu);
    }

    v13[42] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rtt_min", v13 + 43, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v56 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rtt_min failed. Using default value: 100",  buf,  0xCu);
    }

    v13[43] = 100;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rexmt_slop", v13 + 44, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v57 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rexmt_slop failed. Using default value: 200",  buf,  0xCu);
    }

    v13[44] = 200;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.randomize_ports", v13 + 45, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v58 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v58,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.randomize_ports failed. Using default value: 0",  buf,  0xCu);
    }

    v13[45] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.win_scale_factor", v13 + 46, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v59 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v59, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.win_scale_factor failed. Using default value: 3",  buf,  0xCu);
    }

    v13[46] = 3;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.keepinit", v13 + 47, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v60 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.keepinit failed. Using default value: 75 * 1000",  buf,  0xCu);
    }

    v13[47] = 75000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.keepidle", v13 + 48, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v61 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.keepidle failed. Using default value: 120 * 60 * 1000",  buf,  0xCu);
    }

    v13[48] = 7200000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.keepintvl", v13 + 49, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v62 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.keepintvl failed. Using default value: 75 * 1000",  buf,  0xCu);
    }

    v13[49] = 75000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.keepcnt", v13 + 50, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v63 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.keepcnt failed. Using default value: 8",  buf,  0xCu);
    }

    v13[50] = 8;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.msl", v13 + 51, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v64 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.msl failed. Using default value: 15 * 1000",  buf,  0xCu);
    }

    v13[51] = 15000;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.max_persist_timeout", v13 + 52, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v65 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.max_persist_timeout failed. Using default value: 0",  buf,  0xCu);
    }

    v13[52] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.always_keepalive", v13 + 53, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v66 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v66, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.always_keepalive failed. Using default value: 0",  buf,  0xCu);
    }

    v13[53] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.timer_fastmode_idlemax", v13 + 54, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v67 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.timer_fastmode_idlemax failed. Using default value: 10",  buf,  0xCu);
    }

    v13[54] = 10;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.broken_peer_syn_rexmit_thres", v13 + 55, (size_t *)type, 0LL, 0LL)
    || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v68 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.broken_peer_syn_rexmit_thres failed. Using default value: 10",  buf,  0xCu);
    }

    v13[55] = 10;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.pmtud_blackhole_detection", v13 + 56, (size_t *)type, 0LL, 0LL)
    || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v69 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.pmtud_blackhole_detection failed. Using default value: 1",  buf,  0xCu);
    }

    v13[56] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.pmtud_blackhole_mss", v13 + 57, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v70 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v70, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.pmtud_blackhole_mss failed. Using default value: 1200",  buf,  0xCu);
    }

    v13[57] = 1200;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.sendspace", v13 + 58, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v71 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.sendspace failed. Using default value: 1448*256",  buf,  0xCu);
    }

    v13[58] = 370688;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.recvspace", v13 + 59, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v72 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v72, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.recvspace failed. Using default value: 1448*384",  buf,  0xCu);
    }

    v13[59] = 556032;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.microuptime_init", v13 + 60, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v73 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.microuptime_init failed. Using default value: 0",  buf,  0xCu);
    }

    v13[60] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.now_init", v13 + 61, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v74 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v74,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.now_init failed. Using default value: 0",  buf,  0xCu);
    }

    v13[61] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.challengeack_limit", v13 + 62, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v75 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v75, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.challengeack_limit failed. Using default value: 10",  buf,  0xCu);
    }

    v13[62] = 10;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.do_rfc5961", v13 + 63, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v76 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v76,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.do_rfc5961 failed. Using default value: 1",  buf,  0xCu);
    }

    v13[63] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.init_rtt_from_cache", v13 + 64, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v77 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v77, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.init_rtt_from_cache failed. Using default value: 1",  buf,  0xCu);
    }

    v13[64] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.autotunereorder", v13 + 65, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v78 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.autotunereorder failed. Using default value: 1",  buf,  0xCu);
    }

    v13[65] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.do_ack_compression", v13 + 66, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v79 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v79, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.do_ack_compression failed. Using default value: 1",  buf,  0xCu);
    }

    v13[66] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.ack_compression_rate", v13 + 67, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v80 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.ack_compression_rate failed. Using default value: 5",  buf,  0xCu);
    }

    v13[67] = 5;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.do_better_lr", v13 + 68, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v81 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.do_better_lr failed. Using default value: 1",  buf,  0xCu);
    }

    v13[68] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.cubic_minor_fixes", v13 + 69, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v82 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v82, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.cubic_minor_fixes failed. Using default value: 1",  buf,  0xCu);
    }

    v13[69] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.cubic_rfc_compliant", v13 + 70, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v83 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.cubic_rfc_compliant failed. Using default value: 1",  buf,  0xCu);
    }

    v13[70] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.aggressive_rcvwnd_inc", v13 + 71, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v84 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v84, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.aggressive_rcvwnd_inc failed. Using default value: 1",  buf,  0xCu);
    }

    v13[71] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.ack_strategy", v13 + 72, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v85 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v85, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.ack_strategy failed. Using default value: 1",  buf,  0xCu);
    }

    v13[72] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.flow_control_response", v13 + 73, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v86 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v86, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.flow_control_response failed. Using default value: 1",  buf,  0xCu);
    }

    v13[73] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.randomize_timestamps", v13 + 74, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v87 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v87, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.randomize_timestamps failed. Using default value: 1",  buf,  0xCu);
    }

    v13[74] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.ledbat_plus_plus", v13 + 75, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v88 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v88, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.ledbat_plus_plus failed. Using default value: 1",  buf,  0xCu);
    }

    v13[75] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.use_ledbat", v13 + 76, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v89 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v89, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.use_ledbat failed. Using default value: 0",  buf,  0xCu);
    }

    v13[76] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rledbat", v13 + 77, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v90 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v90, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v90,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rledbat failed. Using default value: 1",  buf,  0xCu);
    }

    v13[77] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.use_min_curr_rtt", v13 + 78, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v91 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v91, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v91,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.use_min_curr_rtt failed. Using default value: 1",  buf,  0xCu);
    }

    v13[78] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.fin_timeout", v13 + 79, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v92 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v92, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.fin_timeout failed. Using default value: 30",  buf,  0xCu);
    }

    v13[79] = 30;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.accurate_ecn", v13 + 80, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v93 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v93, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v93,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.accurate_ecn failed. Using default value: 0",  buf,  0xCu);
    }

    v13[80] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.tso", v13 + 81, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v94 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v94, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.tso failed. Using default value: 1",  buf,  0xCu);
    }

    v13[81] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.awdl_rtobase", v13 + 82, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v95 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v95, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.awdl_rtobase failed. Using default value: 100",  buf,  0xCu);
    }

    v13[82] = 100;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.rack", v13 + 83, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v96 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.rack failed. Using default value: 1",  buf,  0xCu);
    }

    v13[83] = 1;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("net.inet.tcp.l4s", v13 + 84, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v97 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v97, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v97,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname net.inet.tcp.l4s failed. Using default value: 0",  buf,  0xCu);
    }

    v13[84] = 0;
  }

  *(void *)os_log_type_t type = 4LL;
  if (sysctlbyname("kern.ipc.throttle_best_effort", v13 + 85, (size_t *)type, 0LL, 0LL) || *(void *)type != 4LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v98 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v98, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v109 = "nw_path_get_sysctls_region_block_invoke";
      _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_INFO,  "%{public}s sysctlbyname kern.ipc.throttle_best_effort failed. Using default value: 0",  buf,  0xCu);
    }

    v13[85] = 0;
  }

  nw_path_get_sysctls_region::sysctls_region = (uint64_t)v13;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v4) {
    free(v4);
  }
LABEL_3:
}

    if (v4) {
      free(v4);
    }
    return 0LL;
  }

  v1 = *(void *)(a1 + 112);
  if (v1) {
    return *(unsigned int *)(v1 + 8);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *((void *)v1 + 26);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(void *)(v3 + 16) != *(void *)(v3 + 24);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = *((void *)v1 + 9);
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = *(void *)(v3 + 16) != *(void *)(v3 + 24);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  return 0LL;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  vpn_config_uuid = 0LL;
LABEL_3:

  return vpn_config_uuid;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  BOOL v16 = v8 + v11 + 4;
  *a3 = v16;
  if (v8 + v11 == -4)
  {
    __nwlog_obj();
    v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "strict_calloc";
    os_log_type_t v43 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v43);
    if (result) {
      goto LABEL_77;
    }
    free(v43);
  }

  __int16 v17 = (char *)calloc(1uLL, v16);
  if (v17)
  {
LABEL_22:
    const char *v17 = *v17 & 0xF8 | *(_BYTE *)(a2 + 24) & 7;
    v17[1] = v13;
    v18 = v17 + 2;
    if (v13)
    {
      uint64_t v19 = *(const __CFData **)(a2 + 8);
      if (v19)
      {
        Length = CFDataGetLength(*(CFDataRef *)(a2 + 8));
        BytePtr = CFDataGetBytePtr(v19);
        *((_WORD *)v17 + 1) = Length;
        memcpy(v17 + 4, BytePtr, Length);
        v18 = &v17[Length + 4];
      }

      if (v13 != 1)
      {
        uint64_t v29 = v13 - 1LL;
        v30 = 0;
        do
        {
          v31 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 16), v30);
          os_log_type_t v32 = v31;
          if (v31)
          {
            v33 = CFDataGetLength(v31);
            v34 = CFDataGetBytePtr(v32);
            *(_WORD *)v18 = v33;
            v35 = v18 + 2;
            memcpy(v35, v34, v33);
            v18 = &v35[v33];
          }

          ++v30;
          --v29;
        }

        while (v29);
      }
    }

    if (*(void *)a2)
    {
      char v22 = CFArrayGetCount(*(CFArrayRef *)a2);
      if (v22)
      {
        for (i = 0LL; i != v22; ++i)
        {
          __int16 v25 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)a2, i);
          __int16 v26 = v25;
          if (v25)
          {
            __int16 v27 = CFDataGetLength(v25);
            uint64_t v28 = CFDataGetBytePtr(v26);
            *(_WORD *)v18 = v27;
            v24 = v18 + 2;
            memcpy(v24, v28, v27);
            v18 = &v24[v27];
          }
        }
      }
    }

    goto LABEL_76;
  }

  __nwlog_obj();
  v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v58 = "strict_calloc";
  v59 = 2048;
  v60 = 1LL;
  char v61 = 2048;
  os_log_type_t v62 = v16;
  v46 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v46);
  if (!result)
  {
    free(v46);
    goto LABEL_22;
  }

  if (v3) {
    free(v3);
  }
LABEL_3:
}

  if (v3) {
    free(v3);
  }
LABEL_3:
}

  if (v3) {
    free(v3);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }

  if (v8) {
    free(v8);
  }
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

  if (v5) {
    free(v5);
  }
  v2 = 0LL;
LABEL_3:

  return v2;
}

    goto LABEL_21;
  }

  os_log_type_t v4 = v2;
  time_t v5 = (const char *)_nw_http_request_copy_url();

  if (v5)
  {
    url = nw_endpoint_create_url(v5);
    BOOL v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
    os_log_type_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = url;

    os_log_type_t v9 = (char *)v5;
LABEL_4:
    free(v9);
  }

  return v2 != 0LL;
}
  }
  }

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v11) {
    free(v11);
  }
  os_log_type_t v8 = 0LL;
LABEL_3:

  return v8;
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v9) {
    free(v9);
  }
LABEL_3:

  return (NWConcrete_nw_agent *)v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v11) {
    free(v11);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  if (v11) {
    free(v11);
  }
LABEL_3:
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

  free(v15);
  if (v6) {
LABEL_43:
  }
    free(v6);
}

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  char v13 = (os_log_s *)gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    os_log_type_t v15 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447490;
    v106 = "nw_protocol_http2_remove_input_handler";
    v107 = 2082;
    v108 = handle + 390;
    v109 = 2080;
    v110 = " ";
    v111 = 1024;
    v112 = v15;
    v113 = 1042;
    *(_DWORD *)v114 = 16;
    *(_WORD *)&v114[4] = 2098;
    *(void *)&v114[6] = a2;
    _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> http2 does not have input handler registered for %{public,uuid_t}.16P",  buf,  0x36u);
    return 0LL;
  }

  return result;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_application_service_name";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_application_service_name";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_browse_descriptor_get_application_service_name";
        os_log_type_t v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_bundle_id";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_bundle_id";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_browse_descriptor_get_bundle_id";
        os_log_type_t v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    goto LABEL_21;
  }

  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)(id)gLogObj;
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      char v22 = "nw_browse_descriptor_set_device_types";
      _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  os_log_type_t v9 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v7 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  BOOL v11 = os_log_type_enabled(v7, type);
  if (!v9)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      char v22 = "nw_browse_descriptor_set_device_types";
      _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    char v22 = "nw_browse_descriptor_set_device_types";
    os_log_type_t v23 = 2082;
    v24 = v9;
    _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v6) {
    goto LABEL_22;
  }
LABEL_23:
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_device_types";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_device_types";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_browse_descriptor_get_device_types";
        os_log_type_t v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

    goto LABEL_21;
  }

  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)(id)gLogObj;
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      char v22 = "nw_browse_descriptor_set_browse_scope";
      _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  os_log_type_t v9 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v7 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  BOOL v11 = os_log_type_enabled(v7, type);
  if (!v9)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      char v22 = "nw_browse_descriptor_set_browse_scope";
      _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    char v22 = "nw_browse_descriptor_set_browse_scope";
    os_log_type_t v23 = 2082;
    v24 = v9;
    _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v6) {
    goto LABEL_22;
  }
LABEL_23:
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_browse_scope";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_browse_scope";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_browse_descriptor_get_browse_scope";
        os_log_type_t v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v8) {
    free(v8);
  }
  time_t v5 = 0LL;
LABEL_3:

  return v5;
}

    if (v4) {
      free(v4);
    }
    return 0LL;
  }

  v1 = *(void *)(a1 + 104);
  if (v1) {
    return (uint64_t)(*(void *)(v1 + 24) - *(void *)(v1 + 16)) >> 3;
  }
  return 0LL;
}

  if (v5) {
    free(v5);
  }
LABEL_3:
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_copy_custom_data";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_copy_custom_data";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_browse_descriptor_copy_custom_data";
        os_log_type_t v23 = 2082;
        *(void *)v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_copy_custom_browse_block";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_copy_custom_browse_block";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_browse_descriptor_copy_custom_browse_block";
        os_log_type_t v23 = 2082;
        *(void *)v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    goto LABEL_21;
  }

  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)(id)gLogObj;
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      char v22 = "nw_browse_descriptor_set_invitation_scope";
      _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s Browse descriptor not of type application service, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  os_log_type_t v9 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v7 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  BOOL v11 = os_log_type_enabled(v7, type);
  if (!v9)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      char v22 = "nw_browse_descriptor_set_invitation_scope";
      _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s Browse descriptor not of type application service, no backtrace",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    char v22 = "nw_browse_descriptor_set_invitation_scope";
    os_log_type_t v23 = 2082;
    v24 = v9;
    _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v6) {
    goto LABEL_22;
  }
LABEL_23:
}

        goto LABEL_21;
      }

      if (!v19)
      {
        __nwlog_obj();
        char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_invitation_scope";
          _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = type;
      __int16 v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_browse_descriptor_get_invitation_scope";
          _os_log_impl(&dword_181A5C000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_20;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v22 = "nw_browse_descriptor_get_invitation_scope";
        os_log_type_t v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_22;
  }

  id v3 = nw_path_parameters_copy_context(*((void **)v1 + 2));
  nw_context_assert_queue(v3);

  os_log_type_t v4 = v2[6];
  if (!v4)
  {
LABEL_22:
    time_t v5 = 0LL;
    goto LABEL_23;
  }

  time_t v5 = *(unsigned int *)(v4 + 40);
LABEL_23:

  return v5;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    goto LABEL_21;
  }

  BOOL v11 = v9;

  self = (NWPathEvaluator *)v11;
  os_log_type_t v12 = self;
LABEL_25:

  return v12;
}

    if (v4) {
      free(v4);
    }
    goto LABEL_22;
  }

  *(void *)cStr = 0LL;
  asprintf((char **)cStr, "[SP%llu %s]", *((void *)self + 1), "MASQUE");
  if (!*(void *)cStr)
  {
LABEL_22:
    v2 = 0LL;
    return (NSString *)v2;
  }

  v2 = (__CFString *)CFStringCreateWithCStringNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  *(const char **)cStr,  0x8000100u,  (CFAllocatorRef)*MEMORY[0x189604DB8]);
  return (NSString *)v2;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
  os_log_type_t v4 = 0LL;
LABEL_3:

  return v4;
}

  if (v7) {
    free(v7);
  }
LABEL_3:
}

  if (v8) {
    free(v8);
  }
LABEL_3:

  return 1LL;
}

  if (v9) {
    free(v9);
  }
  char v6 = 0LL;
LABEL_3:

  return v6;
}

  if (v20) {
    free(v20);
  }
LABEL_3:

  return v13;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v7) {
    free(v7);
  }
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }

  id v3 = v1[22];
  if (!v3)
  {
LABEL_22:
    os_log_type_t v4 = 0LL;
    goto LABEL_23;
  }

  os_log_type_t v4 = nw_interface_create_with_index(v3);
LABEL_23:

  return v4;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0xFFFFFFFFLL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_3:

  return v3;
}

  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_context_assert_queue(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  v1 = a1;
  id v3 = v1;
  if (v1)
  {
    if (((_BYTE)v1[17] & 8) == 0) {
      dispatch_assert_queue_V2(v1[1]);
    }
    goto LABEL_4;
  }

  __nwlog_obj(0LL, v2);
  os_log_type_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_context_assert_queue";
  time_t v5 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  uint64_t v6 = __nwlog_fault(v5, &type, &v15);
  if ((_DWORD)v6)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v6, v7);
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_context_assert_queue";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj(backtrace_string, v11);
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_context_assert_queue";
          __int16 v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_context_assert_queue";
        _os_log_impl(&dword_181A5C000, v8, v12, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj(v6, v7);
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_context_assert_queue";
        _os_log_impl( &dword_181A5C000,  v8,  v14,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A64A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_association_is_empty_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  nw_hash_node_get_object(a2);
  os_log_type_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t extra = nw_hash_node_get_extra(a2);
  if (*(void *)(a1 + 48) <= *(void *)(extra + 32)) {
    goto LABEL_17;
  }
  uint64_t v6 = (uint64_t *)extra;
  uint64_t v7 = *(void *)(extra + 40);
  if (v7) {
    nw_protocol_definition_deallocate_cache_entry(v4, v7);
  }
  nw_context_remove_cache_entry(*(void **)(a1 + 32), v6);
  if (nw_hash_table_remove_node(*(void *)(*(void *)(a1 + 40) + 56LL), a2)
    || nw_path_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 40) + 16LL)))
  {
    goto LABEL_17;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  id v8 = (id)gconnectionLogObj;
  logging_description = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
  *(_DWORD *)buf = 136446722;
  __int16 v27 = "nw_association_is_empty_block_invoke";
  __int16 v28 = 2082;
  uint64_t v29 = logging_description;
  __int16 v30 = 2048;
  uint64_t v31 = a2;
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v10, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        BOOL v13 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
        *(_DWORD *)buf = 136446722;
        __int16 v27 = "nw_association_is_empty_block_invoke";
        __int16 v28 = 2082;
        uint64_t v29 = v13;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p",  buf,  0x20u);
      }
    }

    else if (v24)
    {
      backtrace_string = __nw_create_backtrace_string();
      if (backtrace_string)
      {
        BOOL v16 = (char *)backtrace_string;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v17 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          __int16 v19 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
          *(_DWORD *)buf = 136446978;
          __int16 v27 = "nw_association_is_empty_block_invoke";
          __int16 v28 = 2082;
          uint64_t v29 = v19;
          __int16 v30 = 2048;
          uint64_t v31 = a2;
          __int16 v32 = 2082;
          v33 = v16;
          _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v16);
        if (v10) {
          goto LABEL_16;
        }
        goto LABEL_17;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        os_log_type_t v23 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
        *(_DWORD *)buf = 136446722;
        __int16 v27 = "nw_association_is_empty_block_invoke";
        __int16 v28 = 2082;
        uint64_t v29 = v23;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        uint64_t v21 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8LL));
        *(_DWORD *)buf = 136446722;
        __int16 v27 = "nw_association_is_empty_block_invoke";
        __int16 v28 = 2082;
        uint64_t v29 = v21;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v10) {
LABEL_16:
  }
    free(v10);
LABEL_17:

  return 1LL;
}

void sub_181A64EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_hash_node_get_extra(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return a1 + 32;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "nw_hash_node_get_extra";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_hash_node_get_extra";
        time_t v5 = "%{public}s called with null node";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "nw_hash_node_get_extra";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null node, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_hash_node_get_extra";
        time_t v5 = "%{public}s called with null node, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      id v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_hash_node_get_extra";
        time_t v5 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_hash_table_count(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(unsigned int *)(a1 + 40);
  }
  __nwlog_obj(0LL, a2);
  *(_DWORD *)buf = 136446210;
  char v15 = "nw_hash_table_count";
  id v3 = (void *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  uint64_t v4 = __nwlog_fault(v3, &type, &v12);
  if ((_DWORD)v4)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj(v4, v5);
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_hash_table_count";
        char v8 = "%{public}s called with null table";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj(backtrace_string, v10);
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v15 = "nw_hash_table_count";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null table, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_hash_table_count";
        char v8 = "%{public}s called with null table, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj(v4, v5);
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_hash_table_count";
        char v8 = "%{public}s called with null table, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void nw_protocol_definition_deallocate_cache_entry(void *a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8) {
          goto LABEL_5;
        }
LABEL_56:
        free(v8);
        goto LABEL_5;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_54:
    goto LABEL_55;
  }

  uint64_t v5 = *((void *)v3 + 9);
  if (!v5)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null definition->common_state", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null definition->common_state, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null definition->common_state, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null definition->common_state, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  uint64_t v6 = *(void (**)(id, uint64_t))(v5 + 56);
  if (!v6)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null definition->common_state->deallocate_cache_entry",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null definition->common_state->deallocate_cache_entry, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null definition->common_state->deallocate_cache_entry, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_deallocate_cache_entry";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null definition->common_state->deallocate_cache_entry, dumping backtrace:%{public}s",  buf,  0x16u);
    }

      if (v23) {
        free(v23);
      }
      goto LABEL_56;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_path_evaluator_start";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v13, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)(id)gLogObj;
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_path_evaluator_start";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
        }
      }

      else if (v50)
      {
        uint64_t v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v14, type);
        if (v18)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v53 = "nw_path_evaluator_start";
            uint64_t v54 = 2082;
            *(void *)v55 = v18;
            _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s nw_path_evaluator_evaluate failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v18);
          if (!v13) {
            goto LABEL_5;
          }
          goto LABEL_21;
        }

        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_path_evaluator_start";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s nw_path_evaluator_evaluate failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)(id)gLogObj;
        char v26 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_path_evaluator_start";
          _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s nw_path_evaluator_evaluate failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v13) {
      goto LABEL_5;
    }
LABEL_21:
    free(v13);
    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v41 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v53 = "nw_path_evaluator_start";
  v42 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v50 = 0;
  if (__nwlog_fault(v42, &type, &v50))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_path_evaluator_start";
        _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }

    else if (v50)
    {
      v45 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      v47 = os_log_type_enabled(v43, type);
      if (v45)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v53 = "nw_path_evaluator_start";
          uint64_t v54 = 2082;
          *(void *)v55 = v45;
          _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s called with null evaluator, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v45);
        goto LABEL_90;
      }

      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_path_evaluator_start";
        _os_log_impl(&dword_181A5C000, v43, v46, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_path_evaluator_start";
        _os_log_impl( &dword_181A5C000,  v43,  v48,  "%{public}s called with null evaluator, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v34) {
      free(v34);
    }
    mode = 0;
    goto LABEL_57;
  }

  mode = v1->mode;

  if (mode == 1)
  {
    uint64_t v4 = v2;
    os_unfair_lock_lock(&v4->lock);
    uint64_t v5 = v4->current_path;
    os_unfair_lock_unlock(&v4->lock);

    uint64_t v6 = (void **)nw_endpoint_handler_copy_resolver(v4);
    os_log_type_t v7 = v6[1];
    if (!v7)
    {
LABEL_14:
      os_log_type_t v19 = nw_dictionary_create();
      BOOL v20 = MEMORY[0x1895F87A8];
      v63[0] = MEMORY[0x1895F87A8];
      v63[1] = 3221225472LL;
      v63[2] = ___ZL48nw_endpoint_resolver_update_path_resolver_lockedP30NWConcrete_nw_endpoint_handler_block_invoke;
      v63[3] = &unk_189BBBA18;
      os_log_type_t v21 = v6;
      char v64 = v21;
      BOOL v22 = v19;
      v65 = v22;
      os_log_type_t v23 = v4;
      v66 = v23;
      nw_path_enumerate_resolve_options(v5, v63);
      objc_storeStrong(v21 + 10, v19);
      os_log_type_t v24 = v21[11];
      os_log_type_t v25 = nw_path_copy_resolved_endpoints(v5);
      char v26 = v21[11];
      v21[11] = v25;

      if (v24 || v21[11]) {
        goto LABEL_26;
      }
      __int16 v27 = (unsigned __int8 *)nw_path_copy_flows(v5);
      __int16 v28 = v27;
      if (v27)
      {
        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3032000000LL;
        v70 = __Block_byref_object_copy__30091;
        *(void *)&v71 = __Block_byref_object_dispose__30092;
        *((void *)&v71 + 1) = 0LL;
        v62[0] = v20;
        v62[1] = 3221225472LL;
        v62[2] = ___ZL48nw_endpoint_resolver_update_path_resolver_lockedP30NWConcrete_nw_endpoint_handler_block_invoke_97;
        v62[3] = &unk_189BC50D0;
        v62[4] = buf;
        nw_array_apply(v27, (uint64_t)v62);
        if (*(void *)(*(void *)&buf[8] + 40LL))
        {
          uint64_t v29 = nw_endpoint_handler_copy_endpoint(v23);
          __int16 v30 = nw_endpoint_get_type(v29);

          nw_endpoint_handler_handle_failure(v23);
          if (v30 == 5) {
            uint64_t v31 = 7;
          }
          else {
            uint64_t v31 = 2;
          }
          uint64_t v32 = *(void **)(*(void *)&buf[8] + 40LL);
          v23->event.domain = 2;
          v23->event.event = v31;
          nw_endpoint_handler_report(v23, 0LL, &v23->event.domain, v32);
        }

        _Block_object_dispose(buf, 8);
      }

      if (v21[11]) {
LABEL_26:
      }
        nw_endpoint_resolver_update(v23, v6[1], 2u);

      goto LABEL_78;
    }

    char v8 = v7;
    os_log_type_t v9 = v5;
    os_log_type_t v10 = v9;
    if (v9)
    {
      BOOL v11 = v8[346];
      if ((v11 & 0x40) == 0)
      {
        os_log_type_t v12 = v9;
        BOOL v13 = *((_BYTE *)v12 + 473);

        if ((v13 & 0x40) != 0) {
          *((_WORD *)v8 + 44) &= ~1u;
        }
        BOOL v11 = v8[346];
      }

      if ((v11 & 0x80) == 0)
      {
        os_log_type_t v14 = v10;
        char v15 = *((char *)v14 + 473);

        if (v15 < 0) {
          *((_WORD *)v8 + 44) &= ~2u;
        }
      }

      os_log_type_t v16 = v10;
      BOOL v17 = *((_BYTE *)v16 + 473) & 0x40;

      v8[346] = v8[346] & 0xBF | v17;
      uint64_t v18 = v16;
      LOBYTE(v16) = *((_BYTE *)v16 + 473);

      v8[346] = v16 & 0x80 | v8[346] & 0x7F;
LABEL_13:

      goto LABEL_14;
    }

    __nwlog_obj();
    os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_update_path";
    BOOL v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (__nwlog_fault(v41, &type, &v67))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_update_path";
          _os_log_impl(&dword_181A5C000, v42, v43, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v67)
      {
        v45 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v46 = type;
        v47 = os_log_type_enabled(v42, type);
        if (v45)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_resolver_update_path";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v45;
            _os_log_impl( &dword_181A5C000,  v42,  v46,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v45);
          goto LABEL_98;
        }

        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_update_path";
          _os_log_impl(&dword_181A5C000, v42, v46, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v61 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_update_path";
          _os_log_impl( &dword_181A5C000,  v42,  v61,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_55:
      if (v10) {
        free(v10);
      }
      goto LABEL_57;
    }

    if (!v28)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl( &dword_181A5C000,  v11,  v26,  "%{public}s called with null signature_len, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v11, v22, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_path_get_ipv4_network_signature";
      uint64_t v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s called with null signature_len, dumping backtrace:%{public}s",  buf,  0x16u);
    }

            os_log_type_t v40 = v175;
            BOOL v41 = v40[94];

            if (v41 == 3) {
              v42 = is_viable;
            }
            else {
              v42 = 1;
            }
            if ((v42 & 1) == 0)
            {
              BOOL v44 = v7;
              v45 = v44;
              v46 = (void *)*((void *)v44 + 4);
              if (v46)
              {
                v47 = v46;
                v48 = (v47[12] & 0x4000000000LL) == 0;

                if (!v48)
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v45) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v56 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
                    {
                      v134 = nw_endpoint_handler_get_id_string(v45);
                      v135 = nw_endpoint_handler_dry_run_string(v45);
                      v136 = nw_endpoint_handler_copy_endpoint(v45);
                      v137 = nw_endpoint_get_logging_description(v136);
                      v138 = nw_endpoint_handler_state_string(v45);
                      v139 = nw_endpoint_handler_mode_string(v45);
                      v140 = nw_endpoint_handler_copy_current_path(v45);
                      *(_DWORD *)buf = 136448258;
                      v179 = "nw_endpoint_handler_get_alternate_path_state";
                      v180 = 2082;
                      v181 = (void *)v134;
                      v182 = 2082;
                      v183 = v135;
                      v184 = 2082;
                      v185 = (void *)v137;
                      v186 = 2082;
                      v187 = v138;
                      v188 = 2082;
                      v189 = v139;
                      v190 = 2114;
                      v191 = v140;
                      v192 = 2114;
                      v193 = (nw_endpoint *)v173;
                      v194 = 2114;
                      v195 = (nw_endpoint *)v40;
                      _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] satisfiable pat h %{public}@ preferred to non-viable path %{public}@",  buf,  0x5Cu);
                    }

                    goto LABEL_107;
                  }

                  goto LABEL_191;
                }

                if ((*((_BYTE *)v45 + 268) & 0x20) != 0) {
                  goto LABEL_191;
                }
              }

              else
              {

                if ((*((_BYTE *)v45 + 268) & 0x20) != 0) {
                  goto LABEL_191;
                }
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              os_log_type_t v43 = 1LL;
              v56 = (os_log_s *)(id)gconnectionLogObj;
              if (!os_log_type_enabled(v56, OS_LOG_TYPE_INFO)) {
                goto LABEL_122;
              }
              if ((*((_BYTE *)v45 + 268) & 1) != 0) {
                uint64_t v57 = "dry-run ";
              }
              else {
                uint64_t v57 = "";
              }
              uint64_t v58 = nw_endpoint_handler_copy_endpoint(v45);
              v59 = nw_endpoint_get_logging_description(v58);
              v60 = v45 + 21;
              char v61 = *((unsigned int *)v45 + 30);
              os_log_type_t v62 = v59;
              else {
                v63 = off_189BBBBF0[v61];
              }
              v167 = v63;
              char v64 = v45;
              v65 = v64;
              v66 = "path";
              switch(*((_DWORD *)v174 + 29))
              {
                case 0:
                  break;
                case 1:
                  v66 = "resolver";
                  break;
                case 2:
                  v66 = nw_endpoint_flow_mode_string(*(void **)&v64[62]._os_unfair_lock_opaque);
                  break;
                case 3:
                  v66 = "proxy";
                  break;
                case 4:
                  v66 = "fallback";
                  break;
                case 5:
                  v66 = "transform";
                  break;
                default:
                  v66 = "unknown-mode";
                  break;
              }

              v86 = v65 + 28;
              v87 = v65;
              os_unfair_lock_lock(v65 + 28);
              v88 = v87[8];
              os_unfair_lock_unlock(v86);

              *(_DWORD *)buf = 136448258;
              v179 = "nw_endpoint_handler_get_alternate_path_state";
              v180 = 2082;
              v181 = v60;
              v182 = 2082;
              v183 = v57;
              v184 = 2082;
              v185 = (void *)v62;
              v186 = 2082;
              v187 = v167;
              v188 = 2082;
              v189 = v66;
              v190 = 2114;
              v191 = v88;
              v192 = 2114;
              v193 = (nw_endpoint *)v173;
              v194 = 2114;
              v195 = (nw_endpoint *)v40;
              _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] satisfiable path %{publ ic}@ preferred to non-viable path %{public}@",  buf,  0x5Cu);

              goto LABEL_107;
            }

  if (v17) {
LABEL_55:
  }
    free(v17);
LABEL_56:
  __int16 v27 = 0LL;
LABEL_66:

  return v27;
}

  result = sub_18264F318();
  __break(1u);
  return result;
}

    goto LABEL_55;
  }

  char v8 = *((void *)v6 + 9);
  if (!v8)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_definition_deallocate_globals";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null definition->common_state", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v30)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v28 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null definition->common_state, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    os_log_type_t v24 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null definition->common_state, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_protocol_definition_deallocate_globals";
      uint64_t v34 = 2082;
      v35 = v22;
      _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null definition->common_state, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  os_log_type_t v9 = *(void (**)(id, uint64_t))(v8 + 16);
  if (!v9)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_definition_deallocate_globals";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null definition->common_state->deallocate_globals",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v30)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v29,  "%{public}s called with null definition->common_state->deallocate_globals, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = type;
    char v26 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null definition->common_state->deallocate_globals, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_protocol_definition_deallocate_globals";
      uint64_t v34 = 2082;
      v35 = v22;
      _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null definition->common_state->deallocate_globals, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v8)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_context_set_input_byte_cap";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v36 = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v35)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v28 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl( &dword_181A5C000,  v13,  v28,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = v36;
    os_log_type_t v24 = os_log_type_enabled(v13, v36);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_181A5C000, v13, v23, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_context_set_input_byte_cap";
      v39 = 2082;
      os_log_type_t v40 = v22;
      _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v9)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_context_set_input_byte_cap";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v36 = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v18 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null cap_exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v35)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl( &dword_181A5C000,  v13,  v29,  "%{public}s called with null cap_exceeded, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v25 = v36;
    char v26 = os_log_type_enabled(v13, v36);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_181A5C000, v13, v25, "%{public}s called with null cap_exceeded, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_context_set_input_byte_cap";
      v39 = 2082;
      os_log_type_t v40 = v22;
      _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null cap_exceeded, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (v33) {
      free(v33);
    }
    goto LABEL_25;
  }

  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  }
  uint64_t v18 = (os_log_s *)(id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    os_log_type_t v19 = *(void *)(*(void *)(a1 + 32) + 8LL);
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_candidate_manager_monitor_interface_use_block_invoke";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v19;
    _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEFAULT,  "%{public}s [CM%zu] Changed to no working path",  buf,  0x16u);
  }

  if ((nw_parameters_get_server_mode(*(void **)(*(void *)(a1 + 32) + 80LL)) & 1) == 0)
  {
    BOOL v17 = *(NWConcrete_nw_candidate_manager **)(a1 + 32);
    if (!v17->ids_endpoint || v17->ids_path_evaluator)
    {
LABEL_13:
      nw_candidate_manager_start_awdl_resolver(v17);
      goto LABEL_26;
    }

    os_log_type_t v24 = v17;
    if (v24->lost_path_timer)
    {
      if (__nwlog_candidate_manager_log::onceToken != -1) {
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      }
      os_log_type_t v25 = (os_log_s *)(id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        log_id = v24->log_id;
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_candidate_manager_start_lost_path_timer";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = log_id;
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_INFO,  "%{public}s [CM%zu] Lost path timer already started",  buf,  0x16u);
      }
    }

    else
    {
      if (__nwlog_candidate_manager_log::onceToken != -1) {
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      }
      __int16 v27 = (os_log_s *)(id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v28 = v24->log_id;
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_candidate_manager_start_lost_path_timer";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v28;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEFAULT,  "%{public}s [CM%zu] Starting lost path timer",  buf,  0x16u);
      }

      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL42nw_candidate_manager_start_lost_path_timerP31NWConcrete_nw_candidate_manager_block_invoke;
      os_log_type_t v43 = &unk_189BC93A0;
      BOOL v44 = v24;
      source = nw_queue_context_create_source(0LL, 2, 3, 0, buf, 0LL);
      v24->lost_path_timer = (void *)source;
      __int16 v30 = dispatch_time(0x8000000000000000LL, 30000000000LL);
      nw_queue_set_timer_values(source, v30, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      nw_queue_activate_source((uint64_t)v24->lost_path_timer, v31);
      os_log_type_t v25 = (os_log_s *)v44;
    }

    nw_candidate_manager_start_ids_internal(*(void **)(a1 + 32), *(void **)(*(void *)(a1 + 32) + 16LL));
  }

  _Block_object_dispose(&v65, 8);
LABEL_55:
}

      free(v27);
      if (!v8) {
        goto LABEL_34;
      }
      goto LABEL_33;
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_candidate_manager_set_state_changed_handler";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v34 = 0;
    if (__nwlog_fault(v8, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_181A5C000, v9, v24, "%{public}s called with null candidate_manager", buf, 0xCu);
        }

        goto LABEL_31;
      }

      if (!v34)
      {
        __nwlog_obj();
        os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v32 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v32,  "%{public}s called with null candidate_manager, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_31;
      }

      __int16 v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v28 = type;
      uint64_t v29 = os_log_type_enabled(v9, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v28,  "%{public}s called with null candidate_manager, no backtrace",  buf,  0xCu);
        }

        goto LABEL_31;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_candidate_manager_set_state_changed_handler";
        v38 = 2082;
        v39 = v27;
        _os_log_impl( &dword_181A5C000,  v9,  v28,  "%{public}s called with null candidate_manager, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_54;
    }
  }

    free(backtrace_string);
    goto LABEL_77;
  }

  BOOL v11 = (os_log_s *)__nwlog_obj();
  os_log_type_t v12 = type[0];
  if (os_log_type_enabled(v11, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    BOOL v13 = "%{public}s called with null frames";
    goto LABEL_76;
  }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_input_handler";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null input_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_input_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null input_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_input_handler";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null input_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_input_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if ((*((_BYTE *)v3 + 606) & 4) == 0)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_input_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer->in_start", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_input_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null framer->in_start, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_input_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_input_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_output_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_output_handler";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null output_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_output_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null output_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_output_handler";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null output_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_output_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null output_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if ((*((_BYTE *)v3 + 606) & 4) == 0)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_output_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_output_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer->in_start", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_output_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null framer->in_start, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_output_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_output_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_wakeup_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null wakeup_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null wakeup_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null wakeup_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_wakeup_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null wakeup_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if ((*((_BYTE *)v3 + 606) & 4) == 0)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_wakeup_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer->in_start", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null framer->in_start, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_wakeup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_wakeup_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_stop_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_stop_handler";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null stop_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_stop_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null stop_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_stop_handler";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null stop_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_stop_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null stop_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if ((*((_BYTE *)v3 + 606) & 4) == 0)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_stop_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_stop_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer->in_start", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_stop_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null framer->in_start, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_stop_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_stop_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_cleanup_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null cleanup_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null cleanup_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null cleanup_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_cleanup_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null cleanup_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if ((*((_BYTE *)v3 + 606) & 4) == 0)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_cleanup_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer->in_start", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null framer->in_start, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_cleanup_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_cleanup_handler";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_copy_metadata";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_copy_metadata";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null copy_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_copy_metadata";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null copy_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_copy_metadata";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null copy_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_copy_metadata";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null copy_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if ((v3[606] & 4) == 0)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_framer_set_copy_metadata";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_copy_metadata";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null framer->in_start", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_copy_metadata";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null framer->in_start, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_framer_set_copy_metadata";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_framer_set_copy_metadata";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null framer->in_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_framer_async";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null async_block", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null async_block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl(&dword_181A5C000, v9, v19, "%{public}s called with null async_block, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_framer_async";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null async_block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  uint64_t v6 = (void *)*((void *)v3 + 46);
  if (!v6)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_framer_async";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null framer->context", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null framer->context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_async";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null framer->context, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_framer_async";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null framer->context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (a2)
  {
    nw_context_assert_queue(*((void **)v5 + 46));
    os_log_type_t v7 = *((id *)v5 + 47);
    if (v7
      || (os_log_type_t v7 = (id)nw_protocol_copy_shared_connection_state( (uint64_t)v5 + 288,  *((void *)v5 + 1),  *((void **)v5 + 46),  1)) != 0LL || (v8 = nw_dictionary_create(),  v9 = (void *)*((void *)v5 + 47),  *((void *)v5 + 47) = v8,  v9,  (os_log_type_t v7 = *((id *)v5 + 47)) != 0LL))
    {
      nw_dictionary_set_value((uint64_t)v7, a2, v6);
LABEL_7:

      goto LABEL_8;
    }

    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_framer_connection_state_set_object_value";
    BOOL v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (__nwlog_fault(v17, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_framer_connection_state_set_object_value";
          _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null connection_state", buf, 0xCu);
        }
      }

      else if (v32)
      {
        char v26 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v27 = type;
        __int16 v28 = os_log_type_enabled(v18, type);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "nw_framer_connection_state_set_object_value";
            os_log_type_t v36 = 2082;
            v37 = v26;
            _os_log_impl( &dword_181A5C000,  v18,  v27,  "%{public}s called with null connection_state, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v26);
          goto LABEL_60;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_framer_connection_state_set_object_value";
          _os_log_impl( &dword_181A5C000,  v18,  v27,  "%{public}s called with null connection_state, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v31 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_framer_connection_state_set_object_value";
          _os_log_impl( &dword_181A5C000,  v18,  v31,  "%{public}s called with null connection_state, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_55;
  }

  if (!nw_protocol_options_has_standard_framer_options(v5))
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_framer_options_set_object_value";
    char v8 = (char *)_os_log_send_and_compose_impl();

    __int16 v30 = OS_LOG_TYPE_ERROR;
    uint64_t v29 = 0;
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v30;
      if (os_log_type_enabled(v9, v30))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options)",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v30;
      if (os_log_type_enabled(v9, v30))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = v30;
    BOOL v20 = os_log_type_enabled(v9, v30);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "nw_framer_options_set_object_value";
      v33 = 2082;
      uint64_t v34 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!key)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_framer_options_set_object_value";
    char v8 = (char *)_os_log_send_and_compose_impl();

    __int16 v30 = OS_LOG_TYPE_ERROR;
    uint64_t v29 = 0;
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v30;
      if (os_log_type_enabled(v9, v30))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null key", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = v30;
      if (os_log_type_enabled(v9, v30))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl(&dword_181A5C000, v9, v25, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = v30;
    BOOL v22 = os_log_type_enabled(v9, v30);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_framer_options_set_object_value";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "nw_framer_options_set_object_value";
      v33 = 2082;
      uint64_t v34 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!key)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null key", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl(&dword_181A5C000, v9, v25, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_framer_options_copy_object_value";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!nw_protocol_options_has_standard_framer_options(v3))
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options)",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v22,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v17 = type;
    uint64_t v18 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
      __int16 v30 = 2082;
      uint64_t v31 = v16;
      _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s called with null nw_protocol_options_has_standard_framer_options(options), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null peer_protocol_definition", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v23,  "%{public}s called with null peer_protocol_definition, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v19,  "%{public}s called with null peer_protocol_definition, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_framer_options_set_peer_protocol_definition";
      __int16 v30 = 2082;
      uint64_t v31 = v16;
      _os_log_impl( &dword_181A5C000,  v7,  v19,  "%{public}s called with null peer_protocol_definition, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_endpoint_set_signature";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_endpoint_set_signature";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null signature", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_endpoint_set_signature";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null signature, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_endpoint_set_signature";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_endpoint_set_signature";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null signature, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_endpoint_set_signature";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_endpoint_set_signature";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null signature_length", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v27)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_endpoint_set_signature";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null signature_length, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v30 = "nw_endpoint_set_signature";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null signature_length, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v30 = "nw_endpoint_set_signature";
      uint64_t v31 = 2082;
      uint64_t v32 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null signature_length, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_connection_access_establishment_report";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_connection_access_establishment_report";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null queue", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_connection_access_establishment_report";
        _os_log_impl( &dword_181A5C000,  v11,  v26,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_connection_access_establishment_report";
        _os_log_impl(&dword_181A5C000, v11, v21, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_connection_access_establishment_report";
      os_log_type_t v36 = 2082;
      v37 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_connection_access_establishment_report";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_connection_access_establishment_report";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null access_block", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_connection_access_establishment_report";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s called with null access_block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    os_log_type_t v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_connection_access_establishment_report";
        _os_log_impl(&dword_181A5C000, v11, v23, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_connection_access_establishment_report";
      os_log_type_t v36 = 2082;
      v37 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null access_block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

        free(v18);
        goto LABEL_55;
      }

      if (v25)
      {
        *(_DWORD *)v35 = 136446210;
        *(void *)&v35[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v24, "%{public}s called with null group, no backtrace", v35, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)v35 = 136446210;
        *(void *)&v35[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null group, backtrace limit exceeded",  v35,  0xCu);
      }
    }

    if (v22) {
      free(v22);
    }

    goto LABEL_18;
  }

  os_log_type_t v9 = v8 + 16;
  if (a4) {
    *(_OWORD *)os_log_type_t v9 = *a4;
  }
  else {
    uuid_generate_random(v9);
  }
  *((_DWORD *)a1 + 2) = a2;
  if (v7 && !nw_group_descriptor_allows_endpoint(a1, v7))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v13 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v14 = *((unsigned int *)a1 + 2);
      else {
        char v15 = off_189BB74C8[v14];
      }
      *(_DWORD *)buf = 136446466;
      v37 = "-[NWConcrete_nw_group_descriptor initWithType:member:groupID:]";
      v38 = 2080;
      v39 = (void *)v15;
      _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s Invalid endpoint type specified for group descriptor of type %s",  buf,  0x16u);
    }

LABEL_18:
    a1 = 0LL;
    goto LABEL_19;
  }

  os_log_type_t v10 = nw_array_create();
  BOOL v11 = (void *)a1[4];
  a1[4] = v10;

  if (v7) {
    nw_array_append(a1[4], v7);
  }
  os_log_type_t v12 = (void *)a1[5];
  a1[5] = 0LL;

  *((_BYTE *)a1 + 48) &= ~1u;
LABEL_19:

  return a1;
}

LABEL_55:
      if (v21) {
        free(v21);
      }
      goto LABEL_57;
    }

    if (!v35)
    {
      __nwlog_obj();
      BOOL v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v32 = __buf;
      if (os_log_type_enabled(v22, (os_log_type_t)__buf))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_instance_create_extra_path";
        _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s called with null existing_path, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v29 = __buf;
    __int16 v30 = os_log_type_enabled(v22, (os_log_type_t)__buf);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_instance_create_extra_path";
        _os_log_impl(&dword_181A5C000, v22, v29, "%{public}s called with null existing_path, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      v37 = "nw_protocol_instance_create_extra_path";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s called with null existing_path, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  uint64_t v5 = (void *)v3[15];
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_instance_async";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null instance->context", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async";
        _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s called with null instance->context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type;
    os_log_type_t v19 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null instance->context, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_protocol_instance_async";
      uint64_t v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null instance->context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_instance_async";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null block", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async";
        _os_log_impl( &dword_181A5C000,  v8,  v24,  "%{public}s called with null block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async";
        _os_log_impl(&dword_181A5C000, v8, v20, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_protocol_instance_async";
      uint64_t v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  uint64_t v5 = (void *)v3[15];
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_instance_async_if_needed";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null instance->context", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s called with null instance->context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type;
    os_log_type_t v19 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null instance->context, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_protocol_instance_async_if_needed";
      uint64_t v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null instance->context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_protocol_instance_async_if_needed";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null block", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl( &dword_181A5C000,  v8,  v24,  "%{public}s called with null block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_181A5C000, v8, v20, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_protocol_instance_async_if_needed";
      uint64_t v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null allocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null deallocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_globals_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null allocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null deallocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_context_globals_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null allocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null deallocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_instance_state_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_protocol_definition_set_options_serializer";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null serialize_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl( &dword_181A5C000,  v11,  v26,  "%{public}s called with null serialize_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null serialize_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_protocol_definition_set_options_serializer";
      uint64_t v32 = 2082;
      v33 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null serialize_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a4)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_protocol_definition_set_options_serializer";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null deserialize_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s called with null deserialize_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    os_log_type_t v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null deserialize_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_protocol_definition_set_options_serializer";
      uint64_t v32 = 2082;
      v33 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null deserialize_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null allocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null allocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null deallocate_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_metadata_allocator";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deallocate_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a3)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null initialize_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null initialize_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null initialize_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
      v33 = 2082;
      uint64_t v34 = v21;
      _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null initialize_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a4)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null finalize_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s called with null finalize_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null finalize_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "nw_protocol_definition_set_metadata_initializer";
      v33 = 2082;
      uint64_t v34 = v21;
      _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null finalize_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null serialize_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null serialize_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null serialize_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null serialize_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null deserialize_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null deserialize_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
        _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deserialize_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_metadata_serializer";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null deserialize_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null create_reply_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl( &dword_181A5C000,  v11,  v26,  "%{public}s called with null create_reply_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null create_reply_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
      uint64_t v32 = 2082;
      v33 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null create_reply_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null copy_original_function", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s called with null copy_original_function, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    os_log_type_t v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null copy_original_function, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_protocol_definition_set_metadata_copy_reply";
      uint64_t v32 = 2082;
      v33 = v20;
      _os_log_impl( &dword_181A5C000,  v11,  v23,  "%{public}s called with null copy_original_function, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  char v8 = 1LL;
LABEL_5:

  return v8;
}

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_inbound_events";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null inbound_starting", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null inbound_starting, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_181A5C000, v9, v19, "%{public}s called with null inbound_starting, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_inbound_events";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null inbound_starting, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_protocol_definition_set_inbound_events";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null inbound_stopping", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null inbound_stopping, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null inbound_stopping, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_definition_set_inbound_events";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null inbound_stopping, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
    goto LABEL_55;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    id v3 = *((_WORD *)handle + 531);
    if ((v3 & 0x41) != 0x40) {
      return;
    }
    *((_WORD *)handle + 531) = v3 & 0xFFBF;
    if ((handle[198] & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *((_DWORD *)handle + 263);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_reissue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 114;
        *(_WORD *)&buf[22] = 2080;
        v37 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v38) = 1024;
        *(_DWORD *)((char *)&v38 + 2) = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%sreissuing authenticated request, challenge count %u",  buf,  0x26u);
      }
    }

    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3802000000LL;
    v37 = __Block_byref_object_copy__97;
    v38 = __Block_byref_object_dispose__98;
    parameters = (void *)nw_protocol_get_parameters((uint64_t)handle);
    if (parameters) {
      parameters = os_retain(parameters);
    }
    v39 = parameters;
    v40 |= 1u;
    os_log_type_t v7 = 1048LL;
    if ((*((_WORD *)handle + 531) & 0x10) == 0) {
      os_log_type_t v7 = 1044LL;
    }
    char v8 = *(_DWORD *)&handle[v7];
    if ((v8 & 0xFFFFFFFE) != 4 || *((int *)handle + 260) < 4)
    {
      nw_http_messaging_options_create_transaction_in_parameters( *(void **)(*(void *)&buf[8] + 40LL),  (uint64_t)handle,  2);
      os_log_type_t v12 = (void *)*((void *)handle + 104);
      BOOL v13 = handle[1060];
      v31[5] = handle;
      v32[0] = MEMORY[0x1895F87A8];
      v32[1] = 0x40000000LL;
      v32[2] = ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_2;
      v32[3] = &__block_descriptor_tmp_101;
      v32[4] = handle;
      v30[4] = handle;
      v31[0] = MEMORY[0x1895F87A8];
      v31[1] = 0x40000000LL;
      v31[2] = ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_3;
      v31[3] = &unk_189BB7E90;
      v31[4] = buf;
      v30[0] = MEMORY[0x1895F87A8];
      v30[1] = 0x40000000LL;
      v30[2] = ___ZL30nw_http_authentication_reissueP11nw_protocol_block_invoke_5;
      v30[3] = &__block_descriptor_tmp_106;
      nw_protocol_plugin_retry_reissue_output_frames( (uint64_t)(handle + 344),  (uint64_t)a1,  v12,  0LL,  0LL,  v13,  1,  v32,  v31,  (uint64_t)v30);
      goto LABEL_17;
    }

    if (CFDictionaryGetCount(*((CFDictionaryRef *)handle + 92)))
    {
LABEL_24:
      os_log_type_t v14 = *((void *)handle + 76);
      if (v14) {
        goto LABEL_25;
      }
      goto LABEL_26;
    }

    os_log_type_t v9 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_authentication_credential_cache_entry);
    os_log_type_t v10 = v9;
    if ((*((_WORD *)handle + 531) & 0x10) != 0)
    {
      nw_authentication_credential_cache_entry_set_http_authentication(v9, *((const void **)handle + 108));
      BOOL v11 = (void **)(handle + 672);
    }

    else
    {
      nw_authentication_credential_cache_entry_set_http_authentication(v9, *((const void **)handle + 106));
      BOOL v11 = (void **)(handle + 656);
    }

    nw_authentication_credential_cache_entry_set_credential((uint64_t)v10, *v11);
    nw_authentication_credential_cache_entry_set_for_proxy((uint64_t)v10, (*((_WORD *)handle + 531) & 0x10) != 0);
    if (v10)
    {
      v10->os_log_type_t type = v8;
      nw_array_append(*((void *)handle + 90), v10);
      os_release(v10);
      goto LABEL_24;
    }

    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)BOOL v41 = 136446210;
    v42 = "nw_authentication_credential_cache_entry_set_type";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

    v35 = OS_LOG_TYPE_ERROR;
    uint64_t v34 = 0;
    if (__nwlog_fault(v24, &v35, &v34))
    {
      if (v35 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v26 = v35;
        if (os_log_type_enabled(v25, v35))
        {
          *(_DWORD *)BOOL v41 = 136446210;
          v42 = "nw_authentication_credential_cache_entry_set_type";
          __int16 v27 = "%{public}s called with null cache_entry";
LABEL_70:
          _os_log_impl(&dword_181A5C000, v25, v26, v27, v41, 0xCu);
          goto LABEL_71;
        }

        goto LABEL_71;
      }

      if (!v34)
      {
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v26 = v35;
        if (os_log_type_enabled(v25, v35))
        {
          *(_DWORD *)BOOL v41 = 136446210;
          v42 = "nw_authentication_credential_cache_entry_set_type";
          __int16 v27 = "%{public}s called with null cache_entry, backtrace limit exceeded";
          goto LABEL_70;
        }

    if (v23) {
      free(v23);
    }
    goto LABEL_16;
  }

  __nwlog_obj();
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "nw_flow_replay_updated_path";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v19, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_flow_replay_updated_path";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v37)
    {
      char v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      __int16 v28 = os_log_type_enabled(v20, type);
      if (v26)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "nw_flow_replay_updated_path";
          BOOL v41 = 2082;
          v42 = v26;
          _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v26);
        goto LABEL_48;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_flow_replay_updated_path";
        _os_log_impl(&dword_181A5C000, v20, v27, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v32 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_flow_replay_updated_path";
        _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v21) {
      free(v21);
    }
    goto LABEL_16;
  }

  __nwlog_obj();
  os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v36 = "nw_flow_replay_connect";
  BOOL v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v17, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_flow_replay_connect";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v33)
    {
      os_log_type_t v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      char v26 = os_log_type_enabled(v18, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v36 = "nw_flow_replay_connect";
          v37 = 2082;
          v38 = v24;
          _os_log_impl( &dword_181A5C000,  v18,  v25,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v24);
        goto LABEL_48;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_flow_replay_connect";
        _os_log_impl(&dword_181A5C000, v18, v25, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v30 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_flow_replay_connect";
        _os_log_impl( &dword_181A5C000,  v18,  v30,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v27) {
      free(v27);
    }
    goto LABEL_16;
  }

  __nwlog_obj();
  BOOL v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v43 = "nw_flow_replay_register_notification";
  os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v40 = 0;
  if (__nwlog_fault(v23, &type, &v40))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v43 = "nw_flow_replay_register_notification";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v40)
    {
      __int16 v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v31 = type;
      uint64_t v32 = os_log_type_enabled(v24, type);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v43 = "nw_flow_replay_register_notification";
          BOOL v44 = 2082;
          v45 = v30;
          _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
        goto LABEL_48;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v43 = "nw_flow_replay_register_notification";
        _os_log_impl(&dword_181A5C000, v24, v31, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v43 = "nw_flow_replay_register_notification";
        _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v23) {
      free(v23);
    }
    goto LABEL_16;
  }

  __nwlog_obj();
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v39 = "nw_flow_replay_unregister_notification";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v36 = 0;
  if (__nwlog_fault(v19, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_flow_replay_unregister_notification";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v36)
    {
      char v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      __int16 v28 = os_log_type_enabled(v20, type);
      if (v26)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "nw_flow_replay_unregister_notification";
          os_log_type_t v40 = 2082;
          BOOL v41 = v26;
          _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v26);
        goto LABEL_48;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_flow_replay_unregister_notification";
        _os_log_impl(&dword_181A5C000, v20, v27, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v32 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_flow_replay_unregister_notification";
        _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null demux_options", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v33)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null demux_options, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
        _os_log_impl(&dword_181A5C000, v12, v22, "%{public}s called with null demux_options, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
      v37 = 2082;
      v38 = v21;
      _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null demux_options, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null inbound_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v33)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s called with null inbound_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null inbound_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_listener_register_client_demux_options_if_needed";
      v37 = 2082;
      v38 = v21;
      _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null inbound_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

        free(v14);
        goto LABEL_55;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      uint64_t v58 = "nw_parameters_create_quic";
      os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (__nwlog_fault(v10, &type, &v55))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v11 = (os_log_s *)(id)gLogObj;
          os_log_type_t v12 = type;
          if (os_log_type_enabled(v11, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v58 = "nw_parameters_create_quic";
            _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s nw_parameters_create failed", buf, 0xCu);
          }
        }

        else if (v55)
        {
          BOOL v17 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v11 = (os_log_s *)(id)gLogObj;
          uint64_t v18 = type;
          os_log_type_t v19 = os_log_type_enabled(v11, type);
          if (v17)
          {
            if (v19)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v58 = "nw_parameters_create_quic";
              v59 = 2082;
              v60 = v17;
              _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v17);
            if (!v10) {
              goto LABEL_46;
            }
            goto LABEL_45;
          }

          if (v19)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v58 = "nw_parameters_create_quic";
            _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v11 = (os_log_s *)(id)gLogObj;
          os_log_type_t v24 = type;
          if (os_log_type_enabled(v11, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v58 = "nw_parameters_create_quic";
            _os_log_impl( &dword_181A5C000,  v11,  v24,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v10)
      {
LABEL_46:
        uint64_t v4 = 0LL;
LABEL_57:

        goto LABEL_58;
      }

  if (v6) {
    free(v6);
  }
  quic = 0LL;
LABEL_5:

  return quic;
}

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null cipher_suites", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
        _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s called with null cipher_suites, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type;
    os_log_type_t v19 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
        _os_log_impl(&dword_181A5C000, v8, v18, "%{public}s called with null cipher_suites, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
      uint64_t v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null cipher_suites, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null count", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
        _os_log_impl( &dword_181A5C000,  v8,  v24,  "%{public}s called with null count, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
        _os_log_impl(&dword_181A5C000, v8, v20, "%{public}s called with null count, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_parameters_get_ssl_cipher_suites";
      uint64_t v29 = 2082;
      __int16 v30 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null count, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_parameters_update_with_data";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_update_with_data";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null data", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_update_with_data";
        _os_log_impl(&dword_181A5C000, v9, v24, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_update_with_data";
        _os_log_impl(&dword_181A5C000, v9, v19, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_parameters_update_with_data";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_parameters_update_with_data";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_update_with_data";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null data_len", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_update_with_data";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null data_len, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_update_with_data";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null data_len, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_parameters_update_with_data";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null data_len, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    __break(1u);
  }

  __break(1u);
  return result;
}

    if (v18) {
      free(v18);
    }
    goto LABEL_62;
  }

  if (!v9)
  {
    __nwlog_obj();
    os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
    BOOL v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (__nwlog_fault(v22, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s called with null protocol_definition", buf, 0xCu);
        }
      }

      else if (v43)
      {
        uint64_t v31 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v32 = type;
        v33 = os_log_type_enabled(v23, type);
        if (v31)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
            os_log_type_t v53 = 2082;
            uint64_t v54 = v31;
            _os_log_impl( &dword_181A5C000,  v23,  v32,  "%{public}s called with null protocol_definition, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v31);
          goto LABEL_60;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl( &dword_181A5C000,  v23,  v32,  "%{public}s called with null protocol_definition, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl( &dword_181A5C000,  v23,  v36,  "%{public}s called with null protocol_definition, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    domain_for_policy = 0LL;
    goto LABEL_55;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v16 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v5;
    os_log_type_t v62 = 2082;
    v63 = a2;
    _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %{public}@ indeed matches pattern %{public}s",  buf,  0x20u);
  }

  domain_for_policy = 1LL;
LABEL_56:

  return domain_for_policy;
}

    goto LABEL_55;
  }

  id v3 = *(void **)(*((void *)v1 + 2) + 48LL);
  if (!v3)
  {
    __nwlog_obj();
    char v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_listener_pair_read_inner";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null pair->mlp_parent->mc_in_connection",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v21,  "%{public}s called with null pair->mlp_parent->mc_in_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mlp_parent->mc_in_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_listener_pair_read_inner";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mlp_parent->mc_in_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!*((void *)v1 + 3))
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_listener_pair_read_inner";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null pair->mlp_outer_connection_group",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v22,  "%{public}s called with null pair->mlp_outer_connection_group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type;
    os_log_type_t v19 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_listener_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mlp_outer_connection_group, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_listener_pair_read_inner";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mlp_outer_connection_group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    uint64_t v29 = OS_LOG_TYPE_ERROR;
    __int16 v28 = 0;
    if (v29 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = v29;
      if (os_log_type_enabled(v8, v29))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null direct_receive_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = v29;
      if (os_log_type_enabled(v8, v29))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s called with null direct_receive_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = v29;
    os_log_type_t v19 = os_log_type_enabled(v8, v29);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null direct_receive_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
      uint64_t v32 = 2082;
      v33 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null direct_receive_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!*((void *)v3 + 6))
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    uint64_t v29 = OS_LOG_TYPE_ERROR;
    __int16 v28 = 0;
    if (v29 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = v29;
      if (os_log_type_enabled(v8, v29))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null pair->mcp_outer_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v29;
      if (os_log_type_enabled(v8, v29))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v8,  v24,  "%{public}s called with null pair->mcp_outer_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    BOOL v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = v29;
    os_log_type_t v21 = os_log_type_enabled(v8, v29);
    if (!v17)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null pair->mcp_outer_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_masque_connection_pair_read_inner_direct";
      uint64_t v32 = 2082;
      v33 = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null pair->mcp_outer_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    os_log_type_t v43 = v46;
    v47 = v46 >= v37;
    v45 = v71;
  }

  while (!v47);
  v59 = endpoint;
  v60 = v71;
  char v61 = nw_endpoint_copy_address_string(endpoint);
  nw_dictionary_set_value(*(void *)(*(void *)(v72 + 32) + 40LL), v61, options);
  if (v61) {
    free(v61);
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
    {
      v68 = *(void *)(*(void *)(v72 + 32) + 16LL);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_listener_pair_read_inner_block_invoke";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v68;
      *(_WORD *)&buf[22] = 2112;
      v92 = (uint64_t)endpoint;
      _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ received listener demux pattern for %@",  buf,  0x20u);
    }

    v60 = v71;
    v59 = endpoint;
  }

  nw_masque_listener_pair_setup_inner_direct_connections(*(void **)(v72 + 32), options, v59);
  os_log_type_t v62 = nw_content_context_create("listener ack pattern");
  metadata_for_capsule = nw_http_create_metadata_for_capsule(16770307LL, v60);
  nw_content_context_set_metadata_for_protocol(v62, (nw_protocol_metadata_t)metadata_for_capsule);
  nw_connection_send( *(nw_connection_t *)(*(void *)(*(void *)(v72 + 32) + 16LL) + 48LL),  0LL,  v62,  1,  &__block_literal_global_24170);

LABEL_82:
  v38 = endpoint;
LABEL_83:

LABEL_84:
LABEL_85:
  nw_masque_listener_pair_read_inner(*(NWConcrete_nw_masque_listener_pair **)(v72 + 32));

LABEL_86:
LABEL_87:
}

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null inner_direct_receive_connection",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null inner_direct_receive_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null inner_direct_receive_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
      v35 = 2082;
      os_log_type_t v36 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null inner_direct_receive_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v5[3])
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null pair->mlp_outer_connection_group",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null pair->mlp_outer_connection_group, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null pair->mlp_outer_connection_group, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v34 = "nw_masque_listener_pair_read_inner_direct";
      v35 = 2082;
      os_log_type_t v36 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null pair->mlp_outer_connection_group, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!*(void *)(*((void *)v1 + 2) + 48LL))
  {
    __nwlog_obj();
    char v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null pair->mcp_parent->mc_in_connection",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl( &dword_181A5C000,  v6,  v21,  "%{public}s called with null pair->mcp_parent->mc_in_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mcp_parent->mc_in_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mcp_parent->mc_in_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  id v3 = (void *)*((void *)v1 + 6);
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl(&dword_181A5C000, v6, v11, "%{public}s called with null pair->mcp_outer_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl( &dword_181A5C000,  v6,  v22,  "%{public}s called with null pair->mcp_outer_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type;
    os_log_type_t v19 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
        _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mcp_outer_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_connection_pair_read_outer_datagrams";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mcp_outer_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!*(void *)(*((void *)v1 + 2) + 48LL))
  {
    __nwlog_obj();
    char v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_connection_pair_read_outer";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null pair->mcp_parent->mc_in_connection",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl( &dword_181A5C000,  v6,  v21,  "%{public}s called with null pair->mcp_parent->mc_in_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mcp_parent->mc_in_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_connection_pair_read_outer";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mcp_parent->mc_in_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  id v3 = (void *)*((void *)v1 + 6);
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_connection_pair_read_outer";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl(&dword_181A5C000, v6, v11, "%{public}s called with null pair->mcp_outer_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl( &dword_181A5C000,  v6,  v22,  "%{public}s called with null pair->mcp_outer_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type;
    os_log_type_t v19 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_outer";
        _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mcp_outer_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_connection_pair_read_outer";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mcp_outer_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  id v3 = *(void **)(*((void *)v1 + 2) + 48LL);
  if (!v3)
  {
    __nwlog_obj();
    char v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_connection_pair_read_inner";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null pair->mcp_parent->mc_in_connection",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v21,  "%{public}s called with null pair->mcp_parent->mc_in_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mcp_parent->mc_in_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_connection_pair_read_inner";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null pair->mcp_parent->mc_in_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!*((void *)v1 + 6))
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v28 = "nw_masque_connection_pair_read_inner";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl(&dword_181A5C000, v6, v11, "%{public}s called with null pair->mcp_outer_connection", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v25)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v22,  "%{public}s called with null pair->mcp_outer_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    char v15 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = type;
    os_log_type_t v19 = os_log_type_enabled(v6, type);
    if (!v15)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v28 = "nw_masque_connection_pair_read_inner";
        _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mcp_outer_connection, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v28 = "nw_masque_connection_pair_read_inner";
      uint64_t v29 = 2082;
      __int16 v30 = v15;
      _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s called with null pair->mcp_outer_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

          BOOL v20 = 0LL;
          char v8 = log;
          goto LABEL_100;
        }

  if (v20) {
    free(v20);
  }
  return 0LL;
}

      if (v13) {
        free(v13);
      }
      return 0LL;
    }

    if (!v32)
    {
      os_log_type_t v14 = (os_log_s *)__nwlog_obj();
      char v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        os_log_type_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    char v15 = type;
    os_log_type_t v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        os_log_type_t v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
      os_log_type_t v36 = 2082;
      v37 = backtrace_string;
      BOOL v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_41:
      _os_log_impl(&dword_181A5C000, v14, v15, v22, buf, 0x16u);
    }

  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(*(CFHTTPMessageRef *)(*(void *)(a1 + 32) + 200LL));
  uint64_t v32 = ResponseStatusCode;
  v33 = *(void *)(a1 + 32);
  if ((*(_WORD *)(v33 + 368) & 2) == 0) {
    goto LABEL_154;
  }
  uint64_t v34 = *(_DWORD *)(v33 + 264);
  if (!v34) {
    goto LABEL_154;
  }
  if (ResponseStatusCode != 200)
  {
    has_internal_diagnostics = os_variant_has_internal_diagnostics();
    os_log_type_t v43 = *(void *)(a1 + 32);
    if (!has_internal_diagnostics)
    {
      if (v43 && (*(_WORD *)(v43 + 368) & 0x80) != 0) {
        goto LABEL_154;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v99 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_154;
      }
      v100 = *(void *)(a1 + 32);
      v101 = (const char *)(v100 + 284);
      v102 = "";
      v103 = v100 == 0;
      v104 = *(_DWORD *)(v100 + 264);
      if (v103) {
        v101 = "";
      }
      v168 = "nw_http_connect_process_inbound_data_block_invoke";
      v169 = 2082;
      *(_DWORD *)buf = 136446978;
      if (!v103) {
        v102 = " ";
      }
      v170 = (void *)v101;
      v171 = 2080;
      v172 = v102;
      v173 = 1024;
      *(_DWORD *)v174 = v104;
      uint64_t v57 = "%{public}s %{public}s%s%d bytes of unexpected response data from server";
      uint64_t v58 = (os_log_s *)v99;
      v59 = 38;
      goto LABEL_153;
    }

    if (!v43 || (*(_WORD *)(v43 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v44 = (os_log_s *)gLogObj;
      v45 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      v46 = *(void *)(a1 + 32);
      if (v45)
      {
        v47 = *(_DWORD *)(v46 + 264);
        v48 = v46 == 0;
        if (v46) {
          v49 = (const char *)(v46 + 284);
        }
        else {
          v49 = "";
        }
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_process_inbound_data_block_invoke";
        v169 = 2082;
        v170 = (void *)v49;
        if (v48) {
          v50 = "";
        }
        else {
          v50 = " ";
        }
        v171 = 2080;
        v172 = v50;
        v173 = 1024;
        *(_DWORD *)v174 = v47;
        _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%d bytes of unexpected data from server:",  buf,  0x26u);
        v46 = *(void *)(a1 + 32);
      }

      if (!v46 || (*(_WORD *)(v46 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v51 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v52 = *(void *)(a1 + 32);
          os_log_type_t v53 = (const char *)(v52 + 284);
          uint64_t v54 = "";
          v55 = v52 == 0;
          v56 = *(_DWORD *)(v52 + 264);
          v168 = "nw_http_connect_process_inbound_data_block_invoke";
          if (v55) {
            os_log_type_t v53 = "";
          }
          v169 = 2082;
          *(_DWORD *)buf = 136447234;
          if (!v55) {
            uint64_t v54 = " ";
          }
          v170 = (void *)v53;
          v171 = 2080;
          v172 = v54;
          v173 = 1040;
          *(_DWORD *)v174 = v56;
          *(_WORD *)&v174[4] = 2096;
          *(void *)&v174[6] = &v7[v2 - v56];
          uint64_t v57 = "%{public}s %{public}s%s%{network:data}.*P";
          uint64_t v58 = (os_log_s *)v51;
          v59 = 48;
LABEL_153:
          _os_log_impl(&dword_181A5C000, v58, OS_LOG_TYPE_ERROR, v57, buf, v59);
        }
      }
    }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v21 = (os_log_s *)gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_57;
      }
      v42 = *v4;
      *(_DWORD *)buf = 136446722;
      v63 = "nw_http2_transport_stream_close";
      char v64 = 2082;
      v65 = (void *)(a1 + 205);
      v66 = 1024;
      v67 = v42;
      os_log_type_t v23 = "%{public}s %{public}s did not remove stream %d from id table";
      goto LABEL_56;
    }

    *(_BYTE *)(a2 + 36) = v5 & 0xFE;
    if (gLogDatapath)
    {
      v59 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v63 = "nw_http2_transport_stream_send_rst_stream";
        char v64 = 2082;
        v65 = (void *)(a1 + 205);
        _os_log_impl(&dword_181A5C000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }

    if (*v4 == -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v16 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      BOOL v17 = *v4;
      *(_DWORD *)buf = 136446722;
      v63 = "nw_http2_transport_stream_send_rst_stream";
      char v64 = 2082;
      v65 = (void *)(a1 + 205);
      v66 = 1024;
      v67 = v17;
      os_log_type_t v12 = "%{public}s %{public}s cannot send RST_STREAM for stream with invalid stream id %d";
      BOOL v13 = (os_log_s *)v16;
      os_log_type_t v14 = OS_LOG_TYPE_ERROR;
    }

    else
    {
      char v8 = nghttp2_submit_rst_stream();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = gLogObj;
      if (v8)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v10 = *v4;
          BOOL v11 = nghttp2_strerror();
          *(_DWORD *)buf = 136446978;
          v63 = "nw_http2_transport_stream_send_rst_stream";
          char v64 = 2082;
          v65 = (void *)(a1 + 205);
          v66 = 1024;
          v67 = v10;
          v68 = 2082;
          uint64_t v69 = v11;
          os_log_type_t v12 = "%{public}s %{public}s Failed to submit RST_STREAM on stream %d: %{public}s";
          BOOL v13 = (os_log_s *)v9;
          os_log_type_t v14 = OS_LOG_TYPE_ERROR;
          char v15 = 38;
LABEL_24:
          _os_log_impl(&dword_181A5C000, v13, v14, v12, buf, v15);
        }

  if (v37) {
    free(v37);
  }
LABEL_56:
  if (*((_BYTE *)v2 + 1537))
  {
    BOOL v44 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v60 = 136446466;
      *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(void *)&v60[14] = a1 + 205;
      _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s about to allow http2_transport to send pending data",  v60,  0x16u);
    }
  }

  nw_http2_transport_session_send(a1);
}

      goto LABEL_55;
    }

    if (!v28)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        BOOL v17 = "%{public}s called with null hex_string, backtrace limit exceeded";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    os_log_type_t v25 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        BOOL v17 = "%{public}s called with null hex_string, no backtrace";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_utilities_convert_hex_string_to_bytes";
      uint64_t v32 = 2082;
      v33 = (uint64_t)backtrace_string;
      char v26 = "%{public}s called with null hex_string, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_181A5C000, v15, v16, v26, buf, 0x16u);
    }
}

  if (v10) {
    free(v10);
  }
  os_log_type_t v7 = 0LL;
LABEL_5:

  return v7;
}

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_ws_options_set_client_request_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null client_queue", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v30)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v25,  "%{public}s called with null client_queue, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    os_log_type_t v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_ws_options_set_client_request_handler";
      uint64_t v34 = 2082;
      v35 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null client_queue, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_ws_options_set_client_request_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v30)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v26,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v19 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_181A5C000, v10, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_ws_options_set_client_request_handler";
      uint64_t v34 = 2082;
      v35 = v19;
      _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null client_queue", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v33)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null client_queue, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
      v37 = 2082;
      v38 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null client_queue, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null pong_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v33)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null pong_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = type;
    __int16 v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_181A5C000, v14, v26, "%{public}s called with null pong_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_ws_metadata_set_pong_handler";
      v37 = 2082;
      v38 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null pong_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    BOOL v13 = v16;
    os_log_type_t v14 = v17;
    char v15 = 12;
    goto LABEL_24;
  }

  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_array_set_object_at_index";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      BOOL v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null object";
      goto LABEL_54;
    }

    if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      BOOL v17 = type;
      os_log_type_t v21 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (!v21) {
          goto LABEL_44;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v25 = "nw_array_set_object_at_index";
        char v26 = 2082;
        __int16 v27 = backtrace_string;
        BOOL v20 = "%{public}s called with null object, dumping backtrace:%{public}s";
LABEL_43:
        _os_log_impl(&dword_181A5C000, v16, v17, v20, buf, 0x16u);
LABEL_44:
        free(backtrace_string);
        if (v4) {
          goto LABEL_5;
        }
        return;
      }

      if (!v21) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null object, no backtrace";
    }

    else
    {
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      BOOL v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null object, backtrace limit exceeded";
    }

    goto LABEL_54;
  }

  if (!atomic_load((unsigned __int8 *)(a1 + 40)))
  {
    uint64_t v6 = (void **)(*(void *)(a1 + 16) + 8LL * (void)a3);
    if ((unint64_t)v6 < *(void *)(a1 + 24))
    {
      os_log_type_t v7 = os_retain(object);
      if (*v6) {
        os_release(*v6);
      }
      *uint64_t v6 = v7;
      return;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v25 = "nw_array_set_object_at_index";
    char v26 = 2048;
    __int16 v27 = a3;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_array_set_object_at_index";
      char v26 = 2048;
      __int16 v27 = a3;
      os_log_type_t v10 = "%{public}s array index out of range: %lu";
LABEL_23:
      BOOL v13 = v8;
      os_log_type_t v14 = v9;
      char v15 = 22;
LABEL_24:
      _os_log_impl(&dword_181A5C000, v13, v14, v10, buf, v15);
      goto LABEL_25;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = (os_log_s *)gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_array_set_object_at_index";
      char v26 = 2048;
      __int16 v27 = a3;
      os_log_type_t v10 = "%{public}s array index out of range: %lu, backtrace limit exceeded";
      goto LABEL_23;
    }

    BOOL v11 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = (os_log_s *)gLogObj;
    os_log_type_t v9 = type;
    os_log_type_t v12 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v11)
    {
      if (!v12) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_array_set_object_at_index";
      char v26 = 2048;
      __int16 v27 = a3;
      os_log_type_t v10 = "%{public}s array index out of range: %lu, no backtrace";
      goto LABEL_23;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v25 = "nw_array_set_object_at_index";
      char v26 = 2048;
      __int16 v27 = a3;
      __int16 v28 = 2082;
      uint64_t v29 = v11;
      _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s array index out of range: %lu, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v11);
LABEL_25:
    if (v4) {
      goto LABEL_5;
    }
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v25 = "nw_array_set_object_at_index";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v4))
  {
LABEL_5:
    free(v4);
    return;
  }

  __break(1u);
}

    free(v28);
    goto LABEL_55;
  }

  __nwlog_obj();
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v46 = "nw_read_request_create_multiple";
  BOOL v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v43 = 0;
  if (__nwlog_fault(v13, &type, &v43))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "nw_read_request_create_multiple";
        _os_log_impl(&dword_181A5C000, v14, v38, "%{public}s called with null completion", buf, 0xCu);
      }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_resolver_config_add_server_address";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null server_address", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_resolver_config_add_server_address";
        _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null server_address, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A5C000, v12, v22, "%{public}s called with null server_address, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "nw_resolver_config_add_server_address";
      v33 = 2082;
      uint64_t v34 = v21;
      _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null server_address, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  uint64_t v6 = v4;
  os_log_type_t v7 = -[nw_endpoint type](v6, "type");

  if (v7 != 1)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_resolver_config_add_server_address";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_resolver_config_add_server_address";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address)",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v29)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_resolver_config_add_server_address";
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_resolver_config_add_server_address";
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address), no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "nw_resolver_config_add_server_address";
      v33 = 2082;
      uint64_t v34 = v21;
      _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null (nw_endpoint_get_type(server_address) == nw_endpoint_type_address), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    uint64_t v32 = *(void **)&v81[16];
    if (!*(_DWORD *)&v81[24])
    {
      if (!*(void *)&v81[16]) {
        goto LABEL_86;
      }
      goto LABEL_85;
    }

    __nwlog_obj();
    v33 = **(_BYTE **)&v81[16];
    *(_DWORD *)buf = 136446722;
    v77 = "copyconninfo";
    v78 = 1024;
    *(_DWORD *)v79 = v33;
    *(_WORD *)&v79[4] = 1024;
    *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
    uint64_t v34 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v74 = 0;
    if (__nwlog_fault(v34, &type, &v74))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = (os_log_s *)__nwlog_obj();
        os_log_type_t v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_138;
        }
        v37 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v37;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        v38 = "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed";
LABEL_137:
        _os_log_impl(&dword_181A5C000, v35, v36, v38, buf, 0x18u);
        goto LABEL_138;
      }

      if (!v74)
      {
        v35 = (os_log_s *)__nwlog_obj();
        os_log_type_t v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_138;
        }
        char v61 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v61;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        v38 = "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed, backtrace limit exceeded";
        goto LABEL_137;
      }

      v55 = (char *)__nw_create_backtrace_string();
      v35 = (os_log_s *)__nwlog_obj();
      os_log_type_t v36 = type;
      v56 = os_log_type_enabled(v35, type);
      if (!v55)
      {
        if (!v56) {
          goto LABEL_138;
        }
        v63 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v63;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        v38 = "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed, no backtrace";
        goto LABEL_137;
      }

      if (v56)
      {
        uint64_t v57 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446978;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v57;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        LOWORD(v80[0]) = 2082;
        *(void *)((char *)v80 + 2) = v55;
        _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed, dumping backtrace:%{public}s",  buf,  0x22u);
      }

      free(v55);
    }

      if (v13) {
        free(v13);
      }
      goto LABEL_9;
    }

    __nwlog_obj();
    char v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v37 = 136446210;
    *(void *)&v37[4] = "nw_activity_set_global_parent";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v11 = buf[0];
      if (os_log_type_enabled(v10, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v37 = 136446210;
        *(void *)&v37[4] = "nw_activity_set_global_parent";
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion",  v37,  0xCu);
      }
    }

    else if (type)
    {
      os_log_type_t v16 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = buf[0];
      uint64_t v18 = os_log_type_enabled(v10, (os_log_type_t)buf[0]);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)v37 = 136446466;
          *(void *)&v37[4] = "nw_activity_set_global_parent";
          *(_WORD *)&v37[12] = 2082;
          *(void *)&v37[14] = v16;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s",  v37,  0x16u);
        }

        free(v16);
        goto LABEL_49;
      }

      if (v18)
      {
        *(_DWORD *)v37 = 136446210;
        *(void *)&v37[4] = "nw_activity_set_global_parent";
        _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace",  v37,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = buf[0];
      if (os_log_type_enabled(v10, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v37 = 136446210;
        *(void *)&v37[4] = "nw_activity_set_global_parent";
        _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded",  v37,  0xCu);
      }
    }

LABEL_49:
    if (v9) {
      free(v9);
    }
    goto LABEL_19;
  }

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  uint64_t v6 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v37 = 138543362;
    *(void *)&v37[4] = global_parent;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "Unsetting the global parent activity %{public}@",  v37,  0xCu);
  }

  __int16 v30 = &__block_literal_global_56;
  nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>( (os_unfair_lock_s *)&global_parent_lock,  (uint64_t)&v30);

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  os_log_type_t v7 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v37 = 0;
    _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEFAULT, "Unset the global parent activity", v37, 2u);
  }

LABEL_19:
}

    goto LABEL_55;
  }

  if ((*((_BYTE *)v3 + 140) & 4) != 0)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_activity_set_investigation_identifier";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v24)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v22,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v17 = type;
    uint64_t v18 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v27 = "nw_activity_set_investigation_identifier";
      __int16 v28 = 2082;
      uint64_t v29 = v16;
      _os_log_impl( &dword_181A5C000,  v7,  v17,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if ((*((_BYTE *)v3 + 140) & 8) != 0)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_activity_set_investigation_identifier";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (!v24)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v23,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v19,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v27 = "nw_activity_set_investigation_identifier";
      __int16 v28 = 2082;
      uint64_t v29 = v16;
      _os_log_impl( &dword_181A5C000,  v7,  v19,  "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_5:

  return v3;
}

          os_log_type_t v9 = v125;
          if (!v47) {
            goto LABEL_94;
          }
          goto LABEL_95;
        default:
          goto LABEL_94;
      }

      goto LABEL_73;
    }

        PBReaderRecallMark();
        goto LABEL_4;
      }

      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_5:
      uint64_t v5 = *v4;
      uint64_t v6 = *(void *)((char *)a3 + v5);
      char v8 = *(void *)((char *)a3 + *v7);
      if (v6 >= v8) {
        return *((_BYTE *)a3 + *v9) == 0;
      }
    }

    os_log_type_t v16 = 0LL;
LABEL_39:
    *os_log_type_t v14 = 1;
    goto LABEL_40;
  }

  return *((_BYTE *)a3 + *v9) == 0;
}

    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_socket_replace_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v31 = 0;
    if (__nwlog_fault(v9, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_socket_replace_input_handler";
          os_log_type_t v12 = "%{public}s called with null socket_handler";
          goto LABEL_53;
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = type;
        __int16 v30 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (!v30) {
            goto LABEL_35;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v34 = "nw_socket_replace_input_handler";
          v35 = 2082;
          os_log_type_t v36 = backtrace_string;
          char v15 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
          goto LABEL_34;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_socket_replace_input_handler";
          os_log_type_t v12 = "%{public}s called with null socket_handler, no backtrace";
          goto LABEL_53;
        }
      }

      else
      {
        os_log_type_t v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v34 = "nw_socket_replace_input_handler";
          os_log_type_t v12 = "%{public}s called with null socket_handler, backtrace limit exceeded";
          goto LABEL_53;
        }
      }
    }

    goto LABEL_54;
  }

  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_socket_replace_input_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v31 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v31)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)gLogObj;
        BOOL v11 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_54;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_socket_replace_input_handler";
        os_log_type_t v12 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
        goto LABEL_53;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)gLogObj;
      BOOL v11 = type;
      os_log_type_t v14 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!backtrace_string)
      {
        if (!v14) {
          goto LABEL_54;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_socket_replace_input_handler";
        os_log_type_t v12 = "%{public}s called with null old_input_handler, no backtrace";
        goto LABEL_53;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v34 = "nw_socket_replace_input_handler";
        v35 = 2082;
        os_log_type_t v36 = backtrace_string;
        char v15 = "%{public}s called with null old_input_handler, dumping backtrace:%{public}s";
LABEL_34:
        _os_log_impl(&dword_181A5C000, v10, v11, v15, buf, 0x16u);
      }

    goto LABEL_55;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null next_hop_host", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null next_hop_host, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A5C000, v9, v19, "%{public}s called with null next_hop_host, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null next_hop_host, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  uint64_t v6 = (void *)v3[5];
  if (!v6)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null hop->options", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v26)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl( &dword_181A5C000,  v9,  v25,  "%{public}s called with null hop->options, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
        _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s called with null hop->options, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_proxy_hop_add_next_hop_host";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null hop->options, dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_55:
      if (v10) {
        free(v10);
      }
      goto LABEL_57;
    }

    if (!v28)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl( &dword_181A5C000,  v11,  v26,  "%{public}s called with null signature_len, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_path_get_ipv6_network_signature";
        _os_log_impl(&dword_181A5C000, v11, v22, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v31 = "nw_path_get_ipv6_network_signature";
      uint64_t v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s called with null signature_len, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v21);
    _Block_object_dispose(v100, 8);
    _Block_object_dispose(&v102, 8);
    _Block_object_dispose(&v106, 8);

    if (v24)
    {
      BOOL v41 = necp_client_action();
      v33 = v41 == 0;
      os_log_type_t v9 = v92;
      if (!v41)
      {
LABEL_100:
        free(v24);
        goto LABEL_38;
      }

      v42 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (v42 == 45 || v42 == 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v43 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v113 = "nw_path_group_member_action";
          v114 = 1024;
          *(_DWORD *)v115 = v42;
          _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d",  buf,  0x12u);
        }

LABEL_99:
        os_log_type_t v9 = v92;
        goto LABEL_100;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v113 = "nw_path_group_member_action";
      v114 = 1024;
      *(_DWORD *)v115 = v42;
      os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v101[0]) = 0;
      if (__nwlog_fault(v52, type, v101))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v54 = type[0];
          if (os_log_type_enabled(v53, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            v113 = "nw_path_group_member_action";
            v114 = 1024;
            *(_DWORD *)v115 = v42;
            _os_log_impl(&dword_181A5C000, v53, v54, "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d", buf, 0x12u);
          }
        }

        else if (LOBYTE(v101[0]))
        {
          v56 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v57 = type[0];
          uint64_t v58 = os_log_type_enabled(v53, type[0]);
          if (v56)
          {
            if (v58)
            {
              *(_DWORD *)buf = 136446722;
              v113 = "nw_path_group_member_action";
              v114 = 1024;
              *(_DWORD *)v115 = v42;
              *(_WORD *)&v115[4] = 2082;
              *(void *)&v115[6] = v56;
              _os_log_impl( &dword_181A5C000,  v53,  v57,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v56);
            goto LABEL_97;
          }

          if (v58)
          {
            *(_DWORD *)buf = 136446466;
            v113 = "nw_path_group_member_action";
            v114 = 1024;
            *(_DWORD *)v115 = v42;
            _os_log_impl( &dword_181A5C000,  v53,  v57,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v59 = type[0];
          if (os_log_type_enabled(v53, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            v113 = "nw_path_group_member_action";
            v114 = 1024;
            *(_DWORD *)v115 = v42;
            _os_log_impl( &dword_181A5C000,  v53,  v59,  "%{public}s NECP_CLIENT_ACTION_AGENT %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

    if (v14) {
      free(v14);
    }
    goto LABEL_56;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "-[NWConcrete_nw_endpoint_edge initWithEndpoint:identifier:wildcard:]";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v41.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v18, &v41, &type))
    {
      if (LOBYTE(v41.receiver) == 17)
      {
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v20 = (os_log_type_t)v41.receiver;
        if (os_log_type_enabled(v19, (os_log_type_t)v41.receiver))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "-[NWConcrete_nw_endpoint_edge initWithEndpoint:identifier:wildcard:]";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null _identifier", buf, 0xCu);
        }
      }

      else if (type)
      {
        uint64_t v31 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v32 = (os_log_type_t)v41.receiver;
        v33 = os_log_type_enabled(v19, (os_log_type_t)v41.receiver);
        if (v31)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v44 = "-[NWConcrete_nw_endpoint_edge initWithEndpoint:identifier:wildcard:]";
            v45 = 2082;
            v46 = v31;
            _os_log_impl( &dword_181A5C000,  v19,  v32,  "%{public}s called with null _identifier, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v31);
          goto LABEL_60;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "-[NWConcrete_nw_endpoint_edge initWithEndpoint:identifier:wildcard:]";
          _os_log_impl(&dword_181A5C000, v19, v32, "%{public}s called with null _identifier, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v38 = (os_log_type_t)v41.receiver;
        if (os_log_type_enabled(v19, (os_log_type_t)v41.receiver))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "-[NWConcrete_nw_endpoint_edge initWithEndpoint:identifier:wildcard:]";
          _os_log_impl( &dword_181A5C000,  v19,  v38,  "%{public}s called with null _identifier, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        goto LABEL_55;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v29 = v36[0];
        if (os_log_type_enabled(v12, (os_log_type_t)v36[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
          _os_log_impl( &dword_181A5C000,  v12,  v29,  "%{public}s metadata must be http, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_54;
      }

      BOOL v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = v36[0];
      os_log_type_t v24 = os_log_type_enabled(v12, (os_log_type_t)v36[0]);
      if (!v20)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
          _os_log_impl(&dword_181A5C000, v12, v23, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }

        goto LABEL_54;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v20;
        _os_log_impl( &dword_181A5C000,  v12,  v23,  "%{public}s metadata must be http, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_34;
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    v36[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v11, v36, &type))
    {
      if (v36[0] == 17)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v13 = v36[0];
        if (os_log_type_enabled(v12, (os_log_type_t)v36[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null serialized_length", buf, 0xCu);
        }

        goto LABEL_54;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v28 = v36[0];
        if (os_log_type_enabled(v12, (os_log_type_t)v36[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
          _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s called with null serialized_length, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_54;
      }

      BOOL v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v36[0];
      BOOL v22 = os_log_type_enabled(v12, (os_log_type_t)v36[0]);
      if (!v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
          _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null serialized_length, no backtrace",  buf,  0xCu);
        }

        goto LABEL_54;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_legacy_serialize";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v20;
        _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null serialized_length, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    goto LABEL_55;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v32) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null client_accurate_ecn_state", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!(_BYTE)v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null client_accurate_ecn_state, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type[0];
    os_log_type_t v25 = os_log_type_enabled(v14, type[0]);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null client_accurate_ecn_state, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null client_accurate_ecn_state, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!a3)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v32) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null server_accurate_ecn_state", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!(_BYTE)v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v30 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null server_accurate_ecn_state, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = type[0];
    __int16 v27 = os_log_type_enabled(v14, type[0]);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
        _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null server_accurate_ecn_state, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_establishment_report_get_accurate_ecn_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null server_accurate_ecn_state, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_agent_set_assert_handlers";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null assert_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_assert_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null assert_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null assert_handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_agent_set_assert_handlers";
      os_log_type_t v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null assert_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_agent_set_assert_handlers";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_assert_handlers";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null unassert_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_assert_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null unassert_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = type;
    __int16 v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_assert_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null unassert_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_agent_set_assert_handlers";
      os_log_type_t v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null unassert_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v10)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_agent_add_resolve_handlers";
    char v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null start_resolve_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v39)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v31 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl( &dword_181A5C000,  v16,  v31,  "%{public}s called with null start_resolve_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v25 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = v40;
    __int16 v27 = os_log_type_enabled(v16, v40);
    if (!v25)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null start_resolve_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_agent_add_resolve_handlers";
      os_log_type_t v43 = 2082;
      BOOL v44 = v25;
      _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null start_resolve_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v11)
  {
    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_agent_add_resolve_handlers";
    char v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_181A5C000, v16, v21, "%{public}s called with null stop_resolve_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v39)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v32 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl( &dword_181A5C000,  v16,  v32,  "%{public}s called with null stop_resolve_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v25 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v28 = v40;
    uint64_t v29 = os_log_type_enabled(v16, v40);
    if (!v25)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s called with null stop_resolve_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_agent_add_resolve_handlers";
      os_log_type_t v43 = 2082;
      BOOL v44 = v25;
      _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s called with null stop_resolve_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_agent_set_browse_handlers";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null start_browse_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_browse_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null start_browse_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_browse_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null start_browse_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_agent_set_browse_handlers";
      os_log_type_t v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null start_browse_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_agent_set_browse_handlers";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null stop_browse_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_browse_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null stop_browse_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = type;
    __int16 v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_browse_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null stop_browse_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_agent_set_browse_handlers";
      os_log_type_t v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null stop_browse_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v12)
  {
    __nwlog_obj();
    BOOL v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "nw_agent_set_flow_handlers";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    v42 = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (v42 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = v42;
      if (os_log_type_enabled(v20, v42))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null start_flow_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v41)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v35 = v42;
      if (os_log_type_enabled(v20, v42))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_agent_set_flow_handlers";
        _os_log_impl( &dword_181A5C000,  v20,  v35,  "%{public}s called with null start_flow_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v29 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v30 = v42;
    uint64_t v31 = os_log_type_enabled(v20, v42);
    if (!v29)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_agent_set_flow_handlers";
        _os_log_impl( &dword_181A5C000,  v20,  v30,  "%{public}s called with null start_flow_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "nw_agent_set_flow_handlers";
      v45 = 2082;
      v46 = v29;
      _os_log_impl( &dword_181A5C000,  v20,  v30,  "%{public}s called with null start_flow_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v13)
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "nw_agent_set_flow_handlers";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    v42 = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (v42 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = v42;
      if (os_log_type_enabled(v20, v42))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_181A5C000, v20, v25, "%{public}s called with null stop_flow_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v41)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = v42;
      if (os_log_type_enabled(v20, v42))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_agent_set_flow_handlers";
        _os_log_impl( &dword_181A5C000,  v20,  v36,  "%{public}s called with null stop_flow_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    uint64_t v29 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v32 = v42;
    v33 = os_log_type_enabled(v20, v42);
    if (!v29)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_agent_set_flow_handlers";
        _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s called with null stop_flow_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "nw_agent_set_flow_handlers";
      v45 = 2082;
      v46 = v29;
      _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s called with null stop_flow_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_55;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_agent_set_group_handlers";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null add_members_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_group_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null add_members_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_group_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null add_members_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_agent_set_group_handlers";
      os_log_type_t v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null add_members_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_35;
  }

  if (!v7)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_agent_set_group_handlers";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null remove_members_handler", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v32)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_group_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null remove_members_handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    os_log_type_t v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = type;
    __int16 v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_agent_set_group_handlers";
        _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null remove_members_handler, no backtrace",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_agent_set_group_handlers";
      os_log_type_t v36 = 2082;
      v37 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null remove_members_handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (!v13)
    {
LABEL_56:
      os_log_type_t v10 = 0LL;
      goto LABEL_57;
    }

      free(v25);
      if (!v17) {
        return;
      }
LABEL_85:
      v38 = (char *)v17;
LABEL_86:
      free(v38);
      return;
    }

    uint64_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_84;
    }
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_http2_disconnect";
    BOOL v20 = "%{public}s called with null http2";
LABEL_83:
    _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
    goto LABEL_84;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_http2_disconnect";
    BOOL v17 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_84;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      BOOL v20 = "%{public}s called with null other_protocol";
      goto LABEL_83;
    }

    if (!v42)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_84;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      BOOL v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_83;
    }

    os_log_type_t v25 = (char *)__nw_create_backtrace_string();
    uint64_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    __int16 v28 = os_log_type_enabled(v18, type);
    if (!v25)
    {
      if (!v28) {
        goto LABEL_84;
      }
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      BOOL v20 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_83;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v45 = "nw_protocol_http2_disconnect";
      v46 = 2082;
      v47 = (nw_protocol_identifier *)v25;
      __int16 v27 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_53;
    }

    goto LABEL_54;
  }

  if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v21 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      BOOL v22 = handle[92];
      *(_DWORD *)buf = 136446978;
      v45 = "nw_protocol_http2_disconnect";
      v46 = 2082;
      v47 = (nw_protocol_identifier *)((char *)handle + 390);
      v48 = 2080;
      v49 = " ";
      v50 = 1024;
      v51 = v22;
      _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v10 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    BOOL v11 = handle[92];
    *(_DWORD *)buf = 136446978;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = (nw_protocol_identifier *)((char *)handle + 390);
    v48 = 2080;
    v49 = " ";
    v50 = 1024;
    v51 = v11;
    os_log_type_t v12 = "%{public}s %{public}s%s<i%u> attempting to disconnect on protocol that doesn't have entry in table, ignoring";
    BOOL v13 = (os_log_s *)v10;
    os_log_type_t v14 = 38;
LABEL_22:
    _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return;
  }

  uint64_t v5 = output_handler_context[4];
  if (!v5)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v15 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    os_log_type_t v16 = handle[92];
    *(_DWORD *)buf = 136447490;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = (nw_protocol_identifier *)((char *)handle + 390);
    v48 = 2080;
    v49 = " ";
    v50 = 1024;
    v51 = v16;
    os_log_type_t v52 = 2048;
    os_log_type_t v53 = a2;
    uint64_t v54 = 2048;
    v55 = output_handler_context;
    os_log_type_t v12 = "%{public}s %{public}s%s<i%u> protocol (%p) node (%p) has no stream pointer as extra";
    BOOL v13 = (os_log_s *)v15;
    os_log_type_t v14 = 58;
    goto LABEL_22;
  }

  nw_http2_stream_close((uint64_t)handle, output_handler_context[4]);
  uint64_t v6 = *(unsigned __int16 *)(v5 + 188);
  os_log_type_t v7 = v6 | (*(unsigned __int8 *)(v5 + 190) << 16);
  if ((v6 & 0x40) != 0) {
    return;
  }
  *(_BYTE *)(v5 + 190) = BYTE2(v7);
  *(_WORD *)(v5 + 188) = v7 | 0x40;
  callbacks = a2->callbacks;
  if (callbacks)
  {
    disconnected = (void (*)(nw_protocol *, _DWORD *))callbacks->disconnected;
    if (disconnected)
    {
      disconnected(a2, handle);
      return;
    }
  }

  __nwlog_obj();
  identifier = a2->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)buf = 136446466;
  v45 = "nw_protocol_http2_disconnect";
  v46 = 2082;
  v47 = identifier;
  __int16 v30 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v31 = (os_log_s *)__nwlog_obj();
    uint64_t v32 = type;
    if (!os_log_type_enabled(v31, type)) {
      goto LABEL_96;
    }
    v33 = a2->identifier;
    if (!v33) {
      v33 = (nw_protocol_identifier *)"invalid";
    }
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v33;
    uint64_t v34 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_95:
    _os_log_impl(&dword_181A5C000, v31, v32, v34, buf, 0x16u);
    goto LABEL_96;
  }

  if (!v42)
  {
    uint64_t v31 = (os_log_s *)__nwlog_obj();
    uint64_t v32 = type;
    v39 = os_log_type_enabled(v31, type);
    os_log_type_t v40 = (nw_protocol_identifier *)"invalid";
    if (!v39) {
      goto LABEL_96;
    }
    if (a2->identifier) {
      os_log_type_t v40 = a2->identifier;
    }
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v40;
    uint64_t v34 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
    goto LABEL_95;
  }

  v35 = (char *)__nw_create_backtrace_string();
  uint64_t v31 = (os_log_s *)__nwlog_obj();
  uint64_t v32 = type;
  os_log_type_t v36 = os_log_type_enabled(v31, type);
  if (!v35)
  {
    BOOL v41 = (nw_protocol_identifier *)"invalid";
    if (!v36) {
      goto LABEL_96;
    }
    if (a2->identifier) {
      BOOL v41 = a2->identifier;
    }
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v41;
    uint64_t v34 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
    goto LABEL_95;
  }

  if (v36)
  {
    v37 = (nw_protocol_identifier *)"invalid";
    if (a2->identifier) {
      v37 = a2->identifier;
    }
    *(_DWORD *)buf = 136446722;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v37;
    v48 = 2082;
    v49 = v35;
    _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v35);
LABEL_96:
  if (v30)
  {
    v38 = (char *)v30;
    goto LABEL_86;
  }

  if (v7) {
    free(v7);
  }
  return 0LL;
}

  __break(1u);
  return result;
}

  if (v50) {
    free(v50);
  }
  return 0LL;
}

void sub_181A659F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_context_remove_cache_entry(void *a1, uint64_t *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (v3)
  {
    uint64_t v4 = v3;
    if (a2)
    {
      uint64_t v5 = v3;
      uint64_t v6 = v5;
      if (((_BYTE)v5[17] & 8) == 0) {
        dispatch_assert_queue_V2(v5[1]);
      }

      uint64_t v4 = (void *)nw_context_copy_cache_context(v6);
      uint64_t v7 = a2[2];
      if (v7 || a2[3])
      {
        uint64_t v8 = *((void *)v4 + 3);
        int v9 = *(_DWORD *)(v8 + 64);
        if (v9) {
          *(_DWORD *)(v8 + 64) = v9 - 1;
        }
        os_log_type_t v10 = (void *)a2[3];
        if (v7)
        {
          *(void *)(v7 + 24) = v10;
          os_log_type_t v10 = (void *)a2[3];
        }

        else
        {
          *(void *)(v8 + 24) = v10;
        }

        void *v10 = v7;
        a2[2] = 0LL;
        a2[3] = 0LL;
      }

      uint64_t v11 = *a2;
      os_log_type_t v12 = (void *)a2[1];
      if (*a2)
      {
        *(void *)(v11 + 8) = v12;
        os_log_type_t v12 = (void *)a2[1];
      }

      else
      {
        *(void *)(*((void *)v4 + 3) + 8LL) = v12;
      }

      *os_log_type_t v12 = v11;
      *a2 = 0LL;
      a2[1] = 0LL;
      uint64_t v13 = *((void *)v4 + 3);
      int v14 = *(_DWORD *)(v13 + 68);
      if (v14) {
        *(_DWORD *)(v13 + 68) = v14 - 1;
      }
      goto LABEL_18;
    }

    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = "nw_context_remove_cache_entry";
    BOOL v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null cache_entry", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v34 = "nw_context_remove_cache_entry";
          __int16 v35 = 2082;
          os_log_type_t v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v27,  "%{public}s called with null cache_entry, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_54;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_181A5C000, v21, v27, "%{public}s called with null cache_entry, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_context_remove_cache_entry";
        _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null cache_entry, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_54:
    if (v20) {
      free(v20);
    }
    goto LABEL_18;
  }

  __nwlog_obj();
  char v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v34 = "nw_context_remove_cache_entry";
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (__nwlog_fault(v16, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v31)
    {
      os_log_type_t v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v17, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v34 = "nw_context_remove_cache_entry";
          __int16 v35 = 2082;
          os_log_type_t v36 = v23;
          _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
        goto LABEL_48;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_181A5C000, v17, v24, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v34 = "nw_context_remove_cache_entry";
        _os_log_impl( &dword_181A5C000,  v17,  v29,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_48:
  if (v16) {
    free(v16);
  }
  uint64_t v4 = 0LL;
LABEL_18:
}

    if (v15) {
      free(v15);
    }
    goto LABEL_56;
  }

  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_parameters);
  uint64_t v6 = a1[13];
  a1[13] = v5;

  if (!a1[13])
  {
    __nwlog_obj();
    os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buffer[0]) = 136446210;
    *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_parameters initWithStack:]";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t v30 = 0;
    if (__nwlog_fault(v19, buf, &v30))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = buf[0];
        if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_parameters initWithStack:]";
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null self->path_parameters",  (uint8_t *)buffer,  0xCu);
        }
      }

      else if (v30)
      {
        BOOL v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v26 = buf[0];
        os_log_type_t v27 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
        if (v25)
        {
          if (v27)
          {
            LODWORD(buffer[0]) = 136446466;
            *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_parameters initWithStack:]";
            WORD6(buffer[0]) = 2082;
            *(void *)((char *)buffer + 14) = v25;
            _os_log_impl( &dword_181A5C000,  v20,  v26,  "%{public}s called with null self->path_parameters, dumping backtrace:%{public}s",  (uint8_t *)buffer,  0x16u);
          }

          free(v25);
          goto LABEL_53;
        }

        if (v27)
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_parameters initWithStack:]";
          _os_log_impl( &dword_181A5C000,  v20,  v26,  "%{public}s called with null self->path_parameters, no backtrace",  (uint8_t *)buffer,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = buf[0];
        if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
        {
          LODWORD(buffer[0]) = 136446210;
          *(void *)((char *)buffer + 4) = "-[NWConcrete_nw_parameters initWithStack:]";
          _os_log_impl( &dword_181A5C000,  v20,  v29,  "%{public}s called with null self->path_parameters, backtrace limit exceeded",  (uint8_t *)buffer,  0xCu);
        }
      }
    }

    if (v20) {
      free(v20);
    }
LABEL_50:
    uint64_t v2 = 0LL;
    goto LABEL_12;
  }

  objc_storeStrong((id *)&v5->definition, *((id *)v4 + 1));
  objc_storeStrong((id *)&v2->proxy_endpoint, *((id *)v4 + 3));
  uint64_t v6 = (OS_nw_array *)*((void *)v4 + 4);
  if (v6)
  {
    uint64_t v7 = nw_array_create();
    if ((OS_nw_array *)v7 != v6)
    {
      uint64_t v8 = (OS_nw_array *)v7;
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v7 + 16,  (void **)&v6[2].super.super.isa->isa,  (void **)&v6[3].super.super.isa->isa,  v6[3].super.super.isa - v6[2].super.super.isa);
      uint64_t v6 = v8;
    }

    proxy_next_hops = v2->proxy_next_hops;
    v2->proxy_next_hops = v6;
  }

  v2->override_stack_endpoint = *((_BYTE *)v4 + 152);
  v2->prohibit_joining = *((_BYTE *)v4 + 153);
  os_log_type_t v10 = *(uint64_t (**)(void))(*((void *)v4 + 1) + 96LL);
  if (v10) {
    v2->handle = (void *)v10();
  }
  uint64_t v11 = (void *)*((void *)v4 + 5);
  if (v11)
  {
    os_log_type_t v12 = (OS_xpc_object *)xpc_copy(v11);
    legacy_parameters = v2->legacy_parameters;
    v2->legacy_parameters = v12;
  }

    if (v23) {
      free(v23);
    }
    goto LABEL_30;
  }

  if (v1->mode != 2)
  {
    if ((*((_BYTE *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)v2 + 268) & 1) != 0) {
          uint64_t v5 = "dry-run ";
        }
        else {
          uint64_t v5 = "";
        }
        uint64_t v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        state = v2->state;
        int v9 = logging_description;
        else {
          os_log_type_t v10 = off_189BBBBF0[state];
        }
        os_log_type_t v30 = v10;
        uint64_t v11 = v2;
        os_log_type_t v12 = (os_unfair_lock_s *)v11;
        uint64_t v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v13 = "resolver";
            break;
          case 2:
            uint64_t v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            uint64_t v13 = "proxy";
            break;
          case 4:
            uint64_t v13 = "fallback";
            break;
          case 5:
            uint64_t v13 = "transform";
            break;
          default:
            uint64_t v13 = "unknown-mode";
            break;
        }

        int v14 = v12 + 28;
        char v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        os_log_type_t v16 = v15[8];
        os_unfair_lock_unlock(v14);

        BOOL v17 = v16;
        os_log_type_t v18 = v15;
        os_log_type_t v19 = v18;
        BOOL v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            BOOL v20 = "resolver";
            break;
          case 2:
            BOOL v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            BOOL v20 = "proxy";
            break;
          case 4:
            BOOL v20 = "fallback";
            break;
          case 5:
            BOOL v20 = "transform";
            break;
          default:
            BOOL v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        uint64_t v34 = "nw_endpoint_handler_copy_flow";
        __int16 v35 = 2082;
        id_str = v2->id_str;
        uint64_t v37 = 2082;
        v38 = v5;
        v39 = 2082;
        os_log_type_t v40 = v9;
        BOOL v41 = 2082;
        v42 = v30;
        os_log_type_t v43 = 2082;
        BOOL v44 = v13;
        v45 = 2114;
        v46 = v17;
        v47 = 2082;
        v48 = v20;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public}s, not a flow",  buf,  0x52u);
      }
    }

        uint64_t v34 = 0LL;
LABEL_49:
        sa_len = v29 + v30 + v31 + v32 + v33 + v34 + 24;
LABEL_50:
        if (sa_len <= 0x1C) {
          BOOL v41 = 28LL;
        }
        else {
          BOOL v41 = sa_len;
        }
        goto LABEL_53;
      }

    if (v23) {
      free(v23);
    }
    goto LABEL_30;
  }

  if (v1->mode != 1)
  {
    if ((*((_BYTE *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)v2 + 268) & 1) != 0) {
          uint64_t v5 = "dry-run ";
        }
        else {
          uint64_t v5 = "";
        }
        uint64_t v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        state = v2->state;
        int v9 = logging_description;
        else {
          os_log_type_t v10 = off_189BBBBF0[state];
        }
        os_log_type_t v30 = v10;
        uint64_t v11 = v2;
        os_log_type_t v12 = (os_unfair_lock_s *)v11;
        uint64_t v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v13 = "resolver";
            break;
          case 2:
            uint64_t v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            uint64_t v13 = "proxy";
            break;
          case 4:
            uint64_t v13 = "fallback";
            break;
          case 5:
            uint64_t v13 = "transform";
            break;
          default:
            uint64_t v13 = "unknown-mode";
            break;
        }

        int v14 = v12 + 28;
        char v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        os_log_type_t v16 = v15[8];
        os_unfair_lock_unlock(v14);

        BOOL v17 = v16;
        os_log_type_t v18 = v15;
        os_log_type_t v19 = v18;
        BOOL v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            BOOL v20 = "resolver";
            break;
          case 2:
            BOOL v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            BOOL v20 = "proxy";
            break;
          case 4:
            BOOL v20 = "fallback";
            break;
          case 5:
            BOOL v20 = "transform";
            break;
          default:
            BOOL v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        uint64_t v34 = "nw_endpoint_handler_copy_resolver";
        __int16 v35 = 2082;
        id_str = v2->id_str;
        uint64_t v37 = 2082;
        v38 = v5;
        v39 = 2082;
        os_log_type_t v40 = v9;
        BOOL v41 = 2082;
        v42 = v30;
        os_log_type_t v43 = 2082;
        BOOL v44 = v13;
        v45 = 2114;
        v46 = v17;
        v47 = 2082;
        v48 = v20;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public} s, not a resolver",  buf,  0x52u);
      }
    }

    free(v19);
    goto LABEL_49;
  }

  id v3 = v1;
  uint64_t v4 = -[nw_endpoint type](v3, "type");

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v16 = (id)gLogObj;
    BOOL v17 = v3;
    os_log_type_t v18 = -[nw_endpoint type](v17, "type");

    *(_DWORD *)v90 = 136446466;
    v91 = "nw_endpoint_copy_address_string";
    v92 = 1024;
    LODWORD(v93[0]) = v18;
    LODWORD(v74) = 18;
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v19, buf, &type))
    {
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = buf[0];
        if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
        {
          os_log_type_t v22 = v17;
          os_log_type_t v23 = -[nw_endpoint type](v22, "type", v90, v74);

          *(_DWORD *)v90 = 136446466;
          v91 = "nw_endpoint_copy_address_string";
          v92 = 1024;
          LODWORD(v93[0]) = v23;
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s incorrect endpoint type %u", v90, 0x12u);
        }
      }

      else if (type)
      {
        os_log_type_t v24 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (os_log_s *)(id)gLogObj;
        BOOL v25 = buf[0];
        char v26 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
        if (v24)
        {
          if (v26)
          {
            os_log_type_t v27 = v17;
            BOOL v28 = -[nw_endpoint type](v27, "type", v90, v74);

            *(_DWORD *)v90 = 136446722;
            v91 = "nw_endpoint_copy_address_string";
            v92 = 1024;
            LODWORD(v93[0]) = v28;
            WORD2(v93[0]) = 2082;
            *(void *)((char *)v93 + 6) = v24;
            _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  v90,  0x1Cu);
          }

          free(v24);
          if (!v19) {
            goto LABEL_49;
          }
          goto LABEL_48;
        }

        if (v26)
        {
          v48 = v17;
          v49 = -[nw_endpoint type](v48, "type", v90, v74);

          *(_DWORD *)v90 = 136446466;
          v91 = "nw_endpoint_copy_address_string";
          v92 = 1024;
          LODWORD(v93[0]) = v49;
          _os_log_impl(&dword_181A5C000, v20, v25, "%{public}s incorrect endpoint type %u, no backtrace", v90, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (os_log_s *)(id)gLogObj;
        BOOL v41 = buf[0];
        if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
        {
          v42 = v17;
          os_log_type_t v43 = -[nw_endpoint type](v42, "type", v90, v74);

          *(_DWORD *)v90 = 136446466;
          v91 = "nw_endpoint_copy_address_string";
          v92 = 1024;
          LODWORD(v93[0]) = v43;
          _os_log_impl( &dword_181A5C000,  v20,  v41,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  v90,  0x12u);
        }
      }
    }

    goto LABEL_47;
  }

  uint64_t v5 = v3;
  address_family = nw_endpoint_get_address_family(v5);
  switch(address_family)
  {
    case 1:
      v33 = *((unsigned __int8 *)v5 + 232);
      uint64_t v34 = v33 - 2;
      if (v33 <= 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v35 = (id)gLogObj;
        *(_DWORD *)v90 = 136446210;
        v91 = "nw_endpoint_copy_address_string";
        char v31 = (const char *)_os_log_send_and_compose_impl();

        buf[0] = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (buf[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v36 = (os_log_s *)(id)gLogObj;
          uint64_t v37 = buf[0];
          if (os_log_type_enabled(v36, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)v90 = 136446210;
            v91 = "nw_endpoint_copy_address_string";
            _os_log_impl(&dword_181A5C000, v36, v37, "%{public}s endpoint sockaddr has invalid length", v90, 0xCu);
          }

                    v48 = v52;
LABEL_96:

                    id v3 = v215;
                    a2 = v218;
                    goto LABEL_8;
                  }

                  a2 = v218;
                  if ((logging_disabled & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v48 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)v48, OS_LOG_TYPE_INFO)) {
                      goto LABEL_96;
                    }
                    v49 = nw_endpoint_handler_get_id_string(v6);
                    v50 = nw_endpoint_handler_dry_run_string(v6);
                    v51 = nw_endpoint_handler_copy_endpoint(v6);
                    os_log_type_t v52 = (os_log_s *)v48;
                    os_log_type_t v53 = nw_endpoint_get_logging_description(v51);
                    uint64_t v54 = nw_endpoint_handler_state_string(v6);
                    v55 = nw_endpoint_handler_mode_string(v6);
                    v56 = nw_endpoint_handler_copy_current_path(v6);
                    *(_DWORD *)buf = 136448002;
                    v232 = "nw_flow_connected";
                    v233 = 2082;
                    v234 = (void *)v49;
                    v235 = 2082;
                    v236 = v50;
                    v237 = 2082;
                    v238 = (void *)v53;
                    v239 = 2082;
                    v240 = v54;
                    v241 = 2082;
                    v242 = v55;
                    v243 = 2114;
                    v244 = v56;
                    v245 = 2082;
                    v246 = __str;
                    _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol%{p ublic}s waiting for output, ignore",  buf,  0x52u);

                    goto LABEL_48;
                  }

  tls = 0LL;
LABEL_70:

  return tls;
}

LABEL_49:
    if (v11) {
      free(v11);
    }
LABEL_51:
    radio_os_log_type_t type = nw_interface_radio_type_unknown;
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  if (*((_DWORD *)v4 + 11) <= v5)
  {
    uint64_t v7 = 0LL;
  }

  else if (v5)
  {
    uint64_t v7 = *((void *)v6 + 52) + 360LL * (v5 - 1);
  }

  else
  {
    uint64_t v7 = (uint64_t)v6 + 56;
  }

  radio_os_log_type_t type = nw_interface_get_radio_type(*(void **)(v7 + 352));
LABEL_13:

  return radio_type;
}

      a3 = (char *)sub_18264EB20();
      os_log_type_t v22 = v21;
      goto LABEL_51;
    }
  }

  os_log_type_t v27 = a2->callbacks;
  if (v27)
  {
    get_remote_endpoint = (uint64_t (*)(nw_protocol *))v27->get_remote_endpoint;
    if (get_remote_endpoint)
    {
      os_log_type_t v29 = (void *)get_remote_endpoint(a2);
      goto LABEL_51;
    }
  }

  __nwlog_obj();
  v112 = a2->identifier;
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
  if (!v112) {
    v112 = (nw_protocol_identifier *)"invalid";
  }
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = v112;
  *(_WORD *)&buf[22] = 2048;
  v153 = a2;
  v113 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v151 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v113, type, &v151))
  {
    if (type[0] == 17)
    {
      v114 = (os_log_s *)__nwlog_obj();
      v115 = type[0];
      if (os_log_type_enabled(v114, (os_log_type_t)type[0]))
      {
        v116 = a2->identifier;
        if (!v116) {
          v116 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v116;
        *(_WORD *)&buf[22] = 2048;
        v153 = a2;
        v117 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback";
LABEL_317:
        _os_log_impl(&dword_181A5C000, v114, v115, v117, buf, 0x20u);
      }
    }

    else if (v151)
    {
      v127 = (char *)__nw_create_backtrace_string();
      v114 = (os_log_s *)__nwlog_obj();
      v115 = type[0];
      v128 = os_log_type_enabled(v114, (os_log_type_t)type[0]);
      if (v127)
      {
        if (v128)
        {
          v129 = a2->identifier;
          if (!v129) {
            v129 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v129;
          *(_WORD *)&buf[22] = 2048;
          v153 = a2;
          LOWORD(v154[0]) = 2082;
          *(void *)((char *)v154 + 2) = v127;
          _os_log_impl( &dword_181A5C000,  v114,  v115,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v127);
        goto LABEL_318;
      }

      if (v128)
      {
        v147 = a2->identifier;
        if (!v147) {
          v147 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v147;
        *(_WORD *)&buf[22] = 2048;
        v153 = a2;
        v117 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace";
        goto LABEL_317;
      }
    }

    else
    {
      v114 = (os_log_s *)__nwlog_obj();
      v115 = type[0];
      if (os_log_type_enabled(v114, (os_log_type_t)type[0]))
      {
        v141 = a2->identifier;
        if (!v141) {
          v141 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v141;
        *(_WORD *)&buf[22] = 2048;
        v153 = a2;
        v117 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded";
        goto LABEL_317;
      }
    }
  }

    free(backtrace_string);
    goto LABEL_67;
  }

  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_protocol_udp_copy_info";
    BOOL v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_protocol_udp_copy_info";
        BOOL v20 = "%{public}s called with null udp";
        goto LABEL_66;
      }

      goto LABEL_67;
    }

    if (!v33)
    {
      os_log_type_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_protocol_udp_copy_info";
        BOOL v20 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_66;
      }

      goto LABEL_67;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v28 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_protocol_udp_copy_info";
        BOOL v20 = "%{public}s called with null udp, no backtrace";
        goto LABEL_66;
      }

      goto LABEL_67;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_protocol_udp_copy_info";
      uint64_t v37 = 2082;
      v38 = (uint64_t)backtrace_string;
      os_log_type_t v27 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_47;
    }

    goto LABEL_48;
  }

  uint64_t v5 = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6
    || (uint64_t v7 = *(void *)(v6 + 24)) == 0
    || (uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, void *))(v7 + 224)) == 0LL)
  {
    uint64_t v11 = 0LL;
    goto LABEL_12;
  }

  int v9 = *(void **)(v6 + 40);
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v10 = *(void *)(v6 + 88);
    if (v10) {
      *(void *)(v6 + 88) = v10 + 1;
    }
  }

  if ((_DWORD)a2)
  {
    uint64_t v11 = (void *)v8(v6, a2, a3);
    if (v9 != &nw_protocol_ref_counted_handle) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v36 = "__nw_protocol_copy_info";
  os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v21, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v36 = "__nw_protocol_copy_info";
      os_log_type_t v24 = "%{public}s called with null type";
LABEL_72:
      _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
      goto LABEL_73;
    }

    if (!v33)
    {
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_73;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v36 = "__nw_protocol_copy_info";
      os_log_type_t v24 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_72;
    }

    os_log_type_t v29 = (char *)__nw_create_backtrace_string();
    os_log_type_t v22 = (os_log_s *)__nwlog_obj();
    os_log_type_t v23 = type;
    os_log_type_t v30 = os_log_type_enabled(v22, type);
    if (!v29)
    {
      if (!v30) {
        goto LABEL_73;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v36 = "__nw_protocol_copy_info";
      os_log_type_t v24 = "%{public}s called with null type, no backtrace";
      goto LABEL_72;
    }

    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "__nw_protocol_copy_info";
      uint64_t v37 = 2082;
      v38 = (uint64_t)v29;
      _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v29);
  }

  LOBYTE(v55) = *((_BYTE *)a3 + *v9) == 0;
  return v55;
}

    goto LABEL_49;
  }

  if (v4)
  {
    uint64_t v6 = v3[10];
    uint64_t v7 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v6,  0,  0);

    uint64_t v8 = (void (**)(id, BOOL))v3[16];
    if (v8)
    {
      v8[2](v8, v7);
    }

    else
    {
      int v9 = xpc_array_create(0LL, 0LL);
      xpc_array_set_string(v9, 0xFFFFFFFFFFFFFFFFLL, "com.apple.ids");
      os_log_type_t v10 = xpc_array_create(0LL, 0LL);
      xpc_array_set_string(v10, 0xFFFFFFFFFFFFFFFFLL, "IDSGroupEntitledAgent");
      nw_parameters_set_required_netagent_classes((void *)v7, v9, v10);
    }

    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    }
    uint64_t v11 = (os_log_s *)(id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      os_log_type_t v12 = (char *)v3[1];
      *(_DWORD *)buf = 136446722;
      BOOL v44 = "nw_candidate_manager_start_ids_internal";
      v45 = 2048;
      v46 = v12;
      v47 = 2112;
      v48 = v5;
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Starting: %@", buf, 0x20u);
    }

    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v5, (void *)v7);
    int v14 = v3[22];
    v3[22] = evaluator_for_endpoint;

    char v15 = (os_unfair_lock_s *)v3[22];
    os_log_type_t v16 = MEMORY[0x1895F87A8];
    if (v15)
    {
      BOOL v17 = v15 + 24;
      os_log_type_t v18 = v15;
      os_unfair_lock_lock(v17);
      os_log_type_t v19 = v18[6];
      os_unfair_lock_unlock(v17);

      if (v19)
      {
        BOOL v20 = nw_parameters_copy_context((void *)v7);
        v38[0] = v16;
        v38[1] = 3221225472LL;
        v38[2] = __nw_candidate_manager_start_ids_internal_block_invoke;
        v38[3] = &unk_189BC9238;
        v39 = v3;
        os_log_type_t v19 = v19;
        os_log_type_t v40 = v19;
        nw_queue_context_async(v20, v38);
      }
    }

    else
    {
      os_log_type_t v19 = 0LL;
    }

    os_log_type_t v21 = v3[22];
    v36[0] = v16;
    v36[1] = 3221225472LL;
    v36[2] = __nw_candidate_manager_start_ids_internal_block_invoke_2;
    v36[3] = &unk_189BC8678;
    uint64_t v37 = v3;
    nw_path_evaluator_set_update_handler(v21, 0LL, v36);

    goto LABEL_15;
  }

  __nwlog_obj();
  char v26 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v44 = "nw_candidate_manager_start_ids_internal";
  os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v41 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v27 = type;
    if (os_log_type_enabled(v24, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_candidate_manager_start_ids_internal";
      _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null ids_endpoint", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (!v41)
  {
    __nwlog_obj();
    os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v35 = type;
    if (os_log_type_enabled(v24, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_candidate_manager_start_ids_internal";
      _os_log_impl( &dword_181A5C000,  v24,  v35,  "%{public}s called with null ids_endpoint, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  char v31 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v32 = type;
  v33 = os_log_type_enabled(v24, type);
  if (!v31)
  {
    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_candidate_manager_start_ids_internal";
      _os_log_impl(&dword_181A5C000, v24, v32, "%{public}s called with null ids_endpoint, no backtrace", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (v33)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v44 = "nw_candidate_manager_start_ids_internal";
    v45 = 2082;
    v46 = v31;
    _os_log_impl( &dword_181A5C000,  v24,  v32,  "%{public}s called with null ids_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v31);
  if (v23) {
    goto LABEL_50;
  }
LABEL_15:
}

    goto LABEL_49;
  }

  if (v8)
  {
    os_log_type_t v10 = v7[2];
    if (v10 && !nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v12 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_add_extra_interface_option";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v12;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v9;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Adding interface option details %@ to connection",  buf,  0x1Cu);
      }
    }

    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_connection_add_extra_interface_option_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC9238;
    uint64_t v13 = v7;
    *(void *)&char v31 = v13;
    *((void *)&v31 + 1) = v9;
    nw_connection_async_if_needed(v13, buf);

    goto LABEL_15;
  }

  __nwlog_obj();
  os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_add_extra_interface_option";
  char v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v28 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_add_extra_interface_option";
      _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null interface_option_details", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (!v28)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v27 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_add_extra_interface_option";
      _os_log_impl( &dword_181A5C000,  v16,  v27,  "%{public}s called with null interface_option_details, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  os_log_type_t v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v24 = type;
  BOOL v25 = os_log_type_enabled(v16, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_add_extra_interface_option";
      _os_log_impl( &dword_181A5C000,  v16,  v24,  "%{public}s called with null interface_option_details, no backtrace",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_connection_add_extra_interface_option";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v23;
    _os_log_impl( &dword_181A5C000,  v16,  v24,  "%{public}s called with null interface_option_details, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v23);
  if (v15) {
    goto LABEL_50;
  }
LABEL_15:
}

    goto LABEL_49;
  }

  if (v8)
  {
    os_log_type_t v10 = v7[2];
    if (v10 && !nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v11 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v12 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_remove_extra_interface_option";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v12;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v9;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Removing interface option details %@",  buf,  0x1Cu);
      }
    }

    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_connection_remove_extra_interface_option_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC9238;
    uint64_t v13 = v7;
    *(void *)&char v31 = v13;
    *((void *)&v31 + 1) = v9;
    nw_connection_async_if_needed(v13, buf);

    goto LABEL_15;
  }

  __nwlog_obj();
  os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_remove_extra_interface_option";
  char v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v28 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_remove_extra_interface_option";
      _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null details", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (!v28)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v27 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_remove_extra_interface_option";
      _os_log_impl( &dword_181A5C000,  v16,  v27,  "%{public}s called with null details, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  os_log_type_t v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v24 = type;
  BOOL v25 = os_log_type_enabled(v16, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_remove_extra_interface_option";
      _os_log_impl(&dword_181A5C000, v16, v24, "%{public}s called with null details, no backtrace", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_connection_remove_extra_interface_option";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v23;
    _os_log_impl( &dword_181A5C000,  v16,  v24,  "%{public}s called with null details, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v23);
  if (v15) {
    goto LABEL_50;
  }
LABEL_15:
}

      if (v16)
      {
        os_log_type_t v29 = (char *)v16;
LABEL_57:
        free(v29);
        goto LABEL_58;
      }

      goto LABEL_58;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
    BOOL v20 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    os_log_type_t v21 = v20;
    if (__nwlog_fault(v20, type, &v41))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v22 = (os_log_s *)__nwlog_obj();
        os_log_type_t v23 = type[0];
        if (!os_log_type_enabled(v22, type[0])) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
        os_log_type_t v24 = "%{public}s called with null input_protocol";
LABEL_54:
        _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
        goto LABEL_55;
      }

      if (!v41)
      {
        os_log_type_t v22 = (os_log_s *)__nwlog_obj();
        os_log_type_t v23 = type[0];
        if (!os_log_type_enabled(v22, type[0])) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
        os_log_type_t v24 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_54;
      }

      os_log_type_t v27 = (char *)__nw_create_backtrace_string();
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type[0];
      BOOL v28 = os_log_type_enabled(v22, type[0]);
      if (!v27)
      {
        if (!v28) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
        os_log_type_t v24 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_54;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v27;
        _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v27);
    }

      free(v18);
      if (!v8) {
        return;
      }
LABEL_64:
      free(v8);
      return;
    }

    int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_63;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_protocol_plugins_connected";
    uint64_t v11 = "%{public}s called with null protocol->handle";
LABEL_62:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_63;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_protocol_plugins_handle_connected";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_protocol_plugins_handle_connected";
      uint64_t v11 = "%{public}s called with null other_protocol";
      goto LABEL_62;
    }

    if (!v22)
    {
      int v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_protocol_plugins_handle_connected";
      uint64_t v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_62;
    }

    os_log_type_t v18 = (char *)__nw_create_backtrace_string();
    int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    os_log_type_t v21 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (!v21) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_protocol_plugins_handle_connected";
      uint64_t v11 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_62;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_protocol_plugins_handle_connected";
      char v26 = 2082;
      os_log_type_t v27 = (nw_protocol *)v18;
      BOOL v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_47;
    }

    goto LABEL_48;
  }

  if (gLogDatapath)
  {
    os_log_type_t v12 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      identifier = a1->identifier;
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      BOOL v25 = "nw_protocol_plugins_handle_connected";
      char v26 = 2080;
      os_log_type_t v27 = (nw_protocol *)identifier;
      BOOL v28 = 2048;
      os_log_type_t v29 = a1;
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
    }
  }

  uint64_t v5 = *((void *)handle + 9);
  if (v5)
  {
    if (gLogDatapath)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        char v15 = a1->identifier;
        if (!v15) {
          char v15 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446722;
        BOOL v25 = "nw_protocol_plugin_metadata_connected";
        char v26 = 2048;
        os_log_type_t v27 = a1;
        BOOL v28 = 2080;
        os_log_type_t v29 = (nw_protocol *)v15;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s protocol %p:%s got connected event",  buf,  0x20u);
      }
    }

    uint64_t v6 = *(_BYTE *)(v5 + 142);
    if ((v6 & 1) == 0)
    {
      v6 |= 1u;
      *(_BYTE *)(v5 + 140) = 0;
    }

    *(_BYTE *)(v5 + 142) = v6 & 0xEF;
  }

  uint64_t v7 = (nw_protocol_plugin_retry *)*((void *)handle + 11);
  if (v7) {
    nw_protocol_plugin_retry_connected(v7, a1, a2);
  }
  else {
    nw_protocol_common_connected((uint64_t)a1, (uint64_t)a2);
  }
}

    free(backtrace_string);
    goto LABEL_74;
  }

  if (a10)
  {
    v55 = v19;
    if (gLogDatapath)
    {
      BOOL v41 = v17;
      __nwlog_obj();
      v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447490;
        v76 = "nw_protocol_instance_registrar_find_instance_to_join";
        v77 = 2112;
        v78 = v16;
        v79 = 2080;
        v80 = a2;
        v81 = 2112;
        v82 = v57;
        v83 = 2112;
        v84 = v55;
        v85 = 1024;
        LODWORD(v86) = a4;
        _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ finding instance of %s to join for endpoint %@, parameters %@, (proxy: %u)",  buf,  0x3Au);
      }

      BOOL v17 = v41;
    }

    *(void *)os_log_type_t type = 0LL;
    v71 = type;
    v72 = 0x2020000000LL;
    v73 = 0LL;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_protocol_instance_registrar_find_instance_to_join_block_invoke;
    aBlock[3] = &unk_189BB66D0;
    os_log_type_t v21 = v16;
    v59 = v21;
    char v64 = a2;
    v67 = a5;
    v68 = a6;
    os_log_type_t v22 = v57;
    v60 = v22;
    char v61 = v17;
    os_log_type_t v23 = v55;
    uint64_t v69 = a4;
    v65 = a3;
    v66 = a10;
    os_log_type_t v62 = v23;
    v63 = type;
    os_log_type_t v24 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v16 + 2);
    v24[2](v24);
    os_unfair_lock_unlock(v16 + 2);

    BOOL v25 = *((void *)v71 + 3);
    if (v25)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        char v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v27 = (void *)*((void *)v71 + 3);
          *(_DWORD *)buf = 136447746;
          v76 = "nw_protocol_instance_registrar_find_instance_to_join";
          v77 = 2112;
          v78 = v21;
          v79 = 2048;
          v80 = v27;
          v81 = 2080;
          v82 = a2;
          v83 = 2112;
          v84 = v22;
          v85 = 2112;
          v86 = v23;
          v87 = 1024;
          v88 = a4;
          BOOL v28 = "%{public}s %@ returning instance %p of %s to join for endpoint %@, parameters %@, (proxy: %u)";
          os_log_type_t v29 = v26;
          os_log_type_t v30 = 68;
LABEL_54:
          _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_DEBUG, v28, buf, v30);
          goto LABEL_55;
        }

        goto LABEL_55;
      }
    }

    else
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        char v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v76 = "nw_protocol_instance_registrar_find_instance_to_join";
          v77 = 2112;
          v78 = v21;
          v79 = 2080;
          v80 = a2;
          BOOL v28 = "%{public}s %@ did not find instance of %s to join";
          os_log_type_t v29 = v26;
          os_log_type_t v30 = 32;
          goto LABEL_54;
        }

LABEL_49:
    if (v11) {
      free(v11);
    }
LABEL_51:
    uint64_t v8 = 0LL;
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  if (*((_DWORD *)v4 + 11) <= v5)
  {
    uint64_t v7 = 0LL;
  }

  else if (v5)
  {
    uint64_t v7 = *((void *)v6 + 52) + 360LL * (v5 - 1);
  }

  else
  {
    uint64_t v7 = (uint64_t)v6 + 56;
  }

  uint64_t v8 = (nw_interface *)*(id *)(v7 + 352);
LABEL_13:

  return v8;
}

LABEL_49:
    if (v11) {
      free(v11);
    }
LABEL_51:
    uint64_t v8 = 0LL;
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  if (*((_DWORD *)v4 + 11) <= v5)
  {
    uint64_t v7 = 0LL;
  }

  else if (v5)
  {
    uint64_t v7 = *((void *)v6 + 52) + 360LL * (v5 - 1);
  }

  else
  {
    uint64_t v7 = (uint64_t)v6 + 56;
  }

  uint64_t v8 = *(void *)(v7 + 112);
LABEL_13:

  return v8;
}

LABEL_49:
    if (v11) {
      free(v11);
    }
LABEL_51:
    uint64_t v8 = 0LL;
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  if (*((_DWORD *)v4 + 11) <= v5)
  {
    uint64_t v7 = 0LL;
  }

  else if (v5)
  {
    uint64_t v7 = *((void *)v6 + 52) + 360LL * (v5 - 1);
  }

  else
  {
    uint64_t v7 = (uint64_t)v6 + 56;
  }

  uint64_t v8 = *(void *)(v7 + 120);
LABEL_13:

  return v8;
}

LABEL_49:
    if (v11) {
      free(v11);
    }
LABEL_51:
    uint64_t v8 = 0LL;
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  if (*((_DWORD *)v4 + 11) <= v5)
  {
    uint64_t v7 = 0LL;
  }

  else if (v5)
  {
    uint64_t v7 = *((void *)v6 + 52) + 360LL * (v5 - 1);
  }

  else
  {
    uint64_t v7 = (uint64_t)v6 + 56;
  }

  uint64_t v8 = *(void *)(v7 + 136);
LABEL_13:

  return v8;
}

LABEL_49:
    if (v11) {
      free(v11);
    }
LABEL_51:
    uint64_t v8 = 0LL;
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  if (*((_DWORD *)v4 + 11) <= v5)
  {
    uint64_t v7 = 0LL;
  }

  else if (v5)
  {
    uint64_t v7 = *((void *)v6 + 52) + 360LL * (v5 - 1);
  }

  else
  {
    uint64_t v7 = (uint64_t)v6 + 56;
  }

  uint64_t v8 = *(void *)(v7 + 144);
LABEL_13:

  return v8;
}

LABEL_49:
    if (v11) {
      free(v11);
    }
LABEL_51:
    uint64_t v8 = 0LL;
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  if (*((_DWORD *)v4 + 11) <= v5)
  {
    uint64_t v7 = 0LL;
  }

  else if (v5)
  {
    uint64_t v7 = *((void *)v6 + 52) + 360LL * (v5 - 1);
  }

  else
  {
    uint64_t v7 = (uint64_t)v6 + 56;
  }

  uint64_t v8 = *(void *)(v7 + 152);
LABEL_13:

  return v8;
}

      if (v21) {
        free(v21);
      }
      uint64_t v6 = 0LL;
      if (v10 != &nw_protocol_ref_counted_handle) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
  }

  return v6;
}

      if (v21) {
        free(v21);
      }
      uint64_t v6 = 0LL;
      if (v10 != &nw_protocol_ref_counted_handle) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
  }

  return v6;
}

        goto LABEL_49;
      }

      if (!v28)
      {
        __nwlog_obj();
        char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v25 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_group_descriptor_set_members";
          _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null endpoints, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_48;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      os_log_type_t v23 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_group_descriptor_set_members";
          _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null endpoints, no backtrace", buf, 0xCu);
        }

        goto LABEL_48;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        char v31 = "nw_group_descriptor_set_members";
        uint64_t v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null endpoints, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_36;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v31 = "nw_group_descriptor_set_members";
    int v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v28 = 0;
    if (__nwlog_fault(v14, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_group_descriptor_set_members";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null descriptor", buf, 0xCu);
        }

        goto LABEL_48;
      }

      if (!v28)
      {
        __nwlog_obj();
        char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_group_descriptor_set_members";
          _os_log_impl( &dword_181A5C000,  v15,  v24,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_48;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      os_log_type_t v21 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_group_descriptor_set_members";
          _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }

        goto LABEL_48;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        char v31 = "nw_group_descriptor_set_members";
        uint64_t v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    goto LABEL_49;
  }

  if (!v37)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    if (os_log_type_enabled(v16, type))
    {
      BOOL v25 = (const char *)*((void *)v4 + 2);
      if (!v25) {
        BOOL v25 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_finalize_output_frames";
      os_log_type_t v43 = 2082;
      BOOL v44 = (char *)v25;
      v45 = 2048;
      v46 = v4;
      _os_log_impl( &dword_181A5C000,  v16,  v24,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_48;
  }

  BOOL v20 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v21 = type;
  os_log_type_t v22 = os_log_type_enabled(v16, type);
  if (!v20)
  {
    if (v22)
    {
      if (*((void *)v4 + 2)) {
        char v26 = (const char *)*((void *)v4 + 2);
      }
      else {
        char v26 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_finalize_output_frames";
      os_log_type_t v43 = 2082;
      BOOL v44 = (char *)v26;
      v45 = 2048;
      v46 = v4;
      _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  buf,  0x20u);
    }

    goto LABEL_48;
  }

  if (v22)
  {
    if (*((void *)v4 + 2)) {
      os_log_type_t v23 = (const char *)*((void *)v4 + 2);
    }
    else {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    v42 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v43 = 2082;
    BOOL v44 = (char *)v23;
    v45 = 2048;
    v46 = v4;
    v47 = 2082;
    v48 = v20;
    _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v20);
LABEL_49:
  if (v15) {
    free(v15);
  }
  uint64_t v7 = 0LL;
  if (v5 == &nw_protocol_ref_counted_handle) {
LABEL_14:
  }
    nw::release_if_needed<nw_protocol *>((uint64_t *)v38);
LABEL_15:
  uint64_t v11 = (char *)*((void *)v2 + 37);
  if (v11)
  {
    v35[0] = MEMORY[0x1895F87A8];
    v35[1] = 3221225472LL;
    v35[2] = __nw_protocol_implementation_finalize_pending_frames_block_invoke;
    v35[3] = &unk_189BC86F0;
    os_log_type_t v36 = v2;
    nw_hash_table_apply(v11, (uint64_t)v35);
  }

  return v7;
}
          }

    if (v25) {
      free(v25);
    }
    goto LABEL_27;
  }

  if (*(_BYTE *)(a1 + 56))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    uint64_t v11 = *(void *)(a1 + 32);
    os_log_type_t v12 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 136446722;
    BOOL v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
    v42 = 2114;
    os_log_type_t v43 = v11;
    BOOL v44 = 2048;
    v45[0] = v12;
    uint64_t v13 = "%{public}s %{public}@ wrote %zu bytes is_complete into outer connection";
    int v14 = v10;
    char v15 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_12;
  }

  if (!gLogDatapath)
  {
    *(void *)(v4 + 192) += *(void *)(a1 + 48);
    BOOL v17 = *(void *)(a1 + 32);
    goto LABEL_30;
  }

  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    os_log_type_t v36 = *(void *)(a1 + 32);
    uint64_t v37 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 136446722;
    BOOL v41 = "nw_socks5_connection_inner_connection_read_handler_on_queue_block_invoke";
    v42 = 2114;
    os_log_type_t v43 = v36;
    BOOL v44 = 2048;
    v45[0] = v37;
    uint64_t v13 = "%{public}s %{public}@ wrote %zu bytes not_complete into outer connection";
    int v14 = v10;
    char v15 = OS_LOG_TYPE_DEBUG;
LABEL_12:
    _os_log_impl(&dword_181A5C000, v14, v15, v13, buf, 0x20u);
  }

  if (v19) {
    free(v19);
  }
  uint64_t v13 = 0LL;
LABEL_18:

  return v13;
}

  if (v17) {
    free(v17);
  }
  return 0LL;
}

  if (v23) {
    free(v23);
  }
  return 0LL;
}

  if (v19) {
    free(v19);
  }
  return 0LL;
}

  if (v16) {
    free(v16);
  }
}

      if (v19) {
        free(v19);
      }
      *(_DWORD *)(a1[6] + 192LL) = 0;
      goto LABEL_51;
    }
  }

  int v9 = *(void *)(a2 + 32);
  os_log_type_t v10 = *(void **)(a2 + 40);
  if (v9)
  {
    *(void *)(v9 + 40) = v10;
    os_log_type_t v10 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(a1[5] + 8LL) = v10;
  }

  void *v10 = v9;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

    goto LABEL_49;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v17 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  os_log_type_t v36 = "-[NWRemotePacketProxy setOutputProtocolHandler:local:remote:ipProtocol:]";
  uint64_t v37 = 2048;
  v38 = 60LL;
  uint64_t v13 = (_BYTE *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v18 = (os_log_s *)(id)gLogObj;
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "-[NWRemotePacketProxy setOutputProtocolHandler:local:remote:ipProtocol:]";
      uint64_t v37 = 2048;
      v38 = 60LL;
      BOOL v20 = "%{public}s calloc(%zu) failed";
LABEL_26:
      os_log_type_t v24 = v18;
      BOOL v25 = v19;
LABEL_27:
      _os_log_impl(&dword_181A5C000, v24, v25, v20, buf, 0x16u);
    }
  }

  else
  {
    if (v33)
    {
      os_log_type_t v21 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v18 = (os_log_s *)(id)gLogObj;
      os_log_type_t v22 = type;
      os_log_type_t v23 = os_log_type_enabled(v18, type);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v36 = "-[NWRemotePacketProxy setOutputProtocolHandler:local:remote:ipProtocol:]";
          uint64_t v37 = 2048;
          v38 = 60LL;
          v39 = 2082;
          os_log_type_t v40 = v21;
          _os_log_impl( &dword_181A5C000,  v18,  v22,  "%{public}s calloc(%zu) failed, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v21);
        if (v13) {
          goto LABEL_30;
        }
        goto LABEL_31;
      }

      if (!v23) {
        goto LABEL_28;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "-[NWRemotePacketProxy setOutputProtocolHandler:local:remote:ipProtocol:]";
      uint64_t v37 = 2048;
      v38 = 60LL;
      BOOL v20 = "%{public}s calloc(%zu) failed, no backtrace";
      os_log_type_t v24 = v18;
      BOOL v25 = v22;
      goto LABEL_27;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v18 = (os_log_s *)(id)gLogObj;
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "-[NWRemotePacketProxy setOutputProtocolHandler:local:remote:ipProtocol:]";
      uint64_t v37 = 2048;
      v38 = 60LL;
      BOOL v20 = "%{public}s calloc(%zu) failed, backtrace limit exceeded";
      goto LABEL_26;
    }
  }

  objc_storeStrong((id *)(v15 + 256), (id)v15);
  if (*((_BYTE *)v126 + 24)) {
    nw_parameters_set_attach_protocol_listener(*(void **)(*(void *)(a1 + 32) + 16LL), 0);
  }
  logging_disabled = nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 16LL));
  *(_DWORD *)(*(void *)(a1 + 32) + 72LL) = *(_DWORD *)(a1 + 40);
  __int16 v35 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)(*(void *)(a1 + 32) + 16LL), 1);
  os_log_type_t v36 = *(void **)(a1 + 32);
  if (v36[6])
  {
    if (!logging_disabled)
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      uint64_t v37 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        v38 = *(void *)(a1 + 32);
        v39 = *(unsigned __int16 *)(v38 + 40);
        os_log_type_t v40 = *(void *)(v38 + 48);
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = v39;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v35;
        *(_WORD *)&buf[18] = 2112;
        *(void *)&buf[20] = v40;
        _os_log_impl(&dword_181A5C000, v37, OS_LOG_TYPE_DEFAULT, "[L%u %{public}s] start for connection %@", buf, 0x1Cu);
      }

      os_log_type_t v36 = *(void **)(a1 + 32);
    }

    BOOL v41 = v36;
    nw_context_assert_queue((void *)v41[3]);
    v42 = (void *)v41[6];
    os_log_type_t v43 = (uint64_t *)v41[2];
    if (v42)
    {
      listener_protocol_on_nw_queue = nw_connection_get_listener_protocol_on_nw_queue(v42, v43, 0);
      if (listener_protocol_on_nw_queue)
      {
        v45 = -[nw_listener_inbox_protocol initWithProtocol:delegate:]( objc_alloc(&OBJC_CLASS___nw_listener_inbox_protocol),  listener_protocol_on_nw_queue,  v41);
        if (v45)
        {
          v46 = nw_array_create();
          v47 = (void *)v41[18];
          v41[18] = v46;

          nw_array_append(v41[18], v45);
          nw_listener_set_state_on_queue(v41, 2, 0LL);
LABEL_193:

          goto LABEL_194;
        }

        v79 = v41[2];
        if (v79 && !nw_path_parameters_get_logging_disabled(*(void *)(v79 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
          }
          v80 = (os_log_s *)(id)glistenerLogObj;
          if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          {
            v81 = nw_listener_get_id_string(v41);
            v82 = *(void *)(listener_protocol_on_nw_queue + 16);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_listener_start_connection_on_queue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v81;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&_BYTE buf[24] = v82;
            _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] Failed to create inbox for %{public}s",  buf,  0x20u);
          }
        }

        v68 = v41;
        v83 = nw_error_create_posix_error(12);
        nw_listener_set_state_on_queue(v68, 3, v83);
      }

      else
      {
        uint64_t v69 = v41[2];
        if (v69 && !nw_path_parameters_get_logging_disabled(*(void *)(v69 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
          }
          v70 = (os_log_s *)(id)glistenerLogObj;
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
          {
            v71 = nw_listener_get_id_string(v41);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_start_connection_on_queue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v71;
            _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] Listener could not find protocol to join in connection",  buf,  0x16u);
          }
        }

        v45 = v41;
        v68 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 22);
        nw_listener_set_state_on_queue(v45, 3, v68);
      }
    }

    else
    {
      if (v43 && !nw_path_parameters_get_logging_disabled(v43[13]))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
        }
        v66 = (os_log_s *)(id)glistenerLogObj;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          v67 = nw_listener_get_id_string(v41);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_start_connection_on_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v67;
          _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] Listener no longer has connection to join",  buf,  0x16u);
        }
      }

      v45 = v41;
      v68 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 57);
      nw_listener_set_state_on_queue(v45, 3, v68);
    }

    goto LABEL_193;
  }

  if (!v36[7])
  {
    if (!logging_disabled)
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      v72 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        v73 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 40LL);
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v73;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v35;
        _os_log_impl(&dword_181A5C000, v72, OS_LOG_TYPE_DEFAULT, "[L%u %{public}s] start", buf, 0x12u);
      }

      os_log_type_t v36 = *(void **)(a1 + 32);
    }

    BOOL v41 = v36;
    nw_context_assert_queue((void *)v41[3]);
    nw_listener_set_state_on_queue(v41, 1, 0LL);
    LODWORD(fds) = 12;
    evaluator_for_listener = nw_path_create_evaluator_for_listener((void *)v41[2], (int *)&fds);
    v75 = (void *)v41[21];
    v41[21] = evaluator_for_listener;

    v76 = (void *)v41[21];
    if (v76)
    {
      *(void *)buf = v12;
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL26nw_listener_start_on_queueP22NWConcrete_nw_listener_block_invoke;
      *(void *)&_BYTE buf[24] = &unk_189BC8678;
      v77 = v41;
      *(void *)&buf[32] = v77;
      nw_path_evaluator_set_update_handler(v76, 0LL, buf);
      v78 = nw_path_evaluator_copy_path((os_unfair_lock_s *)v41[21]);
      nw_listener_handle_new_path_on_queue(v77, v78);

      v45 = *(void **)&buf[32];
    }

    else
    {
      v111 = v41[2];
      if (v111 && !nw_path_parameters_get_logging_disabled(*(void *)(v111 + 104)))
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
        }
        v112 = (os_log_s *)(id)glistenerLogObj;
        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
        {
          v113 = nw_listener_get_id_string(v41);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_start_on_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v113;
          _os_log_impl( &dword_181A5C000,  v112,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] nw_path_create_evaluator_for_listener failed",  buf,  0x16u);
        }
      }

      v114 = (int)fds;
      v45 = v41;
      v115 = nw_error_create_posix_error(v114);
      nw_listener_set_state_on_queue(v45, 3, v115);
    }

    goto LABEL_193;
  }

  if (!logging_disabled)
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    v50 = (os_log_s *)(id)glistenerLogObj;
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      v51 = *(void *)(a1 + 32);
      os_log_type_t v52 = *(unsigned __int16 *)(v51 + 40);
      os_log_type_t v53 = *(void *)(v51 + 56);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = v52;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = v35;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v53;
      _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEFAULT,  "[L%u %{public}s] start for launchd key %{public}s",  buf,  0x1Cu);
    }

    os_log_type_t v36 = *(void **)(a1 + 32);
  }

  uint64_t v54 = v36;
  nw_context_assert_queue(*((void **)v54 + 3));
  v55 = nw_array_create();
  v56 = (void *)*((void *)v54 + 18);
  *((void *)v54 + 18) = v55;

  cnt = 0LL;
  fds = 0LL;
  uint64_t v57 = launch_activate_socket(*((const char **)v54 + 7), &fds, &cnt);
  if (v57)
  {
    uint64_t v58 = *((void *)v54 + 2);
    if (v58 && !nw_path_parameters_get_logging_disabled(*(void *)(v58 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      v59 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        v60 = nw_listener_get_id_string(v54);
        char v61 = *((void *)v54 + 7);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v60;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&_BYTE buf[24] = v61;
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v57;
        _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] launch_activate_socket(%{public}s failed: %{darwin.errno}d",  buf,  0x26u);
      }
    }

    os_log_type_t v62 = nw_error_create_posix_error(v57);
  }

  else
  {
    os_log_type_t v62 = 0LL;
  }

  v84 = fds;
  if (!fds) {
    goto LABEL_178;
  }
  if (!cnt) {
    goto LABEL_177;
  }
  for (i = 0LL; i < cnt; ++i)
  {
    if (v62)
    {
      close(fds[i]);
      continue;
    }

    v133 = 4;
    if (getsockopt(fds[i], 0xFFFF, 4104, &v134, &v133)) {
      v86 = 0;
    }
    else {
      v86 = v134 == 1;
    }
    if (v86)
    {
      v90 = objc_alloc(&OBJC_CLASS___nw_listener_inbox_socket);
      v91 = fds[i];
      v92 = *((id *)v54 + 2);
      v93 = v54;
      if (v90)
      {
        v94 = -[nw_listener_inbox_socket initWithParameters:delegate:](v90, "initWithParameters:delegate:", v92, v93);
        v95 = v94;
        if (!v94 || v91 < 0)
        {
          v90 = 0LL;
        }

        else
        {
          v94->_sockfd_from_client = v91;
          v95 = v94;
          v90 = v95;
        }
      }

      else
      {
        v95 = 0LL;
      }

      if (!v90)
      {
        os_log_type_t v62 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 45);
        v101 = *((void *)v54 + 2);
        if (v101 && !nw_path_parameters_get_logging_disabled(*(void *)(v101 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
          }
          v102 = (os_log_s *)(id)glistenerLogObj;
          if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
          {
            v103 = nw_listener_get_id_string(v93);
            v104 = *((void *)v54 + 7);
            v105 = *((void *)v54 + 2);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v103;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&_BYTE buf[24] = v104;
            *(_WORD *)&buf[32] = 2048;
            *(void *)&buf[34] = i;
            *(_WORD *)&buf[42] = 2114;
            v138 = v105;
            _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] Failed to create inbox for %{public}s[%zu] with parameters %{public}@",  buf,  0x34u);
          }
        }

        close(fds[i]);
        goto LABEL_174;
      }

      -[nw_listener_inbox_socket start](v90, "start");
      os_log_type_t v62 = (void *)objc_claimAutoreleasedReturnValue();
      v96 = *((void *)v54 + 2);
      if (v62)
      {
        if (!v96 || nw_path_parameters_get_logging_disabled(*(void *)(v96 + 104))) {
          goto LABEL_174;
        }
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
        }
        v97 = (os_log_s *)(id)glistenerLogObj;
        if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
        {
          v98 = nw_listener_get_id_string(v93);
          v99 = *((void *)v54 + 7);
          v100 = *((void *)v54 + 2);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v98;
          *(_WORD *)&buf[22] = 2114;
          *(void *)&_BYTE buf[24] = v62;
          *(_WORD *)&buf[32] = 2114;
          *(void *)&buf[34] = v90;
          *(_WORD *)&buf[42] = 2082;
          v138 = v99;
          v139 = 2048;
          v140 = i;
          v141 = 2114;
          v142 = v100;
          _os_log_impl( &dword_181A5C000,  v97,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] Error %{public}@ starting inbox %{public}@ for %{public}s[%zu] with parameters %{public}@",  buf,  0x48u);
        }
      }

      else
      {
        if (v96 && !nw_path_parameters_get_logging_disabled(*(void *)(v96 + 104)))
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
          }
          v106 = (os_log_s *)(id)glistenerLogObj;
          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
          {
            v107 = nw_listener_get_id_string(v93);
            v108 = *((void *)v54 + 7);
            v109 = *((void *)v54 + 2);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v107;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&_BYTE buf[24] = v90;
            *(_WORD *)&buf[32] = 2082;
            *(void *)&buf[34] = v108;
            *(_WORD *)&buf[42] = 2048;
            v138 = i;
            v139 = 2114;
            v140 = v109;
            _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%{public}s] Started inbox %{public}@ for %{public}s[%zu] with parameters %{public}@",  buf,  0x3Eu);
          }
        }

        -[nw_listener_inbox local_endpoint](v90, "local_endpoint");
        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (v97) {
          nw_listener_set_local_endpoint_on_queue(v93, v97);
        }
        nw_array_append(*((void *)v54 + 18), v90);
      }

LABEL_174:
      continue;
    }

    v87 = *((void *)v54 + 2);
    if (v87 && !nw_path_parameters_get_logging_disabled(*(void *)(v87 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      v88 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      {
        v89 = *((void *)v54 + 7);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_listener_start_launchd_on_queue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v54 + 42;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&_BYTE buf[24] = v89;
        *(_WORD *)&buf[32] = 2048;
        *(void *)&buf[34] = i;
        _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}s] socket %{public}s[%zu] not SOCK_STREAM - not supported",  buf,  0x2Au);
      }
    }

    os_log_type_t v62 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 45);
    close(fds[i]);
  }

  v84 = fds;
  if (fds)
  {
LABEL_177:
    free(v84);
    fds = 0LL;
  }

    free(v15);
    goto LABEL_49;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v10 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v52 = "nw_parameters_create_custom_ip";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v49 = 0;
  if (__nwlog_fault(v11, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)(id)gLogObj;
      uint64_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "nw_parameters_create_custom_ip";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
    }

    else if (v49)
    {
      os_log_type_t v18 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v52 = "nw_parameters_create_custom_ip";
          os_log_type_t v53 = 2082;
          uint64_t v54 = v18;
          _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v18);
        if (!v11) {
          goto LABEL_40;
        }
        goto LABEL_39;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "nw_parameters_create_custom_ip";
        _os_log_impl(&dword_181A5C000, v12, v19, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "nw_parameters_create_custom_ip";
        _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v11) {
LABEL_39:
  }
    free(v11);
LABEL_40:
  int v9 = 0LL;
LABEL_51:

LABEL_52:
  return v9;
}

    xpc_dictionary_set_BOOL(v2, "prohibit_roaming", 1);
    os_log_type_t v23 = *(xpc_object_t **)(*((void *)v1 + 13) + 176LL);
    if (!v23) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }

  uint64_t v2 = 0LL;
LABEL_106:

  return v2;
}

    goto LABEL_49;
  }

  if (v4)
  {
    memset(buf, 0, 32);
    nw_application_id_get_audit_token(v4, buf);
    if (*(void *)buf | *(void *)&buf[8] | *(void *)&buf[16] | *(void *)&buf[24])
    {
      uint64_t v6 = *(_OWORD *)&buf[16];
      *(_OWORD *)(v3 + 40) = *(_OWORD *)buf;
      *(_OWORD *)(v3 + 56) = v6;
    }

    memset(uu, 0, sizeof(uu));
    nw_application_id_get_uuid(v5, uu);
    if (!uuid_is_null(uu)) {
      *(_OWORD *)(*((void *)v3 + 13) + 24LL) = *(_OWORD *)uu;
    }
    uint64_t v7 = v5;
    uint64_t v8 = (const char *)v7[10];

    if (v8) {
      nw_parameters_set_effective_bundle_id(v3, v8);
    }
    int v9 = v7;
    *(_OWORD *)char v31 = *(_OWORD *)(v9 + 88);

    if (!uuid_is_null(v31)) {
      *(_OWORD *)(*((void *)v3 + 13) + 40LL) = *(_OWORD *)v31;
    }
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_log_type_t type = 136446722;
        char v26 = "nw_parameters_set_application_id";
        os_log_type_t v27 = 2112;
        BOOL v28 = v9;
        os_log_type_t v29 = 2112;
        os_log_type_t v30 = v3;
        _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_DEBUG, "%{public}s set %@ on %@", (uint8_t *)type, 0x20u);
      }
    }

    goto LABEL_12;
  }

  __nwlog_obj();
  int v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_parameters_set_application_id";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  uu[0] = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v15 = type[0];
    if (os_log_type_enabled(v12, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_set_application_id";
      _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null application_id", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (!uu[0])
  {
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type[0];
    if (os_log_type_enabled(v12, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_set_application_id";
      _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null application_id, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  BOOL v20 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v21 = type[0];
  os_log_type_t v22 = os_log_type_enabled(v12, type[0]);
  if (!v20)
  {
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_set_application_id";
      _os_log_impl(&dword_181A5C000, v12, v21, "%{public}s called with null application_id, no backtrace", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_parameters_set_application_id";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v20;
    _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null application_id, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v20);
  if (v11) {
    goto LABEL_50;
  }
LABEL_12:
}

    if (!v33) {
      goto LABEL_29;
    }
    char v31 = (char *)v33;
    goto LABEL_28;
  }

  uint64_t v5 = v3;
  uint64_t v6 = [v5 type];

  if (v6 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (id)gLogObj;
    int v14 = v5;
    char v15 = [v14 type];

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_name";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v15;
    LODWORD(v42) = 18;
    os_log_type_t v16 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (__nwlog_fault(v16, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          os_log_type_t v19 = v14;
          BOOL v20 = objc_msgSend(v19, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v20;
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v43)
      {
        os_log_type_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v22 = type;
        os_log_type_t v23 = os_log_type_enabled(v17, type);
        if (v21)
        {
          if (v23)
          {
            os_log_type_t v24 = v14;
            BOOL v25 = objc_msgSend(v24, "type", buf, v42);

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_name";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v25;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v21;
            _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v21);
          if (!v16) {
            goto LABEL_29;
          }
LABEL_27:
          char v31 = (char *)v16;
LABEL_28:
          free(v31);
          goto LABEL_29;
        }

        if (v23)
        {
          os_log_type_t v29 = v14;
          os_log_type_t v30 = objc_msgSend(v29, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v30;
          _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        char v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          os_log_type_t v27 = v14;
          BOOL v28 = objc_msgSend(v27, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v16) {
      goto LABEL_29;
    }
    goto LABEL_27;
  }

  uint64_t v7 = v5;
  uint64_t v8 = (void *)v7[33];
  if (v8)
  {
    free(v8);
    v7[33] = 0LL;
  }

  if (!a2) {
    goto LABEL_8;
  }
  int v9 = strdup(a2);
  if (v9)
  {
LABEL_7:
    v7[33] = v9;
LABEL_8:
    os_log_type_t v10 = v7;
    uint64_t v11 = (os_unfair_lock_s *)(v10 + 180);
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_endpoint_clear_description_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC93A0;
    v46 = v10;
    os_log_type_t v12 = v10;
    os_unfair_lock_lock(v11);
    __nw_endpoint_clear_description_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v11);

LABEL_29:
    return;
  }

  __nwlog_obj();
  v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  os_log_type_t v40 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v40))
  {
    free(v40);
    goto LABEL_7;
  }

  __break(1u);
}

    if (!v33) {
      goto LABEL_29;
    }
    char v31 = (char *)v33;
    goto LABEL_28;
  }

  uint64_t v5 = v3;
  uint64_t v6 = [v5 type];

  if (v6 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (id)gLogObj;
    int v14 = v5;
    char v15 = [v14 type];

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_model";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v15;
    LODWORD(v42) = 18;
    os_log_type_t v16 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (__nwlog_fault(v16, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          os_log_type_t v19 = v14;
          BOOL v20 = objc_msgSend(v19, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_model";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v20;
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v43)
      {
        os_log_type_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v22 = type;
        os_log_type_t v23 = os_log_type_enabled(v17, type);
        if (v21)
        {
          if (v23)
          {
            os_log_type_t v24 = v14;
            BOOL v25 = objc_msgSend(v24, "type", buf, v42);

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_model";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v25;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v21;
            _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v21);
          if (!v16) {
            goto LABEL_29;
          }
LABEL_27:
          char v31 = (char *)v16;
LABEL_28:
          free(v31);
          goto LABEL_29;
        }

        if (v23)
        {
          os_log_type_t v29 = v14;
          os_log_type_t v30 = objc_msgSend(v29, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_model";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v30;
          _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        char v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          os_log_type_t v27 = v14;
          BOOL v28 = objc_msgSend(v27, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_device_model";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v16) {
      goto LABEL_29;
    }
    goto LABEL_27;
  }

  uint64_t v7 = v5;
  uint64_t v8 = (void *)v7[34];
  if (v8)
  {
    free(v8);
    v7[34] = 0LL;
  }

  if (!a2) {
    goto LABEL_8;
  }
  int v9 = strdup(a2);
  if (v9)
  {
LABEL_7:
    v7[34] = v9;
LABEL_8:
    os_log_type_t v10 = v7;
    uint64_t v11 = (os_unfair_lock_s *)(v10 + 180);
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_endpoint_clear_description_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC93A0;
    v46 = v10;
    os_log_type_t v12 = v10;
    os_unfair_lock_lock(v11);
    __nw_endpoint_clear_description_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v11);

LABEL_29:
    return;
  }

  __nwlog_obj();
  v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  os_log_type_t v40 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v40))
  {
    free(v40);
    goto LABEL_7;
  }

  __break(1u);
}

    if (!v33) {
      goto LABEL_29;
    }
    char v31 = (char *)v33;
    goto LABEL_28;
  }

  uint64_t v5 = v3;
  uint64_t v6 = [v5 type];

  if (v6 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (id)gLogObj;
    int v14 = v5;
    char v15 = [v14 type];

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_contact_id";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v15;
    LODWORD(v42) = 18;
    os_log_type_t v16 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (__nwlog_fault(v16, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          os_log_type_t v19 = v14;
          BOOL v20 = objc_msgSend(v19, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_contact_id";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v20;
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v43)
      {
        os_log_type_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v22 = type;
        os_log_type_t v23 = os_log_type_enabled(v17, type);
        if (v21)
        {
          if (v23)
          {
            os_log_type_t v24 = v14;
            BOOL v25 = objc_msgSend(v24, "type", buf, v42);

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_endpoint_set_contact_id";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v25;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v21;
            _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v21);
          if (!v16) {
            goto LABEL_29;
          }
LABEL_27:
          char v31 = (char *)v16;
LABEL_28:
          free(v31);
          goto LABEL_29;
        }

        if (v23)
        {
          os_log_type_t v29 = v14;
          os_log_type_t v30 = objc_msgSend(v29, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_contact_id";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v30;
          _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        char v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          os_log_type_t v27 = v14;
          BOOL v28 = objc_msgSend(v27, "type", buf, v42);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_contact_id";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v16) {
      goto LABEL_29;
    }
    goto LABEL_27;
  }

  uint64_t v7 = v5;
  uint64_t v8 = (void *)v7[36];
  if (v8)
  {
    free(v8);
    v7[36] = 0LL;
  }

  if (!a2) {
    goto LABEL_8;
  }
  int v9 = strdup(a2);
  if (v9)
  {
LABEL_7:
    v7[36] = v9;
LABEL_8:
    os_log_type_t v10 = v7;
    uint64_t v11 = (os_unfair_lock_s *)(v10 + 180);
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_endpoint_clear_description_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC93A0;
    v46 = v10;
    os_log_type_t v12 = v10;
    os_unfair_lock_lock(v11);
    __nw_endpoint_clear_description_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v11);

LABEL_29:
    return;
  }

  __nwlog_obj();
  v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  os_log_type_t v40 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v40))
  {
    free(v40);
    goto LABEL_7;
  }

  __break(1u);
}

      if (v23) {
        free(v23);
      }
      v30[0] = MEMORY[0x1895F87A8];
      v30[1] = 0x40000000LL;
      v30[2] = __network_config_mptcp_watcher_create_block_invoke_6;
      v30[3] = &unk_189BB95D0;
      os_log_type_t v29 = *(dispatch_queue_s **)(a1 + 40);
      v30[4] = *(void *)(a1 + 32);
      dispatch_async(v29, v30);
    }
  }

    if (v14) {
      free(v14);
    }
    goto LABEL_62;
  }

  if (!v8)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v43 = 0;
    if (__nwlog_fault(v18, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null config", buf, 0xCu);
        }
      }

      else if (v43)
      {
        BOOL v28 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        os_log_type_t v30 = os_log_type_enabled(v19, type);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
            os_log_type_t v53 = 2082;
            uint64_t v54 = v28;
            _os_log_impl( &dword_181A5C000,  v19,  v29,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v28);
          goto LABEL_54;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl(&dword_181A5C000, v19, v29, "%{public}s called with null config, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v35 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v52 = "nw_connection_create_experimental_probe_configuration_block_for_protocol";
          _os_log_impl( &dword_181A5C000,  v19,  v35,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v19) {
      free(v19);
    }
    goto LABEL_12;
  }

    free(v31);
    if (!v19) {
      goto LABEL_13;
    }
    goto LABEL_79;
  }

  nw_context_assert_queue(v7[3]);
  uint64_t v11 = v7;
  os_log_type_t v12 = v8;
  nw_context_assert_queue(v7[3]);
  uint64_t v13 = (char *)(v11 + 33);
  while (1)
  {
    uint64_t v13 = *(char **)v13;
    if (!v13) {
      break;
    }
    if (nw_protocol_definition_is_equal_unsafe(*((void *)v13 + 2), (uint64_t)v12))
    {

      int v14 = _Block_copy(*((const void **)v13 + 3));
      char v15 = v14;
      if (v14)
      {
        os_log_type_t v16 = *((_DWORD *)v11 + 48);
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = ___ZL56nw_connection_deliver_metadata_changed_event_on_nw_queueP24NWConcrete_nw_connectionPU36objcproto25OS_nw_protocol_definition8NSObjectPU34objcproto23OS_nw_protocol_metadataS1__block_invoke;
        *(void *)&_BYTE buf[24] = &unk_189BC91E8;
        v51 = v14;
        v50 = v10;
        nw_connection_async_client(v11, v16, buf);

LABEL_9:
        goto LABEL_13;
      }

      __nwlog_obj();
      os_log_type_t v36 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
      uint64_t v37 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v47 = 0;
      if (__nwlog_fault(v37, &type, &v47))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
            _os_log_impl(&dword_181A5C000, v38, v39, "%{public}s called with null handler_copy", buf, 0xCu);
          }

          goto LABEL_85;
        }

        if (v47)
        {
          os_log_type_t v40 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v41 = type;
          v42 = os_log_type_enabled(v38, type);
          if (v40)
          {
            if (v42)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v40;
              _os_log_impl( &dword_181A5C000,  v38,  v41,  "%{public}s called with null handler_copy, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v40);
            goto LABEL_86;
          }

          if (v42)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
            _os_log_impl( &dword_181A5C000,  v38,  v41,  "%{public}s called with null handler_copy, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v46 = type;
          if (os_log_type_enabled(v38, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
            _os_log_impl( &dword_181A5C000,  v38,  v46,  "%{public}s called with null handler_copy, backtrace limit exceeded",  buf,  0xCu);
          }
        }

      free(backtrace_string);
      goto LABEL_68;
    }

    os_log_type_t v27 = (os_log_s *)__nwlog_obj();
    BOOL v28 = type;
    if (!os_log_type_enabled(v27, (os_log_type_t)type)) {
      goto LABEL_68;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
    os_log_type_t v29 = "%{public}s called with null protocol";
LABEL_67:
    _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
LABEL_68:
    if (v26) {
      free(v26);
    }
    return 0LL;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
    char v26 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v70) = 0;
    if (type == 17)
    {
      os_log_type_t v27 = (os_log_s *)__nwlog_obj();
      BOOL v28 = type;
      if (!os_log_type_enabled(v27, (os_log_type_t)type)) {
        goto LABEL_68;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
      os_log_type_t v29 = "%{public}s called with null demux";
      goto LABEL_67;
    }

    if (!(_BYTE)v70)
    {
      os_log_type_t v27 = (os_log_s *)__nwlog_obj();
      BOOL v28 = type;
      if (!os_log_type_enabled(v27, (os_log_type_t)type)) {
        goto LABEL_68;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
      os_log_type_t v29 = "%{public}s called with null demux, backtrace limit exceeded";
      goto LABEL_67;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v27 = (os_log_s *)__nwlog_obj();
    BOOL v28 = type;
    v33 = os_log_type_enabled(v27, (os_log_type_t)type);
    if (backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v32 = "%{public}s called with null demux, dumping backtrace:%{public}s";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (!v33) {
      goto LABEL_68;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_demux_get_input_frames";
    os_log_type_t v29 = "%{public}s called with null demux, no backtrace";
    goto LABEL_67;
  }

  int v9 = a5;
  os_log_type_t v10 = a4;
  handle[89] = 0;
  output_handler = a1->output_handler;
  if (a1->default_input_handler == a2)
  {
    output_handler_context = 0LL;
    int v14 = handle + 64;
    if (*((void *)handle + 8)) {
      return nw_frame_array_fill_from_pending_array(v14, (uint64_t)a6, a4, a5);
    }
    goto LABEL_8;
  }

  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    int v14 = output_handler_context + 4;
    if (output_handler_context[4]) {
      return nw_frame_array_fill_from_pending_array(v14, (uint64_t)a6, a4, a5);
    }
LABEL_8:
    os_log_type_t v16 = *((void *)handle + 10);
    if (!v16 || !*(_DWORD *)(v16 + 40)) {
      return nw_protocol_get_input_frames((uint64_t)output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
    }
    v78[0] = 0LL;
    v78[1] = v78;
    nw_protocol_get_input_frames((uint64_t)output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)v78);
    BOOL v17 = v78[0];
    if (v78[0])
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      _BYTE buf[24] = 0;
      os_log_type_t type = 0LL;
      p_os_log_type_t type = &type;
      v76 = 0x2000000000LL;
      v77 = 0;
      v70 = 0LL;
      v71 = &v70;
      v73 = 0;
      v72 = 0x2000000000LL;
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 0x40000000LL;
      v59 = ___ZL34nw_protocol_demux_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
      v60 = &unk_189BB9DF0;
      v65 = handle;
      v66 = output_handler_context;
      v67 = a6;
      char v61 = &v70;
      os_log_type_t v62 = buf;
      v68 = a2;
      uint64_t v69 = a1;
      v63 = &type;
      char v64 = v78;
      do
      {
        if (!v17) {
          break;
        }
        os_log_type_t v18 = *(void *)(v17 + 32);
        os_log_type_t v19 = ((uint64_t (*)(void *))v59)(v58);
        BOOL v17 = v18;
      }

      while ((v19 & 1) != 0);
      if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
      {
        BOOL v20 = (char *)*((void *)handle + 10);
        v57[0] = MEMORY[0x1895F87A8];
        v57[1] = 0x40000000LL;
        v57[2] = ___ZL34nw_protocol_demux_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_30;
        v57[3] = &__block_descriptor_tmp_31_25795;
        v57[4] = handle;
        nw_hash_table_apply(v20, (uint64_t)v57);
      }

      if (!*((_BYTE *)p_type + 24)) {
        goto LABEL_21;
      }
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        callbacks = default_input_handler->callbacks;
        if (callbacks)
        {
          input_available = (void (*)(void))callbacks->input_available;
          if (input_available)
          {
            input_available();
LABEL_21:
            os_log_type_t v24 = *((unsigned int *)v71 + 6);
            if (!(_DWORD)v24)
            {
              if ((*(_BYTE *)(*(void *)&buf[8] + 24LL) || *((_BYTE *)p_type + 24)) && *v14) {
                os_log_type_t v24 = nw_frame_array_fill_from_pending_array(v14, (uint64_t)a6, v10, v9);
              }
              else {
                os_log_type_t v24 = 0LL;
              }
            }

            _Block_object_dispose(&v70, 8);
            _Block_object_dispose(&type, 8);
            _Block_object_dispose(buf, 8);
            return v24;
          }
        }
      }

      __nwlog_obj();
      uint64_t v34 = a1->default_input_handler;
      __int16 v35 = "invalid";
      if (v34)
      {
        identifier = v34->identifier;
        if (identifier) {
          __int16 v35 = (const char *)identifier;
        }
      }

      v79 = 136446466;
      v80 = "nw_protocol_demux_get_input_frames";
      v81 = 2082;
      v82 = v35;
      uint64_t v37 = (char *)_os_log_send_and_compose_impl();
      v56 = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (__nwlog_fault(v37, &v56, &v55))
      {
        if (v56 == OS_LOG_TYPE_FAULT)
        {
          v38 = (os_log_s *)__nwlog_obj();
          v39 = v56;
          if (!os_log_type_enabled(v38, v56)) {
            goto LABEL_91;
          }
          os_log_type_t v40 = a1->default_input_handler;
          BOOL v41 = "invalid";
          if (v40)
          {
            v42 = v40->identifier;
            if (v42) {
              BOOL v41 = (const char *)v42;
            }
          }

          v79 = 136446466;
          v80 = "nw_protocol_demux_get_input_frames";
          v81 = 2082;
          v82 = v41;
          os_log_type_t v43 = "%{public}s protocol %{public}s has invalid input_available callback";
          goto LABEL_90;
        }

        if (!v55)
        {
          v38 = (os_log_s *)__nwlog_obj();
          v39 = v56;
          if (!os_log_type_enabled(v38, v56)) {
            goto LABEL_91;
          }
          v49 = a1->default_input_handler;
          v50 = "invalid";
          if (v49)
          {
            v51 = v49->identifier;
            if (v51) {
              v50 = (const char *)v51;
            }
          }

          v79 = 136446466;
          v80 = "nw_protocol_demux_get_input_frames";
          v81 = 2082;
          v82 = v50;
          os_log_type_t v43 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
          goto LABEL_90;
        }

        BOOL v44 = (char *)__nw_create_backtrace_string();
        v38 = (os_log_s *)__nwlog_obj();
        v39 = v56;
        v45 = os_log_type_enabled(v38, v56);
        if (v44)
        {
          if (v45)
          {
            v46 = a1->default_input_handler;
            v47 = "invalid";
            if (v46)
            {
              v48 = v46->identifier;
              if (v48) {
                v47 = (const char *)v48;
              }
            }

            v79 = 136446722;
            v80 = "nw_protocol_demux_get_input_frames";
            v81 = 2082;
            v82 = v47;
            v83 = 2082;
            v84 = v44;
            _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s",  (uint8_t *)&v79,  0x20u);
          }

          free(v44);
          goto LABEL_91;
        }

        if (v45)
        {
          os_log_type_t v52 = a1->default_input_handler;
          os_log_type_t v53 = "invalid";
          if (v52)
          {
            uint64_t v54 = v52->identifier;
            if (v54) {
              os_log_type_t v53 = (const char *)v54;
            }
          }

          v79 = 136446466;
          v80 = "nw_protocol_demux_get_input_frames";
          v81 = 2082;
          v82 = v53;
          os_log_type_t v43 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_90:
          _os_log_impl(&dword_181A5C000, v38, v39, v43, (uint8_t *)&v79, 0x16u);
        }
      }

      if (v15 == 4001) {
        goto LABEL_129;
      }
      goto LABEL_49;
    }

    __nwlog_obj();
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v173 = "nw_endpoint_proxy_add_config_if_applicable";
    v76 = (char *)_os_log_send_and_compose_impl();

    v163[0] = OS_LOG_TYPE_ERROR;
    v171 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v76, v163, &v171))
    {
      if (v163[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v78 = v163[0];
        if (os_log_type_enabled(v77, v163[0]))
        {
          *(_DWORD *)buf = 136446210;
          v173 = "nw_endpoint_proxy_add_config_if_applicable";
          _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s called with null endpoint_proxy->parsed_proxy_configs",  buf,  0xCu);
        }
      }

      else
      {
        if (v171)
        {
          v83 = v14;
          v84 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v86 = v163[0];
          v87 = os_log_type_enabled(v85, v163[0]);
          if (v84)
          {
            if (v87)
            {
              *(_DWORD *)buf = 136446466;
              v173 = "nw_endpoint_proxy_add_config_if_applicable";
              v174 = 2082;
              v175 = v84;
              _os_log_impl( &dword_181A5C000,  v85,  v86,  "%{public}s called with null endpoint_proxy->parsed_proxy_configs, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            int v14 = v83;
            free(v84);
          }

          else
          {
            if (v87)
            {
              *(_DWORD *)buf = 136446210;
              v173 = "nw_endpoint_proxy_add_config_if_applicable";
              _os_log_impl( &dword_181A5C000,  v85,  v86,  "%{public}s called with null endpoint_proxy->parsed_proxy_configs, no backtrace",  buf,  0xCu);
            }

            int v14 = v83;
          }

          goto LABEL_97;
        }

        __nwlog_obj();
        v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v89 = v163[0];
        if (os_log_type_enabled(v77, v163[0]))
        {
          *(_DWORD *)buf = 136446210;
          v173 = "nw_endpoint_proxy_add_config_if_applicable";
          _os_log_impl( &dword_181A5C000,  v77,  v89,  "%{public}s called with null endpoint_proxy->parsed_proxy_configs, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      if (v23) {
        free(v23);
      }
      *((_DWORD *)a1 + 6) = 0;
LABEL_51:
      nw_frame_reset(v60[3], (uint64_t)v9, v2, 0LL, 0LL);
      nw_frame_set_buffer_used_malloc(v60[3], 1);
      *((void *)v64 + 3) = v60[3];
      if (!gLogDatapath) {
        goto LABEL_52;
      }
      v47 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
      {
        v48 = *((void *)v64 + 3);
        buf = 136446722;
        v68 = "nw_frame_cache_create_frame";
        uint64_t v69 = 2048;
        v70 = v48;
        v71 = 1024;
        LODWORD(v72) = v2;
        os_log_type_t v18 = "%{public}s reused bufferless frame %p, allocated buffer of length %u";
        os_log_type_t v19 = v47;
        BOOL v20 = 28;
        goto LABEL_78;
      }

      goto LABEL_7;
    }

    if (gLogDatapath)
    {
      v49 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        buf = 136446466;
        v68 = "nw_frame_cache_create_frame";
        uint64_t v69 = 1024;
        LODWORD(v70) = v2;
        _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s no frame to reuse for length %u",  (uint8_t *)&buf,  0x12u);
      }
    }

    os_log_type_t v16 = nw_frame_create(*((_DWORD *)a1 + 9), (uint64_t)v9, v2, 0LL, 0LL);
    *((void *)v64 + 3) = v16;
    if (v16)
    {
      *(_WORD *)(v16 + 204) |= 1u;
      if (!gLogDatapath)
      {
LABEL_52:
        v39 = *((void *)v64 + 3);
LABEL_53:
        _Block_object_dispose(&v59, 8);
        _Block_object_dispose(v63, 8);
        return v39;
      }

      BOOL v17 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        buf = 136446466;
        v68 = "nw_frame_cache_create_frame";
        uint64_t v69 = 1024;
        LODWORD(v70) = v2;
        os_log_type_t v18 = "%{public}s allocated new frame of length %u";
        os_log_type_t v19 = v17;
        BOOL v20 = 18;
LABEL_78:
        _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_DEBUG, v18, (uint8_t *)&buf, v20);
      }
    }
  }

  else
  {
    if (!minimize_logging)
    {
      os_log_type_t v29 = v11;
      os_log_type_t v30 = *((_BYTE *)v29 + 268);

      if ((v30 & 0x20) != 0) {
        goto LABEL_49;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        char v31 = v29;

        uint64_t v32 = v31;
        v33 = *((_BYTE *)v29 + 268);

        if ((v33 & 1) != 0) {
          uint64_t v34 = "dry-run ";
        }
        else {
          uint64_t v34 = "";
        }
        loga = nw_endpoint_handler_copy_endpoint(v32);
        __int16 v35 = nw_endpoint_get_logging_description(loga);
        os_log_type_t v36 = v32;
        uint64_t v37 = v36;
        v38 = v36[30];
        else {
          v39 = off_189BBBBF0[v38];
        }

        os_log_type_t v43 = v37;
        BOOL v44 = v43;
        v45 = "path";
        switch(v11[29])
        {
          case 0u:
            break;
          case 1u:
            v45 = "resolver";
            break;
          case 2u:
            v45 = nw_endpoint_flow_mode_string(v43[31]);
            break;
          case 3u:
            v45 = "proxy";
            break;
          case 4u:
            v45 = "fallback";
            break;
          case 5u:
            v45 = "transform";
            break;
          default:
            v45 = "unknown-mode";
            break;
        }

        v49 = v44;
        os_unfair_lock_lock((os_unfair_lock_t)v49 + 28);
        v50 = v49[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v49 + 28);

        v51 = v50;
        *(_DWORD *)buf = 136448002;
        v147 = "nw_endpoint_resolver_handle_alternative";
        v148 = 2082;
        id_str = (char *)(v31 + 42);
        v150 = 2082;
        v151 = v34;
        v152 = 2082;
        v153 = v35;
        v154 = 2082;
        v155 = v39;
        v156 = 2082;
        v157 = v45;
        v158 = 2114;
        v159 = v51;
        v160 = 2082;
        v161 = nw_endpoint_get_logging_description(v142);
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Discovered alternative %{public}s",  buf,  0x52u);
      }

      goto LABEL_48;
    }

    if ((nw_endpoint_handler_get_logging_disabled(v11) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v120 = nw_endpoint_handler_get_id_string(v11);
        v121 = nw_endpoint_handler_dry_run_string(v11);
        v122 = nw_endpoint_handler_copy_endpoint(v11);
        v123 = nw_endpoint_get_logging_description(v122);
        v124 = nw_endpoint_handler_state_string(v11);
        v125 = nw_endpoint_handler_mode_string(v11);
        v126 = nw_endpoint_handler_copy_current_path(v11);
        *(_DWORD *)buf = 136448002;
        v147 = "nw_endpoint_resolver_handle_alternative";
        v148 = 2082;
        id_str = (char *)v120;
        v150 = 2082;
        v151 = v121;
        v152 = 2082;
        v153 = v123;
        v154 = 2082;
        v155 = v124;
        v156 = 2082;
        v157 = v125;
        v158 = 2114;
        v159 = v126;
        v160 = 2082;
        v161 = nw_endpoint_get_logging_description(v142);
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Discovered alternative %{public}s",  buf,  0x52u);
      }

      goto LABEL_48;
    }
  }

    if (v23) {
      free(v23);
    }
    goto LABEL_30;
  }

  if (v1->mode != 3)
  {
    if ((*((_BYTE *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)v2 + 268) & 1) != 0) {
          uint64_t v5 = "dry-run ";
        }
        else {
          uint64_t v5 = "";
        }
        uint64_t v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        state = v2->state;
        int v9 = logging_description;
        else {
          os_log_type_t v10 = off_189BBBBF0[state];
        }
        os_log_type_t v30 = v10;
        uint64_t v11 = v2;
        os_log_type_t v12 = (os_unfair_lock_s *)v11;
        uint64_t v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v13 = "resolver";
            break;
          case 2:
            uint64_t v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            uint64_t v13 = "proxy";
            break;
          case 4:
            uint64_t v13 = "fallback";
            break;
          case 5:
            uint64_t v13 = "transform";
            break;
          default:
            uint64_t v13 = "unknown-mode";
            break;
        }

        int v14 = v12 + 28;
        char v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        os_log_type_t v16 = v15[8];
        os_unfair_lock_unlock(v14);

        BOOL v17 = v16;
        os_log_type_t v18 = v15;
        os_log_type_t v19 = v18;
        BOOL v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            BOOL v20 = "resolver";
            break;
          case 2:
            BOOL v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            BOOL v20 = "proxy";
            break;
          case 4:
            BOOL v20 = "fallback";
            break;
          case 5:
            BOOL v20 = "transform";
            break;
          default:
            BOOL v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        uint64_t v34 = "nw_endpoint_handler_copy_proxy";
        __int16 v35 = 2082;
        id_str = v2->id_str;
        uint64_t v37 = 2082;
        v38 = v5;
        v39 = 2082;
        os_log_type_t v40 = v9;
        BOOL v41 = 2082;
        v42 = v30;
        os_log_type_t v43 = 2082;
        BOOL v44 = v13;
        v45 = 2114;
        v46 = v17;
        v47 = 2082;
        v48 = v20;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public}s, not a proxy",  buf,  0x52u);
      }
    }

    if (v23) {
      free(v23);
    }
    goto LABEL_30;
  }

  if (v1->mode != 4)
  {
    if ((*((_BYTE *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)v2 + 268) & 1) != 0) {
          uint64_t v5 = "dry-run ";
        }
        else {
          uint64_t v5 = "";
        }
        uint64_t v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        state = v2->state;
        int v9 = logging_description;
        else {
          os_log_type_t v10 = off_189BBBBF0[state];
        }
        os_log_type_t v30 = v10;
        uint64_t v11 = v2;
        os_log_type_t v12 = (os_unfair_lock_s *)v11;
        uint64_t v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v13 = "resolver";
            break;
          case 2:
            uint64_t v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            uint64_t v13 = "proxy";
            break;
          case 4:
            uint64_t v13 = "fallback";
            break;
          case 5:
            uint64_t v13 = "transform";
            break;
          default:
            uint64_t v13 = "unknown-mode";
            break;
        }

        int v14 = v12 + 28;
        char v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        os_log_type_t v16 = v15[8];
        os_unfair_lock_unlock(v14);

        BOOL v17 = v16;
        os_log_type_t v18 = v15;
        os_log_type_t v19 = v18;
        BOOL v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            BOOL v20 = "resolver";
            break;
          case 2:
            BOOL v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            BOOL v20 = "proxy";
            break;
          case 4:
            BOOL v20 = "fallback";
            break;
          case 5:
            BOOL v20 = "transform";
            break;
          default:
            BOOL v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        uint64_t v34 = "nw_endpoint_handler_copy_fallback";
        __int16 v35 = 2082;
        id_str = v2->id_str;
        uint64_t v37 = 2082;
        v38 = v5;
        v39 = 2082;
        os_log_type_t v40 = v9;
        BOOL v41 = 2082;
        v42 = v30;
        os_log_type_t v43 = 2082;
        BOOL v44 = v13;
        v45 = 2114;
        v46 = v17;
        v47 = 2082;
        v48 = v20;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public}s, not fallback",  buf,  0x52u);
      }
    }

  if (v27) {
    free(v27);
  }
LABEL_19:
}

    if (v4) {
      goto LABEL_49;
    }
    return;
  }

  __nwlog_obj();
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_link_get_local_congestion_info";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v16 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "nw_link_get_local_congestion_info";
    uint64_t v7 = "%{public}s called with null ce_count";
    goto LABEL_46;
  }

  if (!v16)
  {
    __nwlog_obj();
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v19 = "nw_link_get_local_congestion_info";
      uint64_t v7 = "%{public}s called with null ce_count, backtrace limit exceeded";
      goto LABEL_46;
    }

    goto LABEL_47;
  }

  os_log_type_t v12 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v6 = type;
  uint64_t v13 = os_log_type_enabled(v5, type);
  if (!v12)
  {
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v19 = "nw_link_get_local_congestion_info";
      uint64_t v7 = "%{public}s called with null ce_count, no backtrace";
      goto LABEL_46;
    }

    goto LABEL_47;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v19 = "nw_link_get_local_congestion_info";
    BOOL v20 = 2082;
    os_log_type_t v21 = v12;
    int v14 = "%{public}s called with null ce_count, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v5, v6, v14, buf, 0x16u);
  }

    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_49;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        BOOL v17 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v18 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          char v31 = " ";
          LOWORD(v32) = 1024;
          *(_DWORD *)((char *)&v32 + 2) = v18;
          _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }

    if (*((_DWORD *)handle + 111) != 4 && (handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v5 = *((_DWORD *)handle + 115);
        uint64_t v6 = *((_DWORD *)handle + 111);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        char v31 = " ";
        LOWORD(v32) = 1024;
        *(_DWORD *)((char *)&v32 + 2) = v5;
        HIWORD(v32) = 1024;
        LODWORD(v33) = v6;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> output_available called in state %d",  buf,  0x2Cu);
      }
    }

    if (!*((_DWORD *)handle + 112))
    {
      uint64_t v7 = *((void *)handle + 24);
      uint64_t v8 = MEMORY[0x1895F87A8];
      if (v7)
      {
        if (*(void *)(v7 + 16) != *(void *)(v7 + 24))
        {
          int v9 = nw_array_create();
          os_log_type_t v10 = (unsigned __int8 *)*((void *)handle + 24);
          *(void *)buf = v8;
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke;
          char v31 = (const char *)&__block_descriptor_tmp_37_33692;
          uint64_t v32 = handle;
          v33 = v9;
          nw_array_apply(v10, (uint64_t)buf);
          *(void *)os_log_type_t type = v8;
          char v26 = 0x40000000LL;
          os_log_type_t v27 = ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_38;
          BOOL v28 = &__block_descriptor_tmp_39_33693;
          os_log_type_t v29 = handle;
          nw_array_apply((unsigned __int8 *)v9, (uint64_t)type);
          if (v9) {
            os_release((void *)v9);
          }
        }
      }

      uint64_t v11 = (char *)*((void *)handle + 23);
      if (v11)
      {
        v23[0] = v8;
        v23[1] = 0x40000000LL;
        v23[2] = ___ZL49nw_protocol_webtransport_session_output_availableP11nw_protocolS0__block_invoke;
        v23[3] = &__block_descriptor_tmp_58_33694;
        v23[4] = a1;
        nw_hash_table_apply(v11, (uint64_t)v23);
      }

      os_log_type_t v12 = (void *)*((void *)handle + 53);
      if (v12) {
        nw_protocol_output_available(v12, (uint64_t)a1);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v24 = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    int v14 = (os_log_s *)__nwlog_obj();
    char v15 = type[0];
    if (!os_log_type_enabled(v14, type[0])) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
    os_log_type_t v16 = "%{public}s called with null webtransport_session";
    goto LABEL_48;
  }

  if (!v24)
  {
    int v14 = (os_log_s *)__nwlog_obj();
    char v15 = type[0];
    if (!os_log_type_enabled(v14, type[0])) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
    os_log_type_t v16 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_48;
  }

  os_log_type_t v21 = (char *)__nw_create_backtrace_string();
  int v14 = (os_log_s *)__nwlog_obj();
  char v15 = type[0];
  os_log_type_t v22 = os_log_type_enabled(v14, type[0]);
  if (!v21)
  {
    if (!v22) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
    os_log_type_t v16 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_48;
  }

  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_output_available";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v21;
    _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v21);
  if (v13) {
    goto LABEL_50;
  }
}

  if (v6) {
LABEL_49:
  }
    free(v6);
}

            ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
            os_log_type_t v43 = *(void *)(a1 + 72);
            *(void *)(v11 + 32) = 0LL;
            BOOL v44 = *(uint64_t **)(v43 + 8);
            *(void *)(v11 + 40) = v44;
            *BOOL v44 = v11;
            *(void *)(v43 + 8) = v11 + 32;
            return 1LL;
          }
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v25 = *(void *)(a1 + 56);
        if (v25) {
          char v26 = (const char *)(v25 + 205);
        }
        else {
          char v26 = "";
        }
        *(_DWORD *)buf = 136446978;
        char v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
        v65 = 2082;
        v66 = (void *)v26;
        v67 = 1024;
        v68 = v14;
        uint64_t v69 = 1024;
        v70 = v8;
        os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v61 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v28 = (os_log_s *)__nwlog_obj();
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            os_log_type_t v30 = *(void *)(a1 + 56);
            if (v30) {
              char v31 = (const char *)(v30 + 205);
            }
            else {
              char v31 = "";
            }
            *(_DWORD *)buf = 136446978;
            char v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            v65 = 2082;
            v66 = (void *)v31;
            v67 = 1024;
            v68 = v14;
            uint64_t v69 = 1024;
            v70 = v8;
            uint64_t v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame";
LABEL_66:
            _os_log_impl(&dword_181A5C000, v28, v29, v32, buf, 0x22u);
          }
        }

        else if (v61)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          BOOL v28 = (os_log_s *)__nwlog_obj();
          os_log_type_t v29 = type;
          os_log_type_t v36 = os_log_type_enabled(v28, type);
          if (backtrace_string)
          {
            if (v36)
            {
              uint64_t v37 = *(void *)(a1 + 56);
              if (v37) {
                v38 = (const char *)(v37 + 205);
              }
              else {
                v38 = "";
              }
              *(_DWORD *)buf = 136447234;
              char v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
              v65 = 2082;
              v66 = (void *)v38;
              v67 = 1024;
              v68 = v14;
              uint64_t v69 = 1024;
              v70 = v8;
              v71 = 2082;
              v72 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_cr eate_input_frame, dumping backtrace:%{public}s",  buf,  0x2Cu);
            }

            free(backtrace_string);
            goto LABEL_67;
          }

          if (v36)
          {
            v48 = *(void *)(a1 + 56);
            if (v48) {
              v49 = (const char *)(v48 + 205);
            }
            else {
              v49 = "";
            }
            *(_DWORD *)buf = 136446978;
            char v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            v65 = 2082;
            v66 = (void *)v49;
            v67 = 1024;
            v68 = v14;
            uint64_t v69 = 1024;
            v70 = v8;
            uint64_t v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame, no backtrace";
            goto LABEL_66;
          }
        }

        else
        {
          BOOL v28 = (os_log_s *)__nwlog_obj();
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            v46 = *(void *)(a1 + 56);
            if (v46) {
              v47 = (const char *)(v46 + 205);
            }
            else {
              v47 = "";
            }
            *(_DWORD *)buf = 136446978;
            char v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            v65 = 2082;
            v66 = (void *)v47;
            v67 = 1024;
            v68 = v14;
            uint64_t v69 = 1024;
            v70 = v8;
            uint64_t v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame, backtrace limit exceeded";
            goto LABEL_66;
          }
        }

          if (!v21)
          {
LABEL_50:
            os_log_type_t v24 = 0LL;
            goto LABEL_51;
          }

    free(v8);
    goto LABEL_49;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  uint64_t v32 = 0;
  if (__nwlog_fault(v12, type, &v32))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      int v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null msg", buf, 0xCu);
      }
    }

    else if (v32)
    {
      char v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type[0];
      BOOL v17 = os_log_type_enabled(v13, type[0]);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v15;
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null msg, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        if (v12) {
          goto LABEL_40;
        }
        goto LABEL_51;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null msg, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      BOOL v25 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "-[NWPrivilegedHelper startXPCListener]_block_invoke";
        _os_log_impl(&dword_181A5C000, v13, v25, "%{public}s called with null msg, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

  if (v12) {
LABEL_40:
  }
    free(v12);
LABEL_51:
}

        goto LABEL_49;
      }

      if (!(_BYTE)v33)
      {
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          os_log_type_t v24 = "%{public}s called with null canvas, backtrace limit exceeded";
          goto LABEL_47;
        }

        goto LABEL_48;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type[0];
      os_log_type_t v27 = os_log_type_enabled(v22, type[0]);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          os_log_type_t v24 = "%{public}s called with null canvas, no backtrace";
          goto LABEL_47;
        }

        goto LABEL_48;
      }

      if (!v27) {
        goto LABEL_36;
      }
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
      *(_WORD *)&applier[12] = 2082;
      *(void *)&applier[14] = backtrace_string;
      BOOL v28 = "%{public}s called with null canvas, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

    goto LABEL_49;
  }

  if (v9)
  {
    uint64_t v11 = nw_connection_copy_current_path(v9);
    os_log_type_t v12 = v11;
    if (v11)
    {
      uint64_t v13 = v11;
      if (nw_path_network_is_satisfied_update_reason(v13, 0LL))
      {
        effective_traffic_class = v13->effective_traffic_class;
        if (!effective_traffic_class) {
          effective_traffic_class = nw_parameters_get_traffic_class(v13->parameters);
        }
      }

      else
      {
        effective_traffic_class = 0;
      }
    }

    else
    {
      effective_traffic_class = 0;
    }

    traffic_class = nw_parameters_get_traffic_class(v10);
    if (traffic_class != effective_traffic_class)
    {
      os_log_type_t v16 = traffic_class;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v17 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        __int16 v35 = "nw_service_connector_apply_user_parameters";
        os_log_type_t v36 = 2114;
        uint64_t v37 = v7;
        v38 = 1024;
        v39 = v16;
        os_log_type_t v40 = 2114;
        BOOL v41 = v9;
        v42 = 2114;
        os_log_type_t v43 = v8;
        _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ resetting traffic class to %u for connection %{public}@ for %{public}@",  buf,  0x30u);
      }

      nw_connection_reset_traffic_class(v9, v16);
    }

    goto LABEL_15;
  }

  __nwlog_obj();
  os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v35 = "nw_service_connector_apply_user_parameters";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v32 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_service_connector_apply_user_parameters";
      _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null acceptedConnection", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (!v32)
  {
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v31 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_service_connector_apply_user_parameters";
      _os_log_impl( &dword_181A5C000,  v20,  v31,  "%{public}s called with null acceptedConnection, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  os_log_type_t v27 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v28 = type;
  os_log_type_t v29 = os_log_type_enabled(v20, type);
  if (!v27)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "nw_service_connector_apply_user_parameters";
      _os_log_impl( &dword_181A5C000,  v20,  v28,  "%{public}s called with null acceptedConnection, no backtrace",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v35 = "nw_service_connector_apply_user_parameters";
    os_log_type_t v36 = 2082;
    uint64_t v37 = v27;
    _os_log_impl( &dword_181A5C000,  v20,  v28,  "%{public}s called with null acceptedConnection, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v27);
  if (v19) {
    goto LABEL_50;
  }
LABEL_15:
}

  if (v19) {
    free(v19);
  }
  return 0LL;
}

  if (v19) {
    free(v19);
  }
  return 0LL;
}

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_disconnect";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnect";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_disconnect";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnect";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnect";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_disconnect";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_disconnect";
      os_log_type_t v16 = "%{public}s disconnect requires an output handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_disconnect";
      os_log_type_t v16 = "%{public}s disconnect requires an output handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_disconnect";
      os_log_type_t v16 = "%{public}s disconnect requires an output handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_disconnect";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s disconnect requires an output handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a1 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7) {
      *(void *)(a1 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 32);
    if (v9)
    {
      v9(v3, a1);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_disconnect";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_disconnect";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_disconnect";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_disconnect";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_disconnect";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_disconnected";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnected";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_disconnected";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnected";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnected";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_disconnected";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_disconnected";
      os_log_type_t v16 = "%{public}s disconnected requires a default input handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_disconnected";
      os_log_type_t v16 = "%{public}s disconnected requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_disconnected";
      os_log_type_t v16 = "%{public}s disconnected requires a default input handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_disconnected";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s disconnected requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a1 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7) {
      *(void *)(a1 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
    if (v9)
    {
      v9(v3, a1);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_disconnected";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_disconnected";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_disconnected";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_disconnected";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_disconnected";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_input_available";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_available";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_input_available";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_available";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_available";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_input_available";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_available";
      os_log_type_t v16 = "%{public}s input_available requires a default input handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_available";
      os_log_type_t v16 = "%{public}s input_available requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_available";
      os_log_type_t v16 = "%{public}s input_available requires a default input handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_input_available";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s input_available requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a1 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7) {
      *(void *)(a1 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 64);
    if (v9)
    {
      v9(v3, a1);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_input_available";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_available";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_available";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_input_available";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_available";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_output_available";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_available";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_output_available";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_available";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_available";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_output_available";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_output_available";
      os_log_type_t v16 = "%{public}s output_available requires a default input handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_output_available";
      os_log_type_t v16 = "%{public}s output_available requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_output_available";
      os_log_type_t v16 = "%{public}s output_available requires a default input handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_output_available";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s output_available requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a2 + 88);
    if (v7) {
      *(void *)(a2 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 72);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_output_available";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_output_available";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_output_available";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_output_available";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_output_available";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_input_finished";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_finished";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_input_finished";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_finished";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_finished";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_input_finished";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_finished";
      os_log_type_t v16 = "%{public}s input_finished requires a default input handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_finished";
      os_log_type_t v16 = "%{public}s input_finished requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_finished";
      os_log_type_t v16 = "%{public}s input_finished requires a default input handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_input_finished";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s input_finished requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a2 + 88);
    if (v7) {
      *(void *)(a2 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 184);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_input_finished";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_finished";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_finished";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_input_finished";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_finished";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_output_finished";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_finished";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_output_finished";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_finished";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_finished";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_output_finished";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_output_finished";
      os_log_type_t v16 = "%{public}s output_finished requires an output handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_output_finished";
      os_log_type_t v16 = "%{public}s output_finished requires an output handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_output_finished";
      os_log_type_t v16 = "%{public}s output_finished requires an output handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_output_finished";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s output_finished requires an output handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a2 + 88);
    if (v7) {
      *(void *)(a2 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 192);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_output_finished";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_output_finished";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_output_finished";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_output_finished";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_output_finished";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_input_flush";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_flush";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_input_flush";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_flush";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_flush";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_input_flush";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_flush";
      os_log_type_t v16 = "%{public}s input_flush requires a default input handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_flush";
      os_log_type_t v16 = "%{public}s input_flush requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_input_flush";
      os_log_type_t v16 = "%{public}s input_flush requires a default input handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_input_flush";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s input_flush requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a2 + 88);
    if (v7) {
      *(void *)(a2 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 264);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_input_flush";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_flush";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_flush";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_input_flush";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid input_flush callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_input_flush";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

    if (!v3) {
      return;
    }
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_error";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        uint64_t v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_protocol_common_error";
            BOOL v41 = 2082;
            v42 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

          goto LABEL_33;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

    goto LABEL_48;
  }

  id v3 = *(void *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_protocol_common_error";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_error";
      os_log_type_t v16 = "%{public}s error requires a default input handler";
      goto LABEL_47;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)gLogObj;
      char v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_error";
      os_log_type_t v16 = "%{public}s error requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)gLogObj;
    char v15 = type;
    os_log_type_t v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "nw_protocol_common_error";
      os_log_type_t v16 = "%{public}s error requires a default input handler, no backtrace";
      goto LABEL_47;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v40 = "nw_protocol_common_error";
      BOOL v41 = 2082;
      v42 = backtrace_string;
      os_log_type_t v19 = "%{public}s error requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v5 = *(void *)(v3 + 88);
    if (v5) {
      *(void *)(v3 + 88) = v5 + 1;
    }
  }

  uint64_t v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a2 + 88);
    if (v7) {
      *(void *)(a2 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(v3 + 24);
  if (v8)
  {
    int v9 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  os_log_type_t v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v40 = "__nw_protocol_error";
  if (!v24) {
    os_log_type_t v24 = "invalid";
  }
  BOOL v41 = 2082;
  v42 = (void *)v24;
  os_log_type_t v43 = 2048;
  BOOL v44 = v3;
  BOOL v25 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      BOOL v28 = *(const char **)(v3 + 16);
      if (!v28) {
        BOOL v28 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_error";
      BOOL v41 = 2082;
      v42 = (void *)v28;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid error callback";
      goto LABEL_94;
    }

    if (!v37)
    {
      char v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_95;
      }
      __int16 v35 = *(const char **)(v3 + 16);
      if (!v35) {
        __int16 v35 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_error";
      BOOL v41 = 2082;
      v42 = (void *)v35;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
      goto LABEL_94;
    }

    os_log_type_t v30 = (char *)__nw_create_backtrace_string();
    char v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = *(const char **)(v3 + 16);
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v40 = "__nw_protocol_error";
        BOOL v41 = 2082;
        v42 = (void *)v32;
        os_log_type_t v43 = 2048;
        BOOL v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v30);
      goto LABEL_95;
    }

    if (v31)
    {
      os_log_type_t v36 = *(const char **)(v3 + 16);
      if (!v36) {
        os_log_type_t v36 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v40 = "__nw_protocol_error";
      BOOL v41 = 2082;
      v42 = (void *)v36;
      os_log_type_t v43 = 2048;
      BOOL v44 = v3;
      os_log_type_t v29 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v26, v27, v29, buf, 0x20u);
    }
  }

  if (v16) {
    free(v16);
  }
  return 0LL;
}

  if (v16) {
    free(v16);
  }
  return 0LL;
}

    if (v24) {
      free(v24);
    }
    goto LABEL_30;
  }

  *((_DWORD *)v5 + 3) = 0;
  objc_storeStrong(v5 + 2, a1);
  v6[6] = 0LL;
  *((_DWORD *)v6 + 26) = 0;
  uint64_t v7 = v6[12];
  v6[11] = 0LL;
  v6[12] = 0LL;

  if (v4) {
    uint64_t v8 = (nw_parameters_t)v4;
  }
  else {
    uint64_t v8 = nw_parameters_create();
  }
  int v9 = v6[2];
  v6[2] = v8;

  os_log_type_t v10 = nw_parameters_copy_context(v6[2]);
  uint64_t v11 = v6[3];
  v6[3] = v10;

  if (nw_context_is_inline(v6[3]))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v13, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v14 = (os_log_s *)(id)gLogObj;
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts",  buf,  0xCu);
        }
      }

      else if (v31)
      {
        os_log_type_t v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v14 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v14, type);
        if (v18)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
            os_log_type_t v36 = 2082;
            uint64_t v37 = v18;
            _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v18);
          if (!v13) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }

        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v14 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v13)
    {
LABEL_29:

LABEL_30:
      id v3 = 0LL;
      goto LABEL_31;
    }

    goto LABEL_49;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    uint64_t v7 = v6[473];

    if ((v7 & 0x40) == 0 && (uint64_t v8 = v6, v9 = (char)v6[473], v8, v9 < 0))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        char v31 = 2114;
        uint64_t v32 = v8;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s enabling NAT64 prefix detection for path=%{public}@",  buf,  0x16u);
      }

      if (!*((void *)v3 + 6)) {
        nw_nat64_prefixes_resolver_start_dns_query_locked(v3);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        char v31 = 2114;
        uint64_t v32 = v6;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s disabling NAT64 prefix detection for path=%{public}@",  buf,  0x16u);
      }

      if (*((void *)v3 + 6)) {
        nw_nat64_prefixes_resolver_cancel_dns_query_locked(v3);
      }
      *((_DWORD *)v3 + 26) = 0;
      uint64_t v11 = (void *)*((void *)v3 + 11);
      if (v11)
      {
        free(v11);
        *((void *)v3 + 11) = 0LL;
      }
    }

    goto LABEL_11;
  }

  __nwlog_obj();
  BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
  int v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v27 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null path", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (!v27)
  {
    __nwlog_obj();
    char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_181A5C000, v15, v26, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_48;
  }

  os_log_type_t v22 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v23 = type;
  os_log_type_t v24 = os_log_type_enabled(v15, type);
  if (!v22)
  {
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_181A5C000, v15, v23, "%{public}s called with null path, no backtrace", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
    char v31 = 2082;
    uint64_t v32 = v22;
    _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v22);
  if (v14) {
    goto LABEL_50;
  }
LABEL_11:
}

              if (v16) {
                free(v16);
              }
              v42 = v69;
              if (!v69) {
                goto LABEL_19;
              }
              os_log_type_t v43 = (void *)*((void *)v69 + 1);
              if (v43)
              {
                free(v43);
                v42[1] = 0LL;
              }

              BOOL v44 = (void *)v42[2];
              if (v44)
              {
LABEL_54:
                free(v44);
                v42[2] = 0LL;
              }

      free(backtrace_string);
    }

      goto LABEL_49;
    }

    char *v20 = 100;
    *(_DWORD *)(v20 + 1) = 16;
    if (!a2)
    {
      __nwlog_obj();
      v112 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446722;
      v171 = "nw_necp_append_tlv";
      v172 = 1024;
      *(_DWORD *)v173 = 100;
      *(_WORD *)&v173[4] = 1024;
      *(_DWORD *)&v173[6] = 16;
      os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v113 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446722;
          v171 = "nw_necp_append_tlv";
          v172 = 1024;
          *(_DWORD *)v173 = 100;
          *(_WORD *)&v173[4] = 1024;
          *(_DWORD *)&v173[6] = 16;
          _os_log_impl(&dword_181A5C000, v25, v113, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
        }

        goto LABEL_299;
      }

      if (!v165)
      {
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v156 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446722;
          v171 = "nw_necp_append_tlv";
          v172 = 1024;
          *(_DWORD *)v173 = 100;
          *(_WORD *)&v173[4] = 1024;
          *(_DWORD *)&v173[6] = 16;
          _os_log_impl( &dword_181A5C000,  v25,  v156,  "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded",  buf,  0x18u);
        }

        goto LABEL_299;
      }

      v137 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v138 = type;
      v139 = os_log_type_enabled(v32, type);
      if (v137)
      {
        if (v139)
        {
          *(_DWORD *)buf = 136446978;
          v171 = "nw_necp_append_tlv";
          v172 = 1024;
          *(_DWORD *)v173 = 100;
          *(_WORD *)&v173[4] = 1024;
          *(_DWORD *)&v173[6] = 16;
          *(_WORD *)&v173[10] = 2082;
          *(void *)&v173[12] = v137;
          _os_log_impl( &dword_181A5C000,  v32,  v138,  "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s",  buf,  0x22u);
        }

        free(v137);
LABEL_49:
        if (!v24)
        {
LABEL_51:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v41 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v171 = "nw_necp_append_tlv";
          v42 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v165 = 0;
          if (!__nwlog_fault((const char *)v42, &type, &v165))
          {
LABEL_67:
            if (v42) {
              free(v42);
            }
            __int16 v35 = 0LL;
LABEL_70:
            v50 = v15;
            v49 = v164;
            v51 = v163;
            if (a4 == 0LL || a5 == 0) {
              goto LABEL_71;
            }
            goto LABEL_112;
          }

          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v43 = (os_log_s *)(id)gLogObj;
            BOOL v44 = type;
            if (os_log_type_enabled(v43, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null tlv_start", buf, 0xCu);
            }
          }

          else if (v165)
          {
            v45 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v43 = (os_log_s *)(id)gLogObj;
            v46 = type;
            v47 = os_log_type_enabled(v43, type);
            if (v45)
            {
              if (v47)
              {
                *(_DWORD *)buf = 136446466;
                v171 = "nw_necp_append_tlv";
                v172 = 2082;
                *(void *)v173 = v45;
                _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v45);
              goto LABEL_67;
            }

            if (v47)
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_181A5C000, v43, v46, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v43 = (os_log_s *)(id)gLogObj;
            v48 = type;
            if (os_log_type_enabled(v43, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl( &dword_181A5C000,  v43,  v48,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
            }
          }

    if (v21) {
      free(v21);
    }
LABEL_50:
    __int16 v35 = *(void *)(v5 + 24);
    if (v35)
    {
      os_log_type_t v36 = *(void (**)(uint64_t, void *))(v35 + 96);
      if (v36)
      {
        v36(v5, v105);
        goto LABEL_53;
      }
    }

    __nwlog_obj();
    v46 = *(const char **)(v5 + 16);
    if (!v46) {
      v46 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v46;
    v47 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v91 = 0;
    v89 = (char *)v47;
    if (__nwlog_fault(v47, &type, &v91))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v48 = (os_log_s *)__nwlog_obj();
        v49 = type;
        if (!os_log_type_enabled(v48, type)) {
          goto LABEL_93;
        }
        v50 = *(const char **)(v5 + 16);
        if (!v50) {
          v50 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v4;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v50;
        v51 = v48;
        os_log_type_t v52 = v49;
        os_log_type_t v53 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
        goto LABEL_92;
      }

      if (!v91)
      {
        uint64_t v58 = (os_log_s *)__nwlog_obj();
        v59 = type;
        if (!os_log_type_enabled(v58, type)) {
          goto LABEL_93;
        }
        v60 = *(const char **)(v5 + 16);
        if (!v60) {
          v60 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v4;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v60;
        v51 = v58;
        os_log_type_t v52 = v59;
        os_log_type_t v53 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_92;
      }

      uint64_t v54 = (char *)__nw_create_backtrace_string();
      v55 = (os_log_s *)__nwlog_obj();
      v87 = type;
      v56 = os_log_type_enabled(v55, type);
      if (v54)
      {
        if (v56)
        {
          uint64_t v57 = *(const char **)(v5 + 16);
          if (!v57) {
            uint64_t v57 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = v4;
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v57;
          *(_WORD *)&buf[22] = 2082;
          v107 = v54;
          _os_log_impl( &dword_181A5C000,  v55,  v87,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v54);
        goto LABEL_93;
      }

      if (v56)
      {
        char v61 = *(const char **)(v5 + 16);
        if (!v61) {
          char v61 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v4;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v61;
        v51 = v55;
        os_log_type_t v52 = v87;
        os_log_type_t v53 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_92:
        _os_log_impl(&dword_181A5C000, v51, v52, v53, buf, 0x16u);
      }
    }

    uint64_t v13 = v17;
    int v14 = v18;
    char v15 = 12;
    goto LABEL_17;
  }

  handle = (char *)a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_protocol_http3_get_input_frames";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null http3";
      goto LABEL_48;
    }

    if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      os_log_type_t v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v22) {
          goto LABEL_38;
        }
        *(_DWORD *)buf = 136446466;
        char v26 = "nw_protocol_http3_get_input_frames";
        os_log_type_t v27 = 2082;
        BOOL v28 = backtrace_string;
        os_log_type_t v21 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_181A5C000, v17, v18, v21, buf, 0x16u);
LABEL_38:
        free(backtrace_string);
        if (!v7) {
          return 0LL;
        }
        goto LABEL_19;
      }

      if (!v22) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      BOOL v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_http3_get_input_frames";
      os_log_type_t v10 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    goto LABEL_48;
  }

  *(_DWORD *)buf = 136446466;
  char v26 = "nw_protocol_http3_get_input_frames";
  os_log_type_t v27 = 2048;
  BOOL v28 = handle;
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)gLogObj;
    int v9 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_protocol_http3_get_input_frames";
    os_log_type_t v27 = 2048;
    BOOL v28 = handle;
    os_log_type_t v10 = "%{public}s http3 %p called";
LABEL_16:
    uint64_t v13 = v8;
    int v14 = v9;
    char v15 = 22;
LABEL_17:
    _os_log_impl(&dword_181A5C000, v13, v14, v10, buf, v15);
    goto LABEL_18;
  }

  if (!v23)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)gLogObj;
    int v9 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_protocol_http3_get_input_frames";
    os_log_type_t v27 = 2048;
    BOOL v28 = handle;
    os_log_type_t v10 = "%{public}s http3 %p called, backtrace limit exceeded";
    goto LABEL_16;
  }

  uint64_t v11 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v8 = (os_log_s *)gLogObj;
  int v9 = type;
  os_log_type_t v12 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_protocol_http3_get_input_frames";
    os_log_type_t v27 = 2048;
    BOOL v28 = handle;
    os_log_type_t v10 = "%{public}s http3 %p called, no backtrace";
    goto LABEL_16;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446722;
    char v26 = "nw_protocol_http3_get_input_frames";
    os_log_type_t v27 = 2048;
    BOOL v28 = handle;
    os_log_type_t v29 = 2082;
    os_log_type_t v30 = v11;
    _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s http3 %p called, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v11);
LABEL_18:
  if (v7) {
LABEL_19:
  }
    free(v7);
  return 0LL;
}

      if (v12) {
        free(v12);
      }
      return 0LL;
    }

    if (!v22)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      int v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_protocol_http3_remove_listen_handler";
        char v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    int v14 = type;
    BOOL v17 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_protocol_http3_remove_listen_handler";
        char v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_47;
      }

      goto LABEL_48;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_protocol_http3_remove_listen_handler";
      char v26 = 2082;
      os_log_type_t v27 = backtrace_string;
      os_log_type_t v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v13, v14, v18, buf, 0x16u);
    }

    if (v18) {
      free(v18);
    }
    os_log_type_t v10 = 0LL;
    goto LABEL_11;
  }

  __nwlog_obj();
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v32 = "nw_listen_protocol_new_flow";
  int v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v29 = 0;
  if (__nwlog_fault(v14, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null listener", buf, 0xCu);
      }
    }

    else if (v29)
    {
      os_log_type_t v21 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      os_log_type_t v23 = os_log_type_enabled(v15, type);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v32 = "nw_listen_protocol_new_flow";
          v33 = 2082;
          uint64_t v34 = v21;
          _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null listener, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v21);
        goto LABEL_42;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_listen_protocol_new_flow";
        _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_listen_protocol_new_flow";
        _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null listener, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  LOBYTE(v55) = *((_BYTE *)a3 + *v9) == 0;
  return v55;
}

    free(backtrace_string);
    goto LABEL_63;
  }

  memset(__dst, 0, sizeof(__dst));
  v33 = 0;
  *(void *)os_log_type_t type = 0LL;
  BOOL v28 = 0LL;
  os_log_type_t v30 = 0;
  os_log_type_t v29 = 0LL;
  char v26 = 0;
  char v31 = 0LL;
  if (!getaddrinfo(a1, 0LL, &nw_string_is_ip_address::hints, &v31))
  {
    uint64_t v7 = v31;
    if (!v31) {
      return nw_endpoint_create_address_with_port((unsigned __int8 *)__dst, a2);
    }
    uint64_t v8 = v31;
    while (1)
    {
      p_sa_len = &v8->ai_addr->sa_len;
      os_log_type_t v10 = p_sa_len[1];
      if (v10 == 30 || v10 == 2) {
        break;
      }
      uint64_t v8 = v8->ai_next;
      if (!v8) {
        goto LABEL_18;
      }
    }

    os_log_type_t v12 = *p_sa_len;
    if (v12 <= 0x1C) {
      memcpy(__dst, p_sa_len, v12);
    }
LABEL_18:
    freeaddrinfo(v7);
    if (BYTE1(__dst[0]) == 2)
    {
      uint64_t v6 = 32;
    }

    else
    {
      if (BYTE1(__dst[0]) != 30) {
        return nw_endpoint_create_address_with_port((unsigned __int8 *)__dst, a2);
      }
      uint64_t v6 = 0x80;
    }

  if (v9) {
    free(v9);
  }
  return 0LL;
}

  if (v11) {
    free(v11);
  }
  return 0LL;
}

    goto LABEL_49;
  }

  os_log_type_t v12 = v10;
  uint64_t v13 = v12[1];

  if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_59_74543);
  }
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v13,  nw_protocol_copy_http_transaction_definition_definition);

  if (is_equal_unsafe)
  {
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_http_transaction_metadata_set_start_reason_block_invoke;
    __int16 v35 = &__block_descriptor_36_e9_B16__0_v8l;
    os_log_type_t v36 = v9;
    char v15 = (uint64_t)v12[4];
    if (v15) {
      __nw_http_transaction_metadata_set_start_reason_block_invoke((uint64_t)buf, v15);
    }
    goto LABEL_13;
  }

  __nwlog_obj();
  os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_set_start_reason";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v32 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_set_start_reason";
      _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s metadata must be http_transaction", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (!v32)
  {
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v31 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_set_start_reason";
      _os_log_impl( &dword_181A5C000,  v20,  v31,  "%{public}s metadata must be http_transaction, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_48;
  }

  os_log_type_t v27 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v28 = type;
  os_log_type_t v29 = os_log_type_enabled(v20, type);
  if (!v27)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_set_start_reason";
      _os_log_impl(&dword_181A5C000, v20, v28, "%{public}s metadata must be http_transaction, no backtrace", buf, 0xCu);
    }

    goto LABEL_48;
  }

  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_set_start_reason";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v27;
    _os_log_impl( &dword_181A5C000,  v20,  v28,  "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v27);
  if (v19) {
LABEL_50:
  }
    free(v19);
LABEL_13:

  nw_array_append(*(void *)(a2 + 24), v11);
  if (v7)
  {
    start_time = nw_http_transaction_metadata_get_start_time(v11);
    nw_http_transaction_metadata_set_end_time(v7, start_time);
  }

  return 1LL;
}

        goto LABEL_49;
      }

      if (!v26)
      {
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          uint64_t v13 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_47;
        }

        goto LABEL_48;
      }

      BOOL v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      os_log_type_t v21 = os_log_type_enabled(v11, type);
      if (!v20)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          uint64_t v13 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_47;
        }

        goto LABEL_48;
      }

      if (!v21) {
        goto LABEL_31;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
      os_log_type_t v30 = 2082;
      char v31 = v20;
      os_log_type_t v22 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
  }

    free(backtrace_string);
    goto LABEL_58;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_protocol_http_messaging_create";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_http_messaging_create";
        os_log_type_t v19 = "%{public}s called with null parameters";
        goto LABEL_57;
      }

      goto LABEL_58;
    }

    if (!v29)
    {
      BOOL v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_http_messaging_create";
        os_log_type_t v19 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_57;
      }

      goto LABEL_58;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v28 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_http_messaging_create";
        os_log_type_t v19 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_57;
      }

      goto LABEL_58;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "nw_protocol_http_messaging_create";
      v33 = 2082;
      uint64_t v34 = (uint64_t)backtrace_string;
      os_log_type_t v27 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_47;
    }

    goto LABEL_48;
  }

  uint64_t v6 = (char *)calloc(1uLL, 0x118uLL);
  if (v6)
  {
LABEL_4:
    *((void *)v6 + 34) = 0LL;
    *((_OWORD *)v6 + 15) = 0u;
    *((_OWORD *)v6 + 16) = 0u;
    *((_OWORD *)v6 + 13) = 0u;
    *((_OWORD *)v6 + 14) = 0u;
    *((_OWORD *)v6 + 11) = 0u;
    *((_OWORD *)v6 + 12) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    logging_disabled = nw_path_parameters_get_logging_disabled(a4[13]);
    if (logging_disabled) {
      uint64_t v8 = 2;
    }
    else {
      uint64_t v8 = 0;
    }
    v6[272] = v6[272] & 0xFD | v8;
    if (v6) {
      int v9 = logging_disabled;
    }
    else {
      int v9 = 0;
    }
    if (!v9)
    {
      if (gLogDatapath)
      {
        os_log_type_t v22 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v23 = "";
          os_log_type_t v24 = v6 + 188;
          if (!v6) {
            os_log_type_t v24 = "";
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v32 = "nw_protocol_http_messaging_create";
          if (v6) {
            os_log_type_t v23 = " ";
          }
          v33 = 2082;
          uint64_t v34 = (uint64_t)v24;
          __int16 v35 = 2080;
          os_log_type_t v36 = (uint64_t)v23;
          _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }

    if (nw_protocol_http_messaging_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_76181);
    }
    *((void *)v6 + 2) = nw_protocol_http_messaging_identifier::protocol_identifier;
    *((void *)v6 + 3) = &nw_protocol_http_messaging_get_callbacks(void)::protocol_callbacks;
    *((void *)v6 + 5) = v6;
    *((void *)v6 + 8) = &nw_protocol_http_messaging_get_listen_callbacks(void)::listen_protocol_callbacks;
    *((void *)v6 + 11) = v6;
    os_log_type_t v10 = os_retain(a3);
    uint64_t v11 = v6[120];
    if ((v11 & 1) != 0)
    {
      os_log_type_t v12 = (void *)*((void *)v6 + 14);
      if (v12)
      {
        os_release(v12);
        uint64_t v11 = v6[120];
      }
    }

    *((void *)v6 + 14) = v10;
    v6[120] = v11 | 1;
    uint64_t v13 = a4;
    int v14 = v13[12];

    v6[272] = v6[272] & 0xFE | ((v14 & 0x8000) != 0);
    return (BOOL)v6;
  }

  BOOL v20 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v32 = "strict_calloc";
  v33 = 2048;
  uint64_t v34 = 1LL;
  __int16 v35 = 2048;
  os_log_type_t v36 = 280LL;
  os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
    goto LABEL_4;
  }

  __break(1u);
  return result;
}

  if (v18)
  {
    os_log_type_t v36 = (char *)v18;
LABEL_50:
    free(v36);
  }

  return 0LL;
}

  symptom_set_qualifier();
  symptom_set_additional_qualifier();
  if (v36 && strlen(v36)) {
    symptom_set_additional_qualifier();
  }
  if (a9) {
    symptom_set_additional_qualifier();
  }
  if (a10) {
    symptom_set_additional_qualifier();
  }
  v48 = v72;
  *(void *)uu = 0LL;
  *(void *)&uu[8] = uu;
  v83 = 0x2020000000LL;
  v84 = 0LL;
  v49 = v48 + 45;
  *(void *)v80 = MEMORY[0x1895F87A8];
  *(void *)&v80[8] = 3221225472LL;
  *(void *)&v80[16] = __nw_endpoint_get_description_block_invoke;
  *(void *)&v80[24] = &unk_189BC9210;
  v50 = v48;
  *(void *)&v80[32] = v50;
  v81 = uu;
  os_unfair_lock_lock(v49);
  __nw_endpoint_get_description_block_invoke((uint64_t)v80);
  os_unfair_lock_unlock(v49);
  v51 = *(const char **)(*(void *)&uu[8] + 24LL);

  _Block_object_dispose(uu, 8);
  if (v51 && strlen(v51)) {
    symptom_set_additional_qualifier();
  }
  if (a1 == 421899)
  {
    symptom_set_additional_qualifier();
    symptom_set_additional_qualifier();
  }

  else if (a1 == 421898)
  {
    symptom_set_qualifier();
    if (a6)
    {
      uuid_unparse(a6, v80);
      strlen(v80);
      symptom_set_additional_qualifier();
    }
  }

  symptom_send();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v52 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
  {
    os_log_type_t v53 = off_189BC74D0[a1 - 421889];
    *(_DWORD *)v80 = 136446722;
    *(void *)&v80[4] = "nw_connection_report_symptom_internal_on_nw_queue";
    *(_WORD *)&v80[12] = 2082;
    *(void *)&v80[14] = v53;
    *(_WORD *)&v80[22] = 1024;
    *(_DWORD *)&v80[24] = a1;
    _os_log_impl(&dword_181A5C000, v52, OS_LOG_TYPE_DEBUG, "%{public}s Symptom sent: %{public}s(%#x)", v80, 0x1Cu);
  }

LABEL_88:
}

      goto LABEL_49;
    }

    goto LABEL_49;
  }

  uint64_t v7 = nw_endpoint_handler_copy_flow(v5);
  os_unfair_lock_lock((os_unfair_lock_t)v7 + 220);
  identifier = nw_protocol_definition_get_identifier(v4);
  int v9 = (void *)*((void *)v7 + 1);
  if (v9)
  {
    os_log_type_t v10 = v9;
    uint64_t v11 = v10[2];

    if (nw_parameters_has_protocol_in_stack(v11, identifier))
    {
      os_log_type_t v12 = v11;
      uint64_t v13 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v12,  0,  0);

      int v14 = (void *)v13;
    }

    else
    {
      int v14 = 0LL;
    }

    BOOL v25 = (void *)*((void *)v7 + 69);
    if (v25)
    {
LABEL_23:
      if (nw_parameters_has_protocol_in_stack(v25, identifier))
      {
        char v26 = *((id *)v7 + 69);
        os_log_type_t v27 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v26,  0,  0);

        int v14 = (void *)v27;
      }
    }
  }

  else
  {
    int v14 = 0LL;
    BOOL v25 = (void *)*((void *)v7 + 69);
    if (v25) {
      goto LABEL_23;
    }
  }

  if (!v14)
  {
    BOOL v28 = *((void *)v7 + 117);
    if (v28) {
      int v14 = (void *)nw_endpoint_handler_copy_connected_parameters_with_protocol(v28, v4);
    }
    else {
      int v14 = 0LL;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)v7 + 220);

LABEL_52:
  return v14;
}

LABEL_94:
  return v91;
}

      free(v16);
      if (!v8) {
        return;
      }
LABEL_64:
      free(v8);
      return;
    }

    int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    if (!os_log_type_enabled(v9, type)) {
      goto LABEL_63;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_http2_input_finished";
    uint64_t v11 = "%{public}s called with null http2";
LABEL_62:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_63;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_http2_input_finished";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_protocol_http2_input_finished";
      uint64_t v11 = "%{public}s called with null other_protocol";
      goto LABEL_62;
    }

    if (!v21)
    {
      int v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_protocol_http2_input_finished";
      uint64_t v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_62;
    }

    os_log_type_t v16 = (char *)__nw_create_backtrace_string();
    int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    os_log_type_t v19 = os_log_type_enabled(v9, type);
    if (!v16)
    {
      if (!v19) {
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_protocol_http2_input_finished";
      uint64_t v11 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_62;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v24 = "nw_protocol_http2_input_finished";
      BOOL v25 = 2082;
      char v26 = v16;
      os_log_type_t v18 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_47;
    }

    goto LABEL_48;
  }

  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v12 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      os_log_type_t v24 = "nw_protocol_http2_input_finished";
      BOOL v25 = 2082;
      char v26 = handle + 390;
      os_log_type_t v27 = 2080;
      BOOL v28 = " ";
      os_log_type_t v29 = 1024;
      os_log_type_t v30 = v13;
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  if ((*((_WORD *)handle + 194) & 0x9000) == 0x1000)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v3 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      os_log_type_t v24 = "nw_protocol_http2_input_finished";
      BOOL v25 = 2082;
      char v26 = handle + 390;
      os_log_type_t v27 = 2080;
      BOOL v28 = " ";
      os_log_type_t v29 = 1024;
      os_log_type_t v30 = v4;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> still waiting for listen handler, but input finished. Processing input anyway.",  buf,  0x26u);
    }
  }

  nw_protocol_http2_process_input((uint64_t)handle);
  *((_WORD *)handle + 194) |= 2u;
  uint64_t v5 = (char *)*((void *)handle + 19);
  v20[0] = MEMORY[0x1895F87A8];
  v20[1] = 0x40000000LL;
  v20[2] = ___ZL32nw_protocol_http2_input_finishedP11nw_protocolS0__block_invoke;
  v20[3] = &__block_descriptor_tmp_50_83423;
  v20[4] = handle;
  nw_hash_table_apply(v5, (uint64_t)v20);
  uint64_t v7 = *((void *)handle + 11);
  if (v7)
  {
    if (*(void *)v7)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v7, 0x8000000000000000LL, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    }

    else
    {
      *(_OWORD *)(v7 + 32) = xmmword_18272D790;
      if (*(_BYTE *)(v7 + 48))
      {
        if (*(_BYTE *)(v7 + 49)) {
          nw_queue_source_run_timer(v7, v6);
        }
      }
    }
  }

void sub_181A660C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_copy_cache_context(void *a1)
{
  v1 = a1;
  uint64_t v2 = v1;
  if ((v1[136] & 4) != 0 || (v3 = v1, int v4 = v2[136] & 3, v3, v4))
  {
    uint64_t v5 = (void *)*((void *)v2 + 5);
    if (!v5) {
      uint64_t v5 = v2;
    }
  }

  else
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    }
    uint64_t v5 = (void *)nw_context_copy_implicit_context::implicit_context;
  }

  uint64_t v6 = v5;
  if (v6[3]) {
    goto LABEL_8;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  uint64_t v8 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v8);
  if (!result)
  {
    free(v8);
LABEL_8:

    return (BOOL)v6;
  }

  __break(1u);
  return result;
}

BOOL nw_hash_table_remove_node(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj(0LL, a2);
    *(_DWORD *)buf = 136446210;
    v39 = "nw_hash_table_remove_node";
    os_log_type_t v12 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    uint64_t v13 = __nwlog_fault(v12, &type, &v36);
    if (!(_DWORD)v13) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v15 = (os_log_s *)__nwlog_obj(v13, v14);
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "nw_hash_table_remove_node";
      BOOL v17 = "%{public}s called with null table";
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v15 = (os_log_s *)__nwlog_obj(backtrace_string, v30);
      os_log_type_t v16 = type;
      BOOL v31 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "nw_hash_table_remove_node";
          __int16 v40 = 2082;
          BOOL v41 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s called with null table, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_53;
      }

      if (!v31)
      {
LABEL_53:
        if (v12) {
          free(v12);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      v39 = "nw_hash_table_remove_node";
      BOOL v17 = "%{public}s called with null table, no backtrace";
    }

    else
    {
      char v15 = (os_log_s *)__nwlog_obj(v13, v14);
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "nw_hash_table_remove_node";
      BOOL v17 = "%{public}s called with null table, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
    goto LABEL_53;
  }

  if (*(_DWORD *)(a1 + 32))
  {
    int v4 = *(_DWORD *)(a1 + 48);
    if ((v4 & 2) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  os_log_type_t v18 = (os_log_s *)__nwlog_obj(a1, a2);
  os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v39 = "nw_hash_table_lock";
  os_log_type_t v19 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v19);
  if (result) {
    goto LABEL_63;
  }
  free(v19);
  int v4 = *(_DWORD *)(a1 + 48);
  if ((v4 & 2) != 0)
  {
LABEL_4:
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
    int v4 = *(_DWORD *)(a1 + 48);
  }

LABEL_5:
  if ((v4 & 1) == 0)
  {
    __nwlog_obj(a1, a2);
    *(_DWORD *)buf = 136446210;
    v39 = "nw_hash_table_remove_node";
    BOOL v20 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    uint64_t v21 = __nwlog_fault(v20, &type, &v36);
    if (!(_DWORD)v21) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v23 = (os_log_s *)__nwlog_obj(v21, v22);
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_58;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "nw_hash_table_remove_node";
      BOOL v25 = "%{public}s called with invalid hash table";
    }

    else if (v36)
    {
      uint64_t v32 = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = (os_log_s *)__nwlog_obj(v32, v33);
      os_log_type_t v24 = type;
      BOOL v34 = os_log_type_enabled(v23, type);
      if (v32)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "nw_hash_table_remove_node";
          __int16 v40 = 2082;
          BOOL v41 = v32;
          _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s called with invalid hash table, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v32);
LABEL_58:
        if (v20) {
          free(v20);
        }
        if ((*(_BYTE *)(a1 + 48) & 2) != 0)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
          return 0LL;
        }

        return 0LL;
      }

      if (!v34) {
        goto LABEL_58;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "nw_hash_table_remove_node";
      BOOL v25 = "%{public}s called with invalid hash table, no backtrace";
    }

    else
    {
      os_log_type_t v23 = (os_log_s *)__nwlog_obj(v21, v22);
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_58;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "nw_hash_table_remove_node";
      BOOL v25 = "%{public}s called with invalid hash table, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v23, v24, v25, buf, 0xCu);
    goto LABEL_58;
  }

  if (*(_BYTE *)(a2 + 30) != 1)
  {
    char v26 = (os_log_s *)__nwlog_obj(a1, a2);
    os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    unint64_t v27 = *(unsigned __int8 *)(a2 + 30);
    if (v27 > 3) {
      BOOL v28 = "invalid_state";
    }
    else {
      BOOL v28 = off_189BC49E0[v27];
    }
    *(_DWORD *)buf = 136446466;
    v39 = "nw_hash_table_remove_node";
    __int16 v40 = 2082;
    BOOL v41 = (void *)v28;
    __int16 v35 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v35);
    if (result) {
      goto LABEL_63;
    }
    free(v35);
    if (*(_BYTE *)(a2 + 30) != 1)
    {
      uint64_t v11 = 0LL;
      if ((*(_BYTE *)(a1 + 48) & 2) == 0) {
        return v11;
      }
      goto LABEL_16;
    }
  }

  uint64_t v5 = a1 + 16LL * *(unsigned int *)(a2 + 24) + 56;
  *(_BYTE *)(a2 + 30) = 2;
  uint64_t v6 = *(void (**)(void))(a1 + 24);
  if (v6)
  {
    v6(*(void *)(a2 + 16));
    *(void *)(a2 + 16) = 0LL;
  }

  --*(_DWORD *)(a1 + 40);
  uint64_t v7 = *(void **)(a2 + 8);
  if (v7 && *v7 == a2)
  {
LABEL_13:
    if (!*(_WORD *)(a2 + 28)) {
      nw_hash_node_free(v5, (void *)a2);
    }
    uint64_t v11 = 1LL;
    if ((*(_BYTE *)(a1 + 48) & 2) == 0) {
      return v11;
    }
LABEL_16:
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
    return v11;
  }

  uint64_t v8 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v8);
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v39 = "nw_hash_table_remove_node_internal";
  int v9 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v9);
  if (!result)
  {
    free(v9);
    goto LABEL_13;
  }

    if (nwlog_get_private_redacted::onceToken != -1) {
      dispatch_once(&nwlog_get_private_redacted::onceToken, &__block_literal_global_57_44371);
    }
    int v4 = nwlog_get_private_redacted::privateRedacted;
LABEL_12:
    uint64_t v5 = v4 != 0;
    goto LABEL_13;
  }

  uint64_t v5 = 0LL;
LABEL_13:

  return v5;
}

    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
    uint64_t v6 = *(_DWORD *)(a1 + 48);
    goto LABEL_6;
  }

  __break(1u);
  return result;
}

    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
    uint64_t v6 = *(_DWORD *)(a1 + 48);
    goto LABEL_6;
  }

  uint64_t v5 = _Block_copy(v3);
LABEL_6:

  return v5;
}

    uint64_t v5 = *(_DWORD *)(v4 + 552);
    uint64_t v6 = *(_DWORD *)(v4 + 560);
    if (v5 < v6)
    {
LABEL_6:
      uint64_t v7 = *(void *)(v4 + 520);
      *(_DWORD *)(v4 + 552) = v5 + 1;
      *(void *)(v7 + 8LL * (int)v5 + 8) = a2;
      ++*(void *)(v4 + 544);
      return;
    }

    while (1)
    {
      if (!*(_DWORD *)(v4 + 556))
      {
        *(_DWORD *)(v4 + 556) = v5;
        *(int8x16_t *)(v4 + 520) = vextq_s8(*(int8x16_t *)(v4 + 520), *(int8x16_t *)(v4 + 520), 8uLL);
LABEL_11:
        *(_DWORD *)(v4 + 552) = 0;
        goto LABEL_12;
      }

      if (!v6)
      {
        uint64_t v22 = *(void (**)(unint64_t, void))(v4 + 192);
        if (v22) {
          v22(a2, *(void *)(v4 + 208));
        }
        nw_mem_slab_free(v4, a2);
        return;
      }

      int v9 = *(void **)(v4 + 384);
      if (v9)
      {
        *(void *)(v4 + 384) = *v9;
        os_log_type_t v10 = *(_DWORD *)(v4 + 392) - 1;
        *(_DWORD *)(v4 + 392) = v10;
        if (v10 < *(_DWORD *)(v4 + 396)) {
          *(_DWORD *)(v4 + 396) = v10;
        }
        ++*(void *)(v4 + 376);
        uint64_t v11 = *(void **)(v4 + 528);
        if (v11)
        {
          void *v11 = *(void *)(v4 + 352);
          *(void *)(v4 + 352) = v11;
          ++*(_DWORD *)(v4 + 360);
        }

        *(void *)(v4 + 528) = *(void *)(v4 + 520);
        *(_DWORD *)(v4 + 556) = v5;
        *(void *)(v4 + 520) = v9;
        goto LABEL_11;
      }

      os_log_type_t v12 = *(int **)(v4 + 336);
      uint64_t v13 = (malloc_zone_t *)g_slab_zone;
      uint64_t v14 = v12[1];
      char v15 = 8LL * *v12;
      os_log_type_t v16 = v15 + 8;
      if (v15 == -8)
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "strict_malloc_zone_memalign";
        BOOL v34 = (void *)_os_log_send_and_compose_impl();
        free(v34);
        if (v14 <= 7)
        {
LABEL_30:
          os_log_type_t v19 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "strict_malloc_zone_memalign";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v14;
          __int16 v35 = (void *)_os_log_send_and_compose_impl();
          free(v35);
        }
      }

      else if (v14 <= 7)
      {
        goto LABEL_30;
      }

      if ((v14 & (v14 - 1)) != 0)
      {
        BOOL v20 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "strict_malloc_zone_memalign";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v14;
        char v36 = (void *)_os_log_send_and_compose_impl();
        free(v36);
      }

      BOOL v17 = malloc_zone_memalign(v13, v14, v16);
      if (v17)
      {
        uint64_t v6 = *(_DWORD *)(v4 + 560);
        if (v6 != *v12)
        {
          malloc_zone_free((malloc_zone_t *)g_slab_zone, v17);
          uint64_t v6 = *(_DWORD *)(v4 + 560);
          goto LABEL_12;
        }

      os_log_type_t v10 = self->shared_protocol.protocol.output_handler;
      uint64_t v11 = 1;
      if (!v10 || v4 || (*((_WORD *)&self->shared_protocol + 166) & 0x800) != 0 || (*((_BYTE *)self + 35) & 6) != 0)
      {
        if ((*((_BYTE *)self + 34) & 0x10) == 0)
        {
LABEL_11:
          os_unfair_lock_lock(&self->lock);
          connected_path = self->connected_path;
          self->connected_path = 0LL;

          connected_metadata = self->connected_metadata;
          self->connected_metadata = 0LL;

          connection_wide_metadata = self->connection_wide_metadata;
          self->connection_wide_metadata = 0LL;

          connected_endpoint_handler = self->connected_endpoint_handler;
          self->connected_endpoint_handler = 0LL;

          os_unfair_lock_unlock(&self->lock);
          nw_endpoint_flow_cleanup_protocol(v8, (uint64_t)&self->shared_protocol, 0);
          os_unfair_lock_lock(&self->lock);
          candidate_endpoint_handlers = self->candidate_endpoint_handlers;
          self->candidate_endpoint_handlers = 0LL;

          os_unfair_lock_unlock(&self->lock);
          new_flow_read_requests = self->new_flow_read_requests;
          os_log_type_t v18 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
          nw_read_request_report_error_with_override(new_flow_read_requests, 0LL, v18);

          os_log_type_t v19 = self->new_flow_read_requests;
          self->new_flow_read_requests = 0LL;

          if (v11) {
            nw_endpoint_flow_failed_with_error(v8, 0, 0LL);
          }
          child_endpoint_handler = self->child_endpoint_handler;
          if (child_endpoint_handler)
          {
            nw_endpoint_handler_cancel(child_endpoint_handler, v4, 0);
            uint64_t v21 = self->child_endpoint_handler;
          }

          else
          {
            uint64_t v21 = 0LL;
          }

          self->child_endpoint_handler = 0LL;

          *((_BYTE *)self + 35) &= ~4u;
          last_error = self->last_error;
          self->last_error = 0LL;

          flow_divert_token = self->flow_divert_token;
          self->flow_divert_token = 0LL;

          flow_divert_endpoint = self->flow_divert_endpoint;
          self->flow_divert_endpoint = 0LL;

          saved_original_endpoint = self->saved_original_endpoint;
          self->saved_original_endpoint = 0LL;

          goto LABEL_80;
        }

  v18.receiver = self;
  v18.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_path_evaluator;
  -[NWConcrete_nw_path_evaluator dealloc](&v18, sel_dealloc, v16, v17);
}

  *a3 = result;
  a3[1] = v5;
  return result;
}

  *a1 = v8;
  if ((a6 & 0x8000000000000000LL) != 0) {
    return 0LL;
  }
  else {
    return swift_unknownObjectRetain();
  }
}

      swift_bridgeObjectRelease();
      BOOL result = (xpc_object_t)__swift_destroy_boxed_opaque_existential_2((uint64_t)&v26);
      if (v5) {
        goto LABEL_6;
      }
LABEL_8:
      uint64_t v13 = v7 + 1;
      if (__OFADD__(v7, 1LL))
      {
        __break(1u);
        goto LABEL_50;
      }

      if (v13 < v22)
      {
        uint64_t v14 = *(void *)(v21 + 8 * v13);
        if (v14) {
          goto LABEL_11;
        }
        char v15 = v7 + 2;
        ++v7;
        if (v13 + 1 < v22)
        {
          uint64_t v14 = *(void *)(v21 + 8 * v15);
          if (v14) {
            goto LABEL_14;
          }
          uint64_t v7 = v13 + 1;
          if (v13 + 2 < v22)
          {
            uint64_t v14 = *(void *)(v21 + 8 * (v13 + 2));
            if (v14)
            {
              v13 += 2LL;
              goto LABEL_11;
            }

            char v15 = v13 + 3;
            uint64_t v7 = v13 + 2;
            if (v13 + 3 < v22) {
              break;
            }
          }
        }
      }

  uint64_t v8 = swift_allocObject();
  *(void *)(v8 + 16) = a2;
  *(void *)(v8 + 24) = a3;
  return swift_task_create();
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    os_log_type_t v19 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    BOOL v20 = *v19;
    uint64_t v21 = (-1LL << v3) - 1;
  }

  else
  {
    os_log_type_t v19 = (uint64_t *)(v4 + 8 * (result >> 6));
    uint64_t v21 = *v19;
    BOOL v20 = (-1LL << result) - 1;
  }

  void *v19 = v21 & v20;
  uint64_t v22 = *(void *)(a2 + 16);
  os_log_type_t v23 = __OFSUB__(v22, 1LL);
  os_log_type_t v24 = v22 - 1;
  if (v23)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v24;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    BOOL v17 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    os_log_type_t v18 = *v17;
    os_log_type_t v19 = (-1LL << v3) - 1;
  }

  else
  {
    BOOL v17 = (uint64_t *)(v4 + 8 * (result >> 6));
    os_log_type_t v19 = *v17;
    os_log_type_t v18 = (-1LL << result) - 1;
  }

  const char *v17 = v19 & v18;
  BOOL v20 = *(void *)(a2 + 16);
  uint64_t v21 = __OFSUB__(v20, 1LL);
  uint64_t v22 = v20 - 1;
  if (v21)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v22;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, a2, v4);
  uint64_t v13 = a1 + qword_18C58DA60;
  swift_beginAccess();
  uint64_t v14 = *(void *)(v13 + 32);
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *(void *)(v13 + 32) = v14;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    uint64_t v14 = sub_181BC4C98(0, *(void *)(v14 + 16) + 1LL, 1, v14);
    *(void *)(v13 + 32) = v14;
  }

  BOOL v17 = *(void *)(v14 + 16);
  os_log_type_t v16 = *(void *)(v14 + 24);
  if (v17 >= v16 >> 1)
  {
    uint64_t v14 = sub_181BC4C98(v16 > 1, v17 + 1, 1, v14);
    *(void *)(v13 + 32) = v14;
  }

  *(void *)(v14 + 16) = v17 + 1;
  (*(void (**)(unint64_t, char *, uint64_t))(v5 + 32))( v14 + ((*(unsigned __int8 *)(v5 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80))
  + *(void *)(v5 + 72) * v17,
    v7,
    v4);
  return swift_endAccess();
}

    sub_181BE4788(v27);
    v26 += v46;
    --v24;
  }

  while (v24);
  BOOL result = (nw_group_descriptor *)swift_bridgeObjectRelease();
  a4 = v41;
LABEL_16:
  *a4 = v44;
  return result;
}

  swift_release();
  return v7;
}

        os_log_type_t v10 = 0;
        uint64_t v7 = v15;
        if (v12++ == v14)
        {
          uint64_t v7 = v15;
          int v9 = a6;
          goto LABEL_26;
        }
      }
    }

    BOOL result = sub_181C93174(result, a2, a3 & 1);
LABEL_26:
    *(void *)int v9 = v8;
    *(void *)(v9 + 8) = v7;
    *(_BYTE *)(v9 + 16) = v10;
  }

  return result;
}

        ++v17;
        uint64_t v14 = a6;
        os_log_type_t v18 = v31;
        if (v17 == a4)
        {
          os_log_type_t v16 = 0;
          uint64_t v14 = a6;
          break;
        }
      }
    }

    *(void *)a9 = v15;
    *(void *)(a9 + 8) = v14;
    *(_BYTE *)(a9 + 16) = v16;
  }

  return result;
}

  nw_ws_metadata_set_negotiated_permessage_deflate(v3, (*(unsigned __int16 *)(v4 + 273) >> 6) & 1);
  return v3;
}

    goto LABEL_6;
  }

  if (!v17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    uint64_t v13 = type;
    if (os_log_type_enabled(v6, type))
    {
      uint64_t v14 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "-[NWConcrete_nw_endpoint setPriority:]";
      uint64_t v21 = 1024;
      uint64_t v22 = v14;
      _os_log_impl( &dword_181A5C000,  v6,  v13,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_5;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  uint64_t v11 = os_log_type_enabled(v6, type);
  if (!backtrace_string)
  {
    if (v11)
    {
      char v15 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "-[NWConcrete_nw_endpoint setPriority:]";
      uint64_t v21 = 1024;
      uint64_t v22 = v15;
      _os_log_impl(&dword_181A5C000, v6, v10, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_5;
  }

  if (v11)
  {
    os_log_type_t v12 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
    *(_DWORD *)buf = 136446722;
    BOOL v20 = "-[NWConcrete_nw_endpoint setPriority:]";
    uint64_t v21 = 1024;
    uint64_t v22 = v12;
    os_log_type_t v23 = 2082;
    os_log_type_t v24 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(backtrace_string);
  if (v5) {
LABEL_7:
  }
    free(v5);
}

    goto LABEL_6;
  }

  if (!v17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    uint64_t v13 = type;
    if (os_log_type_enabled(v6, type))
    {
      uint64_t v14 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "-[NWConcrete_nw_endpoint setWeight:]";
      uint64_t v21 = 1024;
      uint64_t v22 = v14;
      _os_log_impl( &dword_181A5C000,  v6,  v13,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_5;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  uint64_t v11 = os_log_type_enabled(v6, type);
  if (!backtrace_string)
  {
    if (v11)
    {
      char v15 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "-[NWConcrete_nw_endpoint setWeight:]";
      uint64_t v21 = 1024;
      uint64_t v22 = v15;
      _os_log_impl(&dword_181A5C000, v6, v10, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_5;
  }

  if (v11)
  {
    os_log_type_t v12 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
    *(_DWORD *)buf = 136446722;
    BOOL v20 = "-[NWConcrete_nw_endpoint setWeight:]";
    uint64_t v21 = 1024;
    uint64_t v22 = v12;
    os_log_type_t v23 = 2082;
    os_log_type_t v24 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(backtrace_string);
  if (v5) {
LABEL_7:
  }
    free(v5);
}

    goto LABEL_6;
  }

  if (!v17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (os_log_s *)(id)gLogObj;
    uint64_t v13 = type;
    if (os_log_type_enabled(v6, type))
    {
      uint64_t v14 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "-[NWConcrete_nw_endpoint setEchConfig:]";
      uint64_t v21 = 1024;
      uint64_t v22 = v14;
      _os_log_impl( &dword_181A5C000,  v6,  v13,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
    }

    goto LABEL_5;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (os_log_s *)(id)gLogObj;
  os_log_type_t v10 = type;
  uint64_t v11 = os_log_type_enabled(v6, type);
  if (!backtrace_string)
  {
    if (v11)
    {
      char v15 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "-[NWConcrete_nw_endpoint setEchConfig:]";
      uint64_t v21 = 1024;
      uint64_t v22 = v15;
      _os_log_impl(&dword_181A5C000, v6, v10, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
    }

    goto LABEL_5;
  }

  if (v11)
  {
    os_log_type_t v12 = -[NWConcrete_nw_endpoint type](self, "type", buf, v16);
    *(_DWORD *)buf = 136446722;
    BOOL v20 = "-[NWConcrete_nw_endpoint setEchConfig:]";
    uint64_t v21 = 1024;
    uint64_t v22 = v12;
    os_log_type_t v23 = 2082;
    os_log_type_t v24 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
  }

  free(backtrace_string);
  if (v5) {
LABEL_7:
  }
    free(v5);
}

  if (v0 != 72)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v40 = "get_object_from_pool";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      uint64_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v40 = "get_object_from_pool";
      uint64_t v14 = "%{public}s called with null (m_obj_size == size)";
    }

    else if (v37)
    {
      char v15 = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      uint64_t v13 = type;
      os_log_type_t v16 = os_log_type_enabled(v12, type);
      if (v15)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v40 = "get_object_from_pool";
          BOOL v41 = 2082;
          uint64_t v42 = v15;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null (m_obj_size == size), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        goto LABEL_55;
      }

      if (!v16)
      {
LABEL_55:
        if (v11) {
          free(v11);
        }
        goto LABEL_57;
      }

      *(_DWORD *)buf = 136446210;
      __int16 v40 = "get_object_from_pool";
      uint64_t v14 = "%{public}s called with null (m_obj_size == size), no backtrace";
    }

    else
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      uint64_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v40 = "get_object_from_pool";
      uint64_t v14 = "%{public}s called with null (m_obj_size == size), backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_55;
  }

  uint64_t v5 = qword_18C45F5F0;
  if (!qword_18C45F5F0)
  {
LABEL_57:
    os_unfair_lock_unlock((os_unfair_lock_t)&dword_18C45F5F8);
    goto LABEL_58;
  }

  uint64_t v6 = (unint64_t)qword_18C45F5D0 >= 0x48;
  qword_18C45F5D0 -= 72LL;
  if (!v6)
  {
    if (gLogDatapath)
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v40 = "get_object_from_pool";
        BOOL v41 = 2082;
        uint64_t v42 = "m_pool_size";
        os_log_type_t v43 = 2048;
        BOOL v44 = qword_18C45F5D8;
        v45 = 2048;
        v46 = qword_18C45F5D0;
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
      }
    }

    qword_18C45F5D0 = 0LL;
    uint64_t v5 = qword_18C45F5F0;
  }

  uint64_t v7 = (void **)qword_18C45F5E8;
  uint64_t v8 = *(uint64_t ***)(qword_18C45F5E8 + 16);
  int v9 = *(void *)qword_18C45F5E8;
  *(void *)(v9 + 8) = *(void *)(qword_18C45F5E8 + 8);
  *v7[1] = v9;
  qword_18C45F5F0 = v5 - 1;
  free(v7);
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_18C45F5F8);
  if (!v8)
  {
LABEL_58:
    uint64_t v32 = objc_getClass((const char *)nw_string::_class(void)::instance);
    if (v32)
    {
      Instance = (uint64_t **)class_createInstance(v32, 0x48uLL);
      if (Instance)
      {
        uint64_t v8 = Instance;
        Instance[2] = &nw_string::_class(void)::instance;
        return v8;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v40 = "operator new";
      BOOL v17 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint64_t v37 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v40 = "operator new";
          BOOL v20 = "%{public}s called with null obj";
          goto LABEL_98;
        }

        goto LABEL_99;
      }

      if (!v37)
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v40 = "operator new";
          BOOL v20 = "%{public}s called with null obj, backtrace limit exceeded";
          goto LABEL_98;
        }

        goto LABEL_99;
      }

      char v26 = (char *)__nw_create_backtrace_string();
      os_log_type_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      char v36 = os_log_type_enabled(v18, type);
      if (!v26)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v40 = "operator new";
          BOOL v20 = "%{public}s called with null obj, no backtrace";
          goto LABEL_98;
        }

        goto LABEL_99;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v40 = "operator new";
        BOOL v41 = 2082;
        uint64_t v42 = v26;
        BOOL v28 = "%{public}s called with null obj, dumping backtrace:%{public}s";
        goto LABEL_78;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v40 = "operator new";
      BOOL v17 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint64_t v37 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v40 = "operator new";
          BOOL v20 = "%{public}s called with null objc_cls";
          goto LABEL_98;
        }

        goto LABEL_99;
      }

      if (!v37)
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v40 = "operator new";
          BOOL v20 = "%{public}s called with null objc_cls, backtrace limit exceeded";
          goto LABEL_98;
        }

        goto LABEL_99;
      }

      char v26 = (char *)__nw_create_backtrace_string();
      os_log_type_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      __int16 v35 = os_log_type_enabled(v18, type);
      if (!v26)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v40 = "operator new";
          BOOL v20 = "%{public}s called with null objc_cls, no backtrace";
          goto LABEL_98;
        }

        goto LABEL_99;
      }

      if (v35)
      {
LABEL_44:
        *(_DWORD *)buf = 136446466;
        __int16 v40 = "operator new";
        BOOL v41 = 2082;
        uint64_t v42 = v26;
        BOOL v28 = "%{public}s called with null objc_cls, dumping backtrace:%{public}s";
        goto LABEL_78;
      }
    }

    goto LABEL_6;
  }

  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    uint64_t v7 = type;
    if (os_log_type_enabled(v2, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_parameters_configure_protocol_disable_block_invoke";
      _os_log_impl( &dword_181A5C000,  v2,  v7,  "%{public}s _nw_parameters_configure_protocol_disable called directly, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  uint64_t v5 = type;
  uint64_t v6 = os_log_type_enabled(v2, type);
  if (!backtrace_string)
  {
    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_parameters_configure_protocol_disable_block_invoke";
      _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_parameters_configure_protocol_disable called directly, no backtrace",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  if (v6)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v11 = "_nw_parameters_configure_protocol_disable_block_invoke";
    os_log_type_t v12 = 2082;
    uint64_t v13 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_parameters_configure_protocol_disable called directly, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v1) {
LABEL_7:
  }
    free(v1);
}

    goto LABEL_6;
  }

  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    uint64_t v7 = type;
    if (os_log_type_enabled(v2, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_parameters_configure_protocol_default_configuration_block_invoke_2";
      _os_log_impl( &dword_181A5C000,  v2,  v7,  "%{public}s _nw_parameters_configure_protocol_default_configuration called directly, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  uint64_t v5 = type;
  uint64_t v6 = os_log_type_enabled(v2, type);
  if (!backtrace_string)
  {
    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_parameters_configure_protocol_default_configuration_block_invoke_2";
      _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_parameters_configure_protocol_default_configuration called directly, no backtrace",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  if (v6)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v11 = "_nw_parameters_configure_protocol_default_configuration_block_invoke_2";
    os_log_type_t v12 = 2082;
    uint64_t v13 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_parameters_configure_protocol_default_configuration called directly, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v1) {
LABEL_7:
  }
    free(v1);
}

    goto LABEL_6;
  }

  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    uint64_t v7 = type;
    if (os_log_type_enabled(v2, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_parameters_configure_sec_protocol_default_configuration_block_invoke_3";
      _os_log_impl( &dword_181A5C000,  v2,  v7,  "%{public}s _nw_parameters_configure_sec_protocol_default_configuration called directly, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  uint64_t v5 = type;
  uint64_t v6 = os_log_type_enabled(v2, type);
  if (!backtrace_string)
  {
    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_parameters_configure_sec_protocol_default_configuration_block_invoke_3";
      _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_parameters_configure_sec_protocol_default_configuration called directly, no backtrace",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  if (v6)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v11 = "_nw_parameters_configure_sec_protocol_default_configuration_block_invoke_3";
    os_log_type_t v12 = 2082;
    uint64_t v13 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_parameters_configure_sec_protocol_default_configuration called directly, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v1) {
LABEL_7:
  }
    free(v1);
}
}

    goto LABEL_6;
  }

  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    uint64_t v7 = type;
    if (os_log_type_enabled(v2, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_connection_send_idempotent_content_block_invoke";
      _os_log_impl( &dword_181A5C000,  v2,  v7,  "%{public}s _nw_connection_send_idempotent_content called directly, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  uint64_t v5 = type;
  uint64_t v6 = os_log_type_enabled(v2, type);
  if (!backtrace_string)
  {
    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = "_nw_connection_send_idempotent_content_block_invoke";
      _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_connection_send_idempotent_content called directly, no backtrace",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  if (v6)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v11 = "_nw_connection_send_idempotent_content_block_invoke";
    os_log_type_t v12 = 2082;
    uint64_t v13 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v2,  v5,  "%{public}s _nw_connection_send_idempotent_content called directly, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v1) {
LABEL_7:
  }
    free(v1);
}

  v39[0] = v15;
  v39[1] = 3221225472LL;
  v39[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_2;
  v39[3] = &unk_189BBFE68;
  __int16 v40 = v9;
  BOOL v41 = v11;
  uint64_t v42 = v10;
  os_log_type_t v43 = v12;
  os_log_type_t v16 = v14;
  BOOL v44 = v16;
  os_unfair_lock_lock(v9 + 6);
  __nw_socks5_server_register_udp_associate_request_block_invoke_2((uint64_t)v39);
  os_unfair_lock_unlock(v9 + 6);

LABEL_6:
}

    int v4 = MEMORY[0x1895F87A8];
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_39716;
    v140 = (uint64_t)&__block_descriptor_tmp_55_39717;
    *(void *)v141 = v2 + 616;
    v141[8] = 0;
    uint64_t v5 = *(void *)(v2 + 616);
    do
    {
      if (!v5) {
        break;
      }
      uint64_t v6 = *(void *)(v5 + 32);
      uint64_t v7 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      uint64_t v5 = v6;
    }

    while ((v7 & 1) != 0);
    if ((*(_BYTE *)(v2 + 158) & 1) == 0)
    {
      if (!gLogDatapath) {
        goto LABEL_10;
      }
      v85 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
      {
        v86 = *(void *)(v2 + 488);
        v87 = *(_DWORD *)(*(void *)(v2 + 480) + 372LL);
        v88 = *(_DWORD *)(v2 + 860);
        if (v86) {
          LODWORD(v86) = *(_DWORD *)(v86 + 424);
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_http1_tear_down_connection";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v2 + 74;
        *(_WORD *)&buf[22] = 2080;
        v140 = (uint64_t)" ";
        *(_WORD *)v141 = 1024;
        *(_DWORD *)&v141[2] = v87;
        *(_WORD *)&v141[6] = 1024;
        *(_DWORD *)&v141[8] = v88;
        *(_WORD *)&v141[12] = 1024;
        *(_DWORD *)&v141[14] = v86;
        _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> finalizing processed_input_frames",  buf,  0x32u);
      }
    }

    if (gLogDatapath)
    {
      v89 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(type) = 136446210;
        *(void *)((char *)&type + 4) = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v89, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&type, 0xCu);
      }
    }

    *(_DWORD *)buf = 136446466;
    uint64_t v32 = "nw_ws_validate_client_request";
    uint64_t v33 = 2082;
    BOOL v34 = (const char *)(a1 + 227);
    _os_log_impl( &dword_181A5C000,  (os_log_t)v7,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s client request doesn't match expected value",  buf,  0x16u);
    goto LABEL_6;
  }

  if (CFStringCompare(v5, @"WebSocket", 1uLL))
  {
    CFRelease(v6);
    goto LABEL_4;
  }

  CFRelease(v6);
  os_log_type_t v10 = CFHTTPMessageCopyHeaderFieldValue(v4, @"Connection");
  uint64_t v11 = v10;
  if (!v10)
  {
LABEL_11:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    if (!os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_ERROR)) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  if (CFStringCompare(v10, @"Upgrade", 1uLL))
  {
    CFRelease(v11);
    goto LABEL_11;
  }

  CFRelease(v11);
  if ((*(_WORD *)(a1 + 225) & 0x40) != 0)
  {
    os_log_type_t v12 = CFHTTPMessageCopyHeaderFieldValue(v4, @"Sec-WebSocket-Extensions");
    if (v12)
    {
      *(_WORD *)(a1 + 225) &= ~0x40u;
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)*MEMORY[0x189604DB0],  v12,  @",");
      CFRelease(v12);
      uint64_t v14 = 0LL;
      char v15 = 0LL;
      while (v14 < CFArrayGetCount(ArrayBySeparatingStrings))
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v14);
        if (v15) {
          CFRelease(v15);
        }
        BOOL v17 = nw_ws_copy_extension_decl_as_array(ValueAtIndex);
        char v15 = v17;
        if (v17)
        {
          if (CFArrayGetCount(v17) >= 1)
          {
            os_log_type_t v18 = (const __CFString *)CFArrayGetValueAtIndex(v15, 0LL);
            if (CFStringCompare(v18, @"permessage-deflate", 1uLL) == kCFCompareEqualTo)
            {
              os_log_type_t v19 = 0;
              BOOL v20 = 1LL;
              *(_WORD *)(a1 + 225) |= 0x40u;
              while (1)
              {
                while (1)
                {
                  while (1)
                  {
                    if (v20 >= CFArrayGetCount(v15)) {
                      goto LABEL_76;
                    }
                    uint64_t v21 = (const __CFString *)CFArrayGetValueAtIndex(v15, v20);
                    uint64_t v30 = -1LL;
                    if (CFStringCompare(v21, @"server_no_context_takeover", 1uLL)) {
                      break;
                    }
                    if ((v19 & 1) != 0)
                    {
                      __nwlog_obj();
                      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 136446466;
                        uint64_t v32 = "nw_ws_validate_client_request";
                        uint64_t v33 = 2082;
                        BOOL v34 = (const char *)(a1 + 227);
                        os_log_type_t v23 = "%{public}s %{public}s Duplicate value for server_no_context_takeover";
                        goto LABEL_68;
                      }

                      goto LABEL_75;
                    }

                    v19 |= 1u;
                    *(_WORD *)(a1 + 225) &= ~0x80u;
                    ++v20;
                  }

                  if (CFStringCompare(v21, @"client_no_context_takeover", 1uLL) == kCFCompareEqualTo) {
                    break;
                  }
                  if (nw_ws_get_extension_parameter(v21, @"server_max_window_bits", &v30))
                  {
                    if ((v19 & 4) != 0)
                    {
                      __nwlog_obj();
                      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        os_log_type_t v24 = "";
                        if (a1) {
                          os_log_type_t v24 = (const char *)(a1 + 227);
                        }
                        goto LABEL_67;
                      }

                      goto LABEL_75;
                    }

                    if ((v30 & 0xFFFFFFFFFFFFFFF8LL) != 8)
                    {
                      __nwlog_obj();
                      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_75;
                      }
                      BOOL v25 = "";
                      uint64_t v32 = "nw_ws_validate_client_request";
                      *(_DWORD *)buf = 136446722;
                      if (a1) {
                        BOOL v25 = (const char *)(a1 + 227);
                      }
                      uint64_t v33 = 2082;
                      BOOL v34 = v25;
                      __int16 v35 = 2048;
                      char v36 = v30;
                      os_log_type_t v23 = "%{public}s %{public}s Invalid value for server_max_window_bits (%llu)";
LABEL_73:
                      unint64_t v27 = v22;
                      BOOL v28 = 32;
                      goto LABEL_74;
                    }

                    v19 |= 4u;
                    *(_BYTE *)(a1 + 220) = v30;
                    ++v20;
                  }

                  else if (CFStringCompare(v21, @"client_max_window_bits", 1uLL))
                  {
                    if (!nw_ws_get_extension_parameter(v21, @"client_max_window_bits", &v30))
                    {
                      __nwlog_obj();
                      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_75;
                      }
                      char v26 = (const char *)(a1 + 227);
                      uint64_t v32 = "nw_ws_validate_client_request";
                      *(_DWORD *)buf = 136446722;
                      if (!a1) {
                        char v26 = "";
                      }
                      uint64_t v33 = 2082;
                      BOOL v34 = v26;
                      __int16 v35 = 2112;
                      char v36 = (unint64_t)v21;
                      os_log_type_t v23 = "%{public}s %{public}s Invalid parameter in permessage-deflate extension (%@)";
                      goto LABEL_73;
                    }

                    if ((v19 & 8) != 0)
                    {
                      __nwlog_obj();
                      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        os_log_type_t v24 = "";
                        if (a1) {
                          os_log_type_t v24 = (const char *)(a1 + 227);
                        }
                        goto LABEL_67;
                      }

                      goto LABEL_75;
                    }

                    v19 |= 8u;
                    if (v30 == -1LL)
                    {
                      *(_BYTE *)(a1 + 221) = 15;
                      ++v20;
                    }

                    else
                    {
                      if ((v30 & 0xFFFFFFFFFFFFFFF8LL) != 8)
                      {
                        __nwlog_obj();
                        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_75;
                        }
                        os_log_type_t v29 = "";
                        uint64_t v32 = "nw_ws_validate_client_request";
                        *(_DWORD *)buf = 136446722;
                        if (a1) {
                          os_log_type_t v29 = (const char *)(a1 + 227);
                        }
                        uint64_t v33 = 2082;
                        BOOL v34 = v29;
                        __int16 v35 = 2048;
                        char v36 = v30;
                        os_log_type_t v23 = "%{public}s %{public}s Invalid value for client_max_window_bits (%llu)";
                        goto LABEL_73;
                      }

                      *(_BYTE *)(a1 + 221) = v30;
                      ++v20;
                    }
                  }

                  else
                  {
                    if ((v19 & 8) != 0)
                    {
                      __nwlog_obj();
                      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        os_log_type_t v24 = "";
                        if (a1) {
                          os_log_type_t v24 = (const char *)(a1 + 227);
                        }
LABEL_67:
                        *(_DWORD *)buf = 136446466;
                        uint64_t v32 = "nw_ws_validate_client_request";
                        uint64_t v33 = 2082;
                        BOOL v34 = v24;
                        os_log_type_t v23 = "%{public}s %{public}s Duplicate value for server_max_window_bits";
LABEL_68:
                        unint64_t v27 = v22;
                        BOOL v28 = 22;
LABEL_74:
                        _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_ERROR, v23, buf, v28);
                      }

      if (++v9 >= a5) {
        goto LABEL_169;
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v80 = (id)gLogObj;
    v81 = *(void *)(v32 + 32);
    *(_DWORD *)v152 = 136446978;
    *(void *)&v152[4] = "-[NWURLSessionMultipartPartBoundarySuffixRecognizer consumeCharacter:]";
    *(_WORD *)&v152[12] = 2082;
    *(void *)&v152[14] = "_count";
    v153 = 2048;
    v154 = 1LL;
    v155 = 2048;
    v156 = v81;
    LODWORD(v143) = 42;
    v142 = v152;
    v82 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v150 = 0;
    if (!__nwlog_fault((const char *)v82, &type, &v150))
    {
LABEL_101:
      if (v82) {
        free(v82);
      }
      *(void *)(v32 + 32) = -1LL;
      goto LABEL_104;
    }

    v83 = a5;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v84 = (os_log_s *)(id)gLogObj;
      v85 = type;
      if (os_log_type_enabled(v84, type))
      {
        v86 = *(void *)(v32 + 32);
        *(_DWORD *)v152 = 136446978;
        *(void *)&v152[4] = "-[NWURLSessionMultipartPartBoundarySuffixRecognizer consumeCharacter:]";
        *(_WORD *)&v152[12] = 2082;
        *(void *)&v152[14] = "_count";
        v153 = 2048;
        v154 = 1LL;
        v155 = 2048;
        v156 = v86;
        v87 = v84;
        v88 = v85;
        v89 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_98:
        _os_log_impl(&dword_181A5C000, v87, v88, v89, v152, 0x2Au);
      }
    }

    else if (v150)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v84 = (os_log_s *)(id)gLogObj;
      v96 = type;
      v97 = os_log_type_enabled(v84, type);
      if (backtrace_string)
      {
        if (v97)
        {
          v98 = *(void *)(v32 + 32);
          *(_DWORD *)v152 = 136447234;
          *(void *)&v152[4] = "-[NWURLSessionMultipartPartBoundarySuffixRecognizer consumeCharacter:]";
          *(_WORD *)&v152[12] = 2082;
          *(void *)&v152[14] = "_count";
          v153 = 2048;
          v154 = 1LL;
          v155 = 2048;
          v156 = v98;
          v157 = 2082;
          v158 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v84,  v96,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  v152,  0x34u);
        }

        free(backtrace_string);
        goto LABEL_100;
      }

      if (v97)
      {
        v140 = *(void *)(v32 + 32);
        *(_DWORD *)v152 = 136446978;
        *(void *)&v152[4] = "-[NWURLSessionMultipartPartBoundarySuffixRecognizer consumeCharacter:]";
        *(_WORD *)&v152[12] = 2082;
        *(void *)&v152[14] = "_count";
        v153 = 2048;
        v154 = 1LL;
        v155 = 2048;
        v156 = v140;
        _os_log_impl( &dword_181A5C000,  v84,  v96,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace",  v152,  0x2Au);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v84 = (os_log_s *)(id)gLogObj;
      v108 = type;
      if (os_log_type_enabled(v84, type))
      {
        v109 = *(void *)(v32 + 32);
        *(_DWORD *)v152 = 136446978;
        *(void *)&v152[4] = "-[NWURLSessionMultipartPartBoundarySuffixRecognizer consumeCharacter:]";
        *(_WORD *)&v152[12] = 2082;
        *(void *)&v152[14] = "_count";
        v153 = 2048;
        v154 = 1LL;
        v155 = 2048;
        v156 = v109;
        v87 = v84;
        v88 = v108;
        v89 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_98;
      }
    }

LABEL_100:
    a5 = v83;
    goto LABEL_101;
  }

  if (v7 >= 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v9 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v204 = "nw_http_copy_metadata_from_binary_message";
      v205 = 2048;
      v206 = (const char *)v7;
      v207 = 2048;
      v208 = 3LL;
      os_log_type_t v10 = "%{public}s _output %llu > _max %llu";
      uint64_t v11 = (os_log_s *)v9;
      os_log_type_t v12 = 32;
LABEL_21:
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
      return 0LL;
    }

    return 0LL;
  }

  uint64_t v13 = (_DWORD *)((char *)a1 + v8);
  uint64_t v14 = a2 - v8;
  char v15 = v7 & 0xFFFFFFFFFFFFFFFDLL;
  os_log_type_t v16 = (void *)_nw_http_parsed_fields_create();
  BOOL v17 = v16;
  if ((v7 & 0xFFFFFFFFFFFFFFFDLL) == 0)
  {
    if (a2 == v8)
    {
LABEL_23:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v18 = (os_log_s *)gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      v204 = "nw_http_copy_metadata_from_binary_message";
      os_log_type_t v19 = "%{public}s Failed to decode integer";
      goto LABEL_25;
    }

    unint64_t v27 = *(unsigned __int8 *)v13;
    if (v27 <= 0x3F)
    {
      BOOL v28 = 1LL;
      goto LABEL_35;
    }

    if (v27 >> 6 == 2)
    {
      if (v14 < 4) {
        goto LABEL_23;
      }
      unint64_t v27 = bswap32(*v13 & 0xFFFFFF7F);
      BOOL v28 = 4LL;
    }

    else
    {
      if (v27 >> 6 == 1)
      {
        if (v14 < 2) {
          goto LABEL_23;
        }
        unint64_t v27 = bswap32(*(_WORD *)v13 & 0xFFBF) >> 16;
        BOOL v28 = 2LL;
        goto LABEL_35;
      }

      if (v14 < 8) {
        goto LABEL_23;
      }
      unint64_t v27 = bswap64(*(void *)v13 & 0xFFFFFFFFFFFFFF3FLL);
      BOOL v28 = 8LL;
    }

    if (v27 >= 0x10000)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      goto LABEL_515;
    }

  if (v18)
  {
    if (!self) {
      goto LABEL_20;
    }
  }

  else
  {
    -[NWURLSessionResponseConsumerDownload setError:]((uint64_t)self, v14);
    if (!self) {
      goto LABEL_20;
    }
  }

  if (self->_io)
  {
LABEL_8:
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __90__NWURLSessionResponseConsumerDownload_task_deliverData_complete_error_completionHandler___block_invoke;
    aBlock[3] = &unk_189BC08F8;
    os_log_type_t v19 = (id *)v12;
    v38 = size;
    __int16 v35 = v19;
    char v36 = self;
    v39 = v9;
    uint64_t v37 = v15;
    BOOL v20 = _Block_copy(aBlock);
    uint64_t v21 = v20;
    if (v13)
    {
      uint64_t v22 = v14;
      os_log_type_t v23 = self->_io;
      os_log_type_t v24 = v12;
      if (v19)
      {
        BOOL v25 = v19[50];
        char v26 = v25;
        unint64_t v27 = v15;
        if (v25) {
          BOOL v28 = (void *)*((void *)v25 + 18);
        }
        else {
          BOOL v28 = 0LL;
        }
      }

      else
      {
        unint64_t v27 = v15;
        char v26 = 0LL;
        BOOL v28 = 0LL;
      }

      os_log_type_t v29 = v28;
      v31[0] = MEMORY[0x1895F87A8];
      v31[1] = 3221225472LL;
      v31[2] = __90__NWURLSessionResponseConsumerDownload_task_deliverData_complete_error_completionHandler___block_invoke_3;
      v31[3] = &unk_189BC0920;
      v31[4] = self;
      uint64_t v32 = v19;
      uint64_t v33 = v21;
      dispatch_io_write((dispatch_io_t)v23, 0LL, v13, v29, v31);

      char v15 = v27;
      os_log_type_t v12 = v24;
      uint64_t v14 = v22;
    }

    else
    {
      (*((void (**)(void *))v20 + 2))(v20);
    }

    goto LABEL_14;
  }

        break;
    }
  }
}

  uint64_t v8 = 0LL;
LABEL_6:

  return v8;
}

  *((_BYTE *)a2 + 30) = 3;
  uint64_t v5 = *a2;
  uint64_t v6 = (void *)a2[1];
  if (*a2)
  {
    *(void *)(v5 + 8) = v6;
    uint64_t v6 = (void *)a2[1];
  }

  else
  {
    *(void *)(a1 + 8) = v6;
  }

  *uint64_t v6 = v5;
  free(a2);
}

  uint64_t v8 = 0LL;
LABEL_7:

  return v8;
}
}
}

  uint64_t v5 = 0LL;
LABEL_7:

  return v5;
}

  uint64_t v5 = 0LL;
LABEL_7:

  return v5;
}

LABEL_63:
  __break(1u);
  return result;
}

        goto LABEL_64;
      }
    }

    else
    {
    }

    if ((*((_BYTE *)v26 + 268) & 0x20) != 0) {
      goto LABEL_64;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v30 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      if ((*((_BYTE *)v26 + 268) & 1) != 0) {
        BOOL v44 = "dry-run ";
      }
      else {
        BOOL v44 = "";
      }
      v45 = nw_endpoint_handler_copy_endpoint(v26);
      v46 = nw_endpoint_get_logging_description(v45);
      v47 = *((unsigned int *)v5 + 30);
      v48 = v46;
      else {
        v49 = off_189BBBBF0[v47];
      }
      v75 = v49;
      v50 = v26;
      v51 = (os_unfair_lock_s *)v50;
      os_log_type_t v52 = *((_DWORD *)v5 + 29);
      os_log_type_t v53 = "path";
      switch(v52)
      {
        case 0:
          break;
        case 1:
          os_log_type_t v53 = "resolver";
          break;
        case 2:
          os_log_type_t v53 = nw_endpoint_flow_mode_string(v50[31]);
          break;
        case 3:
          os_log_type_t v53 = "proxy";
          break;
        case 4:
          os_log_type_t v53 = "fallback";
          break;
        case 5:
          os_log_type_t v53 = "transform";
          break;
        default:
          os_log_type_t v53 = "unknown-mode";
          break;
      }

      uint64_t v54 = v51 + 28;
      v55 = v2;
      v56 = v51;
      os_unfair_lock_lock(v51 + 28);
      uint64_t v57 = v56[8];
      os_unfair_lock_unlock(v54);

      uint64_t v2 = v55;
      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      v81 = 2082;
      v82 = v26 + 21;
      v83 = 2082;
      v84 = v44;
      v85 = 2082;
      v86 = v48;
      v87 = 2082;
      v88 = v75;
      v89 = 2082;
      v90 = v53;
      v91 = 2114;
      v92 = v57;
      _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] state changed during initial re port, not starting",  buf,  0x48u);
    }

    goto LABEL_63;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v5 + 28);
  v39 = v5[8];
  v5[8] = 0LL;

  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 28);
  __int16 v40 = v5[7];
  if (v40 && (*((_BYTE *)v5 + 268) & 4) == 0)
  {
    nw_association_unregister(v40, v5);
    BOOL v41 = v5[7];
    v5[7] = 0LL;
  }

  *((_DWORD *)v5 + 30) = 1;
  nw_endpoint_handler_initialize_association(v5);
  uint64_t v42 = nw_association_copy_current_path(v5[7], v2[4]);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 28);
  os_log_type_t v43 = v5[8];
  v5[8] = v42;

  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 28);
  *((_BYTE *)v5 + 268) &= ~4u;
  nw_endpoint_handler_path_change((NWConcrete_nw_endpoint_handler *)v5);
LABEL_64:
}

        free(v22);
        goto LABEL_64;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl( &dword_181A5C000,  v23,  v31,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v34 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v22) {
      free(v22);
    }
    goto LABEL_77;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_active_instance_count";
    char v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v26, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_active_instance_count";
          _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v46)
      {
        char v36 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v37 = type;
        v38 = os_log_type_enabled(v27, type);
        if (v36)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_active_instance_count";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v36;
            _os_log_impl( &dword_181A5C000,  v27,  v37,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v36);
          goto LABEL_68;
        }

        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_active_instance_count";
          _os_log_impl(&dword_181A5C000, v27, v37, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_active_instance_count";
          _os_log_impl( &dword_181A5C000,  v27,  v43,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  __break(1u);
  return result;
}

        goto LABEL_64;
      }

      if (!v43)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v39 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl( &dword_181A5C000,  v22,  v39,  "%{public}s called with null protocol_identifier, backtrace limit exceeded",  v48,  0xCu);
        }

        goto LABEL_63;
      }

      uint64_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v33 = buf[0];
      BOOL v34 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!v30)
      {
        if (v34)
        {
          *(_DWORD *)v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl( &dword_181A5C000,  v22,  v33,  "%{public}s called with null protocol_identifier, no backtrace",  v48,  0xCu);
        }

        goto LABEL_63;
      }

      if (v34)
      {
        *(_DWORD *)v48 = 136446466;
        *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
        *(_WORD *)&v48[12] = 2082;
        *(void *)&v48[14] = v30;
        _os_log_impl( &dword_181A5C000,  v22,  v33,  "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s",  v48,  0x16u);
      }

      goto LABEL_43;
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v48 = 136446210;
    *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t v43 = 0;
    if (__nwlog_fault(v21, buf, &v43))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null parameters", v48, 0xCu);
        }

        goto LABEL_63;
      }

      if (!v43)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v38 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl( &dword_181A5C000,  v22,  v38,  "%{public}s called with null parameters, backtrace limit exceeded",  v48,  0xCu);
        }

        goto LABEL_63;
      }

      uint64_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v31 = buf[0];
      uint64_t v32 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!v30)
      {
        if (v32)
        {
          *(_DWORD *)v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_181A5C000, v22, v31, "%{public}s called with null parameters, no backtrace", v48, 0xCu);
        }

        goto LABEL_63;
      }

      if (v32)
      {
        *(_DWORD *)v48 = 136446466;
        *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
        *(_WORD *)&v48[12] = 2082;
        *(void *)&v48[14] = v30;
        _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  v48,  0x16u);
      }

    free(backtrace_string);
    goto LABEL_90;
  }

  handle = output_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = output_handler[1].callbacks;
    if (callbacks) {
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
  }

  os_log_type_t v10 = output_handler->callbacks;
  if (v10)
  {
    finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v10->finalize_output_frames;
    if (finalize_output_frames)
    {
      os_log_type_t v12 = finalize_output_frames(output_handler, a2);
      if (handle != &nw_protocol_ref_counted_handle) {
        return v12;
      }
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  name = output_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v47 = "__nw_protocol_finalize_output_frames";
  if (!name) {
    name = "invalid";
  }
  v48 = 2082;
  v49 = (void *)name;
  v50 = 2048;
  v51 = output_handler;
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v44 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v20 = (os_log_s *)__nwlog_obj();
    uint64_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_73;
    }
    uint64_t v22 = output_handler->identifier->name;
    if (!v22) {
      uint64_t v22 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v22;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_72:
    _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
    goto LABEL_73;
  }

  if (!v44)
  {
    BOOL v20 = (os_log_s *)__nwlog_obj();
    uint64_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_73;
    }
    char v36 = output_handler->identifier->name;
    if (!v36) {
      char v36 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v36;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
    goto LABEL_72;
  }

  BOOL v28 = (char *)__nw_create_backtrace_string();
  BOOL v20 = (os_log_s *)__nwlog_obj();
  uint64_t v21 = type;
  os_log_type_t v29 = os_log_type_enabled(v20, type);
  if (!v28)
  {
    if (!v29) {
      goto LABEL_73;
    }
    uint64_t v37 = output_handler->identifier->name;
    if (!v37) {
      uint64_t v37 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v37;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
    goto LABEL_72;
  }

  if (v29)
  {
    uint64_t v30 = output_handler->identifier->name;
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v30;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v52 = 2082;
    os_log_type_t v53 = v28;
    _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v28);
LABEL_73:
  if (v19) {
    free(v19);
  }
  os_log_type_t v12 = 0LL;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_13:
    if (output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v14 = output_handler[1].callbacks;
      if (v14)
      {
        char v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
        output_handler[1].callbacks = v15;
        if (!v15)
        {
          os_log_type_t v16 = *(void (***)(void))output_handler[1].flow_id;
          if (v16)
          {
            *(void *)output_handler[1].flow_id = 0LL;
            v16[2](v16);
            _Block_release(v16);
          }

          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            BOOL v17 = *(const void **)output_handler[1].flow_id;
            if (v17) {
              _Block_release(v17);
            }
          }

          free(output_handler);
        }
      }
    }
  }

  return v12;
}

LABEL_64:
        if (!v6) {
          return (NSString *)v4;
        }
LABEL_65:
        free(v6);
        return (NSString *)v4;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v27 = type;
      BOOL v28 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v37 = "-[NWConcrete_nw_error description]";
          _os_log_impl( &dword_181A5C000,  v7,  v27,  "%{public}s CFStringCreateWithCString failed, no backtrace",  buf,  0xCu);
        }

        goto LABEL_63;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v37 = "-[NWConcrete_nw_error description]";
        v38 = 2082;
        v39 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v27,  "%{public}s CFStringCreateWithCString failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      if (v6) {
        goto LABEL_65;
      }
      return (NSString *)v4;
    case 2:
      string_for_dns_service_error = nwlog_get_string_for_dns_service_error(self->code);
      int v4 = (__CFString *)CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"DNS Error: %s",  string_for_dns_service_error);
      if (v4) {
        return (NSString *)v4;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (id)gLogObj;
      *(_DWORD *)__strerrbuf = 136446210;
      BOOL v41 = "-[NWConcrete_nw_error description]";
      uint64_t v11 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = buf[0];
        if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__strerrbuf = 136446210;
          BOOL v41 = "-[NWConcrete_nw_error description]";
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s CFStringCreateWithFormat failed",  (uint8_t *)__strerrbuf,  0xCu);
        }
      }

      else if (type)
      {
        os_log_type_t v19 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v20 = buf[0];
        uint64_t v21 = os_log_type_enabled(v12, (os_log_type_t)buf[0]);
        if (v19)
        {
          if (v21)
          {
            *(_DWORD *)__strerrbuf = 136446466;
            BOOL v41 = "-[NWConcrete_nw_error description]";
            uint64_t v42 = 2082;
            *(void *)os_log_type_t v43 = v19;
            _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s CFStringCreateWithFormat failed, dumping backtrace:%{public}s",  (uint8_t *)__strerrbuf,  0x16u);
          }

          free(v19);
          if (v11) {
LABEL_57:
          }
            free(v11);
LABEL_58:
          int v4 = 0LL;
          return (NSString *)v4;
        }

        if (v21)
        {
          *(_DWORD *)__strerrbuf = 136446210;
          BOOL v41 = "-[NWConcrete_nw_error description]";
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s CFStringCreateWithFormat failed, no backtrace",  (uint8_t *)__strerrbuf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = buf[0];
        if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__strerrbuf = 136446210;
          BOOL v41 = "-[NWConcrete_nw_error description]";
          _os_log_impl( &dword_181A5C000,  v12,  v29,  "%{public}s CFStringCreateWithFormat failed, backtrace limit exceeded",  (uint8_t *)__strerrbuf,  0xCu);
        }
      }

      goto LABEL_56;
    case 3:
      int v4 = (__CFString *)SecCopyErrorMessageString(self->code, 0LL);
      if (v4) {
        return (NSString *)v4;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (id)gLogObj;
      code = self->code;
      *(_DWORD *)__strerrbuf = 136446466;
      BOOL v41 = "-[NWConcrete_nw_error description]";
      uint64_t v42 = 1024;
      *(_DWORD *)os_log_type_t v43 = code;
      uint64_t v11 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (os_log_s *)(id)gLogObj;
        BOOL v17 = buf[0];
        if (os_log_type_enabled(v16, (os_log_type_t)buf[0]))
        {
          os_log_type_t v18 = self->code;
          *(_DWORD *)__strerrbuf = 136446466;
          BOOL v41 = "-[NWConcrete_nw_error description]";
          uint64_t v42 = 1024;
          *(_DWORD *)os_log_type_t v43 = v18;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s SecCopyErrorMessageString(%d, NULL) failed",  (uint8_t *)__strerrbuf,  0x12u);
        }
      }

      else if (type)
      {
        uint64_t v22 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = buf[0];
        os_log_type_t v24 = os_log_type_enabled(v16, (os_log_type_t)buf[0]);
        if (v22)
        {
          if (v24)
          {
            BOOL v25 = self->code;
            *(_DWORD *)__strerrbuf = 136446722;
            BOOL v41 = "-[NWConcrete_nw_error description]";
            uint64_t v42 = 1024;
            *(_DWORD *)os_log_type_t v43 = v25;
            v43[2] = 2082;
            *(void *)&v43[3] = v22;
            _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s SecCopyErrorMessageString(%d, NULL) failed, dumping backtrace:%{public}s",  (uint8_t *)__strerrbuf,  0x1Cu);
          }

          free(v22);
          if (v11) {
            goto LABEL_57;
          }
          goto LABEL_58;
        }

        if (v24)
        {
          uint64_t v33 = self->code;
          *(_DWORD *)__strerrbuf = 136446466;
          BOOL v41 = "-[NWConcrete_nw_error description]";
          uint64_t v42 = 1024;
          *(_DWORD *)os_log_type_t v43 = v33;
          _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s SecCopyErrorMessageString(%d, NULL) failed, no backtrace",  (uint8_t *)__strerrbuf,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v30 = buf[0];
        if (os_log_type_enabled(v16, (os_log_type_t)buf[0]))
        {
          BOOL v31 = self->code;
          *(_DWORD *)__strerrbuf = 136446466;
          BOOL v41 = "-[NWConcrete_nw_error description]";
          uint64_t v42 = 1024;
          *(_DWORD *)os_log_type_t v43 = v31;
          _os_log_impl( &dword_181A5C000,  v16,  v30,  "%{public}s SecCopyErrorMessageString(%d, NULL) failed, backtrace limit exceeded",  (uint8_t *)__strerrbuf,  0x12u);
        }
      }

LABEL_56:
      if (!v11) {
        goto LABEL_58;
      }
      goto LABEL_57;
    default:
      goto LABEL_58;
  }

      BOOL result = 0LL;
      goto LABEL_37;
    }

    __break(1u);
  }

  __break(1u);
  return result;
}

  v46 = a4;
  v47 = v23;
  v48 = sub_181C94200;
  v49 = 0LL;
  __swift_instantiateConcreteTypeFromMangledName(&qword_18C58D498);
  sub_181C02894((unint64_t *)&unk_18C58D4A0, &qword_18C58D498, MEMORY[0x189619618]);
  sub_18264EB14();
  a4 = 0LL;
  unint64_t v27 = 0xE000000000000000LL;
LABEL_64:
LABEL_65:
  if (v17) {
    BOOL v28 = 0x656D656863733ALL;
  }
  else {
    BOOL v28 = 0LL;
  }
  if (v17) {
    os_log_type_t v29 = 0xE700000000000000LL;
  }
  else {
    os_log_type_t v29 = 0LL;
  }
  if (v17) {
    uint64_t v30 = v15;
  }
  else {
    uint64_t v30 = 0LL;
  }
  if (v22) {
    BOOL v31 = 0x69726F687475613ALL;
  }
  else {
    BOOL v31 = 0LL;
  }
  uint64_t v32 = v17;
  if (v22) {
    uint64_t v33 = 0xEA00000000007974LL;
  }
  else {
    uint64_t v33 = 0LL;
  }
  if (v22) {
    BOOL v34 = a3;
  }
  else {
    BOOL v34 = 0LL;
  }
  BOOL v41 = v30;
  uint64_t v42 = v34;
  __int16 v40 = v22;
  if (v27) {
    __int16 v35 = 0x687461703ALL;
  }
  else {
    __int16 v35 = 0LL;
  }
  if (v27) {
    char v36 = 0xE500000000000000LL;
  }
  else {
    char v36 = 0LL;
  }
  if (v27) {
    uint64_t v37 = a4;
  }
  else {
    uint64_t v37 = 0LL;
  }
  os_log_type_t v43 = v37;
  HTTPFields.init(dictionaryLiteral:)(MEMORY[0x18961AFE8], &v46);
  v38 = v46;
  type metadata accessor for __NWHTTPRequest();
  BOOL result = swift_allocObject();
  *(void *)(result + 16) = 0x646F6874656D3ALL;
  *(void *)(result + 24) = 0xE700000000000000LL;
  *(void *)(result + 32) = 0x646F6874656D3ALL;
  *(void *)(result + 40) = 0xE700000000000000LL;
  *(_BYTE *)(result + 48) = 0;
  *(void *)(result + 56) = v44;
  *(void *)(result + 64) = v45;
  *(void *)(result + 72) = v28;
  *(void *)(result + 80) = v29;
  *(void *)(result + 88) = v28;
  *(void *)(result + 96) = v29;
  *(void *)(result + 104) = 0LL;
  *(void *)(result + 112) = v41;
  *(void *)(result + 120) = v32;
  *(void *)(result + 128) = v31;
  *(void *)(result + 136) = v33;
  *(void *)(result + 144) = v31;
  *(void *)(result + 152) = v33;
  *(void *)(result + 160) = 0LL;
  *(void *)(result + 168) = v42;
  *(void *)(result + 176) = v40;
  *(void *)(result + 184) = v35;
  *(void *)(result + 192) = v36;
  *(void *)(result + 200) = v35;
  *(void *)(result + 208) = v36;
  *(void *)(result + 216) = 0LL;
  *(void *)(result + 224) = v43;
  *(void *)(result + 232) = v27;
  *(_OWORD *)(result + 256) = 0u;
  *(_OWORD *)(result + 272) = 0u;
  *(_OWORD *)(result + 240) = 0u;
  *(void *)(result + 288) = 0LL;
  *(void *)(result + 296) = v38;
  return result;
}

LABEL_64:
    if (!v7) {
      goto LABEL_74;
    }
    goto LABEL_65;
  }

  if (!v72)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)(id)gLogObj;
    v38 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v76 = 2082;
      *(void *)v77 = v5;
      _os_log_impl( &dword_181A5C000,  v8,  v38,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_63;
  }

  os_log_type_t v24 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v8 = (os_log_s *)(id)gLogObj;
  BOOL v25 = type;
  char v26 = os_log_type_enabled(v8, type);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v76 = 2082;
      *(void *)v77 = v5;
      _os_log_impl( &dword_181A5C000,  v8,  v25,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
    }

    goto LABEL_63;
  }

  if (v26)
  {
    *(_DWORD *)buf = 136446722;
    v75 = "networkd_privileged_check_mobile_asset_block_invoke";
    v76 = 2082;
    *(void *)v77 = v5;
    *(_WORD *)&v77[8] = 2082;
    *(void *)&v77[10] = v24;
    _os_log_impl( &dword_181A5C000,  v8,  v25,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v24);
  if (v7) {
    goto LABEL_65;
  }
LABEL_74:
  if (v5) {
LABEL_75:
  }
    free(v5);
LABEL_136:
}

LABEL_64:
    if (!v7) {
      goto LABEL_74;
    }
    goto LABEL_65;
  }

  if (!v72)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)(id)gLogObj;
    v38 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v76 = 2082;
      *(void *)v77 = v5;
      _os_log_impl( &dword_181A5C000,  v8,  v38,  "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_63;
  }

  os_log_type_t v24 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v8 = (os_log_s *)(id)gLogObj;
  BOOL v25 = type;
  char v26 = os_log_type_enabled(v8, type);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v76 = 2082;
      *(void *)v77 = v5;
      _os_log_impl( &dword_181A5C000,  v8,  v25,  "%{public}s received unknown type XPC %{public}s, no backtrace",  buf,  0x16u);
    }

    goto LABEL_63;
  }

  if (v26)
  {
    *(_DWORD *)buf = 136446722;
    v75 = "networkd_privileged_run_probes_block_invoke";
    v76 = 2082;
    *(void *)v77 = v5;
    *(_WORD *)&v77[8] = 2082;
    *(void *)&v77[10] = v24;
    _os_log_impl( &dword_181A5C000,  v8,  v25,  "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v24);
  if (v7) {
    goto LABEL_65;
  }
LABEL_74:
  if (v5) {
LABEL_75:
  }
    free(v5);
LABEL_136:
}

      free(v37);
      if (!v25) {
        return;
      }
LABEL_90:
      free(v25);
      return;
    }

    char v26 = (os_log_s *)__nwlog_obj();
    unint64_t v27 = type;
    if (!os_log_type_enabled(v26, type)) {
      goto LABEL_89;
    }
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_plugin_name_set_name";
    BOOL v28 = "%{public}s called with null protocol";
LABEL_88:
    _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
    goto LABEL_89;
  }

  int v4 = a3;
  if (a3) {
    goto LABEL_12;
  }
  uint64_t v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)(a2 + 88);
    if (v7) {
      *(void *)(a2 + 88) = v7 + 1;
    }
  }

  uint64_t v8 = *(void *)(a2 + 24);
  if (v8)
  {
    int v9 = *(uint64_t (**)(uint64_t))(v8 + 112);
    if (v9)
    {
      int v4 = (uint64_t *)v9(a2);
      if (v6 != &nw_protocol_ref_counted_handle) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }

  __nwlog_obj();
  os_log_type_t v29 = *(const char **)(a2 + 16);
  *(_DWORD *)buf = 136446722;
  v49 = "__nw_protocol_get_parameters";
  if (!v29) {
    os_log_type_t v29 = "invalid";
  }
  v50 = 2082;
  v51 = (void *)v29;
  os_log_type_t v52 = 2048;
  os_log_type_t v53 = a2;
  uint64_t v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v46 = 0;
  if (__nwlog_fault(v30, &type, &v46))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v31 = (os_log_s *)__nwlog_obj();
      uint64_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_96;
      }
      uint64_t v33 = *(const char **)(a2 + 16);
      if (!v33) {
        uint64_t v33 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v33;
      os_log_type_t v52 = 2048;
      os_log_type_t v53 = a2;
      BOOL v34 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_95:
      _os_log_impl(&dword_181A5C000, v31, v32, v34, buf, 0x20u);
      goto LABEL_96;
    }

    if (!v46)
    {
      BOOL v31 = (os_log_s *)__nwlog_obj();
      uint64_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_96;
      }
      BOOL v44 = *(const char **)(a2 + 16);
      if (!v44) {
        BOOL v44 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v44;
      os_log_type_t v52 = 2048;
      os_log_type_t v53 = a2;
      BOOL v34 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
      goto LABEL_95;
    }

    BOOL v41 = (char *)__nw_create_backtrace_string();
    BOOL v31 = (os_log_s *)__nwlog_obj();
    uint64_t v32 = type;
    uint64_t v42 = os_log_type_enabled(v31, type);
    if (!v41)
    {
      if (!v42) {
        goto LABEL_96;
      }
      v45 = *(const char **)(a2 + 16);
      if (!v45) {
        v45 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v45;
      os_log_type_t v52 = 2048;
      os_log_type_t v53 = a2;
      BOOL v34 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
      goto LABEL_95;
    }

    if (v42)
    {
      os_log_type_t v43 = *(const char **)(a2 + 16);
      if (!v43) {
        os_log_type_t v43 = "invalid";
      }
      *(_DWORD *)buf = 136446978;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v43;
      os_log_type_t v52 = 2048;
      os_log_type_t v53 = a2;
      uint64_t v54 = 2082;
      v55 = v41;
      _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v41);
  }

        goto LABEL_64;
      }

      if (!v31)
      {
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v30 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_framer_protocol_connect";
          _os_log_impl( &dword_181A5C000,  v16,  v30,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_63;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      unint64_t v27 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_framer_protocol_connect";
          _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
        }

        goto LABEL_63;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v34 = "nw_framer_protocol_connect";
        __int16 v35 = 2082;
        char v36 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v16,  v26,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      BOOL v34 = "nw_framer_protocol_connect";
      char v15 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v31 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_framer_protocol_connect";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null framer", buf, 0xCu);
        }

        goto LABEL_63;
      }

      if (!v31)
      {
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_framer_protocol_connect";
          _os_log_impl( &dword_181A5C000,  v16,  v29,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_63;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "nw_framer_protocol_connect";
          _os_log_impl(&dword_181A5C000, v16, v24, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }

        goto LABEL_63;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v34 = "nw_framer_protocol_connect";
        __int16 v35 = 2082;
        char v36 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v16,  v24,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_64;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v34 = "nw_framer_protocol_connect";
  uint64_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v31 = 0;
  if (__nwlog_fault(v11, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_framer_protocol_connect";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v31)
    {
      BOOL v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v21 = type;
      uint64_t v22 = os_log_type_enabled(v12, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v34 = "nw_framer_protocol_connect";
          __int16 v35 = 2082;
          char v36 = v20;
          _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v20);
        goto LABEL_55;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_framer_protocol_connect";
        _os_log_impl(&dword_181A5C000, v12, v21, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v34 = "nw_framer_protocol_connect";
        _os_log_impl( &dword_181A5C000,  v12,  v28,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v13) {
    free(v13);
  }
}

  if (v22) {
    free(v22);
  }
  return 0LL;
}

      goto LABEL_64;
    case 1:
      dns_error = nw_error_create_dns_error(a3);
      uint64_t v8 = a1[4];
      uint64_t v7 = (void *)a1[5];
      if (v7)
      {
        if (v8)
        {
          if ((*(_BYTE *)(v8 + 346) & 0x20) != 0) {
            goto LABEL_69;
          }
          if (*(_BYTE *)(v8 + 256))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            int v9 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
              goto LABEL_68;
            }
            os_log_type_t v10 = a1[5];
            uint64_t v11 = a1[4] + 256LL;
            os_log_type_t v52 = 136446978;
            os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            uint64_t v54 = 2082;
            *(void *)v55 = v11;
            *(_WORD *)&v55[8] = 2112;
            *(void *)&v55[10] = dns_error;
            *(_WORD *)&v55[18] = 2114;
            *(void *)&v55[20] = v10;
            os_log_type_t v12 = "%{public}s [C%{public}s] Got DNS error %@ for %{public}@";
            uint64_t v13 = v9;
            uint64_t v14 = 42;
            goto LABEL_67;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v9 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            uint64_t v37 = a1[5];
            v38 = *(_DWORD *)(a1[4] + 340LL);
            os_log_type_t v52 = 136446978;
            os_log_type_t v53 = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
            uint64_t v54 = 1024;
            *(_DWORD *)v55 = v38;
            *(_WORD *)&v55[4] = 2112;
            *(void *)&v55[6] = dns_error;
            *(_WORD *)&v55[14] = 2114;
            *(void *)&v55[16] = v37;
            os_log_type_t v12 = "%{public}s [R%u] Got DNS error %@ for %{public}@";
            uint64_t v13 = v9;
            uint64_t v14 = 38;
            goto LABEL_67;
          }

    goto LABEL_64;
  }

  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_data_transfer_report);
  uint64_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v24, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
          _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null report", buf, 0xCu);
        }
      }

      else if (v39)
      {
        uint64_t v33 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v34 = type;
        __int16 v35 = os_log_type_enabled(v25, type);
        if (v33)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
            os_log_type_t v43 = 2082;
            BOOL v44 = v33;
            _os_log_impl( &dword_181A5C000,  v25,  v34,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v33);
          goto LABEL_70;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
          _os_log_impl(&dword_181A5C000, v25, v34, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v38 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_data_transfer_report_create_from_dictionary";
          _os_log_impl( &dword_181A5C000,  v25,  v38,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(backtrace_string);
    goto LABEL_64;
  }

  if (!v4)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_instance_access_cached_content";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null access_block", buf, 0xCu);
      }

      goto LABEL_104;
    }

    if (!v48)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v42 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v42,  "%{public}s called with null access_block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v30 = type;
    BOOL v31 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl(&dword_181A5C000, v13, v30, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }

      goto LABEL_104;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_instance_access_cached_content";
      os_log_type_t v52 = 2082;
      os_log_type_t v53 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v30,  "%{public}s called with null access_block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_63;
  }

  uint64_t v6 = v3[1];
  if (!v6)
  {
    __nwlog_obj();
    BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_instance_access_cached_content";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null instance->parent_definition", buf, 0xCu);
      }

      goto LABEL_104;
    }

    if (!v48)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v43,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v32 = type;
    uint64_t v33 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_instance_access_cached_content";
      os_log_type_t v52 = 2082;
      os_log_type_t v53 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_63;
  }

  uint64_t v7 = v6[9];
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_instance_access_cached_content";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null instance->parent_definition->common_state",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    if (!v48)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v44,  "%{public}s called with null instance->parent_definition->common_state, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v34 = type;
    __int16 v35 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_instance_access_cached_content";
        _os_log_impl( &dword_181A5C000,  v13,  v34,  "%{public}s called with null instance->parent_definition->common_state, no backtrace",  buf,  0xCu);
      }

      goto LABEL_104;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_instance_access_cached_content";
      os_log_type_t v52 = 2082;
      os_log_type_t v53 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v13,  v34,  "%{public}s called with null instance->parent_definition->common_state, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_63;
  }

  if (*(void *)(v7 + 56))
  {
    uint64_t v8 = nw_protocol_instance_copy_association(v3);
    int v9 = v8;
    if (v8)
    {
      if (nw_association_get_cached_content_for_protocol(v8, v3[1]))
      {
        os_log_type_t v10 = v5[2](v5);
LABEL_111:

        goto LABEL_112;
      }

    goto LABEL_64;
  }

  if (a2 != -1)
  {
    node = nw_hash_table_get_node(v7[29], a2, 8LL);
    if (node)
    {
      if (a3) {
        os_log_type_t v10 = 2048;
      }
      else {
        os_log_type_t v10 = 0;
      }
      *(_WORD *)(node + 84) = *(_WORD *)(node + 84) & 0xF7FF | v10;
      *(_DWORD *)(node + 76) = a4;
      if (a3)
      {
        if (*(_DWORD *)(*((void *)v8 + 1) + 64LL) == 3)
        {
          uint64_t v11 = *(void **)(node + 16);
          if (v11)
          {
            os_log_type_t v12 = v11[3];
            if (v12)
            {
              uint64_t v13 = *(void (**)(void))(v12 + 160);
              if (v13)
              {
                uint64_t v14 = (void *)v11[5];
                if (v14 == &nw_protocol_ref_counted_handle)
                {
                  BOOL v17 = v11[11];
                  if (v17) {
                    v11[11] = v17 + 1;
                  }
                  char v15 = -1;
                }

                else
                {
                  char v15 = 0;
                }

                *(void *)buf = v11;
                buf[8] = v15;
                os_log_type_t v18 = (void *)*((void *)v8 - 7);
                if (v18 == &nw_protocol_ref_counted_handle)
                {
                  BOOL v20 = *((void *)v8 - 1);
                  if (v20) {
                    *((void *)v8 - 1) = v20 + 1;
                  }
                  os_log_type_t v19 = -1;
                }

                else
                {
                  os_log_type_t v19 = 0;
                }

                *(void *)os_log_type_t type = v8 - 96;
                uint64_t v37 = v19;
                v13();
                if (v18 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                }
                if (v14 == &nw_protocol_ref_counted_handle) {
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
              }
            }
          }
        }
      }
    }

    else if ((v8[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v16 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
        v39 = 2082;
        __int16 v40 = v8 + 407;
        BOOL v41 = 2080;
        uint64_t v42 = " ";
        os_log_type_t v43 = 2048;
        BOOL v44 = a2;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sCannot set datagram, flow %llx does not exist",  buf,  0x2Au);
      }
    }

    goto LABEL_18;
  }

  __nwlog_obj();
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
  uint64_t v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  __int16 v35 = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v26 = type[0];
    if (os_log_type_enabled(v23, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
      _os_log_impl(&dword_181A5C000, v23, v26, "%{public}s called with null (flow != NW_PROTOCOL_ALL_FLOWS)", buf, 0xCu);
    }

    goto LABEL_63;
  }

  if (!v35)
  {
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v34 = type[0];
    if (os_log_type_enabled(v23, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
      _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s called with null (flow != NW_PROTOCOL_ALL_FLOWS), backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_63;
  }

  uint64_t v30 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v31 = type[0];
  uint64_t v32 = os_log_type_enabled(v23, type[0]);
  if (!v30)
  {
    if (v32)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
      _os_log_impl( &dword_181A5C000,  v23,  v31,  "%{public}s called with null (flow != NW_PROTOCOL_ALL_FLOWS), no backtrace",  buf,  0xCu);
    }

    goto LABEL_63;
  }

  if (v32)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_set_flow_is_datagram";
    v39 = 2082;
    __int16 v40 = v30;
    _os_log_impl( &dword_181A5C000,  v23,  v31,  "%{public}s called with null (flow != NW_PROTOCOL_ALL_FLOWS), dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v30);
  if (v22) {
    goto LABEL_65;
  }
LABEL_18:
}

    if (v25) {
      free(v25);
    }
    goto LABEL_22;
  }

  __nwlog_obj();
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
  uint64_t v21 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v44 = 0;
  if (__nwlog_fault(v21, &type, &v44))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
        _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v44)
    {
      os_log_type_t v29 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = type;
      BOOL v31 = os_log_type_enabled(v22, type);
      if (v29)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v29;
          _os_log_impl( &dword_181A5C000,  v22,  v30,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v29);
        goto LABEL_57;
      }

      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
        _os_log_impl(&dword_181A5C000, v22, v30, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v35 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_flow_replay_finalize_output_frames";
        _os_log_impl( &dword_181A5C000,  v22,  v35,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(backtrace_string);
    if (!v19) {
      goto LABEL_110;
    }
    goto LABEL_109;
  }

  if (v7 == (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_18956)
  {
    __nwlog_obj();
    BOOL v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_parameters_create_webtransport_http";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nw_parameters_create_webtransport_http";
        _os_log_impl( &dword_181A5C000,  v20,  v29,  "%{public}s called with null (configure_webtransport != (_nw_parameters_configure_protocol_disable))",  buf,  0xCu);
      }
    }

    else if (v55)
    {
      os_log_type_t v43 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      v45 = os_log_type_enabled(v20, type);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v58 = "nw_parameters_create_webtransport_http";
          v59 = 2082;
          v60 = v43;
          _os_log_impl( &dword_181A5C000,  v20,  v44,  "%{public}s called with null (configure_webtransport != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
LABEL_108:
        if (!v19)
        {
LABEL_110:
          os_log_type_t v16 = 0LL;
          goto LABEL_13;
        }

    goto LABEL_64;
  }

  if (!a2)
  {
    __nwlog_obj();
    char v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
    uint64_t v33 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v37 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
        _os_log_impl(&dword_181A5C000, v34, v37, "%{public}s called with null application_service", buf, 0xCu);
      }
    }

    else if (v49)
    {
      os_log_type_t v43 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      v45 = os_log_type_enabled(v34, type);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v43;
          _os_log_impl( &dword_181A5C000,  v34,  v44,  "%{public}s called with null application_service, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        if (!v33) {
          goto LABEL_28;
        }
LABEL_65:
        BOOL v31 = (char *)v33;
        goto LABEL_27;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
        _os_log_impl( &dword_181A5C000,  v34,  v44,  "%{public}s called with null application_service, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
        _os_log_impl( &dword_181A5C000,  v34,  v47,  "%{public}s called with null application_service, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_63;
  }

  uint64_t v5 = v3;
  uint64_t v6 = [v5 type];

  if (v6 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (id)gLogObj;
    uint64_t v14 = v5;
    char v15 = [v14 type];

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v15;
    LODWORD(v48) = 18;
    os_log_type_t v16 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (__nwlog_fault(v16, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          os_log_type_t v19 = v14;
          BOOL v20 = objc_msgSend(v19, "type", buf, v48);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v20;
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v49)
      {
        uint64_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type;
        os_log_type_t v23 = os_log_type_enabled(v17, type);
        if (v21)
        {
          if (v23)
          {
            os_log_type_t v24 = v14;
            BOOL v25 = objc_msgSend(v24, "type", buf, v48);

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v25;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v21;
            _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v21);
          if (!v16) {
            goto LABEL_28;
          }
LABEL_26:
          BOOL v31 = (char *)v16;
LABEL_27:
          free(v31);
          goto LABEL_28;
        }

        if (v23)
        {
          os_log_type_t v29 = v14;
          uint64_t v30 = objc_msgSend(v29, "type", buf, v48);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v30;
          _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v17 = (os_log_s *)(id)gLogObj;
        char v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          unint64_t v27 = v14;
          BOOL v28 = objc_msgSend(v27, "type", buf, v48);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_application_service_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v16) {
      goto LABEL_28;
    }
    goto LABEL_26;
  }

  uint64_t v7 = v5;
  uint64_t v8 = (void *)v7[30];
  if (v8)
  {
    free(v8);
    v7[30] = 0LL;
  }

  int v9 = strdup(a2);
  if (v9) {
    goto LABEL_7;
  }
  __nwlog_obj();
  BOOL v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  uint64_t v42 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v42))
  {
    free(v42);
LABEL_7:
    v7[30] = v9;
    os_log_type_t v10 = v7;
    uint64_t v11 = (os_unfair_lock_s *)(v10 + 180);
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_endpoint_clear_description_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC93A0;
    os_log_type_t v52 = v10;
    os_log_type_t v12 = v10;
    os_unfair_lock_lock(v11);
    __nw_endpoint_clear_description_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v11);

LABEL_28:
    return;
  }

  __break(1u);
}

      free(v44);
      if (!v31) {
        goto LABEL_88;
      }
      goto LABEL_87;
    }

    __nwlog_obj();
    uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_85;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nwphRunProbe";
    BOOL v34 = "%{public}s called with null parent_activity";
LABEL_84:
    _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
    goto LABEL_85;
  }

  if (!a4)
  {
    __nwlog_obj();
    char v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nwphRunProbe";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v58 = "nwphRunProbe";
        BOOL v34 = "%{public}s called with null label";
        goto LABEL_84;
      }

    if (!v30) {
      goto LABEL_66;
    }
    uint64_t v37 = (char *)v30;
    goto LABEL_65;
  }

  __break(1u);
}

        free(v19);
        goto LABEL_19;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v35 = "nw_connection_get_listener_protocol_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v25, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v35 = "nw_connection_get_listener_protocol_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v20,  v30,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v26) {
      free(v26);
    }
    goto LABEL_9;
  }

  uint64_t v5 = v3;
  while (1)
  {
    uint64_t v6 = v5;
    if (!v6) {
      break;
    }
    uint64_t v5 = v6;
    uint64_t v7 = v6[29];

    if (v7 == 1)
    {
      v4[2](v4, v5);
      goto LABEL_8;
    }

    uint64_t v8 = (id *)v5;
    uint64_t v5 = v8[9];

    if (!v5) {
      goto LABEL_8;
    }
  }

  __nwlog_obj();
  int v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v36 = "nw_endpoint_handler_get_mode";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v33 = 0;
  if (__nwlog_fault(v10, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v36 = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
      }

  if (v18) {
    free(v18);
  }
  uint64_t v6 = 0LL;
LABEL_24:

  return v6;
}

      free(v40);
    }
  }

    uint64_t v42 = *(void *)(a2 + 32);
    os_log_type_t v43 = *(void **)(a2 + 40);
    BOOL v41 = (void *)(a2 + 32);
    if (v42)
    {
      *(void *)(v42 + 40) = v43;
      os_log_type_t v43 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(*(void *)(a1[6] + 8LL) + 48LL) = v43;
    }

    *os_log_type_t v43 = v42;
    *BOOL v41 = 0LL;
    *(void *)(a2 + 40) = 0LL;
    v132 = a1[9];
    v133 = *(uint64_t **)(v132 + 8);
    *(void *)(a2 + 40) = v133;
    *v133 = a2;
    *(void *)(v132 + 8) = v41;
    v134 = *(void *)(a1[5] + 8LL);
    v135 = *(unsigned int *)(v134 + 24) + 1LL;
    v136 = v135 << 31 >> 31;
    *(_DWORD *)(v134 + 24) = v135;
    if (v136 == v135 && (v136 & 0x8000000000000000LL) == 0) {
      goto LABEL_208;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v137 = *(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "count";
    *(_WORD *)&buf[22] = 2048;
    v232 = 1LL;
    *(_WORD *)v233 = 2048;
    *(void *)&v233[2] = v137;
    v138 = (char *)_os_log_send_and_compose_impl();
    v227[0] = 16;
    LOBYTE(v219) = 0;
    if (__nwlog_fault(v138, v227, &v219))
    {
      if (v227[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v139 = gLogObj;
        v140 = v227[0];
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v227[0]))
        {
          v141 = *(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v232 = 1LL;
          *(_WORD *)v233 = 2048;
          *(void *)&v233[2] = v141;
          v142 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_203:
          v154 = (os_log_s *)v139;
          v155 = v140;
LABEL_204:
          _os_log_impl(&dword_181A5C000, v154, v155, v142, buf, 0x2Au);
        }
      }

      else if ((_BYTE)v219)
      {
        v144 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v145 = (os_log_s *)gLogObj;
        v146 = v227[0];
        v147 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v227[0]);
        if (v144)
        {
          if (v147)
          {
            v148 = *(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v232 = 1LL;
            *(_WORD *)v233 = 2048;
            *(void *)&v233[2] = v148;
            *(_WORD *)&v233[10] = 2082;
            *(void *)&v233[12] = v144;
            _os_log_impl( &dword_181A5C000,  v145,  v146,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v144);
          goto LABEL_205;
        }

        if (v147)
        {
          v157 = *(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v232 = 1LL;
          *(_WORD *)v233 = 2048;
          *(void *)&v233[2] = v157;
          v142 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          v154 = v145;
          v155 = v146;
          goto LABEL_204;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v139 = gLogObj;
        v140 = v227[0];
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v227[0]))
        {
          v153 = *(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v232 = 1LL;
          *(_WORD *)v233 = 2048;
          *(void *)&v233[2] = v153;
          v142 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_203;
        }
      }
    }

      if (v18) {
        free(v18);
      }
      uint64_t v5 = &qword_18C45F000;
      goto LABEL_82;
    }

    uint64_t v22 = *((void *)handle + 14);
    os_log_type_t v23 = (void *)*((void *)handle + 15);
    if (v22)
    {
      *(void *)(v22 + 120) = v23;
      os_log_type_t v23 = (void *)*((void *)handle + 15);
      os_log_type_t v24 = v173;
    }

    else
    {
      os_log_type_t v24 = v173;
      *(void *)(v173 + 336) = v23;
    }

    *os_log_type_t v23 = v22;
    *((void *)handle + 14) = 0LL;
    *((void *)handle + 15) = 0LL;
    os_log_type_t v29 = *(_DWORD *)(v24 + 456);
    *(_DWORD *)(v24 + 456) = v29 - 1;
    if (v29)
    {
LABEL_80:
      v50 = handle[276];
      handle[276] = v50 & 0xDF;
      if ((v50 & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v160 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
          {
            v161 = *((void *)handle + 11);
            if (v161) {
              v162 = *(_DWORD *)(v161 + 460);
            }
            else {
              v162 = -1;
            }
            v167 = *((void *)handle + 8);
            v168 = *(_DWORD *)(v173 + 456);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            v188 = 2082;
            v189 = handle + 192;
            v190 = 2080;
            v191 = (uint64_t)" ";
            v192 = 1024;
            *(_DWORD *)v193 = v162;
            *(_WORD *)&v193[4] = 2048;
            *(void *)&v193[6] = v167;
            *(_WORD *)&v193[14] = 2048;
            *(void *)&v193[16] = handle;
            v194 = 1024;
            LODWORD(v195) = v168;
            BOOL v17 = "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams";
            uint64_t v37 = v160;
            v38 = OS_LOG_TYPE_DEBUG;
            v39 = 64;
            goto LABEL_58;
          }
        }
      }

      goto LABEL_82;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v30 = *(unsigned int *)(v173 + 456);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
    v188 = 2082;
    v189 = "webtransport_session->pending_stream_count";
    v190 = 2048;
    v191 = 1LL;
    v192 = 2048;
    *(void *)v193 = v30;
    BOOL v31 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (__nwlog_fault(v31, type, v174))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v32 = (os_log_s *)__nwlog_obj();
        uint64_t v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          BOOL v34 = *(unsigned int *)(v173 + 456);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          v188 = 2082;
          v189 = "webtransport_session->pending_stream_count";
          v190 = 2048;
          v191 = 1LL;
          v192 = 2048;
          *(void *)v193 = v34;
          __int16 v35 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_75:
          v48 = v32;
          v49 = v33;
LABEL_76:
          _os_log_impl(&dword_181A5C000, v48, v49, v35, buf, 0x2Au);
        }
      }

      else if (LOBYTE(v174[0]))
      {
        uint64_t v42 = (char *)__nw_create_backtrace_string();
        os_log_type_t v43 = (os_log_s *)__nwlog_obj();
        BOOL v44 = type[0];
        v45 = os_log_type_enabled(v43, type[0]);
        if (v42)
        {
          if (v45)
          {
            v46 = *(unsigned int *)(v173 + 456);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            v188 = 2082;
            v189 = "webtransport_session->pending_stream_count";
            v190 = 2048;
            v191 = 1LL;
            v192 = 2048;
            *(void *)v193 = v46;
            *(_WORD *)&v193[8] = 2082;
            *(void *)&v193[10] = v42;
            _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v42);
          goto LABEL_77;
        }

        if (v45)
        {
          v137 = *(unsigned int *)(v173 + 456);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          v188 = 2082;
          v189 = "webtransport_session->pending_stream_count";
          v190 = 2048;
          v191 = 1LL;
          v192 = 2048;
          *(void *)v193 = v137;
          __int16 v35 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          v48 = v43;
          v49 = v44;
          goto LABEL_76;
        }
      }

      else
      {
        uint64_t v32 = (os_log_s *)__nwlog_obj();
        uint64_t v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          v47 = *(unsigned int *)(v173 + 456);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          v188 = 2082;
          v189 = "webtransport_session->pending_stream_count";
          v190 = 2048;
          v191 = 1LL;
          v192 = 2048;
          *(void *)v193 = v47;
          __int16 v35 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_75;
        }
      }
    }

    free(v35);
    if (!v9) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }

  *(_BYTE *)(v5 + 191) = self->_useAWDL;
  *(_WORD *)(v5 + 196) |= 0x2000u;
  has = (__int16)self->_has;
  if ((has & 0x4000) == 0)
  {
LABEL_12:
    if ((has & 0x1000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_65;
  }

    goto LABEL_64;
  }

  if (!v9)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)key = 136446210;
    *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
    os_log_type_t v19 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
        _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null transport_protocol", key, 0xCu);
      }

      goto LABEL_63;
    }

    if (!v37)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v35 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
        _os_log_impl( &dword_181A5C000,  v20,  v35,  "%{public}s called with null transport_protocol, backtrace limit exceeded",  key,  0xCu);
      }

      goto LABEL_63;
    }

    os_log_type_t v29 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v30 = type;
    BOOL v31 = os_log_type_enabled(v20, type);
    if (!v29)
    {
      if (v31)
      {
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
        _os_log_impl( &dword_181A5C000,  v20,  v30,  "%{public}s called with null transport_protocol, no backtrace",  key,  0xCu);
      }

      goto LABEL_63;
    }

    if (v31)
    {
      *(_DWORD *)key = 136446466;
      *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
      __int16 v40 = 2082;
      BOOL v41 = v29;
      _os_log_impl( &dword_181A5C000,  v20,  v30,  "%{public}s called with null transport_protocol, dumping backtrace:%{public}s",  key,  0x16u);
    }

    goto LABEL_44;
  }

  if (!v7[1])
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)key = 136446210;
    *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
    os_log_type_t v19 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
        _os_log_impl(&dword_181A5C000, v20, v25, "%{public}s called with null config->stacks", key, 0xCu);
      }

      goto LABEL_63;
    }

    if (!v37)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v36 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
        _os_log_impl( &dword_181A5C000,  v20,  v36,  "%{public}s called with null config->stacks, backtrace limit exceeded",  key,  0xCu);
      }

      goto LABEL_63;
    }

    os_log_type_t v29 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v32 = type;
    uint64_t v33 = os_log_type_enabled(v20, type);
    if (!v29)
    {
      if (v33)
      {
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
        _os_log_impl(&dword_181A5C000, v20, v32, "%{public}s called with null config->stacks, no backtrace", key, 0xCu);
      }

      goto LABEL_63;
    }

    if (v33)
    {
      *(_DWORD *)key = 136446466;
      *(void *)&key[4] = "nw_proxy_config_set_listener_protocol_stack";
      __int16 v40 = 2082;
      BOOL v41 = v29;
      _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s called with null config->stacks, dumping backtrace:%{public}s",  key,  0x16u);
    }

  if (v16) {
    free(v16);
  }
  os_log_type_t v12 = 0LL;
LABEL_13:

  return (nw_relay_hop_t)v12;
}

    if (v26) {
      free(v26);
    }
    *(_DWORD *)(v8 + 348) = 0;
    char v15 = object;
    goto LABEL_66;
  }

        goto LABEL_64;
      }

      BOOL v25 = fcntl(v5, 3, 0LL);
      if (v25 != -1)
      {
        char v26 = v25;
        if (fcntl(v5, 4, v25 | 4u) != -1) {
          goto LABEL_89;
        }
        unint64_t v27 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v28 = (id)gLogObj;
        *(_DWORD *)v70 = 136447234;
        v71 = "createKernelSocket";
        v72 = 1024;
        *(_DWORD *)v73 = v5;
        *(_WORD *)&v73[4] = 1024;
        *(_DWORD *)&v73[6] = v26;
        *(_WORD *)&v73[10] = 2082;
        *(void *)&v73[12] = &buf[4];
        v74 = 1024;
        LODWORD(v75[0]) = v27;
        os_log_type_t v29 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v65 = 0;
        if (__nwlog_fault((const char *)v29, &type, &v65))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_118;
            }
            *(_DWORD *)v70 = 136447234;
            v71 = "createKernelSocket";
            v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            v74 = 1024;
            LODWORD(v75[0]) = v27;
            uint64_t v32 = "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errno}d";
            goto LABEL_117;
          }

          if (!v65)
          {
            __nwlog_obj();
            uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_118;
            }
            *(_DWORD *)v70 = 136447234;
            v71 = "createKernelSocket";
            v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            v74 = 1024;
            LODWORD(v75[0]) = v27;
            uint64_t v32 = "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errn"
                  "o}d, backtrace limit exceeded";
            goto LABEL_117;
          }

          char v64 = v27;
          v50 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v31 = type;
          v51 = os_log_type_enabled(v30, type);
          if (!v50)
          {
            if (!v51) {
              goto LABEL_118;
            }
            *(_DWORD *)v70 = 136447234;
            v71 = "createKernelSocket";
            v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            v74 = 1024;
            LODWORD(v75[0]) = v64;
            uint64_t v32 = "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errn"
                  "o}d, no backtrace";
LABEL_117:
            _os_log_impl(&dword_181A5C000, v30, v31, v32, (uint8_t *)v70, 0x28u);
LABEL_118:

            if (!v29) {
              goto LABEL_89;
            }
LABEL_88:
            free(v29);
            goto LABEL_89;
          }

          if (v51)
          {
            *(_DWORD *)v70 = 136447490;
            v71 = "createKernelSocket";
            v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            v74 = 1024;
            LODWORD(v75[0]) = v64;
            WORD2(v75[0]) = 2082;
            *(void *)((char *)v75 + 6) = v50;
            _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)v70,  0x32u);
          }

          free(v50);
          if (v29) {
            goto LABEL_88;
          }
LABEL_89:
          os_log_type_t v52 = xpc_fd_create(v5);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v53 = (os_log_s *)(id)gLogObj;
          uint64_t v54 = v53;
          if (v52)
          {
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              v55 = [v3 pid];
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v55;
              _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully created kernel socket %d with name %{public}s for pid %d",  buf,  0x22u);
            }

            [v3 reply];
            v56 = (void *)objc_claimAutoreleasedReturnValue();
            xpc_dictionary_set_value(v56, (const char *)networkd_privileged_key_kernel_socket_fd, v52);

            os_log_type_t v24 = 0LL;
LABEL_113:
            close(v5);

            goto LABEL_114;
          }

          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v5;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = a2;
          uint64_t v57 = (void *)_os_log_send_and_compose_impl();

          v70[0] = OS_LOG_TYPE_ERROR;
          v66[0] = 0;
          if (!__nwlog_fault((const char *)v57, v70, v66))
          {
LABEL_110:
            if (v57) {
              free(v57);
            }
            os_log_type_t v24 = -1005LL;
            goto LABEL_113;
          }

          if (v70[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v58 = (os_log_s *)(id)gLogObj;
            v59 = v70[0];
            if (os_log_type_enabled(v58, v70[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              v60 = "%{public}s xpc_fd_create(%d) name %{public}s failed";
LABEL_108:
              _os_log_impl(&dword_181A5C000, v58, v59, v60, buf, 0x1Cu);
            }
          }

          else
          {
            if (v66[0])
            {
              char v61 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v59 = v70[0];
              os_log_type_t v62 = os_log_type_enabled(v58, v70[0]);
              if (v61)
              {
                if (v62)
                {
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v5;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = a2;
                  *(_WORD *)&buf[28] = 2082;
                  *(void *)&buf[30] = v61;
                  _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s xpc_fd_create(%d) name %{public}s failed, dumping backtrace:%{public}s",  buf,  0x26u);
                }

                free(v61);
                goto LABEL_110;
              }

              if (!v62) {
                goto LABEL_109;
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              v60 = "%{public}s xpc_fd_create(%d) name %{public}s failed, no backtrace";
              goto LABEL_108;
            }

            __nwlog_obj();
            uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v59 = v70[0];
            if (os_log_type_enabled(v58, v70[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              v60 = "%{public}s xpc_fd_create(%d) name %{public}s failed, backtrace limit exceeded";
              goto LABEL_108;
            }
          }

          if (!v42)
          {
LABEL_75:

            if ((*((_BYTE *)v7 + 616) & 1) != 0)
            {
              if (nw_service_connector_get_new_sequence_number(void)::onceToken != -1) {
                dispatch_once( &nw_service_connector_get_new_sequence_number(void)::onceToken,  &__block_literal_global_181);
              }
              do
                v60 = __ldaxr((unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber);
              while (__stlxr( v60 + 1,  (unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber));
              if (!v60)
              {
                do
                {
                  v60 = __ldaxr((unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber);
                  if (__stlxr( v60 + 1,  (unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber))
                  {
                    char v61 = 1;
                  }

                  else
                  {
                    char v61 = v60 == 0;
                  }
                }

                while (v61);
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v62 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
                *(_WORD *)&buf[12] = 2114;
                *(void *)&buf[14] = v94;
                *(_WORD *)&buf[22] = 2114;
                *(void *)&_BYTE buf[24] = v7;
                *(_WORD *)&buf[32] = 2114;
                *(void *)&buf[34] = v93;
                *(_WORD *)&buf[42] = 2048;
                *(void *)&buf[44] = v60;
                _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ accepting incoming request %{public}@ activeConnection %{public}@ reply seq %llu",  buf,  0x34u);
              }

              nwsc_send_feedback(v94, v23, v60, 1, 0, v96);
              goto LABEL_19;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v59 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
              *(_WORD *)&buf[12] = 2114;
              *(void *)&buf[14] = v94;
              *(_WORD *)&buf[22] = 2114;
              *(void *)&_BYTE buf[24] = v23;
              *(_WORD *)&buf[32] = 2114;
              *(void *)&buf[34] = v93;
              _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ outgoing connection %{public}@ was accepted activeConnection %{public}@",  buf,  0x2Au);
            }

            nw_service_connector_remove_active_outgoing_request(v94, v7);
            uint64_t v37 = 0LL;
            goto LABEL_79;
          }

        goto LABEL_64;
      }

      if (!(_BYTE)v50)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (os_log_s *)(id)gLogObj;
        uint64_t v32 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v10;
          _os_log_impl( &dword_181A5C000,  v13,  v32,  "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }

        goto LABEL_63;
      }

      backtrace_string = __nw_create_backtrace_string();
      if (!backtrace_string)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v36 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v10;
          _os_log_impl( &dword_181A5C000,  v13,  v36,  "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, no backtrace",  buf,  0x12u);
        }

        goto LABEL_63;
      }

      os_log_type_t v19 = (char *)backtrace_string;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v20 = (os_log_s *)(id)gLogObj;
      uint64_t v21 = type[0];
      if (os_log_type_enabled(v20, type[0]))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v10;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v19;
        _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v19);
      if (!v12) {
        goto LABEL_66;
      }
    }

    else
    {
      v50 = 1;
      if (ioctl(v8, 0x8004667EuLL, &v50))
      {
        char v15 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v49 = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v13 = (os_log_s *)(id)gLogObj;
          BOOL v17 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v15;
            _os_log_impl(&dword_181A5C000, v13, v17, "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d", buf, 0x12u);
          }

          goto LABEL_63;
        }

        if (!v49)
        {
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v39 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v15;
            _os_log_impl( &dword_181A5C000,  v13,  v39,  "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }

          goto LABEL_63;
        }

        uint64_t v33 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v34 = type[0];
        __int16 v35 = os_log_type_enabled(v13, type[0]);
        if (!v33)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v15;
            _os_log_impl( &dword_181A5C000,  v13,  v34,  "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }

          goto LABEL_63;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v15;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v33;
          _os_log_impl( &dword_181A5C000,  v13,  v34,  "%{public}s ioctl(FIONBIO) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v33);
        if (!v12) {
          goto LABEL_66;
        }
      }

      else
      {
        uint64_t v22 = dispatch_source_create(MEMORY[0x1895F8B60], v8, 0LL, v5);
        if (v22)
        {
          os_log_type_t v23 = v22;
          os_log_type_t v24 = v1[5];
          if (((_BYTE)v4[6] & 1) != 0 && v24)
          {
            v1[5] = 0LL;

            os_log_type_t v24 = v1[5];
          }

          v1[5] = 0LL;

          BOOL v25 = v1[5];
          v1[5] = v23;

          *((_BYTE *)v4 + 48) |= 1u;
          char v26 = v4[7];
          if (((_BYTE)v4[8] & 1) != 0 && v26)
          {
            v4[7] = 0LL;

            char v26 = v4[7];
          }

          v4[7] = 0LL;

          unint64_t v27 = v4[7];
          v4[7] = v9;

          *((_BYTE *)v4 + 64) |= 1u;
          BOOL v28 = MEMORY[0x1895F87A8];
          os_log_type_t v29 = (dispatch_source_s *)v1[5];
          *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
          v45 = 3221225472LL;
          v46 = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke;
          v47 = &unk_189BC93A0;
          uint64_t v30 = v4;
          v48 = v30;
          dispatch_source_set_cancel_handler(v29, type);
          BOOL v31 = (dispatch_source_s *)v1[5];
          *(void *)buf = v28;
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_3;
          *(void *)&_BYTE buf[24] = &unk_189BC9440;
          v56 = v8;
          uint64_t v54 = v30;
          v55 = v6;
          dispatch_source_set_event_handler(v31, buf);
          dispatch_activate(v1[5]);

          int v9 = 0LL;
          goto LABEL_66;
        }

        __nwlog_obj();
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
        os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v49 = 0;
        if (!__nwlog_fault(v12, type, &v49))
        {
LABEL_64:
          if (!v12) {
            goto LABEL_66;
          }
          goto LABEL_65;
        }

        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v38 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
            _os_log_impl(&dword_181A5C000, v13, v38, "%{public}s dispatch_source_create failed", buf, 0xCu);
          }

          goto LABEL_63;
        }

        if (!v49)
        {
          __nwlog_obj();
          uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v43 = type[0];
          if (os_log_type_enabled(v13, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
            _os_log_impl( &dword_181A5C000,  v13,  v43,  "%{public}s dispatch_source_create failed, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_63;
        }

        __int16 v40 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v41 = type[0];
        uint64_t v42 = os_log_type_enabled(v13, type[0]);
        if (!v40)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
            _os_log_impl( &dword_181A5C000,  v13,  v41,  "%{public}s dispatch_source_create failed, no backtrace",  buf,  0xCu);
          }

          goto LABEL_63;
        }

        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v40;
          _os_log_impl( &dword_181A5C000,  v13,  v41,  "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v40);
        if (!v12) {
          goto LABEL_66;
        }
      }
    }

              _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0x18u);
              goto LABEL_64;
            }

            *(void *)(v4[1] + 8LL * v65++) = v69;
          }
        }

    if (v22) {
      free(v22);
    }
    os_log_type_t v19 = 0;
    goto LABEL_35;
  }

  id v3 = *(void *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_multipath_get_subflow_count_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v5;
      _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_INFO, "%{public}s [C%u]  has no connected handler", buf, 0x12u);
    }
  }

    if (v11) {
      free(v11);
    }
    goto LABEL_9;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v30 = "nw_protocol_http3_listen_protocol_disconnected";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v27 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_74;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_http3_listen_protocol_disconnected";
    os_log_type_t v10 = "%{public}s called with null http3";
    goto LABEL_73;
  }

  if (!v27)
  {
    uint64_t v8 = (os_log_s *)__nwlog_obj();
    int v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_74;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_http3_listen_protocol_disconnected";
    os_log_type_t v10 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_73;
  }

  os_log_type_t v24 = (char *)__nw_create_backtrace_string();
  uint64_t v8 = (os_log_s *)__nwlog_obj();
  int v9 = type;
  BOOL v25 = os_log_type_enabled(v8, type);
  if (!v24)
  {
    if (!v25) {
      goto LABEL_74;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_http3_listen_protocol_disconnected";
    os_log_type_t v10 = "%{public}s called with null http3, no backtrace";
    goto LABEL_73;
  }

  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v30 = "nw_protocol_http3_listen_protocol_disconnected";
    BOOL v31 = 2082;
    uint64_t v32 = (nw_protocol_identifier *)v24;
    _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null http3, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v24);
  if (v7) {
    goto LABEL_75;
  }
}

    v305 = v75;
    if (*(void *)(v302 + 136) || *(_DWORD *)(v302 + 40) < *(_DWORD *)(v302 + 36))
    {
      v77 = 1;
LABEL_66:
      v308 = v77;
      goto LABEL_67;
    }

    v78 = *(void *)(v302 + 128);
    if (v78)
    {
      v77 = *(_DWORD *)(v78 + 60) > *(_DWORD *)(v302 + 4);
      goto LABEL_66;
    }

    v308 = 0;
LABEL_67:
    v306 = 0LL;
    v287 = *(void *)(v302 + 216) != 0LL;
    if (!v75) {
      goto LABEL_125;
    }
LABEL_73:
    os_log_type_t v24 = *(uint64_t **)(*(void *)(v68 + 72) + 32LL * (v61 & ~(-1 << *(_DWORD *)(v68 + 52))) + 16);
    if (!v24)
    {
      v306 = 0LL;
      os_log_type_t v24 = 0LL;
      goto LABEL_125;
    }

    v306 = 0LL;
    while (1)
    {
      if (v61 != *((_DWORD *)v24 + 10) || *((_DWORD *)v24 + 12) != (_DWORD)v63 || *((_DWORD *)v24 + 13) != (_DWORD)v64) {
        goto LABEL_76;
      }
      v71 = (unint64_t)v310;
      v76 = v312;
LABEL_76:
      os_log_type_t v24 = (uint64_t *)*v24;
      if (!v24)
      {
        if (v306 != 1) {
          goto LABEL_125;
        }
        os_log_type_t v24 = *(uint64_t **)buf;
        v84 = *(_DWORD *)(*(void *)buf + 24LL);
        LODWORD(v295) = v84;
        if (v308)
        {
          if (!(_DWORD)v26)
          {
LABEL_104:
            v83 = 2LL;
            v81 = 2;
            v306 = 1LL;
            if ((*((_DWORD *)v24 + 8)
                              + *((_DWORD *)v24 + 7)
                              + *(_DWORD *)(v68 + 20)
                              - (*(_DWORD *)(v68 + 32)
                               + *(_DWORD *)(v68 + 16))) >= *(_DWORD *)(v68 + 20) >> 2)
            {
              v79 = 0LL;
              v82 = v295;
              v305 = 1;
              v80 = 0LL;
              goto LABEL_195;
            }

            goto LABEL_125;
          }
        }

        else
        {
          v85 = *(_DWORD *)(v68 + 4);
          if (v84 > v85 || (_DWORD)v26 == 0) {
            goto LABEL_102;
          }
        }

        if ((*(_BYTE *)(v68 + 12) & 2) != 0)
        {
          v87 = (*(_DWORD *)(*(void *)buf + 48LL) + *(_DWORD *)(*(void *)buf + 52LL) + 32);
          v88 = (float)*(unsigned int *)(v68 + 20);
          if ((float)((float)(v87 + *(_DWORD *)(v68 + 16)) / v88) >= 0.8
            && (float)((float)(*(_DWORD *)(*(void *)buf + 28LL)
                                           - *(_DWORD *)(v68 + 32)
                                           + *(_DWORD *)(*(void *)buf + 32LL))
                     / v88) < 0.2)
          {
            can_evict_at_least = qenc_has_or_can_evict_at_least(v68, v87);
            v71 = (unint64_t)v310;
            v76 = v312;
            if (can_evict_at_least)
            {
              v81 = 6;
              if (v308)
              {
                v83 = 0LL;
                v82 = v295;
                v305 = 1;
                v306 = 1LL;
                v308 = 1;
                goto LABEL_99;
              }

              v92 = *(_DWORD *)(v68 + 16);
              v91 = *(_DWORD *)(v68 + 20);
              if (*((_DWORD *)v24 + 8) + *((_DWORD *)v24 + 7) + v91 - (*(_DWORD *)(v68 + 32) + v92) >= v91 >> 2)
              {
                v308 = 0;
                v93 = v92 + *((_DWORD *)v24 + 12) + *((_DWORD *)v24 + 13) + 32;
                v83 = 2LL;
                v81 = 2;
                v306 = 1LL;
                v305 = 1;
                if (v93 > v91)
                {
                  v94 = *(void *)(v68 + 56);
                  v83 = 2LL;
                  v81 = 2;
                  if ((uint64_t *)v94 == v24)
                  {
                    v79 = 0LL;
                    v306 = 1LL;
                    v305 = 1;
                    v308 = 0;
                    v82 = v295;
                    v80 = 0LL;
                  }

                  else
                  {
                    while (1)
                    {
                      v93 = v93 - (*(_DWORD *)(v94 + 48) + *(_DWORD *)(v94 + 52)) - 32;
                      if (v93 <= v91) {
                        break;
                      }
                      v94 = *(void *)(v94 + 16);
                      v83 = 2LL;
                      if ((uint64_t *)v94 == v24)
                      {
                        v306 = 1LL;
                        v308 = 0;
                        v79 = 0LL;
                        v80 = 0LL;
                        v82 = v295;
                        v305 = 1;
                        v81 = 2;
                        goto LABEL_195;
                      }
                    }

                    v308 = 0;
                    v83 = 2LL;
                    v306 = 1LL;
                    v82 = v295;
                    v305 = 1;
                    v79 = 1LL;
                    v80 = 1LL;
                    v81 = 2;
                  }

                  goto LABEL_195;
                }

                v82 = v295;
LABEL_99:
                v79 = 1LL;
                v80 = 1LL;
                goto LABEL_195;
              }

      free(v32);
      if (!v24) {
        return;
      }
LABEL_93:
      free(v24);
      return;
    }

    BOOL v25 = (os_log_s *)__nwlog_obj();
    char v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_92;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_protocol_http3_error";
    unint64_t v27 = "%{public}s called with null http3";
LABEL_91:
    _os_log_impl(&dword_181A5C000, v25, v26, v27, block, 0xCu);
    goto LABEL_92;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_protocol_http3_error";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      char v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      unint64_t v27 = "%{public}s called with null other_protocol";
      goto LABEL_91;
    }

    if (!v51)
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      char v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      unint64_t v27 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_91;
    }

    uint64_t v32 = (char *)__nw_create_backtrace_string();
    BOOL v25 = (os_log_s *)__nwlog_obj();
    char v26 = type;
    __int16 v35 = os_log_type_enabled(v25, type);
    if (!v32)
    {
      if (!v35) {
        goto LABEL_92;
      }
      *(_DWORD *)block = 136446210;
      *(void *)&block[4] = "nw_protocol_http3_error";
      unint64_t v27 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_91;
    }

    if (v35)
    {
      *(_DWORD *)block = 136446466;
      *(void *)&block[4] = "nw_protocol_http3_error";
      *(_WORD *)&block[12] = 2082;
      *(void *)&block[14] = v32;
      BOOL v34 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_62;
    }

    goto LABEL_63;
  }

  uint64_t v7 = handle + 1373;
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
  {
    if (gLogDatapath)
    {
      BOOL v28 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v29 = *((_DWORD *)handle + 320);
        *(_DWORD *)block = 136446978;
        *(void *)&block[4] = "nw_protocol_http3_error";
        *(_WORD *)&block[12] = 2082;
        *(void *)&block[14] = handle + 1289;
        *(_WORD *)&block[22] = 2080;
        uint64_t v54 = " ";
        LOWORD(v55) = 1024;
        *(_DWORD *)((char *)&v55 + 2) = v29;
        _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", block, 0x26u);
      }
    }
  }

  if (a3 == 35)
  {
    uint64_t v8 = (unsigned __int16)*v7;
    if ((v8 & 0x100) != 0)
    {
      if (a1->output_handler != a2) {
        return;
      }
      if (((v8 | (handle[1375] << 16)) & 0x400000) == 0)
      {
        if (gLogDatapath)
        {
          char v36 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v37 = *((_DWORD *)handle + 320);
            *(_DWORD *)block = 136446978;
            *(void *)&block[4] = "nw_protocol_http3_error";
            *(_WORD *)&block[12] = 2082;
            *(void *)&block[14] = handle + 1289;
            *(_WORD *)&block[22] = 2080;
            uint64_t v54 = " ";
            LOWORD(v55) = 1024;
            *(_DWORD *)((char *)&v55 + 2) = v37;
            _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> early data rejected",  block,  0x26u);
          }
        }
      }

      if (!uuid_is_null((const unsigned __int8 *)handle + 848))
      {
        uint64_t v14 = (void *)*((void *)handle + 139);
        if (v14) {
          nw_path_report_error_to_agent(v14, (const unsigned __int8 *)handle + 848, 35);
        }
        goto LABEL_33;
      }

      if (nw_storage_copy_shared_token != -1) {
        dispatch_once(&nw_storage_copy_shared_token, &__block_literal_global_44978);
      }
      int v9 = (id)nw_storage_copy_shared_storage;
      os_log_type_t v10 = (void *)*((void *)handle + 137);
      if (v10) {
        uint64_t v11 = os_retain(v10);
      }
      else {
        uint64_t v11 = 0LL;
      }
      while (1)
      {
        char v15 = v11;
        os_log_type_t v16 = nw_endpoint_copy_parent_endpoint(v11);
        if (!v16) {
          break;
        }
        uint64_t v11 = v16;
        if (v15) {
          os_release(v15);
        }
      }

      BOOL v17 = (void *)*((void *)handle + 157);
      os_log_type_t v18 = v9;
      os_log_type_t v19 = v15;
      BOOL v20 = v17;
      uint64_t v21 = &__block_literal_global_120_62183;
      if (v18)
      {
        if (v19)
        {
          if (v20)
          {
            uint64_t v22 = (dispatch_queue_s *)v18[2];
            *(void *)block = MEMORY[0x1895F87A8];
            *(void *)&block[8] = 3221225472LL;
            *(void *)&block[16] = __nw_storage_remove_items_block_invoke;
            uint64_t v54 = (const char *)&unk_189BC6FC8;
            v55 = v18;
            char v61 = "h3_0rtt";
            v56 = v19;
            uint64_t v57 = 0LL;
            uint64_t v58 = 0LL;
            v59 = v20;
            os_log_type_t v23 = &__block_literal_global_120_62183;
            v60 = &__block_literal_global_120_62183;
            dispatch_async(v22, block);

LABEL_29:
            if (v19) {
              os_release(v19);
            }
            if (v18) {
              os_release(v18);
            }
LABEL_33:
            *v7 |= 0x200u;
            return;
          }

          __nwlog_obj();
          BOOL v44 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)block = 136446210;
          *(void *)&block[4] = "nw_storage_remove_items";
          v39 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v51 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)block = 136446210;
              *(void *)&block[4] = "nw_storage_remove_items";
              uint64_t v42 = "%{public}s called with null context";
              goto LABEL_122;
            }

            if (a4 < 0x40) {
              goto LABEL_64;
            }
            goto LABEL_28;
          }
        }
      }

      v78 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
        return 0LL;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_framer_get_output_frames_for_multiple_http3_frames";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v26;
      v59 = "%{public}s Output handler (%p)'s get_output_frames callback is not properly set";
      v60 = v78;
      char v61 = OS_LOG_TYPE_ERROR;
      os_log_type_t v62 = 22;
      goto LABEL_109;
    case 5:
      BOOL v31 = handle + 736;
      if ((_DWORD)a5 && !a4 && (*((_WORD *)handle + 368) & 0x4000) != 0)
      {
        uint64_t v32 = nw_frame_create(0, 0LL, 0, (uint64_t)nw_protocol_http3_capsule_frame_finalizer, 0LL);
        *(void *)(v32 + 32) = 0LL;
        uint64_t v33 = a6->tqh_last;
        *(void *)(v32 + 40) = v33;
        char *v33 = (nw_frame *)v32;
        a6->tqh_last = (nw_frame **)(v32 + 32);
        uint64_t v11 = 1LL;
        if ((*v31 & 0x800) == 0)
        {
          if (gLogDatapath)
          {
            BOOL v34 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              __int16 v35 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
              char v36 = *((void *)handle + 30);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 636;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&_BYTE buf[24] = " ";
              LOWORD(v91) = 1024;
              *(_DWORD *)((char *)&v91 + 2) = v35;
              WORD3(v91) = 2048;
              *((void *)&v91 + 1) = v36;
              uint64_t v37 = "%{public}s %{public}s%s<i%u:s%llu> returning a metadata-only output frame";
              v38 = v34;
              v39 = 48;
LABEL_43:
              _os_log_impl(&dword_181A5C000, v38, OS_LOG_TYPE_DEBUG, v37, buf, v39);
              return v11;
            }
          }
        }
      }

      else
      {
        __int16 v40 = *((void *)handle + 12);
        if (v40)
        {
          uint64_t v11 = (*(uint64_t (**)(void))(*(void *)(v40 + 24) + 88LL))();
          if ((*v31 & 0x800) == 0)
          {
            if (gLogDatapath)
            {
              BOOL v41 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v42 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
                os_log_type_t v43 = *((void *)handle + 30);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = handle + 636;
                *(_WORD *)&buf[22] = 2080;
                *(void *)&_BYTE buf[24] = " ";
                LOWORD(v91) = 1024;
                *(_DWORD *)((char *)&v91 + 2) = v42;
                WORD3(v91) = 2048;
                *((void *)&v91 + 1) = v43;
                v92 = 1024;
                v93 = v11;
                uint64_t v37 = "%{public}s %{public}s%s<i%u:s%llu> returning %u output datagrams";
                v38 = v41;
                v39 = 54;
                goto LABEL_43;
              }
            }
          }
        }

        else
        {
          uint64_t v11 = 0LL;
          if ((*((_WORD *)handle + 368) & 0x800) == 0 && gLogDatapath)
          {
            v56 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG)) {
              return 0LL;
            }
            uint64_t v57 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
            uint64_t v58 = *((void *)handle + 30);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 636;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&_BYTE buf[24] = " ";
            LOWORD(v91) = 1024;
            *(_DWORD *)((char *)&v91 + 2) = v57;
            WORD3(v91) = 2048;
            *((void *)&v91 + 1) = v58;
            v59 = "%{public}s %{public}s%s<i%u:s%llu> no datagram output handler";
            v60 = v56;
            char v61 = OS_LOG_TYPE_DEBUG;
            os_log_type_t v62 = 48;
LABEL_109:
            _os_log_impl(&dword_181A5C000, v60, v61, v59, buf, v62);
            uint64_t v11 = 0LL;
          }
        }
      }

      break;
    default:
      return v11;
  }

  return v11;
}

          BOOL v31 = *(_DWORD *)&a1[4].flow_id[12];
          if (v31 < 0) {
            goto LABEL_174;
          }
LABEL_64:
          *(_DWORD *)out = 1;
          if (!setsockopt(v31, 0xFFFF, 4130, out, 4u)) {
            goto LABEL_107;
          }
          uint64_t v32 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v33 = (os_log_s *)gLogObj;
          if (v32 == 22)
          {
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 22;
              _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d",  buf,  0x12u);
            }

            goto LABEL_107;
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v32;
          v131 = 18;
          BOOL v44 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v133 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v44, type, &v133))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v45 = (os_log_s *)gLogObj;
              v46 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v32;
              v47 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d";
              goto LABEL_104;
            }

            if (v133 == OS_LOG_TYPE_DEFAULT)
            {
              v45 = (os_log_s *)__nwlog_obj();
              v46 = type[0];
              if (!os_log_type_enabled(v45, type[0])) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v32;
              v47 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_104;
            }

            v48 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v45 = (os_log_s *)gLogObj;
            v46 = type[0];
            v49 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
            if (v48)
            {
              if (v49)
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v32;
                *(_WORD *)&buf[18] = 2082;
                *(void *)&buf[20] = v48;
                _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
              }

              free(v48);
              goto LABEL_105;
            }

            if (v49)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v32;
              v47 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, no backtrace";
LABEL_104:
              _os_log_impl(&dword_181A5C000, v45, v46, v47, buf, 0x12u);
            }
          }

  if (v20) {
    free(v20);
  }
LABEL_65:
  if (!nw_tcp_options_get_no_timewait(a2) || !setsockopt(*(_DWORD *)(a1 + 172), 6, 520, v105, 4u)) {
    goto LABEL_90;
  }
  char v26 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  unint64_t v27 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v107 = "nw_socket_set_bidirectional_tcp_sockopts";
    v108 = 2080;
    *(void *)v109 = a1 + 308;
    *(_WORD *)&v109[8] = 1024;
    *(_DWORD *)&v109[10] = v26;
    _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v28 = (os_log_s *)gLogObj;
  if (v26 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)v109 = 22;
      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d",  buf,  0x12u);
    }

    goto LABEL_90;
  }

  *(_DWORD *)buf = 136446466;
  v107 = "nw_socket_set_bidirectional_tcp_sockopts";
  v108 = 1024;
  *(_DWORD *)v109 = v26;
  os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v103[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v29, type, v103))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v30 = (os_log_s *)gLogObj;
      BOOL v31 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)v109 = v26;
      uint64_t v32 = "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d";
      goto LABEL_87;
    }

    if (v103[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      BOOL v31 = type[0];
      if (!os_log_type_enabled(v30, type[0])) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)v109 = v26;
      uint64_t v32 = "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_87;
    }

    uint64_t v33 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v30 = (os_log_s *)gLogObj;
    BOOL v31 = type[0];
    BOOL v34 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v33)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446722;
        v107 = "nw_socket_set_bidirectional_tcp_sockopts";
        v108 = 1024;
        *(_DWORD *)v109 = v26;
        *(_WORD *)&v109[4] = 2082;
        *(void *)&v109[6] = v33;
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v33);
      goto LABEL_88;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)v109 = v26;
      uint64_t v32 = "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, no backtrace";
LABEL_87:
      _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0x12u);
    }
  }

          free(v33);
          goto LABEL_64;
        }

    if (v21) {
      free(v21);
    }
    uint64_t v6 = 0LL;
    goto LABEL_52;
  }

  if (a3 <= 0x1F)
  {
    __nwlog_obj();
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_oblivious_http_deserialize_options";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v21, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_oblivious_http_deserialize_options";
          os_log_type_t v24 = "%{public}s called with null (serialized_length >= sizeof(struct nw_serialized_oblivious_http_options))";
          goto LABEL_61;
        }

        goto LABEL_62;
      }

      if (!v50)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_oblivious_http_deserialize_options";
          os_log_type_t v24 = "%{public}s called with null (serialized_length >= sizeof(struct nw_serialized_oblivious_http_options)), "
                "backtrace limit exceeded";
          goto LABEL_61;
        }

        goto LABEL_62;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      uint64_t v32 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_oblivious_http_deserialize_options";
          os_log_type_t v24 = "%{public}s called with null (serialized_length >= sizeof(struct nw_serialized_oblivious_http_options)), no backtrace";
          goto LABEL_61;
        }

        goto LABEL_62;
      }

      if (!v32) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v53 = "nw_oblivious_http_deserialize_options";
      uint64_t v54 = 2082;
      v55 = (uint64_t)backtrace_string;
      BOOL v31 = "%{public}s called with null (serialized_length >= sizeof(struct nw_serialized_oblivious_http_options)), dump"
            "ing backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_181A5C000, v22, v23, v31, buf, 0x16u);
LABEL_33:

      free(backtrace_string);
      goto LABEL_63;
    }

    goto LABEL_63;
  }

  uint64_t v6 = calloc(1uLL, 0x28uLL);
  if (!v6)
  {
    __nwlog_obj();
    char v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v53 = "strict_calloc";
    uint64_t v54 = 2048;
    v55 = 1LL;
    v56 = 2048;
    uint64_t v57 = 40LL;
    unint64_t v27 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v27);
    if (result) {
      goto LABEL_66;
    }
    free(v27);
  }

  uint64_t v7 = v6[32] & 0xFE | *(_BYTE *)(a2 + 24) & 1;
  v6[32] = v7;
  v6[32] = v7 & 0xF9 | *(_BYTE *)(a2 + 24) & 6;
  *(void *)uint64_t v6 = *(void *)a2;
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8 + 32 > a3)
  {
LABEL_52:

    return (BOOL)v6;
  }

  if (v8)
  {
    int v9 = xpc_data_create((const void *)(a2 + 25), v8);
    os_log_type_t v10 = (void *)*((void *)v6 + 1);
    *((void *)v6 + 1) = v9;
  }

  uint64_t v11 = *(void *)(a2 + 16);
  if (v11)
  {
    os_log_type_t v12 = *(void *)(a2 + 8);
    uint64_t v13 = calloc(1uLL, *(void *)(a2 + 16));
    uint64_t v14 = v13;
    if (v13)
    {
      *((void *)v6 + 3) = v13;
      char v15 = *(void *)(a2 + 16);
      if (v15 >= 2)
      {
LABEL_10:
        os_log_type_t v16 = (unsigned __int8 *)(a2 + v12 + 25);
        BOOL v17 = 1LL;
        os_log_type_t v18 = v15;
        while (1)
        {
          os_log_type_t v19 = *v16;
          *uint64_t v14 = v19;
          if (!v19) {
            goto LABEL_41;
          }
          ++v14;
          ++v16;
          if (--v18 <= 1) {
            goto LABEL_38;
          }
        }
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      os_log_type_t v53 = "strict_calloc";
      uint64_t v54 = 2048;
      v55 = 1LL;
      v56 = 2048;
      uint64_t v57 = v11;
      BOOL v34 = (void *)_os_log_send_and_compose_impl();

      BOOL result = __nwlog_abort((uint64_t)v34);
      if (result) {
        goto LABEL_66;
      }
      free(v34);
      *((void *)v6 + 3) = 0LL;
      char v15 = *(void *)(a2 + 16);
      __nwlog_obj();
      __int16 v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v53 = "_strict_strlcpy";
      char v36 = (void *)_os_log_send_and_compose_impl();

      BOOL result = __nwlog_abort((uint64_t)v36);
      if (result) {
        goto LABEL_66;
      }
      free(v36);
      if (v15 >= 2) {
        goto LABEL_10;
      }
    }

    BOOL v17 = v15;
LABEL_38:
    if (v15 && v17) {
      *uint64_t v14 = 0;
    }
  }

LABEL_64:
      if (v19) {
        free(v19);
      }
      goto LABEL_5;
    }

    if (!v32)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v31 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v35 = "nw_application_id_copy_serialized_bytes";
        _os_log_impl( &dword_181A5C000,  v20,  v31,  "%{public}s called with null length, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_63;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v27 = type;
    BOOL v28 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v35 = "nw_application_id_copy_serialized_bytes";
        _os_log_impl(&dword_181A5C000, v20, v27, "%{public}s called with null length, no backtrace", buf, 0xCu);
      }

      goto LABEL_63;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v35 = "nw_application_id_copy_serialized_bytes";
      char v36 = 2082;
      uint64_t v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null length, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v14) {
    free(v14);
  }
  return 1LL;
}

  if (v70 == -1)
  {
    if (!v5) {
      goto LABEL_150;
    }
    goto LABEL_112;
  }

  v73 = *(_DWORD *)((char *)a2 + 1706);
  if ((v73 & 0x10) == 0)
  {
    *((_WORD *)a2 + 855) = *((_WORD *)a2 + 855);
    *(_DWORD *)((char *)a2 + 1706) = v73 | 8;
  }

  v74 = nw_connection_get_event_milliseconds(v24, 4, 4, &v407, 0LL);
  if (v74 == -1) {
    goto LABEL_97;
  }
  v75 = v74;
  if (v74 >= v70)
  {
    a2->proxy_milliseconds = v74 - v70;
    goto LABEL_97;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v76 = (id)gLogObj;
  buf[0] = 136446722;
  *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
  LOWORD(buf[3]) = 1024;
  *(_DWORD *)((char *)&buf[3] + 2) = v75;
  HIWORD(buf[4]) = 1024;
  buf[5] = v70;
  v77 = (char *)_os_log_send_and_compose_impl();

  v425[0] = 16;
  LOBYTE(v389) = 0;
  if (!__nwlog_fault(v77, v425, &v389))
  {
LABEL_95:
    uint64_t v5 = v374;
    if (!v77) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }

  if (v425[0] == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v78 = (os_log_s *)(id)gLogObj;
    v79 = v425[0];
    if (os_log_type_enabled(v78, (os_log_type_t)v425[0]))
    {
      buf[0] = 136446722;
      *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
      LOWORD(buf[3]) = 1024;
      *(_DWORD *)((char *)&buf[3] + 2) = v75;
      HIWORD(buf[4]) = 1024;
      buf[5] = v70;
      _os_log_impl(&dword_181A5C000, v78, v79, "%{public}s proxy_finish %u < proxy_start %u", (uint8_t *)buf, 0x18u);
    }

      if (v35) {
        free(v35);
      }
      goto LABEL_76;
    }

    __nwlog_obj();
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v63.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v31, &v63, &type))
    {
      if (LOBYTE(v63.receiver) == 17)
      {
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        receiver = (os_log_type_t)v63.receiver;
        if (os_log_type_enabled(v32, (os_log_type_t)v63.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
          _os_log_impl(&dword_181A5C000, v32, receiver, "%{public}s called with null message", buf, 0xCu);
        }
      }

      else if (type)
      {
        uint64_t v42 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = (os_log_type_t)v63.receiver;
        BOOL v44 = os_log_type_enabled(v32, (os_log_type_t)v63.receiver);
        if (v42)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
            v67 = 2082;
            v68 = v42;
            _os_log_impl( &dword_181A5C000,  v32,  v43,  "%{public}s called with null message, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v42);
          goto LABEL_57;
        }

        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
          _os_log_impl(&dword_181A5C000, v32, v43, "%{public}s called with null message, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v51 = (os_log_type_t)v63.receiver;
        if (os_log_type_enabled(v32, (os_log_type_t)v63.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "-[NWConcrete_nw_agent_client initWithMessage:agent:context:]";
          _os_log_impl( &dword_181A5C000,  v32,  v51,  "%{public}s called with null message, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

          free(v24);
          goto LABEL_73;
        }

        uint64_t v21 = (os_log_s *)__nwlog_obj();
        uint64_t v22 = type;
        if (!os_log_type_enabled(v21, type)) {
          goto LABEL_73;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        os_log_type_t v23 = "%{public}s called with null node";
      }

    nw_frame_set_metadata(a2, *(nw_protocol_metadata **)(v43 + 112), 1, v45);
    if (v45) {
      v56 = 0x80;
    }
    else {
      v56 = 0;
    }
    *(_BYTE *)(a2 + 186) = v56 & 0x80 | *(_BYTE *)(a2 + 186) & 0x7F;
    if (v45) {
      *(_WORD *)(*(void *)(a1 + 48) + 188LL) |= 0x8000u;
    }
    uint64_t v57 = *(void *)(a1 + 48);
    if (v57)
    {
      if (((*(unsigned __int16 *)(v57 + 188) | (*(unsigned __int8 *)(v57 + 190) << 16)) & 0x80000) == 0
        && *((_BYTE *)v46 + 1537))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v159 = *(void *)(a1 + 48);
          v160 = (const char *)(v159 + 191);
          v161 = "";
          if (!v159) {
            v160 = "";
          }
          v163 = *(_DWORD *)(v159 + 176);
          v162 = *(_DWORD *)(v159 + 180);
          if (v159) {
            v161 = " ";
          }
          v164 = **(void **)(*(void *)(v159 + 8) + 8LL);
          v165 = (*(unsigned __int16 *)(v159 + 188) >> 12) & 1;
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v160;
          v216 = 2080;
          v217 = (uint64_t)v161;
          v218 = 1024;
          *(_DWORD *)v219 = v162;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v163;
          *(_WORD *)&v219[10] = 2048;
          *(void *)&v219[12] = v164;
          *(_WORD *)&v219[20] = 1024;
          *(_DWORD *)&v219[22] = v165;
          v55 = "%{public}s %{public}s%s<i%u:s%d> last frame in input_frames is %p, inbound_message_complete: %u";
LABEL_203:
          v149 = (os_log_s *)v47;
          v150 = 60;
LABEL_204:
          _os_log_impl(&dword_181A5C000, v149, OS_LOG_TYPE_DEBUG, v55, buf, v150);
          goto LABEL_71;
        }
      }
    }

    else
    {
      v140 = *(void *)(a1 + 56);
      if ((!v140 || (*(__int16 *)(v140 + 388) & 0x80000000) == 0) && *((_BYTE *)v46 + 1537))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v141 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v143 = *(void *)(a1 + 48);
          v142 = *(void *)(a1 + 56);
          v144 = (const char *)(v142 + 390);
          v145 = "";
          if (v142) {
            v145 = " ";
          }
          else {
            v144 = "";
          }
          v146 = *(_DWORD *)(v142 + 368);
          v147 = **(void **)(*(void *)(v143 + 8) + 8LL);
          v148 = (*(unsigned __int16 *)(v143 + 188) >> 12) & 1;
          *(_DWORD *)buf = 136447490;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v144;
          v216 = 2080;
          v217 = (uint64_t)v145;
          v218 = 1024;
          *(_DWORD *)v219 = v146;
          *(_WORD *)&v219[4] = 2048;
          *(void *)&v219[6] = v147;
          *(_WORD *)&v219[14] = 1024;
          *(_DWORD *)&v219[16] = v148;
          v55 = "%{public}s %{public}s%s<i%u> last frame in input_frames is %p, inbound_message_complete: %u";
          v149 = (os_log_s *)v141;
          v150 = 54;
          goto LABEL_204;
        }
      }
    }

    goto LABEL_71;
  }

  uint64_t v11 = *(void *)(a1 + 48);
  if (v11)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v132 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v133 = *(void *)(a1 + 48);
        v134 = (const char *)(v133 + 191);
        v135 = "";
        v136 = v133 == 0;
        if (!v133) {
          v134 = "";
        }
        v139 = v133 + 176;
        v137 = *(_DWORD *)(v133 + 176);
        v138 = *(_DWORD *)(v139 + 4);
        if (!v136) {
          v135 = " ";
        }
        *(_DWORD *)buf = 136447746;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v134;
        v216 = 2080;
        v217 = (uint64_t)v135;
        v218 = 1024;
        *(_DWORD *)v219 = v138;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v137;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        *(_WORD *)&v219[16] = 1024;
        *(_DWORD *)&v219[18] = v9;
        v122 = "%{public}s %{public}s%s<i%u:s%d> remaining space %u less than frame length %u";
        v123 = (os_log_s *)v132;
        v124 = 56;
LABEL_176:
        _os_log_impl(&dword_181A5C000, v123, OS_LOG_TYPE_DEBUG, v122, buf, v124);
      }
    }
  }

  else
  {
    v115 = *(void *)(a1 + 56);
    if ((!v115 || (*(__int16 *)(v115 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v116 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v117 = *(void *)(a1 + 56);
        v118 = *(_DWORD *)(v117 + 368);
        v119 = v117 == 0;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        if (v117) {
          v120 = (const char *)(v117 + 390);
        }
        else {
          v120 = "";
        }
        v214 = 2082;
        v121 = " ";
        *(_DWORD *)buf = 136447490;
        if (v119) {
          v121 = "";
        }
        v215 = v120;
        v216 = 2080;
        v217 = (uint64_t)v121;
        v218 = 1024;
        *(_DWORD *)v219 = v118;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v8;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v9;
        v122 = "%{public}s %{public}s%s<i%u> remaining space %u less than frame length %u";
        v123 = (os_log_s *)v116;
        v124 = 50;
        goto LABEL_176;
      }
    }
  }

  input_frame = http2_create_input_frame(*(void *)(a1 + 56), *(void *)(a1 + 48), v8);
  if (!input_frame)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v210 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v20 = (os_log_s *)gLogObj;
      uint64_t v21 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v22 = "%{public}s http2_create_input_frame failed";
    }

    else if (v210)
    {
      char v36 = (char *)__nw_create_backtrace_string();
      BOOL v20 = (os_log_s *)__nwlog_obj();
      uint64_t v21 = type;
      uint64_t v37 = os_log_type_enabled(v20, type);
      if (v36)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v36;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s http2_create_input_frame failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v36);
        goto LABEL_132;
      }

      if (!v37)
      {
LABEL_132:
        if (v19) {
          free(v19);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v22 = "%{public}s http2_create_input_frame failed, no backtrace";
    }

    else
    {
      BOOL v20 = (os_log_s *)__nwlog_obj();
      uint64_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446210;
      v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v22 = "%{public}s http2_create_input_frame failed, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_132;
  }

  uint64_t v13 = input_frame;
  if (!*(void *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(void *)(input_frame + 88)))
  {
    os_log_type_t v16 = 0;
    __int16 v35 = 0LL;
  }

  else
  {
    char v15 = *(_DWORD *)(v13 + 52);
    uint64_t v14 = *(unsigned int *)(v13 + 56);
    if (v15) {
      os_log_type_t v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    }
    else {
      os_log_type_t v16 = 0;
    }
    __int16 v35 = (void *)(*(void *)(v13 + 112) + v14);
  }

  v38 = *(void *)(a1 + 48);
  if (v16 == (_DWORD)v8)
  {
    v39 = *(nw_protocol_metadata **)(v38 + 112);
    if (v39) {
      nw_frame_set_metadata(v13, v39, 1, 0);
    }
    __int16 v40 = (const void *)nw_frame_unclaimed_bytes(a2, 0LL);
    memcpy(v35, v40, v8);
    nw_frame_claim(a2, v41, v8, 0);
    http2_input_frame_metadata_reset(a2, *(void *)(a1 + 56), *(void *)(a1 + 48), v10);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v8;
    uint64_t v42 = *(void *)(a1 + 48);
    if (v42)
    {
      if (((*(unsigned __int16 *)(v42 + 188) | (*(unsigned __int8 *)(v42 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v186 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v187 = *(void *)(a1 + 48);
          if (v187) {
            v188 = (const char *)(v187 + 191);
          }
          else {
            v188 = "";
          }
          if (v187) {
            v189 = " ";
          }
          else {
            v189 = "";
          }
          v191 = *(_DWORD *)(v187 + 176);
          v190 = *(_DWORD *)(v187 + 180);
          v192 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)buf = 136448002;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v188;
          v216 = 2080;
          v217 = (uint64_t)v189;
          v218 = 1024;
          *(_DWORD *)v219 = v190;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v191;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v8;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v9;
          *(_WORD *)&v219[22] = 1024;
          *(_DWORD *)&v219[24] = v192;
          _os_log_impl( &dword_181A5C000,  v186,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> delivering partial frame (%u bytes of %u, %u bytes remaining)",  buf,  0x3Eu);
        }
      }
    }

    else
    {
      v166 = *(void *)(a1 + 56);
      if ((!v166 || (*(__int16 *)(v166 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v167 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v168 = *(void *)(a1 + 56);
          if (v168) {
            v169 = (const char *)(v168 + 390);
          }
          else {
            v169 = "";
          }
          if (v168) {
            v170 = " ";
          }
          else {
            v170 = "";
          }
          v171 = *(_DWORD *)(v168 + 368);
          v172 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v169;
          v216 = 2080;
          v217 = (uint64_t)v170;
          v218 = 1024;
          *(_DWORD *)v219 = v171;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v8;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v9;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v172;
          _os_log_impl( &dword_181A5C000,  v167,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> delivering partial frame (%u bytes of %u, %u bytes remaining)",  buf,  0x38u);
        }
      }
    }

    goto LABEL_47;
  }

  if (v38)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v72 = *(void *)(a1 + 48);
    v73 = (const char *)(v72 + 191);
    v74 = v72 == 0;
    if (!v72) {
      v73 = "";
    }
    v77 = v72 + 176;
    v75 = *(_DWORD *)(v72 + 176);
    v76 = *(_DWORD *)(v77 + 4);
    if (v74) {
      v78 = "";
    }
    else {
      v78 = " ";
    }
    *(_DWORD *)buf = 136447746;
    v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    v214 = 2082;
    v215 = v73;
    v216 = 2080;
    v217 = (uint64_t)v78;
    v218 = 1024;
    *(_DWORD *)v219 = v76;
    *(_WORD *)&v219[4] = 1024;
    *(_DWORD *)&v219[6] = v75;
    *(_WORD *)&v219[10] = 1024;
    *(_DWORD *)&v219[12] = v16;
    *(_WORD *)&v219[16] = 1024;
    *(_DWORD *)&v219[18] = v8;
    v79 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v210 = 0;
    if (__nwlog_fault(v79, &type, &v210))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v80 = (os_log_s *)gconnectionLogObj;
        v81 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v82 = *(void *)(a1 + 48);
          v83 = (const char *)(v82 + 191);
          if (v82)
          {
            v84 = " ";
          }

          else
          {
            v83 = "";
            v84 = "";
          }

          v87 = v82 + 176;
          v85 = *(_DWORD *)(v82 + 176);
          v86 = *(_DWORD *)(v87 + 4);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v83;
          v216 = 2080;
          v217 = (uint64_t)v84;
          v218 = 1024;
          *(_DWORD *)v219 = v86;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v85;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame";
LABEL_139:
          v112 = v80;
          v113 = v81;
          v114 = 56;
LABEL_140:
          _os_log_impl(&dword_181A5C000, v112, v113, v88, buf, v114);
        }
      }

      else
      {
        if (v210)
        {
          v89 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v80 = (os_log_s *)gconnectionLogObj;
          v81 = type;
          v90 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (v89)
          {
            if (v90)
            {
              v91 = *(void *)(a1 + 48);
              v92 = (const char *)(v91 + 191);
              if (v91)
              {
                v93 = " ";
              }

              else
              {
                v92 = "";
                v93 = "";
              }

              v96 = v91 + 176;
              v94 = *(_DWORD *)(v91 + 176);
              v95 = *(_DWORD *)(v96 + 4);
              *(_DWORD *)buf = 136448002;
              v213 = "nw_protocol_http2_get_input_frames_block_invoke";
              v214 = 2082;
              v215 = v92;
              v216 = 2080;
              v217 = (uint64_t)v93;
              v218 = 1024;
              *(_DWORD *)v219 = v95;
              *(_WORD *)&v219[4] = 1024;
              *(_DWORD *)&v219[6] = v94;
              *(_WORD *)&v219[10] = 1024;
              *(_DWORD *)&v219[12] = v16;
              *(_WORD *)&v219[16] = 1024;
              *(_DWORD *)&v219[18] = v8;
              *(_WORD *)&v219[22] = 2082;
              *(void *)&v219[24] = v89;
              _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c reate_input_frame, dumping backtrace:%{public}s",  buf,  0x42u);
            }

            free(v89);
            if (!v79) {
              goto LABEL_143;
            }
            goto LABEL_142;
          }

          if (!v90) {
            goto LABEL_141;
          }
          v106 = *(void *)(a1 + 48);
          v107 = (const char *)(v106 + 191);
          if (v106)
          {
            v108 = " ";
          }

          else
          {
            v107 = "";
            v108 = "";
          }

          v111 = v106 + 176;
          v109 = *(_DWORD *)(v106 + 176);
          v110 = *(_DWORD *)(v111 + 4);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v107;
          v216 = 2080;
          v217 = (uint64_t)v108;
          v218 = 1024;
          *(_DWORD *)v219 = v110;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v109;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame, no backtrace";
          goto LABEL_139;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v80 = (os_log_s *)gconnectionLogObj;
        v81 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v100 = *(void *)(a1 + 48);
          v101 = (const char *)(v100 + 191);
          if (v100)
          {
            v102 = " ";
          }

          else
          {
            v101 = "";
            v102 = "";
          }

          v105 = v100 + 176;
          v103 = *(_DWORD *)(v100 + 176);
          v104 = *(_DWORD *)(v105 + 4);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v101;
          v216 = 2080;
          v217 = (uint64_t)v102;
          v218 = 1024;
          *(_DWORD *)v219 = v104;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v103;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame, backtrace limit exceeded";
          goto LABEL_139;
        }
      }
    }
  }

  else
  {
    v173 = *(void *)(a1 + 56);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v174 = *(void *)(a1 + 56);
    v175 = (const char *)(v174 + 390);
    v176 = v174 == 0;
    v177 = *(_DWORD *)(v174 + 368);
    if (v176) {
      v175 = "";
    }
    *(_DWORD *)buf = 136447490;
    v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    if (v176) {
      v178 = "";
    }
    else {
      v178 = " ";
    }
    v214 = 2082;
    v215 = v175;
    v216 = 2080;
    v217 = (uint64_t)v178;
    v218 = 1024;
    *(_DWORD *)v219 = v177;
    *(_WORD *)&v219[4] = 1024;
    *(_DWORD *)&v219[6] = v16;
    *(_WORD *)&v219[10] = 1024;
    *(_DWORD *)&v219[12] = v8;
    v79 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v210 = 0;
    if (__nwlog_fault(v79, &type, &v210))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v179 = (os_log_s *)gconnectionLogObj;
        v180 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_141;
        }
        v181 = *(void *)(a1 + 56);
        v182 = (const char *)(v181 + 390);
        v183 = v181 == 0;
        if (!v181) {
          v182 = "";
        }
        v184 = *(_DWORD *)(v181 + 368);
        if (v183) {
          v185 = "";
        }
        else {
          v185 = " ";
        }
        *(_DWORD *)buf = 136447490;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v182;
        v216 = 2080;
        v217 = (uint64_t)v185;
        v218 = 1024;
        *(_DWORD *)v219 = v184;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_input_frame";
      }

      else if (v210)
      {
        v193 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v179 = (os_log_s *)gconnectionLogObj;
        v180 = type;
        v194 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v193)
        {
          if (v194)
          {
            v195 = *(void *)(a1 + 56);
            v196 = (const char *)(v195 + 390);
            v197 = v195 == 0;
            if (!v195) {
              v196 = "";
            }
            v198 = *(_DWORD *)(v195 + 368);
            if (v197) {
              v199 = "";
            }
            else {
              v199 = " ";
            }
            *(_DWORD *)buf = 136447746;
            v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            v214 = 2082;
            v215 = v196;
            v216 = 2080;
            v217 = (uint64_t)v199;
            v218 = 1024;
            *(_DWORD *)v219 = v198;
            *(_WORD *)&v219[4] = 1024;
            *(_DWORD *)&v219[6] = v16;
            *(_WORD *)&v219[10] = 1024;
            *(_DWORD *)&v219[12] = v8;
            *(_WORD *)&v219[16] = 2082;
            *(void *)&v219[18] = v193;
            _os_log_impl( &dword_181A5C000,  v179,  v180,  "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_ input_frame, dumping backtrace:%{public}s",  buf,  0x3Cu);
          }

          free(v193);
          goto LABEL_141;
        }

        if (!v194) {
          goto LABEL_141;
        }
        v205 = *(void *)(a1 + 56);
        v206 = (const char *)(v205 + 390);
        v207 = v205 == 0;
        if (!v205) {
          v206 = "";
        }
        v208 = *(_DWORD *)(v205 + 368);
        if (v207) {
          v209 = "";
        }
        else {
          v209 = " ";
        }
        *(_DWORD *)buf = 136447490;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v206;
        v216 = 2080;
        v217 = (uint64_t)v209;
        v218 = 1024;
        *(_DWORD *)v219 = v208;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_"
              "input_frame, no backtrace";
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v179 = (os_log_s *)gconnectionLogObj;
        v180 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_141;
        }
        v200 = *(void *)(a1 + 56);
        v201 = (const char *)(v200 + 390);
        v202 = v200 == 0;
        if (!v200) {
          v201 = "";
        }
        v203 = *(_DWORD *)(v200 + 368);
        if (v202) {
          v204 = "";
        }
        else {
          v204 = " ";
        }
        *(_DWORD *)buf = 136447490;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v201;
        v216 = 2080;
        v217 = (uint64_t)v204;
        v218 = 1024;
        *(_DWORD *)v219 = v203;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_"
              "input_frame, backtrace limit exceeded";
      }

      v112 = v179;
      v113 = v180;
      v114 = 50;
      goto LABEL_140;
    }
  }

  if (v17) {
    free(v17);
  }
  return 1LL;
}

  uint64_t v37 = *((void *)v3 + 6);
  if (!v37)
  {
    if (nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
      goto LABEL_108;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v45 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
    {
      v46 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446466;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      v73 = (void *)v46;
      _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_INFO,  "%{public}s <nw_association %{public}s> does not have a connected flow hash table",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_90;
  }

  handle = output_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = output_handler[1].callbacks;
    if (callbacks) {
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
  }

  os_log_type_t v10 = output_handler->callbacks;
  if (v10)
  {
    finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v10->finalize_output_frames;
    if (finalize_output_frames)
    {
      os_log_type_t v12 = finalize_output_frames(output_handler, a2);
      if (handle != &nw_protocol_ref_counted_handle) {
        return v12;
      }
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  name = output_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v47 = "__nw_protocol_finalize_output_frames";
  if (!name) {
    name = "invalid";
  }
  v48 = 2082;
  v49 = (void *)name;
  v50 = 2048;
  v51 = output_handler;
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v44 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v20 = (os_log_s *)__nwlog_obj();
    uint64_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_73;
    }
    uint64_t v22 = output_handler->identifier->name;
    if (!v22) {
      uint64_t v22 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v22;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_72:
    _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
    goto LABEL_73;
  }

  if (!v44)
  {
    BOOL v20 = (os_log_s *)__nwlog_obj();
    uint64_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_73;
    }
    char v36 = output_handler->identifier->name;
    if (!v36) {
      char v36 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v36;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
    goto LABEL_72;
  }

  BOOL v28 = (char *)__nw_create_backtrace_string();
  BOOL v20 = (os_log_s *)__nwlog_obj();
  uint64_t v21 = type;
  os_log_type_t v29 = os_log_type_enabled(v20, type);
  if (!v28)
  {
    if (!v29) {
      goto LABEL_73;
    }
    uint64_t v37 = output_handler->identifier->name;
    if (!v37) {
      uint64_t v37 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v37;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
    goto LABEL_72;
  }

  if (v29)
  {
    uint64_t v30 = output_handler->identifier->name;
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v30;
    v50 = 2048;
    v51 = output_handler;
    os_log_type_t v52 = 2082;
    os_log_type_t v53 = v28;
    _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v28);
LABEL_73:
  if (v19) {
    free(v19);
  }
  os_log_type_t v12 = 0LL;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_13:
    if (output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v14 = output_handler[1].callbacks;
      if (v14)
      {
        char v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
        output_handler[1].callbacks = v15;
        if (!v15)
        {
          os_log_type_t v16 = *(void (***)(void))output_handler[1].flow_id;
          if (v16)
          {
            *(void *)output_handler[1].flow_id = 0LL;
            v16[2](v16);
            _Block_release(v16);
          }

          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            BOOL v17 = *(const void **)output_handler[1].flow_id;
            if (v17) {
              _Block_release(v17);
            }
          }

          free(output_handler);
        }
      }
    }
  }

  return v12;
}

    if (v32) {
      free(v32);
    }
    LOBYTE(v17) = 0;
    uint64_t v6 = *(void *)(a1[4] + 8LL);
    goto LABEL_13;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v41 = "__nw_frame_is_packet_chain_member";
    char v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v27 = (os_log_s *)__nwlog_obj();
      BOOL v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v41 = "__nw_frame_is_packet_chain_member";
      os_log_type_t v29 = "%{public}s called with null frame";
    }

    else if (v38)
    {
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      unint64_t v27 = (os_log_s *)__nwlog_obj();
      BOOL v28 = type;
      BOOL v31 = os_log_type_enabled(v27, type);
      if (v30)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v41 = "__nw_frame_is_packet_chain_member";
          uint64_t v42 = 2082;
          os_log_type_t v43 = v30;
          _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
        goto LABEL_47;
      }

      if (!v31)
      {
LABEL_47:
        if (v26) {
          free(v26);
        }
        goto LABEL_49;
      }

      *(_DWORD *)buf = 136446210;
      BOOL v41 = "__nw_frame_is_packet_chain_member";
      os_log_type_t v29 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      unint64_t v27 = (os_log_s *)__nwlog_obj();
      BOOL v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v41 = "__nw_frame_is_packet_chain_member";
      os_log_type_t v29 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
    goto LABEL_47;
  }

  uint64_t v7 = *(unsigned __int16 *)(a2 + 204);
  uint64_t v8 = v7 | (*(unsigned __int8 *)(a2 + 206) << 16);
  if ((v7 & 0x40) == 0)
  {
LABEL_12:
    BOOL v17 = (v8 >> 7) & 1;
LABEL_13:
    *(_BYTE *)(v6 + 24) = v17;
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = nw_protocol_ipv6_process_input_frame( a1[9],  a2,  a1[8],  a1[10],  (_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL),  (_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL),  a3,  a4);
    if (*(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL)) {
      return 1LL;
    }
    --*(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
    goto LABEL_15;
  }

  if (*(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL)) {
    return 1LL;
  }
  int v9 = *(void *)(a1[6] + 8LL);
  os_log_type_t v10 = *(_DWORD *)(v9 + 24);
  *(_DWORD *)(v9 + 24) = v10 - 1;
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    BOOL v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
    uint64_t v42 = 2082;
    os_log_type_t v43 = "count";
    BOOL v44 = 2048;
    v45 = 1LL;
    v46 = 2048;
    v47 = v11;
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v12, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (os_log_s *)gLogObj;
        uint64_t v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          char v15 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          BOOL v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
          uint64_t v42 = 2082;
          os_log_type_t v43 = "count";
          BOOL v44 = 2048;
          v45 = 1LL;
          v46 = 2048;
          v47 = v15;
          os_log_type_t v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_29:
          _os_log_impl(&dword_181A5C000, v13, v14, v16, buf, 0x2Au);
        }
      }

      else if (v38)
      {
        uint64_t v21 = (char *)__nw_create_backtrace_string();
        uint64_t v13 = (os_log_s *)__nwlog_obj();
        uint64_t v14 = type;
        uint64_t v22 = os_log_type_enabled(v13, type);
        if (v21)
        {
          if (v22)
          {
            os_log_type_t v23 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
            *(_DWORD *)buf = 136447234;
            BOOL v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
            uint64_t v42 = 2082;
            os_log_type_t v43 = "count";
            BOOL v44 = 2048;
            v45 = 1LL;
            v46 = 2048;
            v47 = v23;
            v48 = 2082;
            v49 = v21;
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v21);
          goto LABEL_30;
        }

        if (v22)
        {
          BOOL v25 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          BOOL v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
          uint64_t v42 = 2082;
          os_log_type_t v43 = "count";
          BOOL v44 = 2048;
          v45 = 1LL;
          v46 = 2048;
          v47 = v25;
          os_log_type_t v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_29;
        }
      }

      else
      {
        uint64_t v13 = (os_log_s *)__nwlog_obj();
        uint64_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          os_log_type_t v24 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          BOOL v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
          uint64_t v42 = 2082;
          os_log_type_t v43 = "count";
          BOOL v44 = 2048;
          v45 = 1LL;
          v46 = 2048;
          v47 = v24;
          os_log_type_t v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }

    if (v30) {
      free(v30);
    }
    LOBYTE(v15) = 0;
    int v4 = *(void *)(a1[4] + 8LL);
    goto LABEL_13;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "__nw_frame_is_packet_chain_member";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      char v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "__nw_frame_is_packet_chain_member";
      unint64_t v27 = "%{public}s called with null frame";
    }

    else if (v36)
    {
      BOOL v28 = (char *)__nw_create_backtrace_string();
      BOOL v25 = (os_log_s *)__nwlog_obj();
      char v26 = type;
      os_log_type_t v29 = os_log_type_enabled(v25, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "__nw_frame_is_packet_chain_member";
          __int16 v40 = 2082;
          BOOL v41 = v28;
          _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v28);
        goto LABEL_47;
      }

      if (!v29)
      {
LABEL_47:
        if (v24) {
          free(v24);
        }
        goto LABEL_49;
      }

      *(_DWORD *)buf = 136446210;
      v39 = "__nw_frame_is_packet_chain_member";
      unint64_t v27 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      char v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "__nw_frame_is_packet_chain_member";
      unint64_t v27 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
    goto LABEL_47;
  }

  uint64_t v5 = *(unsigned __int16 *)(a2 + 204);
  uint64_t v6 = v5 | (*(unsigned __int8 *)(a2 + 206) << 16);
  if ((v5 & 0x40) == 0)
  {
LABEL_12:
    char v15 = (v6 >> 7) & 1;
LABEL_13:
    *(_BYTE *)(v4 + 24) = v15;
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = nw_protocol_ipv4_process_input_frame( a1[9],  a2,  a1[8],  a1[10],  (_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL),  (_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL));
    if (*(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL)) {
      return 1LL;
    }
    --*(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
    goto LABEL_15;
  }

  if (*(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL)) {
    return 1LL;
  }
  uint64_t v7 = *(void *)(a1[6] + 8LL);
  uint64_t v8 = *(_DWORD *)(v7 + 24);
  *(_DWORD *)(v7 + 24) = v8 - 1;
  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v9 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
    __int16 v40 = 2082;
    BOOL v41 = "count";
    uint64_t v42 = 2048;
    os_log_type_t v43 = 1LL;
    BOOL v44 = 2048;
    v45 = v9;
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v10, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (os_log_s *)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v13 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          __int16 v40 = 2082;
          BOOL v41 = "count";
          uint64_t v42 = 2048;
          os_log_type_t v43 = 1LL;
          BOOL v44 = 2048;
          v45 = v13;
          uint64_t v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_29:
          _os_log_impl(&dword_181A5C000, v11, v12, v14, buf, 0x2Au);
        }
      }

      else if (v36)
      {
        os_log_type_t v19 = (char *)__nw_create_backtrace_string();
        uint64_t v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v20 = os_log_type_enabled(v11, type);
        if (v19)
        {
          if (v20)
          {
            uint64_t v21 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
            *(_DWORD *)buf = 136447234;
            v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
            __int16 v40 = 2082;
            BOOL v41 = "count";
            uint64_t v42 = 2048;
            os_log_type_t v43 = 1LL;
            BOOL v44 = 2048;
            v45 = v21;
            v46 = 2082;
            v47 = v19;
            _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v19);
          goto LABEL_30;
        }

        if (v20)
        {
          os_log_type_t v23 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          __int16 v40 = 2082;
          BOOL v41 = "count";
          uint64_t v42 = 2048;
          os_log_type_t v43 = 1LL;
          BOOL v44 = 2048;
          v45 = v23;
          uint64_t v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_29;
        }
      }

      else
      {
        uint64_t v11 = (os_log_s *)__nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          uint64_t v22 = *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL);
          *(_DWORD *)buf = 136446978;
          v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          __int16 v40 = 2082;
          BOOL v41 = "count";
          uint64_t v42 = 2048;
          os_log_type_t v43 = 1LL;
          BOOL v44 = 2048;
          v45 = v22;
          uint64_t v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }

        if (v47) {
          free(v47);
        }
        goto LABEL_14;
      }
    }
  }

id nw_context_copy_implicit_context()
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  }
  return (id)nw_context_copy_implicit_context::implicit_context;
}

uint64_t nw_context_get_privacy_level(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if ((v1[34]._os_unfair_lock_opaque & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      os_unfair_lock_lock(v2 + 20);
      uint64_t os_unfair_lock_opaque = v2[31]._os_unfair_lock_opaque;
      os_unfair_lock_unlock(v2 + 20);
    }

    else
    {
      uint64_t os_unfair_lock_opaque = v2[31]._os_unfair_lock_opaque;
    }

    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_context_get_privacy_level";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_context_get_privacy_level";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_context_get_privacy_level";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_context_get_privacy_level";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_context_get_privacy_level";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_23:
  if (v6) {
    free(v6);
  }
  uint64_t os_unfair_lock_opaque = 1LL;
LABEL_6:

  return os_unfair_lock_opaque;
}

    if (v11) {
      free(v11);
    }
    int v9 = 0LL;
    goto LABEL_6;
  }

  int v4 = v1[136];
  if ((v4 & 0x40) != 0)
  {
LABEL_5:
    int v9 = (v4 >> 3) & 1;
LABEL_6:

    return v9;
  }

  uint64_t v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v5);
  uint64_t v6 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v24 = "nw_context_is_inline";
  uint64_t v7 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    int v4 = v3[136];
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v14) {
    free(v14);
  }
LABEL_6:
}

  if (v8) {
    free(v8);
  }
  enable_fast_open = 0LL;
LABEL_6:

  return enable_fast_open;
}

  return v12;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_25;
  }

  id v3 = (const void *)v1[16];
  if (!v3)
  {
    int v4 = v2[5];
    if (v4)
    {
      id v3 = *(const void **)(v4 + 128);
      goto LABEL_5;
    }

    if (v10) {
      free(v10);
    }
    goto LABEL_25;
  }

  id v3 = (void *)v1[12];
  if (v3)
  {
    int v4 = v3;
    uint64_t v5 = *(_WORD *)(v4 + 85);

    if ((v5 & 0x40) != 0)
    {
      os_log_type_t v8 = 1LL;
      goto LABEL_26;
    }
  }

  uint64_t v6 = (void *)v2[13];
  if (!v6)
  {
LABEL_25:
    os_log_type_t v8 = 0LL;
    goto LABEL_26;
  }

  uint64_t v7 = v6;
  os_log_type_t v8 = (*(unsigned __int16 *)(v7 + 85) >> 6) & 1;

LABEL_26:
  return v8;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_25;
  }

  if (!nw_path_uses_nexus_internal(v1, 0)
    || (nexus_agent = nw_path_get_nexus_agent(v2, 0), *(_DWORD *)(nexus_agent + 212) < 0xCCu))
  {
LABEL_25:
    uint64_t v5 = 0LL;
    goto LABEL_26;
  }

  int v4 = *(_DWORD *)(nexus_agent + 216);
  if (v4 >= 5) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = v4;
  }
LABEL_26:

  return v5;
}

    if (v11) {
      free(v11);
    }
    goto LABEL_25;
  }

  override_evaluator = v1->override_evaluator;
  if (!override_evaluator)
  {
    int v4 = nw_path_flow_registration_copy_parent_evaluator(v1);
    if (v4) {
      goto LABEL_5;
    }
LABEL_25:
    os_log_type_t v8 = 0LL;
    goto LABEL_6;
  }

  int v4 = override_evaluator;
LABEL_5:
  uint64_t v5 = (os_unfair_lock_s *)((char *)v4 + 96);
  uint64_t v6 = v4;
  os_unfair_lock_lock(v5);
  uint64_t v7 = v6[6];
  os_unfair_lock_unlock(v5);

  os_log_type_t v8 = nw_path_copy_for_flow_registration(v7, v2);
LABEL_6:

  return v8;
}

  if (v10) {
    free(v10);
  }
  can_support_user_packet_pool = 0LL;
LABEL_6:

  return can_support_user_packet_pool;
}

  if (v10) {
    free(v10);
  }
  should_use_event_ring = 0LL;
LABEL_6:

  return should_use_event_ring;
}

  if (v4) {
    free(v4);
  }
  return &nw_protocol_dummy_quic_connection_identifier(void)::dummy_quic_connection_identifier;
}

  if (v4) {
    free(v4);
  }
  return &nw_protocol_dummy_quic_stream_identifier(void)::dummy_quic_stream_identifier;
}

  uint64_t v14 = nw_parameters_copy_context(v13);
  char v15 = nw_path_copy_flow_registration(v14, (uint64_t)a1);
  if (v15)
  {
    os_log_type_t v16 = v15;
    stats_region = (nw_protocol_identifier *)nw_path_flow_registration_get_stats_region( v15,  (uint64_t)a1->identifier->name);
    a1[2].identifier = stats_region;
    if (!stats_region)
    {
      if (((uint64_t)a1[3].handle & 1) == 0)
      {
        if (gLogDatapath)
        {
          v80 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
            v86 = 2082;
            v87 = (char *)&a1[3].handle + 1;
            v88 = 2080;
            v89 = " ";
            v90 = 2048;
            p_output_handler = (char *)&a1[1].output_handler;
            v92 = 2048;
            v93 = &g_ip_stats;
            _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p ipv4->ip_stats is NULL setting to global %p",  buf,  0x34u);
          }
        }
      }

      a1[2].identifier = (nw_protocol_identifier *)&g_ip_stats;
    }

    os_release(v16);
  }

  if (v14) {
    os_release(v14);
  }
  *(void *)buf = 0LL;
  output_handler = a1->output_handler;
  if (output_handler)
  {
    uint64_t v19 = output_handler->callbacks;
    if (v19)
    {
      get_message_properties = (void (*)(nw_protocol *, nw_protocol *, _BYTE *))v19->get_message_properties;
      if (get_message_properties)
      {
        uint64_t v21 = output_handler->handle;
        if (v21 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v22 = output_handler[1].callbacks;
          if (v22) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v22->add_input_handler + 1);
          }
        }

        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v29 = a1[1].callbacks;
          if (v29) {
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v29->add_input_handler + 1);
          }
          get_message_properties(output_handler, a1, buf);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v47 = a1[1].callbacks;
            if (v47)
            {
              v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
              a1[1].callbacks = v48;
              if (!v48)
              {
                v49 = *(void (***)(void))a1[1].flow_id;
                if (v49)
                {
                  *(void *)a1[1].flow_id = 0LL;
                  v49[2](v49);
                  _Block_release(v49);
                }

                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v50 = *(const void **)a1[1].flow_id;
                  if (v50) {
                    _Block_release(v50);
                  }
                }

                free(a1);
              }
            }
          }
        }

        else
        {
          get_message_properties(output_handler, a1, buf);
        }

        if (v21 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v51 = output_handler[1].callbacks;
          if (v51)
          {
            os_log_type_t v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
            output_handler[1].callbacks = v52;
            if (!v52)
            {
              os_log_type_t v53 = *(void (***)(void))output_handler[1].flow_id;
              if (v53)
              {
                *(void *)output_handler[1].flow_id = 0LL;
                v53[2](v53);
                _Block_release(v53);
              }

              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                uint64_t v54 = *(const void **)output_handler[1].flow_id;
                if (v54) {
                  _Block_release(v54);
                }
              }

              free(output_handler);
            }
          }
        }
      }
    }
  }

  default_input_handler = a1->default_input_handler;
  if (!default_input_handler) {
    return;
  }
  uint64_t v30 = default_input_handler->callbacks;
  if (!v30) {
    return;
  }
  BOOL v31 = (void (*)(nw_protocol *, nw_protocol *))v30->connected;
  if (!v31) {
    return;
  }
  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v32 = default_input_handler[1].callbacks;
    if (v32) {
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
    }
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    v31(default_input_handler, a1);
    goto LABEL_77;
  }

  uint64_t v33 = a1[1].callbacks;
  if (v33) {
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v33->add_input_handler + 1);
  }
  v31(default_input_handler, a1);
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v34 = a1[1].callbacks;
    if (v34)
    {
      __int16 v35 = (nw_protocol_callbacks *)((char *)v34 - 1);
      a1[1].callbacks = v35;
      if (!v35)
      {
        char v36 = *(void (***)(void))a1[1].flow_id;
        if (v36)
        {
          *(void *)a1[1].flow_id = 0LL;
          v36[2](v36);
          _Block_release(v36);
        }

        if ((a1[1].flow_id[8] & 1) != 0)
        {
          uint64_t v37 = *(const void **)a1[1].flow_id;
          if (v37) {
            _Block_release(v37);
          }
        }

        BOOL v28 = a1;
        goto LABEL_76;
      }
    }
  }

    if (!v9)
    {
LABEL_25:
      uint64_t v14 = 0LL;
      goto LABEL_26;
    }

    BOOL v11 = (const char *)nw_setting_tcpconn_min_delay;
    networkd_settings_init();
    if (sCachedSettings)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (sCachedSettings) {
        os_log_type_t v12 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v11);
      }
      else {
        os_log_type_t v12 = 0LL;
      }
      pthread_mutex_unlock(&sSettingsMutex);
    }

    else
    {
      os_log_type_t v12 = 0LL;
    }

    char v13 = (const char *)nw_setting_tcpconn_max_delay;
    networkd_settings_init();
    if (sCachedSettings)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (sCachedSettings) {
        uint64_t v14 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v13);
      }
      else {
        uint64_t v14 = 0LL;
      }
      pthread_mutex_unlock(&sSettingsMutex);
      char v15 = 100000000LL;
      if (v12) {
        char v15 = v12;
      }
      if (v14) {
        goto LABEL_40;
      }
    }

    else
    {
      char v15 = 100000000LL;
      if (v12) {
        char v15 = v12;
      }
    }

    uint64_t v14 = 2000000000LL;
LABEL_40:
    if (v8 >= v14) {
      os_log_type_t v16 = v14;
    }
    else {
      os_log_type_t v16 = v8;
    }
    if (v8 >= v15) {
      __int16 v17 = v16;
    }
    else {
      __int16 v17 = v15;
    }

    goto LABEL_47;
  }

  __nwlog_obj();
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
  BOOL v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v27 = 0;
  if (__nwlog_fault(v20, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null child_handler", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s called with null child_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_64;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
        _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null child_handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
        _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s called with null child_handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v14) {
    free(v14);
  }
  return 22LL;
}

  *((void *)a1 + 2) = 0LL;
  os_log_type_t v12 = (void *)a3[37];
  *((void *)a1 + 3) = v12;
  *os_log_type_t v12 = a1;
  a3[37] = v7;
  if (a3[40]) {
    return;
  }
  *((_DWORD *)a3 + 104) = 0;
  char v13 = a3[50];
  if (v13 && a3[28])
  {
    uint64_t v14 = os_channel_advance_slot();
    if (!v14 || (BOOL v20 = v14, (nw_channel_check_defunct((uint64_t)a3) & 1) != 0))
    {
LABEL_28:
      a3[50] = 0LL;
      goto LABEL_29;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v39 = "nw_channel_finalize_input_frame";
    __int16 v40 = 1024;
    BOOL v41 = v20;
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v36 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v21, type, &v36))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v22 = (os_log_s *)__nwlog_obj();
        os_log_type_t v23 = type[0];
        if (!os_log_type_enabled(v22, type[0])) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446466;
        v39 = "nw_channel_finalize_input_frame";
        __int16 v40 = 1024;
        BOOL v41 = v20;
        os_log_type_t v24 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d";
        goto LABEL_66;
      }

      if (v36 == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v22 = (os_log_s *)__nwlog_obj();
        os_log_type_t v23 = type[0];
        if (!os_log_type_enabled(v22, type[0])) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446466;
        v39 = "nw_channel_finalize_input_frame";
        __int16 v40 = 1024;
        BOOL v41 = v20;
        os_log_type_t v24 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_66;
      }

      BOOL v25 = (char *)__nw_create_backtrace_string();
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type[0];
      char v26 = os_log_type_enabled(v22, type[0]);
      if (v25)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446722;
          v39 = "nw_channel_finalize_input_frame";
          __int16 v40 = 1024;
          BOOL v41 = v20;
          uint64_t v42 = 2082;
          os_log_type_t v43 = v25;
          _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v25);
        goto LABEL_67;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v39 = "nw_channel_finalize_input_frame";
        __int16 v40 = 1024;
        BOOL v41 = v20;
        os_log_type_t v24 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, no backtrace";
LABEL_66:
        _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0x12u);
      }
    }

    id v3 = 0LL;
    goto LABEL_24;
  }

  id v3 = nw_endpoint_flow_copy_connected_path(*(void *)&v2[62]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2 + 28);
LABEL_24:

  return v3;
}

    if (v8) {
      free(v8);
    }
LABEL_25:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unint64_t v27 = "nw_endpoint_handler_get_resolved_endpoint_count";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (__nwlog_fault(v16, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v27 = "nw_endpoint_handler_get_resolved_endpoint_count";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }

      else if (v24)
      {
        BOOL v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v17 = (os_log_s *)(id)gLogObj;
        uint64_t v21 = type;
        uint64_t v22 = os_log_type_enabled(v17, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v27 = "nw_endpoint_handler_get_resolved_endpoint_count";
            BOOL v28 = 2082;
            os_log_type_t v29 = v20;
            _os_log_impl( &dword_181A5C000,  v17,  v21,  "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v20);
          if (!v16) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }

        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v27 = "nw_endpoint_handler_get_resolved_endpoint_count";
          _os_log_impl( &dword_181A5C000,  v17,  v21,  "%{public}s Endpoint handler is not a resolver, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v27 = "nw_endpoint_handler_get_resolved_endpoint_count";
          _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v16)
    {
LABEL_32:
      uint64_t v6 = 0LL;
      goto LABEL_33;
    }

    uint64_t v5 = 1;
LABEL_24:

    goto LABEL_25;
  }

  uint64_t v5 = 1;
LABEL_25:

  return v5;
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_6:

  return v7;
}
}

    BOOL v11 = (v19 - 1) & v19;
    __int16 v17 = __clz(__rbit64(v19)) + (v14 << 6);
LABEL_24:
    uint64_t v21 = *(void *)(v32 + 72);
    sub_181BC9248(*(void *)(v5 + 48) + v21 * v17, (uint64_t)v4, type metadata accessor for NWBrowser.Result);
    sub_18264F648();
    NWEndpoint.hash(into:)();
    BOOL result = sub_18264F684();
    uint64_t v22 = -1LL << *(_BYTE *)(v7 + 32);
    os_log_type_t v23 = result & ~v22;
    os_log_type_t v24 = v23 >> 6;
    if (((-1LL << v23) & ~*(void *)(v12 + 8 * (v23 >> 6))) != 0)
    {
      char v15 = __clz(__rbit64((-1LL << v23) & ~*(void *)(v12 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      BOOL v25 = 0;
      char v26 = (unint64_t)(63 - v22) >> 6;
      do
      {
        if (++v24 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }

        unint64_t v27 = v24 == v26;
        if (v24 == v26) {
          os_log_type_t v24 = 0LL;
        }
        v25 |= v27;
        BOOL v28 = *(void *)(v12 + 8 * v24);
      }

      while (v28 == -1);
      char v15 = __clz(__rbit64(~v28)) + (v24 << 6);
    }

    *(void *)(v12 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v15;
    BOOL result = sub_181BC928C((uint64_t)v4, *(void *)(v7 + 48) + v15 * v21, type metadata accessor for NWBrowser.Result);
    ++*(void *)(v7 + 16);
  }

  BOOL v20 = v18 + 3;
  if (v20 >= v31)
  {
LABEL_33:
    BOOL result = swift_release_n();
    v1 = v29;
    goto LABEL_35;
  }

  uint64_t v19 = *(void *)(v30 + 8 * v20);
  if (v19)
  {
    uint64_t v14 = v20;
    goto LABEL_23;
  }

  while (1)
  {
    uint64_t v14 = v20 + 1;
    if (__OFADD__(v20, 1LL)) {
      break;
    }
    if (v14 >= v31) {
      goto LABEL_33;
    }
    uint64_t v19 = *(void *)(v30 + 8 * v14);
    ++v20;
    if (v19) {
      goto LABEL_23;
    }
  }

        BOOL v11 = (v19 - 1) & v19;
        __int16 v17 = __clz(__rbit64(v19)) + (v14 << 6);
      }

      uint64_t v21 = *(void *)(v33 + 72);
      sub_181BC928C(*(void *)(v5 + 48) + v21 * v17, (uint64_t)v4, type metadata accessor for NWBrowser.Result);
      sub_18264F648();
      NWEndpoint.hash(into:)();
      BOOL result = sub_18264F684();
      uint64_t v22 = -1LL << *(_BYTE *)(v7 + 32);
      os_log_type_t v23 = result & ~v22;
      os_log_type_t v24 = v23 >> 6;
      if (((-1LL << v23) & ~*(void *)(v12 + 8 * (v23 >> 6))) != 0)
      {
        char v15 = __clz(__rbit64((-1LL << v23) & ~*(void *)(v12 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        BOOL v25 = 0;
        char v26 = (unint64_t)(63 - v22) >> 6;
        do
        {
          if (++v24 == v26 && (v25 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }

          unint64_t v27 = v24 == v26;
          if (v24 == v26) {
            os_log_type_t v24 = 0LL;
          }
          v25 |= v27;
          BOOL v28 = *(void *)(v12 + 8 * v24);
        }

        while (v28 == -1);
        char v15 = __clz(__rbit64(~v28)) + (v24 << 6);
      }

      *(void *)(v12 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v15;
      BOOL result = sub_181BC928C((uint64_t)v4, *(void *)(v7 + 48) + v15 * v21, type metadata accessor for NWBrowser.Result);
      ++*(void *)(v7 + 16);
    }
  }

  BOOL result = swift_release();
  os_unfair_lock_s *v1 = v7;
  return result;
}

    BOOL v20 = v19;
    sub_181BE4844(v19, v8);
    sub_181BE4844(v45, v14);
    sub_181BE61C8(v20, v8);
    sub_181BE61C8(v45, v14);
    return 0LL;
  }

  uint64_t v19 = v46;
  if (v14 >> 60 == 15) {
    goto LABEL_23;
  }
  sub_181BE4844(v46, v8);
  sub_181BE4844(v45, v14);
  sub_181C05AD4(v46, v8);
  uint64_t v22 = v21;
  sub_181BE61C8(v45, v14);
  sub_181BE61C8(v46, v8);
  BOOL result = 0LL;
  if ((v22 & 1) == 0 || ((v44 ^ v43) & 1) != 0) {
    return result;
  }
LABEL_28:
  if (!v42)
  {
    char v26 = 0LL;
    os_log_type_t v23 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    goto LABEL_42;
  }

  os_log_type_t v23 = v41;
  if (!v41)
  {
    char v26 = v42;
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
LABEL_42:
    sub_181BD2FFC(v23);
    sub_181BD6288(v26);
    sub_181BD6288(v23);
    return 0LL;
  }

  swift_bridgeObjectRetain_n();
  os_log_type_t v24 = (nw_txt_record *)swift_unknownObjectRetain_n();
  is_equal = nw_txt_record_is_equal(v24, right);
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  sub_181BD6288(v42);
  if (!is_equal) {
    return 0LL;
  }
LABEL_33:
  BOOL result = v38 == 3 && v39 == 3;
  if (v39 != 3 && v38 != 3)
  {
    unint64_t v27 = 7496035LL;
    if ((_BYTE)v39)
    {
      BOOL v28 = 0xE700000000000000LL;
      else {
        os_log_type_t v29 = 0x72656B61657073LL;
      }
    }

    else
    {
      BOOL v28 = 0xE300000000000000LL;
      os_log_type_t v29 = 7496035LL;
    }

    if ((_BYTE)v38)
    {
      uint64_t v30 = 0xE700000000000000LL;
      else {
        unint64_t v27 = 0x72656B61657073LL;
      }
    }

    else
    {
      uint64_t v30 = 0xE300000000000000LL;
    }

    if (v29 == v27 && v28 == v30)
    {
      swift_bridgeObjectRelease_n();
    }

    else
    {
      BOOL v31 = sub_18264F4EC();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      BOOL result = 0LL;
      if ((v31 & 1) == 0) {
        return result;
      }
    }

    uint64_t v32 = v38 >> 8;
    uint64_t v33 = 0xE900000000000079LL;
    BOOL v34 = 0x74696D69786F7270LL;
    if (v39 >> 8)
    {
      if (v39 >> 8 == 1)
      {
        __int16 v35 = 0xE700000000000000LL;
        char v36 = 0x73646E65697266LL;
      }

      else
      {
        __int16 v35 = 0xE800000000000000LL;
        char v36 = 0x656E6F7972657665LL;
      }
    }

    else
    {
      char v36 = 0x74696D69786F7270LL;
      __int16 v35 = 0xE900000000000079LL;
    }

    if (v32)
    {
      if (v32 == 1)
      {
        uint64_t v33 = 0xE700000000000000LL;
        BOOL v34 = 0x73646E65697266LL;
      }

      else
      {
        uint64_t v33 = 0xE800000000000000LL;
        BOOL v34 = 0x656E6F7972657665LL;
      }
    }

    if (v36 == v34 && v35 == v33)
    {
      swift_bridgeObjectRelease_n();
      return 1LL;
    }

    else
    {
      uint64_t v37 = sub_18264F4EC();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return v37 & 1;
    }
  }

  return result;
}

  swift_bridgeObjectRetain();
  swift_retain();
  os_log_type_t v18 = 0LL;
  uint64_t v19 = (void *)MEMORY[0x18961AFE8];
LABEL_24:
  if (v19[2])
  {
    swift_beginAccess();
    sub_181C20890((uint64_t)v19);
    swift_endAccess();
    swift_bridgeObjectRelease();
    __int16 v35 = *v8;
    swift_beginAccess();
    *(void *)(v35 + 24) = 0LL;
  }

  BOOL result = swift_bridgeObjectRelease();
  char v36 = *(void *)(a1 + 16);
  uint64_t v37 = v36 - v18;
  if (v36 == v18) {
    goto LABEL_30;
  }
  if (v36 > v18)
  {
    v38 = (uint64_t *)(a1 + 32 * v18 + 56);
    do
    {
      v39 = *(v38 - 1);
      __int16 v40 = *v38;
      os_log_type_t v52 = *(_OWORD *)(v38 - 3);
      os_log_type_t v53 = v39;
      uint64_t v54 = v40;
      swift_bridgeObjectRetain();
      a2(v48, &v52);
      swift_bridgeObjectRelease();
      sub_181C1E17C(v48);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      v38 += 4;
      --v37;
    }

    while (v37);
LABEL_30:
    swift_release();
    return swift_bridgeObjectRelease();
  }

  swift_bridgeObjectRetain();
  swift_retain();
  os_log_type_t v18 = 0LL;
  uint64_t v19 = (void *)MEMORY[0x18961AFE8];
LABEL_24:
  if (v19[2])
  {
    swift_beginAccess();
    sub_181C20890((uint64_t)v19);
    swift_endAccess();
    swift_bridgeObjectRelease();
    uint64_t v33 = *v8;
    swift_beginAccess();
    *(void *)(v33 + 24) = 0LL;
  }

  BOOL result = swift_bridgeObjectRelease();
  BOOL v34 = *(void *)(a1 + 16);
  __int16 v35 = v34 - v18;
  if (v34 == v18) {
    goto LABEL_30;
  }
  if (v34 > v18)
  {
    char v36 = (uint64_t *)(a1 + 16 * v18 + 40);
    do
    {
      uint64_t v37 = *v36;
      v50[0] = *(v36 - 1);
      v50[1] = v37;
      swift_bridgeObjectRetain();
      a2(v46, v50);
      swift_bridgeObjectRelease();
      sub_181C1E17C(v46);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      v36 += 2;
      --v35;
    }

    while (v35);
LABEL_30:
    swift_release();
    return swift_bridgeObjectRelease();
  }

  swift_bridgeObjectRetain();
  char v15 = 0LL;
  os_log_type_t v16 = (void *)MEMORY[0x18961AFE8];
LABEL_24:
  if (v16[2])
  {
    swift_beginAccess();
    sub_181C20890((uint64_t)v16);
    swift_endAccess();
    swift_bridgeObjectRelease();
    os_log_type_t v29 = *v6;
    swift_beginAccess();
    *(void *)(v29 + 24) = 0LL;
  }

  BOOL result = swift_bridgeObjectRelease();
  uint64_t v30 = *(void *)(a1 + 16);
  BOOL v31 = v30 - v15;
  if (v30 == v15) {
    return swift_bridgeObjectRelease();
  }
  if (v30 > v15)
  {
    uint64_t v32 = (void *)(a1 + 56 * v15 + 80);
    do
    {
      uint64_t v33 = *(v32 - 5);
      BOOL v34 = *(v32 - 4);
      __int16 v35 = *(v32 - 3);
      char v36 = *((_BYTE *)v32 - 16);
      uint64_t v37 = *(v32 - 1);
      v38 = *v32;
      v45[0] = *(v32 - 6);
      v45[1] = v33;
      v45[2] = v34;
      v45[3] = v35;
      v46 = v36;
      v47 = v37;
      v48 = v38;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      sub_181C1E17C(v45);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      v32 += 7;
      --v31;
    }

    while (v31);
    return swift_bridgeObjectRelease();
  }

        char v13 = (v16 - 1) & v16;
        uint64_t v14 = __clz(__rbit64(v16)) + (v7 << 6);
        if (!*(void *)(v6 + 16))
        {
LABEL_51:
          swift_release();
          goto LABEL_49;
        }
      }

      uint64_t v42 = v13;
      os_log_type_t v43 = v7;
      os_log_type_t v18 = (uint64_t *)(*(void *)(v4 + 48) + 16 * v14);
      uint64_t v19 = *(unsigned __int16 *)(*(void *)(v4 + 56) + 4 * v14);
      uint64_t v21 = *v18;
      BOOL v20 = v18[1];
      swift_bridgeObjectRetain();
      uint64_t v22 = sub_181C8C01C(v21, v20);
      if ((v23 & 1) == 0)
      {
        swift_release();
        swift_bridgeObjectRelease();
        goto LABEL_49;
      }

      os_log_type_t v24 = *(unsigned __int16 *)(*(void *)(v6 + 56) + 4 * v22);
      BOOL result = swift_bridgeObjectRelease();
      BOOL v25 = v19 == 0xFFFF || v24 == 0xFFFF;
      if (!v25) {
        break;
      }
LABEL_5:
      BOOL v25 = v19 == v24;
      uint64_t v6 = v40;
      int v4 = v41;
      os_log_type_t v10 = v42;
      uint64_t v7 = v43;
      if (!v25)
      {
LABEL_47:
        swift_bridgeObjectRelease();
        swift_release();
        return 0LL;
      }
    }

    swift_beginAccess();
    BOOL result = swift_beginAccess();
    while (*(void *)(*(void *)v44 + 16LL) > (unint64_t)v19)
    {
      unint64_t v27 = *(void *)v44 + ((unint64_t)v19 << 6);
      BOOL result = *(void *)(v27 + 48);
      BOOL v28 = *(void *)(v27 + 56);
      os_log_type_t v29 = *(unsigned __int8 *)(v27 + 64);
      uint64_t v30 = *(void *)(v27 + 72);
      BOOL v31 = *(void *)(v27 + 80);
      uint64_t v19 = *(unsigned __int16 *)(v27 + 88);
      uint64_t v32 = *(void *)v11 + ((unint64_t)v24 << 6);
      uint64_t v33 = *(unsigned __int8 *)(v32 + 64);
      BOOL v34 = *(void *)(v32 + 72);
      __int16 v35 = *(void *)(v32 + 80);
      os_log_type_t v24 = *(unsigned __int16 *)(v32 + 88);
      if (result != *(void *)(v32 + 48) || v28 != *(void *)(v32 + 56))
      {
        BOOL result = sub_18264F4EC();
        if ((result & 1) == 0) {
          goto LABEL_47;
        }
      }

      if (v29 != v33) {
        goto LABEL_47;
      }
      if (v30 != v34 || v31 != v35)
      {
        BOOL result = sub_18264F4EC();
        if ((result & 1) == 0) {
          goto LABEL_47;
        }
      }

      if (v19 == 0xFFFF || v24 == 0xFFFF) {
        goto LABEL_5;
      }
    }

    __break(1u);
LABEL_55:
    __break(1u);
LABEL_56:
    __break(1u);
LABEL_57:
    __break(1u);
  }

  else
  {
    swift_bridgeObjectRelease();
LABEL_49:
    swift_bridgeObjectRelease();
    return 0LL;
  }

  return result;
}

  __break(1u);
LABEL_24:
  BOOL result = sub_18264F360();
  __break(1u);
  return result;
}

        os_log_type_t v16 = (v23 - 1) & v23;
        uint64_t v21 = __clz(__rbit64(v23)) + (v12 << 6);
      }

      BOOL v25 = *(void *)(*(void *)(v9 + 48) + 8 * v21);
      char v26 = *(void *)(v6 + 72);
      (*(void (**)(char *, unint64_t, uint64_t))(v6 + v40))(v8, *(void *)(v9 + 56) + v26 * v21, v5);
      BOOL result = sub_18264F63C();
      unint64_t v27 = -1LL << *(_BYTE *)(v11 + 32);
      BOOL v28 = result & ~v27;
      os_log_type_t v29 = v28 >> 6;
      if (((-1LL << v28) & ~*(void *)(v17 + 8 * (v28 >> 6))) != 0)
      {
        uint64_t v19 = __clz(__rbit64((-1LL << v28) & ~*(void *)(v17 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        uint64_t v30 = 0;
        BOOL v31 = (unint64_t)(63 - v27) >> 6;
        do
        {
          if (++v29 == v31 && (v30 & 1) != 0)
          {
            __break(1u);
            goto LABEL_41;
          }

          uint64_t v32 = v29 == v31;
          if (v29 == v31) {
            os_log_type_t v29 = 0LL;
          }
          v30 |= v32;
          uint64_t v33 = *(void *)(v17 + 8 * v29);
        }

        while (v33 == -1);
        uint64_t v19 = __clz(__rbit64(~v33)) + (v29 << 6);
      }

      *(void *)(v17 + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v19;
      *(void *)(*(void *)(v11 + 48) + 8 * v19) = v25;
      BOOL result = (*(uint64_t (**)(unint64_t, char *, uint64_t))(v6 + 32))( *(void *)(v11 + 56) + v26 * v19,  v8,  v5);
      ++*(void *)(v11 + 16);
    }
  }

  BOOL result = swift_release();
LABEL_40:
  _BYTE *v3 = v11;
  return result;
}

    os_log_type_t v16 = (v27 - 1) & v27;
    os_log_type_t v24 = __clz(__rbit64(v27)) + (v19 << 6);
LABEL_24:
    os_log_type_t v29 = v48;
    uint64_t v30 = *(void *)(v49 + 72);
    (*(void (**)(_BYTE *, unint64_t, uint64_t))(v49 + v21))(v9, *(void *)(v48 + 48) + v30 * v24, v7);
    BOOL v31 = *(void *)(v29 + 56);
    uint64_t v32 = *(void *)(v51 + 72);
    (*(void (**)(_BYTE *, unint64_t, uint64_t))(v51 + v21))(v50, v31 + v32 * v24, v52);
    sub_181C93408((unint64_t *)&qword_18C58E6E0, MEMORY[0x189606F48]);
    BOOL result = sub_18264E9DC();
    uint64_t v33 = -1LL << *(_BYTE *)(v12 + 32);
    BOOL v34 = result & ~v33;
    __int16 v35 = v34 >> 6;
    if (((-1LL << v34) & ~*(void *)(v17 + 8 * (v34 >> 6))) != 0)
    {
      uint64_t v22 = __clz(__rbit64((-1LL << v34) & ~*(void *)(v17 + 8 * (v34 >> 6)))) | v34 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      char v36 = 0;
      uint64_t v37 = (unint64_t)(63 - v33) >> 6;
      do
      {
        if (++v35 == v37 && (v36 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }

        v38 = v35 == v37;
        if (v35 == v37) {
          __int16 v35 = 0LL;
        }
        v36 |= v38;
        v39 = *(void *)(v17 + 8 * v35);
      }

      while (v39 == -1);
      uint64_t v22 = __clz(__rbit64(~v39)) + (v35 << 6);
    }

    *(void *)(v17 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v22;
    (*(void (**)(unint64_t, _BYTE *, uint64_t))(v49 + 32))(*(void *)(v12 + 48) + v30 * v22, v9, v7);
    BOOL result = (*(uint64_t (**)(unint64_t, _BYTE *, uint64_t))(v51 + 32))( *(void *)(v12 + 56) + v32 * v22,  v50,  v52);
    ++*(void *)(v12 + 16);
  }

  __int16 v40 = v48;
  swift_release();
  id v3 = v44;
  char v26 = v46;
  if ((v43 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  BOOL v41 = 1LL << *(_BYTE *)(v40 + 32);
  if (v41 >= 64) {
    bzero(v26, ((unint64_t)(v41 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *char v26 = -1LL << v41;
  }
  *(void *)(v40 + 16) = 0LL;
LABEL_41:
  BOOL result = swift_release();
  _BYTE *v3 = v12;
  return result;
}

    uint64_t v21 = (v28 - 1) & v28;
LABEL_8:
    BOOL v25 = (const char *)(sub_18264EACC() + 32);
    char v26 = sub_18264EACC();
    nw_relay_hop_add_additional_http_header_field(v17, v25, (const char *)(v26 + 32));
    swift_release();
    BOOL result = swift_release();
  }

  os_log_type_t v29 = v27 + 3;
  if (v29 >= v22)
  {
LABEL_24:
    swift_release();
    swift_unknownObjectRelease();
    sub_181BDA0F0(v31, &qword_18C45E580);
    sub_181BC920C(v32, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    BOOL result = swift_release();
    char *v33 = v17;
    return result;
  }

  BOOL v28 = *(void *)(v18 + 8 * v29);
  if (v28)
  {
    os_log_type_t v24 = v29;
    goto LABEL_23;
  }

  while (1)
  {
    os_log_type_t v24 = v29 + 1;
    if (__OFADD__(v29, 1LL)) {
      break;
    }
    if (v24 >= v22) {
      goto LABEL_24;
    }
    BOOL v28 = *(void *)(v18 + 8 * v24);
    ++v29;
    if (v28) {
      goto LABEL_23;
    }
  }

  __break(1u);
  return result;
}

            v62[0] = MEMORY[0x1895F87A8];
            v62[1] = 0x40000000LL;
            v63 = ___ZL33nw_protocol_udp_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            char v64 = &__block_descriptor_tmp_17;
            v65 = a1;
            tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              uint64_t v19 = (nw_frame *)*((void *)tqh_first + 4);
              BOOL v20 = ((uint64_t (*)(void *))v63)(v62);
              tqh_first = v19;
            }

            while ((v20 & 1) != 0);
            if (_nw_signposts_once != -1) {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
            }
            return v17;
          }

  if (v7) {
    free(v7);
  }
LABEL_6:
}

    operator delete(v23[0]);
    if ((v22 & 0x80000000) == 0)
    {
LABEL_12:
      if ((v20 & 0x80000000) == 0) {
        goto LABEL_13;
      }
      goto LABEL_25;
    }

  os_log_type_t v8 = 1;
LABEL_24:
  if (v6
    || !v8
    || *(_DWORD *)v2 != 1297239878
    || (v2[4] == 18753 ? (os_log_type_t v10 = *((_BYTE *)v2 + 10) == 70) : (os_log_type_t v10 = 0),
        !v10 || (BOOL v11 = *((unsigned __int8 *)v2 + 11), v11 != 70) && v11 != 67))
  {
LABEL_42:
    if (v6 || v4 < 5 || *((_BYTE *)v2 + 3) || *((_BYTE *)v2 + 4)) {
      goto LABEL_46;
    }
    if (*((_BYTE *)v2 + 1))
    {
      if (*((_BYTE *)v2 + 1) == 1 && (v2[1] & 0xF7) == 1) {
        goto LABEL_74;
      }
    }

    else if ((v2[1] & 0xF6) == 2)
    {
LABEL_74:
      uint64_t v6 = 11;
      *(_BYTE *)(result + 23) = 11;
      *(_DWORD *)(result + 7) = 1634169441;
      char v15 = "image/targa";
LABEL_75:
      *(void *)BOOL result = *(void *)v15;
      *(_BYTE *)(result + 11) = 0;
      goto LABEL_66;
    }

    if (v9) {
      free(v9);
    }
    goto LABEL_6;
  }

  uint64_t v5 = v3[136];
  if ((v5 & 0x40) == 0)
  {
LABEL_5:
    v4[136] = v5 & 0xFE | a2;
LABEL_6:

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_context_set_isolate_protocol_stack";
  uint64_t v7 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v7))
  {
    free(v7);
    uint64_t v5 = v4[136];
    goto LABEL_5;
  }

  __break(1u);
}

    if (v8) {
      free(v8);
    }
    goto LABEL_6;
  }

  if ((v3[34] & 0x40) == 0)
  {
LABEL_5:
    v4[30] = a2;
LABEL_6:

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_context_set_scheduling_mode";
  uint64_t v6 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    goto LABEL_5;
  }

  __break(1u);
}

    if (v12) {
      free(v12);
    }
    goto LABEL_6;
  }

  if ((v7[34] & 0x40) == 0)
  {
LABEL_5:
    v8[21] = a2;
    v8[22] = a3;
    v8[23] = a4;
LABEL_6:

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v9 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_context_set_protocol_cache_limits";
  os_log_type_t v10 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v10))
  {
    free(v10);
    goto LABEL_5;
  }

  __break(1u);
}

  if (v8) {
    free(v8);
  }
LABEL_8:
  nw_context_purge_endpoints(*(NWConcrete_nw_context **)(a1 + 32), 0);
}

    free(backtrace_string);
    if (!v13) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  +[NWEndpoint endpointWithInternalEndpoint:](&OBJC_CLASS___NWEndpoint, "endpointWithInternalEndpoint:", v9);
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_40:

  return v11;
}

    free(backtrace_string);
    if (!v9) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  +[NWEndpoint endpointWithInternalEndpoint:](&OBJC_CLASS___NWEndpoint, "endpointWithInternalEndpoint:", v5);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_40:

  return v7;
}

  if (v20) {
    free(v20);
  }
LABEL_6:

  return v13;
}
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (!a3)
  {
LABEL_102:
    int v9 = 0LL;
LABEL_103:

    return v9;
  }

  radio_os_log_type_t type = nw_interface_get_radio_type(v7);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v18 = (os_log_s *)(id)gLogObj;
  uint64_t v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
  if (radio_type)
  {
    if (v19)
    {
      BOOL v20 = nw_interface_get_radio_type(v7);
      *(_DWORD *)buf = 136446722;
      v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
      v95 = 2112;
      v96 = (const char *)v7;
      v97 = 2080;
      *(void *)v98 = nw_interface_radio_type_to_string(v20);
      uint64_t v21 = "%{public}s did not find path report for interface %@[%s], creating";
      uint64_t v22 = v18;
      os_log_type_t v23 = 32;
LABEL_29:
      _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_DEBUG, v21, buf, v23);
    }
  }

  else if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
    v95 = 2112;
    v96 = (const char *)v7;
    uint64_t v21 = "%{public}s did not find path report for interface %@, creating";
    uint64_t v22 = v18;
    os_log_type_t v23 = 22;
    goto LABEL_29;
  }

  os_log_type_t v24 = *((unsigned int *)v5 + 11) + 1LL;
  BOOL v25 = v24 << 31 >> 31;
  *((_DWORD *)v5 + 11) = v24;
  if (v25 != v24 || v25 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v26 = (id)gLogObj;
    unint64_t v27 = (const char *)*((unsigned int *)v5 + 11);
    *(_DWORD *)buf = 136446978;
    v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
    v95 = 2082;
    v96 = "report->path_count";
    v97 = 2048;
    *(void *)v98 = 1LL;
    *(_WORD *)&v98[8] = 2048;
    v99 = v27;
    BOOL v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (__nwlog_fault(v28, &type, &v91))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v29 = (os_log_s *)(id)gLogObj;
        uint64_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          BOOL v31 = (const char *)*((unsigned int *)v5 + 11);
          *(_DWORD *)buf = 136446978;
          v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
          v95 = 2082;
          v96 = "report->path_count";
          v97 = 2048;
          *(void *)v98 = 1LL;
          *(_WORD *)&v98[8] = 2048;
          v99 = v31;
          _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
        }
      }

      else if (v91)
      {
        uint64_t v32 = __nw_create_backtrace_string();
        if (v32)
        {
          uint64_t v33 = (char *)v32;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v34 = (os_log_s *)(id)gLogObj;
          __int16 v35 = type;
          if (os_log_type_enabled(v34, type))
          {
            char v36 = (const char *)*((unsigned int *)v5 + 11);
            *(_DWORD *)buf = 136447234;
            v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
            v95 = 2082;
            v96 = "report->path_count";
            v97 = 2048;
            *(void *)v98 = 1LL;
            *(_WORD *)&v98[8] = 2048;
            v99 = v36;
            v100 = 2082;
            v101 = v33;
            _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v33);
          if (!v28) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }

        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v39 = type;
        if (os_log_type_enabled(v29, type))
        {
          __int16 v40 = (const char *)*((unsigned int *)v5 + 11);
          *(_DWORD *)buf = 136446978;
          v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
          v95 = 2082;
          v96 = "report->path_count";
          v97 = 2048;
          *(void *)v98 = 1LL;
          *(_WORD *)&v98[8] = 2048;
          v99 = v40;
          _os_log_impl( &dword_181A5C000,  v29,  v39,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace",  buf,  0x2Au);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v29 = (os_log_s *)(id)gLogObj;
        uint64_t v37 = type;
        if (os_log_type_enabled(v29, type))
        {
          v38 = (const char *)*((unsigned int *)v5 + 11);
          *(_DWORD *)buf = 136446978;
          v94 = "nw_data_transfer_report_get_path_report_for_interface_locked";
          v95 = 2082;
          v96 = "report->path_count";
          v97 = 2048;
          *(void *)v98 = 1LL;
          *(_WORD *)&v98[8] = 2048;
          v99 = v38;
          _os_log_impl( &dword_181A5C000,  v29,  v37,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded",  buf,  0x2Au);
        }
      }
    }

    if (!v28)
    {
LABEL_51:
      *((_DWORD *)v5 + 11) = -1;
      goto LABEL_52;
    }

  if (v4) {
    free(v4);
  }
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

    free(v8);
    goto LABEL_24;
  }

  __nwlog_obj();
  BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v33 = "nw_protocol_instance_process_external_input";
  __int16 v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v30 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v21 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v33 = "nw_protocol_instance_process_external_input";
      _os_log_impl(&dword_181A5C000, v18, v21, "%{public}s called with null block", buf, 0xCu);
    }

    goto LABEL_61;
  }

  if (!v30)
  {
    __nwlog_obj();
    os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v29 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v33 = "nw_protocol_instance_process_external_input";
      _os_log_impl(&dword_181A5C000, v18, v29, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_61;
  }

  BOOL v25 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  char v26 = type;
  unint64_t v27 = os_log_type_enabled(v18, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v33 = "nw_protocol_instance_process_external_input";
      _os_log_impl(&dword_181A5C000, v18, v26, "%{public}s called with null block, no backtrace", buf, 0xCu);
    }

    goto LABEL_61;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v33 = "nw_protocol_instance_process_external_input";
    BOOL v34 = 2082;
    __int16 v35 = v25;
    _os_log_impl( &dword_181A5C000,  v18,  v26,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v25);
  if (v17) {
    goto LABEL_63;
  }
LABEL_28:
}

  if (v11) {
    free(v11);
  }
  os_log_type_t v8 = 0LL;
LABEL_6:

  return v8;
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v10) {
    free(v10);
  }
  uint64_t v6 = 0LL;
LABEL_3:
  if (*v4 == v6)
  {
    uint64_t v7 = *(_BYTE *)(extra + 40);
    if ((v7 & 1) != 0)
    {
      nw::release_if_needed<nw_protocol *>(v4);
      uint64_t v7 = *(_BYTE *)(extra + 40);
    }

    *(void *)(extra + 32) = 0LL;
    *(_BYTE *)(extra + 40) = v7 | 1;
  }

  return 1LL;
}

  if (v7) {
    free(v7);
  }
  int v4 = 0LL;
LABEL_6:

  return v4;
}

    free(v9);
    goto LABEL_24;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http_authentication_ask_pat_for_creds";
  unint64_t v27 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v64[0] = 0;
  if (__nwlog_fault(v27, type, v64))
  {
    if (type[0] == 17)
    {
      BOOL v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_ask_pat_for_creds";
        uint64_t v30 = "%{public}s called with null http_authentication";
LABEL_60:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      }
    }

    else if (v64[0])
    {
      __int16 v35 = (char *)__nw_create_backtrace_string();
      BOOL v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      char v36 = os_log_type_enabled(v28, (os_log_type_t)type[0]);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_ask_pat_for_creds";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v35;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v35);
        goto LABEL_61;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_ask_pat_for_creds";
        uint64_t v30 = "%{public}s called with null http_authentication, no backtrace";
        goto LABEL_60;
      }
    }

    else
    {
      BOOL v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_ask_pat_for_creds";
        uint64_t v30 = "%{public}s called with null http_authentication, backtrace limit exceeded";
        goto LABEL_60;
      }
    }
  }
  }

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a3);
  if (!a3->output_handler) {
    nw_protocol_set_output_handler((uint64_t)a3, (uint64_t)a1);
  }
  return 1LL;
}

LABEL_24:
    if (v12) {
      free(v12);
    }
    return 0LL;
  }

  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      get_input_frames = (uint64_t (*)(void))callbacks->get_input_frames;
      if (get_input_frames) {
        return get_input_frames();
      }
    }

    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_flow_replay_get_input_frames";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s Output protocol handler does not support get_input_frames",  buf,  0xCu);
    }
  }

  return 0LL;
}

      free(backtrace_string);
      goto LABEL_33;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_protocol_trainer_bottom_notify_input";
    os_log_type_t v8 = "%{public}s called with null protocol";
LABEL_32:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
LABEL_33:
    if (v5) {
      free(v5);
    }
    return 0LL;
  }

  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_protocol_trainer_bottom_notify_input";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      uint64_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v16 = "nw_protocol_trainer_bottom_notify_input";
      os_log_type_t v8 = "%{public}s called with null trainer";
      goto LABEL_32;
    }

    if (!v13)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      uint64_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v16 = "nw_protocol_trainer_bottom_notify_input";
      os_log_type_t v8 = "%{public}s called with null trainer, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = type;
    os_log_type_t v12 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v16 = "nw_protocol_trainer_bottom_notify_input";
        __int16 v17 = 2082;
        os_log_type_t v18 = backtrace_string;
        BOOL v11 = "%{public}s called with null trainer, dumping backtrace:%{public}s";
        goto LABEL_22;
      }

      goto LABEL_23;
    }

    if (!v12) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_protocol_trainer_bottom_notify_input";
    os_log_type_t v8 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_32;
  }

  *(_DWORD *)(v2 + 188) = a2;
  BOOL result = *(void *)(a1 + 48);
  if (!result) {
    return result;
  }
  int v4 = *(void (**)(void))(*(void *)(result + 24) + 64LL);
  if (v4)
  {
    v4();
    return 1LL;
  }

  return 0LL;
}

      free(backtrace_string);
      goto LABEL_33;
    }

    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "nw_protocol_trainer_top_disconnect";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_32:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
LABEL_33:
    if (v3) {
      free(v3);
    }
    return 0LL;
  }

  if (!*(void *)(a1 + 40))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "nw_protocol_trainer_top_disconnect";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_trainer_top_disconnect";
      uint64_t v6 = "%{public}s called with null trainer";
      goto LABEL_32;
    }

    if (!v11)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      uint64_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_trainer_top_disconnect";
      uint64_t v6 = "%{public}s called with null trainer, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    os_log_type_t v10 = os_log_type_enabled(v4, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v14 = "nw_protocol_trainer_top_disconnect";
        char v15 = 2082;
        os_log_type_t v16 = backtrace_string;
        int v9 = "%{public}s called with null trainer, dumping backtrace:%{public}s";
        goto LABEL_22;
      }

      goto LABEL_23;
    }

    if (!v10) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "nw_protocol_trainer_top_disconnect";
    uint64_t v6 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_32;
  }

  BOOL result = *(void *)(a1 + 32);
  if (!result) {
    return result;
  }
  uint64_t v2 = *(void (**)(void))(*(void *)(result + 24) + 32LL);
  if (v2)
  {
    v2();
    return 1LL;
  }

  return 0LL;
}

LABEL_49:
    obj = 0LL;
    goto LABEL_50;
  }

  uint64_t v7 = v4[5];
  if (v7) {
    os_log_type_t v8 = nw_txt_record_create_with_bytes(*((const uint8_t **)v7 + 1), *((void *)v7 + 2));
  }
  else {
    os_log_type_t v8 = 0LL;
  }
  os_log_type_t v18 = *(void **)(bonjour_service + 40);
  *(void *)(bonjour_service + 40) = v8;

  *(_BYTE *)(bonjour_service + 72) = *(_BYTE *)(bonjour_service + 72) & 0xFE | (_BYTE)v4[9] & 1;
LABEL_29:
  obj = (void *)bonjour_service;
  if (!nw_advertise_descriptor_is_equal(v4, (void *)bonjour_service, 0))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v33 = "nw_advertise_descriptor_copy";
    BOOL v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v30 = 0;
    if (__nwlog_fault(v20, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_advertise_descriptor_copy";
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s deep copy of advertise descriptor doesn't match original",  buf,  0xCu);
        }
      }

      else if (v30)
      {
        os_log_type_t v23 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v33 = "nw_advertise_descriptor_copy";
            BOOL v34 = 2082;
            __int16 v35 = v23;
            _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s deep copy of advertise descriptor doesn't match original, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v23);
          if (!v20) {
            goto LABEL_50;
          }
          goto LABEL_61;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_advertise_descriptor_copy";
          _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s deep copy of advertise descriptor doesn't match original, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        unint64_t v27 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_advertise_descriptor_copy";
          _os_log_impl( &dword_181A5C000,  v21,  v27,  "%{public}s deep copy of advertise descriptor doesn't match original, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v20) {
LABEL_61:
    }
      free(v20);
  }

  __nwlog_obj();
  char v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_protocol_options_are_persistent";
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_options_are_persistent";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v23)
    {
      uint64_t v19 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      uint64_t v21 = os_log_type_enabled(v17, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_protocol_options_are_persistent";
          unint64_t v27 = 2082;
          BOOL v28 = v19;
          _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        goto LABEL_39;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_options_are_persistent";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_options_are_persistent";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_6:

  return v7;
}

    *(_OWORD *)buf = *(_OWORD *)(*((void *)v4 + 13) + 40LL);
    uuid_is_null(buf);
    if (v7)
    {
      if (!uuid_is_null(buf))
      {
        os_log_type_t v12 = (char *)v7;
        *(_OWORD *)(v12 + 88) = *(_OWORD *)buf;
      }
    }

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v11) {
    free(v11);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v8) {
    free(v8);
  }
LABEL_6:
}

  if (v8) {
    free(v8);
  }
  no_fast_open_cookie = 0LL;
LABEL_6:

  return no_fast_open_cookie;
}

  if (v8) {
    free(v8);
  }
  fast_open_force_enable = 0LL;
LABEL_6:

  return fast_open_force_enable;
}

  if (v8) {
    free(v8);
  }
  reduce_buffering = 0LL;
LABEL_6:

  return reduce_buffering;
}

  if (v8) {
    free(v8);
  }
  no_delay = 0LL;
LABEL_6:

  return no_delay;
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v8) {
    free(v8);
  }
  enable_keepalive = 0LL;
LABEL_6:

  return enable_keepalive;
}

  if (v8) {
    free(v8);
  }
  keepalive_idle_time = 0LL;
LABEL_6:

  return keepalive_idle_time;
}

  if (v8) {
    free(v8);
  }
  keepalive_interval = 0LL;
LABEL_6:

  return keepalive_interval;
}

  if (v8) {
    free(v8);
  }
  enable_keepalive_offload = 0LL;
LABEL_6:

  return enable_keepalive_offload;
}

  if (v8) {
    free(v8);
  }
  enable_background_traffic_management = 0LL;
LABEL_6:

  return enable_background_traffic_management;
}

    if (!v7) {
      goto LABEL_5;
    }
LABEL_24:
    free(v7);
    goto LABEL_5;
  }

  if (!v4 || dispatch_data_get_size(v4))
  {
    objc_storeStrong(v3 + 18, a2);
    goto LABEL_5;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_parameters_set_initial_data_payload";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v20 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)(id)gLogObj;
    int v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_parameters_set_initial_data_payload";
      _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s initial_data_payload is empty", buf, 0xCu);
    }

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_6:

  return v5;
}

      if (!v6) {
        goto LABEL_36;
      }
      goto LABEL_35;
    }

    os_log_type_t v16 = v43.st_mode & 0x1FF;
    if (v16 == 420) {
      goto LABEL_36;
    }
    if (!fchmod(v3, 0x1A4u))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v30 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v37 = 136447234;
        v38 = "fixFilePermissions";
        v39 = 2114;
        *(void *)__int16 v40 = v1;
        *(_WORD *)&v40[8] = 1024;
        *(_DWORD *)&v40[10] = v3;
        *(_WORD *)&v40[14] = 1024;
        *(_DWORD *)&v40[16] = v16;
        BOOL v41 = 1024;
        LODWORD(v42[0]) = 420;
        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully changed %{public}@ (fd %d) permissions from %o to %o",  (uint8_t *)v37,  0x28u);
      }

      goto LABEL_36;
    }

    __int16 v17 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v18 = (id)gLogObj;
    *(_DWORD *)uint64_t v37 = 136447234;
    v38 = "fixFilePermissions";
    v39 = 1024;
    *(_DWORD *)__int16 v40 = v3;
    *(_WORD *)&v40[4] = 1024;
    *(_DWORD *)&v40[6] = 420;
    *(_WORD *)&v40[10] = 2114;
    *(void *)&v40[12] = v1;
    BOOL v41 = 1024;
    LODWORD(v42[0]) = v17;
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      BOOL v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)uint64_t v37 = 136447234;
      v38 = "fixFilePermissions";
      v39 = 1024;
      *(_DWORD *)__int16 v40 = v3;
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = 420;
      *(_WORD *)&v40[10] = 2114;
      *(void *)&v40[12] = v1;
      BOOL v41 = 1024;
      LODWORD(v42[0]) = v17;
      uint64_t v21 = "%{public}s fchmod(%d, 0x%x) on %{public}@ failed %{darwin.errno}d";
    }

    else if (v35)
    {
      BOOL v31 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      BOOL v20 = type;
      uint64_t v32 = os_log_type_enabled(v19, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)uint64_t v37 = 136447490;
          v38 = "fixFilePermissions";
          v39 = 1024;
          *(_DWORD *)__int16 v40 = v3;
          *(_WORD *)&v40[4] = 1024;
          *(_DWORD *)&v40[6] = 420;
          *(_WORD *)&v40[10] = 2114;
          *(void *)&v40[12] = v1;
          BOOL v41 = 1024;
          LODWORD(v42[0]) = v17;
          WORD2(v42[0]) = 2082;
          *(void *)((char *)v42 + 6) = v31;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s fchmod(%d, 0x%x) on %{public}@ failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)v37,  0x32u);
        }

        free(v31);
        if (!v6) {
          goto LABEL_36;
        }
        goto LABEL_35;
      }

      if (!v32)
      {
LABEL_63:

        if (!v6) {
          goto LABEL_36;
        }
        goto LABEL_35;
      }

      *(_DWORD *)uint64_t v37 = 136447234;
      v38 = "fixFilePermissions";
      v39 = 1024;
      *(_DWORD *)__int16 v40 = v3;
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = 420;
      *(_WORD *)&v40[10] = 2114;
      *(void *)&v40[12] = v1;
      BOOL v41 = 1024;
      LODWORD(v42[0]) = v17;
      uint64_t v21 = "%{public}s fchmod(%d, 0x%x) on %{public}@ failed %{darwin.errno}d, no backtrace";
    }

    else
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)uint64_t v37 = 136447234;
      v38 = "fixFilePermissions";
      v39 = 1024;
      *(_DWORD *)__int16 v40 = v3;
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = 420;
      *(_WORD *)&v40[10] = 2114;
      *(void *)&v40[12] = v1;
      BOOL v41 = 1024;
      LODWORD(v42[0]) = v17;
      uint64_t v21 = "%{public}s fchmod(%d, 0x%x) on %{public}@ failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v19, v20, v21, (uint8_t *)v37, 0x28u);
    goto LABEL_63;
  }

  os_log_type_t v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v10 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = (id)gLogObj;
    v43.st_dev = 136446722;
    *(void *)&v43.st_mode = "fixFilePermissions";
    WORD2(v43.st_ino) = 2114;
    *(__darwin_ino64_t *)((char *)&v43.st_ino + 6) = (__darwin_ino64_t)v1;
    HIWORD(v43.st_gid) = 1024;
    v43.st_rdev = v10;
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)(id)gLogObj;
      uint64_t v14 = v37[0];
      if (os_log_type_enabled(v13, v37[0]))
      {
        v43.st_dev = 136446722;
        *(void *)&v43.st_mode = "fixFilePermissions";
        WORD2(v43.st_ino) = 2114;
        *(__darwin_ino64_t *)((char *)&v43.st_ino + 6) = (__darwin_ino64_t)v1;
        HIWORD(v43.st_gid) = 1024;
        v43.st_rdev = v10;
        char v15 = "%{public}s open(%{public}@, O_RDWR) failed %{darwin.errno}d";
LABEL_51:
        uint64_t v33 = v13;
        BOOL v34 = v14;
LABEL_52:
        _os_log_impl(&dword_181A5C000, v33, v34, v15, (uint8_t *)&v43, 0x1Cu);
      }
    }

    else
    {
      if (type)
      {
        BOOL v25 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v13 = (os_log_s *)(id)gLogObj;
        char v26 = v37[0];
        unint64_t v27 = os_log_type_enabled(v13, v37[0]);
        if (v25)
        {
          if (v27)
          {
            v43.st_dev = 136446978;
            *(void *)&v43.st_mode = "fixFilePermissions";
            WORD2(v43.st_ino) = 2114;
            *(__darwin_ino64_t *)((char *)&v43.st_ino + 6) = (__darwin_ino64_t)v1;
            HIWORD(v43.st_gid) = 1024;
            v43.st_rdev = v10;
            *((_WORD *)&v43.st_rdev + 2) = 2082;
            *(void *)((char *)&v43.st_rdev + 6) = v25;
            _os_log_impl( &dword_181A5C000,  v13,  v26,  "%{public}s open(%{public}@, O_RDWR) failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)&v43,  0x26u);
          }

          free(v25);
          goto LABEL_54;
        }

        if (!v27) {
          goto LABEL_53;
        }
        v43.st_dev = 136446722;
        *(void *)&v43.st_mode = "fixFilePermissions";
        WORD2(v43.st_ino) = 2114;
        *(__darwin_ino64_t *)((char *)&v43.st_ino + 6) = (__darwin_ino64_t)v1;
        HIWORD(v43.st_gid) = 1024;
        v43.st_rdev = v10;
        char v15 = "%{public}s open(%{public}@, O_RDWR) failed %{darwin.errno}d, no backtrace";
        uint64_t v33 = v13;
        BOOL v34 = v26;
        goto LABEL_52;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)(id)gLogObj;
      uint64_t v14 = v37[0];
      if (os_log_type_enabled(v13, v37[0]))
      {
        v43.st_dev = 136446722;
        *(void *)&v43.st_mode = "fixFilePermissions";
        WORD2(v43.st_ino) = 2114;
        *(__darwin_ino64_t *)((char *)&v43.st_ino + 6) = (__darwin_ino64_t)v1;
        HIWORD(v43.st_gid) = 1024;
        v43.st_rdev = v10;
        char v15 = "%{public}s open(%{public}@, O_RDWR) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
}

  if (v8) {
    free(v8);
  }
  maximum_datagram_size = 0;
LABEL_6:

  return maximum_datagram_size;
}

  if (v10) {
    free(v10);
  }
LABEL_6:
}

    if (v5) {
      free(v5);
    }
    return 0LL;
  }

  if (nw_protocol_demux_copy_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
  }
  if (nw_protocol_demux_copy_definition::definition)
  {
    uint64_t v2 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
    id v3 = nw_protocol_options_matches_definition(a1, v2);
    if (v2) {
      os_release(v2);
    }
    return v3;
  }

  return nw_protocol_options_matches_definition(a1, 0LL);
}

      char v15 = 0LL;
      goto LABEL_88;
    }

    char v15 = (os_log_s *)nw_proxy_config_copy_pac_script(v4);
    if (!v15)
    {
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v34 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          __int16 v35 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          char v36 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          uint64_t v37 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          v38 = nw_endpoint_get_logging_description(v37);
          v39 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          __int16 v40 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          BOOL v41 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          *(_DWORD *)bytes = 136447746;
          *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
          *(_WORD *)&bytes[12] = 2082;
          *(void *)&bytes[14] = v35;
          *(_WORD *)&bytes[22] = 2082;
          *(void *)&bytes[24] = v36;
          v133 = 2082;
          v134 = v38;
          v135 = 2082;
          v136 = v39;
          v137 = 2082;
          v138 = v40;
          v139 = 2114;
          v140 = v41;
          _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] PAC script missing",  bytes,  0x48u);
        }
      }

      goto LABEL_23;
    }

    os_log_type_t v16 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
    if (v16)
    {
      __int16 v17 = *(void **)(a1 + 32);
      v120 = v15;
      if (*(void *)(*(void *)(a1 + 40) + 64LL))
      {
        os_log_type_t v18 = nw_endpoint_handler_copy_parameters(v17);
        uint64_t v19 = *(const void **)(*(void *)(a1 + 40) + 64LL);
        BOOL v20 = nw_parameters_get_https_proxy_is_opaque(v18);
        uint64_t v21 = nw_parameters_get_https_proxy_over_tls(v18);
        uint64_t v22 = nw_parameters_get_should_trust_invalid_certificates(v18);
        os_log_type_t v23 = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 32));
        os_log_type_t v24 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        v122[0] = MEMORY[0x1895F87A8];
        v122[1] = 3221225472LL;
        v122[2] = ___ZL32nw_endpoint_proxy_resolve_configP30NWConcrete_nw_endpoint_handler_block_invoke_144;
        v122[3] = &unk_189BB9EF0;
        v123 = *(id *)(a1 + 32);
        v124 = *(id *)(a1 + 40);
        v125 = v4;
        BOOL v25 = nw_pac_resolver_create_with_script(v16, v19, v121, v20, v21, v22, v23, (uint64_t)v24, v122);

LABEL_53:
        v74 = v120;
        CFRelease(v16);
        goto LABEL_70;
      }

      v60 = nw_endpoint_handler_get_minimize_logging(v17);
      char v61 = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
      if (v60)
      {
        if ((v61 & 1) != 0) {
          goto LABEL_50;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v106 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
        {
          logd = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          v107 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          v108 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          v109 = nw_endpoint_get_logging_description(v108);
          v110 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          v111 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          v112 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          *(_DWORD *)bytes = 136447746;
          *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke_3";
          *(_WORD *)&bytes[12] = 2082;
          *(void *)&bytes[14] = logd;
          *(_WORD *)&bytes[22] = 2082;
          *(void *)&bytes[24] = v107;
          v133 = 2082;
          v134 = v109;
          v135 = 2082;
          v136 = v110;
          v137 = 2082;
          v138 = v111;
          v139 = 2114;
          v140 = v112;
          os_log_type_t v62 = v106;
          _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No URL, treating proxy as resolved",  bytes,  0x48u);
        }

        else
        {
          os_log_type_t v62 = v106;
        }
      }

      else
      {
        if ((v61 & 1) != 0)
        {
LABEL_50:
          v70 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
          if (!v70)
          {
            v71 = nw_array_copy(*(void *)(*(void *)(a1 + 40) + 56LL));
            v72 = *(void *)(*(void *)(a1 + 48) + 8LL);
            v73 = *(void **)(v72 + 40);
            *(void *)(v72 + 40) = v71;

            v70 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
          }

          nw_array_remove_object(v70, (uint64_t)v4);
          BOOL v25 = 0LL;
          *(_BYTE *)(*(void *)(a1 + 40) + 96LL) |= 0x80u;
          goto LABEL_53;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v62 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
        {
          logb = v62;
          v63 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          char v64 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          v65 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          v66 = nw_endpoint_get_logging_description(v65);
          v67 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          v68 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          uint64_t v69 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          *(_DWORD *)bytes = 136447746;
          *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
          *(_WORD *)&bytes[12] = 2082;
          *(void *)&bytes[14] = v63;
          *(_WORD *)&bytes[22] = 2082;
          *(void *)&bytes[24] = v64;
          v133 = 2082;
          v134 = v66;
          v135 = 2082;
          v136 = v67;
          v137 = 2082;
          v138 = v68;
          v139 = 2114;
          v140 = v69;
          os_log_type_t v62 = logb;
          _os_log_impl( &dword_181A5C000,  logb,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No URL, treating proxy as resolved",  bytes,  0x48u);
        }
      }

      goto LABEL_50;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v42 = (id)gLogObj;
    *(_DWORD *)bytes = 136446210;
    *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
    os_log_type_t v43 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v126 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v44 = (os_log_s *)(id)gLogObj;
      v45 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)bytes = 136446210;
        *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s _CFXPCCreateCFObjectFromXPCObject failed", bytes, 0xCu);
      }
    }

    else
    {
      if (v126)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v79 = type;
        v80 = os_log_type_enabled(v78, type);
        if (backtrace_string)
        {
          if (v80)
          {
            *(_DWORD *)bytes = 136446466;
            *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
            *(_WORD *)&bytes[12] = 2082;
            *(void *)&bytes[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, dumping backtrace:%{public}s",  bytes,  0x16u);
          }

          free(backtrace_string);
          if (!v43) {
            goto LABEL_88;
          }
          goto LABEL_87;
        }

        if (v80)
        {
          *(_DWORD *)bytes = 136446210;
          *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
          _os_log_impl( &dword_181A5C000,  v78,  v79,  "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, no backtrace",  bytes,  0xCu);
        }

LABEL_86:
        if (!v43) {
          goto LABEL_88;
        }
LABEL_87:
        free(v43);
        goto LABEL_88;
      }

      __nwlog_obj();
      BOOL v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v97 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)bytes = 136446210;
        *(void *)&bytes[4] = "nw_endpoint_proxy_resolve_config_block_invoke";
        _os_log_impl( &dword_181A5C000,  v44,  v97,  "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, backtrace limit exceeded",  bytes,  0xCu);
      }
    }

    goto LABEL_86;
  }

  if (v8) {
    free(v8);
  }
LABEL_6:
}

          os_log_s *v50 = 1;
        }

        os_log_type_t v43 = [v42 countByEnumeratingWithState:type objects:buf count:16];
      }

      while (v43);
    }

    goto LABEL_59;
  }

  os_log_type_t v10 = *(id *)(a1 + 32);
  BOOL v11 = v8;
  os_log_type_t v12 = v9;
  [NSString stringWithUTF8String:"Require-Interface"];
  char v13 = (void *)objc_claimAutoreleasedReturnValue();
  if (![v11 caseInsensitiveCompare:v13])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v55 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_require_interface_header";
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v11;
      *(_WORD *)&buf[22] = 2112;
      v97 = v12;
      _os_log_impl(&dword_181A5C000, v55, OS_LOG_TYPE_DEBUG, "%{public}s %@ : %@", buf, 0x20u);
    }

    if (!strcmp((const char *)[v12 UTF8String], "wifi"))
    {
      v56 = 1;
    }

    else if (!strcmp((const char *)[v12 UTF8String], "cellular"))
    {
      v56 = 2;
    }

    else
    {
      if (strcmp((const char *)[v12 UTF8String], "wired"))
      {
LABEL_58:

        goto LABEL_59;
      }

      v56 = 3;
    }

    v10[64] = v56;
    goto LABEL_58;
  }

  uint64_t v14 = *(id *)(a1 + 32);
  char v15 = v11;
  os_log_type_t v16 = v12;
  [NSString stringWithUTF8String:"Multipath"];
  __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
  if ([v15 caseInsensitiveCompare:v17])
  {

    os_log_type_t v18 = *(id *)(a1 + 32);
    uint64_t v19 = v15;
    BOOL v20 = v16;
    [NSString stringWithUTF8String:"Client-Application"];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v19 caseInsensitiveCompare:v21])
    {

      uint64_t v22 = *(id *)(a1 + 32);
      os_log_type_t v23 = v19;
      os_log_type_t v24 = v20;
      [NSString stringWithUTF8String:"Priority"];
      BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
      if ([v23 caseInsensitiveCompare:v25])
      {

        char v26 = (unsigned __int16 *)*(id *)(a1 + 32);
        unint64_t v27 = v23;
        BOOL v28 = v24;
        v83 = v26;
        [NSString stringWithUTF8String:"Listener-Association"];
        os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v27 caseInsensitiveCompare:v29])
        {
LABEL_17:

          goto LABEL_59;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v30 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_listener_association_header";
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v27;
          *(_WORD *)&buf[22] = 2112;
          v97 = v28;
          _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %@ : %@", buf, 0x20u);
        }

        BOOL v31 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v28];
        if (!v31)
        {
LABEL_16:

          goto LABEL_17;
        }

        WeakRetained = objc_loadWeakRetained((id *)(*((void *)v83 + 2) + 40LL));
        uint64_t v33 = [v28 UTF8String];
        BOOL v34 = (os_unfair_lock_s *)WeakRetained;
        __int16 v35 = v34;
        if (v34)
        {
          if (v33)
          {
            *(void *)os_log_type_t type = 0LL;
            *(void *)&os_log_type_t type[8] = type;
            *(void *)&v93 = 0x2020000000LL;
            WORD4(v93) = 0;
            *(void *)buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = __nw_masque_server_get_listener_association_port_block_invoke;
            v97 = &unk_189BC93F0;
            v98 = v34;
            v99 = type;
            v100 = v33;
            char v36 = (void (**)(void))_Block_copy(buf);
            os_unfair_lock_lock(v35 + 4);
            v36[2](v36);
            os_unfair_lock_unlock(v35 + 4);

            uint64_t v37 = *(_WORD *)(*(void *)&type[8] + 24LL);
            _Block_object_dispose(type, 8);
LABEL_13:

            v83[140] = v37;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v38 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              v39 = v83[140];
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_listener_association_header";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v39;
              _os_log_impl(&dword_181A5C000, v38, OS_LOG_TYPE_DEBUG, "%{public}s local port: %u", buf, 0x12u);
            }

            goto LABEL_16;
          }

          __nwlog_obj();
          v72 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_server_get_listener_association_port";
          uint64_t v69 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v101[0] = 0;
          if (__nwlog_fault(v69, type, v101))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v73 = type[0];
              if (os_log_type_enabled(v70, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_masque_server_get_listener_association_port";
                _os_log_impl(&dword_181A5C000, v70, v73, "%{public}s called with null key", buf, 0xCu);
              }

  if (v6) {
    free(v6);
  }
  id v3 = 0LL;
LABEL_6:

  return v3;
}

  if (v6) {
    free(v6);
  }
  is_multipath = 0LL;
LABEL_6:

  return is_multipath;
}

    if (!v7)
    {
LABEL_25:
      uint64_t v5 = 0LL;
      goto LABEL_26;
    }

  if (v9) {
    free(v9);
  }
LABEL_6:
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v18 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v19 = v12[12];
    switch(a3)
    {
      case 1073741825:
        BOOL v20 = "TCP_CONNECTION_EVENT_KEEPALIVE";
        break;
      case 1073741826:
        BOOL v20 = "TCP_CONNECTION_EVENT_CONDITIONS_CHANGED";
        break;
      case 1073741827:
        BOOL v20 = "TCP_CONNECTION_EVENT_DNSSEC";
        break;
      case 1073741828:
        BOOL v20 = "TCP_CONNECTION_EVENT_ADAPTIVE_READ_TIMEOUT";
        break;
      case 1073741829:
        BOOL v20 = "TCP_CONNECTION_EVENT_ADAPTIVE_WRITE_TIMEOUT";
        break;
      case 1073741830:
        BOOL v20 = "TCP_CONNECTION_EVENT_LOW_THROUGHPUT";
        break;
      case 1073741831:
        BOOL v20 = "TCP_CONNECTION_EVENT_BETTER_ROUTE_CHANGED";
        break;
      case 1073741832:
        BOOL v20 = "TCP_CONNECTION_EVENT_CONNECTION_ATTEMPT_TIMEOUT";
        break;
      case 1073741833:
        BOOL v20 = "TCP_CONNECTION_EVENT_CONNECTION_QUALITY_CHANGED";
        break;
      default:
        BOOL v20 = "TCP_CONNECTION_EVENT_CONNECTED";
        switch(a3)
        {
          case 1:
            goto LABEL_44;
          case 2:
            BOOL v20 = "TCP_CONNECTION_EVENT_READ_CLOSE";
            break;
          case 3:
            BOOL v20 = "TCP_CONNECTION_EVENT_DISCONNECTED";
            break;
          case 4:
            BOOL v20 = "TCP_CONNECTION_EVENT_WRITE_CLOSE";
            break;
          case 5:
            BOOL v20 = "TCP_CONNECTION_EVENT_BETTER_ROUTE";
            break;
          case 6:
            BOOL v20 = "TCP_CONNECTION_EVENT_VIABILITY_CHANGED";
            break;
          case 7:
            BOOL v20 = "TCP_CONNECTION_EVENT_WAITING";
            break;
          case 8:
            BOOL v20 = "TCP_CONNECTION_EVENT_TLS_HANDSHAKE_COMPLETE";
            break;
          default:
            BOOL v20 = "UNKNOWN";
            break;
        }

        break;
    }

  return v6;
}

  tcp_connection_set_adaptive_write_handler_on_nw_connection(v12);
  if (v12[38]) {
    goto LABEL_24;
  }
LABEL_10:
  uint64_t v14 = (void *)*((void *)v12 + 9);
  if (v14)
  {
LABEL_11:
    nw_connection_set_cancel_handler(*((void **)v2 + 2), v14);
    char v15 = (void *)*((void *)v12 + 9);
    *((void *)v12 + 9) = 0LL;
  }

  if (v6) {
    free(v6);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
  if (!nw_hash_table_remove_node(*(void *)(*(void *)(a1 + 40) + 184LL), a2))
  {
    os_log_type_t v18 = *(void *)(a1 + 40);
    if (!v18 || (*(_BYTE *)(v18 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        BOOL v20 = *(void *)(a1 + 40);
        uint64_t v21 = (const char *)(v20 + 464);
        uint64_t v22 = "";
        if (v20) {
          uint64_t v22 = " ";
        }
        else {
          uint64_t v21 = "";
        }
        os_log_type_t v23 = *(_DWORD *)(v20 + 460);
        os_log_type_t v24 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 64LL);
        *(_DWORD *)buf = 136447234;
        v49 = "nw_webtransport_session_destroy_block_invoke";
        v50 = 2082;
        v51 = (void *)v21;
        os_log_type_t v52 = 2080;
        os_log_type_t v53 = v22;
        uint64_t v54 = 1024;
        v55 = v23;
        v56 = 2048;
        uint64_t v57 = v24;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table",  buf,  0x30u);
      }
    }
  }

  BOOL v25 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v25)
  {
    if ((*(_BYTE *)(v25 + 276) & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v26 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        unint64_t v27 = *(void *)(v25 + 88);
        if (v27) {
          BOOL v28 = *(_DWORD *)(v27 + 460);
        }
        else {
          BOOL v28 = -1;
        }
        os_log_type_t v29 = *(void *)(v25 + 64);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_webtransport_stream_destroy";
        v50 = 2082;
        v51 = (void *)(v25 + 192);
        os_log_type_t v52 = 2080;
        os_log_type_t v53 = " ";
        uint64_t v54 = 1024;
        v55 = v28;
        v56 = 2048;
        uint64_t v57 = v29;
        uint64_t v58 = 2048;
        v59 = v25;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p",  buf,  0x3Au);
      }
    }

    if (*(void *)(v25 + 72))
    {
      if ((*(_BYTE *)(v25 + 276) & 0x10) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v30 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          BOOL v31 = *(void *)(v25 + 88);
          if (v31) {
            uint64_t v32 = *(_DWORD *)(v31 + 460);
          }
          else {
            uint64_t v32 = -1;
          }
          uint64_t v33 = *(void *)(v25 + 64);
          *(_DWORD *)buf = 136447234;
          v49 = "nw_webtransport_stream_destroy";
          v50 = 2082;
          v51 = (void *)(v25 + 192);
          os_log_type_t v52 = 2080;
          os_log_type_t v53 = " ";
          uint64_t v54 = 1024;
          v55 = v32;
          v56 = 2048;
          uint64_t v57 = v33;
          _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying",  buf,  0x30u);
        }
      }
    }

    BOOL v34 = *(void *)(v25 + 72);
    if (v34)
    {
      do
      {
        __int16 v35 = *(void *)(v34 + 32);
        nw_frame_finalize(v34);
        BOOL v34 = v35;
      }

      while (v35);
    }

    (*(void (**)(void, void))(*(void *)(v25 + 176) + 16LL))(*(void *)(v25 + 176), 0LL);
    char v36 = *(const void **)(v25 + 176);
    if (v36)
    {
      _Block_release(v36);
      *(void *)(v25 + 176) = 0LL;
    }

    if ((*(_BYTE *)(v25 + 168) & 1) != 0)
    {
      uint64_t v37 = *(void **)(v25 + 160);
      if (v37) {
        os_release(v37);
      }
    }

    *(void *)(v25 + 160) = 0LL;
    if ((*(_BYTE *)(v25 + 152) & 1) != 0)
    {
      v38 = *(void **)(v25 + 144);
      if (v38) {
        os_release(v38);
      }
    }

    *(void *)(v25 + 144) = 0LL;
    if ((*(_BYTE *)(v25 + 136) & 1) != 0)
    {
      v39 = *(void **)(v25 + 128);
      if (v39) {
        os_release(v39);
      }
    }

    if (v13) {
      free(v13);
    }
    *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = -1;
  }

  return 1LL;
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

      disconnected();
      return;
    }

    handle[184] = handle[184] & 0xFFC7 | 0x20;
    BOOL v20 = a1->default_input_handler;
    if (v20)
    {
      uint64_t v21 = v20->callbacks;
      if (v21)
      {
        disconnected = (void (*)(void))v21->disconnected;
        if (disconnected) {
          goto LABEL_23;
        }
      }
    }

    __nwlog_obj();
    uint64_t v22 = a1->default_input_handler;
    os_log_type_t v23 = "invalid";
    if (v22)
    {
      os_log_type_t v24 = v22->identifier;
      if (v24) {
        os_log_type_t v23 = (const char *)v24;
      }
    }

    *(_DWORD *)buf = 136446466;
    v83 = "nw_protocol_http_connect_disconnected";
    v84 = 2082;
    v85 = (void *)v23;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v80 = 0;
    BOOL v25 = (const char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v25, &type, &v80))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v26 = (os_log_s *)__nwlog_obj();
        unint64_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_154;
        }
        BOOL v28 = a1->default_input_handler;
        os_log_type_t v29 = "invalid";
        if (v28)
        {
          uint64_t v30 = v28->identifier;
          if (v30) {
            os_log_type_t v29 = (const char *)v30;
          }
        }

        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v29;
        BOOL v31 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_153:
        _os_log_impl(&dword_181A5C000, v26, v27, v31, buf, 0x16u);
        goto LABEL_154;
      }

      if (!v80)
      {
        char v26 = (os_log_s *)__nwlog_obj();
        unint64_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_154;
        }
        v74 = a1->default_input_handler;
        v75 = "invalid";
        if (v74)
        {
          v76 = v74->identifier;
          if (v76) {
            v75 = (const char *)v76;
          }
        }

        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v75;
        BOOL v31 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_153;
      }

      v66 = (char *)__nw_create_backtrace_string();
      char v26 = (os_log_s *)__nwlog_obj();
      unint64_t v27 = type;
      v67 = os_log_type_enabled(v26, type);
      if (!v66)
      {
        if (!v67) {
          goto LABEL_154;
        }
        v77 = a1->default_input_handler;
        v78 = "invalid";
        if (v77)
        {
          v79 = v77->identifier;
          if (v79) {
            v78 = (const char *)v79;
          }
        }

        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v78;
        BOOL v31 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
        goto LABEL_153;
      }

      if (v67)
      {
        v68 = a1->default_input_handler;
        uint64_t v69 = "invalid";
        if (v68)
        {
          v70 = v68->identifier;
          if (v70) {
            uint64_t v69 = (const char *)v70;
          }
        }

        *(_DWORD *)buf = 136446722;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v69;
        v86 = 2082;
        v87 = v66;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v66);
    }

    free(backtrace_string);
    goto LABEL_33;
  }

  int v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "nw_protocol_http_connect_get_remote_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_32:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

  char v15 = 0LL;
  if ((*(_WORD *)&self->_has & 0x800) != 0)
  {
LABEL_9:
    os_log_type_t v16 = 2654435761LL * self->_reduceBuffering;
    if ((*(_WORD *)&self->_has & 0x100) != 0) {
      goto LABEL_10;
    }
    goto LABEL_25;
  }

  if (v12) {
    free(v12);
  }
LABEL_7:
}

  nw_http2_transport_release_frame_array((nw_frame_array_s *)(v3 + 144));
  nw_http2_transport_release_frame_array((nw_frame_array_s *)(v3 + 128));
  nw_http2_transport_release_frame_array((nw_frame_array_s *)(v3 + 160));
  nw_http2_transport_release_frame_array((nw_frame_array_s *)(v3 + 176));
  *(void *)(v3 + 192) = 0LL;
  char v15 = *(void **)(v3 + 88);
  if (v15)
  {
    os_release(v15);
    *(void *)(v3 + 88) = 0LL;
  }

  os_log_type_t v16 = *(void **)(v3 + 96);
  if (v16)
  {
    os_release(v16);
    *(void *)(v3 + 96) = 0LL;
  }

  nghttp2_session_del();
LABEL_46:
  free((void *)v3);
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v9) {
    free(v9);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  free(v19);
  os_log_type_t v12 = &qword_18C45F000;
  if (v13) {
LABEL_43:
  }
    free(v13);
LABEL_58:
  os_log_type_t v43 = a1[4];
  if (v43)
  {
    BOOL v44 = *(void **)(v43 + 32);
    goto LABEL_60;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http1_get_output_handler";
  v110 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(type) = 16;
  LOBYTE(v213) = 0;
  if (__nwlog_fault(v110, &type, &v213))
  {
    if (type == 17)
    {
      v111 = (os_log_s *)__nwlog_obj();
      v112 = type;
      if (!os_log_type_enabled(v111, (os_log_type_t)type)) {
        goto LABEL_310;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_output_handler";
      v113 = "%{public}s called with null connection";
LABEL_309:
      _os_log_impl(&dword_181A5C000, v111, v112, v113, buf, 0xCu);
      goto LABEL_310;
    }

    if (!(_BYTE)v213)
    {
      v111 = (os_log_s *)__nwlog_obj();
      v112 = type;
      if (!os_log_type_enabled(v111, (os_log_type_t)type)) {
        goto LABEL_310;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_output_handler";
      v113 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_309;
    }

    v164 = (char *)__nw_create_backtrace_string();
    v111 = (os_log_s *)__nwlog_obj();
    v112 = type;
    v165 = os_log_type_enabled(v111, (os_log_type_t)type);
    if (!v164)
    {
      os_log_type_t v12 = &qword_18C45F000;
      if (!v165) {
        goto LABEL_310;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_output_handler";
      v113 = "%{public}s called with null connection, no backtrace";
      goto LABEL_309;
    }

    if (v165)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http1_get_output_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v164;
      _os_log_impl( &dword_181A5C000,  v111,  v112,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v164);
    os_log_type_t v12 = &qword_18C45F000;
  }

    free(backtrace_string);
    if (!v11) {
      return 0;
    }
    goto LABEL_38;
  }
  }
  }

  if (v12) {
    free(v12);
  }
  int v9 = 0LL;
LABEL_7:

  return v9;
}

  if (v12) {
    free(v12);
  }
  int v9 = 0LL;
LABEL_7:

  return v9;
}

      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      return v4 == 0LL;
    }
  }

  os_log_type_t v10 = calloc(1uLL, 0x78uLL);
  if (v10)
  {
LABEL_20:
    BOOL v11 = *(_OWORD *)a1;
    os_log_type_t v12 = *((_OWORD *)a1 + 1);
    v10[8] = a1[4];
    *((_OWORD *)v10 + 2) = v11;
    *((_OWORD *)v10 + 3) = v12;
    v10[10] = a2;
    char v13 = g_registration_list;
    void *v10 = g_registration_list;
    if (v13) {
      *(void *)(v13 + 8) = v10;
    }
    g_registration_list = (uint64_t)v10;
    v10[1] = &g_registration_list;
    goto LABEL_23;
  }

  char v15 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v18 = "strict_calloc";
  uint64_t v19 = 2048;
  BOOL v20 = 1LL;
  uint64_t v21 = 2048;
  uint64_t v22 = 120LL;
  os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v16);
  if (!result)
  {
    free(v16);
    goto LABEL_20;
  }

  __break(1u);
  return result;
}

  if (v8) {
    free(v8);
  }
  int v4 = 0LL;
LABEL_7:

  return v4;
}

    if (v7) {
      free(v7);
    }
    int v4 = 0LL;
    goto LABEL_4;
  }

  int v4 = calloc(1uLL, 4uLL);
  if (v4)
  {
LABEL_3:
    *int v4 = 0;
    *int v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v19 = "strict_calloc";
  BOOL v20 = 2048;
  uint64_t v21 = 1LL;
  uint64_t v22 = 2048;
  os_log_type_t v23 = 4LL;
  BOOL v11 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v4) {
    free(v4);
  }
}

    free(backtrace_string);
    if (!v16) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  +[NWEndpoint endpointWithInternalEndpoint:](&OBJC_CLASS___NWEndpoint, "endpointWithInternalEndpoint:", v12);
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_40:

  return (NWBonjourServiceEndpoint *)v14;
}

  *(void *)(*(void *)(*(void *)v11 + 8LL) + 24LL) = v17;
  BOOL v20 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
  if (!v20)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__src == 17)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      uint64_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      BOOL v34 = "%{public}s called with null cursor";
      goto LABEL_183;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      uint64_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }

    v51 = (char *)__nw_create_backtrace_string();
    uint64_t v32 = (os_log_s *)__nwlog_obj();
    uint64_t v33 = __src;
    os_log_type_t v53 = os_log_type_enabled(v32, (os_log_type_t)__src);
    if (!v51)
    {
      if (!v53) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }

    if (!v53) {
      goto LABEL_107;
    }
    goto LABEL_106;
  }

  if (a5 <= 0x3F)
  {
    __src = a5;
    uint64_t v21 = 1LL;
    goto LABEL_32;
  }

  if (!(a5 >> 14))
  {
    __src = bswap32(a5 | 0x4000) >> 16;
    uint64_t v21 = 2LL;
    goto LABEL_32;
  }

  if (!(a5 >> 30))
  {
    __src = bswap32(a5 | 0x80000000);
    uint64_t v21 = 4LL;
    goto LABEL_32;
  }

  if (a5 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v83 = "_http_vle_encode";
    v84 = 2048;
    v85 = (const char *)a5;
    uint64_t v30 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v30))
    {
      free(v30);
      os_log_type_t v24 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
      goto LABEL_37;
    }

  *(void *)(*(void *)(*(void *)v11 + 8LL) + 24LL) = v17;
  BOOL v20 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
  if (!v20)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v83 = "nw_http_fillout_binary_message_inner_block_invoke";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__src == 17)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      uint64_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      BOOL v34 = "%{public}s called with null cursor";
      goto LABEL_183;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      uint64_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }

    v51 = (char *)__nw_create_backtrace_string();
    uint64_t v32 = (os_log_s *)__nwlog_obj();
    uint64_t v33 = __src;
    os_log_type_t v53 = os_log_type_enabled(v32, (os_log_type_t)__src);
    if (!v51)
    {
      if (!v53) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_binary_message_inner_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }

    if (!v53) {
      goto LABEL_107;
    }
    goto LABEL_106;
  }

  if (a5 <= 0x3F)
  {
    __src = a5;
    uint64_t v21 = 1LL;
    goto LABEL_32;
  }

  if (!(a5 >> 14))
  {
    __src = bswap32(a5 | 0x4000) >> 16;
    uint64_t v21 = 2LL;
    goto LABEL_32;
  }

  if (!(a5 >> 30))
  {
    __src = bswap32(a5 | 0x80000000);
    uint64_t v21 = 4LL;
    goto LABEL_32;
  }

  if (a5 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v83 = "_http_vle_encode";
    v84 = 2048;
    v85 = (const char *)a5;
    uint64_t v30 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v30))
    {
      free(v30);
      os_log_type_t v24 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
      goto LABEL_37;
    }

  *(void *)(*(void *)(*(void *)v11 + 8LL) + 24LL) = v17;
  BOOL v20 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
  if (!v20)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__src == 17)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      uint64_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor";
      goto LABEL_183;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      uint64_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }

    v51 = (char *)__nw_create_backtrace_string();
    uint64_t v32 = (os_log_s *)__nwlog_obj();
    uint64_t v33 = __src;
    os_log_type_t v53 = os_log_type_enabled(v32, (os_log_type_t)__src);
    if (!v51)
    {
      if (!v53) {
        goto LABEL_184;
      }
      *(_DWORD *)buf = 136446210;
      v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }

    if (!v53) {
      goto LABEL_107;
    }
    goto LABEL_106;
  }

  if (a5 <= 0x3F)
  {
    __src = a5;
    uint64_t v21 = 1LL;
    goto LABEL_32;
  }

  if (!(a5 >> 14))
  {
    __src = bswap32(a5 | 0x4000) >> 16;
    uint64_t v21 = 2LL;
    goto LABEL_32;
  }

  if (!(a5 >> 30))
  {
    __src = bswap32(a5 | 0x80000000);
    uint64_t v21 = 4LL;
    goto LABEL_32;
  }

  if (a5 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v83 = "_http_vle_encode";
    v84 = 2048;
    v85 = (const char *)a5;
    uint64_t v30 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v30))
    {
      free(v30);
      os_log_type_t v24 = *(char **)(*(void *)(*(void *)v11 + 8LL) + 24LL);
      goto LABEL_37;
    }

      BOOL v11 = 0;
      goto LABEL_24;
    }

    if (v8 < 8u) {
      goto LABEL_23;
    }
    os_log_type_t v10 = bswap64(*(void *)v9 & 0xFFFFFFFFFFFFFF3FLL);
    BOOL v11 = 8;
  }

    if (v6) {
      free(v6);
    }
    goto LABEL_25;
  }

  *(void *)cStr = 0LL;
  state = self->state;
  else {
    id v3 = off_189BBFEB0[state];
  }
  asprintf((char **)cStr, "[SC%llu port %u %s]", self->uniqueID, self->localPortHBO, v3);
  if (!*(void *)cStr)
  {
LABEL_25:
    int v4 = 0LL;
    return (NSString *)v4;
  }

  int v4 = (__CFString *)CFStringCreateWithCStringNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  *(const char **)cStr,  0x8000100u,  (CFAllocatorRef)*MEMORY[0x189604DB8]);
  return (NSString *)v4;
}

    if (v14) {
      free(v14);
    }
    int v4 = 0LL;
    goto LABEL_4;
  }

  int v4 = (char *)calloc(1uLL, 0x48uLL);
  if (v4)
  {
LABEL_3:
    *((void *)v4 + 8) = 0LL;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *(_OWORD *)int v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    objc_storeStrong((id *)v4, *(id *)a2);
    objc_storeStrong((id *)v4 + 1, *(id *)(a2 + 8));
    objc_storeStrong((id *)v4 + 2, *(id *)(a2 + 16));
    uint64_t v5 = _Block_copy(*(const void **)(a2 + 40));
    uint64_t v6 = (void *)*((void *)v4 + 5);
    *((void *)v4 + 5) = v5;

    objc_storeStrong((id *)v4 + 6, *(id *)(a2 + 48));
    uint64_t v7 = v4[70];
    *((_DWORD *)v4 + 14) = *(_DWORD *)(a2 + 56);
    v4[70] = v7 & 0xFE | *(_BYTE *)(a2 + 70) & 1;
    *((void *)v4 + 4) = *(void *)(a2 + 32);
    objc_storeStrong((id *)v4 + 3, *(id *)(a2 + 24));
    os_log_type_t v8 = v4[70] & 0xFD | (2 * ((*(unsigned __int8 *)(a2 + 70) >> 1) & 1));
    v4[70] = v8;
    int v9 = v8 & 0xFFFFFFFB | (4 * ((*(unsigned __int8 *)(a2 + 70) >> 2) & 1));
    v4[70] = v9;
    os_log_type_t v10 = v9 & 0xFFFFFFF7 | (8 * ((*(unsigned __int8 *)(a2 + 70) >> 3) & 1));
    v4[70] = v10;
    BOOL v11 = v10 & 0xFFFFFFEF | (16 * ((*(unsigned __int8 *)(a2 + 70) >> 4) & 1));
    v4[70] = v11;
    v4[70] = v11 & 0xDF | *(_BYTE *)(a2 + 70) & 0x20;
    *((_WORD *)v4 + 34) = *(_WORD *)(a2 + 68);
    *(void *)(v4 + 60) = *(void *)(a2 + 60);
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  char v26 = "strict_calloc";
  unint64_t v27 = 2048;
  BOOL v28 = 1LL;
  os_log_type_t v29 = 2048;
  uint64_t v30 = 72LL;
  os_log_type_t v18 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v18);
  if (!result)
  {
    free(v18);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

    __break(1u);
    goto LABEL_24;
  }

  uint64_t v5 = *(const char **)(a1 + 16);
  v1 = *(const char **)(a1 + 24);
  if (v1 != v5)
  {
    uint64_t v6 = *(const char **)(a1 + 24);
    do
    {
      os_log_type_t v8 = (void *)*((void *)v6 - 1);
      v6 -= 8;
      uint64_t v7 = v8;
      if (v8) {
        os_release(v7);
      }
      *((void *)v1 - 1) = 0LL;
      v1 = v6;
    }

    while (v6 != v5);
  }

  *(void *)(a1 + 24) = v5;
  do
    int v9 = __ldxr(v3);
  while (__stlxr(0, v3));
  if (v9 != 255)
  {
    char v15 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_array_remove_all_objects";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    goto LABEL_23;
  }

    if (v7) {
      free(v7);
    }
    int v4 = 0LL;
    goto LABEL_4;
  }

  int v4 = calloc(1uLL, 0x10uLL);
  if (v4)
  {
LABEL_3:
    *int v4 = 0LL;
    v4[1] = 0LL;
    *(_OWORD *)int v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v19 = "strict_calloc";
  BOOL v20 = 2048;
  uint64_t v21 = 1LL;
  uint64_t v22 = 2048;
  os_log_type_t v23 = 16LL;
  BOOL v11 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v7) {
    free(v7);
  }
  int v4 = 0LL;
LABEL_6:

  return v4;
}

  if (v7) {
    free(v7);
  }
  int v4 = 0LL;
LABEL_6:

  return v4;
}

    if (v7) {
      free(v7);
    }
    int v4 = 0LL;
    goto LABEL_4;
  }

  int v4 = calloc(1uLL, 1uLL);
  if (v4)
  {
LABEL_3:
    *int v4 = 0;
    *int v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v19 = "strict_calloc";
  BOOL v20 = 2048;
  uint64_t v21 = 1LL;
  uint64_t v22 = 2048;
  os_log_type_t v23 = 1LL;
  BOOL v11 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v10) {
    free(v10);
  }
  uint64_t v5 = 0LL;
LABEL_6:

  return v5;
}

  if (v6) {
    free(v6);
  }
LABEL_6:
}

    if (v10) {
      free(v10);
    }
    int v4 = 0LL;
    goto LABEL_4;
  }

  int v4 = calloc(1uLL, 0x20uLL);
  if (v4)
  {
LABEL_3:
    uint64_t v5 = nw_protocol_options_copy(*(void **)(a2 + 16));
    uint64_t v6 = (void *)v4[2];
    v4[2] = v5;

    uint64_t v7 = v4[3] & 0xFE | *(_BYTE *)(a2 + 24) & 1;
    *((_BYTE *)v4 + 24) = v7;
    *((_BYTE *)v4 + 24) = v7 & 0xFD | *(_BYTE *)(a2 + 24) & 2;
    *(_OWORD *)int v4 = *(_OWORD *)a2;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v22 = "strict_calloc";
  os_log_type_t v23 = 2048;
  os_log_type_t v24 = 1LL;
  BOOL v25 = 2048;
  char v26 = 32LL;
  uint64_t v14 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

  if (v11) {
    free(v11);
  }
LABEL_6:
}

  if (v9) {
    free(v9);
  }
LABEL_6:
}
  }

  if (v7) {
    free(v7);
  }
  int v4 = 0LL;
LABEL_6:

  return v4;
}
  }

      if (v4 == 65087) {
        uint64_t v5 = 1;
      }
      else {
        uint64_t v5 = 40;
      }
      goto LABEL_26;
    }

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

      if (v7) {
        free(v7);
      }
LABEL_25:
      os_release(v6);
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        BOOL v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
        uint64_t v21 = "%{public}s called with null sec_metadata";
        goto LABEL_54;
      }

      if (!v26)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        BOOL v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_55;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
        uint64_t v21 = "%{public}s called with null sec_metadata, backtrace limit exceeded";
        goto LABEL_54;
      }

      os_log_type_t v24 = (char *)__nw_create_backtrace_string();
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      BOOL v20 = type;
      BOOL v25 = os_log_type_enabled(v19, type);
      if (v24)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v24;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null sec_metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v24);
        if (v18) {
          goto LABEL_56;
        }
        return;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
        uint64_t v21 = "%{public}s called with null sec_metadata, no backtrace";
LABEL_54:
        _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      BOOL v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
      uint64_t v21 = "%{public}s called with null handle";
      goto LABEL_54;
    }

    if (!v26)
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      BOOL v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
      uint64_t v21 = "%{public}s called with null handle, backtrace limit exceeded";
      goto LABEL_54;
    }

    uint64_t v22 = (char *)__nw_create_backtrace_string();
    uint64_t v19 = (os_log_s *)__nwlog_obj();
    BOOL v20 = type;
    os_log_type_t v23 = os_log_type_enabled(v19, type);
    if (!v22)
    {
      if (!v23) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
      uint64_t v21 = "%{public}s called with null handle, no backtrace";
      goto LABEL_54;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_send_certificate";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v22;
      _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v22);
  }

  if (!*(void *)(a1 + 176)) {
    goto LABEL_40;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  BOOL v44 = "nw_protocol_http3_stream_destroy";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v41 = 0;
  if (__nwlog_fault(v12, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)gLogObj;
      uint64_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_protocol_http3_stream_destroy";
      char v15 = "%{public}s should not have unprocessed framer input frames left when destroying";
      goto LABEL_37;
    }

    if (!v41)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)gLogObj;
      uint64_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_protocol_http3_stream_destroy";
      char v15 = "%{public}s should not have unprocessed framer input frames left when destroying, backtrace limit exceeded";
      goto LABEL_37;
    }

    os_log_type_t v16 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v13 = (os_log_s *)gLogObj;
    uint64_t v14 = type;
    __int16 v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v16)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v44 = "nw_protocol_http3_stream_destroy";
        v45 = 2082;
        v46 = v16;
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s should not have unprocessed framer input frames left when destroying, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v16);
      goto LABEL_38;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_protocol_http3_stream_destroy";
      char v15 = "%{public}s should not have unprocessed framer input frames left when destroying, no backtrace";
LABEL_37:
      _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    }
  }

      os_log_type_t v12 = 0;
      goto LABEL_24;
    }

    if (v9 < 8u) {
      goto LABEL_23;
    }
    BOOL v11 = bswap64(*(void *)v10 & 0xFFFFFFFFFFFFFF3FLL);
    os_log_type_t v12 = 8;
  }

    free(backtrace_string);
    goto LABEL_33;
  }

  int v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "nw_protocol_http3_get_output_local_endpoint";
    uint64_t v6 = "%{public}s called with null protocol";
LABEL_32:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
  }

    if (v8) {
      free(v8);
    }
    goto LABEL_5;
  }

  os_unfair_lock_lock(v3 + 3);
  if ((v3[2]._os_unfair_lock_opaque & 0x80000000) != 0)
  {
    os_unfair_lock_unlock(v3 + 3);
LABEL_5:
    uint64_t v5 = 0LL;
    goto LABEL_6;
  }

  uint64_t v5 = v4[2](v4);
  os_unfair_lock_unlock(v3 + 3);
LABEL_6:

  return v5;
}

    if (v9) {
      free(v9);
    }
    int v4 = 0LL;
    goto LABEL_4;
  }

  int v4 = calloc(1uLL, 0x28uLL);
  if (v4)
  {
LABEL_3:
    v4[4] = 0LL;
    *(_OWORD *)int v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    v4[4] = *((void *)a2 + 4);
    *(_OWORD *)int v4 = v5;
    *((_OWORD *)v4 + 1) = v6;
LABEL_4:

    return (BOOL)v4;
  }

  __nwlog_obj();
  os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v21 = "strict_calloc";
  uint64_t v22 = 2048;
  os_log_type_t v23 = 1LL;
  os_log_type_t v24 = 2048;
  BOOL v25 = 40LL;
  char v13 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

LABEL_24:
    if (v19) {
      free(v19);
    }
    goto LABEL_7;
  }

  objc_storeStrong((id *)&v9->_descriptor, a3);
  objc_storeStrong((id *)&v10->_parameters, a4);
  [v7 internalDescriptor];
  BOOL v11 = (nw_browse_descriptor *)objc_claimAutoreleasedReturnValue();
  [v8 internalParameters];
  os_log_type_t v12 = (nw_parameters *)objc_claimAutoreleasedReturnValue();
  char v13 = nw_browser_create(v11, v12);
  internalBrowser = v10->_internalBrowser;
  v10->_internalBrowser = v13;

  if (!v10->_internalBrowser)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v16 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v29 = "-[NWBrowser initWithDescriptor:parameters:]";
      uint64_t v30 = 2114;
      BOOL v31 = (char *)v7;
      uint64_t v32 = 2114;
      uint64_t v33 = v8;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s nw_browser_create failed with descriptor %{public}@ and parameters %{public}@",  buf,  0x20u);
    }

LABEL_7:
    char v15 = 0LL;
    goto LABEL_8;
  }

  -[NWBrowser setUpdateHandler](v10, "setUpdateHandler");
  char v15 = v10;
LABEL_8:

  return v15;
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0LL;
LABEL_6:

  return v6;
}

        goto LABEL_24;
      }

      if (!v23)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      uint64_t v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_path_create_evaluator_for_custom_ether";
          _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        char v26 = "nw_path_create_evaluator_for_custom_ether";
        unint64_t v27 = 2082;
        BOOL v28 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

        goto LABEL_24;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      uint64_t v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
          _os_log_impl(&dword_181A5C000, v8, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v24 = "nw_path_create_evaluator_for_all_custom_ether_interfaces";
        BOOL v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

        goto LABEL_24;
      }

      if (!v23)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      uint64_t v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_path_create_evaluator_for_custom_ip";
          _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        char v26 = "nw_path_create_evaluator_for_custom_ip";
        unint64_t v27 = 2082;
        BOOL v28 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

        goto LABEL_24;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_23;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      uint64_t v19 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
          _os_log_impl(&dword_181A5C000, v8, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_23;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v24 = "nw_path_create_evaluator_for_interpose";
        BOOL v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

  if (v7) {
    free(v7);
  }
LABEL_6:
}

    free(backtrace_string);
    if (!v9) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  nw_path_snapshot_path(v6);
  uint64_t v7 = v6;
LABEL_40:

  return v7;
}

    objc_storeStrong((id *)v3 + 7, a2);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 24);
    goto LABEL_24;
  }

  __nwlog_obj();
  os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v31 = "nw_path_evaluator_set_queue";
  char v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v28 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null queue", buf, 0xCu);
    }

    goto LABEL_57;
  }

  if (!v28)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v27 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_181A5C000, v16, v27, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_57;
  }

  os_log_type_t v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v24 = type;
  BOOL v25 = os_log_type_enabled(v16, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_181A5C000, v16, v24, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }

    goto LABEL_57;
  }

  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v31 = "nw_path_evaluator_set_queue";
    uint64_t v32 = 2082;
    uint64_t v33 = v23;
    _os_log_impl( &dword_181A5C000,  v16,  v24,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v23);
  if (v15) {
    goto LABEL_59;
  }
LABEL_24:
}

    if (v8) {
      free(v8);
    }
    goto LABEL_25;
  }

  id v3 = v1;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke;
  uint64_t v19 = &unk_189BC93A0;
  int v4 = (os_unfair_lock_s *)v3;
  BOOL v20 = v4;
  os_unfair_lock_lock(v4 + 2);
  ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v4 + 2);

  if ((BYTE1(v4[118]._os_unfair_lock_opaque) & 0xC0) != 0x80)
  {
LABEL_25:
    uint64_t v6 = 0LL;
    goto LABEL_26;
  }

  uint64_t v5 = *(void *)&v4[46]._os_unfair_lock_opaque;
  if (!v5 || *(void *)(v5 + 24) == *(void *)(v5 + 16)) {
    uint64_t v6 = BYTE2(v4[118]._os_unfair_lock_opaque) & 1;
  }
  else {
    uint64_t v6 = 1LL;
  }
LABEL_26:

  return v6;
}

    if (v9) {
      free(v9);
    }
    goto LABEL_4;
  }

  if (nw_path_uses_nexus_internal(v3, 0))
  {
    nexus_agent = (const unsigned __int8 *)nw_path_get_nexus_agent(v4, 0);
    if (!uuid_is_null(nexus_agent))
    {
      *a2 = *(_OWORD *)nexus_agent;
      uint64_t v6 = 1LL;
      goto LABEL_5;
    }
  }

  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0LL;
LABEL_6:

  return v6;
}

  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0LL;
LABEL_6:

  return v6;
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0LL;
LABEL_6:

  return v7;
}

  if (v10) {
    free(v10);
  }
LABEL_6:
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v10) {
    free(v10);
  }
LABEL_6:
}

  if (v12) {
    free(v12);
  }
LABEL_6:

  return v5;
}

  if (v12) {
    free(v12);
  }
LABEL_6:

  return v5;
}

LABEL_24:
    if (v18) {
      free(v18);
    }
LABEL_7:
    char v13 = 0LL;
    goto LABEL_8;
  }

  char v13 = v12;
  memcpy(__dst, a3, 0xD60uLL);
  -[NWConnectionStatistics setReport:](v13, "setReport:", __dst);
  -[NWConnectionStatistics setClientIdentifier:](v13, "setClientIdentifier:", v10);
  -[NWConnectionStatistics setSourceIdentifier:](v13, "setSourceIdentifier:", v11);
  uint64_t v14 = objc_alloc_init(MEMORY[0x189603F18]);
  -[NWConnectionStatistics setExternallyVisibleActivityUUIDs:](v13, "setExternallyVisibleActivityUUIDs:", v14);

  -[NWConnectionStatistics setExternallyVisibleConnectionUUID:](v13, "setExternallyVisibleConnectionUUID:", 0LL);
  -[NWConnectionStatistics setExternallyVisibleParentUUID:](v13, "setExternallyVisibleParentUUID:", 0LL);
LABEL_8:

  return v13;
}

  if (v12) {
    free(v12);
  }
LABEL_6:

  return v5;
}

    uint64_t v6 = 0LL;
  }
  }
  }
  }

    goto LABEL_24;
  }

  int v4 = v3;
LABEL_4:
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = v4;
  uint64_t v7 = v5;
  if (!v7)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_http_fields_enumerate_modern_header_fields";
    os_log_type_t v10 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v10);
  }

  _nw_http_fields_enumerate_modern_header_fields((uint64_t)v6, v7);

  return 1LL;
}

    goto LABEL_24;
  }

  int v4 = v3;
LABEL_4:
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = v4;
  uint64_t v7 = v5;
  if (!v7)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_http_fields_enumerate_modern_header_fields_combined";
    os_log_type_t v10 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v10);
  }

  _nw_http_fields_enumerate_modern_header_fields_combined((uint64_t)v6, v7);

  return 1LL;
}

    free(backtrace_string);
    goto LABEL_33;
  }

  uint64_t v6 = (os_log_s *)__nwlog_obj();
  uint64_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_parallel_array_copy";
    os_log_type_t v8 = "%{public}s called with null parray";
LABEL_32:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
  }

  if (v7) {
    free(v7);
  }
LABEL_6:
}

    if (v8) {
      free(v8);
    }
    goto LABEL_25;
  }

  id v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if (mode != 2)
  {
LABEL_25:
    uint64_t v6 = 0LL;
    goto LABEL_26;
  }

  uint64_t v5 = nw_endpoint_handler_copy_flow(v3);
  uint64_t v6 = (*((_DWORD *)v5 + 225) & 0x80000000) == 0 || *((void *)v5 + 113) != 0LL;

LABEL_26:
  return v6;
}

      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 22);
      return 2LL;
    }

    if (a2[1] != 2)
    {
      if (!a2[1])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v4 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
          _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s Received hello. Doing SOCKSv5 with no authentication",  buf,  0xCu);
        }

        nw_socksv5_send_connect(*(nw_framer **)(a1 + 32), *(void *)(a1 + 40));
        return 2LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v16 = a2[1];
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        int v9 = "%{public}s Received invalid SOCKS method %d";
        goto LABEL_22;
      }

      goto LABEL_23;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s Received hello. Doing SOCKSv5 with username/password authentication",  buf,  0xCu);
    }

    BOOL v11 = *(nw_framer **)(a1 + 32);
    if (v11)
    {
      os_log_type_t v12 = *(void *)(a1 + 40);
      os_log_type_t v62 = 0u;
      memset(v63, 0, sizeof(v63));
      v60 = 0u;
      char v61 = 0u;
      uint64_t v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      uint64_t v57 = 0u;
      uint64_t v54 = 0u;
      v55 = 0u;
      os_log_type_t v52 = 0u;
      os_log_type_t v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v49 = 0u;
      v48 = 0u;
      v47 = 0u;
      v46 = 0u;
      v45 = 0u;
      BOOL v44 = 0u;
      os_log_type_t v43 = 0u;
      uint64_t v42 = 0u;
      BOOL v41 = 0u;
      __int16 v40 = 0u;
      v39 = 0u;
      v38 = 0u;
      uint64_t v37 = 0u;
      char v36 = 0u;
      __int16 v35 = 0u;
      memset(&buf[2], 0, 32);
      buf[0] = 1;
      if (*(void *)v12)
      {
        length = xpc_string_get_length(*(xpc_object_t *)v12);
        uint64_t v14 = *(void **)(v12 + 8);
        if (v14)
        {
LABEL_19:
          char v15 = xpc_string_get_length(v14);
LABEL_28:
          if (length >= 0xFE) {
            os_log_type_t v18 = 254LL;
          }
          else {
            os_log_type_t v18 = length;
          }
          if (v15 >= 0xFE) {
            uint64_t v19 = 254LL;
          }
          else {
            uint64_t v19 = v15;
          }
          buf[1] = v18;
          if (v18)
          {
            string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)v12);
            strncpy(&buf[2], string_ptr, v18);
          }

          buf[v18 + 2] = v19;
          if (v19)
          {
            uint64_t v21 = xpc_string_get_string_ptr(*(xpc_object_t *)(v12 + 8));
            strncpy(&buf[v18 + 3], v21, v19);
          }

          uint64_t v22 = length - 255;
          if (length >= 0xFF) {
            uint64_t v22 = -1LL;
          }
          os_log_type_t v23 = v15 - 255;
          if (v15 >= 0xFF) {
            os_log_type_t v23 = -1LL;
          }
          nw_framer_write_output(v11, buf, v22 + v23 + 513);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v24 = (os_log_s *)gLogObj;
          uint64_t v6 = 2LL;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t v32 = 136446210;
            uint64_t v33 = "nw_socksv5_send_auth";
            _os_log_impl(&dword_181A5C000, v24, OS_LOG_TYPE_DEBUG, "%{public}s Sent client auth", v32, 0xCu);
          }

          *(_DWORD *)(v12 + 16) = 2;
          return v6;
        }
      }

      else
      {
        length = 0LL;
        uint64_t v14 = *(void **)(v12 + 8);
        if (v14) {
          goto LABEL_19;
        }
      }

      char v15 = 0LL;
      goto LABEL_28;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();
    v32[0] = 16;
    BOOL v31 = 0;
    if (__nwlog_fault(v25, v32, &v31))
    {
      if (v32[0] == 17)
      {
        char v26 = (os_log_s *)__nwlog_obj();
        unint64_t v27 = v32[0];
        if (!os_log_type_enabled(v26, (os_log_type_t)v32[0])) {
          goto LABEL_59;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
        BOOL v28 = "%{public}s called with null framer";
        goto LABEL_58;
      }

      if (!v31)
      {
        char v26 = (os_log_s *)__nwlog_obj();
        unint64_t v27 = v32[0];
        if (!os_log_type_enabled(v26, (os_log_type_t)v32[0])) {
          goto LABEL_59;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
        BOOL v28 = "%{public}s called with null framer, backtrace limit exceeded";
        goto LABEL_58;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v26 = (os_log_s *)__nwlog_obj();
      unint64_t v27 = v32[0];
      uint64_t v30 = os_log_type_enabled(v26, (os_log_type_t)v32[0]);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_59;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
        BOOL v28 = "%{public}s called with null framer, no backtrace";
LABEL_58:
        _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
      }
    }

LABEL_24:
    if (v19) {
      free(v19);
    }
    goto LABEL_7;
  }

  objc_storeStrong((id *)&v9->_endpoint, a3);
  objc_storeStrong((id *)&v10->_parameters, a4);
  [v7 internalEndpoint];
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  [v8 internalParameters];
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  char v13 = nw_resolver_create_with_endpoint(v11, v12);
  internalResolver = v10->_internalResolver;
  v10->_internalResolver = (OS_nw_resolver *)v13;

  if (!v10->_internalResolver)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v16 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v29 = "-[NWResolver initWithEndpoint:parameters:]";
      uint64_t v30 = 2114;
      BOOL v31 = (char *)v7;
      uint64_t v32 = 2114;
      uint64_t v33 = v8;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s nw_resolver_create_with_endpoint failed with endpoint %{public}@ and parameters %{public}@",  buf,  0x20u);
    }

LABEL_7:
    char v15 = 0LL;
    goto LABEL_8;
  }

  -[NWResolver setUpdateHandler](v10, "setUpdateHandler");
  char v15 = v10;
LABEL_8:

  return v15;
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  if (v7) {
    free(v7);
  }
LABEL_6:
}

  uint64_t v14 = nw_parameters_copy_context(v13);
  char v15 = nw_path_copy_flow_registration(v14, (uint64_t)a1);
  if (v15)
  {
    os_log_type_t v16 = v15;
    stats_region = (nw_protocol_identifier *)nw_path_flow_registration_get_stats_region( v15,  (uint64_t)a1->identifier->name);
    a1[2].identifier = stats_region;
    if (!stats_region)
    {
      if ((BYTE6(a1[3].output_handler_context) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v80 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_connected";
            v86 = 2082;
            v87 = (char *)&a1[3].output_handler_context + 7;
            v88 = 2080;
            v89 = " ";
            v90 = 2048;
            p_output_handler = (char *)&a1[1].output_handler;
            v92 = 2048;
            v93 = &g_ip6_stats;
            _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p ipv6->ip6_stats is NULL setting to global %p",  buf,  0x34u);
          }
        }
      }

      a1[2].identifier = (nw_protocol_identifier *)&g_ip6_stats;
    }

    os_release(v16);
  }

  if (v14) {
    os_release(v14);
  }
  *(void *)buf = 0LL;
  output_handler = a1->output_handler;
  if (output_handler)
  {
    uint64_t v19 = output_handler->callbacks;
    if (v19)
    {
      get_message_properties = (void (*)(nw_protocol *, nw_protocol *, _BYTE *))v19->get_message_properties;
      if (get_message_properties)
      {
        uint64_t v21 = output_handler->handle;
        if (v21 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v22 = output_handler[1].callbacks;
          if (v22) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v22->add_input_handler + 1);
          }
        }

        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v29 = a1[1].callbacks;
          if (v29) {
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v29->add_input_handler + 1);
          }
          get_message_properties(output_handler, a1, buf);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v47 = a1[1].callbacks;
            if (v47)
            {
              v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
              a1[1].callbacks = v48;
              if (!v48)
              {
                v49 = *(void (***)(void))a1[1].flow_id;
                if (v49)
                {
                  *(void *)a1[1].flow_id = 0LL;
                  v49[2](v49);
                  _Block_release(v49);
                }

                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v50 = *(const void **)a1[1].flow_id;
                  if (v50) {
                    _Block_release(v50);
                  }
                }

                free(a1);
              }
            }
          }
        }

        else
        {
          get_message_properties(output_handler, a1, buf);
        }

        if (v21 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v51 = output_handler[1].callbacks;
          if (v51)
          {
            os_log_type_t v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
            output_handler[1].callbacks = v52;
            if (!v52)
            {
              os_log_type_t v53 = *(void (***)(void))output_handler[1].flow_id;
              if (v53)
              {
                *(void *)output_handler[1].flow_id = 0LL;
                v53[2](v53);
                _Block_release(v53);
              }

              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                uint64_t v54 = *(const void **)output_handler[1].flow_id;
                if (v54) {
                  _Block_release(v54);
                }
              }

              free(output_handler);
            }
          }
        }
      }
    }
  }

  default_input_handler = a1->default_input_handler;
  if (!default_input_handler) {
    return;
  }
  uint64_t v30 = default_input_handler->callbacks;
  if (!v30) {
    return;
  }
  BOOL v31 = (void (*)(nw_protocol *, nw_protocol *))v30->connected;
  if (!v31) {
    return;
  }
  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v32 = default_input_handler[1].callbacks;
    if (v32) {
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
    }
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    v31(default_input_handler, a1);
    goto LABEL_77;
  }

  uint64_t v33 = a1[1].callbacks;
  if (v33) {
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v33->add_input_handler + 1);
  }
  v31(default_input_handler, a1);
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v34 = a1[1].callbacks;
    if (v34)
    {
      __int16 v35 = (nw_protocol_callbacks *)((char *)v34 - 1);
      a1[1].callbacks = v35;
      if (!v35)
      {
        char v36 = *(void (***)(void))a1[1].flow_id;
        if (v36)
        {
          *(void *)a1[1].flow_id = 0LL;
          v36[2](v36);
          _Block_release(v36);
        }

        if ((a1[1].flow_id[8] & 1) != 0)
        {
          uint64_t v37 = *(const void **)a1[1].flow_id;
          if (v37) {
            _Block_release(v37);
          }
        }

        BOOL v28 = a1;
        goto LABEL_76;
      }
    }
  }

      os_log_type_t v12 = 0LL;
      goto LABEL_24;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    uint64_t v32 = "-[NWPathEvaluator initWithEndpoint:parameters:]";
    uint64_t v33 = 2114;
    BOOL v34 = v8;
    os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v29 = 0;
    if (!__nwlog_fault((const char *)v16, &type, &v29))
    {
LABEL_21:
      if (v16) {
        free(v16);
      }
      goto LABEL_23;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v32 = "-[NWPathEvaluator initWithEndpoint:parameters:]";
        uint64_t v33 = 2114;
        BOOL v34 = v8;
        uint64_t v19 = "%{public}s [%{public}@ copy] failed";
LABEL_18:
        char v26 = v17;
        unint64_t v27 = v18;
LABEL_19:
        _os_log_impl(&dword_181A5C000, v26, v27, v19, buf, 0x16u);
      }
    }

    else
    {
      if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v17 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v32 = "-[NWPathEvaluator initWithEndpoint:parameters:]";
            uint64_t v33 = 2114;
            BOOL v34 = v8;
            __int16 v35 = 2082;
            char v36 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s [%{public}@ copy] failed, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (!v25) {
          goto LABEL_20;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v32 = "-[NWPathEvaluator initWithEndpoint:parameters:]";
        uint64_t v33 = 2114;
        BOOL v34 = v8;
        uint64_t v19 = "%{public}s [%{public}@ copy] failed, no backtrace";
        char v26 = v17;
        unint64_t v27 = v24;
        goto LABEL_19;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (os_log_s *)(id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v32 = "-[NWPathEvaluator initWithEndpoint:parameters:]";
        uint64_t v33 = 2114;
        BOOL v34 = v8;
        uint64_t v19 = "%{public}s [%{public}@ copy] failed, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

    if (!v9)
    {
LABEL_25:
      uint64_t v14 = 0LL;
      goto LABEL_26;
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_24;
  }

  BOOL v11 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v11);
  os_log_type_t v12 = (os_log_s *)gLogObj;
  char v13 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_settings_add_settings_from_bitmask";
    uint64_t v14 = "%{public}s xpc_dictionary_create failed";
    goto LABEL_23;
  }

void nw_release(void *obj)
{
  if (obj) {
    os_release(obj);
  }
}

BOOL nw_context_create(const char *a1)
{
  return -[NWConcrete_nw_context initWithIdentifier:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_context), a1);
}

LABEL_38:
    if (v7) {
      free(v7);
    }

    return 0LL;
  }

  v24.receiver = a1;
  v24.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_context;
  uint64_t v2 = objc_msgSendSuper2(&v24, sel_init);
  if (!v2)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "-[NWConcrete_nw_context initWithIdentifier:]";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v25 = 0;
    if (__nwlog_fault(v11, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "-[NWConcrete_nw_context initWithIdentifier:]";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v25)
      {
        uint64_t v19 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v20 = type;
        uint64_t v21 = os_log_type_enabled(v12, type);
        if (v19)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v28 = "-[NWConcrete_nw_context initWithIdentifier:]";
            os_log_type_t v29 = 2082;
            uint64_t v30 = v19;
            _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v19);
          goto LABEL_44;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "-[NWConcrete_nw_context initWithIdentifier:]";
          _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "-[NWConcrete_nw_context initWithIdentifier:]";
          _os_log_impl( &dword_181A5C000,  v12,  v23,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v17) {
    free(v17);
  }
LABEL_20:
}

    goto LABEL_39;
  }

  if (v4)
  {
    if (v3[20])
    {
      v20[0] = MEMORY[0x1895F87A8];
      v20[1] = 3221225472LL;
      v20[2] = __nw_endpoint_enumerate_alternatives_block_invoke;
      v20[3] = &unk_189BC91E8;
      uint64_t v21 = v3;
      uint64_t v22 = v5;
      nw_endpoint_locked(v21, v20);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_endpoint_enumerate_alternatives";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v24 = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null enumerate_block", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null enumerate_block, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = v24;
  __int16 v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_endpoint_enumerate_alternatives";
    unint64_t v27 = 2082;
    BOOL v28 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null enumerate_block, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v17 = type;
      os_log_type_t v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v24 = "nw_context_copy_registered_endpoint";
        BOOL v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_context_copy_registered_endpoint";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null context", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      os_log_type_t v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v24 = "nw_context_copy_registered_endpoint";
        BOOL v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
      }

          free(v36);
          goto LABEL_39;
        }

        __nwlog_obj();
        uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v37, type))
        {
          v79 = nw_endpoint_get_logging_description(v30);
          *(_DWORD *)v120 = 136446722;
          *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v120[12] = 2114;
          *(void *)&v120[14] = v16;
          *(_WORD *)&v120[22] = 2082;
          v121 = v79;
          _os_log_impl( &dword_181A5C000,  v37,  v78,  "%{public}s %{public}@ failed to add endpoint %{public}s, no backtrace",  v120,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v37 = (os_log_s *)(id)gLogObj;
        v73 = type;
        if (os_log_type_enabled(v37, type))
        {
          v74 = nw_endpoint_get_logging_description(v30);
          *(_DWORD *)v120 = 136446722;
          *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v120[12] = 2114;
          *(void *)&v120[14] = v16;
          *(_WORD *)&v120[22] = 2082;
          v121 = v74;
          _os_log_impl( &dword_181A5C000,  v37,  v73,  "%{public}s %{public}@ failed to add endpoint %{public}s, backtrace limit exceeded",  v120,  0x20u);
        }
      }
    }

    if (!v36) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  BOOL v28 = *(void *)(node + 16);
  os_log_type_t v29 = nw_hash_table_get_node(v28, (uint64_t)v11, 0LL);
  if (!v29)
  {
    buf[0] = 0;
    v46 = v11;
    v47 = (void *)[v46 copyEndpoint];
    nw_endpoint_copy_properties(v46, v47);

    nw_endpoint_set_context(v47, v16);
    nw_endpoint_set_is_registered(v47);
    uint64_t v30 = v47;
    nw_hash_table_add_object(v28, (uint64_t)v30, (char *)buf);
    if (!buf[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = (id)gLogObj;
      v49 = nw_endpoint_get_logging_description(v30);
      *(_DWORD *)v120 = 136446722;
      *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
      *(_WORD *)&v120[12] = 2114;
      *(void *)&v120[14] = v16;
      *(_WORD *)&v120[22] = 2082;
      v121 = v49;
      v50 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v118 = 0;
      if (__nwlog_fault(v50, &type, &v118))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v51 = (os_log_s *)(id)gLogObj;
          os_log_type_t v52 = type;
          if (os_log_type_enabled(v51, type))
          {
            os_log_type_t v53 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446722;
            *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(void *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v53;
            _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s %{public}@ failed to add endpoint %{public}s",  v120,  0x20u);
          }
        }

        else if (v118)
        {
          uint64_t v69 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v70 = type;
          v71 = os_log_type_enabled(v51, type);
          if (v69)
          {
            if (v71)
            {
              v72 = nw_endpoint_get_logging_description(v30);
              *(_DWORD *)v120 = 136446978;
              *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
              *(_WORD *)&v120[12] = 2114;
              *(void *)&v120[14] = v16;
              *(_WORD *)&v120[22] = 2082;
              v121 = v72;
              LOWORD(v122[0]) = 2082;
              *(id *)((char *)v122 + 2) = v69;
              _os_log_impl( &dword_181A5C000,  v51,  v70,  "%{public}s %{public}@ failed to add endpoint %{public}s, dumping backtrace:%{public}s",  v120,  0x2Au);
            }

            free(v69);
            if (!v50) {
              goto LABEL_56;
            }
            goto LABEL_55;
          }

          if (v71)
          {
            v85 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446722;
            *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(void *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v85;
            _os_log_impl( &dword_181A5C000,  v51,  v70,  "%{public}s %{public}@ failed to add endpoint %{public}s, no backtrace",  v120,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v80 = type;
          if (os_log_type_enabled(v51, type))
          {
            v81 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446722;
            *(void *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(void *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v81;
            _os_log_impl( &dword_181A5C000,  v51,  v80,  "%{public}s %{public}@ failed to add endpoint %{public}s, backtrace limit exceeded",  v120,  0x20u);
          }
        }
      }

      if (v50) {
LABEL_55:
      }
        free(v50);
    }

      if (a2[1] != 30) {
        goto LABEL_43;
      }
      goto LABEL_39;
    }

    if (v6 == 16)
    {
      uint64_t v14 = 16;
      goto LABEL_43;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v29 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v53 = 0;
    if (__nwlog_fault(v30, &type, &v53))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v31 = (os_log_s *)(id)gLogObj;
        uint64_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
          _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s sockaddr_in too small", buf, 0xCu);
        }
      }

      else if (v53)
      {
        uint64_t v37 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v38 = type;
        v39 = os_log_type_enabled(v31, type);
        if (v37)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
            uint64_t v58 = 2082;
            *(void *)v59 = v37;
            _os_log_impl( &dword_181A5C000,  v31,  v38,  "%{public}s sockaddr_in too small, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v37);
          goto LABEL_83;
        }

        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
          _os_log_impl(&dword_181A5C000, v31, v38, "%{public}s sockaddr_in too small, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
          _os_log_impl( &dword_181A5C000,  v31,  v43,  "%{public}s sockaddr_in too small, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        goto LABEL_39;
      }

      if (!v28)
      {
        __nwlog_obj();
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v27 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl( &dword_181A5C000,  v17,  v27,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_181A5C000, v17, v24, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v31 = "nw_path_evaluator_set_update_handler";
        uint64_t v32 = 2082;
        uint64_t v33 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v31 = "nw_path_evaluator_set_update_handler";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v28 = 0;
    if (__nwlog_fault(v16, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null evaluator", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v28)
      {
        __nwlog_obj();
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s called with null evaluator, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      os_log_type_t v23 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v31 = "nw_path_evaluator_set_update_handler";
        uint64_t v32 = 2082;
        uint64_t v33 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null evaluator, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v30)
      {
        __nwlog_obj();
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unint64_t v27 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_resolver_set_update_handler";
          _os_log_impl( &dword_181A5C000,  v17,  v27,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_resolver_set_update_handler";
          _os_log_impl(&dword_181A5C000, v17, v24, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v33 = "nw_resolver_set_update_handler";
        BOOL v34 = 2082;
        __int16 v35 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v33 = "nw_resolver_set_update_handler";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v30 = 0;
    if (__nwlog_fault(v16, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_resolver_set_update_handler";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null resolver", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v30)
      {
        __nwlog_obj();
        __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_resolver_set_update_handler";
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      os_log_type_t v23 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_resolver_set_update_handler";
          _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v33 = "nw_resolver_set_update_handler";
        BOOL v34 = 2082;
        __int16 v35 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    goto LABEL_39;
  }

  if (v4)
  {
    nw_activity_activate(v4);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_connection_start_activity";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v20 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_connection_start_activity";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null activity", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v20)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_connection_start_activity";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null activity, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_connection_start_activity";
      _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null activity, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v23 = "nw_connection_start_activity";
    os_log_type_t v24 = 2082;
    BOOL v25 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null activity, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

  uint64_t v32 = 0LL;
LABEL_39:

LABEL_53:
  return v32;
}

  if (v15) {
    free(v15);
  }
  os_log_type_t v12 = 0LL;
LABEL_8:

  return v12;
}

    free(backtrace_string);
    goto LABEL_57;
  }

  if (!a2)
  {
    __nwlog_obj();
    char v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_parameters_copy_protocol_value";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_parameters_copy_protocol_value";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null protocol_instance", buf, 0xCu);
      }

      goto LABEL_56;
    }

    if (!v27)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_parameters_copy_protocol_value";
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null protocol_instance, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    uint64_t v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_parameters_copy_protocol_value";
        _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null protocol_instance, no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v30 = "nw_parameters_copy_protocol_value";
      BOOL v31 = 2082;
      uint64_t v32 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null protocol_instance, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_38;
  }

  if (a3)
  {
    uint64_t v7 = nw_parameters_copy_protocol_value_from_level(v5, 5, a2, a3);
    if (!v7)
    {
      uint64_t v7 = nw_parameters_copy_protocol_value_from_level(v6, 4, a2, a3);
      if (!v7)
      {
        uint64_t v7 = nw_parameters_copy_protocol_value_from_level(v6, 3, a2, a3);
        if (!v7) {
          uint64_t v7 = nw_parameters_copy_protocol_value_from_level(v6, 2, a2, a3);
        }
      }
    }

    goto LABEL_8;
  }

  __nwlog_obj();
  char v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v30 = "nw_parameters_copy_protocol_value";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unint64_t v27 = 0;
  if (__nwlog_fault(v10, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_parameters_copy_protocol_value";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null key", buf, 0xCu);
      }

      free(backtrace_string);
      goto LABEL_52;
    }

    if (!v27) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    uint64_t v22 = "%{public}s called with null input_protocol, no backtrace";
LABEL_51:
    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
LABEL_52:
    if (v19) {
      free(v19);
    }
    return 0LL;
  }

  BOOL v11 = ((unsigned __int16)handle[222] | (*((unsigned __int8 *)handle + 446) << 16)) & 0xFFF9FFFF | 0x20000;
  handle[222] = handle[222];
  *((_BYTE *)handle + 446) = BYTE2(v11);
  nw_channel_update_input_source((uint64_t)handle, (uint64_t)a2, 0);
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      *(_WORD *)&buf[12] = 1042;
      *(_DWORD *)&buf[14] = 16;
      *(_WORD *)&buf[18] = 2098;
      *(void *)&buf[20] = a2;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s Can't find hash table entry for %{public,uuid_t}.16P",  buf,  0x1Cu);
    }

    return 0LL;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(_DWORD *)&_BYTE buf[24] = 0;
  *(void *)&buf[16] = 0x2000000000LL;
  *(void *)os_log_type_t type = 0LL;
  v38 = type;
  __int16 v40 = 0;
  v39 = 0x2000000000LL;
  v28[0] = MEMORY[0x1895F87A8];
  v28[1] = 0x40000000LL;
  os_log_type_t v29 = ___ZL27nw_channel_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
  uint64_t v30 = &unk_189BC90F8;
  BOOL v31 = buf;
  uint64_t v32 = type;
  __int16 v35 = a5;
  char v36 = a4;
  uint64_t v33 = (char *)(output_handler_context + 4);
  BOOL v34 = a6;
  char v13 = output_handler_context[4];
  do
  {
    if (!v13) {
      break;
    }
    uint64_t v14 = *(void *)(v13 + 32);
    char v15 = ((uint64_t (*)(void *))v29)(v28);
    char v13 = v14;
  }

  while ((v15 & 1) != 0);
  os_log_type_t v16 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v16;
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v9 = (NWConcrete_nw_endpoint_mode_handler *)(id)gLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5) {
      uint64_t v30 = "unknown-mode";
    }
    else {
      uint64_t v30 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_update_connected_metadata";
    BOOL v34 = 2082;
    __int16 v35 = (char *)v30;
    char v36 = 2082;
    uint64_t v37 = "flow";
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

    if (v20) {
      free(v20);
    }
    goto LABEL_40;
  }

  BOOL v11 = (unsigned __int16)v9[161];
  if (v9[161])
  {
    os_log_type_t v12 = 0LL;
    if (a4)
    {
      char v13 = 0LL;
      uint64_t v14 = 0xFFFFFFFFLL;
      while (1)
      {
        os_log_type_t v16 = v10[39];
        if (*(unsigned __int16 *)(v16 + v12 + 10) == a3
          && *(unsigned __int16 *)(v16 + v12 + 8) == a2
          && (!*a4 || *(unsigned __int16 *)(v16 + v12 + 12) == (unsigned __int16)*a4))
        {
          char v15 = (a5 - 1);
          if (v15 >= 0xFFFFFFFE)
          {
            *a4 = *(_WORD *)(v16 + v12 + 12);
            uint64_t v14 = nw_delta_nanos(v10[9], *(void *)(v16 + v12)) / 0xF4240uLL;
            if ((_DWORD)a5 != -1) {
              goto LABEL_41;
            }
            BOOL v11 = *((unsigned __int16 *)v10 + 161);
            char v15 = 0xFFFFFFFFLL;
          }
        }

        else
        {
          char v15 = a5;
        }

        ++v13;
        v12 += 16LL;
        a5 = v15;
        if (v13 >= v11) {
          goto LABEL_41;
        }
      }
    }

    uint64_t v14 = 0xFFFFFFFFLL;
    while (1)
    {
      os_log_type_t v18 = v10[39];
      if (*(unsigned __int16 *)((char *)a4 + v18 + 10) == a3 && *(unsigned __int16 *)((char *)a4 + v18 + 8) == a2)
      {
        __int16 v17 = (a5 - 1);
        if (v17 >= 0xFFFFFFFE)
        {
          uint64_t v14 = nw_delta_nanos(v10[9], *(void *)((char *)a4 + v18)) / 0xF4240uLL;
          if ((_DWORD)a5 != -1) {
            goto LABEL_41;
          }
          BOOL v11 = *((unsigned __int16 *)v10 + 161);
          __int16 v17 = 0xFFFFFFFFLL;
        }
      }

      else
      {
        __int16 v17 = a5;
      }

      ++v12;
      a4 += 8;
      a5 = v17;
      if (v12 >= v11) {
        goto LABEL_41;
      }
    }
  }

    a1[1] = (unint64_t)v31;
    if (v17 != v16)
    {
      __int16 v35 = (void **)(v17 - 8);
      char v36 = 8 * (v18 >> 3);
      uint64_t v37 = v6 + 8 * v8 - 8;
      do
      {
        if (*v35) {
          os_release(*v35);
        }
        *v35-- = *(void **)(v37 + v36);
        *(void *)(v37 + v36) = 0LL;
        v36 -= 8LL;
      }

      while (v36);
    }

    if (*(void *)v9) {
      os_release(*(void **)v9);
    }
    *(void *)int v9 = v11;
    return;
  }

  os_log_type_t v12 = ((uint64_t)(v5 - v6) >> 3) + 1;
  if (v12 >> 61) {
    abort();
  }
  char v13 = v10 - v6;
  if (v13 >> 2 > v12) {
    os_log_type_t v12 = v13 >> 2;
  }
  else {
    uint64_t v14 = v12;
  }
  if (v14)
  {
    if (v14 >> 61) {
      goto LABEL_85;
    }
    char v15 = (char *)operator new(8 * v14);
  }

  else
  {
    char v15 = 0LL;
  }

  uint64_t v32 = &v15[8 * v8];
  uint64_t v33 = &v15[8 * v14];
  if (v8 != v14) {
    goto LABEL_52;
  }
  if ((uint64_t)(v7 & 0xFFFFFFFFFFFFFFF8LL) >= 1)
  {
    BOOL v34 = v8 + 2;
    if (v8 >= -1) {
      BOOL v34 = v8 + 1;
    }
    v32 -= 8 * (v34 >> 1);
    goto LABEL_52;
  }

  else {
    v38 = (v7 >> 2) & 0xFFFFFFFFFFFFFFFELL;
  }
  if (v38 >> 61) {
LABEL_85:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  v39 = 8 * v38;
  __int16 v40 = (char *)operator new(8 * v38);
  uint64_t v32 = &v40[8 * (v38 >> 2)];
  uint64_t v33 = &v40[v39];
  if (v15) {
    operator delete(v15);
  }
LABEL_52:
  BOOL v41 = *a3;
  if (*a3) {
    BOOL v41 = os_retain(v41);
  }
  *(void *)uint64_t v32 = v41;
  uint64_t v42 = v32 + 8;
  os_log_type_t v43 = (void *)*a1;
  BOOL v44 = v32;
  if (*a1 != v9)
  {
    v45 = (v7 & 0xFFFFFFFFFFFFFFF8LL) + v6 - (void)v43 - 8;
    v46 = (void *)v9;
    BOOL v44 = v32;
    if (v45 < 0x88) {
      goto LABEL_88;
    }
    if ((unint64_t)&v32[-(v45 & 0xFFFFFFFFFFFFFFF8LL) - 8] < v9)
    {
      v46 = (void *)v9;
      BOOL v44 = v32;
    }

    v47 = (v45 >> 3) + 1;
    v46 = (void *)(v9 - 8 * (v47 & 0x3FFFFFFFFFFFFFFCLL));
    v48 = v32 - 16;
    v49 = (_OWORD *)(v6 + 8 * v8 - 32);
    v50 = v47 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v51 = v49[1];
      *((_OWORD *)v48 - 1) = *v49;
      *(_OWORD *)v48 = v51;
      const char *v49 = 0uLL;
      v49[1] = 0uLL;
      v49 -= 2;
      v48 -= 32;
      v50 -= 4LL;
    }

    while (v50);
    BOOL v44 = &v32[-8 * (v47 & 0x3FFFFFFFFFFFFFFCLL)];
    if (v47 != (v47 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_88:
      do
      {
        os_log_type_t v52 = *--v46;
        *((void *)v44 - 1) = v52;
        v44 -= 8;
        os_log_s *v46 = 0LL;
      }

      while (v46 != v43);
    }
  }

  os_log_type_t v53 = (void *)a1[1];
  if (v53 == (void *)v9) {
    goto LABEL_75;
  }
  uint64_t v54 = (v7 & 0xFFFFFFFFFFFFFFF8LL) + v6;
  v55 = (unint64_t)v53 - v54 - 8;
  if (v55 >= 0x88)
  {
    if ((unint64_t)v42 >= v54 + (v55 & 0xFFFFFFFFFFFFFFF8LL) + 8
      || v9 >= (unint64_t)v42 + (v55 & 0xFFFFFFFFFFFFFFF8LL) + 8)
    {
      uint64_t v58 = (v55 >> 3) + 1;
      v59 = 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
      v56 = (void *)(v9 + v59);
      v60 = v32 + 24;
      char v61 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        os_log_type_t v62 = *(_OWORD *)(v9 + 16);
        *(v60 - 1) = *(_OWORD *)v9;
        os_unfair_lock_s *v60 = v62;
        *(_OWORD *)int v9 = 0uLL;
        *(_OWORD *)(v9 + 16) = 0uLL;
        v9 += 32LL;
        v60 += 2;
        v61 -= 4LL;
      }

      while (v61);
      uint64_t v42 = (void *)((char *)v42 + v59);
      if (v58 == (v58 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_74;
      }
    }

    else
    {
      v56 = (void *)v9;
    }
  }

  else
  {
    v56 = (void *)v9;
  }

  do
  {
    *v42++ = *v56;
    *v56++ = 0LL;
  }

  while (v56 != v53);
LABEL_74:
  int v9 = a1[1];
LABEL_75:
  v63 = *a1;
  *a1 = (unint64_t)v44;
  a1[1] = (unint64_t)v42;
  a1[2] = (unint64_t)v33;
  if (v9 != v63)
  {
    char v64 = v9;
    do
    {
      v66 = *(void **)(v64 - 8);
      v64 -= 8LL;
      v65 = v66;
      if (v66) {
        os_release(v65);
      }
      *(void *)(v9 - 8) = 0LL;
      int v9 = v64;
    }

    while (v64 != v63);
    int v9 = v63;
  }

  if (v9) {
    operator delete((void *)v9);
  }
}

    goto LABEL_39;
  }

  if (v4)
  {
    nw_activity_activate(v4);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_connection_end_activity";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v20 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_connection_end_activity";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null activity", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v20)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_connection_end_activity";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null activity, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_connection_end_activity";
      _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null activity, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v23 = "nw_connection_end_activity";
    os_log_type_t v24 = 2082;
    BOOL v25 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null activity, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v22 = *(void *)(v4 + 88);
    if (v22)
    {
      os_log_type_t v23 = v22 - 1;
      *(void *)(v4 + 88) = v23;
      if (!v23)
      {
        os_log_type_t v24 = *(void (***)(void))(v4 + 64);
        if (v24)
        {
          *(void *)(v4 + 64) = 0LL;
          v24[2](v24);
          _Block_release(v24);
        }

        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          BOOL v25 = *(const void **)(v4 + 64);
          if (v25) {
            _Block_release(v25);
          }
        }

        char v26 = (char *)v4;
        goto LABEL_78;
      }
    }
  }

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (unsigned __int8 *)v3[15];
    if (v6)
    {
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_endpoint_enumerate_cnames_block_invoke;
      v21[3] = &unk_189BC8628;
      uint64_t v22 = v4;
      nw_array_apply(v6, (uint64_t)v21);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_endpoint_enumerate_cnames";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_endpoint_enumerate_cnames";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerate_block", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_endpoint_enumerate_cnames";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerate_block, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_endpoint_enumerate_cnames";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_endpoint_enumerate_cnames";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerate_block, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (v6 || !v7)
  {
    nw_data_transfer_report_collect_inner(v5, v6, v7, 0);
    goto LABEL_5;
  }

  __nwlog_obj();
  char v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_data_transfer_report_collect";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null queue", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_181A5C000, v11, v22, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v18 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_181A5C000, v11, v19, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_data_transfer_report_collect";
    unint64_t v27 = 2082;
    BOOL v28 = v18;
    _os_log_impl( &dword_181A5C000,  v11,  v19,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_40;
  }
LABEL_5:
}

          LOBYTE(v10) = 0;
          LODWORD(v5) = 1;
          goto LABEL_41;
        }

  if (v13) {
    free(v13);
  }
  id v3 = 0LL;
LABEL_8:

  return v3;
}

    free(backtrace_string);
    goto LABEL_52;
  }

  int v9 = (os_log_s *)__nwlog_obj();
  os_log_type_t v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_protocol_shoes_get_path";
    BOOL v11 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_51;
  }

      free(v13);
      goto LABEL_39;
    }

    if (!v26)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v29 = "+[NWAddressEndpoint endpointWithHostname:port:]";
        uint64_t v30 = 2114;
        BOOL v31 = (char *)v5;
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s NWAddressEndpoint created with non-address hostname %{public}@, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)(id)gLogObj;
    uint64_t v21 = type;
    uint64_t v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v29 = "+[NWAddressEndpoint endpointWithHostname:port:]";
        uint64_t v30 = 2114;
        BOOL v31 = (char *)v5;
        _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s NWAddressEndpoint created with non-address hostname %{public}@, no backtrace",  buf,  0x16u);
      }

      goto LABEL_36;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v29 = "+[NWAddressEndpoint endpointWithHostname:port:]";
      uint64_t v30 = 2114;
      BOOL v31 = (char *)v5;
      uint64_t v32 = 2082;
      uint64_t v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s NWAddressEndpoint created with non-address hostname %{public}@, dumping backtrace:%{public}s",  buf,  0x20u);
    }

      free(v9);
      goto LABEL_39;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "+[NWAddressEndpoint endpointWithAddress:]";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s NWAddressEndpoint sockaddr created a non-address endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    __int16 v17 = type;
    os_log_type_t v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "+[NWAddressEndpoint endpointWithAddress:]";
        _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s NWAddressEndpoint sockaddr created a non-address endpoint, no backtrace",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "+[NWAddressEndpoint endpointWithAddress:]";
      char v26 = 2082;
      unint64_t v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s NWAddressEndpoint sockaddr created a non-address endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_39;
  }

  if (!v4 || (v6 = v4, uint64_t v7 = [v6 type], v6, v7 == 3))
  {
    objc_storeStrong(v3 + 5, a2);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v25 = "nw_candidate_manager_set_bonjour_service";
  int v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v22 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_candidate_manager_set_bonjour_service";
      _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service)",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  if (!v22)
  {
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_candidate_manager_set_bonjour_service";
      _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service), backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  __int16 v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v18 = type;
  uint64_t v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_candidate_manager_set_bonjour_service";
      _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service), no backtrace",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v25 = "nw_candidate_manager_set_bonjour_service";
    char v26 = 2082;
    unint64_t v27 = v17;
    _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service), dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v17);
  if (v9) {
    goto LABEL_40;
  }
LABEL_5:
}

            nw_protocol_common_disconnected((uint64_t)a1, (uint64_t)a2);
            return;
          }

          if (gLogDatapath)
          {
            v39 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_retry_disconnected";
              _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s holding onto disconnected because reissuing",  buf,  0xCu);
              os_log_type_t v10 = 0;
              goto LABEL_23;
            }
          }

    goto LABEL_39;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  BOOL v31 = 0;
  v25[0] = MEMORY[0x1895F87A8];
  v25[1] = 3221225472LL;
  v25[2] = ___ZL54nw_protocol_instance_registrar_array_contains_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke;
  v25[3] = &unk_189BC7960;
  os_log_type_t v8 = v6;
  char v26 = v8;
  unint64_t v27 = buf;
  nw_array_apply((unsigned __int8 *)v5, (uint64_t)v25);
  int v9 = *(_BYTE *)(*(void *)&buf[8] + 24LL) == 0;

  _Block_object_dispose(buf, 8);
  if (v9) {
LABEL_4:
  }
    nw_array_append(*(void *)(a1 + 32), v7);

  return 1LL;
}

      free(backtrace_string);
    }

LABEL_39:
      if (v9) {
        free(v9);
      }
      goto LABEL_41;
    }

    if (!v21)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = type;
    os_log_type_t v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v24 = "nw_framer_connection_state_copy_object_value";
      BOOL v25 = 2082;
      char v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_57;
  }

  uint64_t v5 = v3;
  uint64_t v6 = *((id *)v5 + 1);

  is_framer = nw_protocol_definition_is_framer(v6);
  if ((is_framer & 1) == 0)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message)",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (!v31)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    os_log_type_t v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl( &dword_181A5C000,  v14,  v23,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), no backtrace",  buf,  0xCu);
      }

      goto LABEL_56;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v23,  "%{public}s called with null nw_protocol_metadata_is_framer_message(message), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_38;
  }

  if (key)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    BOOL v34 = __Block_byref_object_copy__4444;
    __int16 v35 = __Block_byref_object_dispose__4445;
    char v36 = 0LL;
    v30[0] = MEMORY[0x1895F87A8];
    v30[1] = 3221225472LL;
    v30[2] = __nw_framer_message_copy_object_value_block_invoke;
    v30[3] = &unk_189BC6510;
    v30[4] = buf;
    v30[5] = key;
    os_log_type_t v8 = *((void *)v5 + 4);
    if (v8)
    {
      __nw_framer_message_copy_object_value_block_invoke((uint64_t)v30, v8);
      int v9 = *(void **)(*(void *)&buf[8] + 40LL);
    }

    else
    {
      int v9 = 0LL;
    }

    os_log_type_t v10 = v9;
    _Block_object_dispose(buf, 8);

    goto LABEL_8;
  }

  __nwlog_obj();
  os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
  char v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v31 = 0;
  if (__nwlog_fault(v13, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_framer_message_copy_object_value";
        _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null key", buf, 0xCu);
      }

    free(backtrace_string);
    goto LABEL_51;
  }

  id v3 = v1;
  do
  {
    int v4 = v3;
    uint64_t v5 = [v4 type];

    if (v5 == 2)
    {
      uint64_t v6 = v4;
      uint64_t v7 = (const char *)[v6 hostname];
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    id v3 = v4[14];
  }

  while (!v7 && v3);

  if (!v7) {
    goto LABEL_16;
  }
  os_log_type_t v8 = strlen(v2[11]);
  int v9 = strlen(v7);
  if (v9)
  {
    os_log_type_t v10 = v9 - 1;
    if (v7[v9 - 1] != 46) {
      os_log_type_t v10 = v9;
    }
    BOOL v11 = v10 >= v8;
    os_log_type_t v12 = v10 - v8;
    if (!v11) {
      goto LABEL_16;
    }
LABEL_17:
    char v13 = strncmp(&v7[v12], v2[11], v8) == 0;
    goto LABEL_18;
  }

  os_log_type_t v12 = -(uint64_t)v8;
  if (!v8) {
    goto LABEL_17;
  }
LABEL_16:
  char v13 = 0LL;
LABEL_18:

  return v13;
}

      free(v24);
    }
  }

    free(v24);
    goto LABEL_39;
  }

  __nwlog_obj();
  v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v83 = "strict_strdup";
  uint64_t v57 = (void *)_os_log_send_and_compose_impl();

  BOOL result = (id)__nwlog_abort((uint64_t)v57);
  if (!(_DWORD)result)
  {
    free(v57);
    goto LABEL_7;
  }

  __break(1u);
  return result;
}

        goto LABEL_39;
      }

      if (!v24)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type[0];
      __int16 v17 = os_log_type_enabled(v9, type[0]);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
          _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (__nwlog_fault(v8, type, &v24))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null group", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v24)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type[0];
      char v15 = os_log_type_enabled(v9, type[0]);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null group, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_has_connection_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
      }

  return v9;
}

        free(backtrace_string);
        if (!v11) {
          goto LABEL_53;
        }
        goto LABEL_52;
      }

      if (*(_DWORD *)(*((void *)v6 + 1) + 64LL) == 3)
      {
        uint64_t v14 = (char *)*((void *)v6 + 29);
        if (a2 == -1)
        {
          v49[0] = MEMORY[0x1895F87A8];
          v49[1] = 3221225472LL;
          v49[2] = __nw_protocol_instance_update_outbound_data_limit_block_invoke;
          v49[3] = &unk_189BB75D8;
          os_log_type_t v52 = a3;
          v51 = -1LL;
          v50 = v6;
          nw_hash_table_apply(v14, (uint64_t)v49);

          goto LABEL_53;
        }

        node = nw_hash_table_get_node(*((void *)v6 + 29), a2, 8LL);
        if (!node)
        {
          if ((v6[405] & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            unint64_t v27 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446978;
              v56 = "nw_protocol_instance_update_outbound_data_limit";
              uint64_t v57 = 2082;
              *(void *)uint64_t v58 = v6 + 407;
              *(_WORD *)&v58[8] = 2080;
              *(void *)v59 = " ";
              *(_WORD *)&v59[8] = 2048;
              v60 = a2;
              _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sCannot set outbound data limit, flow %llx does not exist",  buf,  0x2Au);
            }
          }

          goto LABEL_53;
        }

        os_log_type_t v16 = *(void *)(node + 16);
        if (gLogDatapath)
        {
          v45 = node;
          __nwlog_obj();
          v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            v47 = *(_DWORD *)(v45 + 72);
            *(_DWORD *)buf = 136446978;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            uint64_t v57 = 1024;
            *(_DWORD *)uint64_t v58 = v47;
            *(_WORD *)&v58[4] = 1024;
            *(_DWORD *)&v58[6] = a3;
            *(_WORD *)v59 = 2048;
            *(void *)&v59[2] = a2;
            _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s Increase current outbound data limit %u to %u bytes for flow %llx",  buf,  0x22u);
          }

          node = v45;
          *(_DWORD *)(v45 + 72) = a3;
          if (!a3) {
            goto LABEL_53;
          }
        }

        else
        {
          *(_DWORD *)(node + 72) = a3;
          if (!a3) {
            goto LABEL_53;
          }
        }

        __int16 v17 = *(_WORD *)(node + 84);
        if ((v17 & 0x180) != 0x80 || v16 == 0) {
          goto LABEL_53;
        }
        uint64_t v19 = *(void *)(v16 + 24);
        if (!v19 || !*(void *)(v19 + 72)) {
          goto LABEL_53;
        }
        *(_WORD *)(node + 84) = v17 | 0x100;
        BOOL v20 = v6[405];
        goto LABEL_33;
      }

      if (a2 == -1)
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            __int16 v40 = *((_DWORD *)v6 + 26);
            *(_DWORD *)buf = 136446722;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            uint64_t v57 = 1024;
            *(_DWORD *)uint64_t v58 = v40;
            *(_WORD *)&v58[4] = 1024;
            *(_DWORD *)&v58[6] = a3;
            _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_DEBUG,  "%{public}s Increase current outbound data limit %u to %u bytes for connection",  buf,  0x18u);
          }
        }

        *((_DWORD *)v6 + 26) = a3;
        if (!a3) {
          goto LABEL_53;
        }
        if ((v6[404] & 0x80000000) == 0) {
          goto LABEL_53;
        }
        BOOL v20 = v6[405];
        if ((v20 & 1) != 0) {
          goto LABEL_53;
        }
        uint64_t v21 = *((void *)v6 - 6);
        if (!v21) {
          goto LABEL_53;
        }
        uint64_t v22 = *(void *)(v21 + 24);
        if (!v22 || !*(void *)(v22 + 72)) {
          goto LABEL_53;
        }
LABEL_33:
        v6[405] = v20 | 1;
        goto LABEL_53;
      }

      __nwlog_obj();
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v56 = "nw_protocol_instance_update_outbound_data_limit";
      BOOL v11 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v53 = 0;
      if (__nwlog_fault(v11, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v38 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl( &dword_181A5C000,  v12,  v38,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW)",  buf,  0xCu);
          }

          goto LABEL_50;
        }

        if (!v53)
        {
          __nwlog_obj();
          os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v48 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl( &dword_181A5C000,  v12,  v48,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_50;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        BOOL v44 = os_log_type_enabled(v12, type);
        if (!backtrace_string)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl( &dword_181A5C000,  v12,  v43,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), no backtrace",  buf,  0xCu);
          }

          goto LABEL_50;
        }

        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          v56 = "nw_protocol_instance_update_outbound_data_limit";
          uint64_t v57 = 2082;
          *(void *)uint64_t v58 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v43,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_38;
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v56 = "nw_protocol_instance_update_outbound_data_limit";
      BOOL v11 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v53 = 0;
      if (__nwlog_fault(v11, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v31 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl(&dword_181A5C000, v12, v31, "%{public}s called with null flow", buf, 0xCu);
          }

          goto LABEL_50;
        }

        if (!v53)
        {
          __nwlog_obj();
          os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v42 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl( &dword_181A5C000,  v12,  v42,  "%{public}s called with null flow, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_50;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v35 = type;
        char v36 = os_log_type_enabled(v12, type);
        if (!backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl(&dword_181A5C000, v12, v35, "%{public}s called with null flow, no backtrace", buf, 0xCu);
          }

          goto LABEL_50;
        }

        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          v56 = "nw_protocol_instance_update_outbound_data_limit";
          uint64_t v57 = 2082;
          *(void *)uint64_t v58 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v35,  "%{public}s called with null flow, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_38;
      }
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v56 = "nw_protocol_instance_update_outbound_data_limit";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v53 = 0;
    if (__nwlog_fault(v11, &type, &v53))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v56 = "nw_protocol_instance_update_outbound_data_limit";
          _os_log_impl(&dword_181A5C000, v12, v29, "%{public}s called with null instance", buf, 0xCu);
        }

        goto LABEL_50;
      }

      if (!v53)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v41 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v56 = "nw_protocol_instance_update_outbound_data_limit";
          _os_log_impl( &dword_181A5C000,  v12,  v41,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_50;
      }

      uint64_t v32 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v33 = type;
      BOOL v34 = os_log_type_enabled(v12, type);
      if (!v32)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v56 = "nw_protocol_instance_update_outbound_data_limit";
          _os_log_impl(&dword_181A5C000, v12, v33, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }

        goto LABEL_50;
      }

      if (v34)
      {
        *(_DWORD *)buf = 136446466;
        v56 = "nw_protocol_instance_update_outbound_data_limit";
        uint64_t v57 = 2082;
        *(void *)uint64_t v58 = v32;
        _os_log_impl( &dword_181A5C000,  v12,  v33,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v32);
    }
  }

    free(backtrace_string);
    goto LABEL_54;
  }

  uint64_t v5 = v3[30];
  if (!v5 || !*(_DWORD *)(v5 + 40))
  {
    if ((v4[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v30 = "nw_protocol_instance_get_flow_for_key";
        BOOL v31 = 2082;
        uint64_t v32 = v4 + 407;
        uint64_t v33 = 2080;
        BOOL v34 = " ";
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFlow mapping table is empty",  buf,  0x20u);
      }
    }

    goto LABEL_13;
  }

  node = nw_hash_table_get_node(v5, a2, *(unsigned int *)(*(void *)(*((void *)v4 + 1) + 80LL) + 256LL));
  if (!node)
  {
    if ((v4[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        uint64_t v30 = "nw_protocol_instance_get_flow_for_key";
        BOOL v31 = 2082;
        uint64_t v32 = v4 + 407;
        uint64_t v33 = 2080;
        BOOL v34 = " ";
        __int16 v35 = 2048;
        char v36 = a2;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNo flow found for key %p",  buf,  0x2Au);
      }
    }

          if (v16) {
            free(v16);
          }
LABEL_17:
          if (v11 == &nw_protocol_ref_counted_handle)
          {
            nw::release_if_needed<nw_protocol *>(&v27);
            if (v8 != &nw_protocol_ref_counted_handle) {
              return 1LL;
            }
          }

          else if (v8 != &nw_protocol_ref_counted_handle)
          {
            return 1LL;
          }

          nw::release_if_needed<nw_protocol *>((uint64_t *)&v29);
        }
      }
    }
  }

  return 1LL;
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (unsigned __int8 *)v3[4];
    if (v6)
    {
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_protocol_options_enumerate_proxy_next_hops_block_invoke;
      v21[3] = &unk_189BC8628;
      uint64_t v22 = v4;
      nw_array_apply(v6, (uint64_t)v21);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_protocol_options_enumerate_proxy_next_hops";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_options_enumerate_proxy_next_hops";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_options_enumerate_proxy_next_hops";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_options_enumerate_proxy_next_hops";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_protocol_options_enumerate_proxy_next_hops";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    free(backtrace_string);
    goto LABEL_78;
  }

  os_nexus_attr_get();
  os_nexus_attr_destroy();
  *(void *)&buf[8] = 16LL;
  if ((void)v34) {
    buf[12] = 1;
  }
  *(void *)buf = out;
  BOOL v25 = nw_channel_create_with_attributes(a2, (unsigned __int8 *)type, 1u, (uint64_t)buf);
  if (!v25) {
    nw_nexus_remove_instance();
  }
  return v25;
}
}

  if (v20) {
    free(v20);
  }
}

    free(v29);
    goto LABEL_55;
  }

  uint64_t v22 = (os_log_s *)__nwlog_obj();
  os_log_type_t v23 = type;
  if (os_log_type_enabled(v22, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v40 = "nw_protocol_trainer_bottom_inject_input";
    os_log_type_t v24 = "%{public}s called with null protocol";
LABEL_54:
    _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
  }

      goto LABEL_39;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    uint64_t v21 = type;
    uint64_t v22 = os_log_type_enabled(v12, type);
    if (!v20)
    {
      if (!v22) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v41 = "-[NWRemotePacketProxy initWithDelegate:]";
      uint64_t v14 = "%{public}s nw_protocol_hash_table_create failed, no backtrace";
      os_log_type_t v23 = v12;
      os_log_type_t v24 = v21;
      goto LABEL_36;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v41 = "-[NWRemotePacketProxy initWithDelegate:]";
      uint64_t v42 = 2082;
      os_log_type_t v43 = (uint64_t)v20;
      _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s nw_protocol_hash_table_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v20);
LABEL_39:
    if (!v11)
    {
LABEL_41:

LABEL_42:
      self = 0LL;
      goto LABEL_43;
    }

    goto LABEL_39;
  }

  uint64_t v5 = v3[25];
  v3[25] = 0LL;

  if (v4)
  {
    uint64_t v6 = v4;
    uint64_t v7 = [v6 type];

    if (v7 == 4)
    {
      objc_storeStrong(v3 + 25, a2);
      goto LABEL_5;
    }

    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_parameters_set_url_endpoint";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_parameters_set_url_endpoint";
        _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url)",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v21 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_parameters_set_url_endpoint";
        _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    __int16 v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = type;
    uint64_t v19 = os_log_type_enabled(v10, type);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_parameters_set_url_endpoint";
        _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), no backtrace",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_parameters_set_url_endpoint";
      char v26 = 2082;
      unint64_t v27 = v17;
      _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v17);
    if (v9) {
      goto LABEL_40;
    }
  }

    goto LABEL_39;
  }

  if (v4)
  {
    if (v3[20] != v4) {
      objc_storeStrong(v3 + 20, a2);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_parameters_set_transform_array";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v20 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_parameters_set_transform_array";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null transform_array", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v20)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_parameters_set_transform_array";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null transform_array, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_parameters_set_transform_array";
      _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null transform_array, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v23 = "nw_parameters_set_transform_array";
    os_log_type_t v24 = 2082;
    BOOL v25 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null transform_array, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

      free(backtrace_string);
      goto LABEL_52;
    }

    if (!v17) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_client_bottom_accept";
    os_log_type_t v12 = "%{public}s called with null endpoint, no backtrace";
LABEL_51:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
LABEL_52:
    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  if ((nw_http_client_bottom_stalled(*(void *)(a1 + 40)) & 1) != 0) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(v3 + 136);
  if (v6)
  {
    if (!nw_protocol_http_messaging_accept(v6, a2, a3)) {
      return 0LL;
    }
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  os_log_type_t v23 = 0;
  os_log_type_t v8 = *(void **)(v3 + 144);
  if (v8)
  {
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 0x40000000LL;
    v19[2] = __nw_protocol_http_client_bottom_accept_block_invoke;
    v19[3] = &unk_189BB9010;
    v19[4] = buf;
    v19[5] = v3;
    nw_http_connection_metadata_enumerate_secondary_certificates(v8, v19);
    uint64_t v7 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  _Block_object_dispose(buf, 8);
  return v7;
}

  if (v7) {
LABEL_39:
  }
    free(v7);
  return 0LL;
}

    goto LABEL_39;
  }

  if (v3)
  {
    uint64_t v5 = (unsigned __int8 *)v2[50];
    if (v5)
    {
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL45nw_connection_access_probe_connections_lockedP24NWConcrete_nw_connectionU13block_pointerFbS0_E_block_invoke;
      os_log_type_t v23 = &unk_189BC8628;
      os_log_type_t v24 = v3;
      nw_array_apply(v5, (uint64_t)buf);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v20 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null handler", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v20)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
      _os_log_impl(&dword_181A5C000, v8, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_connection_access_probe_connections_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

        free(v33);
        goto LABEL_39;
      }
    }

    if (!v13)
    {
      os_log_type_t v29 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 9);
      uint64_t v30 = (void *)*((void *)v65 + 5);
      *((void *)v65 + 5) = v29;
    }

    BOOL v31 = *((_DWORD *)v8 + 48);
    v60[0] = MEMORY[0x1895F87A8];
    v60[1] = 3221225472LL;
    v60[2] = __nw_connection_receive_file_at_path_with_progress_block_invoke_31;
    v60[3] = &unk_189BBF570;
    char v61 = v10;
    os_log_type_t v62 = v64;
    nw_connection_async_client_if_needed_with_override(v8, 0LL, v31, v60);

    os_log_type_t v18 = v12;
    goto LABEL_43;
  }

  __nwlog_obj();
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
  BOOL v44 = (char *)_os_log_send_and_compose_impl();

  v64[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (v64[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v48 = v64[0];
    if (os_log_type_enabled(v45, v64[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
      _os_log_impl(&dword_181A5C000, v45, v48, "%{public}s called with null handler", buf, 0xCu);
    }

    goto LABEL_82;
  }

  if (type == OS_LOG_TYPE_DEFAULT)
  {
    __nwlog_obj();
    v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v58 = v64[0];
    if (os_log_type_enabled(v45, v64[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
      _os_log_impl( &dword_181A5C000,  v45,  v58,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_82;
  }

  os_log_type_t v52 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v53 = v64[0];
  uint64_t v54 = os_log_type_enabled(v45, v64[0]);
  if (!v52)
  {
    if (v54)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
      _os_log_impl(&dword_181A5C000, v45, v53, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }

    goto LABEL_82;
  }

  if (v54)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_connection_receive_file_at_path_with_progress";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v52;
    _os_log_impl( &dword_181A5C000,  v45,  v53,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v52);
  if (v44) {
    goto LABEL_84;
  }
LABEL_44:
}

        goto LABEL_39;
      }

      if (!v26)
      {
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_connection_write";
          _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      uint64_t v21 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_connection_write";
          _os_log_impl(&dword_181A5C000, v13, v20, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v29 = "nw_connection_write";
        uint64_t v30 = 2082;
        BOOL v31 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_connection_write";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v12, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_connection_write";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null data", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v26)
      {
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_connection_write";
          _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null data, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      uint64_t v19 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_connection_write";
          _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null data, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v29 = "nw_connection_write";
        uint64_t v30 = 2082;
        BOOL v31 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    if (!v12) {
      goto LABEL_40;
    }
LABEL_39:
    free(v12);
    goto LABEL_40;
  }

  uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    uint64_t v7 = nw_endpoint_handler_copy_flow(v5);
    os_log_type_t v8 = _Block_copy(v4);
    int v9 = (void *)*((void *)v7 + 127);
    *((void *)v7 + 127) = v8;

    *((_DWORD *)v7 + 252) = v2;
    if ((*((_BYTE *)v7 + 33) & 4) != 0) {
      nw_endpoint_handler_register_adaptive_read_handler(v5);
    }

    goto LABEL_40;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v10 = (id)gLogObj;
  else {
    BOOL v11 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  uint64_t v32 = "nw_endpoint_handler_set_adaptive_read_handler";
  uint64_t v33 = 2082;
  BOOL v34 = (void *)v11;
  __int16 v35 = 2082;
  char v36 = "flow";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v29 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v13 = (os_log_s *)(id)gLogObj;
    uint64_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      else {
        char v15 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v32 = "nw_endpoint_handler_set_adaptive_read_handler";
      uint64_t v33 = 2082;
      BOOL v34 = (void *)v15;
      __int16 v35 = 2082;
      char v36 = "flow";
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

    if (!v12) {
      goto LABEL_40;
    }
LABEL_39:
    free(v12);
    goto LABEL_40;
  }

  uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    uint64_t v7 = nw_endpoint_handler_copy_flow(v5);
    os_log_type_t v8 = _Block_copy(v4);
    int v9 = (void *)*((void *)v7 + 128);
    *((void *)v7 + 128) = v8;

    *((_DWORD *)v7 + 253) = v2;
    if ((*((_BYTE *)v7 + 33) & 4) != 0) {
      nw_endpoint_handler_register_adaptive_write_handler(v5);
    }

    goto LABEL_40;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v10 = (id)gLogObj;
  else {
    BOOL v11 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  uint64_t v32 = "nw_endpoint_handler_set_adaptive_write_handler";
  uint64_t v33 = 2082;
  BOOL v34 = (void *)v11;
  __int16 v35 = 2082;
  char v36 = "flow";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v29 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v13 = (os_log_s *)(id)gLogObj;
    uint64_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      else {
        char v15 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v32 = "nw_endpoint_handler_set_adaptive_write_handler";
      uint64_t v33 = 2082;
      BOOL v34 = (void *)v15;
      __int16 v35 = 2082;
      char v36 = "flow";
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

    if (!v12) {
      goto LABEL_40;
    }
LABEL_39:
    free(v12);
    goto LABEL_40;
  }

  uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    uint64_t v7 = nw_endpoint_handler_copy_flow(v5);
    os_log_type_t v8 = _Block_copy(v4);
    int v9 = (void *)*((void *)v7 + 129);
    *((void *)v7 + 129) = v8;

    *(int32x2_t *)((char *)v7 + 996) = vrev64_s32(v2);
    if ((*((_BYTE *)v7 + 33) & 4) != 0) {
      nw_endpoint_handler_register_keepalive_handler(v5);
    }

    goto LABEL_40;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v10 = (id)gLogObj;
  else {
    BOOL v11 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  uint64_t v32 = "nw_endpoint_handler_set_keepalive_handler";
  uint64_t v33 = 2082;
  BOOL v34 = (void *)v11;
  __int16 v35 = 2082;
  char v36 = "flow";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v29 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v13 = (os_log_s *)(id)gLogObj;
    uint64_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      else {
        char v15 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v32 = "nw_endpoint_handler_set_keepalive_handler";
      uint64_t v33 = 2082;
      BOOL v34 = (void *)v15;
      __int16 v35 = 2082;
      char v36 = "flow";
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

      free(backtrace_string);
      goto LABEL_48;
    }

    os_log_type_t v12 = (os_log_s *)__nwlog_obj();
    char v13 = type;
    if (!os_log_type_enabled(v12, type)) {
      goto LABEL_48;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_demux_remove_input_handler";
    uint64_t v14 = "%{public}s called with null protocol";
LABEL_47:
    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
LABEL_48:
    if (v11) {
      free(v11);
    }
    return 0LL;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_demux_remove_input_handler";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      char v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_protocol_demux_remove_input_handler";
      uint64_t v14 = "%{public}s called with null demux";
      goto LABEL_47;
    }

    if (!v21)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      char v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_protocol_demux_remove_input_handler";
      uint64_t v14 = "%{public}s called with null demux, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v12 = (os_log_s *)__nwlog_obj();
    char v13 = type;
    os_log_type_t v18 = os_log_type_enabled(v12, type);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v24 = "nw_protocol_demux_remove_input_handler";
        BOOL v25 = 2082;
        char v26 = backtrace_string;
        __int16 v17 = "%{public}s called with null demux, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

      goto LABEL_38;
    }

    if (!v18) {
      goto LABEL_48;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_demux_remove_input_handler";
    uint64_t v14 = "%{public}s called with null demux, no backtrace";
    goto LABEL_47;
  }

  uint64_t v5 = a2;
  if (!a2) {
    return (uint64_t)v5;
  }
  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != v5)
  {
    output_handler_context = (uint64_t)v5->output_handler_context;
    if (output_handler_context)
    {
      v5->output_handler_context = 0LL;
      nw_protocol_set_output_handler((uint64_t)v5, 0LL);
      uint64_t v5 = (nw_protocol *)nw_protocol_demux_destroy_entry((uint64_t)handle, output_handler_context);
      if (a3)
      {
        if (!a1->default_input_handler)
        {
          os_log_type_t v8 = *((void *)handle + 10);
          if (!v8 || !*(_DWORD *)(v8 + 40)) {
            nw_protocol_demux_destroy(handle);
          }
        }
      }

      return (uint64_t)v5;
    }

    return 0LL;
  }

  nw_protocol_set_input_handler((uint64_t)a1, 0LL);
  output_handler = a1->output_handler;
  if (output_handler)
  {
    ((void (*)(void))output_handler->callbacks->remove_input_handler)();
    nw_protocol_set_output_handler((uint64_t)a1, 0LL);
  }

  if (a3)
  {
    os_log_type_t v10 = *((void *)handle + 10);
    if (v10 && *(_DWORD *)(v10 + 40))
    {
      v20[0] = MEMORY[0x1895F87A8];
      v20[1] = 0x40000000LL;
      v20[2] = ___ZL38nw_protocol_demux_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v20[3] = &__block_descriptor_tmp_19_25895;
      v20[4] = handle;
      nw_hash_table_apply((char *)v10, (uint64_t)v20);
    }

    else
    {
      nw_protocol_demux_destroy(handle);
    }
  }

  return 1LL;
}

        goto LABEL_39;
      }

      if (!v22)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          os_log_type_t v16 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_37;
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v15 = type;
      uint64_t v19 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
          os_log_type_t v16 = "%{public}s called with null storage, no backtrace";
          goto LABEL_37;
        }

        goto LABEL_38;
      }

      if (!v19) {
        goto LABEL_28;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_authentication_credential_storage_copy_default_credential";
      char v26 = 2082;
      unint64_t v27 = backtrace_string;
      BOOL v20 = "%{public}s called with null storage, dumping backtrace:%{public}s";
      goto LABEL_27;
    }
  }

      goto LABEL_39;
    }

    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v15 = (os_log_s *)(id)gLogObj;
      unint64_t v27 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_authentication_credential_get_username";
        _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v15 = (os_log_s *)(id)gLogObj;
    uint64_t v22 = type;
    os_log_type_t v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v40 = "nw_authentication_credential_get_username";
        _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v40 = "nw_authentication_credential_get_username";
      BOOL v41 = 2082;
      uint64_t v42 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
  }

    free(v14);
    goto LABEL_39;
  }

  if (!v7)
  {
    __nwlog_obj();
    BOOL v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "-[NWConcrete_nw_endpoint_proxy applyWithHandler:toChildren:]";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "-[NWConcrete_nw_endpoint_proxy applyWithHandler:toChildren:]";
        _os_log_impl(&dword_181A5C000, v15, v29, "%{public}s called with null applyBlock", buf, 0xCu);
      }

    if (v9)
    {
      char v26 = (char *)v9;
LABEL_40:
      free(v26);
    }

    return 0LL;
  }

  nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a3);
  *(_OWORD *)a1->flow_id = *(_OWORD *)a3->flow_id;
  if (!a3->output_handler) {
    nw_protocol_set_output_handler((uint64_t)a3, (uint64_t)a1);
  }
  callbacks = a3->callbacks;
  if (callbacks
    && (supports_external_data = (uint64_t (*)(nw_protocol *))callbacks->supports_external_data) != 0LL)
  {
    os_log_type_t v16 = supports_external_data(a3);
    __int16 v17 = (unsigned int *)(handle + 527);
    if (v16) {
      os_log_type_t v18 = 64;
    }
    else {
      os_log_type_t v18 = 0;
    }
    uint64_t v19 = *(_DWORD *)(handle + 527) & 0xFFFFFFBF | v18;
  }

  else
  {
    __int16 v17 = (unsigned int *)(handle + 527);
    uint64_t v19 = *(_DWORD *)(handle + 527) & 0xFFFFFFBF;
  }

  const char *v17 = v19;
  return 1LL;
}

      free(backtrace_string);
      goto LABEL_52;
    }

    BOOL v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
    char v13 = "%{public}s called with null protocol";
LABEL_51:
    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
LABEL_52:
    if (v10) {
      free(v10);
    }
    return 0LL;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
      char v13 = "%{public}s called with null masque";
      goto LABEL_51;
    }

    if (!v20)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
      char v13 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    os_log_type_t v18 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
        os_log_type_t v24 = 2082;
        BOOL v25 = backtrace_string;
        __int16 v17 = "%{public}s called with null masque, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

      goto LABEL_38;
    }

    if (!v18) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
    char v13 = "%{public}s called with null masque, no backtrace";
    goto LABEL_51;
  }

  if ((handle[529] & 1) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v14 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
      os_log_type_t v24 = 2082;
      BOOL v25 = handle + 531;
      char v26 = 2080;
      unint64_t v27 = " ";
      BOOL v28 = 2048;
      os_log_type_t v29 = a2;
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scalled with listen_protocol %p",  buf,  0x2Au);
    }
  }

  uint64_t v7 = *(_DWORD *)(handle + 527);
  if (*((void *)handle + 55))
  {
    if ((v7 & 0x10000) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      os_log_type_t v8 = (os_log_s *)gprivacy_proxyLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v23 = handle + 531;
        os_log_type_t v24 = 2080;
        BOOL v25 = " ";
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s%salready have a listen handler, ignoring add",  buf,  0x16u);
        return 0LL;
      }

      return result;
    }

    return 0LL;
  }

  if ((v7 & 0x10000) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    uint64_t v19 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v23 = "nw_protocol_masque_add_listen_handler";
      os_log_type_t v24 = 2082;
      BOOL v25 = handle + 531;
      char v26 = 2080;
      unint64_t v27 = " ";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sadded protocol listen handler",  buf,  0x20u);
    }
  }

  *((void *)handle + 55) = a2;
  a2->protocol_handler = a1;
  if ((a3 & 1) != 0) {
    nw_protocol_remove_instance((uint64_t)a1);
  }
  return 1LL;
}

      host_with_numeric_port = 0LL;
      goto LABEL_39;
    }

    __nwlog_obj();
    *(_DWORD *)__s = 136446210;
    *(void *)&__s[4] = "nw_masque_copy_next_hop_from_proxy_status";
    unint64_t v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v27, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_36;
        }
        *(_DWORD *)__s = 136446210;
        *(void *)&__s[4] = "nw_masque_copy_next_hop_from_proxy_status";
        uint64_t v30 = "%{public}s called with null masque";
        goto LABEL_35;
      }

      if (!v51)
      {
        BOOL v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_36;
        }
        *(_DWORD *)__s = 136446210;
        *(void *)&__s[4] = "nw_masque_copy_next_hop_from_proxy_status";
        uint64_t v30 = "%{public}s called with null masque, backtrace limit exceeded";
        goto LABEL_35;
      }

      BOOL v31 = (char *)__nw_create_backtrace_string();
      BOOL v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      uint64_t v32 = os_log_type_enabled(v28, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)__s = 136446466;
          *(void *)&__s[4] = "nw_masque_copy_next_hop_from_proxy_status";
          *(_WORD *)&__s[12] = 2082;
          *(void *)&__s[14] = v31;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null masque, dumping backtrace:%{public}s",  (uint8_t *)__s,  0x16u);
        }

        free(v31);
        goto LABEL_36;
      }

      if (v32)
      {
        *(_DWORD *)__s = 136446210;
        *(void *)&__s[4] = "nw_masque_copy_next_hop_from_proxy_status";
        uint64_t v30 = "%{public}s called with null masque, no backtrace";
LABEL_35:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, (uint8_t *)__s, 0xCu);
      }
    }
}

      free(backtrace_string);
      goto LABEL_73;
    }

    if (!v19) {
      goto LABEL_73;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v37 = "operator()";
    uint64_t v14 = "%{public}s called with null other_protocol, no backtrace";
LABEL_72:
    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
LABEL_73:
    if (v11) {
      free(v11);
    }
    return 0LL;
  }

  if (*(nw_protocol **)(v3 + 48) != a2) {
    return 0LL;
  }
  uint64_t v5 = *(id *)(v3 + 576);
  uint64_t v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v37 = "nw_http_client_metadata_mark_end";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v34 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v37 = "nw_http_client_metadata_mark_end";
        _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v34)
    {
      char v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v27 = type;
      BOOL v28 = os_log_type_enabled(v22, type);
      if (v26)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v37 = "nw_http_client_metadata_mark_end";
          v38 = 2082;
          v39 = v26;
          _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v26);
        goto LABEL_87;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v37 = "nw_http_client_metadata_mark_end";
        _os_log_impl(&dword_181A5C000, v22, v27, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v32 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v37 = "nw_http_client_metadata_mark_end";
        _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    free(v14);
    goto LABEL_39;
  }

  if (!v7)
  {
    __nwlog_obj();
    BOOL v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "-[NWConcrete_nw_endpoint_resolver applyWithHandler:toChildren:]";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "-[NWConcrete_nw_endpoint_resolver applyWithHandler:toChildren:]";
        _os_log_impl(&dword_181A5C000, v15, v29, "%{public}s called with null applyBlock", buf, 0xCu);
      }

        if (v23) {
          free(v23);
        }
        goto LABEL_40;
      }

      uint64_t v42 = v5;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v32 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        loga = nw_endpoint_handler_get_id_string(v1);
        v38 = nw_endpoint_handler_dry_run_string(v1);
        uint64_t v33 = nw_endpoint_handler_copy_endpoint(v1);
        logging_description = nw_endpoint_get_logging_description(v33);
        __int16 v35 = nw_endpoint_handler_state_string(v1);
        char v36 = nw_endpoint_handler_mode_string(v1);
        uint64_t v37 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        v49 = "nw_endpoint_resolver_check_desperate_ivan";
        v50 = 2082;
        v51 = (void *)loga;
        os_log_type_t v52 = 2082;
        os_log_type_t v53 = v38;
        uint64_t v54 = 2082;
        v55 = logging_description;
        v56 = 2082;
        uint64_t v57 = v35;
        uint64_t v58 = 2082;
        v59 = v36;
        v60 = 2114;
        char v61 = v37;
        int v9 = v32;
        _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connectivity seems slow, star ting DesperateIvan timer",  buf,  0x48u);

        uint64_t v5 = v42;
      }

      else
      {
        int v9 = v32;
      }
    }

    else
    {
      if ((logging_disabled & 1) != 0) {
        goto LABEL_18;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v9 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        BOOL v41 = v5;
        id_string = nw_endpoint_handler_get_id_string(v1);
        BOOL v11 = nw_endpoint_handler_dry_run_string(v1);
        log = v9;
        os_log_type_t v12 = nw_endpoint_handler_copy_endpoint(v1);
        char v13 = nw_endpoint_get_logging_description(v12);
        uint64_t v14 = nw_endpoint_handler_state_string(v1);
        char v15 = nw_endpoint_handler_mode_string(v1);
        os_log_type_t v16 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        v49 = "nw_endpoint_resolver_check_desperate_ivan";
        v50 = 2082;
        v51 = (void *)id_string;
        os_log_type_t v52 = 2082;
        os_log_type_t v53 = v11;
        uint64_t v54 = 2082;
        v55 = v13;
        v56 = 2082;
        uint64_t v57 = v14;
        uint64_t v58 = 2082;
        v59 = v15;
        v60 = 2114;
        char v61 = v16;
        int v9 = log;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connectivity seems slow, star ting DesperateIvan timer",  buf,  0x48u);

        uint64_t v5 = v41;
      }
    }

    goto LABEL_18;
  }

            if (!v33)
            {
LABEL_40:

              goto LABEL_41;
            }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_39;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v8 = handle[11];
          if (v8) {
            int v9 = *(_DWORD *)(v8 + 460);
          }
          else {
            int v9 = -1;
          }
          uint64_t v14 = handle[8];
          *(_DWORD *)buf = 136447234;
          os_log_type_t v18 = "nw_protocol_webtransport_stream_input_finished";
          uint64_t v19 = 2082;
          BOOL v20 = (char *)(handle + 24);
          uint64_t v21 = 2080;
          uint64_t v22 = " ";
          os_log_type_t v23 = 1024;
          os_log_type_t v24 = v9;
          BOOL v25 = 2048;
          char v26 = v14;
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called on stream without transport mode set, ignoring",  buf,  0x30u);
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_protocol_webtransport_stream_input_finished";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_input_finished";
    uint64_t v6 = "%{public}s called with null webtransport_stream";
    goto LABEL_38;
  }

  if (!v15)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_input_finished";
    uint64_t v6 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_38;
  }

  os_log_type_t v12 = (char *)__nw_create_backtrace_string();
  int v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  char v13 = os_log_type_enabled(v4, type);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_input_finished";
    uint64_t v6 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_38;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_input_finished";
    uint64_t v19 = 2082;
    BOOL v20 = v12;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v12);
  if (v3) {
    goto LABEL_40;
  }
}

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_39;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v8 = handle[11];
          if (v8) {
            int v9 = *(_DWORD *)(v8 + 460);
          }
          else {
            int v9 = -1;
          }
          uint64_t v14 = handle[8];
          *(_DWORD *)buf = 136447234;
          os_log_type_t v18 = "nw_protocol_webtransport_stream_output_finished";
          uint64_t v19 = 2082;
          BOOL v20 = (char *)(handle + 24);
          uint64_t v21 = 2080;
          uint64_t v22 = " ";
          os_log_type_t v23 = 1024;
          os_log_type_t v24 = v9;
          BOOL v25 = 2048;
          char v26 = v14;
          _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called on stream without transport mode set, ignoring",  buf,  0x30u);
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_protocol_webtransport_stream_output_finished";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_output_finished";
    uint64_t v6 = "%{public}s called with null webtransport_stream";
    goto LABEL_38;
  }

  if (!v15)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_output_finished";
    uint64_t v6 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_38;
  }

  os_log_type_t v12 = (char *)__nw_create_backtrace_string();
  int v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  char v13 = os_log_type_enabled(v4, type);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_output_finished";
    uint64_t v6 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_38;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v18 = "nw_protocol_webtransport_stream_output_finished";
    uint64_t v19 = 2082;
    BOOL v20 = v12;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v12);
  if (v3) {
    goto LABEL_40;
  }
}

  if (v13) {
    free(v13);
  }
  return 0LL;
}

LABEL_39:
      if (v8) {
        free(v8);
      }
      goto LABEL_41;
    }

    if (!v21)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null challenge->protection_space_array, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v16 = type;
    __int16 v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null challenge->protection_space_array, no backtrace",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v24 = "nw_authentication_challenge_try_next_protection_space";
      BOOL v25 = 2082;
      char v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null challenge->protection_space_array, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (void *)v3[5];
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_authentication_credential_iterate_valid_authentication_types_block_invoke;
      applier[3] = &unk_189BC0F80;
      uint64_t v22 = v4;
      xpc_array_apply(v6, applier);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_authentication_credential_iterate_valid_authentication_types";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_authentication_credential_iterate_valid_authentication_types";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null iterator", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_authentication_credential_iterate_valid_authentication_types";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null iterator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_authentication_credential_iterate_valid_authentication_types";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null iterator, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_authentication_credential_iterate_valid_authentication_types";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null iterator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v25 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      char v26 = *(void *)(a1 + 40);
      unint64_t v27 = (const char *)(v26 + 284);
      BOOL v28 = "";
      os_log_type_t v29 = v26 == 0;
      uint64_t v30 = *(_DWORD *)(a1 + 56);
      if (v29) {
        unint64_t v27 = "";
      }
      uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      *(_DWORD *)buf = 136446978;
      if (!v29) {
        BOOL v28 = " ";
      }
      v60 = v27;
      char v61 = 2080;
      os_log_type_t v62 = (void *)v28;
      v63 = 1024;
      LODWORD(v64) = v30;
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sProxy authentication failed with error %d, cancelling connection",  buf,  0x26u);
    }

    goto LABEL_44;
  }

  uint64_t v22 = *(_WORD *)(v9 + 368);
  if ((v22 & 0x20) != 0)
  {
    if ((nw_http_connect_restart_after_disconnect(v9) & 1) != 0) {
      return;
    }
    BOOL v31 = *(void *)(*(void *)(a1 + 40) + 72LL);
    if (v31)
    {
      uint64_t v32 = *(void *)(v31 + 24);
      if (v32)
      {
        uint64_t v33 = *(void (**)(void))(v32 + 48);
        if (v33)
        {
          v33();
          return;
        }
      }
    }

    __nwlog_obj();
    BOOL v34 = *(void *)(*(void *)(a1 + 40) + 72LL);
    __int16 v35 = "invalid";
    if (v34)
    {
      char v36 = *(const char **)(v34 + 16);
      if (v36) {
        __int16 v35 = v36;
      }
    }

    *(_DWORD *)buf = 136446466;
    uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
    v59 = 2082;
    v60 = v35;
    uint64_t v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = (os_log_s *)__nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_84;
      }
      __int16 v40 = *(void *)(*(void *)(a1 + 40) + 72LL);
      BOOL v41 = "invalid";
      if (v40)
      {
        uint64_t v42 = *(const char **)(v40 + 16);
        if (v42) {
          BOOL v41 = v42;
        }
      }

      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      v60 = v41;
      os_log_type_t v43 = "%{public}s protocol %{public}s has invalid disconnected callback";
    }

    else if (v55)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = (os_log_s *)__nwlog_obj();
      v39 = type;
      v45 = os_log_type_enabled(v38, type);
      if (backtrace_string)
      {
        if (v45)
        {
          v46 = *(void *)(*(void *)(a1 + 40) + 72LL);
          v47 = "invalid";
          if (v46)
          {
            v48 = *(const char **)(v46 + 16);
            if (v48) {
              v47 = v48;
            }
          }

          *(_DWORD *)buf = 136446722;
          uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
          v59 = 2082;
          v60 = v47;
          char v61 = 2082;
          os_log_type_t v62 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(backtrace_string);
        goto LABEL_84;
      }

      if (!v45)
      {
LABEL_84:
        if (v37) {
          free(v37);
        }
        return;
      }

      os_log_type_t v52 = *(void *)(*(void *)(a1 + 40) + 72LL);
      os_log_type_t v53 = "invalid";
      if (v52)
      {
        uint64_t v54 = *(const char **)(v52 + 16);
        if (v54) {
          os_log_type_t v53 = v54;
        }
      }

      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      v60 = v53;
      os_log_type_t v43 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
    }

    else
    {
      v38 = (os_log_s *)__nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_84;
      }
      v49 = *(void *)(*(void *)(a1 + 40) + 72LL);
      v50 = "invalid";
      if (v49)
      {
        v51 = *(const char **)(v49 + 16);
        if (v51) {
          v50 = v51;
        }
      }

      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      v60 = v50;
      os_log_type_t v43 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v38, v39, v43, buf, 0x16u);
    goto LABEL_84;
  }

  if ((v22 & 0x18) == 0x10 && (nw_http_connect_send_request(v9, v21) & 1) == 0)
  {
    os_log_type_t v23 = *(void *)(a1 + 40);
    os_log_type_t v24 = 22;
LABEL_48:
    nw_http_connect_fail(v23, v24);
  }

      free(v12);
      if (!v5) {
        return;
      }
LABEL_54:
      free(v5);
      return;
    }

    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = v18;
    if (!os_log_type_enabled(v6, v18)) {
      goto LABEL_53;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_protocol_http2_transport_input_finished";
    os_log_type_t v8 = "%{public}s called with null http2_transport";
LABEL_52:
    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_53;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_protocol_http2_transport_input_finished";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v18 = OS_LOG_TYPE_ERROR;
    __int16 v17 = 0;
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      uint64_t v7 = v18;
      if (!os_log_type_enabled(v6, v18)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "nw_protocol_http2_transport_input_finished";
      os_log_type_t v8 = "%{public}s called with null other_protocol";
      goto LABEL_52;
    }

    if (!v17)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      uint64_t v7 = v18;
      if (!os_log_type_enabled(v6, v18)) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "nw_protocol_http2_transport_input_finished";
      os_log_type_t v8 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_52;
    }

    os_log_type_t v12 = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    uint64_t v7 = v18;
    char v15 = os_log_type_enabled(v6, v18);
    if (!v12)
    {
      if (!v15) {
        goto LABEL_53;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "nw_protocol_http2_transport_input_finished";
      os_log_type_t v8 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_52;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "nw_protocol_http2_transport_input_finished";
      uint64_t v21 = 2082;
      uint64_t v22 = v12;
      uint64_t v14 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_37;
    }

    goto LABEL_38;
  }

  if (gLogDatapath)
  {
    int v9 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "nw_protocol_http2_transport_input_finished";
      uint64_t v21 = 2082;
      uint64_t v22 = handle + 205;
      _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }

  if ((handle[204] & 0x40) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      BOOL v20 = "nw_protocol_http2_transport_input_finished";
      uint64_t v21 = 2082;
      uint64_t v22 = handle + 205;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s still waiting for listen handler, but input finished. Processing input anyway.",  buf,  0x16u);
    }
  }

  nw_protocol_http2_transport_process_input((uint64_t)handle);
  int v4 = (char *)*((void *)handle + 14);
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 0x40000000LL;
  v16[2] = ___ZL42nw_protocol_http2_transport_input_finishedP11nw_protocolS0__block_invoke;
  v16[3] = &__block_descriptor_tmp_29_38281;
  v16[4] = handle;
  nw_hash_table_apply(v4, (uint64_t)v16);
}

    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    goto LABEL_39;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    if (gLogDatapath)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v24 = "nw_protocol_http2_transport_finalize_output_frames";
        BOOL v25 = 2082;
        char v26 = handle + 205;
        _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }

    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 0x40000000LL;
    os_log_type_t v18 = ___ZL50nw_protocol_http2_transport_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
    uint64_t v19 = &__block_descriptor_tmp_41_37922;
    BOOL v20 = a2;
    tqh_first = a2->tqh_first;
    do
    {
      if (!tqh_first) {
        break;
      }
      uint64_t v5 = (nw_frame *)*((void *)tqh_first + 4);
      uint64_t v6 = ((uint64_t (*)(void *))v18)(v17);
      tqh_first = v5;
    }

    while ((v6 & 1) != 0);
    nw_http2_transport_session_send((uint64_t)handle);
    return 0LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v24 = "nw_protocol_http2_transport_finalize_output_frames";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
  uint64_t v22 = OS_LOG_TYPE_ERROR;
  uint64_t v21 = 0;
  if (v22 == OS_LOG_TYPE_FAULT)
  {
    int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v22;
    if (!os_log_type_enabled(v9, v22)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_http2_transport_finalize_output_frames";
    BOOL v11 = "%{public}s called with null http2_transport";
    goto LABEL_38;
  }

  if (!v21)
  {
    int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = v22;
    if (!os_log_type_enabled(v9, v22)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_http2_transport_finalize_output_frames";
    BOOL v11 = "%{public}s called with null http2_transport, backtrace limit exceeded";
    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  int v9 = (os_log_s *)__nwlog_obj();
  os_log_type_t v10 = v22;
  os_log_type_t v16 = os_log_type_enabled(v9, v22);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_protocol_http2_transport_finalize_output_frames";
    BOOL v11 = "%{public}s called with null http2_transport, no backtrace";
    goto LABEL_38;
  }

  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v24 = "nw_protocol_http2_transport_finalize_output_frames";
    BOOL v25 = 2082;
    char v26 = v15;
    _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null http2_transport, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v8) {
    goto LABEL_40;
  }
  return 0LL;
}

    if (v3) {
      goto LABEL_39;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    uint64_t v6 = "%{public}s called with null output_context";
    goto LABEL_37;
  }

  if (!v51)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (os_log_type_enabled(v4, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      uint64_t v6 = "%{public}s called with null output_context, backtrace limit exceeded";
      goto LABEL_37;
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  int v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  uint64_t v42 = os_log_type_enabled(v4, type);
  if (!v15)
  {
    if (v42)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      uint64_t v6 = "%{public}s called with null output_context, no backtrace";
      goto LABEL_37;
    }

    goto LABEL_38;
  }

  if (v42)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    v55 = 2082;
    v56 = (nw_frame *)v15;
    __int16 v17 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
    goto LABEL_16;
  }

  *(_DWORD *)buf = 0;
  nw_frame_array_get_frame_count((uint64_t *)a1, 0, buf);
  BOOL v31 = *(_DWORD *)buf;
  if (*(_DWORD *)buf < 0x1000001u)
  {
LABEL_39:
    if (*((_BYTE *)v5 + 1537))
    {
      uint64_t v32 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v33 = *v87;
        *(_DWORD *)buf = 136446466;
        v91 = "http2_transport_purge_frame_cache_if_necessary";
        v92 = 1024;
        *(_DWORD *)v93 = v33;
        _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s total %u empty frames in cache (final)",  buf,  0x12u);
      }
    }

    return;
  }

  BOOL v34 = "http2_transport_purge_frame_cache_if_necessary";
  __int16 v35 = &qword_18C45F000;
  while (1)
  {
    if (*((_BYTE *)v5 + 1537))
    {
      uint64_t v54 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v91 = v34;
        v92 = 1024;
        *(_DWORD *)v93 = v31;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = 0x1000000;
        _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s too many bytes in frame cache (%u > %u), pruning",  buf,  0x18u);
      }
    }

    char v36 = **((void **)a1->tqh_last + 1);
    if (!v36) {
      break;
    }
    uint64_t v37 = *(void *)(v36 + 16);
    v38 = *(nw_frame ***)(v36 + 24);
    if (v37)
    {
      *(void *)(v37 + 24) = v38;
      v38 = *(nw_frame ***)(v36 + 24);
    }

    else
    {
      a1->tqh_last = v38;
    }

    const char *v38 = (nw_frame *)v37;
    *(void *)(v36 + 16) = 0LL;
    *(void *)(v36 + 24) = 0LL;
    if (!*v87)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v91 = v34;
      v39 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v88 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v40 = gLogObj;
        BOOL v41 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          v91 = v34;
          uint64_t v42 = (os_log_s *)v40;
          os_log_type_t v43 = v41;
          BOOL v44 = "%{public}s http2_transport count attempted to decrement below zero";
          goto LABEL_64;
        }

        goto LABEL_65;
      }

      if (v88)
      {
        v45 = v34;
        v46 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v47 = (os_log_s *)gLogObj;
        v48 = type;
        v49 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v46)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446466;
            v91 = v45;
            v92 = 2082;
            *(void *)v93 = v46;
            _os_log_impl( &dword_181A5C000,  v47,  v48,  "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v46);
          BOOL v34 = v45;
          goto LABEL_65;
        }

        BOOL v34 = v45;
        if (!v49)
        {
LABEL_65:
          if (v39) {
            free(v39);
          }
          __int16 v35 = &qword_18C45F000;
          goto LABEL_68;
        }

        *(_DWORD *)buf = 136446210;
        v91 = v45;
        uint64_t v42 = v47;
        os_log_type_t v43 = v48;
        BOOL v44 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v50 = gLogObj;
        v51 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_65;
        }
        *(_DWORD *)buf = 136446210;
        v91 = v34;
        uint64_t v42 = (os_log_s *)v50;
        os_log_type_t v43 = v51;
        BOOL v44 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
      }

    goto LABEL_39;
  }

  if (username)
  {
    uint64_t v6 = -[NWConcrete_nw_authentication_credential initWithType:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_authentication_credential),  1);
    uint64_t v7 = v5[13];
    v5[13] = v6;

    nw_authentication_credential_set_username(v5[13], username);
    if (password) {
      nw_authentication_credential_set_password(v5[13], password);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v25 = "nw_proxy_config_set_username_and_password";
  int v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v22 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_proxy_config_set_username_and_password";
      _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null username", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v22)
  {
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_proxy_config_set_username_and_password";
      _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s called with null username, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  __int16 v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v18 = type;
  uint64_t v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_proxy_config_set_username_and_password";
      _os_log_impl(&dword_181A5C000, v10, v18, "%{public}s called with null username, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v25 = "nw_proxy_config_set_username_and_password";
    char v26 = 2082;
    unint64_t v27 = v17;
    _os_log_impl( &dword_181A5C000,  v10,  v18,  "%{public}s called with null username, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v17);
  if (v9) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (unsigned __int8 *)v3[6];
    if (v6)
    {
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_proxy_config_enumerate_resolved_endpoints_block_invoke;
      v21[3] = &unk_189BC8628;
      uint64_t v22 = v4;
      nw_array_apply(v6, (uint64_t)v21);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_proxy_config_enumerate_resolved_endpoints";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_resolved_endpoints";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_resolved_endpoints";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_resolved_endpoints";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_proxy_config_enumerate_resolved_endpoints";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (void *)*((void *)v3 + 15);
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_proxy_config_enumerate_match_domains_block_invoke;
      applier[3] = &unk_189BC0F80;
      uint64_t v22 = v4;
      xpc_array_apply(v6, applier);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_proxy_config_enumerate_match_domains";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_match_domains";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_match_domains";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_match_domains";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_proxy_config_enumerate_match_domains";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (void *)*((void *)v3 + 16);
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_proxy_config_enumerate_excluded_domains_block_invoke;
      applier[3] = &unk_189BC0F80;
      uint64_t v22 = v4;
      xpc_array_apply(v6, applier);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_proxy_config_enumerate_excluded_domains";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_excluded_domains";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_excluded_domains";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_excluded_domains";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_proxy_config_enumerate_excluded_domains";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (void *)v3[17];
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_proxy_config_enumerate_preferred_domains_block_invoke;
      applier[3] = &unk_189BC0F80;
      uint64_t v22 = v4;
      xpc_array_apply(v6, applier);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_proxy_config_enumerate_preferred_domains";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_preferred_domains";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_preferred_domains";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_preferred_domains";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_proxy_config_enumerate_preferred_domains";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (void *)v3[18];
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_proxy_config_enumerate_alternate_agents_block_invoke;
      applier[3] = &unk_189BC0F80;
      uint64_t v22 = v4;
      xpc_array_apply(v6, applier);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_proxy_config_enumerate_alternate_agents";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_alternate_agents";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_alternate_agents";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerator, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_enumerate_alternate_agents";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_proxy_config_enumerate_alternate_agents";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (void *)v3[4];
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_proxy_config_remove_protocols_from_stack_block_invoke;
      applier[3] = &unk_189BC8CB8;
      uint64_t v22 = v4;
      xpc_array_apply(v6, applier);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_proxy_config_remove_protocols_from_stack";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_remove_protocols_from_stack";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null stack", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_remove_protocols_from_stack";
      _os_log_impl(&dword_181A5C000, v9, v20, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_proxy_config_remove_protocols_from_stack";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null stack, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_proxy_config_remove_protocols_from_stack";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

    v29 += input_frames;
  }

  while (input_frames);
  if (gLogDatapath)
  {
    v193 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v193, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v193, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  v81 = MEMORY[0x1895F87A8];
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_39716;
  *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_55_39717;
  *(void *)&buf[32] = &v231;
  buf[40] = 0;
  v82 = v231;
  do
  {
    if (!v82) {
      break;
    }
    v83 = (_DWORD *)*((void *)v82 + 4);
    v84 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v82 = v83;
  }

  while ((v84 & 1) != 0);
  v85 = (unsigned __int16)*v230;
  v86 = v85 | (*(unsigned __int8 *)(v12 + 874) << 16);
  if ((v85 & 0x6000) == 0x2000 && !*(void *)(v12 + 616))
  {
    *(_BYTE *)(v12 + 874) = BYTE2(v86);
    *v230 = v86 | 0x4000;
    if (*(void *)(v12 + 488))
    {
      if (*(_DWORD *)(v12 + 868) && llhttp_message_needs_eof(v12 + 200))
      {
        v113 = (unsigned __int16 *)(v12 + 872);
        if ((v86 & 4) == 0)
        {
          v114 = 5;
          if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
            goto LABEL_131;
          }
          goto LABEL_197;
        }

    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_39;
  }

  id v3 = *((void *)this + 5);
  if (v3)
  {
    int v4 = *(_BYTE *)(v3 + 584);
    if ((v4 & 1) != 0)
    {
      uint64_t v5 = *(void **)(v3 + 576);
      if (v5)
      {
        os_release(v5);
        int v4 = *(_BYTE *)(v3 + 584);
      }
    }

    *(void *)(v3 + 576) = 0LL;
    *(_BYTE *)(v3 + 584) = v4 | 1;
    uint64_t v6 = *(_BYTE *)(v3 + 600);
    if ((v6 & 1) != 0)
    {
      uint64_t v7 = *(void **)(v3 + 592);
      if (v7)
      {
        os_release(v7);
        uint64_t v6 = *(_BYTE *)(v3 + 600);
      }
    }

    *(void *)(v3 + 592) = 0LL;
    *(_BYTE *)(v3 + 600) = v6 | 1;
    os_log_type_t v8 = nw_parameters_copy_protocol_options_legacy(*(void **)(v3 + 640), (nw_protocol *)v3);
    *(_DWORD *)(v3 + 672) = nw_http_retry_options_get_limit(v8);
    *(_BYTE *)(v3 + 676) &= 0xF9u;
    if (v8) {
      os_release(v8);
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v20 = "operator()";
  int v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v17 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "operator()";
    os_log_type_t v12 = "%{public}s called with null http_retry";
    goto LABEL_38;
  }

  if (!v17)
  {
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "operator()";
    os_log_type_t v12 = "%{public}s called with null http_retry, backtrace limit exceeded";
    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v10 = (os_log_s *)__nwlog_obj();
  BOOL v11 = type;
  os_log_type_t v16 = os_log_type_enabled(v10, type);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "operator()";
    os_log_type_t v12 = "%{public}s called with null http_retry, no backtrace";
    goto LABEL_38;
  }

  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v20 = "operator()";
    uint64_t v21 = 2082;
    uint64_t v22 = v15;
    _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null http_retry, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v9) {
LABEL_40:
  }
    free(v9);
}

  unint64_t v27 = +[ManagedNetworkSettings sharedMNS](&OBJC_CLASS___ManagedNetworkSettings, "sharedMNS");
  [v27 queue];
  BOOL v28 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
  dispatch_async(v28, &__block_literal_global_371);

  return 0LL;
}

  int v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_56:

  return v4;
}

  int v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_56:

  return v4;
}

  int v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_56:

  return v4;
}

      goto LABEL_39;
    }

    BOOL v20 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    uint64_t v21 = type;
    uint64_t v22 = os_log_type_enabled(v12, type);
    if (!v20)
    {
      if (!v22) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v41 = "-[NWRemoteConnectionDirector initWithDelegate:]";
      uint64_t v14 = "%{public}s nw_protocol_hash_table_create failed, no backtrace";
      os_log_type_t v23 = v12;
      os_log_type_t v24 = v21;
      goto LABEL_36;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v41 = "-[NWRemoteConnectionDirector initWithDelegate:]";
      uint64_t v42 = 2082;
      os_log_type_t v43 = (uint64_t)v20;
      _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s nw_protocol_hash_table_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v20);
LABEL_39:
    if (!v11)
    {
LABEL_41:

LABEL_42:
      self = 0LL;
      goto LABEL_43;
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
    return v14;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v59 = "nw_protocol_create_internal";
  uint64_t v42 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v56 = 0;
  if (__nwlog_fault(v42, &type, &v56))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      BOOL v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v45 = "%{public}s called with null identifier";
LABEL_97:
        _os_log_impl(&dword_181A5C000, v43, v44, v45, buf, 0xCu);
      }
    }

    else if (v56)
    {
      v48 = (char *)__nw_create_backtrace_string();
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      BOOL v44 = type;
      v49 = os_log_type_enabled(v43, type);
      if (v48)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_protocol_create_internal";
          v60 = 2082;
          char v61 = (uint64_t)v48;
          _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v48);
        goto LABEL_98;
      }

      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v45 = "%{public}s called with null identifier, no backtrace";
        goto LABEL_97;
      }
    }

    else
    {
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      BOOL v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v45 = "%{public}s called with null identifier, backtrace limit exceeded";
        goto LABEL_97;
      }
    }
  }

  if (v13) {
    free(v13);
  }
  uint64_t v5 = 0;
LABEL_5:
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "__nw_frame_unclaimed_length";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v17, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        uint64_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "__nw_frame_unclaimed_length";
          BOOL v20 = "%{public}s called with null frame";
LABEL_45:
          _os_log_impl(&dword_181A5C000, v18, v19, v20, buf, 0xCu);
        }
      }

      else if (v26)
      {
        os_log_type_t v24 = (char *)__nw_create_backtrace_string();
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        uint64_t v19 = type;
        BOOL v25 = os_log_type_enabled(v18, type);
        if (v24)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v29 = "__nw_frame_unclaimed_length";
            uint64_t v30 = 2082;
            BOOL v31 = v24;
            _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v24);
          goto LABEL_46;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "__nw_frame_unclaimed_length";
          BOOL v20 = "%{public}s called with null frame, no backtrace";
          goto LABEL_45;
        }
      }

      else
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj();
        uint64_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "__nw_frame_unclaimed_length";
          BOOL v20 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_45;
        }
      }
    }

        free(backtrace_string);
        goto LABEL_107;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v67 = "nw_frame_split";
      v68 = 2048;
      uint64_t v69 = v12;
      char v36 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v64 = 0;
      if (__nwlog_fault(v36, &type, &v64))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v37 = (os_log_s *)__nwlog_obj();
          v38 = type;
          if (!os_log_type_enabled(v37, type)) {
            goto LABEL_91;
          }
          *(_DWORD *)buf = 136446466;
          v67 = "nw_frame_split";
          v68 = 2048;
          uint64_t v69 = v12;
          v39 = "%{public}s frame %p has no split metadata";
          goto LABEL_90;
        }

        if (!v64)
        {
          uint64_t v37 = (os_log_s *)__nwlog_obj();
          v38 = type;
          if (!os_log_type_enabled(v37, type)) {
            goto LABEL_91;
          }
          *(_DWORD *)buf = 136446466;
          v67 = "nw_frame_split";
          v68 = 2048;
          uint64_t v69 = v12;
          v39 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
          goto LABEL_90;
        }

        BOOL v44 = (char *)__nw_create_backtrace_string();
        uint64_t v37 = (os_log_s *)__nwlog_obj();
        v38 = type;
        v45 = os_log_type_enabled(v37, type);
        if (v44)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446722;
            v67 = "nw_frame_split";
            v68 = 2048;
            uint64_t v69 = v12;
            v70 = 2082;
            *(void *)v71 = v44;
            _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v44);
          goto LABEL_91;
        }

        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v67 = "nw_frame_split";
          v68 = 2048;
          uint64_t v69 = v12;
          v39 = "%{public}s frame %p has no split metadata, no backtrace";
LABEL_90:
          _os_log_impl(&dword_181A5C000, v37, v38, v39, buf, 0x16u);
        }
      }

      free(v16);
      goto LABEL_39;
    }

    if (!v29)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (os_log_s *)(id)gLogObj;
      unint64_t v27 = typea;
      if (os_log_type_enabled(v17, typea))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "+[NWBonjourServiceEndpoint endpointWithName:type:domain:]";
        _os_log_impl( &dword_181A5C000,  v17,  v27,  "%{public}s NWBonjourServiceEndpoint created endpoint of wrong type, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)(id)gLogObj;
    os_log_type_t v24 = typea;
    BOOL v25 = os_log_type_enabled(v17, typea);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v32 = "+[NWBonjourServiceEndpoint endpointWithName:type:domain:]";
        _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s NWBonjourServiceEndpoint created endpoint of wrong type, no backtrace",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v32 = "+[NWBonjourServiceEndpoint endpointWithName:type:domain:]";
      uint64_t v33 = 2082;
      BOOL v34 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s NWBonjourServiceEndpoint created endpoint of wrong type, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v33);
    goto LABEL_39;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v12 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  v47 = "nwsc_request_start_path_watcher";
  v48 = 2114;
  v49 = v7;
  v50 = 2114;
  v51 = v8;
  char v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v44 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (os_log_s *)(id)gLogObj;
    char v15 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446722;
      v47 = "nwsc_request_start_path_watcher";
      v48 = 2114;
      v49 = v7;
      v50 = 2114;
      v51 = v8;
      _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s %{public}@ tried to start path watcher on incoming request %{public}@",  buf,  0x20u);
    }

      BOOL v34 = v9->i32[0];
      int v9 = (uint32x2_t *)((char *)v9 + 4);
      v8 += v34;
      if ((v6 & 2) == 0)
      {
LABEL_16:
        if ((v6 & 1) == 0)
        {
LABEL_18:
          uint64_t v19 = __ROR8__(v8, 56);
          else {
            BOOL v20 = v8;
          }
          uint64_t v22 = (unsigned __int16)(((HIDWORD(v21) + (unsigned __int16)v21 + WORD1(v21)) >> 16)
                                 + WORD2(v21)
                                 + v21
                                 + WORD1(v21)
          goto LABEL_22;
        }

      uint64_t v33 = buf;
LABEL_111:
      v49 = (os_log_s *)v18;
      v50 = OS_LOG_TYPE_INFO;
      goto LABEL_112;
    }

    __nwlog_obj();
    v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_INFO,  "%{public}s Received TCP packet with multicast destination address",  buf,  0xCu);
    }

    goto LABEL_39;
  }

  if (a2 < 0x40)
  {
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __nw_ip_metadata_set_dscp_value_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    uint64_t v21 = a2;
    uint64_t v5 = v3[4];
    if (v5) {
      __nw_ip_metadata_set_dscp_value_block_invoke((uint64_t)v20, v5);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v25 = "nw_ip_metadata_set_dscp_value";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v22 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_ip_metadata_set_dscp_value";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null (dscp_value <= _MAX_DSCP)", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v22)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_ip_metadata_set_dscp_value";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_ip_metadata_set_dscp_value";
      _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v25 = "nw_ip_metadata_set_dscp_value";
    char v26 = 2082;
    unint64_t v27 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

  if (v10) {
    free(v10);
  }
  return 0LL;
}

  if (v6)
  {
LABEL_39:
    uint64_t v33 = (char *)v6;
LABEL_86:
    free(v33);
  }

  return 0LL;
}

  if (v8) {
    free(v8);
  }
  return 0xFFFFFFFFLL;
}

    if (v8) {
      free(v8);
    }
    uint64_t v2 = 0LL;
    goto LABEL_46;
  }

  uint64_t v2 = v1;
  if (!nw_protocol_options_is_quic_connection(v2))
  {
    is_quic_stream = nw_protocol_options_is_quic_stream(v2);

    if (is_quic_stream) {
      goto LABEL_5;
    }
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_quic_options_copy_local_public_key";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_quic_options_copy_local_public_key";
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null nw_protocol_options_is_quic(options)",  buf,  0xCu);
      }
    }

    else if (v23)
    {
      os_log_type_t v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = type;
      BOOL v20 = os_log_type_enabled(v13, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_quic_options_copy_local_public_key";
          unint64_t v27 = 2082;
          BOOL v28 = v18;
          _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v18);
        goto LABEL_44;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_quic_options_copy_local_public_key";
        _os_log_impl( &dword_181A5C000,  v13,  v19,  "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_quic_options_copy_local_public_key";
        _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_44:
    if (v12) {
      free(v12);
    }
LABEL_46:
    uint64_t v5 = 0LL;
    goto LABEL_8;
  }

LABEL_5:
  if (nw_protocol_options_is_quic_stream(v2))
  {
    int v4 = nw_quic_stream_copy_shared_connection_options(v2);

    uint64_t v2 = v4;
  }

  uint64_t v5 = nw_quic_connection_copy_local_public_key(v2);
LABEL_8:

  return v5;
}

    free(v9);
    goto LABEL_39;
  }

  __nwlog_obj();
  BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v36 = "nw_parameters_create_qpod";
  char v26 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v33 = 0;
  if (__nwlog_fault(v26, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        char v36 = "nw_parameters_create_qpod";
        _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null configure_qpod", buf, 0xCu);
      }
    }

    else if (v33)
    {
      os_log_type_t v29 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = type;
      BOOL v31 = os_log_type_enabled(v27, type);
      if (v29)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          char v36 = "nw_parameters_create_qpod";
          uint64_t v37 = 2082;
          v38 = v29;
          _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s called with null configure_qpod, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v29);
        goto LABEL_68;
      }

      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        char v36 = "nw_parameters_create_qpod";
        _os_log_impl(&dword_181A5C000, v27, v30, "%{public}s called with null configure_qpod, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v32 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        char v36 = "nw_parameters_create_qpod";
        _os_log_impl( &dword_181A5C000,  v27,  v32,  "%{public}s called with null configure_qpod, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      uint64_t v21 = 0LL;
      goto LABEL_39;
    }

    if (v11)
    {
      char v13 = 0LL;
      uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 136LL);
      if (v19) {
        goto LABEL_30;
      }
      goto LABEL_38;
    }

    __nwlog_obj();
    v71 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
    v72 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (__nwlog_fault(v72, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v73, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_181A5C000, v73, v74, "%{public}s Unexpected result pair for remove", buf, 0xCu);
        }
      }

      else if (v90)
      {
        v83 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v84 = type;
        v85 = os_log_type_enabled(v73, type);
        if (v83)
        {
          if (v85)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            v94 = 2082;
            *(void *)v95 = v83;
            _os_log_impl( &dword_181A5C000,  v73,  v84,  "%{public}s Unexpected result pair for remove, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v83);
          goto LABEL_201;
        }

        if (v85)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl( &dword_181A5C000,  v73,  v84,  "%{public}s Unexpected result pair for remove, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v89 = type;
        if (os_log_type_enabled(v73, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl( &dword_181A5C000,  v73,  v89,  "%{public}s Unexpected result pair for remove, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      free(backtrace_string);
    }

LABEL_39:
    if (v7) {
      free(v7);
    }
    goto LABEL_41;
  }

  int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_activity_report_destination,  12LL);
  id v3 = int64_with_default;
  if (!gLogDatapath)
  {
    else {
      int v4 = 0;
    }
    return v4 & 1;
  }

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  BOOL v11 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v19 = "nw_activity_should_report_to_destination";
    BOOL v20 = 2048;
    uint64_t v21 = (char *)v3;
    _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Activity destination: %llu", buf, 0x16u);
  }

  int v4 = gLogDatapath;
  if ((v3 & a1) == 0)
  {
    if (!gLogDatapath) {
      return v4 & 1;
    }
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
    }
    char v15 = (os_log_s *)(id)gactivityLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_activity_should_report_to_destination";
      BOOL v20 = 1024;
      LODWORD(v21) = a1;
      _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, "%{public}s Destination %u is not configured", buf, 0x12u);
    }

LABEL_41:
    int v4 = 0;
    return v4 & 1;
  }

  if (gLogDatapath)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
    }
    os_log_type_t v12 = (os_log_s *)(id)gactivityLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_activity_should_report_to_destination";
      BOOL v20 = 1024;
      LODWORD(v21) = a1;
      _os_log_impl(&dword_181A5C000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Destination %u is configured", buf, 0x12u);
    }

    int v4 = 1;
  }

  else
  {
    int v4 = 1;
  }

  return v4 & 1;
}

    free(v20);
    if (!v10) {
      goto LABEL_8;
    }
    goto LABEL_59;
  }

  uint64_t v6 = v4;
  uint64_t v7 = (void *)*((void *)v3 + 7);
  if ((v3[64] & 1) != 0 && v7)
  {
    *((void *)v3 + 7) = 0LL;

    uint64_t v7 = (void *)*((void *)v3 + 7);
  }

  *((void *)v3 + 7) = 0LL;

  os_log_type_t v8 = (void *)*((void *)v3 + 7);
  *((void *)v3 + 7) = v6;

  v3[64] |= 1u;
LABEL_8:
}

    goto LABEL_39;
  }

  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __nw_webtransport_metadata_set_stream_id_block_invoke;
    v20[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v20[4] = a2;
    uint64_t v5 = v4[4];
    if (v5) {
      __nw_webtransport_metadata_set_stream_id_block_invoke((uint64_t)v20, v5);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v24 = "nw_webtransport_metadata_set_stream_id";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v21 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v21)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s protocol metadata is not webtransport, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, no backtrace",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v24 = "nw_webtransport_metadata_set_stream_id";
    BOOL v25 = 2082;
    char v26 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __nw_webtransport_metadata_set_is_unidirectional_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    uint64_t v21 = a2;
    uint64_t v5 = v4[4];
    if (v5) {
      __nw_webtransport_metadata_set_is_unidirectional_block_invoke((uint64_t)v20, v5);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v25 = "nw_webtransport_metadata_set_is_unidirectional";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v22 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v22)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s protocol metadata is not webtransport, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, no backtrace",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v25 = "nw_webtransport_metadata_set_is_unidirectional";
    char v26 = 2082;
    unint64_t v27 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __nw_webtransport_metadata_set_is_datagram_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    uint64_t v21 = a2;
    uint64_t v5 = v4[4];
    if (v5) {
      __nw_webtransport_metadata_set_is_datagram_block_invoke((uint64_t)v20, v5);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v25 = "nw_webtransport_metadata_set_is_datagram";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v22 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v22)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s protocol metadata is not webtransport, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, no backtrace",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v25 = "nw_webtransport_metadata_set_is_datagram";
    char v26 = 2082;
    unint64_t v27 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

    goto LABEL_39;
  }

  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __nw_webtransport_metadata_set_is_peer_initiated_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    uint64_t v21 = a2;
    uint64_t v5 = v4[4];
    if (v5) {
      __nw_webtransport_metadata_set_is_peer_initiated_block_invoke((uint64_t)v20, v5);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v25 = "nw_webtransport_metadata_set_is_peer_initiated";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v22 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v22)
  {
    __nwlog_obj();
    os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl( &dword_181A5C000,  v8,  v19,  "%{public}s protocol metadata is not webtransport, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  char v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v16 = type;
  __int16 v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v25 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, no backtrace",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v25 = "nw_webtransport_metadata_set_is_peer_initiated";
    char v26 = 2082;
    unint64_t v27 = v15;
    _os_log_impl( &dword_181A5C000,  v8,  v16,  "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

  if (v16) {
    free(v16);
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, _DWORD **))(*(void *)(v5 + 24) + 88LL);
  char v15 = 0xFFFFFFFFLL;
LABEL_41:
  uint64_t v22 = v7(v5, *(void *)(a1 + 24), v15, v15, 0xFFFFFFFFLL, a4);
  if ((_DWORD)v22) {
    nw_http3_framer_claim_http3_frame_header(v14, *a4);
  }
  return v22;
}

  if (v12) {
    free(v12);
  }
LABEL_40:
  if (!*(void *)(a1 + 376)) {
    goto LABEL_57;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  BOOL v44 = "nw_protocol_http3_stream_destroy";
  os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v41 = 0;
  if (__nwlog_fault(v18, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)gLogObj;
      BOOL v20 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_protocol_http3_stream_destroy";
      uint64_t v21 = "%{public}s should not have input_fields_frame left when destroying";
      goto LABEL_54;
    }

    if (!v41)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)gLogObj;
      BOOL v20 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_protocol_http3_stream_destroy";
      uint64_t v21 = "%{public}s should not have input_fields_frame left when destroying, backtrace limit exceeded";
      goto LABEL_54;
    }

    uint64_t v22 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (os_log_s *)gLogObj;
    BOOL v20 = type;
    os_log_type_t v23 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v22)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v44 = "nw_protocol_http3_stream_destroy";
        v45 = 2082;
        v46 = v22;
        _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s should not have input_fields_frame left when destroying, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v22);
      goto LABEL_55;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v44 = "nw_protocol_http3_stream_destroy";
      uint64_t v21 = "%{public}s should not have input_fields_frame left when destroying, no backtrace";
LABEL_54:
      _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
    }
  }

      BOOL v31 = *((void *)handle + 4);
      uint64_t v32 = *((void *)handle + 110);
      uint64_t v33 = (v32 | v31) == 0;
      if (v31) {
        BOOL v34 = 1;
      }
      else {
        BOOL v34 = v32 == 0;
      }
      if (v34) {
        __int16 v35 = *((void *)handle + 4);
      }
      else {
        __int16 v35 = 0LL;
      }
      if (v32 && !v31)
      {
        while (1)
        {
          __int16 v35 = *(void *)(v32 + 32);
          if (v35) {
            break;
          }
          uint64_t v32 = *(void *)(v32 + 544);
          if (!v32)
          {
            __int16 v35 = 0LL;
            break;
          }
        }
      }

      v221 = a2;
      *(void *)v228 = 0LL;
      *(void *)&v228[8] = v228;
      *(void *)&v228[16] = 0x2000000000LL;
      v229 = 0;
      v217 = v6;
      char v36 = v6;
      uint64_t v37 = (nw_protocol_stack *)v36[19];
      object = v36;

      v38 = MEMORY[0x1895F87A8];
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL43nw_http3_set_prohibit_joining_on_parametersP11nw_protocolP13nw_parameters_block_invoke;
      *(void *)&_BYTE buf[24] = &unk_189BC4568;
      *(void *)&buf[32] = v228;
      *(void *)&buf[40] = v219;
      nw_protocol_stack_iterate_application_protocols(v37, buf);
      v218 = v33;
      if (*(_BYTE *)(*(void *)&v228[8] + 24LL))
      {
        v39 = nw_protocol_stack_copy_transport_protocol(v37);
        if (v39)
        {
          __int16 v40 = v39;
          BOOL v41 = v40[1];

          identifier = nw_protocol_definition_get_identifier(v41);
          if (gLogDatapath)
          {
            v205 = identifier;
            v206 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v206, OS_LOG_TYPE_DEBUG))
            {
              name = v219->identifier->name;
              if (!name) {
                name = "invalid";
              }
              *(_DWORD *)os_log_type_t type = 136446978;
              *(void *)&type[4] = "nw_http3_set_prohibit_joining_on_parameters";
              *(_WORD *)&type[12] = 2080;
              *(void *)&type[14] = name;
              *(_WORD *)&type[22] = 2048;
              *(void *)&type[24] = v219;
              *(_WORD *)&type[32] = 2080;
              *(void *)&type[34] = v205;
              _os_log_impl( &dword_181A5C000,  v206,  OS_LOG_TYPE_DEBUG,  "%{public}s %s (%p) setting prohibit joining on %s",  (uint8_t *)type,  0x2Au);
            }
          }

          if (v41) {
            os_release(v41);
          }
          os_log_type_t v43 = v40;
          *((_BYTE *)v43 + 153) = 1;

          uint64_t v33 = v218;
          *(_BYTE *)(*(void *)&v228[8] + 24LL) = 0;
          os_release(v43);
        }
      }

      if (v37) {
        os_release(v37);
      }
      _Block_object_dispose(v228, 8);
      BOOL v44 = (uint64_t)v221;
      if (v33)
      {
        v45 = object;
        v46 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v45,  0,  1);

        v47 = nw_parameters_copy_protocol_options_legacy((void *)v46, v219);
        if (v47)
        {
          v48 = v47;
          v49 = nw_protocol_options_copy(v47);
          BOOL v44 = (uint64_t)v221;
          if (nw_protocol_copy_http3_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_10_72547);
          }
          v50 = (id)nw_protocol_copy_http3_definition_http3_definition;
          nw_parameters_set_protocol_instance(v49, v51, (uint64_t)handle);
          if (v50) {
            os_release(v50);
          }
          os_log_type_t v52 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v46);
          nw_protocol_stack_replace_protocol_with_handle(v52, (uint64_t)v219, v49);
          if (v52) {
            os_release(v52);
          }
          if (v49) {
            os_release(v49);
          }
          os_release(v48);
        }

        else
        {
          BOOL v44 = (uint64_t)v221;
          if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v53 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              uint64_t v54 = *((_DWORD *)handle + 320);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 1289;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&_BYTE buf[24] = " ";
              *(_WORD *)&buf[32] = 1024;
              *(_DWORD *)&buf[34] = v54;
              *(_WORD *)&buf[38] = 2048;
              *(void *)&buf[40] = v46;
              *(_WORD *)&buf[48] = 2048;
              *(void *)&buf[50] = v45;
              _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> failed to find http3 options in new parameters %p, copy of %p",  buf,  0x3Au);
            }
          }
        }

        v55 = (void *)*((void *)handle + 140);
        if (v55) {
          os_release(v55);
        }
        *((void *)handle + 140) = v46;
      }

      v56 = *((void *)handle + 2);
      uint64_t v57 = (void *)*((void *)handle + 137);
      uint64_t v58 = calloc(1uLL, 0x2E8uLL);
      if (!v58)
      {
        v171 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v171, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "strict_calloc";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 1LL;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&_BYTE buf[24] = 744LL;
        v172 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v172);
        if (result) {
          goto LABEL_387;
        }
        free(v172);
      }

      bzero(v58, 0x2E8uLL);
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      *(void *)&_BYTE buf[24] = v58;
      *(void *)os_log_type_t type = v38;
      *(void *)&os_log_type_t type[8] = 0x40000000LL;
      *(void *)&type[16] = ___ZL22nw_http3_stream_createPK22nw_protocol_identifierP17nw_protocol_http3P11nw_endpointP13nw_parametersb_block_invoke;
      *(void *)&type[24] = &unk_189BC4590;
      *(void *)&type[32] = buf;
      *((void *)v58 + 41) = _Block_copy(type);
      _Block_object_dispose(buf, 8);
      *((void *)v58 + 2) = v56;
      *((void *)v58 + 3) = &nw_protocol_http3_stream_get_callbacks(void)::protocol_callbacks;
      *((void *)v58 + 5) = v58;
      if (nw_protocol_http3_identifier::onceToken != -1) {
        dispatch_once(&nw_protocol_http3_identifier::onceToken, &__block_literal_global_10);
      }
      *((void *)v58 + 10) = &nw_protocol_http3_identifier::http3_protocol_identifier;
      *((void *)v58 + 11) = &nw_protocol_http3_stream_get_callbacks(void)::protocol_callbacks;
      *((void *)v58 + 13) = v58;
      *((void *)v58 + 42) = handle;
      *((void *)v58 + 16) = -1LL;
      *((void *)v58 + 17) = 0LL;
      *((void *)v58 + 18) = 0LL;
      *((void *)v58 + 19) = v58;
      *((void *)v58 + 20) = 0LL;
      *((void *)v58 + 21) = 0LL;
      *((void *)v58 + 22) = 0LL;
      *((void *)v58 + 24) = 0LL;
      *((void *)v58 + 25) = 0LL;
      *((void *)v58 + 23) = v58 + 11;
      *(void *)((char *)v58 + 206) = 0LL;
      if (v57) {
        v59 = os_retain(v57);
      }
      else {
        v59 = 0LL;
      }
      *((void *)v58 + 43) = v59;
      *((void *)v58 + 44) = os_retain(object);
      *((void *)v58 + 46) = 0LL;
      *((void *)v58 + 33) = -1LL;
      v60 = nw_frame_create(0, 0LL, 0, 0LL, 0LL);
      *((void *)v58 + 27) = 0LL;
      *((void *)v58 + 48) = v60;
      *((void *)v58 + 28) = (char *)v58 + 216;
      *((void *)v58 + 61) = 0LL;
      *((void *)v58 + 62) = 0LL;
      *((_WORD *)v58 + 368) |= 4u;
      if (nw_path_parameters_get_logging_disabled(v217[13])) {
        char v61 = 2048;
      }
      else {
        char v61 = 0;
      }
      os_log_type_t v62 = v58[46] & 0xF7FF | (*((unsigned __int8 *)v58 + 738) << 16);
      *((_WORD *)v58 + 368) = v58[46] & 0xF7FF | v61;
      *((_BYTE *)v58 + 738) = BYTE2(v62);
      *((_BYTE *)v58 + 320) = *v222 & 1;
      v63 = nw_parameters_copy_protocol_options_legacy(object, (nw_protocol *)handle);
      if (!v63) {
        goto LABEL_92;
      }
      char v64 = v63;
      singleton = nw_http_messaging_options_copy_transaction_metadata(v63);
      v66 = nw_http3_copy_application_error_callback(v64);
      v67 = *((_BYTE *)v58 + 440);
      if ((v67 & 1) != 0)
      {
        v68 = (const void *)*((void *)v58 + 54);
        if (v68)
        {
          _Block_release(v68);
          v67 = *((_BYTE *)v58 + 440);
        }
      }

      *((void *)v58 + 54) = v66;
      *((_BYTE *)v58 + 440) = v67 | 1;
      os_release(v64);
      if (!singleton)
      {
LABEL_92:
        if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_59_74543);
        }
        singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_transaction_definition_definition);
      }

      uint64_t v69 = v58 + 46;
      *((void *)v58 + 49) = singleton;
      v70 = v218;
      if (v218)
      {
        nw_http_transaction_metadata_set_first_on_connection(singleton);
        singleton = (void *)*((void *)v58 + 49);
      }

      nw_http_transaction_metadata_set_connection_metadata(singleton, *((void **)handle + 156));
      if ((*v69 & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          v177 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v177, OS_LOG_TYPE_DEBUG))
          {
            v178 = (char *)v58 + 636;
            v179 = " ";
            v180 = *(_DWORD *)(*((void *)v58 + 42) + 1280LL);
            v181 = *((void *)v58 + 30);
            if (!v58)
            {
              v179 = "";
              v178 = "";
            }

            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_create";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v178;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&_BYTE buf[24] = v179;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v180;
            *(_WORD *)&buf[38] = 2048;
            *(void *)&buf[40] = v181;
            *(_WORD *)&buf[48] = 2048;
            *(void *)&buf[50] = v58;
            _os_log_impl( &dword_181A5C000,  v177,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> created HTTP/3 stream %p",  buf,  0x3Au);
          }
        }
      }

      if (v44)
      {
        nw_protocol_set_input_handler((uint64_t)v58, v44);
        *uint64_t v58 = *(_OWORD *)v44;
        nw_protocol_set_output_handler(v44, (uint64_t)v58);
        *((void *)v58 + 19) = v58;
        v71 = *(void *)(v44 + 24);
        if (v71)
        {
          v72 = *(uint64_t (**)(uint64_t))(v71 + 176);
          if (v72) {
            *uint64_t v69 = *v69 & 0xFFFE | v72(v44);
          }
        }

        v73 = (void *)*((void *)v58 + 44);
        v74 = (void *)nw_protocol_get_parameters(v44);
        if (v74)
        {
          v75 = v74;
          *((void *)v58 + 44) = os_retain(v74);
          v76 = nw_parameters_copy_context(v73);
          v77 = v75;
          v78 = *(id *)(v77[13] + 136LL);

          if (nw_context_shares_workloop(v76, v78)) {
            goto LABEL_121;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v221;
          *(_WORD *)&buf[22] = 2112;
          *(void *)&_BYTE buf[24] = v78;
          *(_WORD *)&buf[32] = 2112;
          *(void *)&buf[34] = v76;
          v79 = (const char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v228[0] = 0;
          v215 = (char *)v79;
          if (__nwlog_fault(v79, type, v228))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v80 = gLogObj;
              v81 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v221;
                *(_WORD *)&buf[22] = 2112;
                *(void *)&_BYTE buf[24] = v78;
                *(_WORD *)&buf[32] = 2112;
                *(void *)&buf[34] = v76;
                v82 = "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from ht"
                      "tp3_stream, which had workloop %@";
LABEL_116:
                v86 = (os_log_s *)v80;
                v87 = v81;
LABEL_117:
                _os_log_impl(&dword_181A5C000, v86, v87, v82, buf, 0x2Au);
              }
            }

            else if (v228[0])
            {
              v83 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v84 = type[0];
              log = (os_log_s *)gLogObj;
              v85 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
              if (v83)
              {
                if (v85)
                {
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = v221;
                  *(_WORD *)&buf[22] = 2112;
                  *(void *)&_BYTE buf[24] = v78;
                  *(_WORD *)&buf[32] = 2112;
                  *(void *)&buf[34] = v76;
                  *(_WORD *)&buf[42] = 2082;
                  *(void *)&buf[44] = v83;
                  _os_log_impl( &dword_181A5C000,  log,  v84,  "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from http 3_stream, which had workloop %@, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v83);
                goto LABEL_118;
              }

              if (v85)
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v221;
                *(_WORD *)&buf[22] = 2112;
                *(void *)&_BYTE buf[24] = v78;
                *(_WORD *)&buf[32] = 2112;
                *(void *)&buf[34] = v76;
                v82 = "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from ht"
                      "tp3_stream, which had workloop %@, no backtrace";
                v86 = log;
                v87 = v84;
                goto LABEL_117;
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v80 = gLogObj;
              v81 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_add_input_handler";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v221;
                *(_WORD *)&buf[22] = 2112;
                *(void *)&_BYTE buf[24] = v78;
                *(_WORD *)&buf[32] = 2112;
                *(void *)&buf[34] = v76;
                v82 = "%{public}s Incoming http3 stream %p has different workloop on context %@ than original one from ht"
                      "tp3_stream, which had workloop %@, backtrace limit exceeded";
                goto LABEL_116;
              }
            }
          }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_39;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v7 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          char v15 = "nw_protocol_http_early_data_output_available";
          os_log_type_t v16 = 2082;
          __int16 v17 = handle + 114;
          os_log_type_t v18 = 2080;
          uint64_t v19 = " ";
          _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }

    if ((handle[256] & 4) != 0) {
      nw_http_early_data_replay((uint64_t)handle);
    }
    else {
      nw_protocol_output_available(*((void **)handle + 6), (uint64_t)handle);
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v15 = "nw_protocol_http_early_data_output_available";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_protocol_http_early_data_output_available";
    uint64_t v6 = "%{public}s called with null http_early_data";
    goto LABEL_38;
  }

  if (!v12)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    uint64_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_protocol_http_early_data_output_available";
    uint64_t v6 = "%{public}s called with null http_early_data, backtrace limit exceeded";
    goto LABEL_38;
  }

  os_log_type_t v10 = (char *)__nw_create_backtrace_string();
  int v4 = (os_log_s *)__nwlog_obj();
  uint64_t v5 = type;
  BOOL v11 = os_log_type_enabled(v4, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_protocol_http_early_data_output_available";
    uint64_t v6 = "%{public}s called with null http_early_data, no backtrace";
    goto LABEL_38;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    char v15 = "nw_protocol_http_early_data_output_available";
    os_log_type_t v16 = 2082;
    __int16 v17 = v10;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null http_early_data, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v3) {
    goto LABEL_40;
  }
}

  if (v11) {
    free(v11);
  }
  return 0LL;
}

  if (v11) {
    free(v11);
  }
  return 0LL;
}

    if (v24) {
      free(v24);
    }
    uint64_t v19 = 0LL;
    os_log_type_t v18 = v174;
    char v15 = v172;
LABEL_41:
    os_log_type_t v12 = v22;
    uint64_t v14 = v21;
    os_log_type_t v8 = v168;
LABEL_42:
    if (v10) {
      goto LABEL_43;
    }
LABEL_114:
    char v36 = v175;
    if ((v12 & 1) != 0) {
      goto LABEL_139;
    }
    goto LABEL_115;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v179 = "nw_necp_append_tlv";
  v48 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v176 = 0;
  if (__nwlog_fault(v48, &type, &v176))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v49 = (os_log_s *)__nwlog_obj();
      v50 = type;
      if (!os_log_type_enabled(v49, type)) {
        goto LABEL_111;
      }
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v51 = "%{public}s called with null tlv_start";
LABEL_110:
      _os_log_impl(&dword_181A5C000, v49, v50, v51, buf, 0xCu);
      goto LABEL_111;
    }

    if (!v176)
    {
      v49 = (os_log_s *)__nwlog_obj();
      v50 = type;
      if (!os_log_type_enabled(v49, type)) {
        goto LABEL_111;
      }
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v51 = "%{public}s called with null tlv_start, backtrace limit exceeded";
      goto LABEL_110;
    }

    uint64_t v58 = (char *)__nw_create_backtrace_string();
    v49 = (os_log_s *)__nwlog_obj();
    v50 = type;
    v59 = os_log_type_enabled(v49, type);
    if (!v58)
    {
      char v15 = v172;
      if (!v59) {
        goto LABEL_111;
      }
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v51 = "%{public}s called with null tlv_start, no backtrace";
      goto LABEL_110;
    }

    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      v179 = "nw_necp_append_tlv";
      v180 = 2082;
      *(void *)v181 = v58;
      _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v58);
    char v15 = v172;
  }

    if (!v10)
    {
LABEL_46:
      uint64_t v7 = 0LL;
      goto LABEL_47;
    }

            goto LABEL_53;
          }

          if (!v148)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v26 = (os_log_s *)(id)gLogObj;
            uint64_t v33 = type;
            if (os_log_type_enabled(v26, type))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v18;
              *(_WORD *)&buf[22] = 2048;
              v153 = v6;
              v154 = 1024;
              *(_DWORD *)v155 = v22;
              _os_log_impl( &dword_181A5C000,  v26,  v33,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, backtrace limit exceeded",  buf,  0x26u);
            }

            goto LABEL_38;
          }

          os_log_type_t v29 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v30 = (os_log_s *)(id)gLogObj;
          BOOL v31 = type;
          uint64_t v32 = os_log_type_enabled(v30, type);
          if (v29)
          {
            if (v32)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v18;
              *(_WORD *)&buf[22] = 2048;
              v153 = v6;
              v154 = 1024;
              *(_DWORD *)v155 = v22;
              *(_WORD *)&v155[4] = 2082;
              *(void *)&v155[6] = v29;
              _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, dumping backtrace:%{public}s",  buf,  0x30u);
            }

            free(v29);
            if (!v25) {
              goto LABEL_55;
            }
LABEL_54:
            free(v25);
            goto LABEL_55;
          }

          if (v32)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v18;
            *(_WORD *)&buf[22] = 2048;
            v153 = v6;
            v154 = 1024;
            *(_DWORD *)v155 = v22;
            _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, no backtrace",  buf,  0x26u);
          }
        }

      goto LABEL_39;
    }

    if (!v25)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_path_create_browse";
        _os_log_impl( &dword_181A5C000,  v10,  v23,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v21 = type;
    uint64_t v22 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v28 = "nw_path_create_browse";
        _os_log_impl(&dword_181A5C000, v10, v21, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v28 = "nw_path_create_browse";
      os_log_type_t v29 = 2082;
      uint64_t v30 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v21,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_39:
      if (v9) {
        free(v9);
      }
      goto LABEL_41;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null nexus_flow_index, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = type;
    os_log_type_t v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_path_get_nexus_flow_index";
        _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null nexus_flow_index, no backtrace",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_path_get_nexus_flow_index";
      char v26 = 2082;
      unint64_t v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null nexus_flow_index, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = v3[3];
    if (v6)
    {
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_path_flow_registration_remove_extra_interface_option_block_invoke;
      v21[3] = &unk_189BC5080;
      uint64_t v22 = v4;
      os_log_type_t v23 = v3;
      nw_array_remove_objects(v6, (uint64_t)v21);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  unint64_t v27 = "nw_path_flow_registration_remove_extra_interface_option";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  BOOL v25 = OS_LOG_TYPE_ERROR;
  os_log_type_t v24 = 0;
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v27 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null details", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v24)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v27 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null details, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = v25;
  os_log_type_t v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      unint64_t v27 = "nw_path_flow_registration_remove_extra_interface_option";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null details, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v27 = "nw_path_flow_registration_remove_extra_interface_option";
    BOOL v28 = 2082;
    os_log_type_t v29 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null details, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

      free(v9);
      goto LABEL_39;
    }

    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_path_create_from_tlv";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s nw_path_parse_necp_result failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_36;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    __int16 v17 = type;
    os_log_type_t v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_path_create_from_tlv";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s nw_path_parse_necp_result failed, no backtrace", buf, 0xCu);
      }

      goto LABEL_36;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_path_create_from_tlv";
      char v26 = 2082;
      unint64_t v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s nw_path_parse_necp_result failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (unsigned __int8 *)*((void *)v3 + 26);
    if (v6)
    {
      v21[0] = MEMORY[0x1895F87A8];
      v21[1] = 3221225472LL;
      v21[2] = __nw_path_enumerate_gateways_block_invoke;
      v21[3] = &unk_189BC8628;
      uint64_t v22 = v4;
      nw_array_apply(v6, (uint64_t)v21);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_path_enumerate_gateways";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_path_enumerate_gateways";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerate_block", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_path_enumerate_gateways";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerate_block, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_path_enumerate_gateways";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_path_enumerate_gateways";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerate_block, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

  if (a8)
  {
    LOWORD(v61) = v23 | 0x20;
    _BYTE v63[24] = a8;
    if (gLogDatapath)
    {
      __nwlog_obj();
      v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        uint64_t v57 = "nw_path_evaluator_create_flow_inner";
        uint64_t v58 = 1024;
        *(_DWORD *)v59 = a8;
        *(_WORD *)&v59[4] = 1024;
        *(_DWORD *)&v59[6] = v23 | 0x20;
        *(_WORD *)&v59[10] = 2048;
        *(void *)&v59[12] = v25;
        _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s Adding override ip protocol %u, flags %x, length %zu",  buf,  0x22u);
      }
    }

    out[v25] = a8;
  }

  if (necp_client_action())
  {
    BOOL v34 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    __int16 v35 = v16;
    os_unfair_lock_lock((os_unfair_lock_t)v16 + 24);
    char v36 = (NWConcrete_nw_parameters *)*((id *)v16 + 1);
    os_unfair_lock_unlock((os_unfair_lock_t)v16 + 24);

    uint64_t v37 = nw_parameters_copy_description_internal(v36, 1);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v57 = "nw_path_evaluator_create_flow_inner";
      uint64_t v58 = 2112;
      *(void *)v59 = v17;
      *(_WORD *)&v59[8] = 2080;
      *(void *)&v59[10] = v37;
      _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_ERROR,  "%{public}s failed NECP_CLIENT_ACTION_ADD_FLOW %@ evaluator parameters: %s",  buf,  0x20u);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      uint64_t v57 = "nw_path_evaluator_create_flow_inner";
      uint64_t v58 = 1042;
      *(_DWORD *)v59 = 16;
      *(_WORD *)&v59[4] = 2098;
      *(void *)&v59[6] = v16 + 80;
      *(_WORD *)&v59[14] = 1024;
      *(_DWORD *)&v59[16] = v34;
      _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s NECP_CLIENT_ACTION_ADD_FLOW %{public,uuid_t}.16P %{darwin.errno}d",  buf,  0x22u);
    }

    if (v37) {
      free(v37);
    }
    if (a9) {
      *a9 = v34;
    }
    goto LABEL_80;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v40 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136447234;
    uint64_t v57 = "nw_path_evaluator_create_flow_inner";
    uint64_t v58 = 1042;
    *(_DWORD *)v59 = 16;
    *(_WORD *)&v59[4] = 2098;
    *(void *)&v59[6] = &out[16];
    *(_WORD *)&v59[14] = 1042;
    *(_DWORD *)&v59[16] = 16;
    *(_WORD *)&v59[20] = 2098;
    *(void *)&v59[22] = v16 + 80;
    _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_DEBUG,  "%{public}s Added flow %{public,uuid_t}.16P to %{public,uuid_t}.16P",  buf,  0x2Cu);
  }

  BOOL v41 = nw_path_flow_registration_create((NWConcrete_nw_path_evaluator *)v16, &out[16]);
  BOOL v20 = v41;
  if (!v41) {
    goto LABEL_80;
  }
  uint64_t v42 = *((_BYTE *)v41 + 148);
  *((_BYTE *)v41 + 148) = v42 | 1;
  if (a3)
  {
    *((_BYTE *)v41 + 148) = v42 | 5;
    *(_OWORD *)v41->nexus_agent = *(_OWORD *)out;
  }

  if (WORD1(v61))
  {
    os_log_type_t v43 = *(_DWORD **)((char *)&v62 + 4);
    if (*(void *)((char *)&v62 + 4))
    {
      v41->flow_stats_area = *(necp_all_stats **)((char *)&v62 + 4);
      *os_log_type_t v43 = DWORD1(v61);
      v41->flow_stats_area->var0.var0.var0.var1 = DWORD2(v61);
    }
  }

  if (v9) {
    free(v9);
  }
  uint64_t v6 = 0LL;
LABEL_5:

  return v6;
}

    goto LABEL_39;
  }

  if (v4)
  {
    uint64_t v6 = (void *)v3[28];
    if (v6)
    {
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = __nw_path_enumerate_group_options_block_invoke;
      applier[3] = &unk_189BC5208;
      uint64_t v22 = v4;
      xpc_dictionary_apply(v6, applier);
    }

    goto LABEL_5;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_path_enumerate_group_options";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_path_enumerate_group_options";
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null enumerate_block", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (!v23)
  {
    __nwlog_obj();
    int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_path_enumerate_group_options";
      _os_log_impl( &dword_181A5C000,  v9,  v20,  "%{public}s called with null enumerate_block, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_38;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = type;
  os_log_type_t v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_path_enumerate_group_options";
      _os_log_impl(&dword_181A5C000, v9, v17, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }

    goto LABEL_38;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_path_enumerate_group_options";
    unint64_t v27 = 2082;
    BOOL v28 = v16;
    _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s called with null enumerate_block, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_40;
  }
LABEL_5:
}

  BOOL v31 = 0LL;
LABEL_47:

  return v31;
}

  return v8;
}

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_messaging, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_messaging, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_messaging, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http1_options";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_messaging, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_messaging, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_messaging, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http2_options";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_messaging, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_messaging, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_messaging, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_messaging_options_copy_http3_options";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_authentication, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_authentication, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_cache";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_authentication, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_authentication, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_appsso_h1_fallback_headers";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http encoding, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http encoding, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http encoding, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_encoding_options_get_type";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http redirect, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http redirect, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http redirect, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_redirect_options_get_limit";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http retry, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http retry, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http retry, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_retry_options_get_limit";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http security, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http security, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http security, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http security, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http security, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http security, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_security_options_copy_handler_queue";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_cookie_storage";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_cookie_partition_identifier";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_copy_site_for_cookies";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_get_is_top_level_navigation";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    free(v20);
    if (!v10) {
      goto LABEL_8;
    }
    goto LABEL_59;
  }

  v28[0] = MEMORY[0x1895F87A8];
  v28[1] = 3221225472LL;
  v28[2] = __nw_http_metadata_set_method_block_invoke;
  v28[3] = &__block_descriptor_36_e9_B16__0_v8l;
  os_log_type_t v29 = a2;
  os_log_type_t v8 = *((void *)v5 + 4);
  if (v8) {
    __nw_http_metadata_set_method_block_invoke((uint64_t)v28, v8);
  }
LABEL_8:
}

  if (v20) {
    free(v20);
  }
LABEL_40:

  return v4 != 0LL;
}

    free(v20);
    if (!v10) {
      goto LABEL_8;
    }
    goto LABEL_59;
  }

  v28[0] = MEMORY[0x1895F87A8];
  v28[1] = 3221225472LL;
  v28[2] = __nw_http_metadata_set_path_block_invoke;
  v28[3] = &__block_descriptor_40_e9_B16__0_v8l;
  v28[4] = a2;
  os_log_type_t v8 = *((void *)v5 + 4);
  if (v8) {
    __nw_http_metadata_set_path_block_invoke((uint64_t)v28, v8);
  }
LABEL_8:
}

    free(v20);
    if (!v10) {
      goto LABEL_8;
    }
    goto LABEL_59;
  }

  v28[0] = MEMORY[0x1895F87A8];
  v28[1] = 3221225472LL;
  v28[2] = __nw_http_metadata_set_status_block_invoke;
  v28[3] = &__block_descriptor_36_e9_B16__0_v8l;
  os_log_type_t v29 = a2;
  os_log_type_t v8 = *((void *)v5 + 4);
  if (v8) {
    __nw_http_metadata_set_status_block_invoke((uint64_t)v28, v8);
  }
LABEL_8:
}

LABEL_39:
      if (v9) {
        free(v9);
      }
      goto LABEL_41;
    }

    if (!v22)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_http_metadata_is_capsule";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s metadata must be http, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = type;
    os_log_type_t v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_http_metadata_is_capsule";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_http_metadata_is_capsule";
      char v26 = 2082;
      unint64_t v27 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s metadata must be http, dumping backtrace:%{public}s",  buf,  0x16u);
    }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_client, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_client, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_client, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_resend_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

        goto LABEL_39;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s protocol options are not http_client, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_client, no backtrace",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s protocol options are not http_client, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_26;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (__nwlog_fault(v8, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (!v21)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
          _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_38;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      char v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }

        goto LABEL_38;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_client_options_copy_retry_with_h1_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
      }

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_8:

  return v5;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_8:

  return v5;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_8:

  return v5;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_8:

  return v5;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0LL;
LABEL_8:

  return v5;
}

  if (v8) {
    free(v8);
  }
  uint64_t v5 = -1LL;
LABEL_8:

  return v5;
}

    free(v14);
    goto LABEL_39;
  }

  if (!v7)
  {
    __nwlog_obj();
    BOOL v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "-[NWConcrete_nw_endpoint_transform applyWithHandler:toChildren:]";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "-[NWConcrete_nw_endpoint_transform applyWithHandler:toChildren:]";
        _os_log_impl(&dword_181A5C000, v15, v29, "%{public}s called with null applyBlock", buf, 0xCu);
      }

      free(backtrace_string);
    }
  }
  }

  if (v15) {
    free(v15);
  }
LABEL_14:
}

      goto LABEL_39;
    }

    if (!v36)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v35 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
        _os_log_impl( &dword_181A5C000,  v14,  v35,  "%{public}s called with null applyBlock, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v32 = type;
    uint64_t v33 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
        _os_log_impl(&dword_181A5C000, v14, v32, "%{public}s called with null applyBlock, no backtrace", buf, 0xCu);
      }

      goto LABEL_38;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      v39 = "-[NWConcrete_nw_endpoint_flow applyWithHandler:toChildren:]";
      __int16 v40 = 2082;
      BOOL v41 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v32,  "%{public}s called with null applyBlock, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_62;
  }

  else {
    os_log_type_t v10 = 0;
  }
LABEL_42:

  return v10;
}

    if (!v12) {
      goto LABEL_40;
    }
LABEL_39:
    free(v12);
    goto LABEL_40;
  }

  uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    uint64_t v7 = nw_endpoint_handler_copy_flow(v5);
    os_log_type_t v8 = _Block_copy(v4);
    int v9 = (void *)*((void *)v7 + 130);
    *((void *)v7 + 130) = v8;

    if ((*((_BYTE *)v7 + 33) & 4) != 0) {
      nw_endpoint_handler_register_metadata_changed_handler(v5);
    }

    goto LABEL_40;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v10 = (id)gLogObj;
  else {
    BOOL v11 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  uint64_t v32 = "nw_endpoint_handler_set_metadata_changed_handler";
  uint64_t v33 = 2082;
  BOOL v34 = (void *)v11;
  __int16 v35 = 2082;
  char v36 = "flow";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v29 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v13 = (os_log_s *)(id)gLogObj;
    uint64_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      else {
        char v15 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v32 = "nw_endpoint_handler_set_metadata_changed_handler";
      uint64_t v33 = 2082;
      BOOL v34 = (void *)v15;
      __int16 v35 = 2082;
      char v36 = "flow";
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

      if ((*(_WORD *)(a2 + 188) & 0x400) == 0)
      {
        unint64_t v27 = *(void *)(a2 + 32);
        if (v27)
        {
          BOOL v28 = mach_continuous_approximate_time();
          os_log_type_t v29 = v28 <= 1 ? 1LL : v28;
          uint64_t v30 = nw_delta_nanos(v27, v29);
          if (v30 > 1000000000
                   * networkd_settings_get_int64_with_default( (const char *)nw_setting_proxy_setup_threshold_seconds,  5LL))
          {
            BOOL v31 = (unsigned __int16)(*(_WORD *)(a1 + 372))++ + 1;
            if ((v31 & 0x10000) != 0)
            {
              if (gLogDatapath)
              {
                v102 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                {
                  v103 = *(unsigned __int16 *)(a1 + 372);
                  *(_DWORD *)buf = 136446978;
                  v107 = "nw_http2_stream_close";
                  v108 = 2082;
                  v109 = "http2->stream_stall_count";
                  v110 = 2048;
                  v111 = 1LL;
                  v112 = 2048;
                  *(void *)v113 = v103;
                  _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
                }
              }

              *(_WORD *)(a1 + 372) = -1;
            }

            if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v32 = (os_log_s *)gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
              {
                BOOL v34 = *(_DWORD *)(a2 + 176);
                uint64_t v33 = *(_DWORD *)(a2 + 180);
                __int16 v35 = *(unsigned __int16 *)(a1 + 372);
                *(_DWORD *)buf = 136447490;
                v107 = "nw_http2_stream_close";
                v108 = 2082;
                v109 = (const char *)(a2 + 191);
                v110 = 2080;
                v111 = (uint64_t)" ";
                v112 = 1024;
                *(_DWORD *)v113 = v33;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v34;
                v114 = 1024;
                v115 = v35;
                _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%d> stream setup stalls incremented to %u",  buf,  0x32u);
              }
            }
          }
        }
      }

      char v36 = (*(unsigned __int8 *)(a2 + 190) >> 3) & 1;
      if (!gLogDatapath) {
        LOBYTE(v36) = 1;
      }
      if (*(_DWORD *)(a2 + 176) != -1)
      {
        if ((v36 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v92 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v94 = *(_DWORD *)(a2 + 176);
            v93 = *(_DWORD *)(a2 + 180);
            *(_DWORD *)buf = 136447746;
            v107 = "nw_http2_remove_from_id_table";
            v108 = 2082;
            v109 = (const char *)(a2 + 191);
            v110 = 2080;
            v111 = (uint64_t)" ";
            v112 = 1024;
            *(_DWORD *)v113 = v93;
            *(_WORD *)&v113[4] = 1024;
            *(_DWORD *)&v113[6] = v94;
            v114 = 1024;
            v115 = v94;
            v116 = 2048;
            v117 = a2;
            _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> called for stream %d (%p)",  buf,  0x3Cu);
          }
        }

        uint64_t v37 = *(void *)(a1 + 160);
        if (v37)
        {
          node = nw_hash_table_get_node(v37, a2 + 176, 4LL);
          if (node)
          {
            v39 = nw_hash_table_remove_node(*(void *)(a1 + 160), node);
            __int16 v40 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
            if (v39)
            {
              if ((v40 & 0x80000) != 0 || !gLogDatapath) {
                goto LABEL_113;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              BOOL v41 = (os_log_s *)gconnectionLogObj;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_113;
              }
              os_log_type_t v43 = *(_DWORD *)(a2 + 176);
              uint64_t v42 = *(_DWORD *)(a2 + 180);
              *(_DWORD *)buf = 136447490;
              v107 = "nw_http2_remove_from_id_table";
              v108 = 2082;
              v109 = (const char *)(a2 + 191);
              v110 = 2080;
              v111 = (uint64_t)" ";
              v112 = 1024;
              *(_DWORD *)v113 = v42;
              *(_WORD *)&v113[4] = 1024;
              *(_DWORD *)&v113[6] = v43;
              v114 = 1024;
              v115 = v43;
              BOOL v44 = "%{public}s %{public}s%s<i%u:s%d> removed stream %d from id based table";
LABEL_112:
              _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_DEBUG, v44, buf, 0x32u);
LABEL_113:
              if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0
                && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v89 = (os_log_s *)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v91 = *(_DWORD *)(a2 + 176);
                  v90 = *(_DWORD *)(a2 + 180);
                  *(_DWORD *)buf = 136447490;
                  v107 = "nw_http2_stream_close";
                  v108 = 2082;
                  v109 = (const char *)(a2 + 191);
                  v110 = 2080;
                  v111 = (uint64_t)" ";
                  v112 = 1024;
                  *(_DWORD *)v113 = v90;
                  *(_WORD *)&v113[4] = 1024;
                  *(_DWORD *)&v113[6] = v91;
                  v114 = 1024;
                  v115 = v91;
                  _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> removed stream %d from id based table",  buf,  0x32u);
                }
              }

              *int v4 = -1;
              return;
            }

            if ((v40 & 0x80000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v57 = *(_DWORD *)(a2 + 176);
              v56 = *(_DWORD *)(a2 + 180);
              *(_DWORD *)buf = 136447490;
              v107 = "nw_http2_remove_from_id_table";
              v108 = 2082;
              v109 = (const char *)(a2 + 191);
              v110 = 2080;
              v111 = (uint64_t)" ";
              v112 = 1024;
              *(_DWORD *)v113 = v56;
              *(_WORD *)&v113[4] = 1024;
              *(_DWORD *)&v113[6] = v57;
              v114 = 1024;
              v115 = v57;
              uint64_t v58 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              v104 = 0;
              if (type == OS_LOG_TYPE_FAULT)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v59 = (os_log_s *)gconnectionLogObj;
                v60 = type;
                if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                  goto LABEL_105;
                }
                os_log_type_t v62 = *(_DWORD *)(a2 + 176);
                char v61 = *(_DWORD *)(a2 + 180);
                *(_DWORD *)buf = 136447490;
                v107 = "nw_http2_remove_from_id_table";
                v108 = 2082;
                v109 = (const char *)(a2 + 191);
                v110 = 2080;
                v111 = (uint64_t)" ";
                v112 = 1024;
                *(_DWORD *)v113 = v61;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v62;
                v114 = 1024;
                v115 = v62;
                v63 = "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table";
              }

              else if (v104)
              {
                char v64 = (char *)__nw_create_backtrace_string();
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v59 = (os_log_s *)gconnectionLogObj;
                v60 = type;
                v65 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
                if (v64)
                {
                  if (v65)
                  {
                    v67 = *(_DWORD *)(a2 + 176);
                    v66 = *(_DWORD *)(a2 + 180);
                    *(_DWORD *)buf = 136447746;
                    v107 = "nw_http2_remove_from_id_table";
                    v108 = 2082;
                    v109 = (const char *)(a2 + 191);
                    v110 = 2080;
                    v111 = (uint64_t)" ";
                    v112 = 1024;
                    *(_DWORD *)v113 = v66;
                    *(_WORD *)&v113[4] = 1024;
                    *(_DWORD *)&v113[6] = v67;
                    v114 = 1024;
                    v115 = v67;
                    v116 = 2082;
                    v117 = (uint64_t)v64;
                    _os_log_impl( &dword_181A5C000,  v59,  v60,  "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table, dumping backtrace:%{public}s",  buf,  0x3Cu);
                  }

                  free(v64);
                  goto LABEL_105;
                }

                if (!v65)
                {
LABEL_105:
                  if (v58) {
                    free(v58);
                  }
                  goto LABEL_107;
                }

                v71 = *(_DWORD *)(a2 + 176);
                v70 = *(_DWORD *)(a2 + 180);
                *(_DWORD *)buf = 136447490;
                v107 = "nw_http2_remove_from_id_table";
                v108 = 2082;
                v109 = (const char *)(a2 + 191);
                v110 = 2080;
                v111 = (uint64_t)" ";
                v112 = 1024;
                *(_DWORD *)v113 = v70;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v71;
                v114 = 1024;
                v115 = v71;
                v63 = "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table, no backtrace";
              }

              else
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v59 = (os_log_s *)gconnectionLogObj;
                v60 = type;
                if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                  goto LABEL_105;
                }
                uint64_t v69 = *(_DWORD *)(a2 + 176);
                v68 = *(_DWORD *)(a2 + 180);
                *(_DWORD *)buf = 136447490;
                v107 = "nw_http2_remove_from_id_table";
                v108 = 2082;
                v109 = (const char *)(a2 + 191);
                v110 = 2080;
                v111 = (uint64_t)" ";
                v112 = 1024;
                *(_DWORD *)v113 = v68;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v69;
                v114 = 1024;
                v115 = v69;
                v63 = "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table, backtrace limit exceeded";
              }

              _os_log_impl(&dword_181A5C000, v59, v60, v63, buf, 0x32u);
              goto LABEL_105;
            }

  if (v16) {
    free(v16);
  }
LABEL_40:
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v28 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v29 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      __int16 v35 = "nw_http2_send_settings";
      char v36 = 2082;
      uint64_t v37 = a1 + 390;
      v38 = 2080;
      v39 = " ";
      __int16 v40 = 1024;
      BOOL v41 = v29;
      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> submitted settings to nghttp2",  buf,  0x26u);
    }
  }

  nw_http2_session_send(a1);
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v30 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      BOOL v31 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      __int16 v35 = "nw_http2_send_settings";
      char v36 = 2082;
      uint64_t v37 = a1 + 390;
      v38 = 2080;
      v39 = " ";
      __int16 v40 = 1024;
      BOOL v41 = v31;
      _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> nghttp2_session_send complete with settings",  buf,  0x26u);
    }
  }

        uint64_t v33 = (_DWORD *)*(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
        *(_DWORD *)buf = 136446978;
        BOOL v44 = "nw_protocol_test_get_input_frames_block_invoke";
        v45 = 2082;
        v46 = "count";
        v47 = 2048;
        v48 = 1LL;
        v49 = 2048;
        v50 = v33;
        uint64_t v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_39;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v16 = (os_log_s *)gLogObj;
      __int16 v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_40;
      }
LABEL_32:
      uint64_t v32 = (_DWORD *)*(unsigned int *)(*(void *)(a1[5] + 8LL) + 24LL);
      *(_DWORD *)buf = 136446978;
      BOOL v44 = "nw_protocol_test_get_input_frames_block_invoke";
      v45 = 2082;
      v46 = "count";
      v47 = 2048;
      v48 = 1LL;
      v49 = 2048;
      v50 = v32;
      uint64_t v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
      goto LABEL_39;
    }
  }

          if (!v14) {
            return 0LL;
          }
          goto LABEL_39;
        }

        v63 = *(void *)(a1 + 40);
        if (v63 && (*(_BYTE *)(v63 + 136) & 1) != 0) {
          return 0LL;
        }
        __nwlog_obj();
        char v64 = *(void *)(a1 + 40);
        v65 = (const char *)(v64 + 137);
        v66 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        if (v64)
        {
          v67 = " ";
        }

        else
        {
          v65 = "";
          v67 = "";
        }

        v68 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)buf = 136447490;
        v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
        v121 = 2082;
        v122 = v65;
        v123 = 2080;
        v124 = v67;
        v125 = 2048;
        v126 = v64;
        v127 = 1024;
        v128 = v66 + v5;
        v129 = 1024;
        *(_DWORD *)v130 = v68;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v116 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_38;
          }
          uint64_t v69 = *(void *)(a1 + 40);
          v70 = (const char *)(v69 + 137);
          if (v69)
          {
            v71 = " ";
          }

          else
          {
            v70 = "";
            v71 = "";
          }

          v72 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + v5;
          v73 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136447490;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v70;
          v123 = 2080;
          v124 = v71;
          v125 = 2048;
          v126 = v69;
          v127 = 1024;
          v128 = v72;
          v129 = 1024;
          *(_DWORD *)v130 = v73;
          uint64_t v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u)";
        }

        else if (v116)
        {
          v84 = (char *)__nw_create_backtrace_string();
          char v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          v85 = os_log_type_enabled(v15, type);
          if (v84)
          {
            if (v85)
            {
              v86 = *(void *)(a1 + 40);
              v87 = (const char *)(v86 + 137);
              if (v86)
              {
                v88 = " ";
              }

              else
              {
                v87 = "";
                v88 = "";
              }

              v89 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + v5;
              v90 = *(_DWORD *)(a1 + 56);
              *(_DWORD *)buf = 136447746;
              v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
              v121 = 2082;
              v122 = v87;
              v123 = 2080;
              v124 = v88;
              v125 = 2048;
              v126 = v86;
              v127 = 1024;
              v128 = v89;
              v129 = 1024;
              *(_DWORD *)v130 = v90;
              v130[2] = 2082;
              *(void *)&v130[3] = v84;
              _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), dumping backtrace:%{public}s",  buf,  0x40u);
            }

            free(v84);
            if (!v14) {
              return 0LL;
            }
LABEL_39:
            uint64_t v37 = (char *)v14;
LABEL_40:
            free(v37);
            return 0LL;
          }

          if (!v85) {
            goto LABEL_38;
          }
          v111 = *(void *)(a1 + 40);
          v112 = (const char *)(v111 + 137);
          if (v111)
          {
            v113 = " ";
          }

          else
          {
            v112 = "";
            v113 = "";
          }

          v114 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + v5;
          v115 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136447490;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v112;
          v123 = 2080;
          v124 = v113;
          v125 = 2048;
          v126 = v111;
          v127 = 1024;
          v128 = v114;
          v129 = 1024;
          *(_DWORD *)v130 = v115;
          uint64_t v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), no backtrace";
        }

        else
        {
          char v15 = (os_log_s *)__nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_38;
          }
          v97 = *(void *)(a1 + 40);
          v98 = (const char *)(v97 + 137);
          if (v97)
          {
            v99 = " ";
          }

          else
          {
            v98 = "";
            v99 = "";
          }

          v100 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + v5;
          v101 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136447490;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v98;
          v123 = 2080;
          v124 = v99;
          v125 = 2048;
          v126 = v97;
          v127 = 1024;
          v128 = v100;
          v129 = 1024;
          *(_DWORD *)v130 = v101;
          uint64_t v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), backtrace limit exceeded";
        }