LABEL_164:
        if (v27) {
LABEL_165:
        }
          free(v27);
LABEL_166:
        v11 = 0LL;
        goto LABEL_167;
      }

      if (v15) {
        goto LABEL_14;
      }
      __nwlog_obj();
      v69 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v87 = "nw_protocol_definition_allocate_globals";
      v60 = (char *)_os_log_send_and_compose_impl();

      v85 = OS_LOG_TYPE_ERROR;
      type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v60, &v85, &type))
      {
        if (v85 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v70 = v85;
          if (os_log_type_enabled(v61, v85))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_protocol_definition_allocate_globals";
            _os_log_impl( &dword_181A5C000,  v61,  v70,  "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_st ate->allocate_context_globals != __null)",  buf,  0xCu);
          }
        }

        else if (type)
        {
          v72 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v73 = v85;
          v74 = os_log_type_enabled(v61, v85);
          if (v72)
          {
            if (v74)
            {
              *(_DWORD *)buf = 136446466;
              v87 = "nw_protocol_definition_allocate_globals";
              v88 = 2082;
              v89 = v72;
              _os_log_impl( &dword_181A5C000,  v61,  v73,  "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_ state->allocate_context_globals != __null), dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v72);
            if (!v60) {
              goto LABEL_145;
            }
            goto LABEL_144;
          }

          if (v74)
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_protocol_definition_allocate_globals";
            _os_log_impl( &dword_181A5C000,  v61,  v73,  "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_st ate->allocate_context_globals != __null), no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v75 = v85;
          if (os_log_type_enabled(v61, v85))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_protocol_definition_allocate_globals";
            _os_log_impl( &dword_181A5C000,  v61,  v75,  "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_st ate->allocate_context_globals != __null), backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_142;
      }

    goto LABEL_165;
  }

  if (!a2)
  {
    __nwlog_obj();
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
    v52 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v53, v56, "%{public}s called with null snapshot", buf, 0xCu);
      }
    }

    else if (v93)
    {
      v60 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v53, type);
      if (v60)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446466;
          v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
          v97 = 2082;
          v98 = (uint64_t)v60;
          _os_log_impl( &dword_181A5C000,  v53,  v61,  "%{public}s called with null snapshot, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v60);
        if (!v52) {
          goto LABEL_88;
        }
        goto LABEL_166;
      }

      if (v62)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v53, v61, "%{public}s called with null snapshot, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v74 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v53,  v74,  "%{public}s called with null snapshot, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_164;
  }

  nw_context_assert_queue(v9[3]);
  if ((*((_BYTE *)v10 + 109) & 0x40) == 0 || !v10[18]) {
    goto LABEL_88;
  }
  v11 = v10;
  if (!a3)
  {
    __nwlog_obj();
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
    v64 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v66 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v65, v66, "%{public}s called with null snapshot_length", buf, 0xCu);
      }

      goto LABEL_192;
    }

    if (!v93)
    {
      __nwlog_obj();
      v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v89 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v65,  v89,  "%{public}s called with null snapshot_length, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_192;
    }

    v75 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v76 = type;
    v77 = os_log_type_enabled(v65, type);
    if (!v75)
    {
      if (v77)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v65, v76, "%{public}s called with null snapshot_length, no backtrace", buf, 0xCu);
      }

      goto LABEL_192;
    }

    if (v77)
    {
      *(_DWORD *)buf = 136446466;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      v97 = 2082;
      v98 = (uint64_t)v75;
      _os_log_impl( &dword_181A5C000,  v65,  v76,  "%{public}s called with null snapshot_length, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v75);
LABEL_193:
    if (!v64) {
      goto LABEL_8;
    }
    goto LABEL_194;
  }

  if (a4)
  {
    nw_context_assert_queue(v10[3]);
    nw_endpoint_handler_fillout_data_transfer_snapshot(v10[18], a2, a3, a4, a5 ^ 1);
    goto LABEL_8;
  }

  __nwlog_obj();
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
  v64 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v93 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v72 = type;
    if (os_log_type_enabled(v65, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl(&dword_181A5C000, v65, v72, "%{public}s called with null should_release_snapshot", buf, 0xCu);
    }

    if (v54) {
      free(v54);
    }
    goto LABEL_25;
  }

  v15 = nw_context_copy_registered_endpoint_internal(v17, v13, 0);

  if (gLogDatapath)
  {
    __nwlog_obj();
    v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
    {
      v64 = *(void *)(v7 + 16);
      *(_DWORD *)buf = 136448002;
      v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      v87 = 2112;
      v88 = v8;
      v89 = 2048;
      v90 = v7;
      v91 = 2080;
      v92 = v64;
      v93 = 2112;
      v94 = v13;
      v95 = 2048;
      v96 = v13;
      v97 = 2112;
      v98 = v15;
      v99 = 2048;
      v100 = v15;
      _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s replacing unregistered endpoint %@ (%p) with endpoint %@ (%p)",  buf,  0x52u);
    }
  }

LABEL_11:
  v18 = v10;
  v19 = (v18[231] & 4) == 0;

  if (v19)
  {
    v20 = v12;
    v21 = *(id *)(v20[13] + 136LL);

    if (v21)
    {
      v22 = nw_context_copy_registered_endpoint_internal(v21, v18, 0);

      if (gLogDatapath)
      {
        __nwlog_obj();
        log = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          v67 = *(void *)(v7 + 16);
          *(_DWORD *)buf = 136448002;
          v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          v87 = 2112;
          v88 = v8;
          v89 = 2048;
          v90 = v7;
          v91 = 2080;
          v92 = v67;
          v93 = 2112;
          v94 = v18;
          v95 = 2048;
          v96 = v18;
          v97 = 2112;
          v98 = v22;
          v99 = 2048;
          v100 = v22;
          _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s replacing unregistered endpoint %@ (%p) with endpoint %@ (%p)",  buf,  0x52u);
        }
      }

      goto LABEL_16;
    }

    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
    v60 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (__nwlog_fault(v60, &type, &v83))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v62 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136446210;
          v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl(&dword_181A5C000, v61, v62, "%{public}s called with null context", buf, 0xCu);
        }
      }

      else if (v83)
      {
        v71 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v72 = type;
        v73 = os_log_type_enabled(v61, type);
        if (v71)
        {
          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
            v87 = 2082;
            v88 = v71;
            _os_log_impl( &dword_181A5C000,  v61,  v72,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v71);
          goto LABEL_169;
        }

        if (v73)
        {
          *(_DWORD *)buf = 136446210;
          v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl(&dword_181A5C000, v61, v72, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v81 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136446210;
          v86 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
          _os_log_impl( &dword_181A5C000,  v61,  v81,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

          goto LABEL_165;
        }

        if (!v93)
        {
          __nwlog_obj();
          v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v83 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            v84 = *(const char **)(v30 + 16);
            if (!v84) {
              v84 = "invalid";
            }
            *(_DWORD *)v105 = 136446722;
            *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v105[12] = 2082;
            *(void *)&v105[14] = v84;
            *(_WORD *)&v105[22] = 2048;
            v106 = (const char *)v30;
            _os_log_impl( &dword_181A5C000,  v56,  v83,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  v105,  0x20u);
          }

          goto LABEL_164;
        }

        v68 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v69 = type[0];
        v70 = os_log_type_enabled(v56, type[0]);
        if (!v68)
        {
          if (v70)
          {
            v87 = *(const char **)(v30 + 16);
            if (!v87) {
              v87 = "invalid";
            }
            *(_DWORD *)v105 = 136446722;
            *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v105[12] = 2082;
            *(void *)&v105[14] = v87;
            *(_WORD *)&v105[22] = 2048;
            v106 = (const char *)v30;
            _os_log_impl( &dword_181A5C000,  v56,  v69,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  v105,  0x20u);
          }

          goto LABEL_164;
        }

        if (v70)
        {
          v71 = *(const char **)(v30 + 16);
          if (!v71) {
            v71 = "invalid";
          }
          *(_DWORD *)v105 = 136446978;
          *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
          *(_WORD *)&v105[12] = 2082;
          *(void *)&v105[14] = v71;
          *(_WORD *)&v105[22] = 2048;
          v106 = (const char *)v30;
          LOWORD(v107) = 2082;
          *(void *)((char *)&v107 + 2) = v68;
          _os_log_impl( &dword_181A5C000,  v56,  v69,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  v105,  0x2Au);
        }

        free(v68);
      }

    free(backtrace_string);
    goto LABEL_93;
  }

  v6 = strlen(name);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v107 = "nw_endpoint_create_bonjour_service";
    v108 = 2082;
    v109 = "name";
    v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)(id)gLogObj;
      v11 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        v108 = 2082;
        v109 = "name";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s invalid empty string %{public}s", buf, 0x16u);
      }

      goto LABEL_92;
    }

    if (!LOBYTE(v95.receiver))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (os_log_s *)(id)gLogObj;
      v19 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        v108 = 2082;
        v109 = "name";
        _os_log_impl( &dword_181A5C000,  v10,  v19,  "%{public}s invalid empty string %{public}s, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_92;
    }

    v13 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (os_log_s *)(id)gLogObj;
    v14 = typea[0];
    v15 = os_log_type_enabled(v10, typea[0]);
    if (!v13)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        v108 = 2082;
        v109 = "name";
        _os_log_impl(&dword_181A5C000, v10, v14, "%{public}s invalid empty string %{public}s, no backtrace", buf, 0x16u);
      }

      goto LABEL_92;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      v108 = 2082;
      v109 = "name";
      v110 = 2082;
      v111 = v13;
      _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    goto LABEL_41;
  }

  if (v6 >= 0x400)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      v108 = 2082;
      v109 = "name";
      v110 = 1024;
      LODWORD(v111) = 1024;
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", buf, 0x1Cu);
    }

  __break(1u);
}

          free((void *)v83);
          goto LABEL_165;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = "nw_webtransport_stream_destroy";
        v83 = _os_log_send_and_compose_impl();
        v149 = OS_LOG_TYPE_ERROR;
        v148 = 0;
        if (v149 == OS_LOG_TYPE_FAULT)
        {
          v98 = (os_log_s *)__nwlog_obj();
          v99 = v149;
          if (os_log_type_enabled(v98, v149))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = "nw_webtransport_stream_destroy";
            v100 = v98;
            v101 = v99;
            v102 = "%{public}s called with null webtransport_stream";
            goto LABEL_180;
          }

          goto LABEL_183;
        }

        if (v111 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v97 = type[0];
          if (os_log_type_enabled(v66, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v116 = "nw_necp_append_tlv";
            _os_log_impl( &dword_181A5C000,  v66,  v97,  "%{public}s called with null beyond, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_164;
        }

        v80 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v84 = type[0];
        v85 = os_log_type_enabled(v81, type[0]);
        if (v80)
        {
          if (v85)
          {
            *(_DWORD *)buf = 136446466;
            v116 = "nw_necp_append_tlv";
            v117 = 2082;
            v118 = (size_t)v80;
            _os_log_impl( &dword_181A5C000,  v81,  v84,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  buf,  0x16u);
          }

    if (!v49) {
      goto LABEL_61;
    }
    v35 = (char *)v49;
    goto LABEL_60;
  }

  v10 = *(void *)(a1 + 40);
  if (!v10)
  {
    __nwlog_obj();
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v95 = "nw_necp_append_tlv";
    v49 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v90 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v49, type, &v90))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v53 = type[0];
        if (os_log_type_enabled(v50, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v95 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v50, v53, "%{public}s called with null beyond", buf, 0xCu);
        }

    free(backtrace_string);
    goto LABEL_177;
  }

  if (v15->state == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v91 = "nw_service_connector_verify_read_succeeded";
      v92 = 2114;
      v93 = v15;
      v94 = 2082;
      *(void *)v95 = a8;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring %{public}s read data",  buf,  0x20u);
    }

    nw_connection_cancel(v16);
    goto LABEL_92;
  }

  if (!v17)
  {
    v21 = 0;
    if (data) {
      goto LABEL_27;
    }
LABEL_11:
    if (v21) {
      goto LABEL_27;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v23 = "in";
      *(_DWORD *)buf = 136447490;
      v91 = "nw_service_connector_verify_read_succeeded";
      v92 = 2114;
      v93 = v15;
      if (a6) {
        v23 = "";
      }
      v94 = 2082;
      *(void *)v95 = v23;
      v24 = "incoming";
      *(_WORD *)&v95[8] = 2082;
      if (!a3) {
        v24 = "outgoing";
      }
      *(void *)&v95[10] = a8;
      *(_WORD *)&v95[18] = 2082;
      *(void *)&v95[20] = v24;
      *(_WORD *)&v95[28] = 2114;
      *(void *)&v95[30] = v16;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received %{public}scomplete empty %{public}s read on %{public}s %{public}@",  buf,  0x3Eu);
    }

    if ((a6 & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = (id)gLogObj;
      *(_DWORD *)buf = 136446722;
      v91 = "nw_service_connector_verify_read_succeeded";
      if (a3) {
        v26 = "incoming";
      }
      else {
        v26 = "outgoing";
      }
      v92 = 2082;
      v93 = (void *)v26;
      v94 = 2082;
      *(void *)v95 = a8;
      v27 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v88 = 0;
      if (!__nwlog_fault(v27, &type, &v88))
      {
LABEL_70:
        if (!v27) {
          goto LABEL_72;
        }
        goto LABEL_71;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (os_log_s *)(id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          v91 = "nw_service_connector_verify_read_succeeded";
          v92 = 2082;
          v93 = (void *)v26;
          v94 = 2082;
          *(void *)v95 = a8;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s %{public}s %{public}s read got no error no data but not complete failed",  buf,  0x20u);
        }

  if (v51) {
    free(v51);
  }
}

    v72 = v309;
LABEL_195:
    if (((1LL << v79) & 0x3C) != 0 && ((1LL << v83) & 0x78) != 0)
    {
      v122 = 0;
      if ((_DWORD)v63)
      {
        v122 = 0;
        v123 = v313;
        if (v280 < 2) {
          goto LABEL_460;
        }
        v124 = 0;
        v125 = 0;
        v126 = v271;
        v127 = v276;
        do
        {
          v128 = *(v126 - 1);
          v129 = *v126;
          v126 += 2;
          v124 += encode_table[2 * v128 + 1];
          v125 += encode_table[2 * v129 + 1];
          v127 -= 2LL;
        }

        while (v127);
        v122 = v125 + v124;
        v123 = v270;
        if (v280 != v276)
        {
LABEL_460:
          do
          {
            v130 = *v123++;
            v122 += encode_table[2 * v130 + 1];
          }

          while ((unint64_t)v123 < v71);
        }
      }

      v131 = 0;
      v132 = v122 >> 3;
      v133 = (v122 & 7) != 0;
      if (__n)
      {
        v131 = 0;
        v134 = v307;
        if (v281 < 2) {
          goto LABEL_461;
        }
        v135 = 0;
        v136 = 0;
        v137 = v273;
        v138 = v277;
        do
        {
          v139 = *(v137 - 1);
          v140 = *v137;
          v137 += 2;
          v135 += encode_table[2 * v139 + 1];
          v136 += encode_table[2 * v140 + 1];
          v138 -= 2LL;
        }

        while (v138);
        v131 = v136 + v135;
        v134 = v272;
        if (v281 != v277)
        {
LABEL_461:
          do
          {
            v141 = *v134++;
            v131 += encode_table[2 * v141 + 1];
          }

          while ((unint64_t)v134 < v69);
        }
      }

      v142 = v132 + *(_DWORD *)(v68 + 196) + v133 + (v131 >> 3);
      if ((v131 & 7) != 0) {
        ++v142;
      }
      if ((float)((float)v142 / (float)(v283 + *(_DWORD *)(v68 + 192))) > 0.95)
      {
        if (!(_DWORD)v26) {
          __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1917, "index");
        }
        v143 = *(FILE **)(v68 + 200);
        if (v143)
        {
          v144 = v82;
          fwrite("qenc: debug: ", 0xDuLL, 1uLL, v143);
          fwrite("double lit would result in ratio > 0.95, reset", 0x2EuLL, 1uLL, *(FILE **)(v68 + 200));
          fputc(10, *(FILE **)(v68 + 200));
          LODWORD(v26) = 0;
          LODWORD(v295) = v144;
        }

        else
        {
          LODWORD(v26) = 0;
          LODWORD(v295) = v82;
        }

        goto LABEL_344;
      }
    }

    v145 = v64;
    v146 = v83;
    v294 = v81;
    v295 = v80;
    v147 = *(FILE **)(v68 + 200);
    v303 = v82;
    if (v147)
    {
      v148 = v79;
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v147);
      fprintf( *(FILE **)(v68 + 200),  "program: %s; %s; %s; flags: 0x%X",
        eea2str[v148],
        eha2str[v146],
        eta2str[v295],
        v294);
      fputc(10, *(FILE **)(v68 + 200));
      v82 = v303;
      v79 = v148;
    }

    v149 = &v296[v297];
    switch(v79)
    {
      case 0LL:
        break;
      case 1LL:
        if (v297 < 1) {
          goto LABEL_317;
        }
        *v296 = 0;
        v158 = *(_DWORD *)v68 - v82;
        if (v158 > 0x1E)
        {
          *v296 = 31;
          v179 = v296 + 1;
          v180 = v158 - 31;
          if (v158 - 31 < 0x80)
          {
            LOBYTE(v158) = v158 - 31;
            v182 = v296;
            if (v179 >= v298) {
              goto LABEL_317;
            }
          }

          else
          {
            do
            {
              if (v179 >= v298) {
                goto LABEL_317;
              }
              *v179++ = v180 | 0x80;
              v158 = v180 >> 7;
              v181 = v180 >> 14;
              v180 >>= 7;
            }

            while (v181);
            v182 = v179 - 1;
            if (v179 >= v298) {
              goto LABEL_317;
            }
          }

          v159 = v182 + 2;
          *v179 = v158;
          if (v159 <= v296) {
            goto LABEL_317;
          }
        }

        else
        {
          *v296 = *(_BYTE *)v68 - v82;
          v159 = v296 + 1;
        }

        v79 = v159 - v296;
        if (v146 > 6) {
LABEL_445:
        }
          __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2075, "prog.ep_hea_action == EHA_LIT_WITH_NAME_STAT");
        break;
      case 2LL:
        if (v297 < 1) {
          goto LABEL_317;
        }
        *v296 = -64;
        if (v82 > 0x3E)
        {
          *v296 = -1;
          v183 = v296 + 1;
          v184 = v82 - 63LL;
          if (v184 >= 0x80)
          {
            while (v183 < v298)
            {
              *v183++ = v184 | 0x80;
              v185 = v184 >> 7;
              v187 = v184 >> 14;
              v184 >>= 7;
              if (!v187) {
                goto LABEL_279;
              }
            }

    _os_crash();
    __break(1u);
  }

            if (v106) {
              free(v106);
            }
            v8 = &qword_18C45F000;
            goto LABEL_167;
          }

          v88 += 40 * (v92 & 0xFFFFFFFFFFFFFFELL);
        }

        do
        {
          v98 = *((void *)v88 + 1) + v90;
          *(void *)v88 += v90;
          *((void *)v88 + 1) = v98;
          v88 += 40;
        }

        while (v88 != v89);
        goto LABEL_122;
      }

      if (v354[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v282 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v285 = v354[0];
        if (os_log_type_enabled(v282, v354[0]))
        {
          LODWORD(v374[0]) = 136446210;
          *(void *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_181A5C000, v282, v285, "%{public}s metadata must be http", (uint8_t *)v374, 0xCu);
        }

      _os_log_impl(&dword_181A5C000, v100, v101, v102, buf, 0xCu);
      goto LABEL_165;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v98 = gLogObj;
    v99 = type[0];
    if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      v254 = "nw_channel_add_input_frames";
      v100 = (os_log_s *)v98;
      v101 = v99;
      v102 = "%{public}s failed to get buflet from packet";
      goto LABEL_164;
    }

void sub_181B35980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_get_logging_disabled(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 124) == 4;
  }
  return result;
}

int *nw_path_flow_registration_get_stats_area(uint64_t a1, int a2)
{
  *(void *)&v33[13] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_flow_registration_get_stats_area";
    v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v21, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null registration", buf, 0xCu);
        }
      }

      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v31 = "nw_path_flow_registration_get_stats_area";
            __int16 v32 = 2082;
            *(void *)v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v25,  "%{public}s called with null registration, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }

        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null registration, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl( &dword_181A5C000,  v22,  v27,  "%{public}s called with null registration, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B35FC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nwlog_is_datapath_logging_enabled()
{
  return gLogDatapath;
}

BOOL nw_tcp_options_get_no_delay(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_no_delay_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_delay";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_delay";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_delay";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_delay";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_delay";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B362E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_no_delay_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 36) & 2) != 0;
  return 1LL;
}

BOOL nw_tcp_options_get_reduce_buffering(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_reduce_buffering_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reduce_buffering";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reduce_buffering";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reduce_buffering";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reduce_buffering";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reduce_buffering";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B3662C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_reduce_buffering_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 36) & 1;
  return 1LL;
}

BOOL nw_tcp_options_get_disable_blackhole_detection(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_disable_blackhole_detection_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B36974( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_disable_blackhole_detection_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 37) & 1;
  return 1LL;
}

uint64_t nw_tcp_options_get_enable_l4s(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_enable_l4s_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_l4s";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_l4s";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_l4s";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_l4s";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_l4s";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B36CB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_enable_l4s_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 32);
  return 1LL;
}

BOOL nw_parameters_get_fast_open_enabled(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = parameters;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (v1[96] >> 2) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_fast_open_enabled";
  v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_fast_open_enabled";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_fast_open_enabled";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_fast_open_enabled";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_fast_open_enabled";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_tcp_options_get_fast_open_force_enable(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_fast_open_force_enable_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B37290( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_fast_open_force_enable_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_WORD *)(a2 + 36) & 0x4000) != 0;
  return 1LL;
}

uint64_t nw_path_get_effective_traffic_class(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_path_get_effective_traffic_class";
    int v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_get_effective_traffic_class";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            char v16 = "nw_path_get_effective_traffic_class";
            __int16 v17 = 2082;
            id v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_get_effective_traffic_class";
          _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_get_effective_traffic_class";
          _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B37588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_enable_background_traffic_management(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_enable_background_traffic_management_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B3789C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_enable_background_traffic_management_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_WORD *)(a2 + 36) & 0x200) != 0;
  return 1LL;
}

BOOL nw_tcp_options_get_enable_keepalive(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_enable_keepalive_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_keepalive";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_keepalive";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_keepalive";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_keepalive";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_enable_keepalive";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B37BE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_enable_keepalive_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 36) & 0x20) != 0;
  return 1LL;
}

BOOL nw_tcp_options_get_disable_ack_stretching(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_disable_ack_stretching_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ack_stretching";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ack_stretching";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ack_stretching";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ack_stretching";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_disable_ack_stretching";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B37F2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_disable_ack_stretching_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_WORD *)(a2 + 36) & 0x80) != 0;
  return 1LL;
}

BOOL nw_tcp_options_get_no_push(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_no_push_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_push";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_push";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_push";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_push";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_push";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B38274( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_no_push_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 36) & 8) != 0;
  return 1LL;
}

BOOL nw_tcp_options_get_no_options(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_no_options_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B385BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_no_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 36) & 0x10) != 0;
  return 1LL;
}

BOOL nw_tcp_options_get_no_timewait(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_no_timewait_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_timewait";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_timewait";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_timewait";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_timewait";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_timewait";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B38904( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_no_timewait_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 36) & 4) != 0;
  return 1LL;
}

uint64_t nw_tcp_options_get_maximum_segment_size(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_maximum_segment_size_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_maximum_segment_size";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_maximum_segment_size";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_maximum_segment_size";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_maximum_segment_size";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_maximum_segment_size";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B38C44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_maximum_segment_size_block_invoke(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *a2;
  return 1LL;
}

uint64_t nw_tcp_options_get_retransmit_connection_drop_time(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_retransmit_connection_drop_time_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B38F80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_retransmit_connection_drop_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 12);
  return 1LL;
}

BOOL nw_tcp_options_get_retransmit_fin_drop(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_retransmit_fin_drop_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B392C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_retransmit_fin_drop_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_WORD *)(a2 + 36) & 0x400) != 0;
  return 1LL;
}

uint64_t nw_tcp_options_get_connection_timeout(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_connection_timeout_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B39604( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_connection_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 4);
  return 1LL;
}

uint64_t nw_tcp_options_get_persist_timeout(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_tcp_options_get_persist_timeout_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_persist_timeout";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_persist_timeout";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_tcp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_persist_timeout";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_persist_timeout";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_persist_timeout";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B39940( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_persist_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 8);
  return 1LL;
}

uint64_t nw_protocol_ip_create(const nw_protocol_identifier *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  BOOL logging_disabled = nw_parameters_get_logging_disabled((uint64_t)a3);
  int address_family = nw_endpoint_get_address_family(a2);
  if (address_family == 30)
  {
    if (nw_protocol_ip_identifier::onceToken[0] != -1) {
      dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
    }
    uint64_t v8 = nw_protocol_new( 248LL,  (uint64_t)a3,  (uint64_t)&nw_protocol_ip_identifier::identifier,  nw_protocol_ipv6_callbacks(void)::callbacks);
    *(void *)(v8 + 8_Block_object_dispose(va, 8) = 0LL;
    *(void *)(v8 + 96) = v8 + 88;
    *(void *)(v8 + 104) = 0LL;
    *(void *)(v8 + 112) = v8 + 104;
    *(void *)(v8 + 120) = 0LL;
    *(void *)(v8 + 12_Block_object_dispose(va, 8) = v8 + 120;
    *(_DWORD *)(v8 + 152) = 4000;
    *(_BYTE *)(v8 + 15_Block_object_dispose(va, 8) = *(_BYTE *)(v8 + 158) & 0xFE | logging_disabled;
    goto LABEL_13;
  }

  int v7 = address_family;
  if (address_family == 2)
  {
    if (nw_protocol_ip_identifier::onceToken[0] != -1) {
      dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
    }
    uint64_t v8 = nw_protocol_new( 224LL,  (uint64_t)a3,  (uint64_t)&nw_protocol_ip_identifier::identifier,  nw_protocol_ipv4_callbacks(void)::callbacks);
    *(void *)(v8 + 64) = 0LL;
    *(void *)(v8 + 72) = v8 + 64;
    *(void *)(v8 + 80) = 0LL;
    *(void *)(v8 + 8_Block_object_dispose(va, 8) = v8 + 80;
    *(void *)(v8 + 96) = 0LL;
    *(void *)(v8 + 104) = v8 + 96;
    *(_DWORD *)(v8 + 112) = 4000;
    *(_BYTE *)(v8 + 136) = *(_BYTE *)(v8 + 136) & 0xFE | logging_disabled;
LABEL_13:
    if (v8) {
      return v8 - 96;
    }
    else {
      return 0LL;
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  uint64_t v19 = "nw_protocol_ip_create";
  __int16 v20 = 1024;
  int v21 = v7;
  BOOL v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = "nw_protocol_ip_create";
        __int16 v20 = 1024;
        int v21 = v7;
        char v13 = "%{public}s Invalid address family %u";
LABEL_29:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0x12u);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v19 = "nw_protocol_ip_create";
          __int16 v20 = 1024;
          int v21 = v7;
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s Invalid address family %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_30;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = "nw_protocol_ip_create";
        __int16 v20 = 1024;
        int v21 = v7;
        char v13 = "%{public}s Invalid address family %u, no backtrace";
        goto LABEL_29;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = "nw_protocol_ip_create";
        __int16 v20 = 1024;
        int v21 = v7;
        char v13 = "%{public}s Invalid address family %u, backtrace limit exceeded";
        goto LABEL_29;
      }
    }
  }

uint64_t nw_protocol_ipv4_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v141 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v131 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v131)
      {
        v38 = (os_log_s *)__nwlog_obj();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          v134 = "nw_protocol_ipv4_add_input_handler";
          v40 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_298;
        }

        goto LABEL_299;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v48 = os_log_type_enabled(v38, type);
      if (!backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          v134 = "nw_protocol_ipv4_add_input_handler";
          v40 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_298;
        }

        goto LABEL_299;
      }

      if (!v48) {
        goto LABEL_112;
      }
      *(_DWORD *)buf = 136446466;
      v134 = "nw_protocol_ipv4_add_input_handler";
      __int16 v135 = 2082;
      v136 = (nw_protocol_identifier *)backtrace_string;
      v49 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_111;
    }

    v38 = (os_log_s *)__nwlog_obj();
    os_log_type_t v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_299;
    }
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v40 = "%{public}s called with null protocol";
LABEL_298:
    _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, 0xCu);
    goto LABEL_299;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v131 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v131)
      {
        v38 = (os_log_s *)__nwlog_obj();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          v134 = "nw_protocol_ipv4_add_input_handler";
          v40 = "%{public}s called with null ipv4, backtrace limit exceeded";
          goto LABEL_298;
        }

        goto LABEL_299;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v50 = os_log_type_enabled(v38, type);
      if (!backtrace_string)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          v134 = "nw_protocol_ipv4_add_input_handler";
          v40 = "%{public}s called with null ipv4, no backtrace";
          goto LABEL_298;
        }

        goto LABEL_299;
      }

      if (!v50) {
        goto LABEL_112;
      }
      *(_DWORD *)buf = 136446466;
      v134 = "nw_protocol_ipv4_add_input_handler";
      __int16 v135 = 2082;
      v136 = (nw_protocol_identifier *)backtrace_string;
      v49 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_111;
    }

    v38 = (os_log_s *)__nwlog_obj();
    os_log_type_t v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_299;
    }
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v40 = "%{public}s called with null ipv4";
    goto LABEL_298;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v131 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v131)
      {
        v38 = (os_log_s *)__nwlog_obj();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          v134 = "nw_protocol_ipv4_add_input_handler";
          v40 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_298;
        }

        goto LABEL_299;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v51 = os_log_type_enabled(v38, type);
      if (!backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446210;
          v134 = "nw_protocol_ipv4_add_input_handler";
          v40 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_298;
        }

        goto LABEL_299;
      }

      if (!v51) {
        goto LABEL_112;
      }
      *(_DWORD *)buf = 136446466;
      v134 = "nw_protocol_ipv4_add_input_handler";
      __int16 v135 = 2082;
      v136 = (nw_protocol_identifier *)backtrace_string;
      v49 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_111;
    }

    v38 = (os_log_s *)__nwlog_obj();
    os_log_type_t v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_299;
    }
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v40 = "%{public}s called with null input_protocol";
    goto LABEL_298;
  }

  if (a1->default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v131 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_299;
      }
      *(_DWORD *)buf = 136446210;
      v134 = "nw_protocol_ipv4_add_input_handler";
      v40 = "%{public}s Default input handler already exists";
      goto LABEL_298;
    }

    if (!v131)
    {
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_ipv4_add_input_handler";
        v40 = "%{public}s Default input handler already exists, backtrace limit exceeded";
        goto LABEL_298;
      }

      goto LABEL_299;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = (os_log_s *)__nwlog_obj();
    os_log_type_t v39 = type;
    BOOL v52 = os_log_type_enabled(v38, type);
    if (!backtrace_string)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_ipv4_add_input_handler";
        v40 = "%{public}s Default input handler already exists, no backtrace";
        goto LABEL_298;
      }

      goto LABEL_299;
    }

    if (!v52) {
      goto LABEL_112;
    }
    *(_DWORD *)buf = 136446466;
    v134 = "nw_protocol_ipv4_add_input_handler";
    __int16 v135 = 2082;
    v136 = (nw_protocol_identifier *)backtrace_string;
    v49 = "%{public}s Default input handler already exists, dumping backtrace:%{public}s";
LABEL_111:
    _os_log_impl(&dword_181A5C000, v38, v39, v49, buf, 0x16u);
    goto LABEL_112;
  }

  if (a2->identifier) {
    identifier = a2->identifier;
  }
  else {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  if (!strncmp(identifier->name, "quic", 4uLL))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_ipv4_add_input_handler";
    v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v131 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_ipv4_add_input_handler";
        v40 = "%{public}s Attempt to add quic to ip";
        goto LABEL_298;
      }

LABEL_299:
      if (v37) {
        free(v37);
      }
      return 0LL;
    }

    if (!v131)
    {
      v38 = (os_log_s *)__nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_ipv4_add_input_handler";
        v40 = "%{public}s Attempt to add quic to ip, backtrace limit exceeded";
        goto LABEL_298;
      }

      goto LABEL_299;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = (os_log_s *)__nwlog_obj();
    os_log_type_t v39 = type;
    BOOL v53 = os_log_type_enabled(v38, type);
    if (!backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_ipv4_add_input_handler";
        v40 = "%{public}s Attempt to add quic to ip, no backtrace";
        goto LABEL_298;
      }

      goto LABEL_299;
    }

    if (v53)
    {
      *(_DWORD *)buf = 136446466;
      v134 = "nw_protocol_ipv4_add_input_handler";
      __int16 v135 = 2082;
      v136 = (nw_protocol_identifier *)backtrace_string;
      v49 = "%{public}s Attempt to add quic to ip, dumping backtrace:%{public}s";
      goto LABEL_111;
    }

      if (v35) {
LABEL_300:
      }
        free(v35);
LABEL_100:
      if (v30 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
      {
        BOOL v51 = a1[1].callbacks;
        if (v51)
        {
          BOOL v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
          a1[1].callbacks = v52;
          if (!v52)
          {
            BOOL v53 = *(void (***)(void))a1[1].flow_id;
            if (v53)
            {
              *(void *)a1[1].flow_id = 0LL;
              v53[2](v53);
              _Block_release(v53);
            }

            if ((a1[1].flow_id[8] & 1) != 0)
            {
              v54 = *(const void **)a1[1].flow_id;
              if (v54) {
                _Block_release(v54);
              }
            }

            free(a1);
          }
        }
      }

      if (v28 == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
      {
        v55 = a2[1].callbacks;
        if (v55)
        {
          v56 = (nw_protocol_callbacks *)((char *)v55 - 1);
          a2[1].callbacks = v56;
          if (!v56)
          {
            v57 = *(void (***)(void))a2[1].flow_id;
            if (v57)
            {
              *(void *)a2[1].flow_id = 0LL;
              v57[2](v57);
              _Block_release(v57);
            }

            if ((a2[1].flow_id[8] & 1) != 0)
            {
              v58 = *(const void **)a2[1].flow_id;
              if (v58) {
                _Block_release(v58);
              }
            }

            os_log_type_t v27 = a2;
            goto LABEL_121;
          }
        }
      }

      return;
    }

                free(v113);
                goto LABEL_171;
              }

              __nwlog_obj();
              v112 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
              v113 = (char *)_os_log_send_and_compose_impl();

              v177 = OS_LOG_TYPE_ERROR;
              v176 = 0;
              if (v177 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                os_log_type_t v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v115 = v177;
                if (os_log_type_enabled(v114, v177))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                  _os_log_impl(&dword_181A5C000, v114, v115, "%{public}s called with null group", buf, 0xCu);
                }
              }

              else if (v176)
              {
                v130 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                os_log_type_t v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                char v131 = v177;
                v132 = os_log_type_enabled(v114, v177);
                if (v130)
                {
                  if (v132)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v130;
                    _os_log_impl( &dword_181A5C000,  v114,  v131,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v130);
                  goto LABEL_298;
                }

                if (v132)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                  _os_log_impl( &dword_181A5C000,  v114,  v131,  "%{public}s called with null group, no backtrace",  buf,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                os_log_type_t v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v146 = v177;
                if (os_log_type_enabled(v114, v177))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection";
                  _os_log_impl( &dword_181A5C000,  v114,  v146,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
                }
              }

      if (!v111) {
        goto LABEL_319;
      }
      v146 = *(void *)(*((void *)&uu + 1) + 24LL);
      if (v146)
      {
        v147 = v129;
        while (*v147)
        {
          ++v147;
          if (!--v146) {
            goto LABEL_308;
          }
        }

        if (v146 >= 2) {
          *v147++ = 44;
        }
        *v147 = 0;
      }

    if (!v114) {
      goto LABEL_301;
    }
    goto LABEL_300;
  }

  BOOL v15 = *((void *)handle + 1);
  if (!v15)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v178 = "nw_http1_get_http1_protocol";
    os_log_type_t v114 = (char *)_os_log_send_and_compose_impl();
    v176 = OS_LOG_TYPE_ERROR;
    v175 = 0;
    if (v176 == OS_LOG_TYPE_FAULT)
    {
      v115 = (os_log_s *)__nwlog_obj();
      v116 = v176;
      if (!os_log_type_enabled(v115, v176)) {
        goto LABEL_299;
      }
      *(_DWORD *)buf = 136446210;
      v178 = "nw_http1_get_http1_protocol";
      v117 = "%{public}s called with null handle->http1_stream";
      goto LABEL_298;
    }

    if (!v175)
    {
      v115 = (os_log_s *)__nwlog_obj();
      v116 = v176;
      if (!os_log_type_enabled(v115, v176)) {
        goto LABEL_299;
      }
      *(_DWORD *)buf = 136446210;
      v178 = "nw_http1_get_http1_protocol";
      v117 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_298;
    }

    v120 = (char *)__nw_create_backtrace_string();
    v115 = (os_log_s *)__nwlog_obj();
    v116 = v176;
    v134 = os_log_type_enabled(v115, v176);
    if (!v120)
    {
      if (!v134) {
        goto LABEL_299;
      }
      *(_DWORD *)buf = 136446210;
      v178 = "nw_http1_get_http1_protocol";
      v117 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_298;
    }

    if (v134)
    {
      *(_DWORD *)buf = 136446466;
      v178 = "nw_http1_get_http1_protocol";
      v179 = 2082;
      *(void *)v180 = v120;
      v122 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_260;
    }

    goto LABEL_261;
  }

  char v13 = (uint64_t *)(v15 + 248);
LABEL_10:
  char v16 = *v13;
  if (!*v13) {
    goto LABEL_301;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v178 = "nw_protocol_http1_get_output_frames";
    v61 = (char *)_os_log_send_and_compose_impl();
    v176 = OS_LOG_TYPE_ERROR;
    v175 = 0;
    if (v176 == OS_LOG_TYPE_FAULT)
    {
      v62 = (os_log_s *)__nwlog_obj();
      v63 = v176;
      if (!os_log_type_enabled(v62, v176)) {
        goto LABEL_334;
      }
      *(_DWORD *)buf = 136446210;
      v178 = "nw_protocol_http1_get_output_frames";
      v64 = "%{public}s called with null input_protocol";
      goto LABEL_332;
    }

    if (!v175)
    {
      v62 = (os_log_s *)__nwlog_obj();
      v63 = v176;
      if (!os_log_type_enabled(v62, v176)) {
        goto LABEL_334;
      }
      *(_DWORD *)buf = 136446210;
      v178 = "nw_protocol_http1_get_output_frames";
      v64 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_332;
    }

    v69 = (char *)__nw_create_backtrace_string();
    v62 = (os_log_s *)__nwlog_obj();
    v63 = v176;
    v127 = os_log_type_enabled(v62, v176);
    if (!v69)
    {
      if (!v127) {
        goto LABEL_334;
      }
      *(_DWORD *)buf = 136446210;
      v178 = "nw_protocol_http1_get_output_frames";
      v64 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_332;
    }

    if (v127)
    {
      *(_DWORD *)buf = 136446466;
      v178 = "nw_protocol_http1_get_output_frames";
      v179 = 2082;
      *(void *)v180 = v69;
      v71 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_326;
    }

        goto LABEL_49;
      }

      if (!v165)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v25 = (os_log_s *)(id)gLogObj;
        v40 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = 21LL;
          *(_WORD *)&v173[18] = 2048;
          *(void *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 100;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 16;
          _os_log_impl( &dword_181A5C000,  v25,  v40,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
        }

        goto LABEL_299;
      }

      v31 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v32 = (os_log_s *)(id)gLogObj;
      v33 = type;
      os_log_type_t v34 = os_log_type_enabled(v32, type);
      if (v31)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136447746;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = 21LL;
          *(_WORD *)&v173[18] = 2048;
          *(void *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 100;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 16;
          v176 = 2082;
          v177 = v31;
          _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
        }

        free(v31);
        if (!v24) {
          goto LABEL_51;
        }
        goto LABEL_50;
      }

      if (v34)
      {
        *(_DWORD *)buf = 136447490;
        v171 = "nw_necp_append_tlv";
        v172 = 2048;
        *(void *)v173 = v21;
        *(_WORD *)&v173[8] = 2048;
        *(void *)&v173[10] = 21LL;
        *(_WORD *)&v173[18] = 2048;
        *(void *)v174 = &v21[v19];
        *(_WORD *)&v174[8] = 1024;
        *(_DWORD *)v175 = 100;
        *(_WORD *)&v175[4] = 1024;
        *(_DWORD *)&v175[6] = 16;
        _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
      }

        _os_log_impl(&dword_181A5C000, v141, v142, v144, v177, 0x1Eu);
        goto LABEL_300;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v141 = (os_log_s *)gLogObj;
      v142 = (os_log_type_t)v168.msg_name;
      if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v168.msg_name))
      {
        v143 = *(_DWORD *)(v165 + 172);
        *(_DWORD *)v177 = 136446978;
        *(void *)&v177[4] = "nw_socket_set_receive_low_water_mark";
        *(_WORD *)&v177[12] = 1024;
        *(_DWORD *)&v177[14] = *(_DWORD *)buf;
        *(_WORD *)&v177[18] = 1024;
        *(_DWORD *)&v177[20] = v143;
        *(_WORD *)&v177[24] = 1024;
        *(_DWORD *)&v177[26] = v134;
        v144 = "%{public}s setsockopt SO_RCVLOWAT %u fd %d failed %{darwin.errno}d";
        goto LABEL_299;
      }
    }

    goto LABEL_80;
  }

  bzero(&buffer, 0x2400uLL);
  v305[0] = 0LL;
  v305[1] = 0LL;
  v306 = 0;
  *(void *)&v294.msg_iovlen = 1LL;
  memset(v304, 0, sizeof(v304));
  v294.msg_name = v7;
  *(void *)&v294.msg_namelen = 128LL;
  v295[0] = &buffer;
  v295[1] = 9216LL;
  v294.msg_iov = (iovec *)v295;
  v294.msg_control = v304;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(void *)&v294.msg_controllen = 0x8000000100LL;
  while (1)
  {
    char v16 = recvmsg(v13, &v294, 0);
    if ((v16 & 0x8000000000000000LL) == 0) {
      break;
    }
    uint64_t v17 = **(_DWORD **)(StatusReg + 8);
    if (v17 != 4)
    {
      if (v17 != 35)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v17;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s UDP listen socket recvmsg %{darwin.errno}d",  buf,  0x12u);
        }

        BOOL v19 = (void *)*((void *)v14 + 1);
        posix_error = nw_error_create_posix_error(v17);
        [v19 handleInboxFailed:v14 error:posix_error];
      }

      goto LABEL_82;
    }
  }

  if (v9) {
    nw_protocol_callbacks *v9 = 1;
  }
  v293 = 0;
  int v21 = nw_endpoint_get_address(*((nw_endpoint_t *)v14 + 4));
  memset(address, 0, sizeof(address));
  if (v294.msg_controllen < 0xC || (msg_control = (unsigned int *)v294.msg_control) == 0LL)
  {
LABEL_54:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v45 = (id)gLogObj;
    sa_len = v7->sa_len;
    *(_DWORD *)buf = 136448002;
    *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v13;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v16;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = v305;
    *(_WORD *)&buf[38] = 1040;
    *(_DWORD *)v297 = sa_len;
    *(_WORD *)&v297[4] = 2098;
    *(void *)&v297[6] = v7;
    v298 = 1040;
    v299 = address[0];
    v300 = 2098;
    v301 = address;
    v47 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v283.sa_len = 0;
    if (__nwlog_fault(v47, type, &v283))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v48 = (os_log_s *)(id)gLogObj;
        v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          BOOL v50 = v7->sa_len;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v13;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v16;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = v305;
          *(_WORD *)&buf[38] = 1040;
          *(_DWORD *)v297 = v50;
          *(_WORD *)&v297[4] = 2098;
          *(void *)&v297[6] = v7;
          v298 = 1040;
          v299 = address[0];
          v300 = 2098;
          v301 = address;
          _os_log_impl( &dword_181A5C000,  v48,  v49,  "%{public}s recvmsg(%d) got %ld bytes on %s from %{public,network:sockaddr}.*P with bad local address %{publi c,network:sockaddr}.*P",  buf,  0x46u);
        }

                                    if (__nwlog_connection_log::onceToken != -1) {
                                      dispatch_once( &__nwlog_connection_log::onceToken,  &__block_literal_global_24_44325);
                                    }
                                    logh = (id)gconnectionLogObj;
                                    v243 = nw_endpoint_handler_get_id_string(v45);
                                    v244 = nw_endpoint_handler_dry_run_string(v45);
                                    v245 = nw_endpoint_handler_copy_endpoint(v45);
                                    v246 = nw_endpoint_get_logging_description(v245);
                                    v247 = nw_endpoint_handler_state_string(v45);
                                    v248 = nw_endpoint_handler_mode_string(v45);
                                    v249 = nw_endpoint_handler_copy_current_path(v45);
                                    *(_DWORD *)buf = 136447746;
                                    v355 = "nw_endpoint_start_tls_while_connected";
                                    v356 = 2082;
                                    v357 = (char *)v243;
                                    v358 = 2082;
                                    v359 = v244;
                                    v360 = 2082;
                                    v361 = (void *)v246;
                                    v362 = 2082;
                                    v363 = v247;
                                    v364 = 2082;
                                    v365 = v248;
                                    v366 = 2114;
                                    v367 = v249;
                                    v178 = (char *)_os_log_send_and_compose_impl();

                                    type[0] = OS_LOG_TYPE_ERROR;
                                    LOBYTE(v350) = 0;
                                    if ((__nwlog_fault(v178, type, &v350) & 1) != 0)
                                    {
                                      if (type[0] == OS_LOG_TYPE_FAULT)
                                      {
                                        if (__nwlog_connection_log::onceToken != -1) {
                                          dispatch_once( &__nwlog_connection_log::onceToken,  &__block_literal_global_24_44325);
                                        }
                                        v179 = (os_log_s *)(id)gconnectionLogObj;
                                        v250 = type[0];
                                        if (os_log_type_enabled(v179, type[0]))
                                        {
                                          v251 = nw_endpoint_handler_get_id_string(v45);
                                          v252 = nw_endpoint_handler_dry_run_string(v45);
                                          logi = v179;
                                          v253 = nw_endpoint_handler_copy_endpoint(v45);
                                          v254 = nw_endpoint_get_logging_description(v253);
                                          v255 = v45;
                                          v256 = nw_endpoint_handler_state_string(v45);
                                          v257 = nw_endpoint_handler_mode_string(v255);
                                          v258 = nw_endpoint_handler_copy_current_path(v255);
                                          *(_DWORD *)buf = 136447746;
                                          v355 = "nw_endpoint_start_tls_while_connected";
                                          v356 = 2082;
                                          v357 = (char *)v251;
                                          v358 = 2082;
                                          v359 = v252;
                                          v360 = 2082;
                                          v361 = (void *)v254;
                                          v362 = 2082;
                                          v363 = v256;
                                          v364 = 2082;
                                          v365 = v257;
                                          v366 = 2114;
                                          v367 = v258;
                                          _os_log_impl( &dword_181A5C000,  logi,  v250,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public }@)] Failed to repair protocol stack: Could not add old input_protocol",  buf,  0x48u);

                                          v179 = logi;
                                        }

LABEL_126:
  if (v26) {
    free(v26);
  }
  os_log_type_t v12 = 0LL;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_23:
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      int v21 = a2[1].callbacks;
      if (v21)
      {
        __int16 v22 = (nw_protocol_callbacks *)((char *)v21 - 1);
        a2[1].callbacks = v22;
        if (!v22)
        {
          os_log_type_t v23 = *(void (***)(void))a2[1].flow_id;
          if (v23)
          {
            *(void *)a2[1].flow_id = 0LL;
            v23[2](v23);
            _Block_release(v23);
          }

          if ((a2[1].flow_id[8] & 1) != 0)
          {
            uint64_t v24 = *(const void **)a2[1].flow_id;
            if (v24) {
              _Block_release(v24);
            }
          }

          free(a2);
        }
      }
    }
  }

    v112 = 0LL;
    v113 = (uint64_t)&v112;
    os_log_type_t v114 = 0x2000000000LL;
    v115 = 0LL;
    id v67 = *(void *)globals_for_channel;
    v101[0] = MEMORY[0x1895F87A8];
    v101[1] = 0x40000000LL;
    v101[2] = __nw_channel_create_with_attributes_block_invoke;
    v101[3] = &unk_189BC8DF8;
    v101[4] = &v112;
    nw_dictionary_apply(v67, (uint64_t)v101);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v68 = *(const char **)(v113 + 24);
    if (!v68) {
      id v68 = "none";
    }
    *(_DWORD *)block = 136446722;
    *(void *)&block[4] = "nw_channel_create_with_attributes";
    *(_WORD *)&block[12] = 2082;
    *(void *)&block[14] = out;
    *(_WORD *)&block[22] = 2082;
    v126 = v68;
    v69 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v111[0]) = 0;
    if (v105[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v70 = (os_log_s *)gLogObj;
      v71 = v105[0];
      if (os_log_type_enabled((os_log_t)gLogObj, v105[0]))
      {
        v72 = *(const char **)(v113 + 24);
        if (!v72) {
          v72 = "none";
        }
        *(_DWORD *)block = 136446722;
        *(void *)&block[4] = "nw_channel_create_with_attributes";
        *(_WORD *)&block[12] = 2082;
        *(void *)&block[14] = out;
        *(_WORD *)&block[22] = 2082;
        v126 = v72;
        int v73 = "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s";
LABEL_149:
        _os_log_impl(&dword_181A5C000, v70, v71, v73, block, 0x20u);
      }
    }

    else if (LOBYTE(v111[0]))
    {
      v74 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v70 = (os_log_s *)gLogObj;
      v71 = v105[0];
      v75 = os_log_type_enabled((os_log_t)gLogObj, v105[0]);
      if (v74)
      {
        if (v75)
        {
          v76 = *(const char **)(v113 + 24);
          if (!v76) {
            v76 = "none";
          }
          *(_DWORD *)block = 136446978;
          *(void *)&block[4] = "nw_channel_create_with_attributes";
          *(_WORD *)&block[12] = 2082;
          *(void *)&block[14] = out;
          *(_WORD *)&block[22] = 2082;
          v126 = v76;
          LOWORD(v127) = 2082;
          *(void *)((char *)&v127 + 2) = v74;
          _os_log_impl( &dword_181A5C000,  v70,  v71,  "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s, dumpi ng backtrace:%{public}s",  block,  0x2Au);
        }

        free(v74);
        goto LABEL_150;
      }

      if (v75)
      {
        v78 = *(const char **)(v113 + 24);
        if (!v78) {
          v78 = "none";
        }
        *(_DWORD *)block = 136446722;
        *(void *)&block[4] = "nw_channel_create_with_attributes";
        *(_WORD *)&block[12] = 2082;
        *(void *)&block[14] = out;
        *(_WORD *)&block[22] = 2082;
        v126 = v78;
        int v73 = "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s, no backtrace";
        goto LABEL_149;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v70 = (os_log_s *)gLogObj;
      v71 = v105[0];
      if (os_log_type_enabled((os_log_t)gLogObj, v105[0]))
      {
        uint64_t v77 = *(const char **)(v113 + 24);
        if (!v77) {
          uint64_t v77 = "none";
        }
        *(_DWORD *)block = 136446722;
        *(void *)&block[4] = "nw_channel_create_with_attributes";
        *(_WORD *)&block[12] = 2082;
        *(void *)&block[14] = out;
        *(_WORD *)&block[22] = 2082;
        v126 = v77;
        int v73 = "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s, bac"
              "ktrace limit exceeded";
        goto LABEL_149;
      }
    }

        _os_log_impl(&dword_181A5C000, v58, v59, v60, buf, 0xCu);
        goto LABEL_127;
      }

      os_log_type_t v27 = v26->handle;
      if (v27 == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v28 = v26[1].callbacks;
        if (v28) {
          v26[1].callbacks = (nw_protocol_callbacks *)((char *)&v28->add_input_handler + 1);
        }
      }

      v29 = a1->handle;
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        v30 = a1[1].callbacks;
        if (v30) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v30->add_input_handler + 1);
        }
      }

      v31 = v26->callbacks;
      if (!v31
        || (__int16 v32 = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, void *))v31->get_input_frames) == 0LL)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v48 = v26->identifier->name;
        if (!v48) {
          BOOL v48 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v48;
        *(_WORD *)&buf[22] = 2048;
        v199 = (const char *)v26;
        v49 = (const char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        v144 = (char *)v49;
        if (__nwlog_fault(v49, &v197, &v196))
        {
          if (v197 != OS_LOG_TYPE_FAULT)
          {
            if (v196)
            {
              v61 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              log = (os_log_s *)gLogObj;
              typea = v197;
              v62 = os_log_type_enabled((os_log_t)gLogObj, v197);
              if (v61)
              {
                if (v62)
                {
                  v63 = v26->identifier->name;
                  if (!v63) {
                    v63 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63;
                  *(_WORD *)&buf[22] = 2048;
                  v199 = (const char *)v26;
                  v200 = 2082;
                  v201 = v61;
                  _os_log_impl( &dword_181A5C000,  log,  typea,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                }

                free(v61);
                goto LABEL_118;
              }

              if (!v62) {
                goto LABEL_118;
              }
              int v73 = v26->identifier->name;
              if (!v73) {
                int v73 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v73;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              BOOL v52 = log;
              BOOL v53 = typea;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v71 = v197;
              *(void *)typeb = gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, v197)) {
                goto LABEL_118;
              }
              v72 = v26->identifier->name;
              if (!v72) {
                v72 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v72;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              BOOL v52 = *(os_log_s **)typeb;
              BOOL v53 = v71;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            }

      if (!v94) {
        goto LABEL_128;
      }
      goto LABEL_127;
    }

    __nwlog_obj();
    v128 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
    v129 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v154) = 0;
    if (__nwlog_fault(v129, type, &v154))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v130 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v131 = type[0];
        if (os_log_type_enabled(v130, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
          _os_log_impl(&dword_181A5C000, v130, v131, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if ((_BYTE)v154)
      {
        v136 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v130 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v137 = type[0];
        v138 = os_log_type_enabled(v130, type[0]);
        if (v136)
        {
          if (v138)
          {
            *(_DWORD *)buf = 136446466;
            v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
            v165 = 2082;
            *(void *)v166 = v136;
            _os_log_impl( &dword_181A5C000,  v130,  v137,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v136);
          goto LABEL_213;
        }

        if (v138)
        {
          *(_DWORD *)buf = 136446210;
          v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
          _os_log_impl(&dword_181A5C000, v130, v137, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v130 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v140 = type[0];
        if (os_log_type_enabled(v130, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v164 = "-[NWConcrete_nw_connection_group initWithDescriptor:connection:parameters:]";
          _os_log_impl( &dword_181A5C000,  v130,  v140,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

                  if ((SBYTE5(self->flow_in_connected) & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v67 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446722;
                      char v84 = "-[NWConcrete_nw_protocol_instance destroy]";
                      char v85 = 2082;
                      *(void *)uint64_t v86 = (char *)&self->flow_in_connected + 7;
                      *(_WORD *)&v86[8] = 2080;
                      *(void *)&v86[10] = " ";
                      _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sUnable to remove output handler",  buf,  0x20u);
                    }
                  }

                  goto LABEL_130;
                }

  if (v28) {
    free(v28);
  }
LABEL_32:
  if (v12 == &nw_protocol_ref_counted_handle)
  {
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v68);
    if (v7 != &nw_protocol_ref_counted_handle) {
      goto LABEL_34;
    }
LABEL_36:
    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
    goto LABEL_34;
  }

  if (v7 == &nw_protocol_ref_counted_handle) {
    goto LABEL_36;
  }
LABEL_34:
  int v21 = v65;
LABEL_143:

  return v21;
}

      if (v42) {
        free(v42);
      }
LABEL_40:
      if (v22 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
        if (v14 == &nw_protocol_ref_counted_handle) {
LABEL_44:
        }
          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      }

      else if (v14 == &nw_protocol_ref_counted_handle)
      {
        goto LABEL_44;
      }

              nw::release_if_needed<nw_protocol *>((uint64_t *)&v136);
              goto LABEL_127;
            }

            if (v135 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              id v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v103 = v135;
              if (os_log_type_enabled(v68, v135))
              {
                v104 = a2->identifier;
                if (!v104) {
                  v104 = (nw_protocol_identifier *)"invalid";
                }
                *(_DWORD *)buf = 136446722;
                uint64_t v141 = "__nw_protocol_disconnected";
                v142 = 2082;
                v143 = (nw_protocol *)v104;
                v144 = 2048;
                v145 = a2;
                _os_log_impl( &dword_181A5C000,  v68,  v103,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback",  buf,  0x20u);
              }

          free(v76);
          goto LABEL_180;
        }

        __nwlog_obj();
        v56 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        BOOL v51 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v115) = 0;
        if (__nwlog_fault(v51, type, &v115))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            BOOL v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v57 = type[0];
            if (os_log_type_enabled(v52, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
              _os_log_impl( &dword_181A5C000,  v52,  v57,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
            }

            goto LABEL_127;
          }

          if (!v62)
          {
            __nwlog_obj();
            BOOL v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v57 = v65;
            if (os_log_type_enabled(v42, v65))
            {
              v58 = v61->identifier->name;
              if (!v58) {
                v58 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              id v67 = "__nw_protocol_get_parameters";
              id v68 = 2082;
              v69 = (void *)v58;
              int v70 = 2048;
              v71 = v61;
              _os_log_impl( &dword_181A5C000,  v42,  v57,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded",  buf,  0x20u);
            }

            goto LABEL_126;
          }

          BOOL v51 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v52 = v65;
          BOOL v53 = os_log_type_enabled(v42, v65);
          if (!v51)
          {
            if (v53)
            {
              v59 = v61->identifier->name;
              if (!v59) {
                v59 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              id v67 = "__nw_protocol_get_parameters";
              id v68 = 2082;
              v69 = (void *)v59;
              int v70 = 2048;
              v71 = v61;
              _os_log_impl( &dword_181A5C000,  v42,  v52,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace",  buf,  0x20u);
            }

            goto LABEL_126;
          }

          if (v53)
          {
            v54 = v61->identifier->name;
            if (!v54) {
              v54 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            id v67 = "__nw_protocol_get_parameters";
            id v68 = 2082;
            v69 = (void *)v54;
            int v70 = 2048;
            v71 = v61;
            v72 = 2082;
            int v73 = v51;
            _os_log_impl( &dword_181A5C000,  v42,  v52,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v51);
        }

LABEL_127:
      if (v37) {
        free(v37);
      }
      goto LABEL_28;
    }

    if (!(_BYTE)v81)
    {
      __nwlog_obj();
      v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v63 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl( &dword_181A5C000,  v38,  v63,  "%{public}s called with null available_outbound_data, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_126;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v49 = type[0];
    BOOL v50 = os_log_type_enabled(v38, type[0]);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
        _os_log_impl( &dword_181A5C000,  v38,  v49,  "%{public}s called with null available_outbound_data, no backtrace",  buf,  0xCu);
      }

      goto LABEL_126;
    }

    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_service_requested_outbound_data";
      uint64_t v86 = 2082;
      v87 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v38,  v49,  "%{public}s called with null available_outbound_data, dumping backtrace:%{public}s",  buf,  0x16u);
    }

          if (v45) {
            free(v45);
          }
          v4 = 0LL;
          goto LABEL_15;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v13 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v58 = "nw_parameters_create_quic";
        v14 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v55 = 0;
        if (__nwlog_fault(v14, &type, &v55))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v15 = (os_log_s *)(id)gLogObj;
            char v16 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              v58 = "nw_parameters_create_quic";
              _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s nw_quic_create_stream_options failed", buf, 0xCu);
            }
          }

          else if (v55)
          {
            __int16 v20 = __nw_create_backtrace_string();
            if (v20)
            {
              int v21 = (char *)v20;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v22 = (os_log_s *)(id)gLogObj;
              os_log_type_t v23 = type;
              if (os_log_type_enabled(v22, type))
              {
                *(_DWORD *)buf = 136446466;
                v58 = "nw_parameters_create_quic";
                v59 = 2082;
                v60 = v21;
                _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s nw_quic_create_stream_options failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v21);
              if (!v14) {
                goto LABEL_55;
              }
              goto LABEL_54;
            }

            __nwlog_obj();
            BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v26 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              v58 = "nw_parameters_create_quic";
              _os_log_impl( &dword_181A5C000,  v15,  v26,  "%{public}s nw_quic_create_stream_options failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v15 = (os_log_s *)(id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              v58 = "nw_parameters_create_quic";
              _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s nw_quic_create_stream_options failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v14)
        {
LABEL_55:
          v4 = 0LL;
          goto LABEL_56;
        }

                xpc_dictionary_set_BOOL(v2, "allow_joining_connected_fd", 1);
                v35 = *((void *)v1 + 12);
                if ((v35 & 0x4000000) == 0)
                {
LABEL_91:
                  if ((v35 & 0x8000000) == 0) {
                    goto LABEL_92;
                  }
                  goto LABEL_128;
                }

    goto LABEL_127;
  }

  v31 = ArrayBySeparatingStrings;
  if (CFStringHasSuffix(v8, @"."))
  {
    v93.length = CFStringGetLength(v8) - 1;
    v93.location = 0LL;
    __int16 v32 = CFStringCreateWithSubstring(v4, v8, v93);
    v33 = v32;
    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v34 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      uint64_t v86 = "nw_endpoint_proxy_string_matches_pattern";
      v35 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v83 = 0;
      if (!__nwlog_fault((const char *)v35, &type, &v83))
      {
LABEL_153:
        if (v35) {
          free(v35);
        }
        v55 = 0LL;
        v33 = 0LL;
        goto LABEL_156;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v86 = "nw_endpoint_proxy_string_matches_pattern";
          v38 = "%{public}s CFStringCreateMutableCopy failed";
LABEL_151:
          _os_log_impl(&dword_181A5C000, v36, v37, v38, buf, 0xCu);
        }
      }

      else
      {
        if (v83)
        {
          v78 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v37 = type;
          unint64_t v79 = os_log_type_enabled(v36, type);
          if (v78)
          {
            if (v79)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v86 = "nw_endpoint_proxy_string_matches_pattern";
              v87 = 2082;
              v88 = v78;
              _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s CFStringCreateMutableCopy failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v78);
            goto LABEL_153;
          }

          if (!v79) {
            goto LABEL_152;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v86 = "nw_endpoint_proxy_string_matches_pattern";
          v38 = "%{public}s CFStringCreateMutableCopy failed, no backtrace";
          goto LABEL_151;
        }

        __nwlog_obj();
        v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v86 = "nw_endpoint_proxy_string_matches_pattern";
          v38 = "%{public}s CFStringCreateMutableCopy failed, backtrace limit exceeded";
          goto LABEL_151;
        }
      }

    if (v49) {
      free(v49);
    }
    goto LABEL_34;
  }

  do
  {
    char v83 = 0LL;
    char v84 = &v83;
    if (!(*(unsigned int (**)(uint64_t, nw_protocol *, void, void, uint64_t, uint64_t *))(*(void *)(v11 + 24) + 80LL))( v11,  a1,  0LL,  0LL,  1LL,  &v83)) {
      break;
    }
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000LL;
    LOBYTE(v92) = 0;
    v75 = v13;
    v76 = 0x40000000LL;
    uint64_t v77 = (uint64_t (*)(uint64_t *))___ZL34nw_protocol_masque_input_availableP11nw_protocolS0__block_invoke;
    v78 = &unk_189BBA8F0;
    unint64_t v79 = buf;
    int v80 = handle;
    char v82 = v12;
    v81 = v7;
    uint64_t v17 = v83;
    do
    {
      if (!v17) {
        break;
      }
      id v18 = *(void *)(v17 + 32);
      BOOL v19 = v77(&v75);
      uint64_t v17 = v18;
    }

    while ((v19 & 1) != 0);
    int v7 = *(_DWORD *)&handle->flow_id[v5];
    _Block_object_dispose(buf, 8);
  }

  while ((v7 & 0xFFFFFFFE) == 2);
}

    goto LABEL_127;
  }

  os_log_type_t v12 = v10;
  char v13 = *((id *)v12 + 1);

  if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_59_74543);
  }
  v14 = nw_protocol_definition_is_equal_unsafe((uint64_t)v13, nw_protocol_copy_http_transaction_definition_definition);

  if (v14)
  {
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_http_transaction_metadata_increment_inbound_body_size_block_invoke;
    v61 = &__block_descriptor_40_e9_B16__0_v8l;
    v62 = v9;
    BOOL v15 = *((void *)v12 + 4);
    if (v15) {
      __nw_http_transaction_metadata_increment_inbound_body_size_block_invoke((uint64_t)buf, v15);
    }
    goto LABEL_18;
  }

  __nwlog_obj();
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
  v31 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v58 = 0;
  if (__nwlog_fault(v31, &type, &v58))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
        _os_log_impl(&dword_181A5C000, v32, v39, "%{public}s metadata must be http_transaction", buf, 0xCu);
      }
    }

    else if (v58)
    {
      BOOL v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v49 = type;
      BOOL v50 = os_log_type_enabled(v32, type);
      if (v48)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v48;
          _os_log_impl( &dword_181A5C000,  v32,  v49,  "%{public}s metadata must be http_transaction, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v48);
        if (!v31) {
          goto LABEL_18;
        }
        goto LABEL_133;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
        _os_log_impl( &dword_181A5C000,  v32,  v49,  "%{public}s metadata must be http_transaction, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
        _os_log_impl( &dword_181A5C000,  v32,  v56,  "%{public}s metadata must be http_transaction, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_126;
  }

          free(v84);
          goto LABEL_150;
        }

        os_log_type_t v103 = (os_log_s *)__nwlog_obj();
        v104 = v226;
        if (os_log_type_enabled(v103, v226))
        {
          *(_DWORD *)v227 = 136446210;
          *(void *)&v227[4] = "nw_decoder_decode";
          v74 = v103;
          v75 = v104;
          v76 = "%{public}s called with null decoder, backtrace limit exceeded";
          goto LABEL_149;
        }
      }
    }

                free(v59);
LABEL_127:

                uint64_t v8 = v82;
                goto LABEL_140;
              }

              __nwlog_obj();
              v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v61 = type;
              if (os_log_type_enabled(v60, type))
              {
                if (v51 > 0x14) {
                  int v73 = "unknown";
                }
                else {
                  int v73 = off_189BB5C28[v51];
                }
                *(_DWORD *)buf = 136446978;
                v97 = "-[NWPrivilegedHelper registerHandlerFunction:type:allowedEntitlementGroup:]";
                v98 = 1024;
                *(_DWORD *)v99 = v5;
                *(_WORD *)&v99[4] = 2082;
                *(void *)&v99[6] = v73;
                v100 = 2114;
                v101 = v36;
                v75 = "%{public}s Refusing to register handler for type [%u] %{public}s with invalid entitlement %{public"
                      "}@, backtrace limit exceeded";
LABEL_123:
                _os_log_impl(&dword_181A5C000, v60, v61, v75, buf, 0x26u);
              }

          if (v68)
          {
            if (v6)
            {
              v69 = (void *)*((void *)v17 + 2);
              if (v69)
              {
                int v70 = v69;
                legacy_tcp_socket = (nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v70,  0,  0);

                nw_parameters_set_data_mode(legacy_tcp_socket, 2u);
                nw_parameters_set_allow_socket_access(legacy_tcp_socket, 1);
                nw_parameters_set_tfo(legacy_tcp_socket, 1);
                goto LABEL_142;
              }
            }

            legacy_tcp_socket = nw_parameters_create_legacy_tcp_socket(&__block_literal_global_189_49156);
            if (legacy_tcp_socket)
            {
LABEL_142:
              nw_parameters_set_fast_open_enabled(legacy_tcp_socket, 1);
              nw_parameters_set_fast_open_force_enable(legacy_tcp_socket, 1);
              nw_parameters_set_no_proxy(legacy_tcp_socket, 1);
              v64 = nw_connection_create(endpoint, legacy_tcp_socket);
              if (v64)
              {
                if (v6)
                {
                  nwsc_request_stop_path_watcher((NWConcrete_nw_unique_connection_request *)v17);
                  objc_storeStrong((id *)v17 + 72, v64);
                }

                nw_connection_set_queue(v64, *((dispatch_queue_t *)v16 + 4));
                nw_connection_send( v64,  v68,  (nw_content_context_t)&__block_literal_global_41831,  1,  &__block_literal_global_24170);
                handler[0] = MEMORY[0x1895F87A8];
                handler[1] = 3221225472LL;
                handler[2] = ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_190;
                handler[3] = &unk_189BBFDF0;
                unint64_t v79 = v16;
                v113 = v79;
                int v80 = v64;
                os_log_type_t v114 = v80;
                v81 = v17;
                v115 = v81;
                v116 = 0;
                nw_connection_set_state_changed_handler(v80, handler);
                nw_connection_start(v80);
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                char v82 = (os_log_s *)(id)gLogObj;
                if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136446722;
                  v125 = "nwsc_request_create_and_start_connection_inner";
                  LOWORD(v126[0]) = 2114;
                  *(void *)((char *)v126 + 2) = v79;
                  WORD5(v126[0]) = 2114;
                  *(void *)((char *)v126 + 12) = v81;
                  _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ sending connection request %{public}@",  buf,  0x20u);
                }

                char v83 = v80;
LABEL_188:

LABEL_195:
                goto LABEL_196;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v85 = (id)gLogObj;
              *(_DWORD *)buf = 136446210;
              v125 = "nwsc_request_create_and_start_connection_inner";
              uint64_t v86 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(error) = 0;
              if (__nwlog_fault(v86, type, &error))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v88 = type[0];
                  if (os_log_type_enabled(v87, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    v125 = "nwsc_request_create_and_start_connection_inner";
                    _os_log_impl(&dword_181A5C000, v87, v88, "%{public}s nw_connection_create failed", buf, 0xCu);
                  }
                }

                else if ((_BYTE)error)
                {
                  v93 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v94 = type[0];
                  v95 = os_log_type_enabled(v87, type[0]);
                  if (v93)
                  {
                    if (v95)
                    {
                      *(_DWORD *)buf = 136446466;
                      v125 = "nwsc_request_create_and_start_connection_inner";
                      LOWORD(v126[0]) = 2082;
                      *(void *)((char *)v126 + 2) = v93;
                      _os_log_impl( &dword_181A5C000,  v87,  v94,  "%{public}s nw_connection_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v93);
                    goto LABEL_186;
                  }

                  if (v95)
                  {
                    *(_DWORD *)buf = 136446210;
                    v125 = "nwsc_request_create_and_start_connection_inner";
                    _os_log_impl( &dword_181A5C000,  v87,  v94,  "%{public}s nw_connection_create failed, no backtrace",  buf,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v99 = type[0];
                  if (os_log_type_enabled(v87, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    v125 = "nwsc_request_create_and_start_connection_inner";
                    _os_log_impl( &dword_181A5C000,  v87,  v99,  "%{public}s nw_connection_create failed, backtrace limit exceeded",  buf,  0xCu);
                  }
                }
              }

        if (v69) {
          free(v69);
        }
        goto LABEL_49;
      }

      v30 = (void **)calloc(0x10uLL, 1uLL);
      if (v30) {
        goto LABEL_20;
      }
      __nwlog_obj();
      v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v88, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v112 = "strict_calloc";
      v113 = 2048;
      *(void *)os_log_type_t v114 = 16LL;
      *(_WORD *)&v114[8] = 2048;
      *(void *)&v114[10] = 1LL;
      v89 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v89);
      if (!result)
      {
        free(v89);
LABEL_20:
        sdRef = 0LL;
        v31 = DNSServiceGetAddrInfo( &sdRef,  0x40019000u,  v26,  2u,  "ipv4only.arpa",  (DNSServiceGetAddrInfoReply)nw_nat64_getaddrinfo_callback_sync,  v30);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v32 = (os_log_s *)(id)gLogObj;
        v33 = v32;
        if (v31)
        {
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            goto LABEL_67;
          }
          os_log_type_t v34 = nwlog_get_string_for_dns_service_error(v31);
          *(_DWORD *)buf = 136447234;
          v112 = "nw_nat64_copy_ipv4only_records";
          v113 = 1024;
          *(_DWORD *)os_log_type_t v114 = v26;
          *(_WORD *)&v114[4] = 2082;
          *(void *)&v114[6] = "ipv4only.arpa";
          *(_WORD *)&v114[14] = 2082;
          *(void *)&v114[16] = v34;
          *(_WORD *)&v114[24] = 1024;
          *(_DWORD *)&v114[26] = v31;
          v35 = "%{public}s starting DNS query on ifindex %u for %{public}s failed with error=%{public}s(%d)";
        }

        else
        {
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v112 = "nw_nat64_copy_ipv4only_records";
            v113 = 1024;
            *(_DWORD *)os_log_type_t v114 = v26;
            *(_WORD *)&v114[4] = 2082;
            *(void *)&v114[6] = "ipv4only.arpa";
            _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s started DNS query on ifindex %u for %{public}s successfully",  buf,  0x1Cu);
          }

          do
          {
            if (*((_BYTE *)v30 + 12)) {
              goto LABEL_68;
            }
          }

          while (!DNSServiceProcessResult(sdRef));
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (os_log_s *)(id)gLogObj;
          if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            goto LABEL_67;
          }
          v55 = DNSServiceErrorCodeToString();
          *(_DWORD *)buf = 136447234;
          v112 = "nw_nat64_copy_ipv4only_records";
          v56 = "NoError";
          if (v55) {
            v56 = (const char *)v55;
          }
          v113 = 1024;
          *(_DWORD *)os_log_type_t v114 = v26;
          *(_WORD *)&v114[4] = 2082;
          *(void *)&v114[6] = "ipv4only.arpa";
          *(_WORD *)&v114[14] = 2082;
          *(void *)&v114[16] = v56;
          *(_WORD *)&v114[24] = 1024;
          *(_DWORD *)&v114[26] = 0;
          v35 = "%{public}s DNSServiceProcessResult on ifindex %u for %{public}s failed with error=%{public}s(%d)";
        }

        _os_log_impl(&dword_181A5C000, v33, OS_LOG_TYPE_ERROR, v35, buf, 0x2Cu);
LABEL_67:

LABEL_68:
        BOOL v15 = *((unsigned int *)v30 + 2);
        v57 = *v30;
        free(v30);
        if (sdRef) {
          DNSServiceRefDeallocate(sdRef);
        }
        if ((int)v15 >= 1)
        {
          BOOL v15 = nw_nat64_copy_prefixes_from_ipv4only_records((uint64_t)v57, v15, a2);
          if (v57) {
            free(v57);
          }
        }

      if (v51) {
        free(v51);
      }
      BOOL v19 = v49;
LABEL_29:

      if (nw_connection_get_symptom_reporter_handle::once != -1) {
        dispatch_once(&nw_connection_get_symptom_reporter_handle::once, &__block_literal_global_78285);
      }
      symptom_new();
      symptom_set_qualifier();
      symptom_set_additional_qualifier();
      symptom_send();
LABEL_37:
      if (v62) {
        free(v62);
      }
      goto LABEL_39;
    }

    __nwlog_obj();
    BOOL v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_activity_submit_metrics";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "Invalid metric object submitted";
    v43 = (char *)_os_log_send_and_compose_impl();

    v89[0] = 16;
    v81 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v43, v89, &v81))
    {
      if (v89[0] == 17)
      {
        __nwlog_obj();
        v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v45 = v89[0];
        if (os_log_type_enabled(v44, (os_log_type_t)v89[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_activity_submit_metrics";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "Invalid metric object submitted";
          _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
        }
      }

      else if (v81)
      {
        v54 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v55 = v89[0];
        v56 = os_log_type_enabled(v44, (os_log_type_t)v89[0]);
        if (v54)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_activity_submit_metrics";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "Invalid metric object submitted";
            char v83 = 2082;
            char v84 = v54;
            _os_log_impl( &dword_181A5C000,  v44,  v55,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v54);
          goto LABEL_118;
        }

        if (v56)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_activity_submit_metrics";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "Invalid metric object submitted";
          _os_log_impl( &dword_181A5C000,  v44,  v55,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v60 = v89[0];
        if (os_log_type_enabled(v44, (os_log_type_t)v89[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_activity_submit_metrics";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "Invalid metric object submitted";
          _os_log_impl( &dword_181A5C000,  v44,  v60,  "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded",  buf,  0x16u);
        }
      }
    }

              if (!v57) {
                goto LABEL_56;
              }
              v47 = (char *)v57;
LABEL_55:
              free(v47);
              goto LABEL_56;
            }

            v37(v35, v23);
          }

    free(v71);
    if (!v59) {
      goto LABEL_73;
    }
LABEL_161:
    v46 = (char *)v59;
    goto LABEL_72;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  BOOL v19 = &g_registration_list;
  do
  {
    BOOL v19 = (uint64_t *)*v19;
    if (!v19)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      goto LABEL_31;
    }
  }

  while (*(void *)identifier != v19[4]
       || *((void *)identifier + 1) != v19[5]
       || *((void *)identifier + 2) != v19[6]
       || *((void *)identifier + 3) != v19[7]
       || *((void *)identifier + 4) != v19[8]);
  uint64_t v24 = v19[13];
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  if (!v24)
  {
LABEL_31:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v29 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v17);
        v93 = nw_endpoint_handler_dry_run_string(v17);
        v31 = nw_endpoint_handler_copy_endpoint(v17);
        logging_description = nw_endpoint_get_logging_description(v31);
        __int16 v32 = nw_endpoint_handler_state_string(v17);
        v33 = nw_endpoint_handler_mode_string(v17);
        os_log_type_t v34 = nw_endpoint_handler_copy_current_path(v17);
        *(_DWORD *)buf = 136448258;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        v104 = 2082;
        v105 = (void *)id_string;
        v106 = 2082;
        v107 = v93;
        v108 = 2082;
        os_log_type_t v109 = (void *)logging_description;
        v110 = 2082;
        v111 = v32;
        v112 = 2082;
        v113 = v33;
        os_log_type_t v114 = 2114;
        v115 = v34;
        v116 = 2080;
        v117 = identifier;
        BOOL v118 = 2048;
        v119 = (uint64_t)identifier;
        _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not hav e accept function, cannot search for protocol to join",  buf,  0x5Cu);
      }
    }

    goto LABEL_73;
  }

  os_log_type_t v25 = v15;
  BOOL v26 = v25;
  while (1)
  {
    registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join( (uint64_t)identifier,  -1LL,  v97,  v26,  v25,  v16,  v10 != 0);
    registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v26, v10 != 0);

    BOOL v26 = (void *)registered_endpoint;
  }

  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v82 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
    {
      v94 = nw_endpoint_handler_get_id_string(v17);
      v92 = nw_endpoint_handler_dry_run_string(v17);
      char v83 = nw_endpoint_handler_copy_endpoint(v17);
      v90 = nw_endpoint_get_logging_description(v83);
      v89 = nw_endpoint_handler_state_string(v17);
      char v84 = nw_endpoint_handler_mode_string(v17);
      char v85 = nw_endpoint_handler_copy_current_path(v17);
      uint64_t v86 = v85;
      os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
      v87 = "invalid";
      v88 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v88) {
        v87 = v88;
      }
      v104 = 2082;
      v105 = (void *)v94;
      v106 = 2082;
      v107 = v92;
      v108 = 2082;
      os_log_type_t v109 = (void *)v90;
      v110 = 2082;
      v111 = v89;
      v112 = 2082;
      v113 = v84;
      os_log_type_t v114 = 2114;
      v115 = v85;
      v116 = 2080;
      v117 = (void *)v87;
      BOOL v118 = 2048;
      v119 = registered_endpoint;
      _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)",  buf,  0x5Cu);
    }
  }

    free(v71);
    if (!v59) {
      goto LABEL_73;
    }
LABEL_161:
    v46 = (char *)v59;
    goto LABEL_72;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  BOOL v19 = &g_registration_list;
  do
  {
    BOOL v19 = (uint64_t *)*v19;
    if (!v19)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      goto LABEL_31;
    }
  }

  while (*(void *)identifier != v19[4]
       || *((void *)identifier + 1) != v19[5]
       || *((void *)identifier + 2) != v19[6]
       || *((void *)identifier + 3) != v19[7]
       || *((void *)identifier + 4) != v19[8]);
  uint64_t v24 = v19[13];
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  if (!v24)
  {
LABEL_31:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v29 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v17);
        v93 = nw_endpoint_handler_dry_run_string(v17);
        v31 = nw_endpoint_handler_copy_endpoint(v17);
        logging_description = nw_endpoint_get_logging_description(v31);
        __int16 v32 = nw_endpoint_handler_state_string(v17);
        v33 = nw_endpoint_handler_mode_string(v17);
        os_log_type_t v34 = nw_endpoint_handler_copy_current_path(v17);
        *(_DWORD *)buf = 136448258;
        os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
        v104 = 2082;
        v105 = (void *)id_string;
        v106 = 2082;
        v107 = v93;
        v108 = 2082;
        os_log_type_t v109 = (void *)logging_description;
        v110 = 2082;
        v111 = v32;
        v112 = 2082;
        v113 = v33;
        os_log_type_t v114 = 2114;
        v115 = v34;
        v116 = 2080;
        v117 = identifier;
        BOOL v118 = 2048;
        v119 = (uint64_t)identifier;
        _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not hav e accept function, cannot search for protocol to join",  buf,  0x5Cu);
      }
    }

    goto LABEL_73;
  }

  os_log_type_t v25 = v15;
  BOOL v26 = v25;
  while (1)
  {
    registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join( (uint64_t)identifier,  -1LL,  v97,  v26,  v25,  v16,  v10 != 0);
    registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v26, v10 != 0);

    BOOL v26 = (void *)registered_endpoint;
  }

  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v82 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
    {
      v94 = nw_endpoint_handler_get_id_string(v17);
      v92 = nw_endpoint_handler_dry_run_string(v17);
      char v83 = nw_endpoint_handler_copy_endpoint(v17);
      v90 = nw_endpoint_get_logging_description(v83);
      v89 = nw_endpoint_handler_state_string(v17);
      char v84 = nw_endpoint_handler_mode_string(v17);
      char v85 = nw_endpoint_handler_copy_current_path(v17);
      uint64_t v86 = v85;
      os_log_type_t v103 = "nw_endpoint_flow_find_protocol_to_join";
      v87 = "invalid";
      v88 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v88) {
        v87 = v88;
      }
      v104 = 2082;
      v105 = (void *)v94;
      v106 = 2082;
      v107 = v92;
      v108 = 2082;
      os_log_type_t v109 = (void *)v90;
      v110 = 2082;
      v111 = v89;
      v112 = 2082;
      v113 = v84;
      os_log_type_t v114 = 2114;
      v115 = v85;
      v116 = 2080;
      v117 = (void *)v87;
      BOOL v118 = 2048;
      v119 = registered_endpoint;
      _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)",  buf,  0x5Cu);
    }
  }

      _os_log_impl(&dword_181A5C000, v45, v46, v44, buf, v47);
      goto LABEL_127;
    case 4:
      if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v146 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v147 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          v240 = 2082;
          v241 = (void *)(a3 + 390);
          v242 = 2080;
          v243 = " ";
          v244 = 1024;
          v245 = v147;
          _os_log_impl( &dword_181A5C000,  v146,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> received complete SETTINGS frame",  buf,  0x26u);
        }
      }

      BOOL v10 = a2[2];
      if (!v10) {
        return 0LL;
      }
      os_log_type_t v11 = 0LL;
      os_log_type_t v12 = (int *)a2[3];
      while (1)
      {
        char v13 = *v12;
        v12 += 2;
        if (v13 == 11104) {
          break;
        }
        if (v10 == ++v11) {
          return 0LL;
        }
      }

      result = 0LL;
      BOOL v48 = *(_DWORD *)(a2[3] + 8 * v11 + 4);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v49 = gconnectionLogObj;
      result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result) {
        return result;
      }
      BOOL v50 = *(_DWORD *)(a3 + 368);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      v240 = 2082;
      v241 = (void *)(a3 + 390);
      v242 = 2080;
      v243 = " ";
      v244 = 1024;
      v245 = v50;
      v246 = 1024;
      *(_DWORD *)v247 = v48;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> received remote max webtransport session update: %u, ignoring for now";
      id v18 = (os_log_s *)v49;
LABEL_225:
      BOOL v19 = OS_LOG_TYPE_DEBUG;
LABEL_132:
      __int16 v20 = 44;
LABEL_133:
      _os_log_impl(&dword_181A5C000, v18, v19, v17, buf, v20);
      return 0LL;
    case 5:
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v30 = gconnectionLogObj;
      result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result) {
        return result;
      }
      v31 = *(_DWORD *)(a3 + 368);
      __int16 v32 = *((_DWORD *)a2 + 2);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      v240 = 2082;
      v241 = (void *)(a3 + 390);
      v242 = 2080;
      v243 = " ";
      v244 = 1024;
      v245 = v31;
      v246 = 1024;
      *(_DWORD *)v247 = v32;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> received a complete PUSH_PROMISE frame on stream %d -- currently not supported";
      id v18 = (os_log_s *)v30;
      BOOL v19 = OS_LOG_TYPE_ERROR;
      goto LABEL_132;
    case 6:
      if ((*((_BYTE *)a2 + 13) & 1) == 0) {
        return 0LL;
      }
      v33 = a2[2];
      if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v166 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v167 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_http2_received_ping_ack";
          v240 = 2082;
          v241 = (void *)(a3 + 390);
          v242 = 2080;
          v243 = " ";
          v244 = 1024;
          v245 = v167;
          v246 = 2048;
          *(void *)v247 = v33;
          _os_log_impl(&dword_181A5C000, v166, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> seq %llu", buf, 0x30u);
        }
      }

      os_log_type_t v34 = *(int8x8_t *)(a3 + 320);
      if (!*(void *)&v34) {
        goto LABEL_116;
      }
      v35 = (void *)(a3 + 312);
      v36 = (uint8x8_t)vcnt_s8(v34);
      v36.i16[0] = vaddlv_u8(v36);
      if (v36.u32[0] > 1uLL)
      {
        v37 = v33;
        if (*(void *)&v34 <= v33) {
          v37 = v33 % *(void *)&v34;
        }
      }

      else
      {
        v37 = (*(void *)&v34 - 1LL) & v33;
      }

      v65 = *(void ***)(*v35 + 8 * v37);
      if (!v65) {
        goto LABEL_116;
      }
      v66 = *v65;
      if (!*v65) {
        goto LABEL_116;
      }
      if (v36.u32[0] < 2uLL)
      {
        id v67 = *(void *)&v34 - 1LL;
        while (1)
        {
          v69 = v66[1];
          if (v69 == v33)
          {
            if (v66[2] == v33) {
              goto LABEL_182;
            }
          }

          else if ((v69 & v67) != v37)
          {
            goto LABEL_116;
          }

          v66 = (void *)*v66;
          if (!v66) {
            goto LABEL_116;
          }
        }
      }

      while (2)
      {
        id v68 = v66[1];
        if (v68 == v33)
        {
          if (v66[2] == v33)
          {
LABEL_182:
            v105 = v66[3];
            v104 = (void (**)(void, void, void))v66[4];
            v66[4] = 0LL;
            std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>>>::remove( (uint64_t)buf,  v35,  v66);
            v106 = *(void **)buf;
            if (*(void *)buf)
            {
              if (BYTE2(v241))
              {
                if ((*(_BYTE *)(*(void *)buf + 40LL) & 1) != 0)
                {
                  v107 = *(const void **)(*(void *)buf + 32LL);
                  if (v107) {
                    _Block_release(v107);
                  }
                }
              }

              operator delete(v106);
            }

            v108 = mach_continuous_time();
            if (v108 <= 1) {
              os_log_type_t v109 = 1LL;
            }
            else {
              os_log_type_t v109 = v108;
            }
            v104[2](v104, 1LL, v109 - v105);
            _Block_release(v104);
            return 0LL;
          }
        }

        else
        {
          if (v68 >= *(void *)&v34) {
            v68 %= *(void *)&v34;
          }
          if (v68 != v37)
          {
LABEL_116:
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            int v70 = gconnectionLogObj;
            result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result)
            {
              v71 = *(_DWORD *)(a3 + 368);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_http2_received_ping_ack";
              v240 = 2082;
              v241 = (void *)(a3 + 390);
              v242 = 2080;
              v243 = " ";
              v244 = 1024;
              v245 = v71;
              v246 = 2048;
              *(void *)v247 = v33;
              uint64_t v17 = "%{public}s %{public}s%s<i%u> unrecognized ping ack data %llu";
              id v18 = (os_log_s *)v70;
              BOOL v19 = OS_LOG_TYPE_ERROR;
              __int16 v20 = 48;
              goto LABEL_133;
            }

            return result;
          }
        }

        v66 = (void *)*v66;
        if (!v66) {
          goto LABEL_116;
        }
        continue;
      }

    case 7:
      nw_http2_connection_receive_goaway(a3, *((unsigned int *)a2 + 4));
      return 0LL;
    case 8:
      result = 0LL;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v38 = gconnectionLogObj;
      result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result) {
        return result;
      }
      os_log_type_t v39 = *(_DWORD *)(a3 + 368);
      v40 = *((_DWORD *)a2 + 2);
      v41 = *((_DWORD *)a2 + 4);
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      v240 = 2082;
      v241 = (void *)(a3 + 390);
      v242 = 2080;
      v243 = " ";
      v244 = 1024;
      v245 = v39;
      v246 = 1024;
      *(_DWORD *)v247 = v40;
      *(_WORD *)&v247[4] = 1024;
      *(_DWORD *)&v247[6] = v41;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> received window update frame for stream %d, window size increment %d";
      id v18 = (os_log_s *)v38;
      BOOL v19 = OS_LOG_TYPE_DEBUG;
LABEL_98:
      __int16 v20 = 50;
      goto LABEL_133;
    default:
      return 0LL;
  }

        _os_log_impl(&dword_181A5C000, v58, v59, v60, buf, 0xCu);
        goto LABEL_127;
      }

      os_log_type_t v27 = v26->handle;
      if (v27 == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v28 = v26[1].callbacks;
        if (v28) {
          v26[1].callbacks = (nw_protocol_callbacks *)((char *)&v28->add_input_handler + 1);
        }
      }

      v29 = a1->handle;
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        v30 = a1[1].callbacks;
        if (v30) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v30->add_input_handler + 1);
        }
      }

      v31 = v26->callbacks;
      if (!v31
        || (__int16 v32 = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, void *))v31->get_input_frames) == 0LL)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v48 = v26->identifier->name;
        if (!v48) {
          BOOL v48 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v48;
        *(_WORD *)&buf[22] = 2048;
        v199 = (const char *)v26;
        v49 = (const char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        v144 = (char *)v49;
        if (__nwlog_fault(v49, &v197, &v196))
        {
          if (v197 != OS_LOG_TYPE_FAULT)
          {
            if (v196)
            {
              v61 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              log = (os_log_s *)gLogObj;
              typea = v197;
              v62 = os_log_type_enabled((os_log_t)gLogObj, v197);
              if (v61)
              {
                if (v62)
                {
                  v63 = v26->identifier->name;
                  if (!v63) {
                    v63 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v63;
                  *(_WORD *)&buf[22] = 2048;
                  v199 = (const char *)v26;
                  v200 = 2082;
                  v201 = v61;
                  _os_log_impl( &dword_181A5C000,  log,  typea,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                }

                free(v61);
                goto LABEL_118;
              }

              if (!v62) {
                goto LABEL_118;
              }
              int v73 = v26->identifier->name;
              if (!v73) {
                int v73 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v73;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              BOOL v52 = log;
              BOOL v53 = typea;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v71 = v197;
              *(void *)typeb = gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, v197)) {
                goto LABEL_118;
              }
              v72 = v26->identifier->name;
              if (!v72) {
                v72 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v72;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              BOOL v52 = *(os_log_s **)typeb;
              BOOL v53 = v71;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            }

LABEL_135:
  if (v32) {
    free(v32);
  }
  uint64_t v17 = 0LL;
  if (v13 != &nw_protocol_ref_counted_handle) {
    goto LABEL_30;
  }
LABEL_138:
  if (a2->handle != &nw_protocol_ref_counted_handle)
  {
    BOOL v19 = 0;
    goto LABEL_140;
  }

  v92 = a2[1].callbacks;
  if (v92)
  {
    v93 = (nw_protocol_callbacks *)((char *)v92 - 1);
    a2[1].callbacks = v93;
    if (!v93)
    {
      v94 = *(void (***)(void))a2[1].flow_id;
      if (v94)
      {
        *(void *)a2[1].flow_id = 0LL;
        v94[2](v94);
        _Block_release(v94);
      }

      if ((a2[1].flow_id[8] & 1) != 0)
      {
        v95 = *(const void **)a2[1].flow_id;
        if (v95) {
          _Block_release(v95);
        }
      }

      free(a2);
    }
  }

    nw::release_if_needed<nw_protocol *>((uint64_t *)&p_shared_protocol);
    goto LABEL_136;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v22 = (id)gLogObj;
  else {
    os_log_type_t v23 = off_189BBBBC0[v9];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow cancelWithHandler:forced:]";
  __int16 v137 = 2082;
  v138 = (void *)v23;
  __int16 v139 = 2082;
  v140 = "flow";
  uint64_t v24 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(p_shared_protocol) = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (os_log_s *)(id)gLogObj;
    BOOL v26 = type[0];
    if (os_log_type_enabled(v25, type[0]))
    {
      else {
        os_log_type_t v27 = off_189BBBBC0[v9];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow cancelWithHandler:forced:]";
      __int16 v137 = 2082;
      v138 = (void *)v27;
      __int16 v139 = 2082;
      v140 = "flow";
      _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

          goto LABEL_136;
        }

        if (!v98)
        {
          __nwlog_obj();
          int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v60 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl( &dword_181A5C000,  v21,  v60,  "%{public}s received invalid result type, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_131;
        }

        v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v44 = type;
        BOOL v45 = os_log_type_enabled(v21, type);
        if (!v43)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_181A5C000, v21, v44, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
          }

          goto LABEL_131;
        }

        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(void *)os_log_type_t v103 = v43;
          _os_log_impl( &dword_181A5C000,  v21,  v44,  "%{public}s received invalid result type, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }
    }

    nw_frame_set_external_data((uint64_t)v3, 0LL, 0LL);
    v92 = v3[4];
    v93 = (void *)v3[5];
    if (v92)
    {
      *(void *)(v92 + 40) = v93;
      v93 = (void *)v3[5];
    }

    else
    {
      *(void *)(a1[4] + 576LL) = v93;
    }

    nw_protocol_callbacks *v93 = v92;
    v3[4] = 0LL;
    v3[5] = 0LL;
    nw_frame_finalize((uint64_t)v3);
    v94 = size;
    *(_DWORD *)(a1[4] + 600LL) += size;
    *(void *)(*(void *)(a1[5] + 8LL) + 24LL) -= v94;
    if (!gLogDatapath) {
      goto LABEL_69;
    }
    __nwlog_obj();
    subrange = (dispatch_data_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)subrange, OS_LOG_TYPE_DEBUG))
    {
      v95 = a1[4];
      v96 = (const char *)(v95 + 609);
      if (!v95) {
        v96 = "";
      }
      v97 = *(_DWORD *)(v95 + 600);
      v98 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
      *(_DWORD *)buf = 136446978;
      v132 = "nw_framer_write_output_no_copy_block_invoke";
      v133 = 2080;
      v134 = v96;
      __int16 v135 = 1024;
      *(_DWORD *)v136 = v97;
      *(_WORD *)&v136[4] = 2048;
      *(void *)&v136[6] = v98;
      _os_log_impl( &dword_181A5C000,  (os_log_t)subrange,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Pending output cursor %u, remaining output %zu",  buf,  0x26u);
    }

    goto LABEL_68;
  }

  HIDWORD(size) = 0;
  v6 = nw_frame_unclaimed_bytes((uint64_t)v3, (_DWORD *)&size + 1);
  if (gLogDatapath)
  {
    __nwlog_obj();
    v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v103 = a1[4];
      v104 = (const char *)(v103 + 609);
      if (!v103) {
        v104 = "";
      }
      *(_DWORD *)buf = 136446722;
      v132 = "nw_framer_write_output_no_copy_block_invoke";
      v133 = 2080;
      v134 = v104;
      __int16 v135 = 1024;
      *(_DWORD *)v136 = HIDWORD(size);
      _os_log_impl(&dword_181A5C000, v102, OS_LOG_TYPE_DEBUG, "%{public}s %s Writing %u data bytes", buf, 0x1Cu);
    }
  }

  int v7 = (const void *)(v6 + *(unsigned int *)(a1[4] + 600LL));
  if (*(void *)(*(void *)(a1[5] + 8LL) + 24LL) >= (unint64_t)HIDWORD(size))
  {
    uint64_t v8 = dispatch_data_create(v7, HIDWORD(size), 0LL, 0LL);
    uint64_t v24 = *(void *)(a1[6] + 8LL);
    os_log_type_t v27 = *(dispatch_data_s **)(v24 + 40);
    os_log_type_t v25 = (id *)(v24 + 40);
    BOOL v26 = v27;
    if (v27)
    {
      os_log_type_t v28 = dispatch_data_create_concat(v26, v8);
      v29 = *(void *)(a1[6] + 8LL);
      v30 = *(void **)(v29 + 40);
      *(void *)(v29 + 40) = v28;

      if (gLogDatapath)
      {
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          __int16 v32 = a1[4];
          if (v32) {
            v33 = (const char *)(v32 + 609);
          }
          else {
            v33 = "";
          }
          os_log_type_t v34 = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL));
          v35 = *(_DWORD *)(v32 + 600);
          *(_DWORD *)buf = 136447234;
          v132 = "nw_framer_write_output_no_copy_block_invoke";
          v133 = 2080;
          v134 = v33;
          __int16 v135 = 2048;
          *(void *)v136 = v34;
          *(_WORD *)&v136[8] = 1024;
          *(_DWORD *)&v136[10] = HIDWORD(size);
          *(_WORD *)&v136[14] = 1024;
          *(_DWORD *)&v136[16] = v35;
          v36 = "%{public}s %s Appending message data to output data, now %zu bytes, %u bytes from offset %u";
LABEL_113:
          _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEBUG, v36, buf, 0x2Cu);
          goto LABEL_114;
        }

        goto LABEL_114;
      }
    }

    else
    {
      objc_storeStrong(v25, v8);
      if (gLogDatapath)
      {
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          v116 = a1[4];
          if (v116) {
            v117 = (const char *)(v116 + 609);
          }
          else {
            v117 = "";
          }
          BOOL v118 = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL));
          v119 = *(_DWORD *)(v116 + 600);
          *(_DWORD *)buf = 136447234;
          v132 = "nw_framer_write_output_no_copy_block_invoke";
          v133 = 2080;
          v134 = v117;
          __int16 v135 = 2048;
          *(void *)v136 = v118;
          *(_WORD *)&v136[8] = 1024;
          *(_DWORD *)&v136[10] = HIDWORD(size);
          *(_WORD *)&v136[14] = 1024;
          *(_DWORD *)&v136[16] = v119;
          v36 = "%{public}s %s Setting message data as output data, %zu bytes, %u bytes from offset %u";
          goto LABEL_113;
        }

      if (v31) {
        free(v31);
      }
      goto LABEL_44;
    }

    __nwlog_obj();
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
    v41 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v91) = 16;
    v89[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v41, &v91, v89))
    {
      if (v91 == 17)
      {
        __nwlog_obj();
        BOOL v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v43 = v91;
        if (os_log_type_enabled(v42, (os_log_type_t)v91))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v42, v43, "%{public}s called with null protocol", buf, 0xCu);
        }
      }

      else
      {
        if (v89[0] == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v59 = v91;
          if (os_log_type_enabled(v58, (os_log_type_t)v91))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_149;
        }

        BOOL v52 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        logd = v91;
        BOOL v53 = os_log_type_enabled(v42, (os_log_type_t)v91);
        if (v52)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v52;
            _os_log_impl( &dword_181A5C000,  v42,  logd,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v52);
          goto LABEL_149;
        }

        if (v53)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v42, logd, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
    }

    if (!v37)
    {
LABEL_137:

      v14 = endpoint;
      goto LABEL_138;
    }

    BOOL v42 = v93;
    uint64_t v17 = v95;
    goto LABEL_136;
  }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v19 = (os_log_s *)gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)v12;
    int v21 = "%{public}s %{public}s could not add protocol to protocol based hash table, cannot add input handler";
    goto LABEL_137;
  }

        free(v51);
        goto LABEL_48;
      }

      v35 = *(void *)(v2 + 480);
      if (v35)
      {
        v36 = *(void *)(v35 + 200);
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL56nw_http1_match_idle_connection_with_pending_stream_asyncP19nw_http1_connection_block_invoke;
        v76 = (uint64_t)&unk_189BBD540;
        *(void *)uint64_t v77 = v36;
        nw_queue_context_async(v34, buf);
        goto LABEL_48;
      }

      __nwlog_obj();
      *(_DWORD *)os_log_type_t type = 136446210;
      v81 = "nw_http1_match_idle_connection_with_pending_stream_async";
      BOOL v51 = (char *)_os_log_send_and_compose_impl();
      v74 = OS_LOG_TYPE_ERROR;
      int v73 = 0;
      if (__nwlog_fault(v51, &v74, &v73))
      {
        if (v74 == OS_LOG_TYPE_FAULT)
        {
          BOOL v52 = (os_log_s *)__nwlog_obj();
          BOOL v53 = v74;
          if (!os_log_type_enabled(v52, v74)) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          v81 = "nw_http1_match_idle_connection_with_pending_stream_async";
          v54 = "%{public}s called with null http1";
          goto LABEL_132;
        }

        if (!v73)
        {
          BOOL v52 = (os_log_s *)__nwlog_obj();
          BOOL v53 = v74;
          if (!os_log_type_enabled(v52, v74)) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          v81 = "nw_http1_match_idle_connection_with_pending_stream_async";
          v54 = "%{public}s called with null http1, backtrace limit exceeded";
          goto LABEL_132;
        }

        id v68 = (char *)__nw_create_backtrace_string();
        BOOL v52 = (os_log_s *)__nwlog_obj();
        BOOL v53 = v74;
        v71 = os_log_type_enabled(v52, v74);
        if (!v68)
        {
          if (!v71) {
            goto LABEL_134;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          v81 = "nw_http1_match_idle_connection_with_pending_stream_async";
          v54 = "%{public}s called with null http1, no backtrace";
          goto LABEL_132;
        }

        if (v71)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          v81 = "nw_http1_match_idle_connection_with_pending_stream_async";
          char v82 = 2082;
          char v83 = v68;
          int v70 = "%{public}s called with null http1, dumping backtrace:%{public}s";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

          if (v45) {
            free(v45);
          }
          return 1LL;
        }

        __int16 v20 = *(_DWORD *)(v3 + 536);
        if (v20 == 35)
        {
          if ((*(_BYTE *)(v3 + 198) & 1) != 0) {
            goto LABEL_14;
          }
          if (!gLogDatapath) {
            goto LABEL_14;
          }
          int v21 = (os_log_s *)__nwlog_obj();
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_14;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_retry_can_retry";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v3 + 114;
          *(_WORD *)&buf[22] = 2080;
          char v83 = (uint64_t)" ";
          __int16 v22 = "%{public}s %{public}s%srequest received no response and EAGAIN, able to retry";
LABEL_106:
          _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, v22, buf, 0x20u);
          goto LABEL_14;
        }

        if (v20 == 43)
        {
          if ((*(_BYTE *)(v3 + 198) & 1) != 0) {
            goto LABEL_14;
          }
          if (!gLogDatapath) {
            goto LABEL_14;
          }
          int v21 = (os_log_s *)__nwlog_obj();
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_14;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_retry_can_retry";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v3 + 114;
          *(_WORD *)&buf[22] = 2080;
          char v83 = (uint64_t)" ";
          __int16 v22 = "%{public}s %{public}s%srequest received no response, should retry using HTTP/1.1";
          goto LABEL_106;
        }

        result = (uint64_t)v8;
      }

      os_release((void *)result);
      return 0LL;
    }

    return 0LL;
  }

  return 1LL;
}

    goto LABEL_136;
  }

  if (!v10)
  {
    __nwlog_obj();
    BOOL v48 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_service_connector_start_request";
    BOOL v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v49 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A5C000, v46, v49, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_135;
    }

    if (!v75)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v65 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl( &dword_181A5C000,  v46,  v65,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_135;
    }

    v57 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v58 = type;
    v59 = os_log_type_enabled(v46, type);
    if (!v57)
    {
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A5C000, v46, v58, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_135;
    }

    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      v78 = "nw_service_connector_start_request";
      unint64_t v79 = 2082;
      int v80 = (size_t)v57;
      _os_log_impl( &dword_181A5C000,  v46,  v58,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_110;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v50 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_service_connector_start_request";
    BOOL v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v51 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A5C000, v46, v51, "%{public}s called with null userService", buf, 0xCu);
      }

      goto LABEL_135;
    }

    if (!v75)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v66 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl( &dword_181A5C000,  v46,  v66,  "%{public}s called with null userService, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_135;
    }

    v57 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v60 = type;
    v61 = os_log_type_enabled(v46, type);
    if (!v57)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A5C000, v46, v60, "%{public}s called with null userService, no backtrace", buf, 0xCu);
      }

      goto LABEL_135;
    }

    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v78 = "nw_service_connector_start_request";
      unint64_t v79 = 2082;
      int v80 = (size_t)v57;
      _os_log_impl( &dword_181A5C000,  v46,  v60,  "%{public}s called with null userService, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_110;
  }

  if (!v11)
  {
    __nwlog_obj();
    BOOL v52 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_service_connector_start_request";
    BOOL v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v53 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A5C000, v46, v53, "%{public}s called with null requestBlock", buf, 0xCu);
      }

      goto LABEL_135;
    }

    if (!v75)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v67 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl( &dword_181A5C000,  v46,  v67,  "%{public}s called with null requestBlock, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_135;
    }

    v57 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v62 = type;
    v63 = os_log_type_enabled(v46, type);
    if (!v57)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A5C000, v46, v62, "%{public}s called with null requestBlock, no backtrace", buf, 0xCu);
      }

      goto LABEL_135;
    }

    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      v78 = "nw_service_connector_start_request";
      unint64_t v79 = 2082;
      int v80 = (size_t)v57;
      _os_log_impl( &dword_181A5C000,  v46,  v62,  "%{public}s called with null requestBlock, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_136;
  }

  if (v9)
  {
    if (v8)
    {
      if (a3)
      {
        os_log_type_t v11 = v8;
        os_log_type_t v12 = [v11 type];

        if (v12 == 1)
        {
          char v13 = strlen(a3);
          if (v13 >= 0x101)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = (id)gLogObj;
            *(_DWORD *)buf = 136446722;
            uint64_t v77 = "nw_service_connector_cancel_active_connection";
            v78 = 2082;
            unint64_t v79 = (size_t)a3;
            int v80 = 1024;
            LODWORD(v81[0]) = 256;
            BOOL v15 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v74 = 0;
            if (__nwlog_fault(v15, &type, &v74))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                char v16 = (os_log_s *)(id)gLogObj;
                uint64_t v17 = type;
                if (os_log_type_enabled(v16, type))
                {
                  *(_DWORD *)buf = 136446722;
                  uint64_t v77 = "nw_service_connector_cancel_active_connection";
                  v78 = 2082;
                  unint64_t v79 = (size_t)a3;
                  int v80 = 1024;
                  LODWORD(v81[0]) = 256;
                  _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Service name %{public}s too long. Max allowed length is %d",  buf,  0x1Cu);
                }
              }

              else if (v74)
              {
                v40 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v41 = type;
                BOOL v42 = os_log_type_enabled(v16, type);
                if (v40)
                {
                  if (v42)
                  {
                    *(_DWORD *)buf = 136446978;
                    uint64_t v77 = "nw_service_connector_cancel_active_connection";
                    v78 = 2082;
                    unint64_t v79 = (size_t)a3;
                    int v80 = 1024;
                    LODWORD(v81[0]) = 256;
                    WORD2(v81[0]) = 2082;
                    *(void *)((char *)v81 + 6) = v40;
                    _os_log_impl( &dword_181A5C000,  v16,  v41,  "%{public}s Service name %{public}s too long. Max allowed length is %d, dumping backtrace:%{public}s",  buf,  0x26u);
                  }

                  free(v40);
                  if (!v15) {
                    goto LABEL_78;
                  }
LABEL_92:
                  v49 = (char *)v15;
                  goto LABEL_77;
                }

                if (v42)
                {
                  *(_DWORD *)buf = 136446722;
                  uint64_t v77 = "nw_service_connector_cancel_active_connection";
                  v78 = 2082;
                  unint64_t v79 = (size_t)a3;
                  int v80 = 1024;
                  LODWORD(v81[0]) = 256;
                  _os_log_impl( &dword_181A5C000,  v16,  v41,  "%{public}s Service name %{public}s too long. Max allowed length is %d, no backtrace",  buf,  0x1Cu);
                }
              }

              else
              {
                __nwlog_obj();
                char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                BOOL v50 = type;
                if (os_log_type_enabled(v16, type))
                {
                  *(_DWORD *)buf = 136446722;
                  uint64_t v77 = "nw_service_connector_cancel_active_connection";
                  v78 = 2082;
                  unint64_t v79 = (size_t)a3;
                  int v80 = 1024;
                  LODWORD(v81[0]) = 256;
                  _os_log_impl( &dword_181A5C000,  v16,  v50,  "%{public}s Service name %{public}s too long. Max allowed length is %d, backtrace limit exceeded",  buf,  0x1Cu);
                }
              }
            }

            if (!v15) {
              goto LABEL_78;
            }
            goto LABEL_92;
          }

          __int16 v32 = v13;
          v33 = xpc_string_create(a3);
          os_log_type_t v34 = v33;
          if (v33)
          {
            v35 = v7[4];
            block[0] = MEMORY[0x1895F87A8];
            block[1] = 3221225472LL;
            block[2] = __nw_service_connector_cancel_active_connection_block_invoke;
            block[3] = &unk_189BC7210;
            int v70 = v33;
            v71 = v7;
            v72 = v11;
            int v73 = v10;
            dispatch_async(v35, block);

LABEL_102:
            goto LABEL_79;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v44 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          uint64_t v77 = "nw_service_connector_cancel_active_connection";
          v78 = 2048;
          unint64_t v79 = v32;
          BOOL v45 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v74 = 0;
          if (__nwlog_fault(v45, &type, &v74))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v47 = type;
              if (os_log_type_enabled(v46, type))
              {
                *(_DWORD *)buf = 136446466;
                uint64_t v77 = "nw_service_connector_cancel_active_connection";
                v78 = 2048;
                unint64_t v79 = v32;
                _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s xpc_string_create(%zu) failed", buf, 0x16u);
              }
            }

            else if (v74)
            {
              BOOL v51 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v52 = type;
              BOOL v53 = os_log_type_enabled(v46, type);
              if (v51)
              {
                if (v53)
                {
                  *(_DWORD *)buf = 136446722;
                  uint64_t v77 = "nw_service_connector_cancel_active_connection";
                  v78 = 2048;
                  unint64_t v79 = v32;
                  int v80 = 2082;
                  v81[0] = v51;
                  _os_log_impl( &dword_181A5C000,  v46,  v52,  "%{public}s xpc_string_create(%zu) failed, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(v51);
                goto LABEL_99;
              }

              if (v53)
              {
                *(_DWORD *)buf = 136446466;
                uint64_t v77 = "nw_service_connector_cancel_active_connection";
                v78 = 2048;
                unint64_t v79 = v32;
                _os_log_impl( &dword_181A5C000,  v46,  v52,  "%{public}s xpc_string_create(%zu) failed, no backtrace",  buf,  0x16u);
              }
            }

            else
            {
              __nwlog_obj();
              v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v54 = type;
              if (os_log_type_enabled(v46, type))
              {
                *(_DWORD *)buf = 136446466;
                uint64_t v77 = "nw_service_connector_cancel_active_connection";
                v78 = 2048;
                unint64_t v79 = v32;
                _os_log_impl( &dword_181A5C000,  v46,  v54,  "%{public}s xpc_string_create(%zu) failed, backtrace limit exceeded",  buf,  0x16u);
              }
            }
          }

        BYTE1(v10[1].super.isa) |= 8u;
        if ((v35 & 1) == 0)
        {
LABEL_76:
          if ((v35 & 2) == 0) {
            goto LABEL_77;
          }
          goto LABEL_137;
        }

  if (v83) {
    free(v83);
  }
  return 0LL;
}

            goto LABEL_136;
          }

          if (!(_BYTE)obj)
          {
            __nwlog_obj();
            v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v69 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              char v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v43,  v69,  "%{public}s nw_path_parse_necp_result failed, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
            }

            goto LABEL_135;
          }

          v58 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v61 = v80[0];
          v62 = os_log_type_enabled(v43, v80[0]);
          if (!v58)
          {
            if (v62)
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              char v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v43,  v61,  "%{public}s nw_path_parse_necp_result failed, no backtrace",  (uint8_t *)type,  0xCu);
            }

            goto LABEL_135;
          }

          if (v62)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            char v82 = "nw_path_observer_update_block_invoke";
            char v83 = 2082;
            char v84 = v58;
            _os_log_impl( &dword_181A5C000,  v43,  v61,  "%{public}s nw_path_parse_necp_result failed, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
          }

          goto LABEL_103;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446210;
        char v82 = "nw_path_observer_update_block_invoke";
        BOOL v42 = (char *)_os_log_send_and_compose_impl();

        v80[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(obj) = 0;
        if (__nwlog_fault(v42, v80, &obj))
        {
          if (v80[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v44 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              char v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s nw_path_create failed", (uint8_t *)type, 0xCu);
            }

            goto LABEL_135;
          }

          if (!(_BYTE)obj)
          {
            __nwlog_obj();
            v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v68 = v80[0];
            if (os_log_type_enabled(v43, v80[0]))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              char v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v43,  v68,  "%{public}s nw_path_create failed, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
            }

            goto LABEL_135;
          }

          v58 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v59 = v80[0];
          v60 = os_log_type_enabled(v43, v80[0]);
          if (!v58)
          {
            if (v60)
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              char v82 = "nw_path_observer_update_block_invoke";
              _os_log_impl( &dword_181A5C000,  v43,  v59,  "%{public}s nw_path_create failed, no backtrace",  (uint8_t *)type,  0xCu);
            }

            goto LABEL_135;
          }

          if (v60)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            char v82 = "nw_path_observer_update_block_invoke";
            char v83 = 2082;
            char v84 = v58;
            _os_log_impl( &dword_181A5C000,  v43,  v59,  "%{public}s nw_path_create failed, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
          }

          if (!v54) {
            goto LABEL_45;
          }
          v41 = (char *)v54;
LABEL_44:
          free(v41);
LABEL_45:

          return;
        }

LABEL_140:
  v58 = a2->callbacks;
  if (v58)
  {
    get_remote_endpoint = (uint64_t (*)(nw_protocol *))v58->get_remote_endpoint;
    if (get_remote_endpoint)
    {
      v60 = (nw_endpoint *)get_remote_endpoint(a2);
      if (!v19) {
        goto LABEL_144;
      }
      goto LABEL_143;
    }
  }

  __nwlog_obj();
  v100 = a2->identifier;
  if (!v100) {
    v100 = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)buf = 136446722;
  v134 = "__nw_protocol_get_remote_endpoint";
  __int16 v135 = 2082;
  v136 = v100;
  __int16 v137 = 2048;
  v138 = a2;
  v101 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v131 = 0;
  if (__nwlog_fault(v101, &type, &v131))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v102 = (os_log_s *)__nwlog_obj();
      os_log_type_t v103 = type;
      if (!os_log_type_enabled(v102, type)) {
        goto LABEL_255;
      }
      v104 = a2->identifier;
      if (!v104) {
        v104 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_remote_endpoint";
      __int16 v135 = 2082;
      v136 = v104;
      __int16 v137 = 2048;
      v138 = a2;
      v105 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback";
LABEL_253:
      v126 = v102;
LABEL_254:
      _os_log_impl(&dword_181A5C000, v126, v103, v105, buf, 0x20u);
      goto LABEL_255;
    }

    if (!v131)
    {
      v102 = (os_log_s *)__nwlog_obj();
      os_log_type_t v103 = type;
      if (!os_log_type_enabled(v102, type)) {
        goto LABEL_255;
      }
      v125 = a2->identifier;
      if (!v125) {
        v125 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_remote_endpoint";
      __int16 v135 = 2082;
      v136 = v125;
      __int16 v137 = 2048;
      v138 = a2;
      v105 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded";
      goto LABEL_253;
    }

    v116 = (char *)__nw_create_backtrace_string();
    v117 = (os_log_s *)__nwlog_obj();
    os_log_type_t v103 = type;
    log = v117;
    BOOL v118 = os_log_type_enabled(v117, type);
    if (v116)
    {
      if (v118)
      {
        v119 = a2->identifier;
        if (!v119) {
          v119 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)buf = 136446978;
        v134 = "__nw_protocol_get_remote_endpoint";
        __int16 v135 = 2082;
        v136 = v119;
        __int16 v137 = 2048;
        v138 = a2;
        __int16 v139 = 2082;
        v140 = v116;
        _os_log_impl( &dword_181A5C000,  log,  v103,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v116);
    }

    else if (v118)
    {
      v128 = a2->identifier;
      if (!v128) {
        v128 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_remote_endpoint";
      __int16 v135 = 2082;
      v136 = v128;
      __int16 v137 = 2048;
      v138 = a2;
      v105 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace";
      v126 = log;
      goto LABEL_254;
    }
  }

              v14 = nw_flow_add_read_request(v5, (uint64_t)v8 + 376, v10);
              os_log_type_t v11 = 0LL;
              goto LABEL_95;
            }

            __nwlog_obj();
            int v80 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
            v81 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v107 = 0;
            if (__nwlog_fault(v81, type, &v107))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                char v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                char v83 = type[0];
                if (os_log_type_enabled(v82, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl(&dword_181A5C000, v82, v83, "%{public}s called with null request", buf, 0xCu);
                }
              }

              else if (v107)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                char v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                char v85 = type[0];
                uint64_t v86 = os_log_type_enabled(v82, type[0]);
                if (backtrace_string)
                {
                  if (v86)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v82,  v85,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(backtrace_string);
                  goto LABEL_138;
                }

                if (v86)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl( &dword_181A5C000,  v82,  v85,  "%{public}s called with null request, no backtrace",  buf,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                char v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v89 = type[0];
                if (os_log_type_enabled(v82, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl( &dword_181A5C000,  v82,  v89,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
                }
              }
            }

              goto LABEL_141;
            }

            if (!v66)
            {
              __nwlog_obj();
              BOOL v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v65 = type;
              if (os_log_type_enabled(v52, type))
              {
                *(_DWORD *)buf = 136446210;
                v69 = "nw_protocol_definition_copy_framer_start";
                _os_log_impl( &dword_181A5C000,  v52,  v65,  "%{public}s called with null definition->common_state, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_140;
            }

            v59 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v62 = type;
            v63 = os_log_type_enabled(v52, type);
            if (!v59)
            {
              if (v63)
              {
                *(_DWORD *)buf = 136446210;
                v69 = "nw_protocol_definition_copy_framer_start";
                _os_log_impl( &dword_181A5C000,  v52,  v62,  "%{public}s called with null definition->common_state, no backtrace",  buf,  0xCu);
              }

              goto LABEL_140;
            }

            if (v63)
            {
              *(_DWORD *)buf = 136446466;
              v69 = "nw_protocol_definition_copy_framer_start";
              int v70 = 2082;
              v71 = v59;
              _os_log_impl( &dword_181A5C000,  v52,  v62,  "%{public}s called with null definition->common_state, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            goto LABEL_128;
          }
        }

        else
        {
          __nwlog_obj();
          BOOL v50 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v69 = "nw_protocol_definition_copy_framer_start";
          BOOL v51 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v66 = 0;
          if (__nwlog_fault(v51, &type, &v66))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              BOOL v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v53 = type;
              if (os_log_type_enabled(v52, type))
              {
                *(_DWORD *)buf = 136446210;
                v69 = "nw_protocol_definition_copy_framer_start";
                _os_log_impl(&dword_181A5C000, v52, v53, "%{public}s called with null definition", buf, 0xCu);
              }

              goto LABEL_140;
            }

            if (!v66)
            {
              __nwlog_obj();
              BOOL v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v64 = type;
              if (os_log_type_enabled(v52, type))
              {
                *(_DWORD *)buf = 136446210;
                v69 = "nw_protocol_definition_copy_framer_start";
                _os_log_impl( &dword_181A5C000,  v52,  v64,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_140;
            }

            v59 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v60 = type;
            v61 = os_log_type_enabled(v52, type);
            if (!v59)
            {
              if (v61)
              {
                *(_DWORD *)buf = 136446210;
                v69 = "nw_protocol_definition_copy_framer_start";
                _os_log_impl( &dword_181A5C000,  v52,  v60,  "%{public}s called with null definition, no backtrace",  buf,  0xCu);
              }

              goto LABEL_140;
            }

            if (v61)
            {
              *(_DWORD *)buf = 136446466;
              v69 = "nw_protocol_definition_copy_framer_start";
              int v70 = 2082;
              v71 = v59;
              _os_log_impl( &dword_181A5C000,  v52,  v60,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

    if (v23) {
LABEL_141:
    }
      free(v23);
LABEL_142:
    int v21 = 0LL;
    goto LABEL_143;
  }

  v65 = 0LL;
  v6 = *(void **)&v3[-1].log_str[25];
  if (!v6)
  {
    __nwlog_obj();
    BOOL v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v73 = "__nw_protocol_get_message_properties";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v6_Block_object_dispose(va, 8) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type[0];
      if (os_log_type_enabled(v24, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v73 = "__nw_protocol_get_message_properties";
        _os_log_impl(&dword_181A5C000, v24, v46, "%{public}s called with null protocol", buf, 0xCu);
      }

      goto LABEL_139;
    }

    if (!(_BYTE)v68)
    {
      __nwlog_obj();
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v63 = type[0];
      if (os_log_type_enabled(v24, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v73 = "__nw_protocol_get_message_properties";
        _os_log_impl( &dword_181A5C000,  v24,  v63,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_139;
    }

    BOOL v50 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v54 = type[0];
    v55 = os_log_type_enabled(v24, type[0]);
    if (!v50)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        int v73 = "__nw_protocol_get_message_properties";
        _os_log_impl(&dword_181A5C000, v24, v54, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }

      goto LABEL_139;
    }

    if (v55)
    {
      *(_DWORD *)buf = 136446466;
      int v73 = "__nw_protocol_get_message_properties";
      v74 = 2082;
      v75 = v50;
      _os_log_impl( &dword_181A5C000,  v24,  v54,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_101;
  }

  int v7 = (void *)v6[5];
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v17 = v6[11];
    if (v17) {
      v6[11] = v17 + 1;
    }
    os_log_type_t v9 = -1;
  }

  else
  {
    os_log_type_t v9 = 0;
  }

  p_paths_log_id_num = &v3[-1].paths_log_id_num;
  *(void *)os_log_type_t type = v6;
  v71 = v9;
  os_log_type_t v12 = *(void **)&v3[-1].log_str[33];
  if (v12 == &nw_protocol_ref_counted_handle)
  {
    BOOL v19 = *(void *)&v3[-1].log_str[81];
    if (v19) {
      *(void *)&v3[-1].log_str[81] = v19 + 1;
    }
    id v18 = -1;
  }

  else
  {
    id v18 = 0;
  }

  id v68 = &v3[-1].paths_log_id_num;
  v69 = v18;
  __int16 v20 = v6[3];
  if (v20)
  {
    char v16 = *(void (**)(void *, unsigned __int16 *, uint64_t *))(v20 + 248);
    if (v16) {
      goto LABEL_31;
    }
  }

  __nwlog_obj();
  __int16 v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = (const char *)v6[2];
  *(_DWORD *)buf = 136446722;
  int v73 = "__nw_protocol_get_message_properties";
  if (!v33) {
    v33 = "invalid";
  }
  v74 = 2082;
  v75 = (void *)v33;
  v76 = 2048;
  uint64_t v77 = v6;
  os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

  id v67 = OS_LOG_TYPE_ERROR;
  v66 = 0;
  if (__nwlog_fault(v28, &v67, &v66))
  {
    if (v67 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = v67;
      if (os_log_type_enabled(v29, v67))
      {
        v35 = (const char *)v6[2];
        if (!v35) {
          v35 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        int v73 = "__nw_protocol_get_message_properties";
        v74 = 2082;
        v75 = (void *)v35;
        v76 = 2048;
        uint64_t v77 = v6;
        _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback",  buf,  0x20u);
      }

      goto LABEL_125;
    }

    if (!v66)
    {
      __nwlog_obj();
      v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v58 = v67;
      if (os_log_type_enabled(v29, v67))
      {
        v59 = (const char *)v6[2];
        if (!v59) {
          v59 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        int v73 = "__nw_protocol_get_message_properties";
        v74 = 2082;
        v75 = (void *)v59;
        v76 = 2048;
        uint64_t v77 = v6;
        _os_log_impl( &dword_181A5C000,  v29,  v58,  "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, backtrace limit exceeded",  buf,  0x20u);
      }

      goto LABEL_125;
    }

    v41 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v47 = v67;
    BOOL v48 = os_log_type_enabled(v29, v67);
    if (!v41)
    {
      if (v48)
      {
        v61 = (const char *)v6[2];
        if (!v61) {
          v61 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        int v73 = "__nw_protocol_get_message_properties";
        v74 = 2082;
        v75 = (void *)v61;
        v76 = 2048;
        uint64_t v77 = v6;
        _os_log_impl( &dword_181A5C000,  v29,  v47,  "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, no backtrace",  buf,  0x20u);
      }

      goto LABEL_125;
    }

    if (v48)
    {
      v49 = (const char *)v6[2];
      if (!v49) {
        v49 = "invalid";
      }
      *(_DWORD *)buf = 136446978;
      int v73 = "__nw_protocol_get_message_properties";
      v74 = 2082;
      v75 = (void *)v49;
      v76 = 2048;
      uint64_t v77 = v6;
      v78 = 2082;
      unint64_t v79 = v41;
      _os_log_impl( &dword_181A5C000,  v29,  v47,  "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    goto LABEL_88;
  }

    goto LABEL_159;
  }

  __nwlog_obj();
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
  os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v75) = 0;
  if (__nwlog_fault(v25, type, &v75))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)v75)
    {
      v43 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v44 = type[0];
      BOOL v45 = os_log_type_enabled(v26, type[0]);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v43;
          _os_log_impl( &dword_181A5C000,  v26,  v44,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_130;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl(&dword_181A5C000, v26, v44, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v61 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_disconnected";
        _os_log_impl( &dword_181A5C000,  v26,  v61,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

            goto LABEL_141;
          }

          if (!v69)
          {
            __nwlog_obj();
            v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v64 = v72;
            if (os_log_type_enabled(v49, v72))
            {
              v65 = v68->identifier->name;
              if (!v65) {
                v65 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
              v74 = 2082;
              v75 = (char *)v65;
              v76 = 2048;
              uint64_t v77 = (const char *)v68;
              _os_log_impl( &dword_181A5C000,  v49,  v64,  "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded",  buf,  0x20u);
            }

            goto LABEL_140;
          }

          v58 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v59 = v72;
          v60 = os_log_type_enabled(v49, v72);
          if (!v58)
          {
            if (v60)
            {
              v66 = v68->identifier->name;
              if (!v66) {
                v66 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
              v74 = 2082;
              v75 = (char *)v66;
              v76 = 2048;
              uint64_t v77 = (const char *)v68;
              _os_log_impl( &dword_181A5C000,  v49,  v59,  "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace",  buf,  0x20u);
            }

            goto LABEL_140;
          }

          if (v60)
          {
            v61 = v68->identifier->name;
            if (!v61) {
              v61 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
            v74 = 2082;
            v75 = (char *)v61;
            v76 = 2048;
            uint64_t v77 = (const char *)v68;
            v78 = 2082;
            unint64_t v79 = v58;
            _os_log_impl( &dword_181A5C000,  v49,  v59,  "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v58);
        }

            goto LABEL_141;
          }

          if (!v69)
          {
            __nwlog_obj();
            v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v64 = v72;
            if (os_log_type_enabled(v49, v72))
            {
              v65 = v68->identifier->name;
              if (!v65) {
                v65 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
              v74 = 2082;
              v75 = (char *)v65;
              v76 = 2048;
              uint64_t v77 = (const char *)v68;
              _os_log_impl( &dword_181A5C000,  v49,  v64,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded",  buf,  0x20u);
            }

            goto LABEL_140;
          }

          v58 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v59 = v72;
          v60 = os_log_type_enabled(v49, v72);
          if (!v58)
          {
            if (v60)
            {
              v66 = v68->identifier->name;
              if (!v66) {
                v66 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
              v74 = 2082;
              v75 = (char *)v66;
              v76 = 2048;
              uint64_t v77 = (const char *)v68;
              _os_log_impl( &dword_181A5C000,  v49,  v59,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace",  buf,  0x20u);
            }

            goto LABEL_140;
          }

          if (v60)
          {
            v61 = v68->identifier->name;
            if (!v61) {
              v61 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_remote_endpoint";
            v74 = 2082;
            v75 = (char *)v61;
            v76 = 2048;
            uint64_t v77 = (const char *)v68;
            v78 = 2082;
            unint64_t v79 = v58;
            _os_log_impl( &dword_181A5C000,  v49,  v59,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v58);
        }

            goto LABEL_141;
          }

          if (!v70)
          {
            __nwlog_obj();
            BOOL v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v65 = v73;
            if (os_log_type_enabled(v50, v73))
            {
              v66 = v69->identifier->name;
              if (!v66) {
                v66 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_path";
              v75 = 2082;
              v76 = (char *)v66;
              uint64_t v77 = 2048;
              v78 = (const char *)v69;
              _os_log_impl( &dword_181A5C000,  v50,  v65,  "%{public}s protocol %{public}s (%p) has invalid get_path callback, backtrace limit exceeded",  buf,  0x20u);
            }

            goto LABEL_140;
          }

          v59 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v60 = v73;
          v61 = os_log_type_enabled(v50, v73);
          if (!v59)
          {
            if (v61)
            {
              id v67 = v69->identifier->name;
              if (!v67) {
                id v67 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_path";
              v75 = 2082;
              v76 = (char *)v67;
              uint64_t v77 = 2048;
              v78 = (const char *)v69;
              _os_log_impl( &dword_181A5C000,  v50,  v60,  "%{public}s protocol %{public}s (%p) has invalid get_path callback, no backtrace",  buf,  0x20u);
            }

            goto LABEL_140;
          }

          if (v61)
          {
            v62 = v69->identifier->name;
            if (!v62) {
              v62 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_path";
            v75 = 2082;
            v76 = (char *)v62;
            uint64_t v77 = 2048;
            v78 = (const char *)v69;
            unint64_t v79 = 2082;
            int v80 = v59;
            _os_log_impl( &dword_181A5C000,  v50,  v60,  "%{public}s protocol %{public}s (%p) has invalid get_path callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v59);
        }

      if (v34) {
        free(v34);
      }
      BOOL v15 = 0;
      goto LABEL_32;
    }

    v86[0] = 0LL;
    v86[1] = v86;
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      callbacks = a2[1].callbacks;
      if (callbacks) {
        a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      v91 = a2;
      os_log_type_t v9 = v92 | 1;
    }

    else
    {
      v91 = a2;
      os_log_type_t v9 = v92 & 0xFE;
    }

    v92 = v9;
    if (*(_UNKNOWN **)&v4[-1].log_str[33] == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v12 = *(void *)&v4[-1].log_str[81];
      if (v12) {
        *(void *)&v4[-1].log_str[81] = v12 + 1;
      }
      *(void *)v89 = (char *)v4 - 96;
      os_log_type_t v11 = v90 | 1;
    }

    else
    {
      *(void *)v89 = (char *)v4 - 96;
      os_log_type_t v11 = v90 & 0xFE;
    }

    v90 = v11;
    char v13 = a2->callbacks;
    if (!v13
      || (get_input_frames = (uint64_t (*)(nw_protocol *, unsigned __int16 *, uint64_t, uint64_t, uint64_t, void *))v13->get_input_frames) == 0LL)
    {
      __nwlog_obj();
      os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
      identifier = a2->identifier;
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = identifier;
      *(_WORD *)&buf[22] = 2048;
      v94 = a2;
      log = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v87 = 0;
      os_log_type_t v27 = (char *)log;
      if (!__nwlog_fault(log, &type, &v87))
      {
LABEL_118:
        if (v27) {
          free(v27);
        }
        BOOL v15 = 0;
        if ((v11 & 1) == 0) {
          goto LABEL_24;
        }
LABEL_23:
        nw::release_if_needed<nw_protocol *>((uint64_t *)v89);
        goto LABEL_24;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v72 = type;
        if (os_log_type_enabled(v28, type))
        {
          v29 = a2->identifier;
          if (!v29) {
            v29 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2048;
          v94 = a2;
          _os_log_impl( &dword_181A5C000,  v28,  v72,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback",  buf,  0x20u);
        }
      }

      else
      {
        if (v87)
        {
          v37 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v70 = type;
          v38 = os_log_type_enabled(v74, type);
          if (v37)
          {
            if (v38)
            {
              os_log_type_t v39 = a2->identifier;
              if (!v39) {
                os_log_type_t v39 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v39;
              *(_WORD *)&buf[22] = 2048;
              v94 = a2;
              LOWORD(v95) = 2082;
              *(void *)((char *)&v95 + 2) = v37;
              _os_log_impl( &dword_181A5C000,  v74,  v70,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v37);
          }

          else
          {
            if (v38)
            {
              v54 = a2->identifier;
              if (!v54) {
                v54 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v54;
              *(_WORD *)&buf[22] = 2048;
              v94 = a2;
              _os_log_impl( &dword_181A5C000,  v74,  v70,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace",  buf,  0x20u);
            }
          }

          goto LABEL_117;
        }

        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v76 = type;
        if (os_log_type_enabled(v28, type))
        {
          BOOL v51 = a2->identifier;
          if (!v51) {
            BOOL v51 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v51;
          *(_WORD *)&buf[22] = 2048;
          v94 = a2;
          _os_log_impl( &dword_181A5C000,  v28,  v76,  "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded",  buf,  0x20u);
        }
      }

LABEL_117:
      os_log_type_t v27 = (char *)log;
      goto LABEL_118;
    }

    BOOL v15 = get_input_frames(a2, &v4[-1].paths_log_id_num, 1LL, 0xFFFFFFFFLL, 0xFFFFFFFFLL, v86);
    if ((v11 & 1) != 0) {
      goto LABEL_23;
    }
LABEL_24:
    if ((v9 & 1) != 0)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)&v91);
      if (!v15) {
        goto LABEL_32;
      }
    }

    else if (!v15)
    {
      goto LABEL_32;
    }

    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL45nw_protocol_implementation_get_input_internalP31NWConcrete_nw_protocol_instanceP11nw_protocolmjjj_block_invoke;
    v94 = (nw_protocol *)&unk_189BB77F0;
    *((void *)&v95 + 1) = v86;
    *(void *)&v95 = v8;
    v96 = v7;
    char v16 = v86[0];
    do
    {
      if (!v16) {
        break;
      }
      uint64_t v17 = *(void *)(v16 + 32);
      id v18 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      char v16 = v17;
    }

    while ((v18 & 1) != 0);

LABEL_32:
    nw_protocol_instance_flush_batched_input_internal(v8);
    if (!v4->pending_inbound_frames.tqh_last) {
      goto LABEL_46;
    }
    if ((SBYTE5(v4->flow_in_connected) & 0x80000000) == 0 && gLogDatapath)
    {
      __nwlog_obj();
      v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_read";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)&v4->flow_in_connected + 7;
        *(_WORD *)&buf[22] = 2080;
        v94 = (nw_protocol *)" ";
        _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing pending outbound frames (one-off)",  buf,  0x20u);
      }
    }

    BOOL v19 = *(void *)&v4[-1].log_str[25];
    if (v19)
    {
      if (*(_UNKNOWN **)(v19 + 40) == &nw_protocol_ref_counted_handle)
      {
        int v21 = *(void *)(v19 + 88);
        if (v21) {
          *(void *)(v19 + 8_Block_object_dispose(va, 8) = v21 + 1;
        }
        v91 = (nw_protocol *)v19;
        __int16 v20 = v92 | 1;
      }

      else
      {
        v91 = *(nw_protocol **)&v4[-1].log_str[25];
        __int16 v20 = v92 & 0xFE;
      }

      v92 = v20;
      __int16 v22 = *(void *)(v19 + 24);
      if (v22)
      {
        os_log_type_t v23 = *(void (**)(uint64_t, nw_frame ***))(v22 + 96);
        if (v23)
        {
          v23(v19, &v4->pending_inbound_frames.tqh_last);
LABEL_44:
          if ((v20 & 1) != 0) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)&v91);
          }
          goto LABEL_46;
        }
      }

      __nwlog_obj();
      loga = (os_log_t)objc_claimAutoreleasedReturnValue();
      v30 = *(const char **)(v19 + 16);
      if (!v30) {
        v30 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v30;
      *(_WORD *)&buf[22] = 2048;
      v94 = (nw_protocol *)v19;
      v31 = (char *)_os_log_send_and_compose_impl();

      v89[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v86[0]) = 0;
      if (__nwlog_fault(v31, v89, v86))
      {
        if (v89[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          logb = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v73 = v89[0];
          if (os_log_type_enabled(logb, v89[0]))
          {
            __int16 v32 = *(const char **)(v19 + 16);
            if (!v32) {
              __int16 v32 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v32;
            *(_WORD *)&buf[22] = 2048;
            v94 = (nw_protocol *)v19;
            _os_log_impl( &dword_181A5C000,  logb,  v73,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback",  buf,  0x20u);
          }
        }

        else
        {
          if (LOBYTE(v86[0]))
          {
            *(void *)v75 = v31;
            BOOL v45 = __nw_create_backtrace_string();
            __nwlog_obj();
            logc = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v69 = v89[0];
            v46 = os_log_type_enabled(logc, v89[0]);
            v71 = (char *)v45;
            if (v45)
            {
              if (v46)
              {
                v47 = *(const char **)(v19 + 16);
                if (!v47) {
                  v47 = "invalid";
                }
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v47;
                *(_WORD *)&buf[22] = 2048;
                v94 = (nw_protocol *)v19;
                LOWORD(v95) = 2082;
                *(void *)((char *)&v95 + 2) = v45;
                _os_log_impl( &dword_181A5C000,  logc,  v69,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
              }

              v31 = *(char **)v75;
              free(v71);
            }

            else
            {
              if (v46)
              {
                v57 = *(const char **)(v19 + 16);
                if (!v57) {
                  v57 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v57;
                *(_WORD *)&buf[22] = 2048;
                v94 = (nw_protocol *)v19;
                _os_log_impl( &dword_181A5C000,  logc,  v69,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  buf,  0x20u);
              }

              v31 = *(char **)v75;
            }

            goto LABEL_135;
          }

          __nwlog_obj();
          logb = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v77 = v89[0];
          if (os_log_type_enabled(logb, v89[0]))
          {
            v55 = *(const char **)(v19 + 16);
            if (!v55) {
              v55 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v55;
            *(_WORD *)&buf[22] = 2048;
            v94 = (nw_protocol *)v19;
            _os_log_impl( &dword_181A5C000,  logb,  v77,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

        BYTE1(v10[1].super.isa) |= 0x80u;
        if ((v35 & 0x2000) == 0) {
          goto LABEL_21;
        }
LABEL_141:
        BYTE2(v10[1].super.isa) |= 1u;
        goto LABEL_21;
      case 8:
        if ((_DWORD)v18 == 8) {
          goto LABEL_98;
        }
        if (v18 >= 9)
        {
          __nwlog_obj();
          v106 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 8;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&_BYTE buf[24] = 1024;
            *(_DWORD *)&buf[26] = 8;
            _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
          }

LABEL_98:
          v10->interface_struct = *(necp_client_result_interface *)v29;
        }

        v38 = nw_parameters_copy_context(v4->parameters);
        os_log_type_t v39 = nw_path_copy_interface_with_generation(v38, v10->interface_struct.index, v10->interface_struct.generation);
        interface = v10->interface;
        v10->interface = (OS_nw_interface *)v39;

        goto LABEL_21;
      case 12:
        if ((_DWORD)v18 == 12) {
          goto LABEL_107;
        }
        if (v18 >= 0xD)
        {
          __nwlog_obj();
          v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 12;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&_BYTE buf[24] = 1024;
            *(_DWORD *)&buf[26] = 12;
            _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
          }

LABEL_107:
          v47 = *((_DWORD *)v29 + 2);
          BOOL v48 = *(necp_client_result_interface *)v29;
          BYTE2(v10[1].super.isa) |= 2u;
          *(necp_client_result_interface *)&v10->ctl_command_value = v48;
          *(_DWORD *)&v10->tfo_cookie_len = v47;
        }

        goto LABEL_21;
      case 13:
        if (v18 <= 0x10)
        {
          memcpy(__dst, v29, v18);
          LOBYTE(v10[1].super.isa) = v18;
          goto LABEL_21;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v63 = (id)gLogObj;
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 13;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v18;
        *(_WORD *)&_BYTE buf[24] = 2080;
        *(void *)&buf[26] = "nw_path_create_flow_result_from_tlv";
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = 2413;
        v64 = (char *)_os_log_send_and_compose_impl();

        v178[0] = 16;
        v177 = 0;
        if (v178[0] == 17)
        {
          __nwlog_obj();
          v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v66 = v178[0];
          if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
          {
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 13;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&_BYTE buf[24] = 2080;
            *(void *)&buf[26] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = 2413;
            _os_log_impl( &dword_181A5C000,  v65,  v66,  "%{public}s TLV of type %d has invalid length %u (%s:%d)",  buf,  0x28u);
          }

          goto LABEL_217;
        }

        if (v177)
        {
          v74 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v76 = v178[0];
          uint64_t v77 = os_log_type_enabled(v75, (os_log_type_t)v178[0]);
          if (v74)
          {
            if (v77)
            {
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 13;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v18;
              *(_WORD *)&_BYTE buf[24] = 2080;
              *(void *)&buf[26] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 2413;
              *(_WORD *)&buf[40] = 2082;
              *(void *)&buf[42] = v74;
              _os_log_impl( &dword_181A5C000,  v75,  v76,  "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s",  buf,  0x32u);
            }

            free(v74);
          }

          else
          {
            if (v77)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 13;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v18;
              *(_WORD *)&_BYTE buf[24] = 2080;
              *(void *)&buf[26] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 2413;
              _os_log_impl( &dword_181A5C000,  v75,  v76,  "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace",  buf,  0x28u);
            }
          }

          goto LABEL_218;
        }

        __nwlog_obj();
        v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v89 = v178[0];
        if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
        {
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 13;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v18;
          *(_WORD *)&_BYTE buf[24] = 2080;
          *(void *)&buf[26] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = 2413;
          _os_log_impl( &dword_181A5C000,  v65,  v89,  "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded",  buf,  0x28u);
        }

        goto LABEL_217;
      case 16:
        if ((_DWORD)v18 == 16) {
          goto LABEL_91;
        }
        if (v18 >= 0x11)
        {
          __nwlog_obj();
          v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 16;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&_BYTE buf[24] = 1024;
            *(_DWORD *)&buf[26] = 16;
            _os_log_impl( &dword_181A5C000,  v105,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
          }

LABEL_91:
          *(_OWORD *)v167 = *(_OWORD *)v29;
        }

        goto LABEL_21;
      case 100:
        uuid_clear(uu);
        if ((_DWORD)v18 == 16) {
          goto LABEL_93;
        }
        if (v18 >= 0x11)
        {
          __nwlog_obj();
          v119 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 100;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&_BYTE buf[24] = 1024;
            *(_DWORD *)&buf[26] = 16;
            _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
          }

LABEL_93:
          *(_OWORD *)uu = *(_OWORD *)v29;
        }

        goto LABEL_21;
      case 101:
        if ((_DWORD)v18 == 2) {
          goto LABEL_113;
        }
        if (v18 < 3)
        {
          v10->ctl_command_code = 0;
        }

        else
        {
          __nwlog_obj();
          v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 101;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&_BYTE buf[24] = 1024;
            *(_DWORD *)&buf[26] = 2;
            _os_log_impl( &dword_181A5C000,  v116,  OS_LOG_TYPE_DEBUG,  "%{public}s Permitting TLV of type %u with larger length %u, should be %u",  buf,  0x1Eu);
          }

LABEL_113:
          v10->ctl_command_code = *(unsigned __int16 *)v29;
        }

        goto LABEL_21;
      case 102:
        nexus_key = v10->nexus_key;
        if (nexus_key)
        {
          free(nexus_key);
          v10->nexus_key = 0LL;
        }

        v10->nexus_flow_index = 0;
        BOOL v50 = malloc(v18);
        if (v50)
        {
          v10->nexus_key = v50;
          memcpy(v50, v29, v18);
          v10->nexus_flow_index = v18;
LABEL_21:
          if (v11 >= a3 - 5) {
            goto LABEL_334;
          }
          continue;
        }

        __nwlog_obj();
        v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v108, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "strict_malloc";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v18;
        os_log_type_t v109 = (void *)_os_log_send_and_compose_impl();

        v110 = v4;
        result = __nwlog_abort((uint64_t)v109);
        if (!result)
        {
          free(v109);
          v10->nexus_key = 0LL;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v112 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          v113 = (char *)_os_log_send_and_compose_impl();

          v178[0] = 16;
          v177 = 0;
          if (__nwlog_fault(v113, v178, &v177))
          {
            if (v178[0] == 17)
            {
              __nwlog_obj();
              os_log_type_t v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v115 = v178[0];
              if (os_log_type_enabled(v114, (os_log_type_t)v178[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v18;
                _os_log_impl(&dword_181A5C000, v114, v115, "%{public}s malloc(%u) failed", buf, 0x12u);
              }

              goto LABEL_302;
            }

            if (v177)
            {
              v122 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v123 = v178[0];
              BOOL v124 = os_log_type_enabled(v114, (os_log_type_t)v178[0]);
              if (v122)
              {
                if (v124)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v18;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v122;
                  _os_log_impl( &dword_181A5C000,  v114,  v123,  "%{public}s malloc(%u) failed, dumping backtrace:%{public}s",  buf,  0x1Cu);
                }

                free(v122);
                goto LABEL_306;
              }

              if (v124)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v18;
                _os_log_impl(&dword_181A5C000, v114, v123, "%{public}s malloc(%u) failed, no backtrace", buf, 0x12u);
              }
            }

            else
            {
              __nwlog_obj();
              os_log_type_t v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v129 = v178[0];
              if (os_log_type_enabled(v114, (os_log_type_t)v178[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v18;
                _os_log_impl( &dword_181A5C000,  v114,  v129,  "%{public}s malloc(%u) failed, backtrace limit exceeded",  buf,  0x12u);
              }
            }

      id v67 = v162;
      if (!v162)
      {
LABEL_142:

        return (BOOL)v21;
      }

            if ((~v4 & 6) != 0)
            {
              if ((v4 & 0x100) == 0) {
                goto LABEL_155;
              }
              if ((*v2 & 0x80) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v60 = (os_log_s *)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)os_log_type_t type = 136446466;
                  *(void *)&type[4] = "nw_socket_handle_socket_event";
                  *(_WORD *)&type[12] = 2082;
                  *(void *)&type[14] = v1 + 308;
                  _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Socket received KEEPALIVE event",  type,  0x16u);
                }
              }

              if (_nw_signposts_once == -1)
              {
                if (_nw_signposts_enabled) {
                  goto LABEL_149;
                }
              }

              else
              {
                dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
                if (_nw_signposts_enabled)
                {
LABEL_149:
                }
              }

              v61 = *(void *)(v1 + 48);
              if (v61)
              {
                v62 = *(void *)(v61 + 24);
                if (v62)
                {
                  v63 = *(void (**)(uint64_t, uint64_t))(v62 + 160);
                  if (v63) {
                    v63(v61, v1 - 96);
                  }
                }
              }

  if (v48) {
    free(v48);
  }
LABEL_142:
  *(_DWORD *)os_log_type_t v103 = nw_tcp_options_get_persist_timeout(a2);
  if (!*(_DWORD *)v103 || !setsockopt(*(_DWORD *)(a1 + 172), 6, 64, v103, 4u)) {
    goto LABEL_167;
  }
  v54 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v55 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v107 = "nw_socket_set_bidirectional_tcp_sockopts";
    v108 = 2080;
    *(void *)os_log_type_t v109 = a1 + 308;
    *(_WORD *)&v109[8] = 1024;
    *(_DWORD *)&v109[10] = v54;
    _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v56 = (os_log_s *)gLogObj;
  if (v54 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = 22;
      _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d",  buf,  0x12u);
    }

    goto LABEL_167;
  }

  *(_DWORD *)buf = 136446466;
  v107 = "nw_socket_set_bidirectional_tcp_sockopts";
  v108 = 1024;
  *(_DWORD *)os_log_type_t v109 = v54;
  v57 = (char *)_os_log_send_and_compose_impl();
  v102[0] = OS_LOG_TYPE_ERROR;
  v101[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v57, v102, v101))
  {
    if (v102[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v58 = (os_log_s *)gLogObj;
      v59 = v102[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v102[0])) {
        goto LABEL_165;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = v54;
      v60 = "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d";
      goto LABEL_164;
    }

    if (v101[0] == OS_LOG_TYPE_DEFAULT)
    {
      v58 = (os_log_s *)__nwlog_obj();
      v59 = v102[0];
      if (!os_log_type_enabled(v58, v102[0])) {
        goto LABEL_165;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = v54;
      v60 = "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_164;
    }

    v61 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v58 = (os_log_s *)gLogObj;
    v59 = v102[0];
    v62 = os_log_type_enabled((os_log_t)gLogObj, v102[0]);
    if (v61)
    {
      if (v62)
      {
        *(_DWORD *)buf = 136446722;
        v107 = "nw_socket_set_bidirectional_tcp_sockopts";
        v108 = 1024;
        *(_DWORD *)os_log_type_t v109 = v54;
        *(_WORD *)&v109[4] = 2082;
        *(void *)&v109[6] = v61;
        _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v61);
      goto LABEL_165;
    }

    if (v62)
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = v54;
      v60 = "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, no backtrace";
LABEL_164:
      _os_log_impl(&dword_181A5C000, v58, v59, v60, buf, 0x12u);
    }
  }

  __break(1u);
  return result;
}

            goto LABEL_119;
          }
        }

        if (*(_DWORD *)v89)
        {
          BOOL v51 = (OS_nw_interface *)nw_interface_create_with_index(*(unsigned int *)v89);
          BOOL v52 = self->super._interface;
          self->super._interface = v51;
        }
      }
    }

    v59 = 0LL;
    goto LABEL_70;
  }

        v66 = 0;
LABEL_141:
        if (!v12)
        {
LABEL_150:
          os_release(v6);
          os_log_type_t v25 = 0LL;
          *((_DWORD *)handle + 46) = v66;
          switch(v66)
          {
            case 0:
              nw_protocol_http_messaging_error((nw_protocol *)handle, (nw_protocol *)handle);
              nw_protocol_http_messaging_disconnected((nw_protocol *)handle, (nw_protocol *)handle);
              return;
            case 3:
              goto LABEL_37;
            case 4:
              if (nw_protocol_http2_identifier::onceToken != -1) {
                dispatch_once(&nw_protocol_http2_identifier::onceToken, &__block_literal_global_83570);
              }
              os_log_type_t v25 = &nw_protocol_http2_identifier::http2_protocol_identifier;
              if ((handle[272] & 1) != 0) {
                goto LABEL_40;
              }
              goto LABEL_159;
            case 5:
              if (nw_protocol_http3_identifier::onceToken != -1) {
                dispatch_once(&nw_protocol_http3_identifier::onceToken, &__block_literal_global_10);
              }
              os_log_type_t v25 = &nw_protocol_http3_identifier::http3_protocol_identifier;
              if ((handle[272] & 1) != 0) {
                goto LABEL_40;
              }
LABEL_159:
              if (nw_endpoint_is_registered(*((void **)handle + 14)))
              {
                nw_endpoint_add_edges_for_instance(*((void **)handle + 14), (unsigned __int8 *)handle, 1);
              }

              else if ((handle[272] & 2) == 0)
              {
                v89 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v101 = "nw_protocol_http_messaging_connected";
                  v102 = 2082;
                  os_log_type_t v103 = handle + 188;
                  v104 = 2080;
                  v105 = " ";
                  _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sconnection's endpoint is not registered, cannot add edges",  buf,  0x20u);
                }
              }

              break;
            default:
              goto LABEL_40;
          }

          goto LABEL_40;
        }

        goto LABEL_149;
      }

      is_quic_stream = nw_protocol_metadata_is_quic_stream(v12);

      if (is_quic_stream) {
        goto LABEL_81;
      }
    }

    else
    {
      if ((handle[272] & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446722;
          v101 = "nw_http_messaging_get_http_version_from_alpn";
          v102 = 2082;
          os_log_type_t v103 = handle + 188;
          v104 = 2080;
          v105 = " ";
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sTop metadata isn't TLS, assuming HTTP/1.1",  buf,  0x20u);
        }
      }

      if (!v6) {
        goto LABEL_36;
      }
    }

    os_release(v6);
LABEL_36:
    *((_DWORD *)handle + 46) = 3;
LABEL_37:
    if (nw_protocol_http1_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http1_identifier::onceToken, &__block_literal_global_39881);
    }
    os_log_type_t v25 = &nw_protocol_http1_identifier::http1_protocol_identifier;
LABEL_40:
    internal = nw_protocol_create_internal((uint64_t)v25, *((void **)handle + 14), *((const char **)handle + 12), 0);
    *((void *)handle + 19) = internal;
    *(void *)(internal + 16) = *((void *)handle + 2);
    os_log_type_t v27 = *((void *)handle + 6);
    nw_protocol_set_input_handler((uint64_t)handle, 0LL);
    nw_http_messaging_add_to_version_specific_protocol((uint64_t)handle, v27);
    nw_protocol_add_listen_handler(*((void *)handle + 19), (uint64_t)(handle + 64));
    nw_protocol_replace_input_handler(*((void *)handle + 4), (uint64_t)handle, *(void *)(v27 + 32));
    nw_protocol_set_output_handler((uint64_t)handle, 0LL);
    nw_protocol_connect(*(void *)(v27 + 32), v27);
    os_log_type_t v28 = handle + 188;
    v29 = &nwlog_legacy_init(void)::init_once;
    v30 = nwlog_legacy_init_once;
    v31 = &qword_18C45F000;
    __int16 v32 = "nw_protocol_http_messaging_connected";
    while (1)
    {
      os_log_type_t v34 = *((void *)handle + 20);
      v33 = *((void *)handle + 21);
      v35 = v34;
      if (v34 != v33)
      {
        while (*(_DWORD *)(v35 + 8) == 2)
        {
          v35 += 16LL;
          if (v35 == v33) {
            return;
          }
        }
      }

      if (v35 == v33) {
        return;
      }
      v36 = *(void **)v35;
      v37 = *(_DWORD *)(v35 + 8);
      v38 = v35 + 16;
      if (v35 + 16 != v33)
      {
        os_log_type_t v39 = v33 - v35 - 32;
        if (v39 >= 0x10)
        {
          v40 = (v35 - v34) >> 4;
          v41 = (v39 >> 4) + 1;
          BOOL v42 = 16 * (v41 & 0x1FFFFFFFFFFFFFFELL);
          v35 += v42;
          v43 = v34 + 16 * v40 + 24;
          v44 = v41 & 0x1FFFFFFFFFFFFFFELL;
          do
          {
            BOOL v45 = *(void *)(v43 + 8);
            *(void *)(v43 - 24) = *(void *)(v43 - 8);
            *(void *)(v43 - _Block_object_dispose(va, 8) = v45;
            LODWORD(v45) = *(_DWORD *)(v43 + 16);
            *(_DWORD *)(v43 - 16) = *(_DWORD *)v43;
            *(_DWORD *)v43 = v45;
            v43 += 32LL;
            v44 -= 2LL;
          }

          while (v44);
          if (v41 == (v41 & 0x1FFFFFFFFFFFFFFELL)) {
            goto LABEL_53;
          }
          v38 += v42;
        }

        do
        {
          *(void *)v35 = *(void *)v38;
          *(_DWORD *)(v35 + _Block_object_dispose(va, 8) = *(_DWORD *)(v38 + 8);
          v35 += 16LL;
          v38 += 16LL;
        }

        while (v38 != v33);
      }

        int v21 = v10;
        goto LABEL_141;
      default:
        goto LABEL_140;
    }
  }

    goto LABEL_106;
  }

  if (!v4)
  {
    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_association_mark_flow_disconnected";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v60 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_181A5C000, v17, v60, "%{public}s called with null handle", buf, 0xCu);
      }

      goto LABEL_140;
    }

    if (!v68)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v67 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl( &dword_181A5C000,  v17,  v67,  "%{public}s called with null handle, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_140;
    }

    int v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v64 = type;
    v65 = os_log_type_enabled(v17, type);
    if (!v21)
    {
      if (v65)
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_181A5C000, v17, v64, "%{public}s called with null handle, no backtrace", buf, 0xCu);
      }

      goto LABEL_140;
    }

    if (v65)
    {
      *(_DWORD *)buf = 136446466;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      int v73 = v21;
      _os_log_impl( &dword_181A5C000,  v17,  v64,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_31;
  }

  v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);

  int v7 = *((void *)v3 + 5);
  if (!v7)
  {
    if (nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
      goto LABEL_108;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v14 = (id)gconnectionLogObj;
    logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446466;
    v71 = "nw_association_mark_flow_disconnected";
    v72 = 2082;
    int v73 = (void *)logging_description;
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v17 = (os_log_s *)(id)gconnectionLogObj;
      id v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        BOOL v19 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        int v73 = (void *)v19;
        _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s <nw_association %{public}s> does not have a handle hash table",  buf,  0x16u);
      }

      goto LABEL_140;
    }

    if (!v68)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v17 = (os_log_s *)(id)gconnectionLogObj;
      v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        v30 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        int v73 = (void *)v30;
        _os_log_impl( &dword_181A5C000,  v17,  v29,  "%{public}s <nw_association %{public}s> does not have a handle hash table, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_140;
    }

    __int16 v20 = __nw_create_backtrace_string();
    if (!v20)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v17 = (os_log_s *)(id)gconnectionLogObj;
      v31 = type;
      if (os_log_type_enabled(v17, type))
      {
        __int16 v32 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        int v73 = (void *)v32;
        _os_log_impl( &dword_181A5C000,  v17,  v31,  "%{public}s <nw_association %{public}s> does not have a handle hash table, no backtrace",  buf,  0x16u);
      }

      goto LABEL_140;
    }

    int v21 = (char *)v20;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v17 = (os_log_s *)(id)gconnectionLogObj;
    __int16 v22 = type;
    if (os_log_type_enabled(v17, type))
    {
      os_log_type_t v23 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446722;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      int v73 = (void *)v23;
      v74 = 2082;
      v75 = v21;
      _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s <nw_association %{public}s> does not have a handle hash table, dumping backtrace:%{public}s",  buf,  0x20u);
    }

LABEL_255:
  if (v101) {
    free(v101);
  }
  v60 = 0LL;
  if (v19)
  {
LABEL_143:
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      v88 = a2[1].callbacks;
      if (v88)
      {
        v89 = (nw_protocol_callbacks *)((char *)v88 - 1);
        a2[1].callbacks = v89;
        if (!v89)
        {
          v90 = *(void (***)(void))a2[1].flow_id;
          if (v90)
          {
            *(void *)a2[1].flow_id = 0LL;
            v90[2](v90);
            _Block_release(v90);
          }

          if ((a2[1].flow_id[8] & 1) != 0)
          {
            v91 = *(const void **)a2[1].flow_id;
            if (v91) {
              _Block_release(v91);
            }
          }

          free(a2);
        }
      }
    }
  }

                  v91 = 1LL;
LABEL_307:

                  return v91;
                }

                if (v9[405] < 0) {
                  goto LABEL_306;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v35 = (id)gLogObj;
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v9 + 407;
                *(_WORD *)&buf[22] = 2080;
                v166 = " ";
                *(_WORD *)v167 = 2048;
                *(void *)&v167[2] = a2;
                v36 = (char *)_os_log_send_and_compose_impl();

                v170[0] = 16;
                LOBYTE(v163) = 0;
                if (__nwlog_fault(v36, v170, &v163))
                {
                  if (v170[0] == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v37 = (os_log_s *)(id)gLogObj;
                    v38 = v170[0];
                    if (os_log_type_enabled(v37, (os_log_type_t)v170[0]))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v9 + 407;
                      *(_WORD *)&buf[22] = 2080;
                      v166 = " ";
                      *(_WORD *)v167 = 2048;
                      *(void *)&v167[2] = a2;
                      _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table",  buf,  0x2Au);
                    }
                  }

                  else if ((_BYTE)v163)
                  {
                    backtrace_string = __nw_create_backtrace_string();
                    if (backtrace_string)
                    {
                      v44 = (char *)backtrace_string;
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      BOOL v45 = (os_log_s *)(id)gLogObj;
                      v46 = v170[0];
                      if (os_log_type_enabled(v45, (os_log_type_t)v170[0]))
                      {
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v9 + 407;
                        *(_WORD *)&buf[22] = 2080;
                        v166 = " ";
                        *(_WORD *)v167 = 2048;
                        *(void *)&v167[2] = a2;
                        v168 = 2082;
                        v169 = v44;
                        _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, dumping back trace:%{public}s",  buf,  0x34u);
                      }

                      free(v44);
                      if (!v36) {
                        goto LABEL_306;
                      }
                      goto LABEL_84;
                    }

                    __nwlog_obj();
                    v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    BOOL v53 = v170[0];
                    if (os_log_type_enabled(v37, (os_log_type_t)v170[0]))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v9 + 407;
                      *(_WORD *)&buf[22] = 2080;
                      v166 = " ";
                      *(_WORD *)v167 = 2048;
                      *(void *)&v167[2] = a2;
                      _os_log_impl( &dword_181A5C000,  v37,  v53,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, no backtrace",  buf,  0x2Au);
                    }
                  }

                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v37 = (os_log_s *)(id)gLogObj;
                    BOOL v48 = v170[0];
                    if (os_log_type_enabled(v37, (os_log_type_t)v170[0]))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v9 + 407;
                      *(_WORD *)&buf[22] = 2080;
                      v166 = " ";
                      *(_WORD *)v167 = 2048;
                      *(void *)&v167[2] = a2;
                      _os_log_impl( &dword_181A5C000,  v37,  v48,  "%{public}s %{public}s%sFailed to remove protocol node for protocol %p from table, backtrace limit exceeded",  buf,  0x2Au);
                    }
                  }

                  goto LABEL_82;
                }

  if (v73) {
    free(v73);
  }
  return 0LL;
}

                goto LABEL_227;
              }

              if (!v147)
              {
                __nwlog_obj();
                v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v133 = type;
                if (os_log_type_enabled(v93, type))
                {
                  *(_DWORD *)buf = 136446210;
                  v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                  _os_log_impl( &dword_181A5C000,  v93,  v133,  "%{public}s called with null (configure_tcp_fallback != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded",  buf,  0xCu);
                }

                goto LABEL_255;
              }

              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v121 = type;
              v122 = os_log_type_enabled(v108, type);
              if (backtrace_string)
              {
                if (v122)
                {
                  *(_DWORD *)buf = 136446466;
                  v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                  v151 = 2082;
                  v152 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v108,  v121,  "%{public}s called with null (configure_tcp_fallback != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s",  buf,  0x16u);
                }

    if (v89) {
      free(v89);
    }
LABEL_257:
    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
LABEL_268:

LABEL_269:
    v65 = v222;
    goto LABEL_270;
  }

  *(_WORD *)__dst[0].sa_data = v21;
  os_log_type_t v25 = nw_endpoint_create_address(__dst);
  v220 = v25;
  if (!v25)
  {
    __nwlog_obj();
    v100 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    v101 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(buffer) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v101, &buffer, type))
    {
      if (buffer == 17)
      {
        __nwlog_obj();
        v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v103 = buffer;
        if (os_log_type_enabled(v102, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_181A5C000, v102, v103, "%{public}s nw_endpoint_create_address failed", applier, 0xCu);
        }
      }

      else if (type[0])
      {
        v126 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v127 = buffer;
        v128 = os_log_type_enabled(v102, (os_log_type_t)buffer);
        if (v126)
        {
          if (v128)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = v126;
            _os_log_impl( &dword_181A5C000,  v102,  v127,  "%{public}s nw_endpoint_create_address failed, dumping backtrace:%{public}s",  applier,  0x16u);
          }

          free(v126);
          goto LABEL_264;
        }

        if (v128)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v102,  v127,  "%{public}s nw_endpoint_create_address failed, no backtrace",  applier,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v192 = buffer;
        if (os_log_type_enabled(v102, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v102,  v192,  "%{public}s nw_endpoint_create_address failed, backtrace limit exceeded",  applier,  0xCu);
        }
      }
    }

LABEL_156:
  if (v66)
  {
    LODWORD(a1[3].identifier) = nw_path_get_maximum_packet_size(v66);
    HIDWORD(a1[3].identifier) = nw_path_get_mtu(v66);
    LOBYTE(a1[3].handle) = (16 * (nw_path_get_csum_flags(v66) & 1)) | (uint64_t)a1[3].handle & 0xEF;
    id v67 = v66[12];
    if (v67)
    {
      id v68 = v67;
      v69 = v68;
      if ((*(_WORD *)((_BYTE *)v68 + 85) & 0x80) != 0) {
        int v70 = *((_DWORD *)v68 + 18);
      }
      else {
        int v70 = 0;
      }

      HIDWORD(a1[3].callbacks) = v70;
      v71 = v69;
      v72 = v71;
      if ((*(_WORD *)(v69 + 85) & 0x100) != 0) {
        int v73 = v71[19];
      }
      else {
        int v73 = 0;
      }

      LODWORD(a1[3].output_handler) = v73;
      os_release(v72);
    }
  }

    if (v70) {
      free(v70);
    }

LABEL_159:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v106 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446210;
    *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    v181 = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v107 = (os_log_s *)(id)gLogObj;
      v108 = __str[0];
      if (os_log_type_enabled(v107, __str[0]))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_181A5C000, v107, v108, "%{public}s failed to add kIDSKeyRemoteInterfaceType", type, 0xCu);
      }
    }

    else if (v181)
    {
      os_log_type_t v109 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v110 = __str[0];
      v111 = os_log_type_enabled(v107, __str[0]);
      if (v109)
      {
        if (v111)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          *(void *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&type[12] = 2082;
          *(void *)&type[14] = v109;
          _os_log_impl( &dword_181A5C000,  v107,  v110,  "%{public}s failed to add kIDSKeyRemoteInterfaceType, dumping backtrace:%{public}s",  type,  0x16u);
        }

        free(v109);
LABEL_175:
        if (!v74)
        {
LABEL_177:
          v96 = 0LL;
          goto LABEL_178;
        }

    if (v67) {
      free(v67);
    }
    goto LABEL_158;
  }

  if (v12[190] < 0 || *((int *)v12 + 10) >= 3)
  {
    if (!nw_parameters_get_logging_disabled(*((void *)v12 + 7)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      v71 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        v72 = *((_DWORD *)v12 + 42);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v72;
        _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] Cannot send a message on a failed or cancelled group",  buf,  0x12u);
      }
    }

    int v73 = 89LL;
    goto LABEL_159;
  }

  if (v10) {
    goto LABEL_5;
  }
  os_log_type_t v28 = nw_group_descriptor_copy_members(*((void **)v12 + 8));
  __int16 v22 = v28;
  if (!v28 || *((void *)v28 + 3) == *((void *)v28 + 2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v41 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
    BOOL v42 = (char *)_os_log_send_and_compose_impl();

    v154[0] = 16;
    v152[0] = 0;
    if (v154[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v43 = (os_log_s *)(id)gLogObj;
      v44 = v154[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v154[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
        _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s Cannot find endpoints for sending", buf, 0xCu);
      }
    }

    else if (v152[0])
    {
      BOOL v45 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v43 = (os_log_s *)(id)gLogObj;
      v46 = v154[0];
      v47 = os_log_type_enabled(v43, (os_log_type_t)v154[0]);
      if (v45)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v45;
          _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s Cannot find endpoints for sending, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v45);
        if (!v42) {
          goto LABEL_73;
        }
        goto LABEL_72;
      }

      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
        _os_log_impl( &dword_181A5C000,  v43,  v46,  "%{public}s Cannot find endpoints for sending, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v43 = (os_log_s *)(id)gLogObj;
      v57 = v154[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v154[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
        _os_log_impl( &dword_181A5C000,  v43,  v57,  "%{public}s Cannot find endpoints for sending, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_70;
  }

  v29 = nw_array_get_object_at_index((uint64_t)v28, 0LL);
  if (v29)
  {
    BOOL v10 = (id)v29;

LABEL_5:
    BOOL v10 = v10;
    v115 = (void *)[v10 copyEndpoint];
    nw_endpoint_copy_properties(v10, v115);

    char v13 = *((id *)v12 + 7);
    v14 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v13,  0,  0);

    BOOL v15 = v12;
    char v16 = (void *)*((void *)v15 + 8);
    host_with_numeric_port = (BOOL)v15;
    if (v16)
    {
      id v18 = v16;
      BOOL v19 = v18[2];

      if (v19 != 1) {
        goto LABEL_9;
      }
      port = nw_connection_group_get_port(v15);
      host_with_numeric_port = nw_endpoint_create_host_with_numeric_port("0.0.0.0", port);
      nw_parameters_set_reuse_local_address((nw_parameters_t)v14, 1);
      nw_parameters_set_local_endpoint((nw_parameters_t)v14, (nw_endpoint_t)host_with_numeric_port);
      nw_parameters_set_allow_socket_access((void *)v14, 1);
    }

LABEL_9:
    int v21 = v15;
    __int16 v22 = v115;
    os_log_type_t v23 = (id)v14;
    v117 = v23;
    if (v22)
    {
      uint64_t v24 = v23;
      if (v23)
      {
        __int16 v135 = 0LL;
        v136 = &v135;
        __int16 v137 = 0x3032000000LL;
        v138 = __Block_byref_object_copy__8579;
        __int16 v139 = __Block_byref_object_dispose__8580;
        v140 = 0LL;
        char v131 = 0LL;
        v132 = &v131;
        v133 = 0x2020000000LL;
        v134 = 0;
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke;
        *(void *)&_BYTE buf[24] = &unk_189BB7300;
        os_log_type_t v114 = v21;
        *(void *)&buf[32] = v114;
        v150 = &v131;
        os_log_type_t v25 = v24;
        v148 = v25;
        v113 = v22;
        v149 = v113;
        v151 = &v135;
        BOOL v26 = (void (**)(void))_Block_copy(buf);
        os_unfair_lock_lock(v21 + 43);
        v26[2](v26);
        os_unfair_lock_unlock(v21 + 43);

        if (*((_BYTE *)v132 + 24))
        {
          os_log_type_t v27 = 0LL;
LABEL_61:

          _Block_object_dispose(&v131, 8);
          _Block_object_dispose(&v135, 8);

          v61 = v117;
LABEL_62:

          if (v27)
          {
            if (!nw_parameters_get_logging_disabled(*((void *)v12 + 7)) && gLogDatapath)
            {
              if (__nwlog_connection_group_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
              }
              char v85 = (os_log_s *)(id)gconnection_groupLogObj;
              if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
              {
                os_unfair_lock_opaque = v21[42]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = os_unfair_lock_opaque;
                *(_WORD *)&buf[18] = 2112;
                *(void *)&buf[20] = v22;
                *(_WORD *)&buf[28] = 2112;
                *(void *)&buf[30] = v117;
                *(_WORD *)&buf[38] = 2112;
                v148 = v27;
                _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Got connection for endpoint (%@) and parameters (%@): %@",  buf,  0x30u);
              }
            }

            nw_connection_group_touch_connection((NWConcrete_nw_connection_group *)v21, v27);
            completion[0] = MEMORY[0x1895F87A8];
            completion[1] = 3221225472LL;
            completion[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_150;
            completion[3] = &unk_189BB8328;
            v122 = v21;
            v123 = v27;
            BOOL v124 = (void (**)(void))v119;
            nw_connection_send((nw_connection_t)v123, content, context, 1, completion);
            v62 = (id *)&v122;
            v63 = (id *)&v123;
            v64 = v124;
          }

          else
          {
            v125[0] = MEMORY[0x1895F87A8];
            v125[1] = 3221225472LL;
            v125[2] = ___ZL41nw_connection_group_send_message_internalP30NWConcrete_nw_connection_groupPU27objcproto16OS_dispatch_data8NSObjectPU25objcproto14OS_nw_endpointS1_PU32objcproto21OS_nw_content_contextS1_U13block_pointerFvPU22objcproto11OS_nw_errorS1_E_block_invoke_148;
            v125[3] = &unk_189BC91E8;
            v126 = v21;
            v127 = v119;
            v64 = (void (**)(void))_Block_copy(v125);
            os_unfair_lock_lock(v21 + 43);
            v64[2](v64);
            v62 = (id *)&v126;
            v63 = &v127;
            os_unfair_lock_unlock(v21 + 43);
          }

          goto LABEL_74;
        }

        if (v136[5])
        {
          v30 = (void *)*((void *)v15 + 8);
          if (!v30 || (v31 = v30, __int16 v32 = v31[2], v31, v32 != 2))
          {
LABEL_60:
            os_log_type_t v27 = (NWConcrete_nw_connection *)(id)v136[5];
            goto LABEL_61;
          }
        }

        if (!nw_parameters_get_logging_disabled(*((void *)v12 + 7)) && gLogDatapath)
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          v94 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
          {
            v95 = v114[42]._os_unfair_lock_opaque;
            *(_DWORD *)v154 = 136446978;
            *(void *)&v154[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            *(_WORD *)&v154[12] = 1024;
            *(_DWORD *)&v154[14] = v95;
            *(_WORD *)&v154[18] = 2112;
            *(void *)&v154[20] = v113;
            *(_WORD *)&v154[28] = 2112;
            *(void *)&v154[30] = v25;
            _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Did not find connection for (remote: %@, parameters: %@), creating new connection",  v154,  0x26u);
          }
        }

        v33 = (void *)v136[5];
        v110 = v114;
        os_log_type_t v109 = v33;
        v111 = (nw_endpoint *)v113;
        os_log_type_t v34 = v25;
        *(void *)v154 = 0LL;
        *(void *)&v154[8] = v154;
        *(void *)&v154[16] = 0x3032000000LL;
        *(void *)&v154[24] = __Block_byref_object_copy__8579;
        *(void *)&v154[32] = __Block_byref_object_dispose__8580;
        v155 = 0LL;
        v108 = v34;
        parameters = (nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v108,  0,  0);

        v36 = v109;
        v35 = v110;
        nw_parameters_set_reuse_local_address(parameters, 1);
        if (!nw_parameters_get_logging_disabled(*((void *)v12 + 7)) && gLogDatapath)
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          v96 = (os_log_s *)(id)gconnection_groupLogObj;
          v35 = v110;
          if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
          {
            v97 = v110[42]._os_unfair_lock_opaque;
            *(_DWORD *)v152 = 136446978;
            *(void *)&v152[4] = "nw_connection_group_create_connection_for_endpoint_and_parameters";
            *(_WORD *)&v152[12] = 1024;
            *(_DWORD *)&v152[14] = v97;
            *(_WORD *)&v152[18] = 2112;
            *(void *)&v152[20] = v111;
            *(_WORD *)&v152[28] = 2112;
            *(void *)&v152[30] = parameters;
            _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Creating connection for endpoint (%@) and parameters (%@)",  v152,  0x26u);
          }

          v36 = v109;
        }

        v37 = (void *)*((void *)v15 + 8);
        if (v37 && (v38 = v37, os_log_type_t v39 = v38[2], v38, v39 == 2)) {
          v40 = nw_connection_create_with_connection(v36, parameters);
        }
        else {
          v40 = nw_connection_create(v111, parameters);
        }
        BOOL v48 = *(void **)(*(void *)&v154[8] + 40LL);
        *(void *)(*(void *)&v154[8] + 40LL) = v40;

        if (*(void *)(*(void *)&v154[8] + 40LL))
        {
          *(void *)v152 = MEMORY[0x1895F87A8];
          *(void *)&v152[8] = 3221225472LL;
          *(void *)&v152[16] = ___ZL65nw_connection_group_create_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS3_PU33objcproto22OS_nw_protocol_optionsS3_b_block_invoke;
          *(void *)&v152[24] = &unk_189BC9210;
          *(void *)&v152[32] = v35;
          v153 = v154;
          v49 = (void (**)(void))_Block_copy(v152);
          os_unfair_lock_lock(v21 + 43);
          v49[2](v49);
          os_unfair_lock_unlock(v21 + 43);

          BOOL v50 = *(os_log_s **)&v152[32];
        }

        else
        {
          if (nw_parameters_get_logging_disabled(*((void *)v12 + 7))) {
            goto LABEL_47;
          }
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          BOOL v50 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            BOOL v51 = v35[42]._os_unfair_lock_opaque;
            BOOL v52 = *((void *)v12 + 7);
            *(_DWORD *)v152 = 136446722;
            *(void *)&v152[4] = "nw_connection_group_create_connection_for_endpoint_and_parameters";
            *(_WORD *)&v152[12] = 1024;
            *(_DWORD *)&v152[14] = v51;
            *(_WORD *)&v152[18] = 2112;
            *(void *)&v152[20] = v52;
            _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] failed to create connection with parameters %@",  v152,  0x1Cu);
          }
        }

LABEL_47:
        BOOL v53 = *(id *)(*(void *)&v154[8] + 40LL);

        _Block_object_dispose(v154, 8);
        v54 = (void *)v136[5];
        v136[5] = (uint64_t)v53;

        if (v136[5])
        {
          *(void *)v152 = 0LL;
          *(void *)&v152[8] = v152;
          *(void *)&v152[16] = 0x2020000000LL;
          v152[24] = 0;
          *(void *)v154 = MEMORY[0x1895F87A8];
          *(void *)&v154[8] = 3221225472LL;
          *(void *)&v154[16] = ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke_154;
          *(void *)&v154[24] = &unk_189BC9210;
          v155 = v152;
          v55 = v35;
          *(void *)&v154[32] = v55;
          v56 = (void (**)(void))_Block_copy(v154);
          os_unfair_lock_lock(v21 + 43);
          v56[2](v56);
          os_unfair_lock_unlock(v21 + 43);

          if (*(_BYTE *)(*(void *)&v152[8] + 24LL))
          {
            nw_connection_start((nw_connection_t)v136[5]);
          }

          else if (!nw_parameters_get_logging_disabled(*((void *)v12 + 7)))
          {
            if (__nwlog_connection_group_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
            }
            v58 = (os_log_s *)(id)gconnection_groupLogObj;
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
            {
              v59 = v55[42]._os_unfair_lock_opaque;
              v60 = v136[5];
              *(_DWORD *)uint64_t v141 = 136446722;
              v142 = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
              v143 = 1024;
              v144 = v59;
              v145 = 2112;
              v146 = v60;
              _os_log_impl( &dword_181A5C000,  v58,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Deferring start of connection %@ until group start",  v141,  0x1Cu);
            }
          }

          _Block_object_dispose(v152, 8);
        }

        goto LABEL_60;
      }

      __nwlog_obj();
      v78 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
      v75 = (char *)_os_log_send_and_compose_impl();

      v154[0] = 16;
      v152[0] = 0;
      if (__nwlog_fault(v75, v154, v152))
      {
        if (v154[0] == 17)
        {
          __nwlog_obj();
          v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          unint64_t v79 = v154[0];
          if (os_log_type_enabled(v76, (os_log_type_t)v154[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            _os_log_impl(&dword_181A5C000, v76, v79, "%{public}s called with null parameters", buf, 0xCu);
          }

  if (v47) {
    free(v47);
  }
  return 0LL;
}

    if (v54) {
      free(v54);
    }
  }

      *((_BYTE *)v11 + 475) |= 0x10u;
      resolver_configs = (unsigned __int8 *)v201->resolver_configs;
      if (!resolver_configs) {
        goto LABEL_192;
      }
LABEL_157:
      if (!v11->override_resolver_configs)
      {
        uint64_t v86 = nw_array_create();
        override_resolver_configs = v11->override_resolver_configs;
        v11->override_resolver_configs = (OS_nw_array *)v86;

        resolver_configs = (unsigned __int8 *)v201->resolver_configs;
      }

      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = ___ZL23nw_path_snapshot_agentsP18NWConcrete_nw_path_block_invoke;
      *(void *)&_BYTE buf[24] = &unk_189BC85B0;
      *(void *)&buf[32] = v11;
      nw_array_apply(resolver_configs, (uint64_t)buf);

      int v80 = v201;
      goto LABEL_192;
    }

    BOOL v42 = 0LL;
    v199 = (unsigned int *)(v18 + 216);
    v198 = (char *)(v18 + 221);
    v203 = (char *)(v18 + 217);
    v204 = v32 - 1;
    *(void *)v205 = v32 - 5;
    while (1)
    {
      if (v41 < v42)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v43 = (id)gLogObj;
        LODWORD(length[0]) = 136446722;
        *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
        WORD2(length[1]) = 2048;
        *(size_t *)((char *)&length[1] + 6) = v42;
        HIWORD(length[2]) = 2048;
        length[3] = v207;
        v196 = length;
        v44 = (void *)_os_log_send_and_compose_impl();

        LOBYTE(type) = 16;
        LOBYTE(v236) = 0;
        if (__nwlog_fault((const char *)v44, &type, &v236))
        {
          if (type == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v45 = (os_log_s *)(id)gLogObj;
            v46 = type;
            if (os_log_type_enabled(v45, (os_log_type_t)type))
            {
              LODWORD(length[0]) = 136446722;
              *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
              WORD2(length[1]) = 2048;
              *(size_t *)((char *)&length[1] + 6) = v42;
              HIWORD(length[2]) = 2048;
              length[3] = v207;
              _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu",  (uint8_t *)length,  0x20u);
            }
          }

          else if ((_BYTE)v236)
          {
            BOOL v52 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v45 = (os_log_s *)(id)gLogObj;
            BOOL v53 = type;
            v54 = os_log_type_enabled(v45, (os_log_type_t)type);
            if (v52)
            {
              if (v54)
              {
                LODWORD(length[0]) = 136446978;
                *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
                WORD2(length[1]) = 2048;
                *(size_t *)((char *)&length[1] + 6) = v42;
                HIWORD(length[2]) = 2048;
                length[3] = v207;
                LOWORD(length[4]) = 2082;
                *(size_t *)((char *)&length[4] + 2) = (size_t)v52;
                _os_log_impl( &dword_181A5C000,  v45,  v53,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, dumping backtrace:%{public}s",  (uint8_t *)length,  0x2Au);
              }

              free(v52);
              if (!v44)
              {
LABEL_84:
                BOOL v51 = 0;
LABEL_105:
                v60 = 0LL;
                goto LABEL_106;
              }

    goto LABEL_157;
  }

  os_log_type_t v12 = nw_parameters_create();
  char v13 = v12;
  if (v12)
  {
    nw_parameters_set_context(v12, v11);
    obj = 0LL;
    *(void *)unint64_t v79 = 0LL;
    v76 = 0LL;
    uint64_t v77 = 0LL;
    v75 = 0;
    v74 = 0;
    int v73 = 0;
    if ((nw_path_parse_necp_parameters(v13, (void **)v79, &obj, &v77, &v76, &v75, &v74, (char *)&v73 + 1, &v73, a3, a4) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v81 = "nw_path_copy_path_for_tlv";
      char v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v71 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = (os_log_s *)(id)gLogObj;
        uint64_t v24 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl(&dword_181A5C000, v17, v24, "%{public}s nw_path_parse_necp_parameters failed", buf, 0xCu);
        }

        goto LABEL_64;
      }

      if (!v71)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = (os_log_s *)(id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl( &dword_181A5C000,  v17,  v33,  "%{public}s nw_path_parse_necp_parameters failed, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_64;
      }

      os_log_type_t v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)(id)gLogObj;
      v29 = type;
      v30 = os_log_type_enabled(v17, type);
      if (!v28)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v81 = "nw_path_copy_path_for_tlv";
          _os_log_impl( &dword_181A5C000,  v17,  v29,  "%{public}s nw_path_parse_necp_parameters failed, no backtrace",  buf,  0xCu);
        }

        goto LABEL_64;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        v81 = "nw_path_copy_path_for_tlv";
        char v82 = 2082;
        char v83 = v28;
        _os_log_impl( &dword_181A5C000,  v17,  v29,  "%{public}s nw_path_parse_necp_parameters failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_33;
    }

    if (v77)
    {
      browse = nw_path_create_browse(v77, v13);
      if (!browse)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v15 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v81 = "nw_path_copy_path_for_tlv";
        char v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v71 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = (os_log_s *)(id)gLogObj;
          id v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s nw_path_create_browse failed", buf, 0xCu);
          }

          goto LABEL_64;
        }

        if (!v71)
        {
          __nwlog_obj();
          uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v49 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl( &dword_181A5C000,  v17,  v49,  "%{public}s nw_path_create_browse failed, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_64;
        }

        os_log_type_t v28 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v41 = type;
        BOOL v42 = os_log_type_enabled(v17, type);
        if (!v28)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446210;
            v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_181A5C000, v17, v41, "%{public}s nw_path_create_browse failed, no backtrace", buf, 0xCu);
          }

          goto LABEL_64;
        }

        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          v81 = "nw_path_copy_path_for_tlv";
          char v82 = 2082;
          char v83 = v28;
          _os_log_impl( &dword_181A5C000,  v17,  v41,  "%{public}s nw_path_create_browse failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

  if (v38) {
    free(v38);
  }
  return 0LL;
}

    if (v78) {
      free(v78);
    }
    goto LABEL_103;
  }

  int v70 = v13;
  __nwlog_obj();
  v75 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v102 = "nw_association_register_internal";
  v72 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v99 = OS_LOG_TYPE_DEFAULT;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    int v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v76 = type;
    if (os_log_type_enabled(v73, type))
    {
      *(_DWORD *)buf = 136446210;
      v102 = "nw_association_register_internal";
      _os_log_impl(&dword_181A5C000, v73, v76, "%{public}s called with null handle", buf, 0xCu);
    }

LABEL_165:
  v74 = nw_parameters_copy_protocol_options_legacy(v12, a1);
  if (v74)
  {
    v75 = v74;
    v76 = v75;
    uint64_t v77 = 0LL;
    BYTE1(a1[3].handle) = 0;
    v78 = (char *)&a1[3].handle + 1;
    unint64_t v79 = 84LL;
    while (1)
    {
      int v80 = v75[v77 + 48];
      v78[v77] = v80;
      if (!v80) {
        break;
      }
      --v79;
      ++v77;
      if (v79 <= 1)
      {
        v78[v77] = 0;
        break;
      }
    }

    int hop_limit = nw_ip_options_get_hop_limit(v76);
    if (hop_limit) {
      char v82 = hop_limit;
    }
    else {
      char v82 = 64;
    }
    HIBYTE(a1[3].output_handler) = v82;
    if (nw_ip_options_get_calculate_receive_time(v76)) {
      char v83 = 2;
    }
    else {
      char v83 = 0;
    }
    LOBYTE(a1[3].handle) = (uint64_t)a1[3].handle & 0xFD | v83;
    if (nw_ip_options_get_receive_hop_limit(v76)) {
      char v84 = 0x80;
    }
    else {
      char v84 = 0;
    }
    LOBYTE(a1[3].handle) = v84 & 0x80 | (uint64_t)a1[3].handle & 0x7F;
    LOBYTE(a1[3].handle) = (uint64_t)a1[3].handle & 0xF7 | (8
                                                         * (nw_ip_options_get_fragmentation_value(v76) == 2));
    if (nw_ip_options_get_corrupt_checksums(v76)) {
      char v85 = 32;
    }
    else {
      char v85 = 0;
    }
    LOBYTE(a1[3].handle) = (uint64_t)a1[3].handle & 0xDF | v85;
    os_release(v76);
  }

  else
  {
    HIBYTE(a1[3].output_handler) = 64;
  }

  uint64_t v86 = 1LL;
  nw_protocol_ip_register_segmentation_offload_notification(a1, 1);
  return v86;
}

          if (v73) {
            free(v73);
          }
          goto LABEL_173;
        }

        __nwlog_obj();
        v65 = (void *)objc_claimAutoreleasedReturnValue();
        v66 = *(_DWORD *)(a1 + 132);
        *(_DWORD *)buf = 136447746;
        v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
        char v131 = 2112;
        *(void *)v132 = a1;
        *(_WORD *)&v132[8] = 1042;
        *(_DWORD *)&v132[10] = 16;
        *(_WORD *)&v132[14] = 2098;
        *(void *)&v132[16] = a1 + 136;
        *(_WORD *)&v132[24] = 1042;
        *(_DWORD *)&v132[26] = 16;
        LOWORD(v133) = 2098;
        *(void *)((char *)&v133 + 2) = a1 + 115;
        WORD5(v133) = 1024;
        HIDWORD(v133) = v66;
        id v67 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v127 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v67, type, &v127))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            id v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v69 = type[0];
            if (os_log_type_enabled(v68, type[0]))
            {
              int v70 = *(_DWORD *)(a1 + 132);
              *(_DWORD *)buf = 136447746;
              v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
              char v131 = 2112;
              *(void *)v132 = a1;
              *(_WORD *)&v132[8] = 1042;
              *(_DWORD *)&v132[10] = 16;
              *(_WORD *)&v132[14] = 2098;
              *(void *)&v132[16] = a1 + 136;
              *(_WORD *)&v132[24] = 1042;
              *(_DWORD *)&v132[26] = 16;
              LOWORD(v133) = 2098;
              *(void *)((char *)&v133 + 2) = a1 + 115;
              WORD5(v133) = 1024;
              HIDWORD(v133) = v70;
              _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s %@: Failed to create channel for flow id %{public, uuid_t}.16P nexus instance %{public, uuid_t}.16P port %u",  buf,  0x3Cu);
            }
          }

          else if (v127)
          {
            uint64_t v77 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            id v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v78 = type[0];
            unint64_t v79 = os_log_type_enabled(v68, type[0]);
            if (v77)
            {
              if (v79)
              {
                int v80 = *(_DWORD *)(a1 + 132);
                *(_DWORD *)buf = 136448002;
                v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                char v131 = 2112;
                *(void *)v132 = a1;
                *(_WORD *)&v132[8] = 1042;
                *(_DWORD *)&v132[10] = 16;
                *(_WORD *)&v132[14] = 2098;
                *(void *)&v132[16] = a1 + 136;
                *(_WORD *)&v132[24] = 1042;
                *(_DWORD *)&v132[26] = 16;
                LOWORD(v133) = 2098;
                *(void *)((char *)&v133 + 2) = a1 + 115;
                WORD5(v133) = 1024;
                HIDWORD(v133) = v80;
                v134 = 2082;
                *(void *)__int16 v135 = v77;
                _os_log_impl( &dword_181A5C000,  v68,  v78,  "%{public}s %@: Failed to create channel for flow id %{public, uuid_t}.16P nexus instance %{public, uui d_t}.16P port %u, dumping backtrace:%{public}s",  buf,  0x46u);
              }

              free(v77);
              goto LABEL_148;
            }

            if (v79)
            {
              v104 = *(_DWORD *)(a1 + 132);
              *(_DWORD *)buf = 136447746;
              v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
              char v131 = 2112;
              *(void *)v132 = a1;
              *(_WORD *)&v132[8] = 1042;
              *(_DWORD *)&v132[10] = 16;
              *(_WORD *)&v132[14] = 2098;
              *(void *)&v132[16] = a1 + 136;
              *(_WORD *)&v132[24] = 1042;
              *(_DWORD *)&v132[26] = 16;
              LOWORD(v133) = 2098;
              *(void *)((char *)&v133 + 2) = a1 + 115;
              WORD5(v133) = 1024;
              HIDWORD(v133) = v104;
              _os_log_impl( &dword_181A5C000,  v68,  v78,  "%{public}s %@: Failed to create channel for flow id %{public, uuid_t}.16P nexus instance %{public, uuid_ t}.16P port %u, no backtrace",  buf,  0x3Cu);
            }
          }

          else
          {
            __nwlog_obj();
            id v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v102 = type[0];
            if (os_log_type_enabled(v68, type[0]))
            {
              os_log_type_t v103 = *(_DWORD *)(a1 + 132);
              *(_DWORD *)buf = 136447746;
              v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
              char v131 = 2112;
              *(void *)v132 = a1;
              *(_WORD *)&v132[8] = 1042;
              *(_DWORD *)&v132[10] = 16;
              *(_WORD *)&v132[14] = 2098;
              *(void *)&v132[16] = a1 + 136;
              *(_WORD *)&v132[24] = 1042;
              *(_DWORD *)&v132[26] = 16;
              LOWORD(v133) = 2098;
              *(void *)((char *)&v133 + 2) = a1 + 115;
              WORD5(v133) = 1024;
              HIDWORD(v133) = v103;
              _os_log_impl( &dword_181A5C000,  v68,  v102,  "%{public}s %@: Failed to create channel for flow id %{public, uuid_t}.16P nexus instance %{public, uuid_ t}.16P port %u, backtrace limit exceeded",  buf,  0x3Cu);
            }
          }
        }

          if (v120) {
            free(v120);
          }
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = -1;
          goto LABEL_168;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = (const char *)**(unsigned int **)(a1 + 104);
        *(_DWORD *)buf = 136446978;
        v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v149 = 2082;
        *(void *)v150 = "maximum_frame_count";
        *(_WORD *)&v150[8] = 2048;
        v151 = 1LL;
        v152 = 2048;
        v153 = v55;
        v56 = (char *)_os_log_send_and_compose_impl();
        v146 = OS_LOG_TYPE_ERROR;
        v144 = 0;
        if (__nwlog_fault(v56, &v146, &v144))
        {
          if (v146 == OS_LOG_TYPE_FAULT)
          {
            v57 = (os_log_s *)__nwlog_obj();
            v58 = v146;
            if (os_log_type_enabled(v57, v146))
            {
              v59 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(void *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1LL;
              v152 = 2048;
              v153 = v59;
              v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_126:
              _os_log_impl(&dword_181A5C000, v57, v58, v60, buf, 0x2Au);
            }
          }

          else if (v144)
          {
            v64 = (char *)__nw_create_backtrace_string();
            v57 = (os_log_s *)__nwlog_obj();
            v58 = v146;
            v65 = os_log_type_enabled(v57, v146);
            if (v64)
            {
              if (v65)
              {
                v66 = (const char *)**(unsigned int **)(a1 + 104);
                *(_DWORD *)buf = 136447234;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(void *)v150 = "maximum_frame_count";
                *(_WORD *)&v150[8] = 2048;
                v151 = 1LL;
                v152 = 2048;
                v153 = v66;
                v154 = 2082;
                v155 = v64;
                _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v64);
              goto LABEL_127;
            }

            if (v65)
            {
              v97 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(void *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1LL;
              v152 = 2048;
              v153 = v97;
              v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_126;
            }
          }

          else
          {
            v57 = (os_log_s *)__nwlog_obj();
            v58 = v146;
            if (os_log_type_enabled(v57, v146))
            {
              v96 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(void *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1LL;
              v152 = 2048;
              v153 = v96;
              v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_126;
            }
          }
        }

          goto LABEL_166;
        }

        if (!v152[0])
        {
          __nwlog_obj();
          v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v101 = v154[0];
          if (os_log_type_enabled(v76, (os_log_type_t)v154[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            _os_log_impl( &dword_181A5C000,  v76,  v101,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_165;
        }

        v87 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v90 = v154[0];
        v91 = os_log_type_enabled(v76, (os_log_type_t)v154[0]);
        if (!v87)
        {
          if (v91)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            _os_log_impl(&dword_181A5C000, v76, v90, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }

          goto LABEL_165;
        }

        if (v91)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v87;
          _os_log_impl( &dword_181A5C000,  v76,  v90,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_124;
      }
    }

    else
    {
      __nwlog_obj();
      v74 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
      v75 = (char *)_os_log_send_and_compose_impl();

      v154[0] = 16;
      v152[0] = 0;
      if (__nwlog_fault(v75, v154, v152))
      {
        if (v154[0] == 17)
        {
          __nwlog_obj();
          v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v77 = v154[0];
          if (os_log_type_enabled(v76, (os_log_type_t)v154[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            _os_log_impl(&dword_181A5C000, v76, v77, "%{public}s called with null remote_endpoint", buf, 0xCu);
          }

          goto LABEL_165;
        }

        if (!v152[0])
        {
          __nwlog_obj();
          v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v100 = v154[0];
          if (os_log_type_enabled(v76, (os_log_type_t)v154[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            _os_log_impl( &dword_181A5C000,  v76,  v100,  "%{public}s called with null remote_endpoint, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_165;
        }

        v87 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v88 = v154[0];
        v89 = os_log_type_enabled(v76, (os_log_type_t)v154[0]);
        if (!v87)
        {
          if (v89)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            _os_log_impl( &dword_181A5C000,  v76,  v88,  "%{public}s called with null remote_endpoint, no backtrace",  buf,  0xCu);
          }

          goto LABEL_165;
        }

        if (v89)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v87;
          _os_log_impl( &dword_181A5C000,  v76,  v88,  "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

      if (v55) {
        free(v55);
      }
      if ((v91 & 1) == 0) {
        goto LABEL_58;
      }
LABEL_57:
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      goto LABEL_58;
    }

    __nwlog_obj();
    v65 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v105 = 136446210;
    *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
    v40 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v66 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
        _os_log_impl(&dword_181A5C000, v41, v66, "%{public}s called with null protocol", v105, 0xCu);
      }

      goto LABEL_189;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v89 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
        _os_log_impl( &dword_181A5C000,  v41,  v89,  "%{public}s called with null protocol, backtrace limit exceeded",  v105,  0xCu);
      }

      goto LABEL_189;
    }

    BOOL v48 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unint64_t v79 = buf[0];
    int v80 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
    if (!v48)
    {
      if (v80)
      {
        *(_DWORD *)v105 = 136446210;
        *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
        _os_log_impl(&dword_181A5C000, v41, v79, "%{public}s called with null protocol, no backtrace", v105, 0xCu);
      }

      goto LABEL_189;
    }

    if (v80)
    {
      *(_DWORD *)v105 = 136446466;
      *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
      *(_WORD *)&v105[12] = 2082;
      *(void *)&v105[14] = v48;
      _os_log_impl( &dword_181A5C000,  v41,  v79,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  v105,  0x16u);
    }

        free(v71);
        if (!v18) {
          goto LABEL_111;
        }
        goto LABEL_110;
      }
    }

    if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
    {
      v29 = *(void *)(v21 + 88);
      if (v29) {
        *(void *)(v21 + 8_Block_object_dispose(va, 8) = v29 + 1;
      }
      __int16 v22 = -1;
    }

    else
    {
      __int16 v22 = 0;
    }

    *(void *)os_log_type_t type = v21;
    v107 = v22;
    if (*(v6 - 7) == &nw_protocol_ref_counted_handle)
    {
      v31 = (uint64_t)*(v6 - 1);
      if (v31) {
        *(v6 - 1) = (void *)(v31 + 1);
      }
      v30 = -1;
    }

    else
    {
      v30 = 0;
    }

    v104 = v6 - 12;
    v105 = v30;
    __int16 v32 = *(void *)(v21 + 24);
    if (v32)
    {
      v33 = *(void (**)(uint64_t, void **))(v32 + 192);
      if (v33)
      {
        v33(v21, v6 - 12);
        v30 = v105;
LABEL_59:
        if ((v30 & 1) != 0) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)&v104);
        }
        if ((v107 & 1) != 0) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        }
        goto LABEL_111;
      }
    }

    __nwlog_obj();
    v78 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v79 = *(const char **)(v21 + 16);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v109 = "__nw_protocol_output_finished";
    if (!v79) {
      unint64_t v79 = "invalid";
    }
    v110 = 2082;
    v111 = (char *)v79;
    v112 = 2048;
    v113 = v21;
    int v80 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v103 = OS_LOG_TYPE_ERROR;
    v102 = 0;
    if (__nwlog_fault(v80, &v103, &v102))
    {
      if (v103 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v82 = v103;
        if (os_log_type_enabled(v81, v103))
        {
          char v83 = *(const char **)(v21 + 16);
          if (!v83) {
            char v83 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v109 = "__nw_protocol_output_finished";
          v110 = 2082;
          v111 = (char *)v83;
          v112 = 2048;
          v113 = v21;
          _os_log_impl( &dword_181A5C000,  v81,  v82,  "%{public}s protocol %{public}s (%p) has invalid output_finished callback",  buf,  0x20u);
        }
      }

      else if (v102)
      {
        v87 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v88 = v103;
        v89 = os_log_type_enabled(v81, v103);
        if (v87)
        {
          if (v89)
          {
            v90 = *(const char **)(v21 + 16);
            if (!v90) {
              v90 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v109 = "__nw_protocol_output_finished";
            v110 = 2082;
            v111 = (char *)v90;
            v112 = 2048;
            v113 = v21;
            os_log_type_t v114 = 2082;
            v115 = v87;
            _os_log_impl( &dword_181A5C000,  v81,  v88,  "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v87);
          goto LABEL_238;
        }

        if (v89)
        {
          v100 = *(const char **)(v21 + 16);
          if (!v100) {
            v100 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v109 = "__nw_protocol_output_finished";
          v110 = 2082;
          v111 = (char *)v100;
          v112 = 2048;
          v113 = v21;
          _os_log_impl( &dword_181A5C000,  v81,  v88,  "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v98 = v103;
        if (os_log_type_enabled(v81, v103))
        {
          v99 = *(const char **)(v21 + 16);
          if (!v99) {
            v99 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v109 = "__nw_protocol_output_finished";
          v110 = 2082;
          v111 = (char *)v99;
          v112 = 2048;
          v113 = v21;
          _os_log_impl( &dword_181A5C000,  v81,  v98,  "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

        free(v46);
        goto LABEL_171;
      }

      if (!v59) {
        goto LABEL_171;
      }
      *(_DWORD *)buf = 136446210;
      v63 = "nw_protocol_http1_replace_input_handler";
      v36 = "%{public}s called with null http1_stream, no backtrace";
LABEL_170:
      _os_log_impl(&dword_181A5C000, v34, v35, v36, buf, 0xCu);
LABEL_171:
      if (v33)
      {
        os_log_type_t v28 = (char *)v33;
        goto LABEL_173;
      }

      return 0LL;
    }

    os_log_type_t v12 = *((void *)handle + 2);
    if (v12)
    {
      char v13 = (uint64_t *)(v12 + 488);
      goto LABEL_18;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v63 = "nw_http1_get_stream_for_protocol";
    BOOL v50 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v60 = 0;
    if (__nwlog_fault(v50, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v51 = (os_log_s *)__nwlog_obj();
        BOOL v52 = type;
        if (!os_log_type_enabled(v51, type)) {
          goto LABEL_154;
        }
        *(_DWORD *)buf = 136446210;
        v63 = "nw_http1_get_stream_for_protocol";
        BOOL v53 = "%{public}s called with null handle->http1_connection";
        goto LABEL_153;
      }

      if (!v60)
      {
        BOOL v51 = (os_log_s *)__nwlog_obj();
        BOOL v52 = type;
        if (!os_log_type_enabled(v51, type)) {
          goto LABEL_154;
        }
        *(_DWORD *)buf = 136446210;
        v63 = "nw_http1_get_stream_for_protocol";
        BOOL v53 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_153;
      }

      v56 = (char *)__nw_create_backtrace_string();
      BOOL v51 = (os_log_s *)__nwlog_obj();
      BOOL v52 = type;
      v57 = os_log_type_enabled(v51, type);
      if (v56)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446466;
          v63 = "nw_http1_get_stream_for_protocol";
          v64 = 2082;
          v65 = (nw_protocol *)v56;
          _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v56);
        goto LABEL_154;
      }

      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        v63 = "nw_http1_get_stream_for_protocol";
        BOOL v53 = "%{public}s called with null handle->http1_connection, no backtrace";
LABEL_153:
        _os_log_impl(&dword_181A5C000, v51, v52, v53, buf, 0xCu);
      }
    }

        __nwlog_obj();
        *(_DWORD *)os_log_type_t type = 136446210;
        os_log_type_t v114 = "nw_http1_match_idle_connection_with_pending_stream_async";
        v72 = (char *)_os_log_send_and_compose_impl();
        v107 = OS_LOG_TYPE_ERROR;
        v106 = 0;
        if (v107 == OS_LOG_TYPE_FAULT)
        {
          int v73 = (os_log_s *)__nwlog_obj();
          v74 = v107;
          if (!os_log_type_enabled(v73, v107)) {
            goto LABEL_212;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v114 = "nw_http1_match_idle_connection_with_pending_stream_async";
          v75 = "%{public}s called with null http1_connection->context";
          goto LABEL_210;
        }

        if (!v106)
        {
          int v73 = (os_log_s *)__nwlog_obj();
          v74 = v107;
          if (!os_log_type_enabled(v73, v107)) {
            goto LABEL_212;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v114 = "nw_http1_match_idle_connection_with_pending_stream_async";
          v75 = "%{public}s called with null http1_connection->context, backtrace limit exceeded";
          goto LABEL_210;
        }

        v95 = (char *)__nw_create_backtrace_string();
        int v73 = (os_log_s *)__nwlog_obj();
        v74 = v107;
        v98 = os_log_type_enabled(v73, v107);
        if (!v95)
        {
          if (!v98) {
            goto LABEL_212;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v114 = "nw_http1_match_idle_connection_with_pending_stream_async";
          v75 = "%{public}s called with null http1_connection->context, no backtrace";
          goto LABEL_210;
        }

        if (v98)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          os_log_type_t v114 = "nw_http1_match_idle_connection_with_pending_stream_async";
          v115 = 2082;
          v116 = v95;
          v97 = "%{public}s called with null http1_connection->context, dumping backtrace:%{public}s";
          goto LABEL_181;
        }

  if (v57) {
    free(v57);
  }
LABEL_167:
  if (!nw_tcp_options_get_enable_background_traffic_management(a2)
    || !setsockopt(*(_DWORD *)(a1 + 172), 0xFFFF, 4357, v105, 4u))
  {
    goto LABEL_192;
  }

  v63 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  v64 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v107 = "nw_socket_set_bidirectional_tcp_sockopts";
    v108 = 2080;
    *(void *)os_log_type_t v109 = a1 + 308;
    *(_WORD *)&v109[8] = 1024;
    *(_DWORD *)&v109[10] = v63;
    _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v65 = (os_log_s *)gLogObj;
  if (v63 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = 22;
      _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d",  buf,  0x12u);
    }

    goto LABEL_192;
  }

  *(_DWORD *)buf = 136446466;
  v107 = "nw_socket_set_bidirectional_tcp_sockopts";
  v108 = 1024;
  *(_DWORD *)os_log_type_t v109 = v63;
  v66 = (char *)_os_log_send_and_compose_impl();
  v102[0] = OS_LOG_TYPE_ERROR;
  v101[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v66, v102, v101))
  {
    if (v102[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v67 = (os_log_s *)gLogObj;
      id v68 = v102[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v102[0])) {
        goto LABEL_190;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = v63;
      v69 = "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d";
      goto LABEL_189;
    }

    if (v101[0] == OS_LOG_TYPE_DEFAULT)
    {
      id v67 = (os_log_s *)__nwlog_obj();
      id v68 = v102[0];
      if (!os_log_type_enabled(v67, v102[0])) {
        goto LABEL_190;
      }
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = v63;
      v69 = "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_189;
    }

    int v70 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v67 = (os_log_s *)gLogObj;
    id v68 = v102[0];
    v71 = os_log_type_enabled((os_log_t)gLogObj, v102[0]);
    if (v70)
    {
      if (v71)
      {
        *(_DWORD *)buf = 136446722;
        v107 = "nw_socket_set_bidirectional_tcp_sockopts";
        v108 = 1024;
        *(_DWORD *)os_log_type_t v109 = v63;
        *(_WORD *)&v109[4] = 2082;
        *(void *)&v109[6] = v70;
        _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v70);
      goto LABEL_190;
    }

    if (v71)
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_socket_set_bidirectional_tcp_sockopts";
      v108 = 1024;
      *(_DWORD *)os_log_type_t v109 = v63;
      v69 = "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d, no backtrace";
LABEL_189:
      _os_log_impl(&dword_181A5C000, v67, v68, v69, buf, 0x12u);
    }
  }

        if (*(_BYTE *)(a2 + *v8)) {
          v123 = 0LL;
        }
LABEL_167:
        *(_BYTE *)(a1 + 62) = v123 != 0;
        goto LABEL_4;
      case 0xAu:
        *(_BYTE *)(a1 + 64) |= 0x10u;
        v54 = *v3;
        v55 = *(void *)(a2 + v54);
        if (v55 == -1LL || v55 >= *(void *)(a2 + *v6))
        {
          v58 = 0LL;
LABEL_149:
          *(_BYTE *)(a2 + *v_Block_object_dispose(va, 8) = 1;
          goto LABEL_150;
        }

        v56 = v55 + 1;
        v57 = *(_BYTE *)(*(void *)(a2 + *v10) + v55);
        *(void *)(a2 + v54) = v56;
        v58 = v57 & 0x7F;
        if ((v57 & 0x80) == 0) {
          goto LABEL_150;
        }
        v59 = *v3;
        v60 = *(void *)(a2 + v59);
        if (v60 == -1LL || v60 >= *(void *)(a2 + *v6)) {
          goto LABEL_149;
        }
        v61 = v60 + 1;
        v62 = *(char *)(*(void *)(a2 + *v10) + v60);
        *(void *)(a2 + v59) = v61;
        v58 |= (unint64_t)(v62 & 0x7F) << 7;
        if ((v62 & 0x80000000) == 0) {
          goto LABEL_150;
        }
        v63 = *v3;
        v64 = *(void *)(a2 + v63);
        if (v64 == -1LL || v64 >= *(void *)(a2 + *v6)) {
          goto LABEL_149;
        }
        v65 = v64 + 1;
        v66 = *(char *)(*(void *)(a2 + *v10) + v64);
        *(void *)(a2 + v63) = v65;
        v58 |= (unint64_t)(v66 & 0x7F) << 14;
        if ((v66 & 0x80000000) == 0) {
          goto LABEL_150;
        }
        id v67 = *v3;
        id v68 = *(void *)(a2 + v67);
        if (v68 == -1LL || v68 >= *(void *)(a2 + *v6)) {
          goto LABEL_149;
        }
        v69 = v68 + 1;
        int v70 = *(char *)(*(void *)(a2 + *v10) + v68);
        *(void *)(a2 + v67) = v69;
        v58 |= (unint64_t)(v70 & 0x7F) << 21;
        if ((v70 & 0x80000000) == 0) {
          goto LABEL_150;
        }
        v71 = *v3;
        v72 = *(void *)(a2 + v71);
        if (v72 == -1LL || v72 >= *(void *)(a2 + *v6)) {
          goto LABEL_149;
        }
        int v73 = v72 + 1;
        v74 = *(char *)(*(void *)(a2 + *v10) + v72);
        *(void *)(a2 + v71) = v73;
        v58 |= (unint64_t)(v74 & 0x7F) << 28;
        if ((v74 & 0x80000000) == 0) {
          goto LABEL_150;
        }
        v162 = *v3;
        v163 = *(void *)(a2 + v162);
        if (v163 == -1LL || v163 >= *(void *)(a2 + *v6)) {
          goto LABEL_149;
        }
        v164 = v163 + 1;
        v165 = *(char *)(*(void *)(a2 + *v10) + v163);
        *(void *)(a2 + v162) = v164;
        v58 |= (unint64_t)(v165 & 0x7F) << 35;
        if (v165 < 0)
        {
          v198 = *v3;
          v199 = *(void *)(a2 + v198);
          if (v199 == -1LL || v199 >= *(void *)(a2 + *v6)) {
            goto LABEL_149;
          }
          v200 = v199 + 1;
          v201 = *(char *)(*(void *)(a2 + *v10) + v199);
          *(void *)(a2 + v19_Block_object_dispose(va, 8) = v200;
          v58 |= (unint64_t)(v201 & 0x7F) << 42;
          if (v201 < 0)
          {
            v202 = *v3;
            v203 = *(void *)(a2 + v202);
            if (v203 == -1LL || v203 >= *(void *)(a2 + *v6)) {
              goto LABEL_149;
            }
            v204 = v203 + 1;
            v205 = *(char *)(*(void *)(a2 + *v10) + v203);
            *(void *)(a2 + v202) = v204;
            v58 |= (unint64_t)(v205 & 0x7F) << 49;
            if (v205 < 0)
            {
              v206 = *v3;
              v207 = *(void *)(a2 + v206);
              if (v207 == -1LL || v207 >= *(void *)(a2 + *v6)) {
                goto LABEL_149;
              }
              v208 = v207 + 1;
              v209 = *(char *)(*(void *)(a2 + *v10) + v207);
              *(void *)(a2 + v206) = v208;
              v58 |= (unint64_t)(v209 & 0x7F) << 56;
              if (v209 < 0)
              {
                v210 = *v3;
                v211 = *(void *)(a2 + v210);
                if (v211 == -1LL || v211 >= *(void *)(a2 + *v6)) {
                  goto LABEL_149;
                }
                v212 = v211 + 1;
                v213 = *(unsigned __int8 *)(*(void *)(a2 + *v10) + v211);
                *(void *)(a2 + v210) = v212;
                if ((v213 & 0x80) != 0)
                {
                  v58 = 0LL;
                  goto LABEL_152;
                }

                v58 |= v213 << 63;
              }
            }
          }
        }

                  v43 = 0LL;
                  goto LABEL_62;
                }

                v37 = *(id *)(v36 + 88);
                if (v37)
                {
LABEL_46:

                  goto LABEL_54;
                }

                BOOL v42 = *(void *)(a1 + 40);
                if (v42)
                {
                  if (*(_BYTE *)(v42 + 15)) {
                    goto LABEL_54;
                  }
                  v55 = *(void **)(v42 + 48);
                }

                else
                {
                  v55 = 0LL;
                }

                objc_msgSend(v55, "loaderDataTask", v120, v121);
                v56 = (void *)objc_claimAutoreleasedReturnValue();
                v57 = *(void *)(a1 + 40);
                if (v57)
                {
                  v58 = *(void **)(v57 + 96);
                  v59 = *(void **)(v57 + 24);
                }

                else
                {
                  v58 = 0LL;
                  v59 = 0LL;
                }

                v60 = v58;
                v122 = v59;
                v123 = v24;
                v37 = v56;
                if (!v60)
                {
LABEL_100:

                  goto LABEL_46;
                }

                *((void *)v60 + 2) = 0LL;
                objc_storeStrong((id *)v60 + 7, v59);
                objc_storeStrong((id *)v60 + 5, v24);
                objc_storeStrong((id *)v60 + 6, v56);
                objc_storeStrong((id *)v60 + 3, MEMORY[0x1895F8AA8]);
                v61 = *((void *)v60 + 2);
                if (v61)
                {
                  if (v61 != 1)
                  {
                    v61 = 0LL;
                    goto LABEL_84;
                  }

                  v62 = *((id *)v60 + 1);
                  v63 = [v62 memoryCapacity];
                  [*((id *)v60 + 1) _maxCacheableEntrySizeRatio];
                  v65 = v64;

                  v61 = (unint64_t)(v65 * (double)v63);
                }

                v66 = *((id *)v60 + 1);
                id v67 = [v66 diskCapacity];
                [*((id *)v60 + 1) _maxCacheableEntrySizeRatio];
                v69 = v68;

                int v70 = v69 * (double)v67;
LABEL_84:
                *((void *)v60 + 4) = v61;
                v71 = [*((id *)v60 + 5) statusCode];
                if (v71 <= 300)
                {
                  if (v71 != 200 && v71 != 203) {
                    goto LABEL_99;
                  }
                }

                else if (((unint64_t)(v71 - 301) > 7 || ((1LL << (v71 - 45)) & 0x89) == 0) {
                       && v71 != 410
                }
                       && v71 != 404)
                {
                  goto LABEL_99;
                }

                [*((id *)v60 + 5) valueForHTTPHeaderField:@"Cache-Control"];
                v72 = (void *)objc_claimAutoreleasedReturnValue();
                int v73 = v72;
                if (!v72 || ([v72 rangeOfString:@"no-store" options:1], !v74))
                {
                  [*((id *)v60 + 7) valueForHTTPHeaderField:@"Cache-Control"];
                  v75 = (void *)objc_claimAutoreleasedReturnValue();
                  v76 = v75;
                  if (!v75
                    || ([v75 rangeOfString:@"no-store" options:1], !v77)
                    && ([v76 rangeOfString:@"no-cache" options:1], !v78))
                  {

                    goto LABEL_99;
                  }
                }

LABEL_99:
                unint64_t v79 = (void *)*((void *)v60 + 3);
                *((void *)v60 + 3) = 0LL;

                int v80 = (void *)*((void *)v60 + 5);
                *((void *)v60 + 4) = 0LL;
                *((void *)v60 + 5) = 0LL;

                goto LABEL_100;
              }

              [NSString stringWithUTF8String:v32];
              os_log_type_t v28 = (void *)objc_claimAutoreleasedReturnValue();
              [v24 _setMIMEType:v28];
LABEL_35:

              goto LABEL_36;
            }

            __nwlog_obj();
            v90 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
            LODWORD(v121) = 12;
            v120 = buf;
            uint64_t v86 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v128 = 0;
            if (__nwlog_fault(v86, &type, &v128))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v91 = type;
                if (os_log_type_enabled(v87, type))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
                  _os_log_impl(&dword_181A5C000, v87, v91, "%{public}s metadata must be http_client", buf, 0xCu);
                }
              }

              else if (v128)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v103 = type;
                v104 = os_log_type_enabled(v87, type);
                if (backtrace_string)
                {
                  if (v104)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v87,  v103,  "%{public}s metadata must be http_client, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(backtrace_string);
                  if (!v86) {
                    goto LABEL_162;
                  }
                  goto LABEL_161;
                }

                if (v104)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
                  _os_log_impl( &dword_181A5C000,  v87,  v103,  "%{public}s metadata must be http_client, no backtrace",  buf,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v110 = type;
                if (os_log_type_enabled(v87, type))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_client_metadata_get_sniffed_media_type";
                  _os_log_impl( &dword_181A5C000,  v87,  v110,  "%{public}s metadata must be http_client, backtrace limit exceeded",  buf,  0xCu);
                }
              }

              goto LABEL_159;
            }

        if (v70) {
          free(v70);
        }
LABEL_79:
        if (!a2)
        {
          __nwlog_obj();
          v64 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)&buf[0].sa_len = 136446210;
          *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
          v65 = (const char *)_os_log_send_and_compose_impl();

          int v7 = v97;
          v102[0] = OS_LOG_TYPE_ERROR;
          v107[0] = 0;
          if (__nwlog_fault(v65, v102, v107))
          {
            if (v102[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              id v67 = v102[0];
              if (os_log_type_enabled(v66, v102[0]))
              {
                *(_DWORD *)&buf[0].sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s called with null input_protocol",  &buf[0].sa_len,  0xCu);
              }
            }

            else if (v107[0])
            {
              v74 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v76 = v102[0];
              uint64_t v77 = os_log_type_enabled(v75, v102[0]);
              if (v74)
              {
                if (v77)
                {
                  *(_DWORD *)&buf[0].sa_len = 136446466;
                  *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                  *(_WORD *)&buf[0].sa_data[10] = 2082;
                  *(void *)&buf[0].sa_data[12] = v74;
                  _os_log_impl( &dword_181A5C000,  v75,  v76,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  &buf[0].sa_len,  0x16u);
                }

                int v7 = v97;
                free(v74);
              }

              else
              {
                if (v77)
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl( &dword_181A5C000,  v75,  v76,  "%{public}s called with null input_protocol, no backtrace",  &buf[0].sa_len,  0xCu);
                }

                int v7 = v97;
              }
            }

            else
            {
              __nwlog_obj();
              char v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              char v85 = v102[0];
              if (os_log_type_enabled(v84, v102[0]))
              {
                *(_DWORD *)&buf[0].sa_len = 136446210;
                *(void *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                _os_log_impl( &dword_181A5C000,  v84,  v85,  "%{public}s called with null input_protocol, backtrace limit exceeded",  &buf[0].sa_len,  0xCu);
              }

              int v7 = v97;
            }
          }

          if (!v65) {
            goto LABEL_114;
          }
          v62 = (char *)v65;
          goto LABEL_113;
        }

        if ((nw_protocol *)internal != a2)
        {
          BOOL v50 = *(void **)(internal + 24);
          if (v50 && *v50)
          {
            if (!nw_protocol_add_input_handler(internal, (uint64_t)a2))
            {
              __int16 v22 = 0LL;
              goto LABEL_115;
            }

            BOOL v51 = *((char *)v4 + 33);
            if ((v51 & 0x80000000) == 0)
            {
              __int16 v22 = 1LL;
LABEL_115:

              goto LABEL_116;
            }

            if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
            {
              if (((*(unsigned __int16 *)(internal + 397) | (*(unsigned __int8 *)(internal + 399) << 16)) & 0x20000) != 0)
              {
LABEL_104:
                __int16 v22 = 1LL;
                goto LABEL_115;
              }

    if (v97) {
      free(v97);
    }
    uint64_t v17 = v245;
    if ((*v5 & 0x1000) == 0)
    {
      BOOL v3 = v27;
      uint64_t v8 = v233;
      goto LABEL_187;
    }

    uint64_t v8 = v233;
    if (!*(void *)(v245 + 136) || !os_channel_packet_free())
    {
      BOOL v3 = v27;
      goto LABEL_187;
    }

uint64_t nw_path_get_maximum_packet_size(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t mtu = nw_path_get_mtu(v1);
    uint64_t v4 = mtu;
    if ((_DWORD)mtu) {
      unsigned int v5 = mtu;
    }
    else {
      unsigned int v5 = 1500;
    }
    if (v5 >= 0x28)
    {
      v6 = v2[3];
      if (v6
        && (id v7 = v6, v8 = [v7 type], v7, v8 == 1)
        && nw_endpoint_get_address_family(v2[3]) == 2)
      {
        uint64_t v4 = v5 - 20;
      }

      else
      {
        uint64_t v4 = v5 - 40;
      }
    }

    goto LABEL_11;
  }

  __nwlog_obj();
  BOOL v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v21 = "nw_path_get_maximum_packet_size";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v21 = "nw_path_get_maximum_packet_size";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          int v21 = "nw_path_get_maximum_packet_size";
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        int v21 = "nw_path_get_maximum_packet_size";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        int v21 = "nw_path_get_maximum_packet_size";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B3B9FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_mtu(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v19 = "nw_path_get_mtu";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_path_get_mtu";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v19 = "nw_path_get_mtu";
            __int16 v20 = 2082;
            int v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }

        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_path_get_mtu";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_path_get_mtu";
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B3BD4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_csum_flags(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v18 = "nw_path_get_csum_flags";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_path_get_csum_flags";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            char v18 = "nw_path_get_csum_flags";
            __int16 v19 = 2082;
            __int16 v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_path_get_csum_flags";
          _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_path_get_csum_flags";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B3C010(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_ip_options_get_hop_limit(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_hop_limit_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_hop_limit";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_hop_limit";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B3C31C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 12);
  return 1LL;
}

BOOL nw_ip_options_get_calculate_receive_time(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_calculate_receive_time_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_calculate_receive_time";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_calculate_receive_time";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_calculate_receive_time";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_calculate_receive_time";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_calculate_receive_time";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B3C660( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_calculate_receive_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 13) & 2) != 0;
  return 1LL;
}

uint64_t nw_ip_options_get_fragmentation_value(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_fragmentation_value_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B3C9A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_fragmentation_value_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 8);
  return 1LL;
}

BOOL nw_ip_options_get_corrupt_checksums(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_corrupt_checksums_block_invoke;
    v12[3] = &unk_189BC60A8;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_corrupt_checksums";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_corrupt_checksums";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_corrupt_checksums";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_corrupt_checksums";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_corrupt_checksums";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B3CCE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_corrupt_checksums_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 13) & 8) != 0;
  return 1LL;
}

uint64_t __nwlog_tcp_log()
{
  if (__nwlog_tcp_log::onceToken != -1) {
    dispatch_once(&__nwlog_tcp_log::onceToken, &__block_literal_global_42_44349);
  }
  return gtcpLogObj;
}

id nw_path_flow_registration_copy_assigned_protocol( NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2)
{
  BOOL v2 = (id *)nw_path_copy_flow_for_registration(a1, a2);
  BOOL v3 = v2;
  if (v2) {
    id v4 = v2[9];
  }
  else {
    id v4 = 0LL;
  }

  return v4;
}

BOOL nw_endpoint_flow_attach_channel_protocol(void *a1, uint64_t a2, int a3)
{
  uint64_t v133 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  v6 = nw_endpoint_handler_copy_flow(v5);
  if ((*((_BYTE *)v6 + 33) & 0x40) != 0)
  {
    unsigned int v113 = 0;
    char v16 = (NWConcrete_nw_path *)nw_endpoint_flow_copy_path(v5);
    v110 = v16;
    if (!nw_path_flow_registration_get_nexus_instance( v16,  *((NWConcrete_nw_path_flow_registration **)v6 + 104),  &uu,  &v113))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
      {
        BOOL v15 = 0LL;
        goto LABEL_102;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v21 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_endpoint_handler_get_id_string(v5);
        os_log_type_t v23 = nw_endpoint_handler_dry_run_string(v5);
        nw_endpoint_t v24 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v24);
        BOOL v26 = nw_endpoint_handler_state_string(v5);
        os_log_type_t v27 = nw_endpoint_handler_mode_string(v5);
        id v28 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136447746;
        v117 = "nw_endpoint_flow_attach_channel_protocol";
        __int16 v118 = 2082;
        uint64_t v119 = (uint64_t)id_string;
        __int16 v120 = 2082;
        BOOL v121 = (void *)v23;
        __int16 v122 = 2082;
        v123 = logging_description;
        __int16 v124 = 2082;
        v125 = v26;
        __int16 v126 = 2082;
        v127 = v27;
        __int16 v128 = 2114;
        id v129 = v28;
        _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nexus is not ready",  buf,  0x48u);
      }

      BOOL v15 = 0LL;
LABEL_101:
      char v16 = v110;
LABEL_102:

      goto LABEL_103;
    }

    id v17 = nw_path_copy_flow_for_registration(v16, *((NWConcrete_nw_path_flow_registration **)v6 + 104));
    char v18 = v17;
    if (v17)
    {
      __int16 v19 = v17;
      uint64_t v20 = v19[1];
      if (!v20 || !*((_DWORD *)v19 + 40)) {
        uint64_t v20 = 0LL;
      }
    }

    else
    {
      uint64_t v20 = 0LL;
    }

    uint64_t v111 = 0LL;
    uint64_t v112 = 0LL;
    HIDWORD(v112) = nw_path_flow_registration_can_support_user_packet_pool(v110, *((void **)v6 + 104));
    else {
      char v29 = 0;
    }
    BYTE4(v112) = BYTE4(v112) & 0xFD | v29;
    uint64_t v111 = v20;
    LODWORD(v112) = 16;
    id v109 = nw_endpoint_handler_copy_parameters(v5);
    v30 = nw_parameters_copy_context(v109);
    BOOL v31 = nw_channel_create_with_attributes(v30, (unsigned __int8 *)&uu, v113, (uint64_t)&v111);
    __int16 v32 = (void *)*((void *)v6 + 113);
    *((void *)v6 + 113) = v31;

    if (!*((void *)v6 + 113))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v44 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          BOOL v45 = nw_endpoint_handler_get_id_string(v5);
          v46 = nw_endpoint_handler_dry_run_string(v5);
          nw_endpoint_t v47 = nw_endpoint_handler_copy_endpoint(v5);
          BOOL v48 = nw_endpoint_get_logging_description(v47);
          v49 = nw_endpoint_handler_state_string(v5);
          BOOL v50 = nw_endpoint_handler_mode_string(v5);
          id v51 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136447746;
          v117 = "nw_endpoint_flow_attach_channel_protocol";
          __int16 v118 = 2082;
          uint64_t v119 = (uint64_t)v45;
          __int16 v120 = 2082;
          BOOL v121 = (void *)v46;
          __int16 v122 = 2082;
          v123 = v48;
          __int16 v124 = 2082;
          v125 = v49;
          __int16 v126 = 2082;
          v127 = v50;
          __int16 v128 = 2114;
          id v129 = v51;
          _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to open channel",  buf,  0x48u);
        }
      }

      goto LABEL_99;
    }

    int minimize_logging = nw_endpoint_handler_get_minimize_logging(v5);
    char logging_disabled = nw_endpoint_handler_get_logging_disabled(v5);
    if (minimize_logging)
    {
      if ((logging_disabled & 1) != 0)
      {
LABEL_33:
        nw_channel_set_close_automatically(*((void *)v6 + 113), 1);
        nw_channel_set_defer_input_available(*((void *)v6 + 113), 1);
        nw_channel_set_protocol_level(*((void *)v6 + 113), a3);
        if (a3 == 2)
        {
          if (nw_protocol_ip_identifier::onceToken[0] != -1) {
            dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
          }
          if (nw_parameters_has_protocol_in_stack(v109, &nw_protocol_ip_identifier::identifier)) {
            goto LABEL_49;
          }
          BOOL v52 = (void *)*((void *)v6 + 95);
          if (v52)
          {
            if (nw_protocol_ip_identifier::onceToken[0] != -1) {
              dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
            }
            if (nw_protocols_are_equal(v52, &nw_protocol_ip_identifier::identifier))
            {
LABEL_49:
              nw_endpoint_t v53 = nw_endpoint_handler_copy_endpoint(v5);
              int address_family = nw_endpoint_get_address_family(v53);

              v55 = (void *)*((void *)v6 + 104);
              if (nw_protocol_ip_identifier::onceToken[0] != -1) {
                dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
              }
              if (address_family == 2) {
                int v56 = 1;
              }
              else {
                int v56 = 2;
              }
              uint64_t stats_region = nw_channel_get_stats_region(*((void *)v6 + 113), v56);
              nw_path_flow_registration_set_stats_region( v55,  2,  (__int128 *)&nw_protocol_ip_identifier::identifier,  stats_region);
            }
          }
        }

        else
        {
          if (a3 == 1)
          {
            nw_channel_set_no_close_delay(*((void *)v6 + 113));
            goto LABEL_65;
          }

          if ((a3 & 0xFFFFFFFE) != 2) {
            goto LABEL_65;
          }
        }

        v58 = (void *)nw_protocol_tcp_identifier();
        if (nw_parameters_has_protocol_in_stack(v109, v58))
        {
          v59 = (void *)*((void *)v6 + 104);
          v60 = (__int128 *)nw_protocol_tcp_identifier();
          int v61 = 3;
LABEL_64:
          uint64_t v62 = nw_channel_get_stats_region(*((void *)v6 + 113), v61);
          nw_path_flow_registration_set_stats_region(v59, 3, v60, v62);
          goto LABEL_65;
        }

        if (nw_protocol_udp_identifier::onceToken != -1) {
          dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
        }
        if (nw_parameters_has_protocol_in_stack(v109, &nw_protocol_udp_identifier::identifier))
        {
          v59 = (void *)*((void *)v6 + 104);
          if (nw_protocol_udp_identifier::onceToken != -1) {
            dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
          }
          v60 = (__int128 *)&nw_protocol_udp_identifier::identifier;
          int v61 = 4;
          goto LABEL_64;
        }

        if (nw_parameters_get_upper_transport_protocol(v109) == 253)
        {
          upper_transport_protocol_identifier = (__int128 *)nw_parameters_get_upper_transport_protocol_identifier(v109);
          v78 = (void *)*((void *)v6 + 104);
          uint64_t v79 = nw_channel_get_stats_region(*((void *)v6 + 113), 5);
          nw_path_flow_registration_set_stats_region(v78, 3, upper_transport_protocol_identifier, v79);
          int v80 = (void *)*((void *)v6 + 104);
          if (nw_protocol_udp_identifier::onceToken != -1) {
            dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
          }
          uint64_t v81 = nw_channel_get_stats_region(*((void *)v6 + 113), 4);
          nw_path_flow_registration_set_stats_region(v80, 3, (__int128 *)&nw_protocol_udp_identifier::identifier, v81);
        }

LABEL_130:
            free(v97);
            goto LABEL_143;
          }

          if (v102)
          {
            *(_DWORD *)buf = 136446210;
            v117 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl( &dword_181A5C000,  v98,  v101,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v91 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v117 = "nw_protocol_utilities_add_input_handler";
          v92 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v114 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v94 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              v117 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_181A5C000, v93, v94, "%{public}s called with null protocol", buf, 0xCu);
            }

            goto LABEL_136;
          }

          if (!v114)
          {
            __nwlog_obj();
            v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v103 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              v117 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl( &dword_181A5C000,  v93,  v103,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_136;
          }

          v97 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v98 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v99 = type;
          BOOL v100 = os_log_type_enabled(v98, type);
          if (v97)
          {
            if (v100)
            {
              *(_DWORD *)buf = 136446466;
              v117 = "nw_protocol_utilities_add_input_handler";
              __int16 v118 = 2082;
              uint64_t v119 = (uint64_t)v97;
              _os_log_impl( &dword_181A5C000,  v98,  v99,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            goto LABEL_130;
          }

          if (v100)
          {
            *(_DWORD *)buf = 136446210;
            v117 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_181A5C000, v98, v99, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }
        }

        goto LABEL_143;
      }

      uint64_t v84 = a2;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      char v85 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
      {
        loga = nw_endpoint_handler_get_id_string(v5);
        v106 = nw_endpoint_handler_dry_run_string(v5);
        nw_endpoint_t v86 = nw_endpoint_handler_copy_endpoint(v5);
        v87 = nw_endpoint_get_logging_description(v86);
        v88 = nw_endpoint_handler_state_string(v5);
        v89 = nw_endpoint_handler_mode_string(v5);
        id v90 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136448002;
        v117 = "nw_endpoint_flow_attach_channel_protocol";
        __int16 v118 = 2082;
        uint64_t v119 = (uint64_t)loga;
        __int16 v120 = 2082;
        BOOL v121 = (void *)v106;
        __int16 v122 = 2082;
        v123 = v87;
        __int16 v124 = 2082;
        v125 = v88;
        __int16 v126 = 2082;
        v127 = v89;
        __int16 v128 = 2114;
        id v129 = v90;
        __int16 v130 = 1024;
        int v131 = a3;
        v35 = v85;
        _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] opened channel at level %u",  buf,  0x4Eu);

        a2 = v84;
      }

      else
      {
        v35 = v85;
      }
    }

    else
    {
      if ((logging_disabled & 1) != 0) {
        goto LABEL_33;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v35 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
      {
        uint64_t v105 = a2;
        log = v35;
        v36 = nw_endpoint_handler_get_id_string(v5);
        v37 = nw_endpoint_handler_dry_run_string(v5);
        nw_endpoint_t v38 = nw_endpoint_handler_copy_endpoint(v5);
        int v39 = a3;
        v40 = nw_endpoint_get_logging_description(v38);
        v41 = nw_endpoint_handler_state_string(v5);
        BOOL v42 = nw_endpoint_handler_mode_string(v5);
        id v43 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136448002;
        v117 = "nw_endpoint_flow_attach_channel_protocol";
        __int16 v118 = 2082;
        uint64_t v119 = (uint64_t)v36;
        __int16 v120 = 2082;
        BOOL v121 = (void *)v37;
        __int16 v122 = 2082;
        v123 = v40;
        __int16 v124 = 2082;
        v125 = v41;
        __int16 v126 = 2082;
        v127 = v42;
        __int16 v128 = 2114;
        id v129 = v43;
        __int16 v130 = 1024;
        a3 = v39;
        int v131 = v39;
        v35 = log;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] opened channel at level %u",  buf,  0x4Eu);

        a2 = v105;
      }
    }

    goto LABEL_33;
  }

  if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v7 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = nw_endpoint_handler_get_id_string(v5);
      os_log_type_t v9 = nw_endpoint_handler_dry_run_string(v5);
      nw_endpoint_t v10 = nw_endpoint_handler_copy_endpoint(v5);
      os_log_type_t v11 = nw_endpoint_get_logging_description(v10);
      BOOL v12 = nw_endpoint_handler_state_string(v5);
      char v13 = nw_endpoint_handler_mode_string(v5);
      id v14 = nw_endpoint_handler_copy_current_path(v5);
      *(_DWORD *)buf = 136447746;
      v117 = "nw_endpoint_flow_attach_channel_protocol";
      __int16 v118 = 2082;
      uint64_t v119 = (uint64_t)v8;
      __int16 v120 = 2082;
      BOOL v121 = (void *)v9;
      __int16 v122 = 2082;
      v123 = v11;
      __int16 v124 = 2082;
      v125 = v12;
      __int16 v126 = 2082;
      v127 = v13;
      __int16 v128 = 2114;
      id v129 = v14;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow does not use channels",  buf,  0x48u);
    }
  }

  BOOL v15 = 0LL;
LABEL_103:

  return v15;
}

          os_packet_set_tso_flags();
          os_packet_set_protocol_segment_size();
          goto LABEL_131;
        }
      }

      else if (((v47 | (*((unsigned __int8 *)a1 + 206) << 16)) & 0x10000) == 0)
      {
        goto LABEL_129;
      }

      os_packet_set_app_metadata();
      if (!*((_WORD *)a1 + 99)) {
        goto LABEL_131;
      }
      goto LABEL_130;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
    v153 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v153, &v223, type))
    {
      if (v223 == 17)
      {
        v154 = (os_log_s *)__nwlog_obj();
        v155 = v223;
        if (!os_log_type_enabled(v154, (os_log_type_t)v223)) {
          goto LABEL_418;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        v156 = "%{public}s called with null frame";
LABEL_417:
        _os_log_impl(&dword_181A5C000, v154, v155, v156, buf, 0xCu);
        goto LABEL_418;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v154 = (os_log_s *)__nwlog_obj();
        v155 = v223;
        if (!os_log_type_enabled(v154, (os_log_type_t)v223)) {
          goto LABEL_418;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        v156 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_417;
      }

      v163 = (char *)__nw_create_backtrace_string();
      v154 = (os_log_s *)__nwlog_obj();
      v155 = v223;
      v164 = os_log_type_enabled(v154, (os_log_type_t)v223);
      if (!v163)
      {
        if (!v164) {
          goto LABEL_418;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        v156 = "%{public}s called with null frame, no backtrace";
        goto LABEL_417;
      }

      if (v164)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        v221 = 2082;
        *(void *)v222 = v163;
        _os_log_impl( &dword_181A5C000,  v154,  v155,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v163);
    }

      if (v43) {
        free(v43);
      }
      id v17 = 0LL;
      goto LABEL_23;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_protocol_udp_get_output_frames";
    v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v66 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v31 = (os_log_s *)__nwlog_obj();
      __int16 v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null udp";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    if (!v66)
    {
      BOOL v31 = (os_log_s *)__nwlog_obj();
      __int16 v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    v40 = (char *)__nw_create_backtrace_string();
    BOOL v31 = (os_log_s *)__nwlog_obj();
    __int16 v32 = type;
    nw_endpoint_t v47 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null udp, no backtrace";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      v69 = "nw_protocol_udp_get_output_frames";
      os_log_type_t v70 = 2082;
      v71 = v40;
      BOOL v42 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    goto LABEL_78;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v69 = "nw_protocol_udp_get_output_frames";
  v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v66 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v66)
    {
      BOOL v31 = (os_log_s *)__nwlog_obj();
      __int16 v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    v40 = (char *)__nw_create_backtrace_string();
    BOOL v31 = (os_log_s *)__nwlog_obj();
    __int16 v32 = type;
    v41 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_114;
      }

      goto LABEL_115;
    }

    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      v69 = "nw_protocol_udp_get_output_frames";
      os_log_type_t v70 = 2082;
      v71 = v40;
      BOOL v42 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_77:
      _os_log_impl(&dword_181A5C000, v31, v32, v42, buf, 0x16u);
    }

LABEL_131:
      if (!v16) {
        goto LABEL_76;
      }
LABEL_75:
      free(v16);
      goto LABEL_76;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj(v72, v73);
      v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v90 = v95;
      if (os_log_type_enabled(v69, v95))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl( &dword_181A5C000,  v69,  v90,  "%{public}s called with null block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_130;
    }

    uint64_t v79 = (char *)__nw_create_backtrace_string();
    __nwlog_obj(v79, v85);
    v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    nw_endpoint_t v86 = v95;
    v87 = os_log_type_enabled(v69, v95);
    if (!v79)
    {
      if (v87)
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl(&dword_181A5C000, v69, v86, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }

      goto LABEL_130;
    }

    if (v87)
    {
      *(_DWORD *)buf = 136446466;
      v97 = "nw_context_reset_timer_block_with_time";
      v98 = 2082;
      os_log_type_t v99 = (uint64_t)v79;
      _os_log_impl( &dword_181A5C000,  v69,  v86,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_131;
  }

  if (!v8)
  {
    __nwlog_obj();
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
    v37 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v41 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl(&dword_181A5C000, v38, v41, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_130;
    }

    if (!v98)
    {
      __nwlog_obj();
      nw_endpoint_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v79 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl( &dword_181A5C000,  v38,  v79,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_130;
    }

    nw_endpoint_t v47 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    nw_endpoint_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v48 = type;
    v49 = os_log_type_enabled(v38, type);
    if (!v47)
    {
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl(&dword_181A5C000, v38, v48, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_130;
    }

    if (v49)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
      BOOL v102 = 2082;
      os_log_type_t v103 = v47;
      _os_log_impl( &dword_181A5C000,  v38,  v48,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_72;
  }

  if (!*(void *)(a3 + 16))
  {
    __nwlog_obj();
    BOOL v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
    v37 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v43 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl(&dword_181A5C000, v38, v43, "%{public}s called with null protocol->identifier", buf, 0xCu);
      }

      goto LABEL_130;
    }

    if (!v98)
    {
      __nwlog_obj();
      nw_endpoint_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v80 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl( &dword_181A5C000,  v38,  v80,  "%{public}s called with null protocol->identifier, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_130;
    }

    nw_endpoint_t v47 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    nw_endpoint_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v50 = type;
    id v51 = os_log_type_enabled(v38, type);
    if (!v47)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
        _os_log_impl( &dword_181A5C000,  v38,  v50,  "%{public}s called with null protocol->identifier, no backtrace",  buf,  0xCu);
      }

      goto LABEL_130;
    }

    if (v51)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v101 = "nw_protocol_instance_registrar_add_wildcard_edge_for_instance";
      BOOL v102 = 2082;
      os_log_type_t v103 = v47;
      _os_log_impl( &dword_181A5C000,  v38,  v50,  "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s",  buf,  0x16u);
    }
  }

      if (v89) {
        free(v89);
      }
      goto LABEL_46;
    }

    goto LABEL_30;
  }

  if (v6)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        BOOL v26 = a1[4];
        if (v26) {
          os_log_type_t v27 = (const char *)(v26 + 609);
        }
        else {
          os_log_type_t v27 = "";
        }
        id v28 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
        *(_DWORD *)buf = 136446978;
        v93 = "nw_framer_flush_output_block_invoke";
        os_log_type_t v94 = 2080;
        v95 = (void *)v27;
        os_log_type_t v96 = 1024;
        LODWORD(v97[0]) = 0;
        WORD2(v97[0]) = 2048;
        *(void *)((char *)v97 + 6) = v28;
        _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Dropping empty output external frame %u < %zu bytes",  buf,  0x26u);
      }
    }

    free(v72);
    if (!v62) {
      goto LABEL_100;
    }
    goto LABEL_151;
  }

  os_log_type_t v27 = *((_DWORD *)v12 + 13);
  if (v27) {
    v27 -= *((_DWORD *)v12 + 14) + *((_DWORD *)v12 + 15);
  }
  id v28 = *((_DWORD *)v11 + 51) + v27;
  ++*((_DWORD *)v11 + 50);
  *((_DWORD *)v11 + 51) = v28;
  *((void *)v12 + 4) = 0LL;
  char v29 = (void *)*((void *)v11 + 24);
  *((void *)v12 + 5) = v29;
  nw_protocol_identifier *v29 = v12;
  *((void *)v11 + 24) = v12 + 32;
  if ((v11[402] & 8) != 0)
  {
    if ((v11[403] & 0x10) != 0)
    {
      if (a6) {
        v11[403] |= 0x40u;
      }
    }

    else
    {
      v30 = (void *)*((void *)v11 - 6);
      if (!v30) {
        goto LABEL_51;
      }
      BOOL v31 = v30[3];
      if (!v31) {
        goto LABEL_51;
      }
      __int16 v32 = *(void (**)(void))(v31 + 64);
      if (!v32) {
        goto LABEL_51;
      }
      v33 = (void *)v30[5];
      if (v33 == &nw_protocol_ref_counted_handle)
      {
        v36 = v30[11];
        if (v36) {
          v30[11] = v36 + 1;
        }
        os_log_type_t v34 = -1;
      }

      else
      {
        os_log_type_t v34 = 0;
      }

      *(void *)buf = v30;
      buf[8] = v34;
      v37 = (void *)*((void *)v11 - 7);
      if (v37 == &nw_protocol_ref_counted_handle)
      {
        int v39 = *((void *)v11 - 1);
        if (v39) {
          *((void *)v11 - 1) = v39 + 1;
        }
        nw_endpoint_t v38 = -1;
      }

      else
      {
        nw_endpoint_t v38 = 0;
      }

      *(void *)os_log_type_t type = v11 - 96;
      os_log_type_t v82 = v38;
      v32();
      if (v37 == &nw_protocol_ref_counted_handle) {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      }
      if (v33 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
        if (!a6) {
          goto LABEL_100;
        }
      }

      else
      {
LABEL_51:
        if (!a6) {
          goto LABEL_100;
        }
      }

      v40 = (void *)*((void *)v11 - 6);
      if (v40)
      {
        v41 = v40[3];
        if (v41)
        {
          BOOL v42 = *(void (**)(void))(v41 + 184);
          if (v42)
          {
            id v43 = (void *)v40[5];
            if (v43 == &nw_protocol_ref_counted_handle)
            {
              nw_endpoint_t v53 = v40[11];
              if (v53) {
                v40[11] = v53 + 1;
              }
              v44 = -1;
            }

            else
            {
              v44 = 0;
            }

            *(void *)buf = v40;
            buf[8] = v44;
            v54 = (void *)*((void *)v11 - 7);
            if (v54 == &nw_protocol_ref_counted_handle)
            {
              int v56 = *((void *)v11 - 1);
              if (v56) {
                *((void *)v11 - 1) = v56 + 1;
              }
              v55 = -1;
            }

            else
            {
              v55 = 0;
            }

            *(void *)os_log_type_t type = v11 - 96;
            os_log_type_t v82 = v55;
            v42();
            if (v54 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            }
            if (v43 == &nw_protocol_ref_counted_handle) {
              goto LABEL_99;
            }
          }
        }
      }
    }
  }

  if (v25) {
    free(v25);
  }
}

                xpc_dictionary_set_BOOL(v2, "disable_listener_datapath", 1);
                if ((*((void *)v1 + 12) & 0x40000000) == 0)
                {
LABEL_96:
                  v36 = *((void *)v1 + 13);
                  if ((*(_WORD *)(v36 + 108) & 0x4000) != 0)
                  {
                    xpc_dictionary_set_BOOL(v2, "known_tracker", 1);
                    v36 = *((void *)v1 + 13);
                  }

                  if (*(_BYTE *)(v36 + 102)) {
                    xpc_dictionary_set_uint64(v2, "attribution", *(unsigned __int8 *)(v36 + 102));
                  }
                  v37 = *((void *)v1 + 12);
                  if ((v37 & 0x800000000LL) != 0)
                  {
                    xpc_dictionary_set_BOOL(v2, "include_ble", 1);
                    v37 = *((void *)v1 + 12);
                    if ((v37 & 0x1000000000LL) == 0)
                    {
LABEL_102:
                      if ((v37 & 0x2000000000LL) == 0) {
                        goto LABEL_103;
                      }
                      goto LABEL_134;
                    }
                  }

                  else if ((v37 & 0x1000000000LL) == 0)
                  {
                    goto LABEL_102;
                  }

                  xpc_dictionary_set_BOOL(v2, "screen_off", 1);
                  v37 = *((void *)v1 + 12);
                  if ((v37 & 0x2000000000LL) == 0)
                  {
LABEL_103:
                    if ((v37 & 0x4000000000LL) == 0)
                    {
LABEL_105:
                      xpc_dictionary_set_value(v2, "metadata", *((xpc_object_t *)v1 + 27));

                      goto LABEL_106;
                    }

    if (v106) {
      free(v106);
    }
    goto LABEL_45;
  }

  if (!*((_BYTE *)v46 + 218) && v46[6] && !v46[36])
  {
    v63 = v46 + 2;
    uint64_t v64 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *((dispatch_queue_t *)v46[2] + 4));
    v65 = v47[36];
    v47[36] = v64;

    uint64_t v66 = *v63;
    id v67 = v47[6];
    id v68 = (dispatch_source_s *)v47[36];
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL45nw_masque_connection_pair_start_waiting_timerP36NWConcrete_nw_masque_connection_pair_block_invoke;
    __int16 v126 = (void *(*)(uint64_t, uint64_t))&unk_189BC9238;
    v69 = v66;
    *(void *)v127 = v69;
    os_log_type_t v70 = v67;
    *(void *)&v127[8] = v70;
    dispatch_source_set_event_handler(v68, buf);
    v71 = (dispatch_source_s *)v47[36];
    uint64_t v72 = dispatch_time(0LL, 15000000000LL);
    dispatch_source_set_timer(v71, v72, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    dispatch_resume((dispatch_object_t)v47[36]);
    __nwlog_obj();
    int v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      v74 = v47[2];
      os_log_type_t v75 = v47[6];
      *(_DWORD *)__int16 v130 = 136446722;
      int v131 = "nw_masque_connection_pair_start_waiting_timer";
      v132 = 2114;
      uint64_t v133 = v74;
      v134 = 2112;
      __int16 v135 = v75;
      _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ starting wait timer for %@",  v130,  0x20u);
    }
  }

            goto LABEL_131;
          }

          if (v69)
          {
            *(_DWORD *)buf = 136446466;
            char v83 = "nw_pac_resolver_create_with_url";
            uint64_t v84 = 2082;
            char v85 = v66;
            _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v66);
        }

      if (!v51)
      {
LABEL_132:
        v6 = &qword_18C45F000;
        goto LABEL_133;
      }

    free(backtrace_string);
    if (!v31) {
      return;
    }
LABEL_61:
    BOOL v42 = (char *)v31;
LABEL_62:
    free(v42);
    return;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v117 = "nw_protocol_http_connect_connected";
    BOOL v31 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (uu == 17)
    {
      v59 = (os_log_s *)__nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      os_log_type_t v34 = "%{public}s called with null http_connect";
      goto LABEL_177;
    }

    if (!(_BYTE)v112)
    {
      v59 = (os_log_s *)__nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      os_log_type_t v34 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_177;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = (os_log_s *)__nwlog_obj();
    v60 = uu;
    v69 = os_log_type_enabled(v59, (os_log_type_t)uu);
    if (!backtrace_string)
    {
      if (!v69) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      os_log_type_t v34 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_177;
    }

    if (v69)
    {
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      __int16 v118 = 2082;
      uint64_t v119 = backtrace_string;
      id v68 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
      goto LABEL_129;
    }

    goto LABEL_130;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v117 = "nw_protocol_http_connect_connected";
    BOOL v31 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (uu == 17)
    {
      v59 = (os_log_s *)__nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      os_log_type_t v34 = "%{public}s called with null other_protocol";
      goto LABEL_177;
    }

    if (!(_BYTE)v112)
    {
      v59 = (os_log_s *)__nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      os_log_type_t v34 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_177;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = (os_log_s *)__nwlog_obj();
    v60 = uu;
    os_log_type_t v70 = os_log_type_enabled(v59, (os_log_type_t)uu);
    if (backtrace_string)
    {
      if (!v70) {
        goto LABEL_130;
      }
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      __int16 v118 = 2082;
      uint64_t v119 = backtrace_string;
      id v68 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_129;
    }

    if (!v70) {
      goto LABEL_60;
    }
    *(_DWORD *)buf = 136446210;
    v117 = "nw_protocol_http_connect_connected";
    os_log_type_t v34 = "%{public}s called with null other_protocol, no backtrace";
LABEL_177:
    int v39 = v59;
    v40 = v60;
    v41 = 12;
LABEL_59:
    _os_log_impl(&dword_181A5C000, v39, v40, v34, buf, v41);
LABEL_60:
    if (!v31) {
      return;
    }
    goto LABEL_61;
  }

  if (a1->output_handler != a2)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
        if (connected)
        {
          int v8 = a2;
LABEL_10:
          connected(default_input_handler, v8);
          return;
        }
      }
    }

    __nwlog_obj();
    BOOL v48 = a1->default_input_handler;
    v49 = "invalid";
    if (v48)
    {
      identifier = v48->identifier;
      if (identifier) {
        v49 = (const char *)identifier;
      }
    }

    *(_DWORD *)buf = 136446466;
    v117 = "nw_protocol_http_connect_connected";
    __int16 v118 = 2082;
    uint64_t v119 = (char *)v49;
    id v51 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (__nwlog_fault(v51, &uu, &v112))
    {
      if (uu == 17)
      {
        BOOL v52 = (os_log_s *)__nwlog_obj();
        nw_endpoint_t v53 = uu;
        if (!os_log_type_enabled(v52, (os_log_type_t)uu)) {
          goto LABEL_163;
        }
        v54 = a1->default_input_handler;
        v55 = "invalid";
        if (v54)
        {
          int v56 = v54->identifier;
          if (v56) {
            v55 = (const char *)v56;
          }
        }

  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = __95__NWURLSessionTask_loaderDidReceiveServerTrustChallenge_secProtocolMetadata_completionHandler___block_invoke_2;
  aBlock[3] = &unk_189BBFE68;
  aBlock[4] = self;
  v87 = v10;
  uint64_t v84 = v9;
  char v85 = v8;
  nw_endpoint_t v86 = v14;
  v69 = _Block_copy(aBlock);
  os_log_type_t v70 = v69;
  if (self && self->_performingServerTrustCallback)
  {
    serverTrustCallbackQueue = self->_serverTrustCallbackQueue;
    if (!serverTrustCallbackQueue)
    {
      uint64_t v72 = (NSMutableArray *)objc_alloc_init(MEMORY[0x189603FA8]);
      int v73 = self->_serverTrustCallbackQueue;
      self->_serverTrustCallbackQueue = v72;

      serverTrustCallbackQueue = self->_serverTrustCallbackQueue;
    }

    v74 = serverTrustCallbackQueue;
    os_log_type_t v75 = _Block_copy(v70);
    -[NSMutableArray addObject:](v74, "addObject:", v75);
  }

  else
  {
    (*((void (**)(void *))v69 + 2))(v69);
  }

  int v39 = v87;
LABEL_137:

  CFRelease(v33);
}

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v72 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v125 = "nwsc_request_create_and_start_connection_inner";
          int v73 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(error) = 0;
          if (__nwlog_fault(v73, type, &error))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v74 = (os_log_s *)(id)gLogObj;
              os_log_type_t v75 = type[0];
              if (os_log_type_enabled(v74, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v125 = "nwsc_request_create_and_start_connection_inner";
                _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s nw_service_connector_create_initial_payload_for_request failed",  buf,  0xCu);
              }
            }

            else if ((_BYTE)error)
            {
              BOOL v76 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v74 = (os_log_s *)(id)gLogObj;
              uint64_t v77 = type[0];
              v78 = os_log_type_enabled(v74, type[0]);
              if (v76)
              {
                if (v78)
                {
                  *(_DWORD *)buf = 136446466;
                  v125 = "nwsc_request_create_and_start_connection_inner";
                  LOWORD(v126[0]) = 2082;
                  *(void *)((char *)v126 + 2) = v76;
                  _os_log_impl( &dword_181A5C000,  v74,  v77,  "%{public}s nw_service_connector_create_initial_payload_for_request failed, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v76);
                if (!v73) {
                  goto LABEL_156;
                }
                goto LABEL_155;
              }

              if (v78)
              {
                *(_DWORD *)buf = 136446210;
                v125 = "nwsc_request_create_and_start_connection_inner";
                _os_log_impl( &dword_181A5C000,  v74,  v77,  "%{public}s nw_service_connector_create_initial_payload_for_request failed, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v74 = (os_log_s *)(id)gLogObj;
              uint64_t v84 = type[0];
              if (os_log_type_enabled(v74, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v125 = "nwsc_request_create_and_start_connection_inner";
                _os_log_impl( &dword_181A5C000,  v74,  v84,  "%{public}s nw_service_connector_create_initial_payload_for_request failed, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

          if (!v73)
          {
LABEL_156:
            uint64_t v64 = 0LL;
LABEL_196:

            goto LABEL_197;
          }

      if (v38) {
        free(v38);
      }
LABEL_36:
      if (v21 != 89) {
        nw_connection_cancel(v16);
      }
      goto LABEL_92;
    }

                *(_DWORD *)(v92 + 40_Block_object_dispose(va, 8) = 0;
                *(void *)(v92 + 392) = 0LL;
                *(_DWORD *)(v92 + 400) = 0;
                *(_DWORD *)(v92 + 412) = *(_DWORD *)(v92 + 256);
                if (v93)
                {
                  if (*v106)
                  {
                    v107 = *(void *)(v92 + 368);
                    if (v107)
                    {
                      while (*(void *)(v107 + 40) != v95)
                      {
                        v107 = *(void *)(v107 + 16);
                        if (!v107) {
                          goto LABEL_160;
                        }
                      }

                      *(void *)(v92 + 392) = v107;
                    }
                  }
                }

    if (v56) {
LABEL_131:
    }
      free(v56);
    return 0LL;
  }

  a6->tqh_first = 0LL;
  a6->tqh_last = &a6->tqh_first;
  nw_endpoint_t v10 = &a1[6].flow_id[13];
  os_log_type_t v11 = *(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16);
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x4800) != 0) {
    return 0LL;
  }
  if ((~v11 & 0x18000) != 0)
  {
    identifier = (int)a1[4].identifier;
    if (identifier != 2)
    {
      if (identifier != 1 || !a5 || !a4)
      {
LABEL_42:
        if ((v11 & 0x800) == 0)
        {
          a1[6].flow_id[15] = BYTE2(v11);
          *(_WORD *)nw_endpoint_t v10 = v11 | 0x800;
          nw_queue_resume_source((uint64_t)p_output_handler[15], (uint64_t)a2);
        }

        nw_socket_set_send_low_water_mark((uint64_t)p_output_handler, 1u);
        return 0LL;
      }

      BOOL v12 = 0LL;
      for (i = 0; i < a4; i += v19)
      {
        if (a4 - i >= 0x2400) {
          __int16 v19 = 9216LL;
        }
        else {
          __int16 v19 = a4 - i;
        }
        output_frame = nw_socket_allocate_output_frame((uint64_t)p_output_handler, v19);
        if (!output_frame) {
          break;
        }
        *(void *)(output_frame + 16) = 0LL;
        uint64_t v21 = *(uint64_t **)a1[5].flow_id;
        *(void *)(output_frame + 24) = v21;
        os_log_s *v21 = output_frame;
        *(void *)a1[5].flow_id = output_frame + 16;
        *(void *)(output_frame + 32) = 0LL;
        tqh_last = a6->tqh_last;
        *(void *)(output_frame + 40) = tqh_last;
        *tqh_last = (nw_frame *)output_frame;
        a6->tqh_last = (nw_frame **)(output_frame + 32);
        BOOL v12 = (v12 + 1);
      }

      free(backtrace_string);
      goto LABEL_148;
    }

    if (!v67) {
      goto LABEL_148;
    }
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_get_output_frames";
    v59 = "%{public}s called with null return_array, no backtrace";
LABEL_147:
    _os_log_impl(&dword_181A5C000, v57, v58, v59, buf, 0xCu);
LABEL_148:
    if (v56) {
      free(v56);
    }
    return 0LL;
  }

  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v60 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v61 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v106 = "nw_protocol_http2_get_output_frames";
      v107 = 2082;
      v108 = handle + 390;
      id v109 = 2080;
      v110 = " ";
      uint64_t v111 = 1024;
      uint64_t v112 = v61;
      _os_log_impl(&dword_181A5C000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }

  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_25_81808);
  }
  a6->tqh_first = 0LL;
  a6->tqh_last = &a6->tqh_first;
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    if ((*((__int16 *)handle + 194) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v19 = gconnectionLogObj;
      result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        uint64_t v20 = *((_DWORD *)handle + 92);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447490;
        v106 = "nw_protocol_http2_get_output_frames";
        v107 = 2082;
        v108 = handle + 390;
        id v109 = 2080;
        v110 = " ";
        uint64_t v111 = 1024;
        uint64_t v112 = v20;
        unsigned int v113 = 2048;
        *(void *)char v114 = a2;
        *(_WORD *)&v114[8] = 2080;
        *(void *)&v114[10] = identifier;
        char v18 = "%{public}s %{public}s%s<i%u> cannot get output frames for protocol %p (%s) without proper output handler context";
        uint64_t v22 = (os_log_s *)v19;
        os_log_type_t v23 = OS_LOG_TYPE_ERROR;
        nw_endpoint_t v24 = 58;
LABEL_31:
        _os_log_impl(&dword_181A5C000, v22, v23, v18, buf, v24);
        return 0LL;
      }

      return result;
    }

    return 0LL;
  }

  os_log_type_t v11 = output_handler_context[4];
  if (v11)
  {
    BOOL v12 = *(unsigned __int16 *)(v11 + 188);
    char v13 = v12 | (*(unsigned __int8 *)(v11 + 190) << 16);
    if ((v12 & 1) == 0)
    {
      if ((v13 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v14 = gconnectionLogObj;
        result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          id v17 = *(_DWORD *)(v11 + 176);
          char v16 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447490;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          id v109 = 2080;
          v110 = " ";
          uint64_t v111 = 1024;
          uint64_t v112 = v16;
          unsigned int v113 = 1024;
          *(_DWORD *)char v114 = v17;
          *(_WORD *)&v114[4] = 2048;
          *(void *)&v114[6] = a2;
          char v18 = "%{public}s %{public}s%s<i%u:s%d> cannot get output frames for stream that is not yet open, protocol (%p)";
LABEL_30:
          uint64_t v22 = (os_log_s *)v14;
          os_log_type_t v23 = OS_LOG_TYPE_ERROR;
          nw_endpoint_t v24 = 54;
          goto LABEL_31;
        }

        return result;
      }

      return 0LL;
    }

    if ((v12 & 0x2000) != 0)
    {
      result = 0LL;
      if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v29 = gconnectionLogObj;
        result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        if (result)
        {
          v30 = *((_DWORD *)handle + 92);
          BOOL v31 = *(_DWORD *)(v11 + 176);
          *(_DWORD *)buf = 136447234;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = handle + 390;
          id v109 = 2080;
          v110 = " ";
          uint64_t v111 = 1024;
          uint64_t v112 = v30;
          unsigned int v113 = 1024;
          *(_DWORD *)char v114 = v31;
          char v18 = "%{public}s %{public}s%s<i%u> stream %d sending informational response, not allowing output frames";
          uint64_t v22 = (os_log_s *)v29;
          os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
          nw_endpoint_t v24 = 44;
          goto LABEL_31;
        }
      }

      return result;
    }

    if (*(void *)(v11 + 16))
    {
      result = 0LL;
      if ((v13 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v26 = gconnectionLogObj;
        result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        if (result)
        {
          id v28 = *(_DWORD *)(v11 + 176);
          os_log_type_t v27 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447490;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          id v109 = 2080;
          v110 = " ";
          uint64_t v111 = 1024;
          uint64_t v112 = v27;
          unsigned int v113 = 1024;
          *(_DWORD *)char v114 = v28;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v28;
          char v18 = "%{public}s %{public}s%s<i%u:s%d> stream %d already has waiting output frames, cannot get more";
          uint64_t v22 = (os_log_s *)v26;
          os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
          nw_endpoint_t v24 = 50;
          goto LABEL_31;
        }
      }

      return result;
    }

    if (a4 >= 0x1000000) {
      __int16 v32 = 0x1000000LL;
    }
    else {
      __int16 v32 = a4;
    }
    if ((v13 & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v72 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v74 = *(_DWORD *)(v11 + 176);
        int v73 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v106 = "nw_protocol_http2_get_output_frames";
        v107 = 2082;
        v108 = (char *)(v11 + 191);
        id v109 = 2080;
        v110 = " ";
        uint64_t v111 = 1024;
        uint64_t v112 = v73;
        unsigned int v113 = 1024;
        *(_DWORD *)char v114 = v74;
        *(_WORD *)&v114[4] = 1024;
        *(_DWORD *)&v114[6] = v32;
        *(_WORD *)&v114[10] = 1024;
        *(_DWORD *)&v114[12] = a4;
        _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> h2 was asked for frame of adjusted size %u (original %u)",  buf,  0x38u);
      }
    }

    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v75 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v77 = *(_DWORD *)(v11 + 176);
        BOOL v76 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447490;
        v106 = "nw_protocol_http2_get_output_frames";
        v107 = 2082;
        v108 = (char *)(v11 + 191);
        id v109 = 2080;
        v110 = " ";
        uint64_t v111 = 1024;
        uint64_t v112 = v76;
        unsigned int v113 = 1024;
        *(_DWORD *)char v114 = v77;
        *(_WORD *)&v114[4] = 1024;
        *(_DWORD *)&v114[6] = v32;
        _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> adding frame of size %u",  buf,  0x32u);
      }
    }

    if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v78 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v79 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v106 = "http2_create_output_frame";
        v107 = 2082;
        v108 = handle + 390;
        id v109 = 2080;
        v110 = " ";
        uint64_t v111 = 1024;
        uint64_t v112 = v79;
        unsigned int v113 = 1024;
        *(_DWORD *)char v114 = v32;
        _os_log_impl( &dword_181A5C000,  v78,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> requested output frame of length %u",  buf,  0x2Cu);
      }
    }

    frame = nw_frame_cache_create_frame((uint64_t *)handle + 25, v32);
    if (frame)
    {
      os_log_type_t v34 = frame;
      *(void *)(frame + 16) = 0LL;
      v35 = (uint64_t *)*((void *)handle + 24);
      *(void *)(frame + 24) = v35;
      os_log_s *v35 = frame;
      *((void *)handle + 24) = frame + 16;
      *(void *)(frame + 80) = nw_protocol_http2_frame_output_finalizer;
      *(void *)(frame + 8_Block_object_dispose(va, 8) = 0LL;
      http2_output_frame_metadata_reset(frame, (uint64_t)handle, (uint64_t)a2);
      if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v80 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v81 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136447490;
          v106 = "http2_create_output_frame";
          v107 = 2082;
          v108 = handle + 390;
          id v109 = 2080;
          v110 = " ";
          uint64_t v111 = 1024;
          uint64_t v112 = v81;
          unsigned int v113 = 2048;
          *(void *)char v114 = v34;
          *(_WORD *)&v114[8] = 1024;
          *(_DWORD *)&v114[10] = v32;
          _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> output_frame_create returning frame %p for requested length %u",  buf,  0x36u);
        }
      }

      v36 = *(_DWORD *)(v34 + 52);
      if (v36) {
        v37 = v36 - (*(_DWORD *)(v34 + 56) + *(_DWORD *)(v34 + 60));
      }
      else {
        v37 = 0;
      }
      nw_endpoint_t v38 = *(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16);
      if (v37 == (_DWORD)v32)
      {
        if ((v38 & 0x80000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v84 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            nw_endpoint_t v86 = *(_DWORD *)(v11 + 176);
            char v85 = *(_DWORD *)(v11 + 180);
            *(_DWORD *)buf = 136447490;
            v106 = "nw_protocol_http2_get_output_frames";
            v107 = 2082;
            v108 = (char *)(v11 + 191);
            id v109 = 2080;
            v110 = " ";
            uint64_t v111 = 1024;
            uint64_t v112 = v85;
            unsigned int v113 = 1024;
            *(_DWORD *)char v114 = v86;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v32;
            _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> returning frame of %u bytes",  buf,  0x32u);
          }
        }

        *(void *)(v34 + 32) = 0LL;
        tqh_last = a6->tqh_last;
        *(void *)(v34 + 40) = tqh_last;
        *tqh_last = (nw_frame *)v34;
        a6->tqh_last = (nw_frame **)(v34 + 32);
        return 1LL;
      }

      if ((v38 & 0x80000) != 0)
      {
LABEL_92:
        nw_frame_finalize(v34);
        return 0LL;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v41 = *(_DWORD *)(v11 + 176);
      v40 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)buf = 136447746;
      v106 = "nw_protocol_http2_get_output_frames";
      v107 = 2082;
      v108 = (char *)(v11 + 191);
      id v109 = 2080;
      v110 = " ";
      uint64_t v111 = 1024;
      uint64_t v112 = v40;
      unsigned int v113 = 1024;
      *(_DWORD *)char v114 = v41;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v37;
      *(_WORD *)&v114[10] = 1024;
      *(_DWORD *)&v114[12] = v32;
      BOOL v42 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v103 = 0;
      if (__nwlog_fault(v42, &type, &v103))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v43 = (os_log_s *)gconnectionLogObj;
          v44 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_90;
          }
          v46 = *(_DWORD *)(v11 + 176);
          BOOL v45 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447746;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          id v109 = 2080;
          v110 = " ";
          uint64_t v111 = 1024;
          uint64_t v112 = v45;
          unsigned int v113 = 1024;
          *(_DWORD *)char v114 = v46;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          nw_endpoint_t v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_create_output_frame";
          goto LABEL_89;
        }

        if (!v103)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v43 = (os_log_s *)gconnectionLogObj;
          v44 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_90;
          }
          nw_endpoint_t v53 = *(_DWORD *)(v11 + 176);
          BOOL v52 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447746;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          id v109 = 2080;
          v110 = " ";
          uint64_t v111 = 1024;
          uint64_t v112 = v52;
          unsigned int v113 = 1024;
          *(_DWORD *)char v114 = v53;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          nw_endpoint_t v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_creat"
                "e_output_frame, backtrace limit exceeded";
          goto LABEL_89;
        }

        BOOL v48 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v43 = (os_log_s *)gconnectionLogObj;
        v44 = type;
        v49 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v48)
        {
          if (v49)
          {
            id v51 = *(_DWORD *)(v11 + 176);
            BOOL v50 = *(_DWORD *)(v11 + 180);
            *(_DWORD *)buf = 136448002;
            v106 = "nw_protocol_http2_get_output_frames";
            v107 = 2082;
            v108 = (char *)(v11 + 191);
            id v109 = 2080;
            v110 = " ";
            uint64_t v111 = 1024;
            uint64_t v112 = v50;
            unsigned int v113 = 1024;
            *(_DWORD *)char v114 = v51;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v37;
            *(_WORD *)&v114[10] = 1024;
            *(_DWORD *)&v114[12] = v32;
            *(_WORD *)&v114[16] = 2082;
            *(void *)&v114[18] = v48;
            _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_create_ output_frame, dumping backtrace:%{public}s",  buf,  0x42u);
          }

          free(v48);
          goto LABEL_90;
        }

        if (v49)
        {
          v55 = *(_DWORD *)(v11 + 176);
          v54 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447746;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          id v109 = 2080;
          v110 = " ";
          uint64_t v111 = 1024;
          uint64_t v112 = v54;
          unsigned int v113 = 1024;
          *(_DWORD *)char v114 = v55;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          nw_endpoint_t v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_creat"
                "e_output_frame, no backtrace";
LABEL_89:
          _os_log_impl(&dword_181A5C000, v43, v44, v47, buf, 0x38u);
        }
      }

    if (v78) {
      free(v78);
    }
    id v68 = 0;
    uint64_t v5 = v238;
    v65 = v244;
    v63 = v245;
LABEL_102:
    v70[2] = 0LL;
    v69 = *(void **)(v63 + 296);
    v70[3] = v69;
    os_log_s *v69 = v70;
    *(void *)(v63 + 296) = v71;
    if (v65) {
      continue;
    }
    break;
  }

  if (!*(_WORD *)type) {
    id v68 = 1;
  }
  if ((v68 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v96 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = *(unsigned __int16 *)type;
      _os_log_impl(&dword_181A5C000, v96, OS_LOG_TYPE_ERROR, "%{public}s use_count is not 0 at the end: %u", buf, 0x12u);
    }
  }

  v6 = v234;
  v63 = v245;
LABEL_143:
  if ((nw_channel_check_defunct(v63) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v254 = "nw_channel_add_input_frames";
    v97 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v252 = OS_LOG_TYPE_DEFAULT;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v252)
      {
        os_log_type_t v103 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v104 = (os_log_s *)gLogObj;
        uint64_t v105 = type[0];
        v106 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v103)
        {
          if (v106)
          {
            *(_DWORD *)buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            v255 = 2082;
            v256[0] = v103;
            _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s failed to get buflet from packet, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v103);
          goto LABEL_165;
        }

        if (!v106) {
          goto LABEL_165;
        }
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        BOOL v100 = v104;
        os_log_type_t v101 = v105;
        BOOL v102 = "%{public}s failed to get buflet from packet, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v111 = gLogObj;
        uint64_t v112 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_165;
        }
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        BOOL v100 = (os_log_s *)v111;
        os_log_type_t v101 = v112;
        BOOL v102 = "%{public}s failed to get buflet from packet, backtrace limit exceeded";
      }

void sub_181B3DF3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_registration_can_support_user_packet_pool(void *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  BOOL v3 = a1;
  id v4 = a2;
  if (v3)
  {
    id v5 = nw_path_copy_flow_for_registration(v3, v4);
    v6 = v5;
    if (v5) {
      uint64_t can_support_user_packet_pool = nw_path_flow_nexus_can_support_user_packet_pool(v5);
    }
    else {
      uint64_t can_support_user_packet_pool = 0LL;
    }

    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
  nw_endpoint_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_path_flow_nexus_can_support_user_packet_pool(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    nw_endpoint_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null flow", length, 0xCu);
        }
      }

      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)length = 136446466;
            *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null flow, dumping backtrace:%{public}s",  length,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v16)
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null flow, no backtrace", length, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null flow, backtrace limit exceeded",  length,  0xCu);
        }
      }
    }

uint64_t nw_path_flow_registration_should_use_event_ring(void *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  BOOL v3 = a1;
  id v4 = a2;
  if (v3)
  {
    id v5 = nw_path_copy_flow_for_registration(v3, v4);
    v6 = v5;
    if (v5) {
      uint64_t should_use_event_ring = nw_path_flow_nexus_should_use_event_ring(v5);
    }
    else {
      uint64_t should_use_event_ring = 0LL;
    }

    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_path_flow_registration_should_use_event_ring";
  nw_endpoint_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_should_use_event_ring";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v20 = "nw_path_flow_registration_should_use_event_ring";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_should_use_event_ring";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_path_flow_registration_should_use_event_ring";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_path_flow_nexus_should_use_event_ring(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    nw_endpoint_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(void *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null flow", length, 0xCu);
        }
      }

      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)length = 136446466;
            *(void *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null flow, dumping backtrace:%{public}s",  length,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v16)
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null flow, no backtrace", length, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null flow, backtrace limit exceeded",  length,  0xCu);
        }
      }
    }

BOOL nw_channel_create_with_attributes(_DWORD *a1, unsigned __int8 *uu, unsigned int a3, uint64_t a4)
{
  uint64_t v129 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "nw_channel_create_with_attributes";
    int v80 = (char *)_os_log_send_and_compose_impl();
    out[0] = 16;
    LOBYTE(v112) = 0;
    if (out[0] == 17)
    {
      uint64_t v81 = (os_log_s *)__nwlog_obj();
      os_log_type_t v82 = out[0];
      if (os_log_type_enabled(v81, (os_log_type_t)out[0]))
      {
        *(_DWORD *)block = 136446210;
        *(void *)&block[4] = "nw_channel_create_with_attributes";
        char v83 = "%{public}s called with null context";
LABEL_189:
        _os_log_impl(&dword_181A5C000, v81, v82, v83, block, 0xCu);
      }

LABEL_225:
  __break(1u);
  return result;
}

  if (v77) {
LABEL_226:
  }
    free(v77);
}

          if (v180) {
            free(v180);
          }
          os_log_type_t v11 = 0LL;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = -1;
          return v11;
        }

        return 0LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v72 = (_DWORD *)**(unsigned int **)(a1 + 40);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = "maximum_frame_count";
      *(_WORD *)&buf[22] = 2048;
      v292 = 1LL;
      v293 = 2048;
      v294 = v72;
      int v73 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v288 = 0;
      if (__nwlog_fault(v73, &type, &v288))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v74 = (os_log_s *)__nwlog_obj();
          BOOL v75 = type;
          if (os_log_type_enabled(v74, type))
          {
            BOOL v76 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1LL;
            v293 = 2048;
            v294 = v76;
            uint64_t v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_186:
            _os_log_impl(&dword_181A5C000, v74, v75, v77, buf, 0x2Au);
          }
        }

        else if (v288)
        {
          v88 = (char *)__nw_create_backtrace_string();
          v74 = (os_log_s *)__nwlog_obj();
          BOOL v75 = type;
          os_log_type_t v89 = os_log_type_enabled(v74, type);
          if (v88)
          {
            if (v89)
            {
              id v90 = (_DWORD *)**(unsigned int **)(a1 + 40);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "maximum_frame_count";
              *(_WORD *)&buf[22] = 2048;
              v292 = 1LL;
              v293 = 2048;
              v294 = v90;
              v295 = 2082;
              v296 = v88;
              _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v88);
            goto LABEL_187;
          }

          if (v89)
          {
            v157 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1LL;
            v293 = 2048;
            v294 = v157;
            uint64_t v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_186;
          }
        }

        else
        {
          v74 = (os_log_s *)__nwlog_obj();
          BOOL v75 = type;
          if (os_log_type_enabled(v74, type))
          {
            v153 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1LL;
            v293 = 2048;
            v294 = v153;
            uint64_t v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_186;
          }
        }
      }

            nw::release_if_needed<nw_protocol *>((uint64_t *)&v163);
            goto LABEL_226;
          }

          __nwlog_obj();
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
          os_log_type_t v65 = (char *)_os_log_send_and_compose_impl();

          v170[0] = 16;
          LOBYTE(v163) = 0;
          if (__nwlog_fault(v65, v170, &v163))
          {
            if (v170[0] == 17)
            {
              __nwlog_obj();
              uint32_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v67 = v170[0];
              if (os_log_type_enabled(v66, (os_log_type_t)v170[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler";
                _os_log_impl(&dword_181A5C000, v66, v67, "%{public}s called with null protocol", buf, 0xCu);
              }

                    if (v98) {
                      free(v98);
                    }
                    uint64_t v67 = 0LL;
LABEL_136:

                    *((void *)handle + 23) = v67;
                    id v68 = v60;
                    v69 = v68[23];

                    if (!v69)
                    {
LABEL_153:
                      os_log_type_t v82 = v68;
                      char v83 = *(id *)(v8[13] + 136);

                      *((void *)handle + 2_Block_object_dispose(va, 8) = 0LL;
                      uint64_t v84 = handle + 224;
                      *((void *)v84 - 7) = v83;
                      *((_DWORD *)v84 + 14) = 0;
                      *((void *)v84 + 1) = v84;
                      return 1LL;
                    }

                    os_log_type_t v70 = v69;
                    os_log_type_t v71 = v70;
                    if (v70[38] == 1)
                    {
                      uint64_t v72 = v70[39];

                      int v73 = (v72 == 4002) << 8;
                    }

                    else
                    {

                      int v73 = 0;
                    }

                    *((_WORD *)handle + 184) = *((_WORD *)handle + 184) & 0xFEFF | v73;
                    v74 = v71;
                    BOOL v75 = v74[13];

                    if (v75
                      && (username = (const char *)nw_authentication_credential_get_username(v75),
                          (password = (const char *)nw_authentication_credential_get_password(v75)) != 0LL))
                    {
                      if (username)
                      {
                        if (*username)
                        {
                          v78 = password;
                          if (*password)
                          {
                            uint64_t v79 = (void *)*((void *)handle + 22);
                            if (v79)
                            {
                              os_release(v79);
                              *((void *)handle + 22) = 0LL;
                            }

                            int v80 = nw_authentication_credential_create(1);
                            *((void *)handle + 22) = v80;
                            *((_DWORD *)handle + 6_Block_object_dispose(va, 8) = 0;
                            nw_authentication_credential_set_username(v80, username);
                            nw_authentication_credential_set_password(*((void **)handle + 22), v78);
                          }
                        }
                      }
                    }

                    else
                    {
                      uint64_t v81 = (nw_endpoint *)nw_proxy_config_copy_endpoint(v74);
                      nw_endpoint_get_hostname(v81);
                      if (v81) {
                        os_release(v81);
                      }
                      if (!v75) {
                        goto LABEL_152;
                      }
                    }

                    os_release(v75);
LABEL_152:
                    os_release(v74);
                    goto LABEL_153;
                  }
                }

                else
                {
                  *((void *)handle + 17) = 0LL;
                }

                if ((*((_WORD *)handle + 184) & 0x80) != 0) {
                  goto LABEL_159;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();
                type[0] = OS_LOG_TYPE_ERROR;
                uint64_t v111 = 0;
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v28 = (os_log_s *)gLogObj;
                  char v29 = type[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                    goto LABEL_157;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = handle + 284;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  v30 = "%{public}s %{public}s%sNo remote endpoint";
                  goto LABEL_156;
                }

                if (!v111)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v28 = (os_log_s *)gLogObj;
                  char v29 = type[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                    goto LABEL_157;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = handle + 284;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  v30 = "%{public}s %{public}s%sNo remote endpoint, backtrace limit exceeded";
                  goto LABEL_156;
                }

                v37 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v28 = (os_log_s *)gLogObj;
                char v29 = type[0];
                os_log_type_t v38 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
                if (!v37)
                {
                  if (!v38) {
                    goto LABEL_157;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = handle + 284;
                  *(_WORD *)&buf[22] = 2080;
                  uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  v30 = "%{public}s %{public}s%sNo remote endpoint, no backtrace";
                  goto LABEL_156;
                }

                if (!v38) {
                  goto LABEL_90;
                }
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                LOWORD(v114) = 2082;
                *(void *)((char *)&v114 + 2) = v37;
                int v39 = "%{public}s %{public}s%sNo remote endpoint, dumping backtrace:%{public}s";
LABEL_89:
                _os_log_impl(&dword_181A5C000, v28, v29, v39, buf, 0x2Au);
                goto LABEL_90;
              }

              __int16 v19 = *((_WORD *)handle + 184) & 0x80;
            }
          }

          if (v19) {
            goto LABEL_159;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
          os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          uint64_t v111 = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v28 = (os_log_s *)gLogObj;
            char v29 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
              goto LABEL_157;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
            v30 = "%{public}s %{public}s%sUnable to get path";
            goto LABEL_156;
          }

          if (!v111)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v28 = (os_log_s *)gLogObj;
            char v29 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
              goto LABEL_157;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
            v30 = "%{public}s %{public}s%sUnable to get path, backtrace limit exceeded";
            goto LABEL_156;
          }

          v37 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v28 = (os_log_s *)gLogObj;
          char v29 = type[0];
          v40 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (!v37)
          {
            if (!v40) {
              goto LABEL_157;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
            v30 = "%{public}s %{public}s%sUnable to get path, no backtrace";
            goto LABEL_156;
          }

          if (!v40) {
            goto LABEL_90;
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v114) = 2082;
          *(void *)((char *)&v114 + 2) = v37;
          int v39 = "%{public}s %{public}s%sUnable to get path, dumping backtrace:%{public}s";
          goto LABEL_89;
        }
      }
    }
  }

  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
    id v31 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    uint64_t v111 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v32 = (os_log_s *)gLogObj;
      v33 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
      os_log_type_t v34 = "%{public}s %{public}s%sUnable to get parameters";
    }

    else if (v111)
    {
      v35 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v32 = (os_log_s *)gLogObj;
      v33 = type[0];
      v36 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v114) = 2082;
          *(void *)((char *)&v114 + 2) = v35;
          _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s %{public}s%sUnable to get parameters, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v35);
LABEL_79:
        if (v31)
        {
          int v51 = (char *)v31;
LABEL_81:
          free(v51);
          goto LABEL_82;
        }

        goto LABEL_82;
      }

      if (!v36) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
      os_log_type_t v34 = "%{public}s %{public}s%sUnable to get parameters, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v32 = (os_log_s *)gLogObj;
      v33 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_connect_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
      os_log_type_t v34 = "%{public}s %{public}s%sUnable to get parameters, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0x20u);
    goto LABEL_79;
  }

          if (!v8) {
            return;
          }
          goto LABEL_226;
        }

        ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v54);
        uint64_t v57 = CFHTTPMessageCopyResponseStatusLine(*((CFHTTPMessageRef *)handle + 25));
        if ((*((_WORD *)handle + 184) & 0x80) == 0)
        {
          if (*((_BYTE *)v32 + 1537))
          {
            uint64_t v114 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v172 = " ";
              LOWORD(v173) = 2112;
              *(void *)((char *)&v173 + 2) = v57;
              _os_log_impl( &dword_181A5C000,  v114,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sResponse Message: %@",  buf,  0x2Au);
            }
          }
        }

        if ((*((_WORD *)handle + 184) & 0x80) == 0)
        {
          if (*((_BYTE *)v32 + 1537))
          {
            v115 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v172 = " ";
              LOWORD(v173) = 2048;
              *(void *)((char *)&v173 + 2) = ResponseStatusCode;
              _os_log_impl( &dword_181A5C000,  v115,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sStatus Code: %ld",  buf,  0x2Au);
            }
          }
        }

        if (!*((void *)handle + 1))
        {
          uint64_t v58 = mach_continuous_time();
          if (v58 <= 1) {
            v59 = 1LL;
          }
          else {
            v59 = v58;
          }
          *((void *)handle + 1) = v59;
        }

        if (ResponseStatusCode != 407)
        {
          if (ResponseStatusCode == 200)
          {
            v60 = *((void *)handle + 21);
            if ((!v60 || *(_DWORD *)(v60 + 124) != 4) && (*((_WORD *)handle + 184) & 0x80) == 0)
            {
              BOOL v61 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_http_connect_process_response";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                v172 = " ";
                _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%shttp connect proxy connected",  buf,  0x20u);
              }
            }

            uint64_t v62 = mach_continuous_time();
            if (v62 <= 1) {
              int v63 = 1LL;
            }
            else {
              int v63 = v62;
            }
            *((void *)handle + 2) = v63;
            *((_DWORD *)handle + 70) = 2;
            _CFHTTPAuthenticationApplyProxyAuthorizationToRequest();
            uint64_t v64 = *((void *)handle + 9);
            if (v64)
            {
              os_log_type_t v65 = *(void *)(v64 + 24);
              if (v65)
              {
                uint32_t v66 = *(void (**)(uint64_t, void))(v65 + 40);
                if (v66)
                {
                  v66(v64, *((void *)handle + 7));
                  uint64_t v67 = *((void *)handle + 9);
                  if (!v67) {
                    goto LABEL_352;
                  }
LABEL_178:
                  id v68 = *(void *)(v67 + 24);
                  if (v68)
                  {
                    v69 = *(void (**)(uint64_t, char *))(v68 + 40);
                    if (v69)
                    {
                      v69(v67, handle + 24);
                      goto LABEL_296;
                    }
                  }

void nw_channel_set_close_automatically(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2) {
      __int16 v2 = 32;
    }
    else {
      __int16 v2 = 0;
    }
    int v3 = *(_WORD *)(a1 + 444) & 0xFFDF | (*(unsigned __int8 *)(a1 + 446) << 16);
    *(_WORD *)(a1 + 444) = *(_WORD *)(a1 + 444) & 0xFFDF | v2;
    *(_BYTE *)(a1 + 446) = BYTE2(v3);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v13 = "nw_channel_set_close_automatically";
  id v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      char v13 = "nw_channel_set_close_automatically";
      BOOL v7 = "%{public}s called with null channel";
      goto LABEL_20;
    }

    if (!v10)
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      char v13 = "nw_channel_set_close_automatically";
      BOOL v7 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        char v13 = "nw_channel_set_close_automatically";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      char v13 = "nw_channel_set_close_automatically";
      BOOL v7 = "%{public}s called with null channel, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

void nw_channel_set_defer_input_available(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2) {
      __int16 v2 = 128;
    }
    else {
      __int16 v2 = 0;
    }
    int v3 = *(_WORD *)(a1 + 444) & 0xFF7F | (*(unsigned __int8 *)(a1 + 446) << 16);
    *(_WORD *)(a1 + 444) = *(_WORD *)(a1 + 444) & 0xFF7F | v2;
    *(_BYTE *)(a1 + 446) = BYTE2(v3);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v13 = "nw_channel_set_defer_input_available";
  id v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      char v13 = "nw_channel_set_defer_input_available";
      BOOL v7 = "%{public}s called with null channel";
      goto LABEL_20;
    }

    if (!v10)
    {
      id v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      char v13 = "nw_channel_set_defer_input_available";
      BOOL v7 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        char v13 = "nw_channel_set_defer_input_available";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      char v13 = "nw_channel_set_defer_input_available";
      BOOL v7 = "%{public}s called with null channel, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

void nw_channel_set_protocol_level(uint64_t a1, int a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(_DWORD *)(a1 + 264) = a2;
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v11 = "nw_channel_set_protocol_level";
  __int16 v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v11 = "nw_channel_set_protocol_level";
      id v5 = "%{public}s called with null channel";
      goto LABEL_16;
    }

    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v11 = "nw_channel_set_protocol_level";
      id v5 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_16;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v3 = (os_log_s *)gLogObj;
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v11 = "nw_channel_set_protocol_level";
        __int16 v12 = 2082;
        char v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_17;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v11 = "nw_channel_set_protocol_level";
      id v5 = "%{public}s called with null channel, no backtrace";
LABEL_16:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

BOOL nw_parameters_has_protocol_in_stack(void *a1, void *a2)
{
  id v3 = a1;
  BOOL v4 = nw_parameters_has_protocol_at_level(v3, 5, a2)
    || nw_parameters_has_protocol_at_level(v3, 4, a2)
    || nw_parameters_has_protocol_at_level(v3, 3, a2)
    || nw_parameters_has_protocol_at_level(v3, 2, a2);

  return v4;
}

BOOL nw_parameters_has_protocol_at_level(void *a1, int a2, void *a3)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  os_log_type_t v6 = v5;
  if (v5)
  {
    if (a3)
    {
      BOOL v7 = v5[19];
      char v8 = v7;
      if (v7)
      {
        *(void *)uint64_t v48 = 0LL;
        *(void *)&v48[8] = v48;
        *(void *)&v48[16] = 0x2020000000LL;
        char v49 = 0;
        switch(a2)
        {
          case 2:
            BOOL v9 = (void *)v7[6];
            if (v9) {
              goto LABEL_11;
            }
            goto LABEL_15;
          case 3:
            BOOL v9 = (void *)v7[3];
            if (v9)
            {
LABEL_11:
              __int16 v12 = v9;
              id v13 = v12[1];

              identifier = nw_protocol_definition_get_identifier(v13);
              BOOL v15 = nw_protocols_are_equal(a3, identifier);
              *(_BYTE *)(*(void *)&v48[8] + 24LL) = v15;
            }

            goto LABEL_15;
          case 4:
            uint64_t v16 = (unsigned __int8 *)v7[2];
            uint64_t v41 = MEMORY[0x1895F87A8];
            int v17 = __nw_parameters_has_protocol_at_level_block_invoke_2;
            char v18 = &v41;
            goto LABEL_14;
          case 5:
            uint64_t v16 = (unsigned __int8 *)v7[1];
            uint64_t v42 = MEMORY[0x1895F87A8];
            int v17 = __nw_parameters_has_protocol_at_level_block_invoke;
            char v18 = &v42;
LABEL_14:
            v18[1] = 3221225472LL;
            v18[2] = (uint64_t)v17;
            v18[3] = (uint64_t)&unk_189BC93C8;
            v18[4] = (uint64_t)v48;
            v18[5] = (uint64_t)a3;
            nw_array_apply(v16, (uint64_t)v18);
LABEL_15:
            BOOL v11 = *(_BYTE *)(*(void *)&v48[8] + 24LL) != 0;
            break;
          default:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v10 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              BOOL v45 = "nw_parameters_has_protocol_at_level";
              __int16 v46 = 1024;
              int v47 = a2;
              _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s Unsupported protocol level %u",  buf,  0x12u);
            }

            BOOL v11 = 0LL;
            break;
        }

        _Block_object_dispose(v48, 8);
LABEL_17:

        goto LABEL_18;
      }

      __nwlog_obj();
      unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)uint64_t v48 = 136446210;
      *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
      os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      char v43 = 0;
      if (__nwlog_fault(v27, buf, &v43))
      {
        if (buf[0] == 17)
        {
          __nwlog_obj();
          id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v29 = buf[0];
          if (os_log_type_enabled(v28, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)uint64_t v48 = 136446210;
            *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
            _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null stack", v48, 0xCu);
          }
        }

        else if (v43)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v36 = buf[0];
          BOOL v37 = os_log_type_enabled(v28, (os_log_type_t)buf[0]);
          if (backtrace_string)
          {
            if (v37)
            {
              *(_DWORD *)uint64_t v48 = 136446466;
              *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
              *(_WORD *)&v48[12] = 2082;
              *(void *)&v48[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v28,  v36,  "%{public}s called with null stack, dumping backtrace:%{public}s",  v48,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_70;
          }

          if (v37)
          {
            *(_DWORD *)uint64_t v48 = 136446210;
            *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
            _os_log_impl(&dword_181A5C000, v28, v36, "%{public}s called with null stack, no backtrace", v48, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v40 = buf[0];
          if (os_log_type_enabled(v28, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)uint64_t v48 = 136446210;
            *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
            _os_log_impl( &dword_181A5C000,  v28,  v40,  "%{public}s called with null stack, backtrace limit exceeded",  v48,  0xCu);
          }
        }
      }

BOOL __nw_parameters_has_protocol_at_level_block_invoke_2(uint64_t a1, int a2, nw_protocol_options_t options)
{
  nw_protocol_definition_t v4 = nw_protocol_options_copy_definition(options);
  identifier = nw_protocol_definition_get_identifier(v4);
  BOOL v6 = nw_protocols_are_equal(*(void **)(a1 + 40), identifier);
  if (v6) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  BOOL v7 = !v6;

  return v7;
}

BOOL nw_protocols_are_equal(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2) {
      return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v18 = "nw_protocols_are_equal";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_protocols_are_equal";
        char v10 = "%{public}s called with null identifier2";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    if (!v15)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_protocols_are_equal";
        char v10 = "%{public}s called with null identifier2, backtrace limit exceeded";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_protocols_are_equal";
        char v10 = "%{public}s called with null identifier2, no backtrace";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      char v18 = "nw_protocols_are_equal";
      __int16 v19 = 2082;
      uint64_t v20 = backtrace_string;
      id v13 = "%{public}s called with null identifier2, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

    goto LABEL_36;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v18 = "nw_protocols_are_equal";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_protocols_are_equal";
        char v10 = "%{public}s called with null identifier1, backtrace limit exceeded";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_protocols_are_equal";
        char v10 = "%{public}s called with null identifier1, no backtrace";
        goto LABEL_45;
      }

      goto LABEL_46;
    }

    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      char v18 = "nw_protocols_are_equal";
      __int16 v19 = 2082;
      uint64_t v20 = backtrace_string;
      id v13 = "%{public}s called with null identifier1, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v8, v9, v13, buf, 0x16u);
    }

uint64_t nw_channel_get_stats_region(uint64_t a1, int a2)
{
  *(void *)&v22[13] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_channel_get_stats_region";
    nw_protocol_definition_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_channel_get_stats_region";
      BOOL v7 = "%{public}s called with null channel";
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v16 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v20 = "nw_channel_get_stats_region";
          __int16 v21 = 2082;
          *(void *)uint64_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (!v16) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_channel_get_stats_region";
      BOOL v7 = "%{public}s called with null channel, no backtrace";
    }

    else
    {
      id v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v20 = "nw_channel_get_stats_region";
      BOOL v7 = "%{public}s called with null channel, backtrace limit exceeded";
    }

    char v10 = v13;
    os_log_type_t v11 = v14;
    uint32_t v12 = 12;
LABEL_20:
    _os_log_impl(&dword_181A5C000, v10, v11, v7, buf, v12);
    goto LABEL_21;
  }

  if (!*(void *)(a1 + 136)) {
    return 0LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  uint64_t v20 = "nw_channel_get_stats_region";
  __int16 v21 = 1024;
  *(_DWORD *)uint64_t v22 = a2;
  nw_protocol_definition_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v4, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_channel_get_stats_region";
      __int16 v21 = 1024;
      *(_DWORD *)uint64_t v22 = a2;
      BOOL v7 = "%{public}s Unknown stats type %u";
    }

    else if (v17)
    {
      char v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v8)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v20 = "nw_channel_get_stats_region";
          __int16 v21 = 1024;
          *(_DWORD *)uint64_t v22 = a2;
          v22[2] = 2082;
          *(void *)&v22[3] = v8;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s Unknown stats type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v8);
        if (!v4) {
          return 0LL;
        }
        goto LABEL_22;
      }

      if (!v9) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_channel_get_stats_region";
      __int16 v21 = 1024;
      *(_DWORD *)uint64_t v22 = a2;
      BOOL v7 = "%{public}s Unknown stats type %u, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (os_log_s *)gLogObj;
      os_log_type_t v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v20 = "nw_channel_get_stats_region";
      __int16 v21 = 1024;
      *(_DWORD *)uint64_t v22 = a2;
      BOOL v7 = "%{public}s Unknown stats type %u, backtrace limit exceeded";
    }

    char v10 = v5;
    os_log_type_t v11 = v6;
    uint32_t v12 = 18;
    goto LABEL_20;
  }

void nw_path_flow_registration_set_stats_region(void *a1, int a2, __int128 *a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  BOOL v7 = a1;
  char v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_path_flow_registration_set_stats_region";
    char v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v31 = "nw_path_flow_registration_set_stats_region";
          __int16 v32 = 2082;
          os_log_type_t v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null flow_registration, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v10) {
          goto LABEL_11;
        }
LABEL_62:
        free(v10);
        goto LABEL_11;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null flow_registration, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null flow_registration, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181B42640(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__int128 *nw_protocol_get_quic_connection_protocol_identifier()
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  BOOL result = (__int128 *)nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier;
  if (nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier) {
    return result;
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
  }
  id v1 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (v1)
  {
    id v2 = v1;

    nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier = (uint64_t)v2 + 8;
    return (__int128 *)nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier;
  }

  __nwlog_obj();
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_protocol_get_quic_connection_protocol_identifier";
  nw_protocol_definition_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_get_quic_connection_protocol_identifier";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null quic_connection_definition", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_protocol_get_quic_connection_protocol_identifier";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null quic_connection_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_get_quic_connection_protocol_identifier";
        _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null quic_connection_definition, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_get_quic_connection_protocol_identifier";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null quic_connection_definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

int *nw_protocol_get_quic_stream_protocol_identifier()
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  BOOL result = (int *)nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier;
  if (nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier) {
    return result;
  }
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
  }
  id v1 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  if (v1)
  {
    id v2 = v1;

    nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier = (uint64_t)v2 + 8;
    return (int *)nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier;
  }

  __nwlog_obj();
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_protocol_get_quic_stream_protocol_identifier";
  nw_protocol_definition_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_get_quic_stream_protocol_identifier";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null quic_stream_definition", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v14 = "nw_protocol_get_quic_stream_protocol_identifier";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null quic_stream_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_get_quic_stream_protocol_identifier";
        _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null quic_stream_definition, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_protocol_get_quic_stream_protocol_identifier";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null quic_stream_definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_channel_get_protocol_handler(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return a1 + 24;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  char v11 = "nw_channel_get_protocol_handler";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "nw_channel_get_protocol_handler";
        id v5 = "%{public}s called with null channel";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          char v11 = "nw_channel_get_protocol_handler";
          __int16 v12 = 2082;
          id v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_17;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "nw_channel_get_protocol_handler";
        id v5 = "%{public}s called with null channel, no backtrace";
        goto LABEL_16;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)gLogObj;
      os_log_type_t v4 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "nw_channel_get_protocol_handler";
        id v5 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }

BOOL nw_channel_add_input_handler(nw_protocol *a1, nw_protocol *uu)
{
  *(void *)&v56[13] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v54 = "nw_channel_add_input_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_channel_add_input_handler";
        BOOL v9 = "%{public}s called with null channel_protocol";
        goto LABEL_71;
      }

      goto LABEL_72;
    }

    if (!v51)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_channel_add_input_handler";
        BOOL v9 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
        goto LABEL_71;
      }

      goto LABEL_72;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v49 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_channel_add_input_handler";
        BOOL v9 = "%{public}s called with null channel_protocol, no backtrace";
        goto LABEL_71;
      }

      goto LABEL_72;
    }

    if (!v49) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v54 = "nw_channel_add_input_handler";
    __int16 v55 = 2082;
    *(void *)int v56 = backtrace_string;
    id v13 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_18:
    _os_log_impl(&dword_181A5C000, v7, v8, v13, buf, 0x16u);
    goto LABEL_19;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v54 = "nw_channel_add_input_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_channel_add_input_handler";
        BOOL v9 = "%{public}s called with null channel";
        goto LABEL_71;
      }

      goto LABEL_72;
    }

    if (!v51)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_channel_add_input_handler";
        BOOL v9 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_71;
      }

      goto LABEL_72;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v50 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_channel_add_input_handler";
        BOOL v9 = "%{public}s called with null channel, no backtrace";
        goto LABEL_71;
      }

      goto LABEL_72;
    }

    if (!v50) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v54 = "nw_channel_add_input_handler";
    __int16 v55 = 2082;
    *(void *)int v56 = backtrace_string;
    id v13 = "%{public}s called with null channel, dumping backtrace:%{public}s";
    goto LABEL_18;
  }

  if (!uu)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v54 = "nw_channel_add_input_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v54 = "nw_channel_add_input_handler";
      BOOL v9 = "%{public}s called with null input_protocol";
      goto LABEL_71;
    }

    if (!v51)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v54 = "nw_channel_add_input_handler";
      BOOL v9 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_71;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v12) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v54 = "nw_channel_add_input_handler";
      BOOL v9 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_71;
    }

    if (!v12)
    {
LABEL_19:
      free(backtrace_string);
      goto LABEL_72;
    }

    *(_DWORD *)buf = 136446466;
    uint64_t v54 = "nw_channel_add_input_handler";
    __int16 v55 = 2082;
    *(void *)int v56 = backtrace_string;
    id v13 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_18;
  }

  if (!uuid_is_null(uu->flow_id))
  {
    *((_WORD *)handle + 222) |= 0x100u;
    uint64_t internal = *((void *)handle + 35);
LABEL_21:
    uint64_t internal = nw_hash_table_create_internal( 0x11u,  128,  (const void *(*)(const void *, unsigned int *))nw_protocol_get_key,  (unsigned int (*)(const void *, unsigned int))nw_protocol_key_hash,  (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_matches_key,  0LL);
    if (internal)
    {
      *(_DWORD *)(internal + 48) &= ~2u;
      *((void *)handle + 35) = internal;
      goto LABEL_23;
    }

    *((void *)handle + 35) = 0LL;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v54 = "nw_channel_add_input_handler";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (__nwlog_fault(v6, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v7 = (os_log_s *)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_72;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v54 = "nw_channel_add_input_handler";
        BOOL v9 = "%{public}s nw_protocol_hash_table_create failed";
        goto LABEL_71;
      }

      if (v51)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v44 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (!v44) {
            goto LABEL_19;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v54 = "nw_channel_add_input_handler";
          __int16 v55 = 2082;
          *(void *)int v56 = backtrace_string;
          id v13 = "%{public}s nw_protocol_hash_table_create failed, dumping backtrace:%{public}s";
          goto LABEL_18;
        }

        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v54 = "nw_channel_add_input_handler";
          BOOL v9 = "%{public}s nw_protocol_hash_table_create failed, no backtrace";
          goto LABEL_71;
        }
      }

      else
      {
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v54 = "nw_channel_add_input_handler";
          BOOL v9 = "%{public}s nw_protocol_hash_table_create failed, backtrace limit exceeded";
LABEL_71:
          _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
        }
      }
    }

void nw_protocol_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 8;
}

NWConcrete_nw_link_info *nw_link_info_create(int a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v2 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_link_info);
  id v3 = v2;
  if (v2)
  {
    v2->flow_control_status = a1;
    v2->link_quality = 0;
    os_log_type_t v4 = v2;
    goto LABEL_10;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_link_info_create";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)(id)gLogObj;
    os_log_type_t v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_link_info_create";
      _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s [nw_link_info init] failed", buf, 0xCu);
    }

BOOL nw_channel_set_path_flow_registration(uint64_t a1, void *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_channel_set_path_flow_registration";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        BOOL v21 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (!v21) {
            goto LABEL_18;
          }
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_channel_set_path_flow_registration";
          __int16 v27 = 2082;
          v28[0] = backtrace_string;
          uint64_t v19 = "%{public}s called with null channel, dumping backtrace:%{public}s";
          goto LABEL_17;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_channel_set_path_flow_registration";
          BOOL v9 = "%{public}s called with null channel, no backtrace";
          goto LABEL_25;
        }
      }

      else
      {
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_channel_set_path_flow_registration";
          BOOL v9 = "%{public}s called with null channel, backtrace limit exceeded";
          goto LABEL_25;
        }
      }

      goto LABEL_26;
    }

    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type[0];
    if (!os_log_type_enabled(v7, type[0])) {
      goto LABEL_26;
    }
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_channel_set_path_flow_registration";
    BOOL v9 = "%{public}s called with null channel";
LABEL_25:
    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_26;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_channel_set_path_flow_registration";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        BOOL v22 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (!v22) {
            goto LABEL_18;
          }
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_channel_set_path_flow_registration";
          __int16 v27 = 2082;
          v28[0] = backtrace_string;
          uint64_t v19 = "%{public}s called with null path, dumping backtrace:%{public}s";
          goto LABEL_17;
        }

        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_channel_set_path_flow_registration";
          BOOL v9 = "%{public}s called with null path, no backtrace";
          goto LABEL_25;
        }
      }

      else
      {
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_channel_set_path_flow_registration";
          BOOL v9 = "%{public}s called with null path, backtrace limit exceeded";
          goto LABEL_25;
        }
      }

      goto LABEL_26;
    }

    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type[0];
    if (!os_log_type_enabled(v7, type[0])) {
      goto LABEL_26;
    }
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_channel_set_path_flow_registration";
    BOOL v9 = "%{public}s called with null path";
    goto LABEL_25;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_channel_set_path_flow_registration";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v6, type, &v24))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_channel_set_path_flow_registration";
          BOOL v9 = "%{public}s called with null flow_registration";
          goto LABEL_25;
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        BOOL v23 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (!v23) {
            goto LABEL_18;
          }
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_channel_set_path_flow_registration";
          __int16 v27 = 2082;
          v28[0] = backtrace_string;
          uint64_t v19 = "%{public}s called with null flow_registration, dumping backtrace:%{public}s";
          goto LABEL_17;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_channel_set_path_flow_registration";
          BOOL v9 = "%{public}s called with null flow_registration, no backtrace";
          goto LABEL_25;
        }
      }

      else
      {
        BOOL v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          char v26 = "nw_channel_set_path_flow_registration";
          BOOL v9 = "%{public}s called with null flow_registration, backtrace limit exceeded";
          goto LABEL_25;
        }
      }
    }

void sub_181B44928(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

uint64_t nw_channel_get_advisory_region(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)BOOL v9 = 0LL;
    if (*(void *)(a1 + 144))
    {
      os_channel_attr_get();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v1 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v12 = "nw_channel_get_advisory_region";
        _os_log_impl( &dword_181A5C000,  v1,  OS_LOG_TYPE_DEFAULT,  "%{public}s advisory region not supported by this channel",  buf,  0xCu);
      }
    }

    return 0LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v12 = "nw_channel_get_advisory_region";
  id v3 = (char *)_os_log_send_and_compose_impl();
  v9[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (v9[0] == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = v9[0];
    if (!os_log_type_enabled(v4, v9[0])) {
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v12 = "nw_channel_get_advisory_region";
    os_log_type_t v6 = "%{public}s called with null channel";
    goto LABEL_22;
  }

  if (type == OS_LOG_TYPE_DEFAULT)
  {
    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = v9[0];
    if (!os_log_type_enabled(v4, v9[0])) {
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v12 = "nw_channel_get_advisory_region";
    os_log_type_t v6 = "%{public}s called with null channel, backtrace limit exceeded";
    goto LABEL_22;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  os_log_type_t v4 = (os_log_s *)__nwlog_obj();
  os_log_type_t v5 = v9[0];
  BOOL v8 = os_log_type_enabled(v4, v9[0]);
  if (!backtrace_string)
  {
    if (!v8) {
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v12 = "nw_channel_get_advisory_region";
    os_log_type_t v6 = "%{public}s called with null channel, no backtrace";
LABEL_22:
    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
LABEL_5:
    if (!v3) {
      return 0LL;
    }
LABEL_6:
    free(v3);
    return 0LL;
  }

  if (v8)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v12 = "nw_channel_get_advisory_region";
    __int16 v13 = 2082;
    char v14 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null channel, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v3) {
    goto LABEL_6;
  }
  return 0LL;
}

BOOL nw_endpoint_copy_proxy_original_endpoint(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v3 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_endpoint_copy_proxy_original_endpoint";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v21 = "nw_endpoint_copy_proxy_original_endpoint";
            __int16 v22 = 2082;
            BOOL v23 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B452A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_default_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_default_connect";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_connect";
      id v9 = "%{public}s called with null protocol";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v15 = "nw_protocol_default_connect";
          __int16 v16 = 2082;
          os_log_type_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v11)
      {
LABEL_20:
        if (v6) {
          free(v6);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_connect";
      id v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_connect";
      id v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_20;
  }

  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      connect = (uint64_t (*)(void))callbacks->connect;
      if (connect) {
        return connect();
      }
    }
  }

  return 0LL;
}

uint64_t nw_channel_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v89 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v82 = "nw_channel_connect";
    BOOL v49 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v50 = (os_log_s *)__nwlog_obj();
      os_log_type_t v51 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v82 = "nw_channel_connect";
        uint64_t v52 = "%{public}s called with null channel_protocol";
LABEL_162:
        _os_log_impl(&dword_181A5C000, v50, v51, v52, buf, 0xCu);
      }

LABEL_181:
      if (v58) {
        free(v58);
      }
      goto LABEL_33;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v82 = "__nw_protocol_input_available";
    id v4 = (nw_protocol *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v79 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v79))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v69 = (os_log_s *)__nwlog_obj();
        os_log_type_t v70 = type;
        if (!os_log_type_enabled(v69, type)) {
          goto LABEL_188;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v82 = "__nw_protocol_input_available";
        os_log_type_t v71 = "%{public}s called with null protocol";
        goto LABEL_187;
      }

      if (!v79)
      {
        v69 = (os_log_s *)__nwlog_obj();
        os_log_type_t v70 = type;
        if (!os_log_type_enabled(v69, type)) {
          goto LABEL_188;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v82 = "__nw_protocol_input_available";
        os_log_type_t v71 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_187;
      }

      BOOL v75 = (char *)__nw_create_backtrace_string();
      v69 = (os_log_s *)__nwlog_obj();
      os_log_type_t v70 = type;
      BOOL v76 = os_log_type_enabled(v69, type);
      if (v75)
      {
        if (v76)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v82 = "__nw_protocol_input_available";
          __int16 v83 = 2082;
          uint64_t v84 = v75;
          _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v75);
        if (!v4) {
          return 1LL;
        }
LABEL_98:
        free(v4);
        return 1LL;
      }

      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v82 = "__nw_protocol_input_available";
        os_log_type_t v71 = "%{public}s called with null protocol, no backtrace";
LABEL_187:
        _os_log_impl(&dword_181A5C000, v69, v70, v71, buf, 0xCu);
      }
    }

          if (v65) {
            free(v65);
          }
          if (*(_DWORD *)(*((void *)v9 + 1) + 64LL) != 3) {
            goto LABEL_189;
          }
          __nwlog_obj();
          v92 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
          v93 = (char *)_os_log_send_and_compose_impl();

          v170[0] = 16;
          LOBYTE(v163) = 0;
          if (__nwlog_fault(v93, v170, &v163))
          {
            if (v170[0] == 17)
            {
              __nwlog_obj();
              os_log_type_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v95 = v170[0];
              if (os_log_type_enabled(v94, (os_log_type_t)v170[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                _os_log_impl(&dword_181A5C000, v94, v95, "%{public}s called with null protocol", buf, 0xCu);
              }
            }

            else if ((_BYTE)v163)
            {
              int v131 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v132 = v170[0];
              uint64_t v133 = os_log_type_enabled(v94, (os_log_type_t)v170[0]);
              if (v131)
              {
                if (v133)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v131;
                  _os_log_impl( &dword_181A5C000,  v94,  v132,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v131);
                goto LABEL_300;
              }

              if (v133)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                _os_log_impl( &dword_181A5C000,  v94,  v132,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              os_log_type_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v145 = v170[0];
              if (os_log_type_enabled(v94, (os_log_type_t)v170[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                _os_log_impl( &dword_181A5C000,  v94,  v145,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

          if (v121) {
            free(v121);
          }
          goto LABEL_183;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v110 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v133 = nw_endpoint_handler_get_id_string(v5);
          v144 = nw_endpoint_handler_dry_run_string(v5);
          v147 = nw_endpoint_handler_copy_endpoint(v5);
          v134 = nw_endpoint_get_logging_description(v147);
          __int16 v135 = nw_endpoint_handler_state_string(v5);
          v136 = nw_endpoint_handler_mode_string(v5);
          __int16 v137 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136448002;
          v166 = "nw_endpoint_proxy_start_next_child";
          v167 = 2082;
          v168 = (void *)v133;
          v169 = 2082;
          v170 = v144;
          v171 = 2082;
          v172 = v134;
          v173 = 2082;
          v174 = v135;
          v175 = 2082;
          v176 = v136;
          v177 = 2114;
          v178 = v137;
          v179 = 2048;
          v180 = delta / 0xF4240;
          _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums",  buf,  0x52u);
        }
      }

      else
      {
        if ((v109 & 1) != 0) {
          goto LABEL_144;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v110 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_INFO))
        {
          v146 = nw_endpoint_handler_get_id_string(v5);
          v143 = nw_endpoint_handler_dry_run_string(v5);
          uint64_t v111 = nw_endpoint_handler_copy_endpoint(v5);
          uint64_t v112 = nw_endpoint_get_logging_description(v111);
          uint64_t v113 = nw_endpoint_handler_state_string(v5);
          uint64_t v114 = nw_endpoint_handler_mode_string(v5);
          v115 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136448002;
          v166 = "nw_endpoint_proxy_start_next_child";
          v167 = 2082;
          v168 = (void *)v146;
          v169 = 2082;
          v170 = v143;
          v171 = 2082;
          v172 = v112;
          v173 = 2082;
          v174 = v113;
          v175 = 2082;
          v176 = v114;
          v177 = 2114;
          v178 = v115;
          v179 = 2048;
          v180 = delta / 0xF4240;
          _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums",  buf,  0x52u);
        }
      }

      goto LABEL_144;
    }

    __nwlog_obj();
    v88 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v166 = "nw_endpoint_proxy_start_next_child";
    uint64_t v89 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v163 = 0;
    if (__nwlog_fault(v89, &type, &v163))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v91 = type;
        if (os_log_type_enabled(v90, type))
        {
          *(_DWORD *)buf = 136446210;
          v166 = "nw_endpoint_proxy_start_next_child";
          _os_log_impl(&dword_181A5C000, v90, v91, "%{public}s called with null endpoint_proxy", buf, 0xCu);
        }
      }

      else if (v163)
      {
        __int16 v124 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v125 = type;
        __int16 v126 = os_log_type_enabled(v90, type);
        if (v124)
        {
          if (v126)
          {
            *(_DWORD *)buf = 136446466;
            v166 = "nw_endpoint_proxy_start_next_child";
            v167 = 2082;
            v168 = v124;
            _os_log_impl( &dword_181A5C000,  v90,  v125,  "%{public}s called with null endpoint_proxy, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v124);
          goto LABEL_176;
        }

        if (v126)
        {
          *(_DWORD *)buf = 136446210;
          v166 = "nw_endpoint_proxy_start_next_child";
          _os_log_impl( &dword_181A5C000,  v90,  v125,  "%{public}s called with null endpoint_proxy, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v131 = type;
        if (os_log_type_enabled(v90, type))
        {
          *(_DWORD *)buf = 136446210;
          v166 = "nw_endpoint_proxy_start_next_child";
          _os_log_impl( &dword_181A5C000,  v90,  v131,  "%{public}s called with null endpoint_proxy, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v59) {
      free(v59);
    }
    char v12 = 0LL;
    goto LABEL_85;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "operator()";
  os_log_type_t v51 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v106[0] = OS_LOG_TYPE_DEFAULT;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (v106[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v52 = (os_log_s *)__nwlog_obj();
      int v53 = type[0];
      if (os_log_type_enabled(v52, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v54 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_161;
      }

      goto LABEL_162;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v52 = (os_log_s *)__nwlog_obj();
    int v53 = type[0];
    int v63 = os_log_type_enabled(v52, type[0]);
    if (!backtrace_string)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        uint64_t v54 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_161;
      }

      goto LABEL_162;
    }

    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v57 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_117;
    }

          if (v83) {
            goto LABEL_164;
          }
          goto LABEL_165;
        }

        if (!v148)
        {
          v107 = (os_log_s *)__nwlog_obj();
          v108 = v149;
          if (!os_log_type_enabled(v107, v149)) {
            goto LABEL_181;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
          BOOL v100 = v107;
          os_log_type_t v101 = v108;
          BOOL v102 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
LABEL_180:
          _os_log_impl(&dword_181A5C000, v100, v101, v102, buf, 0xCu);
          goto LABEL_181;
        }

        os_log_type_t v103 = (char *)__nw_create_backtrace_string();
        os_log_type_t v104 = (os_log_s *)__nwlog_obj();
        uint64_t v105 = v149;
        uint64_t v106 = os_log_type_enabled(v104, v149);
        if (!v103)
        {
          handle = v136;
          if (!v106) {
            goto LABEL_181;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
          BOOL v100 = v104;
          os_log_type_t v101 = v105;
          BOOL v102 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_180;
        }

        if (v106)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
          v151 = 2082;
          v152 = v103;
          _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v103);
        handle = v136;
        if (v83) {
          goto LABEL_164;
        }
LABEL_165:
        v145[3] = v65;
      }
    }

    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        uint64_t v120 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v121 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = handle + 464;
          v153 = 2080;
          v154 = (uint64_t)" ";
          v155 = 1024;
          *(_DWORD *)v156 = v121;
          *(_WORD *)&v156[4] = 2048;
          *(void *)&v156[6] = v5;
          _os_log_impl( &dword_181A5C000,  v120,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream (%p)",  buf,  0x30u);
        }
      }
    }

    if ((v5[276] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
      v151 = 2048;
      v152 = v5;
      os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v137[0]) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_57;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
        v151 = 2048;
        v152 = v5;
        __int16 v16 = "%{public}s stream %p not in pending list, cannot remove";
      }

      else if (LOBYTE(v137[0]))
      {
        uint64_t v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type[0];
        uint64_t v20 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v19)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            v151 = 2048;
            v152 = v5;
            v153 = 2082;
            v154 = (uint64_t)v19;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v19);
          goto LABEL_57;
        }

        if (!v20)
        {
LABEL_57:
          if (v13) {
            free(v13);
          }
          goto LABEL_69;
        }

        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
        v151 = 2048;
        v152 = v5;
        __int16 v16 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_57;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
        v151 = 2048;
        v152 = v5;
        __int16 v16 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
      }

      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0x16u);
      goto LABEL_57;
    }

    os_log_type_t v17 = *((void *)v5 + 14);
    uint64_t v18 = (void *)*((void *)v5 + 15);
    if (v17)
    {
      *(void *)(v17 + 120) = v18;
      uint64_t v18 = (void *)*((void *)v5 + 15);
    }

    else
    {
      *((void *)handle + 42) = v18;
    }

    *uint64_t v18 = v17;
    *((void *)v5 + 14) = 0LL;
    *((void *)v5 + 15) = 0LL;
    BOOL v21 = *((_DWORD *)handle + 114);
    *((_DWORD *)handle + 114) = v21 - 1;
    if (v21)
    {
LABEL_67:
      uint64_t v37 = v5[276];
      v5[276] = v37 & 0xDF;
      if ((v37 & 0x10) != 0) {
        goto LABEL_69;
      }
      if (!gLogDatapath) {
        goto LABEL_69;
      }
      uint64_t v122 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_69;
      }
      v123 = *((void *)v5 + 11);
      if (v123) {
        __int16 v124 = *(_DWORD *)(v123 + 460);
      }
      else {
        __int16 v124 = -1;
      }
      uint64_t v129 = *((void *)v5 + 8);
      __int16 v130 = *((_DWORD *)handle + 114);
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
      v151 = 2082;
      v152 = v5 + 192;
      v153 = 2080;
      v154 = (uint64_t)" ";
      v155 = 1024;
      *(_DWORD *)v156 = v124;
      *(_WORD *)&v156[4] = 2048;
      *(void *)&v156[6] = v129;
      *(_WORD *)&v156[14] = 2048;
      *(void *)&v156[16] = v5;
      v157 = 1024;
      LODWORD(v15_Block_object_dispose(va, 8) = v130;
      char v12 = "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams";
      os_log_type_t v29 = v122;
      uint64_t v30 = OS_LOG_TYPE_DEBUG;
      os_log_type_t v31 = 64;
      goto LABEL_46;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v22 = *((unsigned int *)handle + 114);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
    v151 = 2082;
    v152 = "webtransport_session->pending_stream_count";
    v153 = 2048;
    v154 = 1LL;
    v155 = 2048;
    *(void *)v156 = v22;
    BOOL v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (__nwlog_fault(v23, type, v137))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (os_log_s *)gLogObj;
        os_log_type_t v25 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          char v26 = *((unsigned int *)handle + 114);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = "webtransport_session->pending_stream_count";
          v153 = 2048;
          v154 = 1LL;
          v155 = 2048;
          *(void *)v156 = v26;
          __int16 v27 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_63:
          _os_log_impl(&dword_181A5C000, v24, v25, v27, buf, 0x2Au);
        }
      }

      else if (LOBYTE(v137[0]))
      {
        __int16 v32 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (os_log_s *)gLogObj;
        os_log_type_t v25 = type[0];
        os_log_type_t v33 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v32)
        {
          if (v33)
          {
            uint64_t v34 = *((unsigned int *)handle + 114);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
            v151 = 2082;
            v152 = "webtransport_session->pending_stream_count";
            v153 = 2048;
            v154 = 1LL;
            v155 = 2048;
            *(void *)v156 = v34;
            *(_WORD *)&v156[8] = 2082;
            *(void *)&v156[10] = v32;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v32);
          goto LABEL_64;
        }

        if (v33)
        {
          os_log_type_t v36 = *((unsigned int *)handle + 114);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = "webtransport_session->pending_stream_count";
          v153 = 2048;
          v154 = 1LL;
          v155 = 2048;
          *(void *)v156 = v36;
          __int16 v27 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_63;
        }
      }

      else
      {
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          BOOL v35 = *((unsigned int *)handle + 114);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = "webtransport_session->pending_stream_count";
          v153 = 2048;
          v154 = 1LL;
          v155 = 2048;
          *(void *)v156 = v35;
          __int16 v27 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
    }

                  if (v100)
                  {
                    free(v100);
                    v115 = 1;
                    goto LABEL_328;
                  }

                  goto LABEL_254;
                }

                nw_http_connection_metadata_closed(*(void **)(v16 + 768));
                os_log_type_t v15 = &qword_18C45F000;
                if ((*(_BYTE *)(v16 + 158) & 1) == 0)
                {
                  if (!gLogDatapath) {
                    goto LABEL_129;
                  }
                  v594 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v594, OS_LOG_TYPE_DEBUG))
                  {
                    v595 = *(void *)(v16 + 488);
                    v596 = *(_DWORD *)(*(void *)(v16 + 480) + 372LL);
                    v597 = *(_DWORD *)(v16 + 860);
                    if (v595) {
                      LODWORD(v595) = *(_DWORD *)(v595 + 424);
                    }
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = "nw_http1_tear_down_connection";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v16 + 74;
                    *(_WORD *)&buf[22] = 2080;
                    v1051 = (uint64_t)" ";
                    *(_WORD *)v1052 = 1024;
                    *(_DWORD *)&v1052[2] = v596;
                    *(_WORD *)&v1052[6] = 1024;
                    *(_DWORD *)&v1052[8] = v597;
                    *(_WORD *)&v1052[12] = 1024;
                    *(_DWORD *)&v1052[14] = v595;
                    _os_log_impl( &dword_181A5C000,  v594,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> finalizing unprocessed_input_frames",  buf,  0x32u);
                    BOOL v11 = v1042;
                  }
                }

                if (gLogDatapath)
                {
                  v598 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v598, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)v1065 = 136446210;
                    *(void *)&v1065[4] = "nw_protocol_finalize_temp_frame_array";
                    _os_log_impl(&dword_181A5C000, v598, OS_LOG_TYPE_DEBUG, "%{public}s called", v1065, 0xCu);
                  }
                }

        int v56 = 0LL;
LABEL_182:
        os_log_type_t v8 = v107;
        goto LABEL_183;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        os_log_type_t v60 = (os_log_s *)(id)gbrowserLogObj;
        BOOL v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          uint64_t v62 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v62;
          _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s [B%u] tried to remove non-existent interface",  buf,  0x12u);
        }

        goto LABEL_177;
      }

      if (!v108)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        os_log_type_t v60 = (os_log_s *)(id)gbrowserLogObj;
        __int16 v85 = type;
        if (os_log_type_enabled(v60, type))
        {
          nw_endpoint_t v86 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v86;
          _os_log_impl( &dword_181A5C000,  v60,  v85,  "%{public}s [B%u] tried to remove non-existent interface, backtrace limit exceeded",  buf,  0x12u);
        }

        goto LABEL_177;
      }

      os_log_type_t v65 = __nw_create_backtrace_string();
      if (!v65)
      {
        if (__nwlog_browser_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
        }
        os_log_type_t v60 = (os_log_s *)(id)gbrowserLogObj;
        id v90 = type;
        if (os_log_type_enabled(v60, type))
        {
          BOOL v91 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v91;
          _os_log_impl( &dword_181A5C000,  v60,  v90,  "%{public}s [B%u] tried to remove non-existent interface, no backtrace",  buf,  0x12u);
        }

        goto LABEL_177;
      }

      BOOL v66 = (char *)v65;
      if (__nwlog_browser_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
      }
      uint64_t v67 = (os_log_s *)(id)gbrowserLogObj;
      BOOL v68 = type;
      if (os_log_type_enabled(v67, type))
      {
        v69 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v69;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v66;
        _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s [B%u] tried to remove non-existent interface, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      goto LABEL_161;
    }

LABEL_188:
    if (!v4) {
      return 1LL;
    }
    goto LABEL_98;
  }

  return result;
}

        else {
          buf = v81;
        }
LABEL_191:
        *a1 = buf;
        buf.__r_.__value_.__s.__size_ = 0;
        buf.__r_.__value_.__s.__data_[0] = 0;
        goto LABEL_16;
      case 1:
        id v9 = *(__int16 **)(a2 + 520);
        os_log_type_t v10 = *(unsigned __int16 **)(a2 + 528);
        if (v9 != (__int16 *)v10)
        {
          memset(&__dst, 0, sizeof(__dst));
          BOOL v11 = (char *)v10 - (char *)v9;
          if (v11 >= 0x200) {
            BOOL v11 = 512LL;
          }
          if (v11 < 3) {
            goto LABEL_46;
          }
          if (*v9 != -2 && *v9 != -257)
          {
            char v12 = (unsigned __int16)*v9;
            os_log_type_t v13 = *((unsigned __int8 *)v9 + 2);
            if (v12 != 48111 || v13 != 191) {
              goto LABEL_46;
            }
          }

          std::string::__assign_external(&__dst, (const std::string::value_type *)kNWMIMETypeTextPlain);
          os_log_type_t v15 = __dst.__r_.__value_.__s.__size_;
          if ((__dst.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            os_log_type_t v15 = __dst.__r_.__value_.__l.__size_;
          }
          if (!v15)
          {
LABEL_46:
            __int16 v16 = *(void *)(a2 + 520);
            os_log_type_t v17 = *(void *)(a2 + 528);
            if (v16 == v17) {
              goto LABEL_67;
            }
            uint64_t v18 = v17 - v16;
            if (v18 >= 0x200) {
              uint64_t v18 = 512LL;
            }
            if (!v18) {
              goto LABEL_67;
            }
            uint64_t v19 = v18 + v16 - 1;
            uint64_t v20 = v16 + 1;
            do
            {
              BOOL v21 = *(unsigned __int8 *)(v20 - 1);
              BOOL v23 = v21 >= 9 && v21 != 11 && v21 - 14 >= 0xD;
              uint64_t v24 = v21 & 0xFC;
              os_log_type_t v25 = !v23 || v24 == 28;
              char v26 = v25;
              if (v25) {
                break;
              }
            }

            while (v20++ <= v19);
            if ((v26 & 1) == 0) {
LABEL_67:
            }
              std::string::__assign_external(&__dst, (const std::string::value_type *)kNWMIMETypeTextPlain);
          }

          cap_high = __dst.__r_.__value_.__s.__size_;
          LOBYTE(v29) = __dst.__r_.__value_.__s.__size_;
          uint64_t v30 = __dst.__r_.__value_.__l.__size_;
          if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            os_log_type_t v31 = __dst.__r_.__value_.__s.__size_;
          }
          else {
            os_log_type_t v31 = __dst.__r_.__value_.__l.__size_;
          }
          if (!v31)
          {
            {
              sNonScriptableTypeRules(void)::rules = 0LL;
              *(void *)algn_18C5A2AE8 = "%!PS-Adobe-";
              qword_18C5A2AF0 = 11LL;
              unk_18C5A2AF8 = "application/postscript";
              qword_18C5A2B00 = (uint64_t)&unk_182667116;
              unk_18C5A2B08 = &unk_18266711B;
              qword_18C5A2B10 = 4LL;
              unk_18C5A2B18 = kNWMIMETypeTextPlain;
              qword_18C5A2B20 = (uint64_t)&unk_182667116;
              unk_18C5A2B28 = &unk_182667120;
              qword_18C5A2B30 = 4LL;
              unk_18C5A2B38 = kNWMIMETypeTextPlain;
              qword_18C5A2B40 = (uint64_t)&unk_182667125;
              unk_18C5A2B48 = &unk_18266712A;
              qword_18C5A2B50 = 4LL;
              unk_18C5A2B58 = kNWMIMETypeTextPlain;
              qword_18C5A2B60 = 0LL;
              unk_18C5A2B68 = &unk_182665FC8;
              qword_18C5A2B70 = 7LL;
              unk_18C5A2B78 = "application/x-rar-compressed";
              qword_18C5A2B80 = 0LL;
              unk_18C5A2B88 = "PK\x03\x04";
              qword_18C5A2B90 = 4LL;
              unk_18C5A2B98 = "application/zip";
              qword_18C5A2BA0 = 0LL;
              unk_18C5A2BA8 = "\x1F\x8B\b";
              qword_18C5A2BB0 = 3LL;
              unk_18C5A2BB8 = "application/x-gzip";
              qword_18C5A2BC0 = 0LL;
              unk_18C5A2BC8 = 0LL;
              qword_18C5A2BD0 = 0LL;
              unk_18C5A2BD8 = "";
            }

            nw_http_sniffing_get_mime_type_for_rule_array( &buf,  *(void *)(a2 + 520),  *(void *)(a2 + 528),  &sNonScriptableTypeRules(void)::rules,  0);
            __dst = buf;
            cap_high = HIBYTE(buf.__r_.__value_.__l.__cap_);
            uint64_t v30 = buf.__r_.__value_.__l.__size_;
            os_log_type_t v29 = HIBYTE(buf.__r_.__value_.__l.__cap_);
          }

          if ((v29 & 0x80u) == 0LL) {
            os_log_type_t v33 = cap_high;
          }
          else {
            os_log_type_t v33 = v30;
          }
          if (!v33)
          {
            {
              sImageTypeRules(void)::rules = 0LL;
              unk_18C5A2BF0 = "GIF87a";
              qword_18C5A2BF8 = 6LL;
              unk_18C5A2C00 = kNWMIMETypeImageGIF;
              qword_18C5A2C08 = 0LL;
              unk_18C5A2C10 = "GIF89a";
              qword_18C5A2C18 = 6LL;
              unk_18C5A2C20 = kNWMIMETypeImageGIF;
              qword_18C5A2C28 = 0LL;
              unk_18C5A2C30 = "\x89PNG\r\n\x1A\n";
              qword_18C5A2C38 = 8LL;
              unk_18C5A2C40 = kNWMIMETypeImagePNG;
              qword_18C5A2C48 = 0LL;
              unk_18C5A2C50 = "\xFF\xD8\xFF";
              qword_18C5A2C58 = 3LL;
              unk_18C5A2C60 = kNWMIMETypeImageJPEG;
              qword_18C5A2C68 = 0LL;
              unk_18C5A2C70 = "BM";
              qword_18C5A2C78 = 2LL;
              unk_18C5A2C80 = kNWMIMETypeImageBMP;
              qword_18C5A2C88 = 0LL;
              unk_18C5A2C90 = &unk_18266712F;
              qword_18C5A2C98 = 4LL;
              unk_18C5A2CA0 = kNWMIMETypeImageICO;
              qword_18C5A2CA8 = 0LL;
              unk_18C5A2CB0 = 0LL;
              qword_18C5A2CB8 = 0LL;
              unk_18C5A2CC0 = "";
            }

            nw_http_sniffing_get_mime_type_for_rule_array( &buf,  *(void *)(a2 + 520),  *(void *)(a2 + 528),  &sImageTypeRules(void)::rules,  0);
            __dst = buf;
            cap_high = HIBYTE(buf.__r_.__value_.__l.__cap_);
            uint64_t v30 = buf.__r_.__value_.__l.__size_;
            os_log_type_t v29 = HIBYTE(buf.__r_.__value_.__l.__cap_);
          }

          if ((v29 & 0x80u) == 0LL) {
            BOOL v35 = cap_high;
          }
          else {
            BOOL v35 = v30;
          }
          if (!v35)
          {
            nw_http_sniffing_get_mime_type_for_complex_nonscriptable_type_rules((uint64_t)&buf, a2);
            __dst = buf;
            cap_high = HIBYTE(buf.__r_.__value_.__l.__cap_);
            uint64_t v30 = buf.__r_.__value_.__l.__size_;
            os_log_type_t v29 = HIBYTE(buf.__r_.__value_.__l.__cap_);
          }

          if ((v29 & 0x80u) != 0LL) {
            cap_high = v30;
          }
          if (!cap_high) {
            std::string::__assign_external(&__dst, "application/octet-stream", 0x18uLL);
          }
LABEL_207:
          *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          cap = __dst.__r_.__value_.__l.__cap_;
          goto LABEL_15;
        }

        uint64_t v48 = (const void *)kNWMIMETypeTextPlain;
        BOOL v49 = strlen((const char *)kNWMIMETypeTextPlain);
        if (v49 >= 0x7FFFFFFFFFFFFFF8LL) {
          abort();
        }
        BOOL v50 = v49;
        if (v49 >= 0x17)
        {
          os_log_type_t v70 = (v49 & 0xFFFFFFFFFFFFFFF8LL) + 8;
          if ((v49 | 7) != 0x17) {
            os_log_type_t v70 = v49 | 7;
          }
          os_log_type_t v71 = v70 + 1;
          p_dst = operator new(v70 + 1);
          __dst.__r_.__value_.__l.__size_ = v50;
          __dst.__r_.__value_.__l.__cap_ = v71 | 0x8000000000000000LL;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }

        else
        {
          __dst.__r_.__value_.__s.__size_ = v49;
          p_dst = &__dst;
          if (!v49) {
            goto LABEL_206;
          }
        }

        memmove(p_dst, v48, v50);
LABEL_206:
        *((_BYTE *)p_dst + v50) = 0;
        goto LABEL_207;
      case 2:
        {
          sImageTypeRules(void)::rules = 0LL;
          unk_18C5A2BF0 = "GIF87a";
          qword_18C5A2BF8 = 6LL;
          unk_18C5A2C00 = kNWMIMETypeImageGIF;
          qword_18C5A2C08 = 0LL;
          unk_18C5A2C10 = "GIF89a";
          qword_18C5A2C18 = 6LL;
          unk_18C5A2C20 = kNWMIMETypeImageGIF;
          qword_18C5A2C28 = 0LL;
          unk_18C5A2C30 = "\x89PNG\r\n\x1A\n";
          qword_18C5A2C38 = 8LL;
          unk_18C5A2C40 = kNWMIMETypeImagePNG;
          qword_18C5A2C48 = 0LL;
          unk_18C5A2C50 = "\xFF\xD8\xFF";
          qword_18C5A2C58 = 3LL;
          unk_18C5A2C60 = kNWMIMETypeImageJPEG;
          qword_18C5A2C68 = 0LL;
          unk_18C5A2C70 = "BM";
          qword_18C5A2C78 = 2LL;
          unk_18C5A2C80 = kNWMIMETypeImageBMP;
          qword_18C5A2C88 = 0LL;
          unk_18C5A2C90 = &unk_18266712F;
          qword_18C5A2C98 = 4LL;
          unk_18C5A2CA0 = kNWMIMETypeImageICO;
          qword_18C5A2CA8 = 0LL;
          unk_18C5A2CB0 = 0LL;
          qword_18C5A2CB8 = 0LL;
          unk_18C5A2CC0 = "";
        }

        nw_http_sniffing_get_mime_type_for_rule_array( &buf,  *(void *)(a2 + 520),  *(void *)(a2 + 528),  &sImageTypeRules(void)::rules,  0);
        uint64_t v37 = buf.__r_.__value_.__s.__size_;
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v37 = buf.__r_.__value_.__l.__size_;
        }
        if (v4 != &buf && !v37)
        {
          uint64_t v38 = *(_BYTE *)(a2 + 519);
          if ((char)buf.__r_.__value_.__s.__size_ < 0)
          {
            if (v38 >= 0) {
              BOOL v68 = (void *)(a2 + 496);
            }
            else {
              BOOL v68 = *(void **)(a2 + 496);
            }
            if (v38 >= 0) {
              v69 = *(unsigned __int8 *)(a2 + 519);
            }
            else {
              v69 = *(void *)(a2 + 504);
            }
            std::string::__assign_no_alias<false>((void **)&buf.__r_.__value_.__l.__data_, v68, v69);
          }

          else if ((*(_BYTE *)(a2 + 519) & 0x80) != 0)
          {
            std::string::__assign_no_alias<true>(&buf, *(void **)(a2 + 496), *(void *)(a2 + 504));
          }

          else
          {
            *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
            buf.__r_.__value_.__l.__cap_ = *(void *)(a2 + 512);
          }
        }

        goto LABEL_12;
      case 3:
        goto LABEL_11;
      default:
        goto LABEL_16;
    }
  }

  __nwlog_obj();
  LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
  uint64_t v72 = (char *)_os_log_send_and_compose_impl();
  __dst.__r_.__value_.__s.__data_[0] = 16;
  os_log_type_t v82 = 0;
  if (__nwlog_fault(v72, &__dst, &v82))
  {
    if (__dst.__r_.__value_.__s.__data_[0] == 17)
    {
      BOOL v73 = (os_log_s *)__nwlog_obj();
      v74 = __dst.__r_.__value_.__s.__data_[0];
      if (os_log_type_enabled(v73, (os_log_type_t)__dst.__r_.__value_.__s.__data_[0]))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
        BOOL v75 = "%{public}s called with null http_sniffing";
LABEL_239:
        _os_log_impl(&dword_181A5C000, v73, v74, v75, (uint8_t *)&buf, 0xCu);
      }
    }

    else if (v82)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v73 = (os_log_s *)__nwlog_obj();
      v74 = __dst.__r_.__value_.__s.__data_[0];
      uint64_t v77 = os_log_type_enabled(v73, (os_log_type_t)__dst.__r_.__value_.__s.__data_[0]);
      if (backtrace_string)
      {
        if (v77)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s called with null http_sniffing, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_240;
      }

      if (v77)
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
        BOOL v75 = "%{public}s called with null http_sniffing, no backtrace";
        goto LABEL_239;
      }
    }

    else
    {
      BOOL v73 = (os_log_s *)__nwlog_obj();
      v74 = __dst.__r_.__value_.__s.__data_[0];
      if (os_log_type_enabled(v73, (os_log_type_t)__dst.__r_.__value_.__s.__data_[0]))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
        BOOL v75 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
        goto LABEL_239;
      }
    }
  }

      if (!v57) {
        goto LABEL_137;
      }
LABEL_189:
      free(v57);
      goto LABEL_137;
    }

    __nwlog_obj();
    os_log_type_t v55 = (void *)objc_claimAutoreleasedReturnValue();
    int v56 = networkd_privileged_result_to_string(v36);
    *(_DWORD *)buf = 136446722;
    uint64_t v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    __int16 v85 = 2048;
    *(void *)nw_endpoint_t v86 = v36;
    *(_WORD *)&v86[8] = 2082;
    *(void *)&v86[10] = v56;
    uint64_t v57 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v81 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v59 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        __int16 v85 = 2048;
        *(void *)nw_endpoint_t v86 = v36;
        *(_WORD *)&v86[8] = 2082;
        *(void *)&v86[10] = v56;
        _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s received internal failure result code: [%lld] %{public}s",  buf,  0x20u);
      }
    }

    else if (v81)
    {
      uint64_t v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v68 = type;
      v69 = os_log_type_enabled(v58, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          uint64_t v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          __int16 v85 = 2048;
          *(void *)nw_endpoint_t v86 = v36;
          *(_WORD *)&v86[8] = 2082;
          *(void *)&v86[10] = v56;
          __int16 v87 = 2082;
          v88 = (uint64_t)v67;
          _os_log_impl( &dword_181A5C000,  v58,  v68,  "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v67);
        goto LABEL_188;
      }

      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        __int16 v85 = 2048;
        *(void *)nw_endpoint_t v86 = v36;
        *(_WORD *)&v86[8] = 2082;
        *(void *)&v86[10] = v56;
        _os_log_impl( &dword_181A5C000,  v58,  v68,  "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v79 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        __int16 v85 = 2048;
        *(void *)nw_endpoint_t v86 = v36;
        *(_WORD *)&v86[8] = 2082;
        *(void *)&v86[10] = v56;
        _os_log_impl( &dword_181A5C000,  v58,  v79,  "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }

    goto LABEL_188;
  }

  if (*(_BYTE *)(a1 + 48)) {
    uint64 = xpc_dictionary_get_uint64(v4, (const char *)networkd_privileged_key_opportunistic_inuse);
  }
  else {
    uint64 = 0LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v70 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
  {
    os_log_type_t v71 = *(unsigned __int8 *)(a1 + 48);
    string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 32));
    BOOL v73 = "";
    *(_DWORD *)buf = 136446978;
    uint64_t v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    __int16 v85 = 2082;
    if (!v71) {
      BOOL v73 = "un";
    }
    *(void *)nw_endpoint_t v86 = v73;
    *(_WORD *)&v86[8] = 2082;
    *(void *)&v86[10] = string_ptr;
    __int16 v87 = 2048;
    v88 = uint64;
    _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully %{public}sblocked opportunistic traffic on %{public}s count=%llu",  buf,  0x2Au);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
LABEL_138:
}

              os_log_type_t v94 = *(dispatch_object_s **)(v17 + 208);
              if (v94)
              {
                dispatch_release(v94);
                *(void *)(v17 + 20_Block_object_dispose(va, 8) = 0LL;
              }

              *(_DWORD *)(v17 + 224) = 4;
              *(void *)(v17 + 176) = 0LL;
              os_log_type_t v95 = *(_BYTE *)(v17 + 228);
              *(_BYTE *)(v17 + 22_Block_object_dispose(va, 8) = v95 | 0x20;
              if (v267) {
                *(_BYTE *)(v17 + 22_Block_object_dispose(va, 8) = v95 | 0x24;
              }
LABEL_270:
              if (v60) {
                free(v60);
              }
              goto LABEL_272;
            }

            __int16 v126 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v126, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "strict_malloc";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v61;
            __int128 v127 = (void *)_os_log_send_and_compose_impl();
            free(v127);
            nw_dispatch_data_copyout(*(dispatch_data_s **)(v17 + 208), 0LL, v61);
            os_log_type_t v60 = 0LL;
            BOOL v21 = v264;
            if (*(void *)(v17 + 216)) {
              goto LABEL_188;
            }
          }

          else
          {
            os_log_type_t v60 = 0LL;
            BOOL v21 = v264;
            if (*(void *)(v17 + 216)) {
              goto LABEL_188;
            }
          }

      if (!v61)
      {
LABEL_190:
        os_log_type_t v29 = 0LL;
        goto LABEL_26;
      }

      free(backtrace_string);
      goto LABEL_218;
    }

    if (!v71) {
      goto LABEL_218;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    int v63 = "%{public}s called with null out_remaining_length, no backtrace";
LABEL_217:
    _os_log_impl(&dword_181A5C000, v61, v62, v63, buf, 0xCu);
LABEL_218:
    if (v60) {
      free(v60);
    }
    return 0LL;
  }

  *a4 = 0LL;
  *a5 = 0;
  *a6 = 0LL;
  *a7 = a2;
  if (!a3) {
    goto LABEL_110;
  }
  BOOL v7 = *(unsigned __int8 *)a1;
  if (v7 > 0x3F)
  {
    char v14 = v7 >> 6;
    if (v14 == 2)
    {
      if (a2 < 4) {
        return 0LL;
      }
      BOOL v7 = bswap32(*a1 & 0xFFFFFF7F);
      os_log_type_t v8 = 4LL;
    }

    else if (v14 == 1)
    {
      if (a2 < 2) {
        return 0LL;
      }
      BOOL v7 = bswap32(*(_WORD *)a1 & 0xFFBF) >> 16;
      os_log_type_t v8 = 2LL;
    }

    else
    {
      if (a2 < 8) {
        return 0LL;
      }
      BOOL v7 = bswap64(*(void *)a1 & 0xFFFFFFFFFFFFFF3FLL);
      os_log_type_t v8 = 8LL;
    }
  }

  else
  {
    os_log_type_t v8 = 1LL;
  }

  if (v7 > 3) {
    return 0LL;
  }
  if ((v7 & 0x3FFFFFFFFFFFFFFELL) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v16 = "%{public}s Message is not indeterminate";
    os_log_type_t v17 = (os_log_s *)v15;
    uint64_t v18 = 12;
    goto LABEL_22;
  }

  id v9 = (_DWORD *)((char *)a1 + v8);
  os_log_type_t v10 = a2 - v8;
  if ((v7 & 0xFFFFFFFFFFFFFFFDLL) != 0)
  {
    if (a2 == v8) {
      return 0LL;
    }
    BOOL v11 = *(unsigned __int8 *)v9;
    if (v11 <= 0x3F)
    {
      char v12 = (_DWORD *)((char *)v9 + 1);
      os_log_type_t v13 = v10 - 1;
      goto LABEL_65;
    }

    if (v11 >> 6 == 2)
    {
      if (v10 < 4) {
        return 0LL;
      }
      BOOL v11 = bswap32(*v9 & 0xFFFFFF7F);
      os_log_type_t v39 = 4LL;
    }

    else if (v11 >> 6 == 1)
    {
      if (v10 < 2) {
        return 0LL;
      }
      BOOL v11 = bswap32(*(_WORD *)v9 & 0xFFBF) >> 16;
      os_log_type_t v39 = 2LL;
    }

    else
    {
      if (v10 < 8) {
        return 0LL;
      }
      BOOL v11 = bswap64(*(void *)v9 & 0xFFFFFFFFFFFFFF3FLL);
      os_log_type_t v39 = 8LL;
    }

    if (v11 <= 0x3E8)
    {
      char v12 = (_DWORD *)((char *)v9 + v39);
      os_log_type_t v13 = v10 - v39;
LABEL_65:
      if (v11 - 601 <= 0xFFFFFFFFFFFFFE6ELL)
      {
        os_log_type_t v40 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          return 0LL;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
        uint64_t v77 = 2048;
        v78 = v11;
        __int16 v16 = "%{public}s Informational statuses not supported: %llu";
        os_log_type_t v17 = v40;
        uint64_t v18 = 22;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
        return 0LL;
      }

      goto LABEL_68;
    }

    return 0LL;
  }

  if (a2 == v8) {
    return 0LL;
  }
  uint64_t v19 = *(unsigned __int8 *)v9;
  if (v19 > 0x3F)
  {
    if (v19 >> 6 == 2)
    {
      if (v10 < 4) {
        return 0LL;
      }
      uint64_t v19 = bswap32(*v9 & 0xFFFFFF7F);
      uint64_t v20 = 4LL;
    }

    else if (v19 >> 6 == 1)
    {
      if (v10 < 2) {
        return 0LL;
      }
      uint64_t v19 = bswap32(*(_WORD *)v9 & 0xFFBF) >> 16;
      uint64_t v20 = 2LL;
    }

    else
    {
      if (v10 < 8) {
        return 0LL;
      }
      uint64_t v19 = bswap64(*(void *)v9 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v20 = 8LL;
    }
  }

  else
  {
    uint64_t v20 = 1LL;
  }

  BOOL v21 = 0LL;
  if (v19 >> 16) {
    return v21;
  }
  __int16 v22 = v10 - v20;
  if (v22 < v19) {
    return v21;
  }
  BOOL v23 = v22 - v19;
  if (!v23) {
    return 0LL;
  }
  uint64_t v24 = (_DWORD *)((char *)v9 + v20 + v19);
  os_log_type_t v25 = *(unsigned __int8 *)v24;
  if (v25 > 0x3F)
  {
    if (v25 >> 6 == 2)
    {
      if (v23 < 4) {
        return 0LL;
      }
      os_log_type_t v25 = bswap32(*v24 & 0xFFFFFF7F);
      char v26 = 4LL;
    }

    else if (v25 >> 6 == 1)
    {
      if (v23 < 2) {
        return 0LL;
      }
      os_log_type_t v25 = bswap32(*(_WORD *)v24 & 0xFFBF) >> 16;
      char v26 = 2LL;
    }

    else
    {
      if (v23 < 8) {
        return 0LL;
      }
      os_log_type_t v25 = bswap64(*(void *)v24 & 0xFFFFFFFFFFFFFF3FLL);
      char v26 = 8LL;
    }
  }

  else
  {
    char v26 = 1LL;
  }

  BOOL v21 = 0LL;
  if (v25 >> 16) {
    return v21;
  }
  __int16 v27 = v23 - v26;
  if (v27 < v25) {
    return v21;
  }
  char v28 = v27 - v25;
  if (!v28) {
    return 0LL;
  }
  os_log_type_t v29 = (_DWORD *)((char *)v24 + v26 + v25);
  uint64_t v30 = *(unsigned __int8 *)v29;
  if (v30 > 0x3F)
  {
    if (v30 >> 6 == 2)
    {
      if (v28 < 4) {
        return 0LL;
      }
      uint64_t v30 = bswap32(*v29 & 0xFFFFFF7F);
      os_log_type_t v31 = 4LL;
    }

    else if (v30 >> 6 == 1)
    {
      if (v28 < 2) {
        return 0LL;
      }
      uint64_t v30 = bswap32(*(_WORD *)v29 & 0xFFBF) >> 16;
      os_log_type_t v31 = 2LL;
    }

    else
    {
      if (v28 < 8) {
        return 0LL;
      }
      uint64_t v30 = bswap64(*(void *)v29 & 0xFFFFFFFFFFFFFF3FLL);
      os_log_type_t v31 = 8LL;
    }
  }

  else
  {
    os_log_type_t v31 = 1LL;
  }

  BOOL v21 = 0LL;
  if (v30 >> 16) {
    return v21;
  }
  __int16 v32 = v28 - v31;
  if (v32 < v30) {
    return v21;
  }
  os_log_type_t v33 = v32 - v30;
  if (!v33) {
    return 0LL;
  }
  uint64_t v34 = (_DWORD *)((char *)v29 + v31 + v30);
  BOOL v35 = *(unsigned __int8 *)v34;
  if (v35 > 0x3F)
  {
    uint64_t v72 = v35 >> 6;
    if (v72 == 2)
    {
      if (v33 < 4) {
        return 0LL;
      }
      BOOL v35 = bswap32(*v34 & 0xFFFFFF7F);
      os_log_type_t v36 = 4LL;
    }

    else if (v72 == 1)
    {
      if (v33 < 2) {
        return 0LL;
      }
      BOOL v35 = bswap32(*(_WORD *)v34 & 0xFFBF) >> 16;
      os_log_type_t v36 = 2LL;
    }

    else
    {
      if (v33 < 8) {
        return 0LL;
      }
      BOOL v35 = bswap64(*(void *)v34 & 0xFFFFFFFFFFFFFF3FLL);
      os_log_type_t v36 = 8LL;
    }
  }

  else
  {
    os_log_type_t v36 = 1LL;
  }

  uint64_t v37 = v33 - v36;
  if (v35 >> 16) {
    uint64_t v38 = 0;
  }
  else {
    uint64_t v38 = v37 >= v35;
  }
  if (!v38) {
    return 0LL;
  }
  char v12 = (_DWORD *)((char *)v34 + v36 + v35);
  os_log_type_t v13 = v37 - v35;
LABEL_68:
  if (!v13) {
    return 0LL;
  }
  while (1)
  {
    BOOL v45 = *(unsigned __int8 *)v12;
    if (v45 <= 0x3F)
    {
      __int16 v46 = 1LL;
      goto LABEL_86;
    }

    int v47 = v45 >> 6;
    if (v47 != 2) {
      break;
    }
    if (v13 < 4) {
      return 0LL;
    }
    BOOL v45 = bswap32(*v12 & 0xFFFFFF7F);
    __int16 v46 = 4LL;
LABEL_86:
    a1 = (_DWORD *)((char *)v12 + v46);
    a2 = v13 - v46;
    if (!v45) {
      goto LABEL_109;
    }
LABEL_87:
    uint64_t v48 = a2 - v45;
    if (a2 <= v45) {
      return 0LL;
    }
    BOOL v49 = (_DWORD *)((char *)a1 + v45);
    BOOL v50 = *((unsigned __int8 *)a1 + v45);
    if (v50 <= 0x3F)
    {
      uint64_t v41 = 1LL;
    }

    else if (v50 >> 6 == 2)
    {
      if (v48 < 4) {
        return 0LL;
      }
      BOOL v50 = bswap32(*v49 & 0xFFFFFF7F);
      uint64_t v41 = 4LL;
    }

    else if (v50 >> 6 == 1)
    {
      if (v48 < 2) {
        return 0LL;
      }
      BOOL v50 = bswap32(*(_WORD *)v49 & 0xFFBF) >> 16;
      uint64_t v41 = 2LL;
    }

    else
    {
      if (v48 < 8) {
        return 0LL;
      }
      BOOL v50 = bswap64(*(void *)v49 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v41 = 8LL;
    }

    BOOL v21 = 0LL;
    uint64_t v42 = v48 - v41;
    char v12 = (_DWORD *)((char *)v49 + v41 + v50);
    os_log_type_t v13 = v48 - v41 - v50;
    if (HIDWORD(v50)) {
      char v43 = 0;
    }
    else {
      char v43 = v42 >= v50;
    }
    if (!v43 || v13 == 0) {
      return v21;
    }
  }

  if (v47 == 1)
  {
    if (v13 < 2) {
      return 0LL;
    }
    BOOL v45 = bswap32(*(_WORD *)v12 & 0xFFBF) >> 16;
    __int16 v46 = 2LL;
    goto LABEL_86;
  }

  if (v13 < 8) {
    return 0LL;
  }
  os_log_type_t v51 = *(void *)v12;
  a1 = v12 + 2;
  BOOL v45 = bswap64(v51 & 0xFFFFFFFFFFFFFF3FLL);
  if (HIDWORD(v45)) {
    return 0LL;
  }
  a2 = v13 - 8;
  if (v45) {
    goto LABEL_87;
  }
LABEL_109:
  if (!a2) {
    return 0LL;
  }
LABEL_110:
  uint64_t v52 = *(unsigned __int8 *)a1;
  if (v52 <= 0x3F)
  {
    int v53 = 1LL;
    goto LABEL_112;
  }

  if (v52 >> 6 == 2)
  {
    if (a2 < 4) {
      return 0LL;
    }
    uint64_t v52 = bswap32(*a1 & 0xFFFFFF7F);
    int v53 = 4LL;
LABEL_112:
    BOOL v21 = (char *)a1 + v53;
    uint64_t v54 = a2 - v53;
    if (!v52) {
      goto LABEL_126;
    }
  }

  else
  {
    if (v52 >> 6 == 1)
    {
      if (a2 >= 2)
      {
        uint64_t v52 = bswap32(*(_WORD *)a1 & 0xFFBF) >> 16;
        int v53 = 2LL;
        goto LABEL_112;
      }

      return 0LL;
    }

    if (a2 < 8) {
      return 0LL;
    }
    uint64_t v58 = *(void *)a1;
    uint64_t v57 = (char *)(a1 + 2);
    uint64_t v52 = bswap64(v58 & 0xFFFFFFFFFFFFFF3FLL);
    if (HIDWORD(v52)) {
      return 0LL;
    }
    int v53 = 8LL;
    BOOL v21 = v57;
    uint64_t v54 = a2 - 8;
    if (!v52)
    {
LABEL_126:
      *a5 = 1;
      *a7 = v54;
      if (a2 == v53) {
        BOOL v21 = 0LL;
      }
      *a6 = v21;
      return 0LL;
    }
  }

  os_log_type_t v55 = v54 == v52;
  if (v54 < v52) {
    return 0LL;
  }
  *a4 = v52;
  *a7 = v54 - v52;
  int v56 = &v21[v52];
  if (v55) {
    int v56 = 0LL;
  }
  *a6 = v56;
  return v21;
}

    if (v79) {
      free(v79);
    }
    goto LABEL_208;
  }

  if (!v11)
  {
    __nwlog_obj();
    os_log_type_t v82 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
    __int16 v83 = (char *)_os_log_send_and_compose_impl();

    uu[0] = OS_LOG_TYPE_ERROR;
    v136 = 0;
    if (__nwlog_fault(v83, uu, &v136))
    {
      if (uu[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v85 = uu[0];
        if (os_log_type_enabled(v84, uu[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl(&dword_181A5C000, v84, v85, "%{public}s called with null flow", buf, 0xCu);
        }
      }

      else if (v136)
      {
        v97 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v98 = uu[0];
        int v99 = os_log_type_enabled(v84, uu[0]);
        if (v97)
        {
          if (v99)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v97;
            _os_log_impl( &dword_181A5C000,  v84,  v98,  "%{public}s called with null flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v97);
          goto LABEL_194;
        }

        if (v99)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl(&dword_181A5C000, v84, v98, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v122 = uu[0];
        if (os_log_type_enabled(v84, uu[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl( &dword_181A5C000,  v84,  v122,  "%{public}s called with null flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_protocol_ipv4_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
    os_log_type_t v55 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_171;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
      uint64_t v58 = "%{public}s called with null protocol";
      goto LABEL_170;
    }

    if (!v83)
    {
      int v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_171;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
      uint64_t v58 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_170;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v56 = (os_log_s *)__nwlog_obj();
    os_log_type_t v57 = type;
    BOOL v67 = os_log_type_enabled(v56, type);
    if (!backtrace_string)
    {
      if (!v67) {
        goto LABEL_171;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
      uint64_t v58 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_170;
    }

    if (v67)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
      __int16 v86 = 2082;
      __int16 v87 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_171:
    if (!v55) {
      return;
    }
    goto LABEL_172;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
    os_log_type_t v55 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_171;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
      uint64_t v58 = "%{public}s called with null ipv4";
      goto LABEL_170;
    }

    if (!v83)
    {
      int v56 = (os_log_s *)__nwlog_obj();
      os_log_type_t v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_171;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
      uint64_t v58 = "%{public}s called with null ipv4, backtrace limit exceeded";
      goto LABEL_170;
    }

    BOOL v68 = (char *)__nw_create_backtrace_string();
    int v56 = (os_log_s *)__nwlog_obj();
    os_log_type_t v57 = type;
    BOOL v69 = os_log_type_enabled(v56, type);
    if (v68)
    {
      if (v69)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
        __int16 v86 = 2082;
        __int16 v87 = v68;
        _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s called with null ipv4, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v68);
      if (!v55) {
        return;
      }
LABEL_172:
      uint64_t v42 = (nw_protocol *)v55;
LABEL_88:
      free(v42);
      return;
    }

    if (v69)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
      uint64_t v58 = "%{public}s called with null ipv4, no backtrace";
LABEL_170:
      _os_log_impl(&dword_181A5C000, v56, v57, v58, buf, 0xCu);
      goto LABEL_171;
    }

    goto LABEL_171;
  }

  if (((uint64_t)a1[3].handle & 1) == 0)
  {
    if (gLogDatapath)
    {
      v59 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_connected";
        __int16 v86 = 2082;
        __int16 v87 = (char *)&a1[3].handle + 1;
        __int16 v88 = 2080;
        uint64_t v89 = " ";
        __int16 v90 = 2048;
        p_output_handler = (char *)&a1[1].output_handler;
        _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p Got a connected event from the lower layer",  buf,  0x2Au);
      }
    }
  }

  default_input_handler = a1->default_input_handler;
  if (a1->output_handler != a2)
  {
    if (!default_input_handler) {
      return;
    }
    callbacks = default_input_handler->callbacks;
    if (!callbacks) {
      return;
    }
    if (!a2) {
      return;
    }
    connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
    if (!connected) {
      return;
    }
    handle = default_input_handler->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v8 = default_input_handler[1].callbacks;
      if (v8) {
        default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v8->add_input_handler + 1);
      }
    }

    if (a2->handle != &nw_protocol_ref_counted_handle)
    {
      connected(default_input_handler, a2);
      goto LABEL_77;
    }

    BOOL v23 = a2[1].callbacks;
    if (v23) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v23->add_input_handler + 1);
    }
    connected(default_input_handler, a2);
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v24 = a2[1].callbacks;
      if (v24)
      {
        os_log_type_t v25 = (nw_protocol_callbacks *)((char *)v24 - 1);
        a2[1].callbacks = v25;
        if (!v25)
        {
          char v26 = *(void (***)(void))a2[1].flow_id;
          if (v26)
          {
            *(void *)a2[1].flow_id = 0LL;
            v26[2](v26);
            _Block_release(v26);
          }

          if ((a2[1].flow_id[8] & 1) != 0)
          {
            __int16 v27 = *(const void **)a2[1].flow_id;
            if (v27) {
              _Block_release(v27);
            }
          }

          char v28 = a2;
LABEL_76:
          free(v28);
          goto LABEL_77;
        }
      }
    }

    goto LABEL_77;
  }

  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    os_log_type_t v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (__nwlog_fault(v70, &type, &v83))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v71 = (os_log_s *)__nwlog_obj();
        os_log_type_t v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
          BOOL v73 = "%{public}s called with null protocol";
LABEL_188:
          _os_log_impl(&dword_181A5C000, v71, v72, v73, buf, 0xCu);
        }
      }

      else if (v83)
      {
        uint64_t v77 = (char *)__nw_create_backtrace_string();
        os_log_type_t v71 = (os_log_s *)__nwlog_obj();
        os_log_type_t v72 = type;
        BOOL v78 = os_log_type_enabled(v71, type);
        if (v77)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
            __int16 v86 = 2082;
            __int16 v87 = v77;
            _os_log_impl( &dword_181A5C000,  v71,  v72,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v77);
          goto LABEL_189;
        }

        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
          BOOL v73 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_188;
        }
      }

      else
      {
        os_log_type_t v71 = (os_log_s *)__nwlog_obj();
        os_log_type_t v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
          BOOL v73 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_188;
        }
      }
    }

LABEL_77:
  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v38 = default_input_handler[1].callbacks;
    if (v38)
    {
      os_log_type_t v39 = (nw_protocol_callbacks *)((char *)v38 - 1);
      default_input_handler[1].callbacks = v39;
      if (!v39)
      {
        os_log_type_t v40 = *(void (***)(void))default_input_handler[1].flow_id;
        if (v40)
        {
          *(void *)default_input_handler[1].flow_id = 0LL;
          v40[2](v40);
          _Block_release(v40);
        }

        if ((default_input_handler[1].flow_id[8] & 1) != 0)
        {
          uint64_t v41 = *(const void **)default_input_handler[1].flow_id;
          if (v41) {
            _Block_release(v41);
          }
        }

        uint64_t v42 = default_input_handler;
        goto LABEL_88;
      }
    }
  }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }
          }

        goto LABEL_78;
      }

      if (!v45)
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = v46;
        if (os_log_type_enabled(v31, v46))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl( &dword_181A5C000,  v31,  v36,  "%{public}s called with null metadata, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
        }

        goto LABEL_77;
      }

      os_log_type_t v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v34 = v46;
      BOOL v35 = os_log_type_enabled(v31, v46);
      if (!v33)
      {
        if (v35)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl( &dword_181A5C000,  v31,  v34,  "%{public}s called with null metadata, no backtrace",  (uint8_t *)type,  0xCu);
        }

        goto LABEL_77;
      }

      if (v35)
      {
        *(_DWORD *)os_log_type_t type = 136446466;
        os_log_type_t v51 = "nw_ip_metadata_set_receive_time";
        uint64_t v52 = 2082;
        int v53 = v33;
        _os_log_impl( &dword_181A5C000,  v31,  v34,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
      }

      free(v33);
    }

    goto LABEL_78;
  }

  if (!(_BYTE)p_shared_protocol)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (os_log_s *)(id)gLogObj;
    char v43 = type[0];
    if (os_log_type_enabled(v25, type[0]))
    {
      else {
        BOOL v44 = off_189BBBBC0[v9];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow cancelWithHandler:forced:]";
      __int16 v137 = 2082;
      v138 = (void *)v44;
      __int16 v139 = 2082;
      v140 = "flow";
      _os_log_impl( &dword_181A5C000,  v25,  v43,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_77;
  }

  char v28 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v25 = (os_log_s *)(id)gLogObj;
  os_log_type_t v29 = type[0];
  uint64_t v30 = os_log_type_enabled(v25, type[0]);
  if (!v28)
  {
    if (v30)
    {
      else {
        BOOL v45 = off_189BBBBC0[v9];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow cancelWithHandler:forced:]";
      __int16 v137 = 2082;
      v138 = (void *)v45;
      __int16 v139 = 2082;
      v140 = "flow";
      _os_log_impl( &dword_181A5C000,  v25,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_77;
  }

  if (v30)
  {
    else {
      os_log_type_t v31 = off_189BBBBC0[v9];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow cancelWithHandler:forced:]";
    __int16 v137 = 2082;
    v138 = (void *)v31;
    __int16 v139 = 2082;
    v140 = "flow";
    uint64_t v141 = 2082;
    v142 = v28;
    _os_log_impl( &dword_181A5C000,  v25,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v28);
  if (v24) {
    goto LABEL_79;
  }
LABEL_80:
}

        if (v27) {
          free(v27);
        }
        goto LABEL_29;
      }

  if (v14) {
    free(v14);
  }
  return 0LL;
}

        _os_log_impl(&dword_181A5C000, v46, v47, v48, buf, 0xCu);
        goto LABEL_78;
      }

      if ((*(_BYTE *)(v32 + 235) & 0xE) == 6)
      {
        os_log_type_t v33 = *(void *)(v32 + 64);
        if (v33)
        {
          *(void *)(v32 + 64) = *(void *)(v32 + 32);
          nw_protocol_set_output_handler((uint64_t)handle, v33);
          nw_protocol_set_output_handler(v32, v33);
          *(_BYTE *)(v32 + 235) |= 8u;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v34 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v35 = *(unsigned __int16 *)(v32 + 144);
            uint64_t v37 = *(void *)(v32 + 96);
            os_log_type_t v36 = *(void *)(v32 + 104);
            *(_DWORD *)buf = 136447234;
            uint64_t v84 = "nw_protocol_shoes_process_udp_associate_completion";
            __int16 v85 = 2082;
            __int16 v86 = (char *)(v32 + 151);
            __int16 v87 = 1024;
            __int16 v88 = v35;
            uint64_t v89 = 2112;
            *(void *)__int16 v90 = v36;
            *(_WORD *)&v90[8] = 2112;
            BOOL v91 = v37;
            uint64_t v38 = (os_log_s *)v34;
            os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
            os_log_type_t v40 = "%{public}s %{public}s udp-associate completed with port %d to %@ and remote %@";
            uint64_t v41 = 48;
LABEL_31:
            _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, v41);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v42 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v84 = "nw_protocol_shoes_process_udp_associate_completion";
            __int16 v85 = 2082;
            __int16 v86 = (char *)(v32 + 151);
            uint64_t v38 = (os_log_s *)v42;
            os_log_type_t v39 = OS_LOG_TYPE_ERROR;
            os_log_type_t v40 = "%{public}s %{public}s udp-associate no output handler";
            uint64_t v41 = 22;
            goto LABEL_31;
          }
        }
      }
    }

    if (v37) {
      free(v37);
    }
    return 0LL;
  }

  uint64_t result = nw_shoes_create_request((uint64_t)a1->handle);
  if (!result) {
    return result;
  }
  id v4 = (unsigned __int8 *)result;
  id v5 = bswap32(*(unsigned __int16 *)result) >> 16;
  BOOL v6 = (char *)a1->handle;
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_shoes_send";
    uint64_t v41 = (char *)_os_log_send_and_compose_impl();
    v58[0] = 16;
    LOBYTE(v53) = 0;
    if (v58[0] == 17)
    {
      uint64_t v42 = (os_log_s *)__nwlog_obj();
      char v43 = v58[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v58[0])) {
        goto LABEL_85;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_shoes_send";
      BOOL v44 = "%{public}s called with null shoes";
    }

    else if ((_BYTE)v53)
    {
      int v47 = (char *)__nw_create_backtrace_string();
      uint64_t v42 = (os_log_s *)__nwlog_obj();
      char v43 = v58[0];
      uint64_t v48 = os_log_type_enabled(v42, (os_log_type_t)v58[0]);
      if (v47)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_shoes_send";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v47;
          _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s called with null shoes, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v47);
        goto LABEL_85;
      }

      if (!v48)
      {
LABEL_85:
        if (v41) {
          free(v41);
        }
        goto LABEL_32;
      }

      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_shoes_send";
      BOOL v44 = "%{public}s called with null shoes, no backtrace";
    }

    else
    {
      uint64_t v42 = (os_log_s *)__nwlog_obj();
      char v43 = v58[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v58[0])) {
        goto LABEL_85;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_shoes_send";
      BOOL v44 = "%{public}s called with null shoes, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v42, v43, v44, buf, 0xCu);
    goto LABEL_85;
  }

  BOOL v7 = v5 + 2;
  int v53 = 0LL;
  uint64_t v54 = &v53;
  os_log_type_t v51 = 0LL;
  uint64_t v52 = &v51;
  os_log_type_t v8 = ((uint64_t (*)(void))a1->output_handler->callbacks->get_output_frames)();
  id v9 = v8;
  os_log_type_t v10 = v53;
  if (!v53 || !v8)
  {
    if (v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v22 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_shoes_send";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v6 + 151;
        *(_WORD *)&buf[22] = 1024;
        os_log_type_t v65 = v9;
        _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Output handler reported %u frames to write, but array is empty",  buf,  0x1Cu);
      }
    }

    if (v29) {
      free(v29);
    }
    return 0LL;
  }

  uint64_t v2 = v1;
  id v3 = nw_context_copy_globals_context(v1);

  if ((*(_BYTE *)(v3 + 136) & 8) == 0)
  {
    __nwlog_obj();
    __int16 v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v73 = "nw_context_run_queued_blocks_inline";
    os_log_type_t v33 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v70) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v33, &v70, &type))
    {
      if (v70 == 17)
      {
        __nwlog_obj();
        uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v35 = v70;
        if (os_log_type_enabled(v34, (os_log_type_t)v70))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s called with null context->is_inline", buf, 0xCu);
        }
      }

      else if (type)
      {
        os_log_type_t v55 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v56 = v70;
        os_log_type_t v57 = os_log_type_enabled(v34, (os_log_type_t)v70);
        if (v55)
        {
          if (v57)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v73 = "nw_context_run_queued_blocks_inline";
            v74 = 2082;
            BOOL v75 = (__uint64_t)v55;
            _os_log_impl( &dword_181A5C000,  v34,  v56,  "%{public}s called with null context->is_inline, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v55);
          goto LABEL_82;
        }

        if (v57)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl( &dword_181A5C000,  v34,  v56,  "%{public}s called with null context->is_inline, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v59 = v70;
        if (os_log_type_enabled(v34, (os_log_type_t)v70))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl( &dword_181A5C000,  v34,  v59,  "%{public}s called with null context->is_inline, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(backtrace_string);
    goto LABEL_91;
  }

  if (gLogDatapath)
  {
    uint64_t v38 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "__nw_protocol_fulfill_frame_request";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = a4;
      LOWORD(v79) = 1024;
      *(_DWORD *)((char *)&v79 + 2) = a5;
      _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s called with minimum bytes: %u, maximum bytes: %u, maximum frames: %u",  buf,  0x1Eu);
    }
  }

  if (a4 < a3 || !a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "__nw_protocol_fulfill_frame_request";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a4;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    LOWORD(v79) = 1024;
    *(_DWORD *)((char *)&v79 + 2) = a5;
    char v26 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v73[0] = 0;
    if (__nwlog_fault(v26, type, v73))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v27 = (os_log_s *)gLogObj;
        char v28 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_fulfill_frame_request";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a4;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = a3;
          LOWORD(v79) = 1024;
          *(_DWORD *)((char *)&v79 + 2) = a5;
          os_log_type_t v29 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u";
LABEL_42:
          _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0x1Eu);
        }
      }

      else if (v73[0])
      {
        uint64_t v30 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v27 = (os_log_s *)gLogObj;
        char v28 = type[0];
        os_log_type_t v31 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v30)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "__nw_protocol_fulfill_frame_request";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = a4;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = a3;
            LOWORD(v79) = 1024;
            *(_DWORD *)((char *)&v79 + 2) = a5;
            HIWORD(v79) = 2082;
            int v80 = v30;
            _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s invalid values for frame request, max %u, min %u, max frame %u, dumping backtrace:%{public}s",  buf,  0x28u);
          }

          free(v30);
          goto LABEL_43;
        }

        if (v31)
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_fulfill_frame_request";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a4;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = a3;
          LOWORD(v79) = 1024;
          *(_DWORD *)((char *)&v79 + 2) = a5;
          os_log_type_t v29 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, no backtrace";
          goto LABEL_42;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v27 = (os_log_s *)gLogObj;
        char v28 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_fulfill_frame_request";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a4;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = a3;
          LOWORD(v79) = 1024;
          *(_DWORD *)((char *)&v79 + 2) = a5;
          os_log_type_t v29 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, backtrace limit exceeded";
          goto LABEL_42;
        }
      }
    }

  if (v10) {
    free(v10);
  }
  return 0LL;
}

                  free((void *)v34);
                  goto LABEL_29;
                }
              }

              __nwlog_obj();
              __int16 v130 = *(const char **)(v34 + 16);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
              if (!v130) {
                __int16 v130 = "invalid";
              }
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v130;
              *(_WORD *)&buf[22] = 2048;
              v167 = (void *)v34;
              int v131 = (char *)_os_log_send_and_compose_impl();
              v165 = OS_LOG_TYPE_ERROR;
              v164 = 0;
              if (__nwlog_fault(v131, &v165, &v164))
              {
                if (v165 == OS_LOG_TYPE_FAULT)
                {
                  v132 = (os_log_s *)__nwlog_obj();
                  uint64_t v133 = v165;
                  if (!os_log_type_enabled(v132, v165)) {
                    goto LABEL_325;
                  }
                  v134 = *(const char **)(v34 + 16);
                  if (!v134) {
                    v134 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v134;
                  *(_WORD *)&buf[22] = 2048;
                  v167 = (void *)v34;
                  __int16 v135 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
                  goto LABEL_324;
                }

                if (!v164)
                {
                  v132 = (os_log_s *)__nwlog_obj();
                  uint64_t v133 = v165;
                  if (!os_log_type_enabled(v132, v165)) {
                    goto LABEL_325;
                  }
                  v151 = *(const char **)(v34 + 16);
                  if (!v151) {
                    v151 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v151;
                  *(_WORD *)&buf[22] = 2048;
                  v167 = (void *)v34;
                  __int16 v135 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
                  goto LABEL_324;
                }

                v143 = (char *)__nw_create_backtrace_string();
                v132 = (os_log_s *)__nwlog_obj();
                uint64_t v133 = v165;
                v144 = os_log_type_enabled(v132, v165);
                if (v143)
                {
                  if (v144)
                  {
                    v145 = *(const char **)(v34 + 16);
                    if (!v145) {
                      v145 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v145;
                    *(_WORD *)&buf[22] = 2048;
                    v167 = (void *)v34;
                    *(_WORD *)v168 = 2082;
                    *(void *)&v168[2] = v143;
                    _os_log_impl( &dword_181A5C000,  v132,  v133,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                  }

                  free(v143);
                  goto LABEL_325;
                }

                if (v144)
                {
                  v157 = *(const char **)(v34 + 16);
                  if (!v157) {
                    v157 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_finalize_output_frames";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v157;
                  *(_WORD *)&buf[22] = 2048;
                  v167 = (void *)v34;
                  __int16 v135 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_324:
                  _os_log_impl(&dword_181A5C000, v132, v133, v135, buf, 0x20u);
                }
              }

            free((void *)v4);
          }
        }
      }

  free(v14);
  if (v8) {
LABEL_113:
  }
    free(v8);
}

      goto LABEL_78;
    }

    if (!v60)
    {
      __nwlog_obj();
      uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v48 = v61;
      if (os_log_type_enabled(v38, v61))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v63 = "nw_connection_group_handle_incoming_connection";
        _os_log_impl( &dword_181A5C000,  v38,  v48,  "%{public}s called with null new_connection, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v45 = v61;
    __int16 v46 = os_log_type_enabled(v38, v61);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v63 = "nw_connection_group_handle_incoming_connection";
        _os_log_impl(&dword_181A5C000, v38, v45, "%{public}s called with null new_connection, no backtrace", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v63 = "nw_connection_group_handle_incoming_connection";
      BOOL v64 = 2082;
      *(void *)os_log_type_t v65 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v38,  v45,  "%{public}s called with null new_connection, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_78;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)int v56 = 136446210;
    *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v22 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int v56 = 136446210;
        *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v22, "%{public}s called with null connection", v56, 0xCu);
      }
    }

    else if (v51)
    {
      __int16 v32 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type;
      uint64_t v34 = os_log_type_enabled(v19, type);
      if (v32)
      {
        if (v34)
        {
          *(_DWORD *)int v56 = 136446466;
          *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
          *(_WORD *)&v56[12] = 2082;
          *(void *)&v56[14] = v32;
          _os_log_impl( &dword_181A5C000,  v19,  v33,  "%{public}s called with null connection, dumping backtrace:%{public}s",  v56,  0x16u);
        }

        free(v32);
        if (!v18) {
          goto LABEL_80;
        }
        goto LABEL_79;
      }

      if (v34)
      {
        *(_DWORD *)int v56 = 136446210;
        *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl(&dword_181A5C000, v19, v33, "%{public}s called with null connection, no backtrace", v56, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)int v56 = 136446210;
        *(void *)&v56[4] = "nw_connection_group_has_connection_locked";
        _os_log_impl( &dword_181A5C000,  v19,  v44,  "%{public}s called with null connection, backtrace limit exceeded",  v56,  0xCu);
      }
    }

    goto LABEL_77;
  }

  *(void *)int v56 = 0LL;
  *(void *)&v56[8] = v56;
  *(void *)&v56[16] = 0x2020000000LL;
  os_log_type_t v57 = 0;
  BOOL v6 = (unsigned __int8 *)v3[13];
  if (v6)
  {
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL41nw_connection_group_has_connection_lockedP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connection_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC7960;
    uint64_t v54 = v4;
    os_log_type_t v55 = v56;
    nw_array_apply(v6, (uint64_t)buf);

    BOOL v7 = *(unsigned __int8 *)(*(void *)&v56[8] + 24LL);
  }

  else
  {
    BOOL v7 = 0;
  }

  os_log_type_t v8 = v7 == 0;
  _Block_object_dispose(v56, 8);

  if (!v8)
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      id v9 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v10 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
        BOOL v11 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_connection_group_extract_connection_for_message_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v10;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v11;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] has connection %p, removing from group and returning",  buf,  0x1Cu);
      }
    }

    char v12 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    os_log_type_t v13 = *(id *)(a1 + 32);
    id v14 = v12;
    id v15 = v14;
    if (v13)
    {
      if (v14)
      {
        __int16 v16 = v13[13];
        if (v16)
        {
          nw_array_remove_object(v16, (uint64_t)v15);
          if (!nw_parameters_get_logging_disabled(v13[7]))
          {
            if (gLogDatapath)
            {
              if (__nwlog_connection_group_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
              }
              BOOL v35 = (os_log_s *)(id)gconnection_groupLogObj;
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
              {
                os_log_type_t v36 = *((_DWORD *)v13 + 42);
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_connection_group_remove_connection_locked";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v36;
                *(_WORD *)&buf[18] = 2112;
                *(void *)&buf[20] = v15;
                _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] removed connection %@",  buf,  0x1Cu);
              }
            }
          }
        }

        goto LABEL_18;
      }

      __nwlog_obj();
      __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_remove_connection_locked";
      uint64_t v24 = (char *)_os_log_send_and_compose_impl();

      v56[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v24, v56, &type))
      {
        if (v56[0] == 17)
        {
          __nwlog_obj();
          os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v28 = v56[0];
          if (os_log_type_enabled(v25, (os_log_type_t)v56[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_remove_connection_locked";
            _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s called with null connection", buf, 0xCu);
          }
        }

        else if (type)
        {
          os_log_type_t v40 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v41 = v56[0];
          uint64_t v42 = os_log_type_enabled(v25, (os_log_type_t)v56[0]);
          if (v40)
          {
            if (v42)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_group_remove_connection_locked";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v40;
              _os_log_impl( &dword_181A5C000,  v25,  v41,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v40);
            if (!v24) {
              goto LABEL_18;
            }
            goto LABEL_102;
          }

          if (v42)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_remove_connection_locked";
            _os_log_impl(&dword_181A5C000, v25, v41, "%{public}s called with null connection, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v50 = v56[0];
          if (os_log_type_enabled(v25, (os_log_type_t)v56[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_remove_connection_locked";
            _os_log_impl( &dword_181A5C000,  v25,  v50,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_100;
      }
    }
  }

  else if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    id v4 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      __int16 v16 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_start_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v16;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] The group has already been started, ignoring nw_connection_group_start().",  buf,  0x12u);
    }

    goto LABEL_77;
  }

        free(v14);
        goto LABEL_78;
      }

      if (!v31) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_add_listen_handler";
      uint64_t v18 = "%{public}s called with null listen_protocol, no backtrace";
    }

    else
    {
      BOOL v23 = (os_log_s *)__nwlog_obj();
      uint64_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_add_listen_handler";
      uint64_t v18 = "%{public}s called with null listen_protocol, backtrace limit exceeded";
    }

    uint64_t v34 = v23;
    BOOL v35 = v24;
    os_log_type_t v36 = 12;
    goto LABEL_75;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "__nw_protocol_add_listen_handler";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v19, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_add_listen_handler";
        __int16 v22 = "%{public}s called with null protocol";
LABEL_68:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else if (v37)
    {
      char v28 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      os_log_type_t v29 = os_log_type_enabled(v20, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "__nw_protocol_add_listen_handler";
          uint64_t v41 = 2082;
          uint64_t v42 = v28;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v28);
        goto LABEL_69;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_add_listen_handler";
        __int16 v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_68;
      }
    }

    else
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_add_listen_handler";
        __int16 v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_68;
      }
    }
  }

        free(v14);
        goto LABEL_78;
      }

      if (!v31) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_remove_listen_handler";
      uint64_t v18 = "%{public}s called with null listen_protocol, no backtrace";
    }

    else
    {
      BOOL v23 = (os_log_s *)__nwlog_obj();
      uint64_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_remove_listen_handler";
      uint64_t v18 = "%{public}s called with null listen_protocol, backtrace limit exceeded";
    }

    uint64_t v34 = v23;
    BOOL v35 = v24;
    os_log_type_t v36 = 12;
    goto LABEL_75;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "__nw_protocol_remove_listen_handler";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v19, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_remove_listen_handler";
        __int16 v22 = "%{public}s called with null protocol";
LABEL_68:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else if (v37)
    {
      char v28 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      os_log_type_t v29 = os_log_type_enabled(v20, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "__nw_protocol_remove_listen_handler";
          uint64_t v41 = 2082;
          uint64_t v42 = v28;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v28);
        goto LABEL_69;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_remove_listen_handler";
        __int16 v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_68;
      }
    }

    else
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_remove_listen_handler";
        __int16 v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_68;
      }
    }
  }

        free(v14);
        goto LABEL_78;
      }

      if (!v31) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_finalize_output_frames";
      uint64_t v18 = "%{public}s called with null frames, no backtrace";
    }

    else
    {
      BOOL v23 = (os_log_s *)__nwlog_obj();
      uint64_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_finalize_output_frames";
      uint64_t v18 = "%{public}s called with null frames, backtrace limit exceeded";
    }

    uint64_t v34 = v23;
    BOOL v35 = v24;
    os_log_type_t v36 = 12;
    goto LABEL_75;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "__nw_protocol_finalize_output_frames";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v19, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_finalize_output_frames";
        __int16 v22 = "%{public}s called with null protocol";
LABEL_68:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else if (v37)
    {
      char v28 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      os_log_type_t v29 = os_log_type_enabled(v20, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "__nw_protocol_finalize_output_frames";
          uint64_t v41 = 2082;
          uint64_t v42 = v28;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v28);
        goto LABEL_69;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_finalize_output_frames";
        __int16 v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_68;
      }
    }

    else
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_finalize_output_frames";
        __int16 v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_68;
      }
    }
  }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v14 = *(void *)(v2 + 88);
        if (v14)
        {
          id v15 = v14 - 1;
          *(void *)(v2 + 8_Block_object_dispose(va, 8) = v15;
          if (!v15)
          {
            __int16 v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0LL;
              v16[2](v16);
              _Block_release(v16);
            }

            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              os_log_type_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }

        free(v14);
        goto LABEL_78;
      }

      if (!v31) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_copy_info";
      uint64_t v18 = "%{public}s called with null type, no backtrace";
    }

    else
    {
      BOOL v23 = (os_log_s *)__nwlog_obj();
      uint64_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v40 = "__nw_protocol_copy_info";
      uint64_t v18 = "%{public}s called with null type, backtrace limit exceeded";
    }

    uint64_t v34 = v23;
    BOOL v35 = v24;
    os_log_type_t v36 = 12;
    goto LABEL_75;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "__nw_protocol_copy_info";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v37 = 0;
  if (__nwlog_fault(v19, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_copy_info";
        __int16 v22 = "%{public}s called with null protocol";
LABEL_68:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else if (v37)
    {
      char v28 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      os_log_type_t v29 = os_log_type_enabled(v20, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "__nw_protocol_copy_info";
          uint64_t v41 = 2082;
          uint64_t v42 = v28;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v28);
        goto LABEL_69;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_copy_info";
        __int16 v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_68;
      }
    }

    else
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "__nw_protocol_copy_info";
        __int16 v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_68;
      }
    }
  }
}

    goto LABEL_78;
  }

  if (!v6)
  {
    char v26 = v7;
    __nwlog_obj();
    os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
    char v28 = (char *)_os_log_send_and_compose_impl();

    uint64_t v58 = OS_LOG_TYPE_ERROR;
    os_log_type_t v57 = 0;
    if (v58 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v32 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null old_protocol", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (!v57)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl( &dword_181A5C000,  v29,  v44,  "%{public}s called with null old_protocol, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_77;
    }

    uint64_t v38 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v39 = v58;
    os_log_type_t v40 = os_log_type_enabled(v29, v58);
    if (!v38)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_181A5C000, v29, v39, "%{public}s called with null old_protocol, no backtrace", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v38;
      _os_log_impl( &dword_181A5C000,  v29,  v39,  "%{public}s called with null old_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_58;
  }

  if (!v7)
  {
    char v26 = 0LL;
    __nwlog_obj();
    os_log_type_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
    char v28 = (char *)_os_log_send_and_compose_impl();

    uint64_t v58 = OS_LOG_TYPE_ERROR;
    os_log_type_t v57 = 0;
    if (v58 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v34 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_181A5C000, v29, v34, "%{public}s called with null new_options", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (!v57)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v45 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl( &dword_181A5C000,  v29,  v45,  "%{public}s called with null new_options, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_77;
    }

    uint64_t v38 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v41 = v58;
    uint64_t v42 = os_log_type_enabled(v29, v58);
    if (!v38)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_181A5C000, v29, v41, "%{public}s called with null new_options, no backtrace", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_stack_replace_protocol";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v38;
      _os_log_impl( &dword_181A5C000,  v29,  v41,  "%{public}s called with null new_options, dumping backtrace:%{public}s",  buf,  0x16u);
    }

          os_log_type_t v10 = 0LL;
LABEL_78:

          goto LABEL_79;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        uint64_t v62 = "nw_parameters_create_secure_udp";
        BOOL v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (os_log_s *)(id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v62 = "nw_parameters_create_secure_udp";
              _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s nw_udp_create_options failed", buf, 0xCu);
            }
          }

          else if (v59)
          {
            os_log_type_t v31 = __nw_create_backtrace_string();
            if (v31)
            {
              __int16 v32 = (char *)v31;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v33 = (os_log_s *)(id)gLogObj;
              uint64_t v34 = type;
              if (os_log_type_enabled(v33, type))
              {
                *(_DWORD *)buf = 136446466;
                uint64_t v62 = "nw_parameters_create_secure_udp";
                os_log_type_t v63 = 2082;
                BOOL v64 = v32;
                _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s nw_udp_create_options failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v32);
              if (!v23) {
                goto LABEL_77;
              }
              goto LABEL_76;
            }

            __nwlog_obj();
            uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v38 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v62 = "nw_parameters_create_secure_udp";
              _os_log_impl( &dword_181A5C000,  v24,  v38,  "%{public}s nw_udp_create_options failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v24 = (os_log_s *)(id)gLogObj;
            os_log_type_t v36 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v62 = "nw_parameters_create_secure_udp";
              _os_log_impl( &dword_181A5C000,  v24,  v36,  "%{public}s nw_udp_create_options failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v23) {
          goto LABEL_77;
        }
LABEL_76:
        free(v23);
        goto LABEL_77;
      }

      goto LABEL_70;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v62 = "nw_parameters_create_secure_udp";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (__nwlog_fault(v19, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)(id)gLogObj;
        BOOL v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "nw_parameters_create_secure_udp";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s nw_tls_create_options failed", buf, 0xCu);
        }
      }

      else if (v59)
      {
        char v26 = __nw_create_backtrace_string();
        if (v26)
        {
          __int16 v27 = (char *)v26;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v28 = (os_log_s *)(id)gLogObj;
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v62 = "nw_parameters_create_secure_udp";
            os_log_type_t v63 = 2082;
            BOOL v64 = v27;
            _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s nw_tls_create_options failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v27);
          if (!v19) {
            goto LABEL_70;
          }
          goto LABEL_69;
        }

        __nwlog_obj();
        uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v37 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "nw_parameters_create_secure_udp";
          _os_log_impl(&dword_181A5C000, v20, v37, "%{public}s nw_tls_create_options failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (os_log_s *)(id)gLogObj;
        BOOL v35 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v62 = "nw_parameters_create_secure_udp";
          _os_log_impl( &dword_181A5C000,  v20,  v35,  "%{public}s nw_tls_create_options failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v19)
    {
LABEL_70:

      goto LABEL_71;
    }

              xpc_dictionary_set_uint64(v2, "ecn_mode", v31);
              goto LABEL_78;
            }

      if (v36) {
        free(v36);
      }
LABEL_11:
      id v15 = 0LL;
      goto LABEL_24;
    }

    __nwlog_obj();
    os_log_type_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();

    v59 = OS_LOG_TYPE_ERROR;
    uint64_t v58 = 0;
    if (__nwlog_fault(v30, &v59, &v58))
    {
      if (v59 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v34 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
          _os_log_impl(&dword_181A5C000, v31, v34, "%{public}s called with null protocol_identifier", buf, 0xCu);
        }

              _os_log_impl(&dword_181A5C000, v56, v57, v58, (uint8_t *)&v105, 0x1Cu);
              goto LABEL_78;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v54 = (os_log_s *)(id)gLogObj;
            os_log_type_t v55 = buf;
            if (os_log_type_enabled(v54, (os_log_type_t)buf))
            {
              uint64_t v105 = 136446722;
              uint64_t v106 = "-[ManagedNetworkSettings reloadMNS]";
              v107 = 2114;
              v108[0] = v30;
              LOWORD(v108[1]) = 1024;
              *(_DWORD *)((char *)&v108[1] + 2) = *(_DWORD *)v75;
              int v56 = v54;
              os_log_type_t v57 = v55;
              uint64_t v58 = "%{public}s MNS error reading sysctl %{public}@ %{darwin.errno}d";
              goto LABEL_77;
            }

    if (v30) {
      free(v30);
    }
    goto LABEL_97;
  }

  if (!v8)
  {
    __nwlog_obj();
    os_log_type_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
    uint64_t v34 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v65 = 0;
    if (__nwlog_fault(v34, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
          _os_log_impl(&dword_181A5C000, v35, v36, "%{public}s called with null config", buf, 0xCu);
        }
      }

      else if (v65)
      {
        uint64_t v48 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v49 = type;
        BOOL v50 = os_log_type_enabled(v35, type);
        if (v48)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
            BOOL v69 = 2082;
            os_log_type_t v70 = v48;
            _os_log_impl( &dword_181A5C000,  v35,  v49,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v48);
          goto LABEL_83;
        }

        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
          _os_log_impl(&dword_181A5C000, v35, v49, "%{public}s called with null config, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v58 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v68 = "nw_connection_create_experimental_probe_configuration_block_for_protocol_locked";
          _os_log_impl( &dword_181A5C000,  v35,  v58,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        free(v40);
        goto LABEL_89;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v41 = (os_log_s *)(id)gLogObj;
      os_log_type_t v63 = v149[0];
      if (os_log_type_enabled(v41, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_connected_socket";
        _os_log_impl( &dword_181A5C000,  v41,  v63,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_76;
  }

  *((_DWORD *)v28 + 29) = 2;
  uint64_t v30 = v28[9];
  os_log_type_t v31 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
  *((_BYTE *)v31 + 32) = *((_BYTE *)v31 + 32) & 0xFC | (v30 == 0LL) | 2;
  __int16 v32 = v29[31];
  v29[31] = v31;

  if (a5)
  {
    os_log_type_t v33 = v133;
    uint64_t v34 = (*(_WORD *)(v33[13] + 100LL) & 0x10) == 0;
  }

  else
  {
    uint64_t v34 = 0;
  }

  char v43 = v29[31];
  BOOL v44 = v135;
  if (v43)
  {
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_endpoint_flow_set_pre_connected_fd_block_invoke;
    *(void *)&_BYTE buf[24] = &unk_189BC7898;
    BOOL v45 = v43;
    *(void *)v144 = v45;
    if ((nw_fd_wrapper_get_fd(v44, buf) & 1) != 0)
    {
      *((_BYTE *)v45 + 34) |= 0x40u;
      objc_storeStrong((id *)v45 + 111, a1);
      if (v34) {
        __int16 v46 = 64;
      }
      else {
        __int16 v46 = 0;
      }
      *((_BYTE *)v45 + 35) = *((_BYTE *)v45 + 35) & 0xBF | v46;
LABEL_40:

      goto LABEL_41;
    }

    __nwlog_obj();
    os_log_type_t v103 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v149 = 136446466;
    v150 = "nw_endpoint_flow_set_pre_connected_fd";
    v151 = 2114;
    v152 = v44;
    v132 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v141 = 0;
    os_log_type_t v104 = (char *)v132;
    if ((__nwlog_fault(v132, &type, &v141) & 1) == 0)
    {
LABEL_230:
      if (v104) {
        free(v104);
      }
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v106 = type;
      if (os_log_type_enabled(v105, type))
      {
        *(_DWORD *)v149 = 136446466;
        v150 = "nw_endpoint_flow_set_pre_connected_fd";
        v151 = 2114;
        v152 = v44;
        _os_log_impl(&dword_181A5C000, v105, v106, "%{public}s invalid pre_connected_fd: %{public}@", v149, 0x16u);
      }
    }

    else
    {
      if (v141)
      {
        uint64_t v120 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v122 = type;
        v123 = os_log_type_enabled(v121, type);
        if (v120)
        {
          if (v123)
          {
            *(_DWORD *)v149 = 136446722;
            v150 = "nw_endpoint_flow_set_pre_connected_fd";
            v151 = 2114;
            v152 = v44;
            v153 = 2082;
            v154 = v120;
            _os_log_impl( &dword_181A5C000,  v121,  v122,  "%{public}s invalid pre_connected_fd: %{public}@, dumping backtrace:%{public}s",  v149,  0x20u);
          }

          free(v120);
        }

        else
        {
          if (v123)
          {
            *(_DWORD *)v149 = 136446466;
            v150 = "nw_endpoint_flow_set_pre_connected_fd";
            v151 = 2114;
            v152 = v44;
            _os_log_impl( &dword_181A5C000,  v121,  v122,  "%{public}s invalid pre_connected_fd: %{public}@, no backtrace",  v149,  0x16u);
          }
        }

        goto LABEL_229;
      }

      __nwlog_obj();
      uint64_t v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int128 v127 = type;
      if (os_log_type_enabled(v105, type))
      {
        *(_DWORD *)v149 = 136446466;
        v150 = "nw_endpoint_flow_set_pre_connected_fd";
        v151 = 2114;
        v152 = v44;
        _os_log_impl( &dword_181A5C000,  v105,  v127,  "%{public}s invalid pre_connected_fd: %{public}@, backtrace limit exceeded",  v149,  0x16u);
      }
    }

LABEL_229:
    os_log_type_t v104 = (char *)v132;
    goto LABEL_230;
  }

  __nwlog_obj();
  int v99 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_set_pre_connected_fd";
  int v131 = (const char *)_os_log_send_and_compose_impl();

  v149[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  BOOL v100 = (char *)v131;
  if (__nwlog_fault(v131, v149, &type))
  {
    if (v149[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v102 = v149[0];
      if (os_log_type_enabled(v101, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_set_pre_connected_fd";
        _os_log_impl(&dword_181A5C000, v101, v102, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }

    else
    {
      if (type)
      {
        v116 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v118 = v149[0];
        os_log_type_t v119 = os_log_type_enabled(v117, (os_log_type_t)v149[0]);
        if (v116)
        {
          if (v119)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_set_pre_connected_fd";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v116;
            _os_log_impl( &dword_181A5C000,  v117,  v118,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v116);
        }

        else
        {
          if (v119)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_set_pre_connected_fd";
            _os_log_impl( &dword_181A5C000,  v117,  v118,  "%{public}s called with null endpoint_flow, no backtrace",  buf,  0xCu);
          }
        }

        goto LABEL_223;
      }

      __nwlog_obj();
      os_log_type_t v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v126 = v149[0];
      if (os_log_type_enabled(v101, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_set_pre_connected_fd";
        _os_log_impl( &dword_181A5C000,  v101,  v126,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_223:
    BOOL v100 = (char *)v131;
  }

  if (v100) {
    free(v100);
  }
LABEL_41:

  if (a5 && !nw_endpoint_flow_pre_attach_protocols(v29, 0LL))
  {
    if ((*((_BYTE *)v29 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v56 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)v29 + 268) & 1) != 0) {
          os_log_type_t v57 = "dry-run ";
        }
        else {
          os_log_type_t v57 = "";
        }
        uint64_t v58 = nw_endpoint_handler_copy_endpoint(v29);
        logging_description = nw_endpoint_get_logging_description(v58);
        os_log_type_t v60 = *((unsigned int *)v29 + 30);
        __int16 v130 = v57;
        uint64_t v129 = logging_description;
        else {
          BOOL v61 = off_189BBBBF0[v60];
        }
        __int16 v128 = v61;
        BOOL v64 = v29;
        os_log_type_t v65 = "path";
        switch(*((_DWORD *)v29 + 29))
        {
          case 0:
            break;
          case 1:
            os_log_type_t v65 = "resolver";
            break;
          case 2:
            os_log_type_t v65 = nw_endpoint_flow_mode_string(v29[31]);
            break;
          case 3:
            os_log_type_t v65 = "proxy";
            break;
          case 4:
            os_log_type_t v65 = "fallback";
            break;
          case 5:
            os_log_type_t v65 = "transform";
            break;
          default:
            os_log_type_t v65 = "unknown-mode";
            break;
        }

        BOOL v66 = v64 + 28;
        BOOL v67 = v64;
        os_unfair_lock_lock(v64 + 28);
        BOOL v68 = v67[8];
        os_unfair_lock_unlock(v66);

        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_connected_socket";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v29 + 21;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&_BYTE buf[24] = v130;
        *(_WORD *)v144 = 2082;
        *(void *)&v144[2] = v129;
        *(_WORD *)&v144[10] = 2082;
        *(void *)&v144[12] = v128;
        v145 = 2082;
        v146 = v65;
        v147 = 2114;
        v148 = v68;
        _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nw_endpoint_flow_pre_attach_protocols",  buf,  0x48u);
      }
    }

    nw_endpoint_handler_cancel(v29, 1LL, 0);
    goto LABEL_89;
  }

  int v47 = v29;
LABEL_90:

LABEL_91:
  BOOL v69 = (void *)v27[18];
  v27[18] = v47;

  os_log_type_t v70 = *(void *)(v22 + 16);
  if (v70 && !nw_path_parameters_get_logging_disabled(*(void *)(v70 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v71 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
    {
      os_log_type_t v72 = *(_DWORD *)(v22 + 448);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v72;
      *(_WORD *)&buf[18] = 2114;
      *(void *)&buf[20] = v135;
      _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] create connection to connected fd %{public}@",  buf,  0x1Cu);
    }
  }

  if (!v27[18])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v74 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
    os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();

    v149[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v149[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v37 = (os_log_s *)(id)gLogObj;
      BOOL v75 = v149[0];
      if (os_log_type_enabled(v37, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
        _os_log_impl( &dword_181A5C000,  v37,  v75,  "%{public}s nw_endpoint_handler_create_with_connected_socket failed",  buf,  0xCu);
      }

    goto LABEL_78;
  }

  if (!v8)
  {
    __nwlog_obj();
    __int16 v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v23 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null protocol", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (!v47)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v44 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v20,  v44,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_77;
    }

    os_log_type_t v31 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v32 = type;
    os_log_type_t v33 = os_log_type_enabled(v20, type);
    if (!v31)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v32, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v31;
      _os_log_impl( &dword_181A5C000,  v20,  v32,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_48;
  }

  if (!v9)
  {
    __nwlog_obj();
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v47 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v25, "%{public}s called with null metadata", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (!v47)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v45 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v20,  v45,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_77;
    }

    os_log_type_t v31 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v34 = type;
    BOOL v35 = os_log_type_enabled(v20, type);
    if (!v31)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v20, v34, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }

      goto LABEL_77;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_deliver_metadata_changed_event_on_nw_queue";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v31;
      _os_log_impl( &dword_181A5C000,  v20,  v34,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
    }
  }

      if (v8) {
        free(v8);
      }
      return 0LL;
    }

    if (!v22)
    {
      id v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
        BOOL v11 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    uint64_t v19 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
        BOOL v11 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_webtransport_session_connect";
      char v26 = 2082;
      __int16 v27 = backtrace_string;
      __int16 v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_56;
    }

    if (v31) {
      free(v31);
    }
    *(_DWORD *)(v173 + 456) = 0;
    id v5 = &qword_18C45F000;
    goto LABEL_80;
  }

  if (*(char **)(v173 + 416) == handle)
  {
    if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v163 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
        {
          v164 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v164;
          _os_log_impl( &dword_181A5C000,  v163,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Removing placeholder stream for session",  buf,  0x26u);
        }
      }
    }

    *(void *)(v173 + 416) = 0LL;
  }

  else if (*(char **)(v173 + 424) == handle)
  {
    if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v165 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
        {
          v166 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v166;
          _os_log_impl( &dword_181A5C000,  v165,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Removing datagram stream for session",  buf,  0x26u);
        }
      }
    }

    *(void *)(v173 + 424) = 0LL;
  }

  else
  {
    *(void *)os_log_type_t type = *((void *)handle + 8);
    uint64_t node = nw_hash_table_get_node(*(void *)(v173 + 184), (uint64_t)type, 8LL);
    if (node)
    {
      if (!nw_hash_table_remove_node(*(void *)(v173 + 184), node) && (*(_BYTE *)(v173 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          __int16 v16 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v16;
          *(_WORD *)&v193[4] = 2048;
          *(void *)&v193[6] = *(void *)type;
          os_log_type_t v17 = "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table";
LABEL_57:
          uint64_t v37 = (os_log_s *)v15;
          uint64_t v38 = OS_LOG_TYPE_ERROR;
          os_log_type_t v39 = 48;
LABEL_58:
          _os_log_impl(&dword_181A5C000, v37, v38, v17, buf, v39);
        }
      }
    }

    else if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v15 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v36 = *(_DWORD *)(v173 + 460);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_stream";
        v188 = 2082;
        v189 = (const char *)(v173 + 464);
        v190 = 2080;
        v191 = (uint64_t)" ";
        v192 = 1024;
        *(_DWORD *)v193 = v36;
        *(_WORD *)&v193[4] = 2048;
        *(void *)&v193[6] = *(void *)type;
        os_log_type_t v17 = "%{public}s %{public}s%s<i%u> called remove_input_handler with stream id %lld, but no stream found";
        goto LABEL_57;
      }
    }
  }

  PBDataWriterWriteBOOLField();
  has = (__int16)self->_has;
  if ((has & 0x4000) == 0)
  {
LABEL_22:
    if ((has & 0x1000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_79;
  }

    if (!v4) {
      return 0LL;
    }
    goto LABEL_33;
  }

  __break(1u);
  return result;
}

    if (!v22) {
      goto LABEL_29;
    }
    uint64_t v20 = (char *)v22;
    goto LABEL_28;
  }

  if (!v4)
  {
    __nwlog_obj();
    char v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "nw_necp_append_tlv";
    __int16 v22 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (__nwlog_fault(v22, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      if (!v41)
      {
        __nwlog_obj();
        BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond, backtrace limit exceeded";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v24 = type;
      os_log_type_t v33 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond, no backtrace";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      if (!v33) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2082;
      *(void *)__int16 v46 = backtrace_string;
      __int16 v32 = "%{public}s called with null beyond, dumping backtrace:%{public}s";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v23, v24, v32, buf, 0x16u);
LABEL_52:

      free(backtrace_string);
      goto LABEL_77;
    }

    goto LABEL_77;
  }

  BOOL v7 = (v6 + 1);
  if (v5 >= v4)
  {
    __nwlog_obj();
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v4;
    *(_WORD *)&v47[8] = 1024;
    *(_DWORD *)uint64_t v48 = 13;
    *(_WORD *)&v48[4] = 1024;
    *(_DWORD *)&v48[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 13;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }

    else if (v41)
    {
      id v14 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      uint64_t v34 = os_log_type_enabled(v10, type);
      if (v14)
      {
        if (!v34) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136447490;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 2048;
        *(void *)__int16 v46 = v5;
        *(_WORD *)&v46[8] = 2048;
        *(void *)int v47 = v4;
        *(_WORD *)&v47[8] = 1024;
        *(_DWORD *)uint64_t v48 = 13;
        *(_WORD *)&v48[4] = 1024;
        *(_DWORD *)&v48[6] = v7;
        *(_WORD *)BOOL v49 = 2082;
        *(void *)&v49[2] = v14;
        __int16 v16 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s";
        os_log_type_t v17 = v10;
        uint64_t v18 = v28;
        uint64_t v19 = 54;
LABEL_17:
        _os_log_impl(&dword_181A5C000, v17, v18, v16, buf, v19);
LABEL_18:

        free(v14);
        goto LABEL_19;
      }

      if (!v34) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 13;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 13;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }

    uint64_t v38 = v10;
    os_log_type_t v39 = v28;
    os_log_type_t v40 = 44;
LABEL_87:
    _os_log_impl(&dword_181A5C000, v38, v39, v29, buf, v40);
    goto LABEL_88;
  }

  if (v4 - v5 < v7 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v7 + 5;
    *(_WORD *)&v47[8] = 2048;
    *(void *)uint64_t v48 = v4;
    *(_WORD *)&v48[8] = 1024;
    *(_DWORD *)BOOL v49 = 13;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 13;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
      goto LABEL_25;
    }

    if (!v41)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 13;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_25;
    }

    id v14 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    BOOL v11 = type;
    id v15 = os_log_type_enabled(v10, type);
    if (!v14)
    {
      if (!v15) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 13;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0x36u);
LABEL_26:

      if (!v9)
      {
LABEL_29:
        os_log_type_t v13 = 0LL;
        goto LABEL_30;
      }

      goto LABEL_27;
    }

    if (!v15) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136447746;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v7 + 5;
    *(_WORD *)&v47[8] = 2048;
    *(void *)uint64_t v48 = v4;
    *(_WORD *)&v48[8] = 1024;
    *(_DWORD *)BOOL v49 = 13;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v7;
    BOOL v50 = 2082;
    os_log_type_t v51 = v14;
    __int16 v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s";
    os_log_type_t v17 = v10;
    uint64_t v18 = v11;
    uint64_t v19 = 64;
    goto LABEL_17;
  }

  *(_BYTE *)id v5 = 13;
  *(_DWORD *)(v5 + 1) = v7;
  if (v6 != -1)
  {
    if (__s)
    {
      memcpy((void *)(v5 + 5), __s, v7);
      goto LABEL_12;
    }

    __nwlog_obj();
    BOOL v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 1024;
    *(_DWORD *)__int16 v46 = 13;
    *(_WORD *)&v46[4] = 1024;
    *(_DWORD *)&v46[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (!__nwlog_fault(v9, &type, &v41))
    {
LABEL_19:
      if (!v9) {
        goto LABEL_29;
      }
LABEL_27:
      uint64_t v20 = (char *)v9;
LABEL_28:
      free(v20);
      goto LABEL_29;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 13;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL";
LABEL_86:
        uint64_t v38 = v10;
        os_log_type_t v39 = v36;
        os_log_type_t v40 = 24;
        goto LABEL_87;
      }
    }

    else
    {
      if (v41)
      {
        id v14 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        uint64_t v37 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (!v37) {
            goto LABEL_18;
          }
          *(_DWORD *)buf = 136446978;
          BOOL v44 = "nw_necp_append_tlv";
          BOOL v45 = 1024;
          *(_DWORD *)__int16 v46 = 13;
          *(_WORD *)&v46[4] = 1024;
          *(_DWORD *)&v46[6] = v7;
          *(_WORD *)int v47 = 2082;
          *(void *)&v47[2] = v14;
          __int16 v16 = "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s";
          os_log_type_t v17 = v10;
          uint64_t v18 = v36;
          uint64_t v19 = 34;
          goto LABEL_17;
        }

        if (!v37) {
          goto LABEL_88;
        }
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 13;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL, no backtrace";
        goto LABEL_86;
      }

      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 13;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded";
        goto LABEL_86;
      }
    }

    if (!v22) {
      goto LABEL_29;
    }
    uint64_t v20 = (char *)v22;
    goto LABEL_28;
  }

  if (!v4)
  {
    __nwlog_obj();
    char v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "nw_necp_append_tlv";
    __int16 v22 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (__nwlog_fault(v22, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      if (!v41)
      {
        __nwlog_obj();
        BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond, backtrace limit exceeded";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v24 = type;
      os_log_type_t v33 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond, no backtrace";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      if (!v33) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2082;
      *(void *)__int16 v46 = backtrace_string;
      __int16 v32 = "%{public}s called with null beyond, dumping backtrace:%{public}s";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v23, v24, v32, buf, 0x16u);
LABEL_52:

      free(backtrace_string);
      goto LABEL_77;
    }

    goto LABEL_77;
  }

  BOOL v7 = (v6 + 1);
  if (v5 >= v4)
  {
    __nwlog_obj();
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v4;
    *(_WORD *)&v47[8] = 1024;
    *(_DWORD *)uint64_t v48 = 14;
    *(_WORD *)&v48[4] = 1024;
    *(_DWORD *)&v48[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 14;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }

    else if (v41)
    {
      id v14 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      uint64_t v34 = os_log_type_enabled(v10, type);
      if (v14)
      {
        if (!v34) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136447490;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 2048;
        *(void *)__int16 v46 = v5;
        *(_WORD *)&v46[8] = 2048;
        *(void *)int v47 = v4;
        *(_WORD *)&v47[8] = 1024;
        *(_DWORD *)uint64_t v48 = 14;
        *(_WORD *)&v48[4] = 1024;
        *(_DWORD *)&v48[6] = v7;
        *(_WORD *)BOOL v49 = 2082;
        *(void *)&v49[2] = v14;
        __int16 v16 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s";
        os_log_type_t v17 = v10;
        uint64_t v18 = v28;
        uint64_t v19 = 54;
LABEL_17:
        _os_log_impl(&dword_181A5C000, v17, v18, v16, buf, v19);
LABEL_18:

        free(v14);
        goto LABEL_19;
      }

      if (!v34) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 14;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 14;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }

    uint64_t v38 = v10;
    os_log_type_t v39 = v28;
    os_log_type_t v40 = 44;
LABEL_87:
    _os_log_impl(&dword_181A5C000, v38, v39, v29, buf, v40);
    goto LABEL_88;
  }

  if (v4 - v5 < v7 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v7 + 5;
    *(_WORD *)&v47[8] = 2048;
    *(void *)uint64_t v48 = v4;
    *(_WORD *)&v48[8] = 1024;
    *(_DWORD *)BOOL v49 = 14;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 14;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
      goto LABEL_25;
    }

    if (!v41)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 14;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_25;
    }

    id v14 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    BOOL v11 = type;
    id v15 = os_log_type_enabled(v10, type);
    if (!v14)
    {
      if (!v15) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 14;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0x36u);
LABEL_26:

      if (!v9)
      {
LABEL_29:
        os_log_type_t v13 = 0LL;
        goto LABEL_30;
      }

      goto LABEL_27;
    }

    if (!v15) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136447746;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v7 + 5;
    *(_WORD *)&v47[8] = 2048;
    *(void *)uint64_t v48 = v4;
    *(_WORD *)&v48[8] = 1024;
    *(_DWORD *)BOOL v49 = 14;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v7;
    BOOL v50 = 2082;
    os_log_type_t v51 = v14;
    __int16 v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s";
    os_log_type_t v17 = v10;
    uint64_t v18 = v11;
    uint64_t v19 = 64;
    goto LABEL_17;
  }

  *(_BYTE *)id v5 = 14;
  *(_DWORD *)(v5 + 1) = v7;
  if (v6 != -1)
  {
    if (__s)
    {
      memcpy((void *)(v5 + 5), __s, v7);
      goto LABEL_12;
    }

    __nwlog_obj();
    BOOL v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 1024;
    *(_DWORD *)__int16 v46 = 14;
    *(_WORD *)&v46[4] = 1024;
    *(_DWORD *)&v46[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (!__nwlog_fault(v9, &type, &v41))
    {
LABEL_19:
      if (!v9) {
        goto LABEL_29;
      }
LABEL_27:
      uint64_t v20 = (char *)v9;
LABEL_28:
      free(v20);
      goto LABEL_29;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 14;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL";
LABEL_86:
        uint64_t v38 = v10;
        os_log_type_t v39 = v36;
        os_log_type_t v40 = 24;
        goto LABEL_87;
      }
    }

    else
    {
      if (v41)
      {
        id v14 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        uint64_t v37 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (!v37) {
            goto LABEL_18;
          }
          *(_DWORD *)buf = 136446978;
          BOOL v44 = "nw_necp_append_tlv";
          BOOL v45 = 1024;
          *(_DWORD *)__int16 v46 = 14;
          *(_WORD *)&v46[4] = 1024;
          *(_DWORD *)&v46[6] = v7;
          *(_WORD *)int v47 = 2082;
          *(void *)&v47[2] = v14;
          __int16 v16 = "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s";
          os_log_type_t v17 = v10;
          uint64_t v18 = v36;
          uint64_t v19 = 34;
          goto LABEL_17;
        }

        if (!v37) {
          goto LABEL_88;
        }
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 14;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL, no backtrace";
        goto LABEL_86;
      }

      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 14;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded";
        goto LABEL_86;
      }
    }

    if (!v22) {
      goto LABEL_29;
    }
    uint64_t v20 = (char *)v22;
    goto LABEL_28;
  }

  if (!v4)
  {
    __nwlog_obj();
    char v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v44 = "nw_necp_append_tlv";
    __int16 v22 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (__nwlog_fault(v22, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      if (!v41)
      {
        __nwlog_obj();
        BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond, backtrace limit exceeded";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v24 = type;
      os_log_type_t v33 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v44 = "nw_necp_append_tlv";
          os_log_type_t v25 = "%{public}s called with null beyond, no backtrace";
          goto LABEL_75;
        }

        goto LABEL_76;
      }

      if (!v33) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2082;
      *(void *)__int16 v46 = backtrace_string;
      __int16 v32 = "%{public}s called with null beyond, dumping backtrace:%{public}s";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v23, v24, v32, buf, 0x16u);
LABEL_52:

      free(backtrace_string);
      goto LABEL_77;
    }

    goto LABEL_77;
  }

  BOOL v7 = (v6 + 1);
  if (v5 >= v4)
  {
    __nwlog_obj();
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v4;
    *(_WORD *)&v47[8] = 1024;
    *(_DWORD *)uint64_t v48 = 18;
    *(_WORD *)&v48[4] = 1024;
    *(_DWORD *)&v48[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 18;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }

    else if (v41)
    {
      id v14 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      uint64_t v34 = os_log_type_enabled(v10, type);
      if (v14)
      {
        if (!v34) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136447490;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 2048;
        *(void *)__int16 v46 = v5;
        *(_WORD *)&v46[8] = 2048;
        *(void *)int v47 = v4;
        *(_WORD *)&v47[8] = 1024;
        *(_DWORD *)uint64_t v48 = 18;
        *(_WORD *)&v48[4] = 1024;
        *(_DWORD *)&v48[6] = v7;
        *(_WORD *)BOOL v49 = 2082;
        *(void *)&v49[2] = v14;
        __int16 v16 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s";
        os_log_type_t v17 = v10;
        uint64_t v18 = v28;
        uint64_t v19 = 54;
LABEL_17:
        _os_log_impl(&dword_181A5C000, v17, v18, v16, buf, v19);
LABEL_18:

        free(v14);
        goto LABEL_19;
      }

      if (!v34) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 18;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_88;
      }
      *(_DWORD *)buf = 136447234;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v4;
      *(_WORD *)&v47[8] = 1024;
      *(_DWORD *)uint64_t v48 = 18;
      *(_WORD *)&v48[4] = 1024;
      *(_DWORD *)&v48[6] = v7;
      os_log_type_t v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }

    uint64_t v38 = v10;
    os_log_type_t v39 = v28;
    os_log_type_t v40 = 44;
LABEL_87:
    _os_log_impl(&dword_181A5C000, v38, v39, v29, buf, v40);
    goto LABEL_88;
  }

  if (v4 - v5 < v7 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v7 + 5;
    *(_WORD *)&v47[8] = 2048;
    *(void *)uint64_t v48 = v4;
    *(_WORD *)&v48[8] = 1024;
    *(_DWORD *)BOOL v49 = 18;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 18;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
      goto LABEL_25;
    }

    if (!v41)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 18;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_25;
    }

    id v14 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    BOOL v11 = type;
    id v15 = os_log_type_enabled(v10, type);
    if (!v14)
    {
      if (!v15) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      BOOL v44 = "nw_necp_append_tlv";
      BOOL v45 = 2048;
      *(void *)__int16 v46 = v5;
      *(_WORD *)&v46[8] = 2048;
      *(void *)int v47 = v7 + 5;
      *(_WORD *)&v47[8] = 2048;
      *(void *)uint64_t v48 = v4;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)BOOL v49 = 18;
      *(_WORD *)&v49[4] = 1024;
      *(_DWORD *)&v49[6] = v7;
      char v12 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
LABEL_25:
      _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0x36u);
LABEL_26:

      if (!v9)
      {
LABEL_29:
        os_log_type_t v13 = 0LL;
        goto LABEL_30;
      }

      goto LABEL_27;
    }

    if (!v15) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136447746;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 2048;
    *(void *)__int16 v46 = v5;
    *(_WORD *)&v46[8] = 2048;
    *(void *)int v47 = v7 + 5;
    *(_WORD *)&v47[8] = 2048;
    *(void *)uint64_t v48 = v4;
    *(_WORD *)&v48[8] = 1024;
    *(_DWORD *)BOOL v49 = 18;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = v7;
    BOOL v50 = 2082;
    os_log_type_t v51 = v14;
    __int16 v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s";
    os_log_type_t v17 = v10;
    uint64_t v18 = v11;
    uint64_t v19 = 64;
    goto LABEL_17;
  }

  *(_BYTE *)id v5 = 18;
  *(_DWORD *)(v5 + 1) = v7;
  if (v6 != -1)
  {
    if (__s)
    {
      memcpy((void *)(v5 + 5), __s, v7);
      goto LABEL_12;
    }

    __nwlog_obj();
    BOOL v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    BOOL v44 = "nw_necp_append_tlv";
    BOOL v45 = 1024;
    *(_DWORD *)__int16 v46 = 18;
    *(_WORD *)&v46[4] = 1024;
    *(_DWORD *)&v46[6] = v7;
    id v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (!__nwlog_fault(v9, &type, &v41))
    {
LABEL_19:
      if (!v9) {
        goto LABEL_29;
      }
LABEL_27:
      uint64_t v20 = (char *)v9;
LABEL_28:
      free(v20);
      goto LABEL_29;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 18;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL";
LABEL_86:
        uint64_t v38 = v10;
        os_log_type_t v39 = v36;
        os_log_type_t v40 = 24;
        goto LABEL_87;
      }
    }

    else
    {
      if (v41)
      {
        id v14 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        uint64_t v37 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (!v37) {
            goto LABEL_18;
          }
          *(_DWORD *)buf = 136446978;
          BOOL v44 = "nw_necp_append_tlv";
          BOOL v45 = 1024;
          *(_DWORD *)__int16 v46 = 18;
          *(_WORD *)&v46[4] = 1024;
          *(_DWORD *)&v46[6] = v7;
          *(_WORD *)int v47 = 2082;
          *(void *)&v47[2] = v14;
          __int16 v16 = "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s";
          os_log_type_t v17 = v10;
          uint64_t v18 = v36;
          uint64_t v19 = 34;
          goto LABEL_17;
        }

        if (!v37) {
          goto LABEL_88;
        }
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 18;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL, no backtrace";
        goto LABEL_86;
      }

      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        BOOL v44 = "nw_necp_append_tlv";
        BOOL v45 = 1024;
        *(_DWORD *)__int16 v46 = 18;
        *(_WORD *)&v46[4] = 1024;
        *(_DWORD *)&v46[6] = v7;
        os_log_type_t v29 = "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded";
        goto LABEL_86;
      }
    }

    goto LABEL_78;
  }

  id v14 = SecKeyCopyPublicKey(privateKeyRef);
  if (privateKeyRef)
  {
    CFRelease(privateKeyRef);
    privateKeyRef = 0LL;
  }

  if (!v14)
  {
    __nwlog_obj();
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v55 = "nw_utilities_public_key_info_for_sec_identity";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v28 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s called with null publicKey", buf, 0xCu);
      }

  if (v32)
  {
    free(v32);
    BOOL v21 = 0LL;
    goto LABEL_23;
  }

          free(v30);
          goto LABEL_78;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v25 = (id)gLogObj;
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_ws_create_client_request";
        char v26 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v80[0]) = 0;
        if (__nwlog_fault(v26, type, v80))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v27 = (os_log_s *)(id)gLogObj;
            char v28 = type[0];
            if (os_log_type_enabled(v27, type[0]))
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s CFURLCreateWithString failed", applier, 0xCu);
            }
  }

    if (v27) {
      free(v27);
    }
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v52 = "-[NWConcrete_nw_url_endpoint initWithURL:]";
    os_log_type_t v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v48 = 0;
    if (__nwlog_fault(v31, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v52 = "-[NWConcrete_nw_url_endpoint initWithURL:]";
          _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null _url", buf, 0xCu);
        }
      }

      else if (v48)
      {
        uint64_t v37 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v38 = type;
        os_log_type_t v39 = os_log_type_enabled(v32, type);
        if (v37)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v52 = "-[NWConcrete_nw_url_endpoint initWithURL:]";
            int v53 = 2082;
            uint64_t v54 = v37;
            _os_log_impl( &dword_181A5C000,  v32,  v38,  "%{public}s called with null _url, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v37);
          goto LABEL_82;
        }

        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v52 = "-[NWConcrete_nw_url_endpoint initWithURL:]";
          _os_log_impl(&dword_181A5C000, v32, v38, "%{public}s called with null _url, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v47 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v52 = "-[NWConcrete_nw_url_endpoint initWithURL:]";
          _os_log_impl( &dword_181A5C000,  v32,  v47,  "%{public}s called with null _url, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  v59 = v38->u32[0];
  os_log_type_t v60 = v38->u32[1];
  ++v38;
  v37 += v59 + v60;
  if ((v23 & 4) == 0)
  {
LABEL_66:
    if ((v23 & 2) == 0) {
      goto LABEL_67;
    }
LABEL_79:
    uint64_t v62 = v38->u16[0];
    uint64_t v38 = (uint32x2_t *)((char *)v38 + 2);
    v37 += v62;
    if ((v23 & 1) == 0) {
      goto LABEL_69;
    }
    goto LABEL_68;
  }

      free(backtrace_string);
      goto LABEL_104;
    }

    if (!v39) {
      goto LABEL_104;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v45 = "nw_protocol_common_updated_path";
    os_log_type_t v31 = "%{public}s called with null path, no backtrace";
LABEL_103:
    _os_log_impl(&dword_181A5C000, v29, v30, v31, buf, 0xCu);
LABEL_104:
    if (v28) {
      free(v28);
    }
    return 0LL;
  }

  id v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v16 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v45 = "nw_protocol_common_updated_path";
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s updated_path requires an output handler",  buf,  0xCu);
    }

    return 0LL;
  }

  id v5 = *(void **)(v4 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    BOOL v6 = *(void *)(v4 + 88);
    if (v6) {
      *(void *)(v4 + 8_Block_object_dispose(va, 8) = v6 + 1;
    }
  }

  BOOL v7 = *(void **)(a2 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v8 = *(void *)(a2 + 88);
    if (v8) {
      *(void *)(a2 + 8_Block_object_dispose(va, 8) = v8 + 1;
    }
  }

  id v9 = *(void *)(v4 + 24);
  if (!v9 || (os_log_type_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 168)) == 0LL)
  {
    __nwlog_obj();
    __int16 v22 = *(const char **)(v4 + 16);
    *(_DWORD *)buf = 136446722;
    BOOL v45 = "__nw_protocol_updated_path";
    if (!v22) {
      __int16 v22 = "invalid";
    }
    __int16 v46 = 2082;
    int v47 = (void *)v22;
    uint64_t v48 = 2048;
    BOOL v49 = v4;
    BOOL v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v42 = 0;
    if (__nwlog_fault(v23, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (!os_log_type_enabled(v24, type)) {
          goto LABEL_93;
        }
        char v26 = *(const char **)(v4 + 16);
        if (!v26) {
          char v26 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        BOOL v45 = "__nw_protocol_updated_path";
        __int16 v46 = 2082;
        int v47 = (void *)v26;
        uint64_t v48 = 2048;
        BOOL v49 = v4;
        __int16 v27 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback";
LABEL_92:
        _os_log_impl(&dword_181A5C000, v24, v25, v27, buf, 0x20u);
        goto LABEL_93;
      }

      if (!v42)
      {
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (!os_log_type_enabled(v24, type)) {
          goto LABEL_93;
        }
        os_log_type_t v40 = *(const char **)(v4 + 16);
        if (!v40) {
          os_log_type_t v40 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        BOOL v45 = "__nw_protocol_updated_path";
        __int16 v46 = 2082;
        int v47 = (void *)v40;
        uint64_t v48 = 2048;
        BOOL v49 = v4;
        __int16 v27 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded";
        goto LABEL_92;
      }

      __int16 v32 = (char *)__nw_create_backtrace_string();
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      os_log_type_t v33 = os_log_type_enabled(v24, type);
      if (!v32)
      {
        if (!v33) {
          goto LABEL_93;
        }
        uint64_t v41 = *(const char **)(v4 + 16);
        if (!v41) {
          uint64_t v41 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        BOOL v45 = "__nw_protocol_updated_path";
        __int16 v46 = 2082;
        int v47 = (void *)v41;
        uint64_t v48 = 2048;
        BOOL v49 = v4;
        __int16 v27 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback, no backtrace";
        goto LABEL_92;
      }

      if (v33)
      {
        uint64_t v34 = *(const char **)(v4 + 16);
        if (!v34) {
          uint64_t v34 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        BOOL v45 = "__nw_protocol_updated_path";
        __int16 v46 = 2082;
        int v47 = (void *)v34;
        uint64_t v48 = 2048;
        BOOL v49 = v4;
        BOOL v50 = 2082;
        os_log_type_t v51 = v32;
        _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s protocol %{public}s (%p) has invalid updated_path callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v32);
    }

      if (v26)
      {
        os_log_type_t v33 = (char *)v26;
        goto LABEL_86;
      }

      return 0LL;
    }

    uint64_t v19 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    os_log_type_t v70 = "nw_nat64_write_prefix_to_string";
    os_log_type_t v71 = 1024;
    *(_DWORD *)os_log_type_t v72 = v19;
    os_log_type_t v39 = (const char *)_os_log_send_and_compose_impl();

    BOOL v68 = OS_LOG_TYPE_ERROR;
    BOOL v67 = 0;
    if (v68 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v21 = (os_log_s *)(id)gLogObj;
      __int16 v22 = v68;
      if (os_log_type_enabled(v21, v68))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v70 = "nw_nat64_write_prefix_to_string";
        os_log_type_t v71 = 1024;
        *(_DWORD *)os_log_type_t v72 = v19;
        BOOL v23 = "%{public}s inet_ntop failed %{darwin.errno}d";
LABEL_65:
        uint64_t v52 = v21;
        int v53 = v22;
LABEL_66:
        uint64_t v54 = 18;
LABEL_67:
        _os_log_impl(&dword_181A5C000, v52, v53, v23, buf, v54);
      }
    }

    else if (v67)
    {
      uint64_t v34 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v21 = (os_log_s *)(id)gLogObj;
      BOOL v35 = v68;
      os_log_type_t v36 = os_log_type_enabled(v21, v68);
      if (v34)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v70 = "nw_nat64_write_prefix_to_string";
          os_log_type_t v71 = 1024;
          *(_DWORD *)os_log_type_t v72 = v19;
          *(_WORD *)&v72[4] = 2082;
          *(void *)&v72[6] = v34;
          _os_log_impl( &dword_181A5C000,  v21,  v35,  "%{public}s inet_ntop failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v34);
        goto LABEL_84;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v70 = "nw_nat64_write_prefix_to_string";
        os_log_type_t v71 = 1024;
        *(_DWORD *)os_log_type_t v72 = v19;
        BOOL v23 = "%{public}s inet_ntop failed %{darwin.errno}d, no backtrace";
        uint64_t v52 = v21;
        int v53 = v35;
        goto LABEL_66;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v21 = (os_log_s *)(id)gLogObj;
      __int16 v22 = v68;
      if (os_log_type_enabled(v21, v68))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v70 = "nw_nat64_write_prefix_to_string";
        os_log_type_t v71 = 1024;
        *(_DWORD *)os_log_type_t v72 = v19;
        BOOL v23 = "%{public}s inet_ntop failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_65;
      }
    }
  }

      if (v38) {
        free(v38);
      }
      uint64_t v42 = 0x10000;
      goto LABEL_80;
    }

    os_log_type_t v25 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v26 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v71 = "nw_socket_get_output_frames";
      os_log_type_t v72 = 2080;
      *(void *)BOOL v73 = (char *)a1 + 404;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v25;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %s getsockopt SO_NWRITE failed %{darwin.errno}d",  buf,  0x1Cu);
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v71 = "nw_socket_get_output_frames";
    os_log_type_t v72 = 1024;
    *(_DWORD *)BOOL v73 = v25;
    __int16 v27 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v66) = 0;
    if (__nwlog_fault(v27, type, &v66))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        char v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          os_log_type_t v72 = 1024;
          *(_DWORD *)BOOL v73 = v25;
          uint64_t v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d";
LABEL_53:
          BOOL v35 = v28;
LABEL_54:
          _os_log_impl(&dword_181A5C000, v35, v29, v30, buf, 0x12u);
        }
      }

      else if ((_BYTE)v66)
      {
        __int16 v32 = (char *)__nw_create_backtrace_string();
        os_log_type_t v33 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type[0];
        log = v33;
        uint64_t v34 = os_log_type_enabled(v33, type[0]);
        if (v32)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v71 = "nw_socket_get_output_frames";
            os_log_type_t v72 = 1024;
            *(_DWORD *)BOOL v73 = v25;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = v32;
            _os_log_impl( &dword_181A5C000,  log,  v29,  "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v32);
          goto LABEL_55;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          os_log_type_t v72 = 1024;
          *(_DWORD *)BOOL v73 = v25;
          uint64_t v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, no backtrace";
          BOOL v35 = log;
          goto LABEL_54;
        }
      }

      else
      {
        char v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          os_log_type_t v72 = 1024;
          *(_DWORD *)BOOL v73 = v25;
          uint64_t v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_53;
        }
      }
    }

      goto LABEL_89;
    }

    if (!(_BYTE)v75)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      uint64_t v42 = type[0];
      if (os_log_type_enabled(v19, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v81 = "nw_path_create_evaluator_for_client_id";
        os_log_type_t v82 = 1024;
        LODWORD(v83[0]) = v7;
        _os_log_impl( &dword_181A5C000,  v19,  v42,  "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
      }

      goto LABEL_77;
    }

    BOOL v21 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (os_log_s *)(id)gLogObj;
    uint64_t v24 = type[0];
    os_log_type_t v25 = os_log_type_enabled(v19, type[0]);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v81 = "nw_path_create_evaluator_for_client_id";
        os_log_type_t v82 = 1024;
        LODWORD(v83[0]) = v7;
        _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, no backtrace",  buf,  0x12u);
      }

      goto LABEL_77;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v81 = "nw_path_create_evaluator_for_client_id";
      os_log_type_t v82 = 1024;
      LODWORD(v83[0]) = v7;
      WORD2(v83[0]) = 2082;
      *(void *)((char *)v83 + 6) = v21;
      _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s NECP_CLIENT_ACTION_CLAIM %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

LABEL_34:
    free(v21);
    if (!v11) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }

LABEL_78:
        if (!v8) {
          return 0LL;
        }
LABEL_79:
        free(v8);
        return 0LL;
      }

      if (v80[0] == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v9 = (os_log_s *)(id)gLogObj;
        char v26 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v3;
          _os_log_impl( &dword_181A5C000,  v9,  v26,  "%{public}s Path observer result cannot hold update header (%d), backtrace limit exceeded",  (uint8_t *)out,  0x12u);
        }

        goto LABEL_77;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      id v15 = type[0];
      __int16 v16 = os_log_type_enabled(v9, type[0]);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)out = 136446466;
          *(void *)&out[4] = "nw_path_observer_update_block_invoke";
          *(_WORD *)&out[12] = 1024;
          *(_DWORD *)&out[14] = v3;
          _os_log_impl( &dword_181A5C000,  v9,  v15,  "%{public}s Path observer result cannot hold update header (%d), no backtrace",  (uint8_t *)out,  0x12u);
        }

        goto LABEL_77;
      }

      if (v16)
      {
        *(_DWORD *)out = 136446722;
        *(void *)&out[4] = "nw_path_observer_update_block_invoke";
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v3;
        *(_WORD *)&out[18] = 2082;
        *(void *)&out[20] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v15,  "%{public}s Path observer result cannot hold update header (%d), dumping backtrace:%{public}s",  (uint8_t *)out,  0x1Cu);
      }
    }

    free(backtrace_string);
    if (!v8) {
      return 0LL;
    }
    goto LABEL_79;
  }

  uuid_unparse(uu, out);
  if (v86 != 3)
  {
    if (v86 != 2)
    {
      if (v86 == 1)
      {
        obj = 0LL;
        *(void *)int v80 = 0LL;
        uint64_t v77 = 0LL;
        BOOL v78 = 0LL;
        id v4 = nw_parameters_create();
        id v5 = v4;
        if (v4)
        {
          BOOL v76 = 0;
          *(_WORD *)BOOL v75 = 0;
          v74 = 0;
          if ((nw_path_parse_necp_parameters( v4,  (void **)v80,  &obj,  &v78,  &v77,  &v76,  v75,  (char *)&v74 + 1,  &v74,  (uint64_t)v87,  v3 - 4LL) & 1) != 0)
          {
            if (v78) {
              browse = nw_path_create_browse(v78, v5);
            }
            else {
              browse = nw_path_create(*(void **)v80, v5);
            }
            uint64_t v52 = browse;
            if (browse)
            {
              objc_storeStrong((id *)&browse->group_descriptor, obj);
              objc_storeStrong((id *)&v52->advertise_descriptor, v77);
              int v53 = *((_BYTE *)v52 + 475) & 0xFC | v76;
              v52->custom_etheros_log_type_t type = *(_WORD *)v75;
              v52->custom_ip_protocol = HIBYTE(v74);
              *((_BYTE *)v52 + 475) = v53 | (2 * v74);
              *(_OWORD *)v52->client_id = *(_OWORD *)uu;
              nw_dictionary_set_value(*(void *)(a1[4] + 24LL), out, v52);
LABEL_149:

LABEL_150:
              return 0LL;
            }

            __nwlog_obj();
            uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)os_log_type_t type = 136446210;
            os_log_type_t v82 = "nw_path_observer_update_block_invoke";
            os_log_type_t v55 = (char *)_os_log_send_and_compose_impl();

            BOOL v73 = OS_LOG_TYPE_ERROR;
            os_log_type_t v72 = 0;
            if (__nwlog_fault(v55, &v73, &v72))
            {
              if (v73 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                int v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v57 = v73;
                if (os_log_type_enabled(v56, v73))
                {
                  *(_DWORD *)os_log_type_t type = 136446210;
                  os_log_type_t v82 = "nw_path_observer_update_block_invoke";
                  _os_log_impl(&dword_181A5C000, v56, v57, "%{public}s nw_path_create failed", (uint8_t *)type, 0xCu);
                }
              }

              else if (v72)
              {
                os_log_type_t v65 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                int v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                BOOL v66 = v73;
                BOOL v67 = os_log_type_enabled(v56, v73);
                if (v65)
                {
                  if (v67)
                  {
                    *(_DWORD *)os_log_type_t type = 136446466;
                    os_log_type_t v82 = "nw_path_observer_update_block_invoke";
                    char v83 = 2082;
                    uint64_t v84 = v65;
                    _os_log_impl( &dword_181A5C000,  v56,  v66,  "%{public}s nw_path_create failed, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
                  }

                  free(v65);
                  goto LABEL_147;
                }

                if (v67)
                {
                  *(_DWORD *)os_log_type_t type = 136446210;
                  os_log_type_t v82 = "nw_path_observer_update_block_invoke";
                  _os_log_impl( &dword_181A5C000,  v56,  v66,  "%{public}s nw_path_create failed, no backtrace",  (uint8_t *)type,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                int v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v70 = v73;
                if (os_log_type_enabled(v56, v73))
                {
                  *(_DWORD *)os_log_type_t type = 136446210;
                  os_log_type_t v82 = "nw_path_observer_update_block_invoke";
                  _os_log_impl( &dword_181A5C000,  v56,  v70,  "%{public}s nw_path_create failed, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
                }
              }
            }

  __break(1u);
  return result;
}

    if (v27) {
      free(v27);
    }
    goto LABEL_6;
  }

  __break(1u);
  return result;
}

        if (v21) {
          free(v21);
        }
        return 4294966775LL;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v13 = *(_DWORD *)(a3 + 368);
      *(_DWORD *)buf = 136446978;
      BOOL v64 = "before_frame_send_callback";
      os_log_type_t v65 = 2082;
      *(void *)BOOL v66 = a3 + 390;
      *(_WORD *)&v66[8] = 2080;
      *(void *)&v66[10] = " ";
      BOOL v67 = 1024;
      BOOL v68 = v13;
      id v14 = (const char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      uint64_t v62 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v14, type, &v62))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v15 = (os_log_s *)gconnectionLogObj;
          __int16 v16 = type[0];
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          {
            os_log_type_t v17 = *(_DWORD *)(a3 + 368);
            *(_DWORD *)buf = 136446978;
            BOOL v64 = "before_frame_send_callback";
            os_log_type_t v65 = 2082;
            *(void *)BOOL v66 = a3 + 390;
            *(_WORD *)&v66[8] = 2080;
            *(void *)&v66[10] = " ";
            BOOL v67 = 1024;
            BOOL v68 = v17;
            uint64_t v18 = "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection";
LABEL_65:
            _os_log_impl(&dword_181A5C000, v15, v16, v18, buf, 0x26u);
          }
        }

        else if (v62)
        {
          __int16 v27 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v15 = (os_log_s *)gconnectionLogObj;
          __int16 v16 = type[0];
          char v28 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
          if (!v27)
          {
            if (!v28) {
              goto LABEL_66;
            }
            uint64_t v38 = *(_DWORD *)(a3 + 368);
            *(_DWORD *)buf = 136446978;
            BOOL v64 = "before_frame_send_callback";
            os_log_type_t v65 = 2082;
            *(void *)BOOL v66 = a3 + 390;
            *(_WORD *)&v66[8] = 2080;
            *(void *)&v66[10] = " ";
            BOOL v67 = 1024;
            BOOL v68 = v38;
            uint64_t v18 = "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection, no backtrace";
            goto LABEL_65;
          }

          if (v28)
          {
            os_log_type_t v29 = *(_DWORD *)(a3 + 368);
            *(_DWORD *)buf = 136447234;
            BOOL v64 = "before_frame_send_callback";
            os_log_type_t v65 = 2082;
            *(void *)BOOL v66 = a3 + 390;
            *(_WORD *)&v66[8] = 2080;
            *(void *)&v66[10] = " ";
            BOOL v67 = 1024;
            BOOL v68 = v29;
            BOOL v69 = 2082;
            v70[0] = v27;
            _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection, dumping bac ktrace:%{public}s",  buf,  0x30u);
          }

          free(v27);
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v15 = (os_log_s *)gconnectionLogObj;
          __int16 v16 = type[0];
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          {
            uint64_t v34 = *(_DWORD *)(a3 + 368);
            *(_DWORD *)buf = 136446978;
            BOOL v64 = "before_frame_send_callback";
            os_log_type_t v65 = 2082;
            *(void *)BOOL v66 = a3 + 390;
            *(_WORD *)&v66[8] = 2080;
            *(void *)&v66[10] = " ";
            BOOL v67 = 1024;
            BOOL v68 = v34;
            uint64_t v18 = "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection, backtra"
                  "ce limit exceeded";
            goto LABEL_65;
          }
        }
      }

  if (v37) {
    free(v37);
  }
  int v47 = v32 == -529;
  os_log_type_t v8 = &qword_18C45F000;
  a4 = v147;
  if (!v47) {
    goto LABEL_235;
  }
LABEL_81:
  id v15 = 0LL;
  uint64_t v48 = *(void *)(a3 + 16);
  *(void *)(v11 + 16) = v48;
  if (!v48) {
    uint64_t v48 = a3;
  }
  *(void *)(v48 + 24) = v14;
  *(void *)(a3 + 16) = v11;
  *(void *)(v11 + 24) = v9;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v49 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v51 = *(_DWORD *)(a3 + 176);
      BOOL v50 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)(a3 + 16), 0, buf);
      uint64_t v52 = *(_DWORD *)buf;
      *(_DWORD *)buf = 136447746;
      v153 = "nw_http2_drain_next_frame_for_stream";
      v154 = 2082;
      v155 = a3 + 191;
      v156 = 2080;
      *(void *)v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v50;
      v158 = 1024;
      v159 = v51;
      v160 = 2048;
      *(void *)v161 = v11;
      *(_WORD *)&v161[8] = 1024;
      v162 = v52;
      _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> couldn't send frame, prepending frame %p to waiting_output_frames, stream now h as %u bytes pending",  buf,  0x3Cu);
    }

    id v15 = 0LL;
    os_log_type_t v8 = &qword_18C45F000;
LABEL_90:
    a4 = v147;
  }

  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v38 = default_input_handler[1].callbacks;
    if (v38)
    {
      os_log_type_t v39 = (nw_protocol_callbacks *)((char *)v38 - 1);
      default_input_handler[1].callbacks = v39;
      if (!v39)
      {
        os_log_type_t v40 = *(void (***)(void))default_input_handler[1].flow_id;
        if (v40)
        {
          *(void *)default_input_handler[1].flow_id = 0LL;
          v40[2](v40);
          _Block_release(v40);
        }

        if ((default_input_handler[1].flow_id[8] & 1) != 0)
        {
          uint64_t v41 = *(const void **)default_input_handler[1].flow_id;
          if (v41) {
            _Block_release(v41);
          }
        }

        uint64_t v42 = default_input_handler;
        goto LABEL_88;
      }
    }
  }

    if (v36) {
      free(v36);
    }
    goto LABEL_79;
  }

  id v14 = v12;
  id v15 = bswap32(*(unsigned __int16 *)(v12 + 4)) >> 16;
  __int16 v16 = *(unsigned __int8 *)(v12 + 6);
  os_log_type_t v17 = *(unsigned __int8 *)(a1 + 156);
  if (v16 != v17)
  {
    uint64_t v42 = a1;
    uint64_t v18 = 0;
    uint64_t v20 = v15 + 40;
    uint64_t v19 = 40;
    while (1)
    {
      if (v16 > 43)
      {
        if (v16 == 60) {
          goto LABEL_22;
        }
        if (v16 != 44) {
          goto LABEL_26;
        }
        if ((unint64_t)v19 + 8 > v20)
        {
          char v26 = v15;
          if ((*(_BYTE *)(v42 + 158) & 1) == 0)
          {
            uint64_t v30 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136447234;
              uint64_t v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
              BOOL v49 = 2082;
              BOOL v50 = (const char *)(v42 + 159);
              os_log_type_t v51 = 2080;
              uint64_t v52 = " ";
              int v53 = 2048;
              uint64_t v54 = v42;
              os_log_type_t v55 = 2048;
              *(void *)int v56 = v20;
              a1 = v42;
              _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %lu",  buf,  0x34u);
              __int16 v16 = 44;
              goto LABEL_46;
            }
          }

          __int16 v16 = 44;
LABEL_45:
          a1 = v42;
          goto LABEL_46;
        }

        BOOL v21 = (unsigned __int8 *)(v12 + v19);
        __int16 v16 = *v21;
        if (a5) {
          *a5 = *((_DWORD *)v21 + 1);
        }
        if (a3) {
          *a3 = v21[3] & 1;
        }
        v19 += 8;
        if (a4) {
          *a4 = bswap32(*((_WORD *)v21 + 1) & 0xF8FF) >> 16;
        }
        uint64_t v18 = 1;
        if (v16 == v17)
        {
LABEL_25:
          __int16 v16 = v17;
LABEL_26:
          a1 = v42;
          goto LABEL_27;
        }
      }

      else
      {
        if (v16 && v16 != 43) {
          goto LABEL_26;
        }
LABEL_22:
        if ((unint64_t)v19 + 2 > v20)
        {
          char v26 = v15;
          if ((*(_BYTE *)(v42 + 158) & 1) == 0)
          {
            __int16 v27 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136447234;
              uint64_t v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
              BOOL v49 = 2082;
              BOOL v50 = (const char *)(v42 + 159);
              os_log_type_t v51 = 2080;
              uint64_t v52 = " ";
              int v53 = 2048;
              uint64_t v54 = v42;
              os_log_type_t v55 = 2048;
              *(void *)int v56 = v20;
              a1 = v42;
              _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p IPv6 extension header cannot fit in packet length %lu",  buf,  0x34u);
LABEL_46:
              uint64_t v24 = a7;
              LODWORD(v15) = v26;
              goto LABEL_28;
            }
          }

          goto LABEL_45;
        }

        __int16 v22 = (unsigned __int8 *)(v12 + v19);
        BOOL v23 = 8 * v22[1] + 8;
        if (v23 + v19 > v13)
        {
          char v28 = v15;
          if ((*(_BYTE *)(v42 + 158) & 1) != 0
            || (os_log_type_t v29 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)))
          {
            a1 = v42;
          }

          else
          {
            *(_DWORD *)buf = 136447490;
            uint64_t v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
            BOOL v49 = 2082;
            BOOL v50 = (const char *)(v42 + 159);
            os_log_type_t v51 = 2080;
            uint64_t v52 = " ";
            int v53 = 2048;
            uint64_t v54 = v42;
            os_log_type_t v55 = 1024;
            v56[0] = v23;
            LOWORD(v56[1]) = 2048;
            *(void *)((char *)&v56[1] + 2) = v20;
            a1 = v42;
            _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p IPv6 extension header length %u cannot fit in packet length %lu",  buf,  0x3Au);
          }

          uint64_t v24 = a7;
          LODWORD(v15) = v28;
          goto LABEL_28;
        }

        __int16 v16 = *v22;
        v19 += v23;
        if (v16 == v17) {
          goto LABEL_25;
        }
      }
    }
  }

  uint64_t v18 = 0;
  uint64_t v19 = 40;
LABEL_27:
  uint64_t v24 = a7;
LABEL_28:
  if (a6 && v24 && v16 == *(unsigned __int8 *)(a1 + 156))
  {
    *a6 = v14 + v19;
    *uint64_t v24 = v15 - v19 + 40;
  }

  return v18 & 1;
}

uint64_t nw_path_flow_registration_get_stats_region(void *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_path_flow_registration_get_stats_region";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null flow_registration", buf, 0xCu);
      }

      goto LABEL_42;
    }

    if (!v20)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl( &dword_181A5C000,  v9,  v18,  "%{public}s called with null flow_registration, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null flow_registration, no backtrace",  buf,  0xCu);
      }

      goto LABEL_42;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v23 = "nw_path_flow_registration_get_stats_region";
      __int16 v24 = 2082;
      os_log_type_t v25 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null flow_registration, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_30;
  }

  if (!a2)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_path_flow_registration_get_stats_region";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null protocol_identifier", buf, 0xCu);
      }

void nw_channel_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)&v26[13] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v24 = "nw_channel_get_message_properties";
    BOOL v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v24 = "nw_channel_get_message_properties";
      id v9 = "%{public}s called with null protocol";
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v24 = "nw_channel_get_message_properties";
          __int16 v25 = 2082;
          *(void *)uint64_t v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_46:
        if (!v6) {
          return;
        }
        goto LABEL_47;
      }

      if (!v15) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v24 = "nw_channel_get_message_properties";
      id v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v24 = "nw_channel_get_message_properties";
      id v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_path_flow_registration_get_advisory_region(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 10);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_flow_registration_get_advisory_region";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_flow_registration_get_advisory_region";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null flow_registration, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null flow_registration, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null flow_registration, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_path_get_tso_max_segment_size_v4(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_path_get_tso_max_segment_size_v4";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_path_get_tso_max_segment_size_v4";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v18 = "nw_path_get_tso_max_segment_size_v4";
            __int16 v19 = 2082;
            char v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_path_get_tso_max_segment_size_v4";
          _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_path_get_tso_max_segment_size_v4";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B480B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_ipv4_notify(uint64_t a1, uint64_t a2, unsigned int a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v49 = "nw_protocol_ipv4_notify";
    __int16 v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v23 = (os_log_s *)__nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v49 = "nw_protocol_ipv4_notify";
      __int16 v25 = "%{public}s called with null protocol";
    }

    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v23 = (os_log_s *)__nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v27 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v49 = "nw_protocol_ipv4_notify";
          __int16 v50 = 2082;
          os_log_type_t v51 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_131:
        if (!v22) {
          return;
        }
        goto LABEL_132;
      }

      if (!v27) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v49 = "nw_protocol_ipv4_notify";
      __int16 v25 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v23 = (os_log_s *)__nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v49 = "nw_protocol_ipv4_notify";
      __int16 v25 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_130;
  }

  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v49 = "nw_protocol_ipv4_notify";
    __int16 v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        BOOL v23 = (os_log_s *)__nwlog_obj();
        os_log_type_t v24 = type;
        if (!os_log_type_enabled(v23, type)) {
          goto LABEL_131;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v49 = "nw_protocol_ipv4_notify";
        __int16 v25 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_130;
      }

      char v28 = (char *)__nw_create_backtrace_string();
      BOOL v23 = (os_log_s *)__nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v29 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v29) {
          goto LABEL_131;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v49 = "nw_protocol_ipv4_notify";
        __int16 v25 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_130;
      }

      if (!v29) {
        goto LABEL_99;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v49 = "nw_protocol_ipv4_notify";
      __int16 v50 = 2082;
      os_log_type_t v51 = v28;
      uint64_t v30 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    BOOL v23 = (os_log_s *)__nwlog_obj();
    os_log_type_t v24 = type;
    if (!os_log_type_enabled(v23, type)) {
      goto LABEL_131;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v49 = "nw_protocol_ipv4_notify";
    __int16 v25 = "%{public}s called with null ipv4";
LABEL_130:
    _os_log_impl(&dword_181A5C000, v23, v24, v25, buf, 0xCu);
    goto LABEL_131;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v49 = "nw_protocol_ipv4_notify";
    __int16 v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        BOOL v23 = (os_log_s *)__nwlog_obj();
        os_log_type_t v24 = type;
        if (!os_log_type_enabled(v23, type)) {
          goto LABEL_131;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v49 = "nw_protocol_ipv4_notify";
        __int16 v25 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_130;
      }

      char v28 = (char *)__nw_create_backtrace_string();
      BOOL v23 = (os_log_s *)__nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v31 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v31) {
          goto LABEL_131;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v49 = "nw_protocol_ipv4_notify";
        __int16 v25 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_130;
      }

      if (!v31) {
        goto LABEL_99;
      }
      *(_DWORD *)buf = 136446466;
      BOOL v49 = "nw_protocol_ipv4_notify";
      __int16 v50 = 2082;
      os_log_type_t v51 = v28;
      uint64_t v30 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_98;
    }

    BOOL v23 = (os_log_s *)__nwlog_obj();
    os_log_type_t v24 = type;
    if (!os_log_type_enabled(v23, type)) {
      goto LABEL_131;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v49 = "nw_protocol_ipv4_notify";
    __int16 v25 = "%{public}s called with null other_protocol";
    goto LABEL_130;
  }

  uint64_t v8 = a1 + 96;
  if (a3 == 17)
  {
    if (*(void *)(a1 + 32) != a2) {
      goto LABEL_13;
    }
    BOOL v12 = *(void **)(a2 + 40);
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v13 = *(void *)(a2 + 88);
      if (v13) {
        *(void *)(a2 + 8_Block_object_dispose(va, 8) = v13 + 1;
      }
    }

    uint64_t v14 = *(void *)(a2 + 24);
    if (v14)
    {
      char v15 = *(uint64_t (**)(uint64_t))(v14 + 200);
      if (v15)
      {
        os_log_type_t v16 = (nw_endpoint *)v15(a2);
        if (v12 != &nw_protocol_ref_counted_handle)
        {
LABEL_22:
          if (v16)
          {
            if (nw_endpoint_get_address_family(v16) == 2)
            {
              *(_DWORD *)(a1 + 152) = *(_DWORD *)&nw_endpoint_get_address(v16)->sa_data[2];
              if ((*(_BYTE *)(a1 + 232) & 1) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                __int16 v17 = (os_log_s *)gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)buf = 136446978;
                  BOOL v49 = "nw_protocol_ipv4_notify";
                  __int16 v50 = 2082;
                  os_log_type_t v51 = (void *)(a1 + 233);
                  __int16 v52 = 2080;
                  int v53 = " ";
                  __int16 v54 = 2048;
                  os_log_type_t v55 = (char *)v8;
                  _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s%p updated local address",  buf,  0x2Au);
                }
              }
            }
          }

          goto LABEL_13;
        }

uint64_t nw_path_get_tso_max_segment_size_v6(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_path_get_tso_max_segment_size_v6";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_path_get_tso_max_segment_size_v6";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v18 = "nw_path_get_tso_max_segment_size_v6";
            __int16 v19 = 2082;
            char v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_path_get_tso_max_segment_size_v6";
          _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_path_get_tso_max_segment_size_v6";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B49274(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_ipv4_network_signature(void *a1, void *a2, _BYTE *a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  BOOL v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v31 = "nw_path_get_ipv4_network_signature";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl( &dword_181A5C000,  v11,  v24,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v31 = "nw_path_get_ipv4_network_signature";
      __int16 v32 = 2082;
      os_log_type_t v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_36;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v31 = "nw_path_get_ipv4_network_signature";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null signature", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null signature, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v11, v20, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }

      goto LABEL_54;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v31 = "nw_path_get_ipv4_network_signature";
      __int16 v32 = 2082;
      os_log_type_t v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null signature, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_36;
  }

  if (!a3)
  {
    __nwlog_obj();
    char v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v31 = "nw_path_get_ipv4_network_signature";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null signature_len", buf, 0xCu);
      }

void sub_181B49954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_interface_get_ipv4_network_signature(void *a1, void *a2, _BYTE *a3)
{
  *(void *)&v45[13] = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  BOOL v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v43 = "nw_interface_get_ipv4_network_signature";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        char v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null interface", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (!v40)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        char v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl( &dword_181A5C000,  v24,  v37,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v31 = type;
    BOOL v32 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        char v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v24, v31, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      char v43 = "nw_interface_get_ipv4_network_signature";
      __int16 v44 = 2082;
      *(void *)BOOL v45 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_56;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v43 = "nw_interface_get_ipv4_network_signature";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        char v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null signature", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (!v40)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        char v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl( &dword_181A5C000,  v24,  v38,  "%{public}s called with null signature, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v33 = type;
    BOOL v34 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        char v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v24, v33, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }

      goto LABEL_74;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      char v43 = "nw_interface_get_ipv4_network_signature";
      __int16 v44 = 2082;
      *(void *)BOOL v45 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v24,  v33,  "%{public}s called with null signature, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_56;
  }

  if (!a3)
  {
    __nwlog_obj();
    char v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v43 = "nw_interface_get_ipv4_network_signature";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        char v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_181A5C000, v24, v29, "%{public}s called with null signature_len", buf, 0xCu);
      }

uint64_t net_flowhash_jhash(int *a1, unsigned int a2, int a3)
{
  uint64_t result = a2 + a3 - 559038737;
  if ((a1 & 3) != 0)
  {
    if ((a1 & 1) != 0)
    {
      if (a2 >= 0xD)
      {
        int v42 = a2 + a3 - 559038737;
        int v41 = v42;
        do
        {
          int v27 = v42
              + *((unsigned __int8 *)a1 + 4)
              + (*((unsigned __int8 *)a1 + 5) << 8)
          int v28 = result
              + *((unsigned __int8 *)a1 + 8)
              + (*((unsigned __int8 *)a1 + 9) << 8)
          int v29 = (v41
               + *(unsigned __int8 *)a1
               + (*((unsigned __int8 *)a1 + 1) << 8)
               + (*((unsigned __int8 *)a1 + 2) << 16)
          int v30 = v28 + v27;
          int v31 = (v27 - v29) ^ __ROR4__(v29, 26);
          int v32 = v29 + v30;
          int v33 = (v30 - v31) ^ __ROR4__(v31, 24);
          int v34 = v31 + v32;
          int v35 = (v32 - v33) ^ __ROR4__(v33, 16);
          int v36 = v33 + v34;
          int v37 = (v34 - v35) ^ __ROR4__(v35, 13);
          int v41 = v35 + v36;
          uint64_t result = (v36 - v37) ^ __ROR4__(v37, 28);
          int v42 = v37 + v41;
          a2 -= 12;
          a1 += 3;
        }

        while (a2 > 0xC);
      }

      else
      {
        int v41 = a2 + a3 - 559038737;
        int v42 = v41;
      }

      switch(a2)
      {
        case 0u:
          return result;
        case 1u:
          goto LABEL_34;
        case 2u:
          goto LABEL_33;
        case 3u:
          goto LABEL_32;
        case 4u:
          goto LABEL_31;
        case 5u:
          goto LABEL_30;
        case 6u:
          goto LABEL_29;
        case 7u:
          goto LABEL_28;
        case 8u:
          goto LABEL_27;
        case 9u:
          goto LABEL_26;
        case 0xAu:
          goto LABEL_25;
        case 0xBu:
          goto LABEL_24;
        case 0xCu:
          LODWORD(result) = result + (*((unsigned __int8 *)a1 + 11) << 24);
LABEL_24:
          LODWORD(result) = result + (*((unsigned __int8 *)a1 + 10) << 16);
LABEL_25:
          LODWORD(result) = result + (*((unsigned __int8 *)a1 + 9) << 8);
LABEL_26:
          LODWORD(result) = result + *((unsigned __int8 *)a1 + 8);
LABEL_27:
          v42 += *((unsigned __int8 *)a1 + 7) << 24;
LABEL_28:
          v42 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_29:
          v42 += *((unsigned __int8 *)a1 + 5) << 8;
LABEL_30:
          v42 += *((unsigned __int8 *)a1 + 4);
LABEL_31:
          v41 += *((unsigned __int8 *)a1 + 3) << 24;
LABEL_32:
          v41 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_33:
          v41 += *((unsigned __int8 *)a1 + 1) << 8;
LABEL_34:
          v41 += *(unsigned __int8 *)a1;
          break;
        default:
          break;
      }

      HIDWORD(v43) = v42;
      LODWORD(v43) = v42;
      HIDWORD(v43) = (result ^ v42) - (v43 >> 18);
      int v44 = HIDWORD(v43);
      LODWORD(v43) = HIDWORD(v43);
      int v45 = (HIDWORD(v43) ^ v41) - (v43 >> 21);
      HIDWORD(v43) = v45;
      LODWORD(v43) = v45;
      int v46 = (v45 ^ v42) - (v43 >> 7);
      HIDWORD(v43) = v46;
      LODWORD(v43) = v46;
      int v47 = (v46 ^ v44) - (v43 >> 16);
      HIDWORD(v43) = v47;
      LODWORD(v43) = v47;
      HIDWORD(v43) = (v47 ^ v45) - (v43 >> 28);
      LODWORD(v43) = HIDWORD(v43);
      int v48 = v43 >> 18;
      int v49 = HIDWORD(v43) ^ v46;
      goto LABEL_62;
    }

    if (a2 >= 0xD)
    {
      int v40 = a2 + a3 - 559038737;
      int v39 = v40;
      do
      {
        int v5 = a1[1] + v40;
        int v6 = a1[2] + result;
        int v7 = (*a1 + v39 - v6) ^ __ROR4__(v6, 28);
        int v8 = v6 + v5;
        int v9 = (v5 - v7) ^ __ROR4__(v7, 26);
        int v10 = v7 + v8;
        int v11 = (v8 - v9) ^ __ROR4__(v9, 24);
        int v12 = v9 + v10;
        int v13 = (v10 - v11) ^ __ROR4__(v11, 16);
        int v14 = v11 + v12;
        int v15 = (v12 - v13) ^ __ROR4__(v13, 13);
        int v39 = v13 + v14;
        uint64_t result = (v14 - v15) ^ __ROR4__(v15, 28);
        int v40 = v15 + v39;
        a2 -= 12;
        a1 += 3;
      }

      while (a2 > 0xC);
    }

    else
    {
      int v39 = a2 + a3 - 559038737;
      int v40 = v39;
    }

    switch(a2)
    {
      case 0u:
        return result;
      case 1u:
        v39 += *(unsigned __int8 *)a1;
        goto LABEL_61;
      case 2u:
        goto LABEL_48;
      case 3u:
        v39 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_48:
        v39 += *(unsigned __int16 *)a1;
        goto LABEL_61;
      case 4u:
        goto LABEL_53;
      case 5u:
        int v54 = *((unsigned __int8 *)a1 + 4);
        goto LABEL_52;
      case 6u:
        goto LABEL_51;
      case 7u:
        v40 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_51:
        int v54 = *((unsigned __int16 *)a1 + 2);
LABEL_52:
        v40 += v54;
        goto LABEL_53;
      case 8u:
        break;
      case 9u:
        int v55 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_57;
      case 0xAu:
        goto LABEL_56;
      case 0xBu:
        LODWORD(result) = result + (*((unsigned __int8 *)a1 + 10) << 16);
LABEL_56:
        int v55 = *((unsigned __int16 *)a1 + 4);
LABEL_57:
        LODWORD(result) = result + v55;
        break;
      case 0xCu:
        goto LABEL_36;
      default:
        goto LABEL_61;
    }
  }

  else
  {
    if (a2 < 0xD)
    {
      int v39 = a2 + a3 - 559038737;
      int v40 = v39;
    }

    else
    {
      int v40 = a2 + a3 - 559038737;
      int v39 = v40;
      do
      {
        int v16 = a1[1] + v40;
        int v17 = a1[2] + result;
        int v18 = (*a1 + v39 - v17) ^ __ROR4__(v17, 28);
        int v19 = v17 + v16;
        int v20 = (v16 - v18) ^ __ROR4__(v18, 26);
        int v21 = v18 + v19;
        int v22 = (v19 - v20) ^ __ROR4__(v20, 24);
        int v23 = v20 + v21;
        int v24 = (v21 - v22) ^ __ROR4__(v22, 16);
        int v25 = v22 + v23;
        int v26 = (v23 - v24) ^ __ROR4__(v24, 13);
        int v39 = v24 + v25;
        uint64_t result = (v25 - v26) ^ __ROR4__(v26, 28);
        int v40 = v26 + v39;
        a2 -= 12;
        a1 += 3;
      }

      while (a2 > 0xC);
    }

    switch(a2)
    {
      case 0u:
        return result;
      case 1u:
        int v38 = *(unsigned __int8 *)a1;
        goto LABEL_60;
      case 2u:
        int v38 = *(unsigned __int16 *)a1;
        goto LABEL_60;
      case 3u:
        int v38 = *a1 & 0xFFFFFF;
        goto LABEL_60;
      case 4u:
        goto LABEL_53;
      case 5u:
        int v51 = *((unsigned __int8 *)a1 + 4);
        goto LABEL_41;
      case 6u:
        int v51 = *((unsigned __int16 *)a1 + 2);
LABEL_41:
        v40 += v51;
LABEL_53:
        int v38 = *a1;
        goto LABEL_60;
      case 7u:
        __int16 v52 = a1;
        int v38 = *a1;
        int v53 = v52[1] & 0xFFFFFF;
        goto LABEL_59;
      case 8u:
        break;
      case 9u:
        int v50 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_46;
      case 0xAu:
        int v50 = *((unsigned __int16 *)a1 + 4);
        goto LABEL_46;
      case 0xBu:
        int v50 = a1[2] & 0xFFFFFF;
        goto LABEL_46;
      case 0xCu:
LABEL_36:
        int v50 = a1[2];
LABEL_46:
        LODWORD(result) = v50 + result;
        break;
      default:
        goto LABEL_61;
    }
  }

  __int16 v56 = a1;
  int v38 = *a1;
  int v53 = v56[1];
LABEL_59:
  v40 += v53;
LABEL_60:
  v39 += v38;
LABEL_61:
  HIDWORD(v57) = v40;
  LODWORD(v57) = v40;
  HIDWORD(v57) = (result ^ v40) - (v57 >> 18);
  int v58 = HIDWORD(v57);
  LODWORD(v57) = HIDWORD(v57);
  int v59 = (HIDWORD(v57) ^ v39) - (v57 >> 21);
  HIDWORD(v57) = v59;
  LODWORD(v57) = v59;
  int v60 = (v59 ^ v40) - (v57 >> 7);
  HIDWORD(v57) = v60;
  LODWORD(v57) = v60;
  int v47 = (v60 ^ v58) - (v57 >> 16);
  HIDWORD(v57) = v47;
  LODWORD(v57) = v47;
  HIDWORD(v57) = (v47 ^ v59) - (v57 >> 28);
  LODWORD(v57) = HIDWORD(v57);
  int v48 = v57 >> 18;
  int v49 = HIDWORD(v57) ^ v60;
LABEL_62:
  HIDWORD(v61) = v49 - v48;
  LODWORD(v61) = v49 - v48;
  return ((v49 - v48) ^ v47) - (v61 >> 8);
}

uint64_t nw_path_flow_registration_get_partial_checksum_offload(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[148] >> 1) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_flow_registration_get_partial_checksum_offload";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_flow_registration_get_partial_checksum_offload";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null flow_registration, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null flow_registration, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null flow_registration, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_path_is_local(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[473] >> 4) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_is_local";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_is_local";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_is_local";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_is_local";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_is_local";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

uint64_t nw_path_is_direct(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[473] >> 5) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_is_direct";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_is_direct";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_is_direct";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_is_direct";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_is_direct";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

id *nw_path_copy_direct_interface(id *result)
{
  if (result) {
    return (id *)result[12];
  }
  return result;
}

nw_interface_type_t nw_interface_get_type(nw_interface_t interface)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = interface;
  nw_interface_t v2 = v1;
  if (v1)
  {
    nw_interface_type_t v3 = *((_DWORD *)v1 + 24);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_interface_get_type";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_get_type";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_interface_get_type";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_get_type";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_get_type";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_interface_get_subtype(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[25];
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_interface_get_subtype";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_get_subtype";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_interface_get_subtype";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_get_subtype";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_get_subtype";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_interface_supports_tx_start(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(v1 + 85) >> 3) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_interface_supports_tx_start";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_tx_start";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_interface_supports_tx_start";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_tx_start";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_tx_start";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_interface_supports_ack_priority(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(v1 + 85) >> 4) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_interface_supports_ack_priority";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_ack_priority";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_interface_supports_ack_priority";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_ack_priority";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_ack_priority";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_interface_supports_carrier_aggregation(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(v1 + 85) >> 5) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_interface_supports_carrier_aggregation";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_carrier_aggregation";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_interface_supports_carrier_aggregation";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_carrier_aggregation";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_interface_supports_carrier_aggregation";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_path_copy_delegate_interface(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    id v3 = v1[13];
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_copy_delegate_interface";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_copy_delegate_interface";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_copy_delegate_interface";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_copy_delegate_interface";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_copy_delegate_interface";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

uint64_t nw_path_should_probe_connectivity(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[474] >> 5) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_should_probe_connectivity";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_should_probe_connectivity";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_should_probe_connectivity";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_should_probe_connectivity";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_should_probe_connectivity";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

BOOL network_config_get_tcp_accurate_ecn_enabled()
{
  v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_accurate_ecn, 0LL);
  nw_interface_t v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1895F9228])
  {
    BOOL value = xpc_BOOL_get_value(v1);

    if (value) {
      return 1LL;
    }
  }

  else
  {
  }

  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_181B4C1A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *networkd_settings_copy_value_of_type(const char *a1, objc_class *a2)
{
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    id v4 = (void *)sCachedSettings;
    if (sCachedSettings)
    {
      Class Class = object_getClass((id)sCachedSettings);
      int v6 = 0LL;
      if (!a1 || Class != (Class)MEMORY[0x1895F9250]) {
        goto LABEL_12;
      }
      xpc_object_t value = xpc_dictionary_get_value(v4, a1);
      int v6 = value;
      if (a2 && value)
      {
        if (object_getClass(value) != a2) {
          goto LABEL_8;
        }
      }

      else if (!value)
      {
        goto LABEL_12;
      }

      xpc_retain(v6);
      goto LABEL_12;
    }

uint64_t nw_path_flow_registration_ecn_enabled( NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2)
{
  nw_interface_t v2 = (unsigned __int8 *)nw_path_copy_flow_for_registration(a1, a2);
  if (v2) {
    uint64_t v3 = (v2[185] >> 2) & 1;
  }
  else {
    uint64_t v3 = 0LL;
  }

  return v3;
}

uint64_t nw_protocol_ipv4_get_output_frames( nw_protocol *a1, nw_protocol *a2, size_t __count, unsigned int a4, int a5, nw_frame_array_s *a6)
{
  uint64_t v85 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      int v8 = __count;
      if (a5 && LODWORD(a1[3].identifier) < __count && ((uint64_t)a1[3].handle & 4) == 0)
      {
        BOOL v9 = nw_calloc_type<unsigned char>(__count);
        uint64_t v10 = nw_frame_create( 0,  v9,  v8,  (uint64_t)nw_protocol_ipv4_frame_output_finalizer,  (uint64_t)&a1[1].output_handler);
        uint64_t v11 = v10;
        if (v10)
        {
          *(_WORD *)(v10 + 204) |= 1u;
          *(void *)(v10 + 16) = 0LL;
          os_log_type_t v12 = *(uint64_t **)&a1[3].flow_id[8];
          *(void *)(v10 + 24) = v12;
          uint64_t *v12 = v10;
          *(void *)&a1[3].flow_id[8] = v10 + 16;
LABEL_65:
          *(void *)(v11 + 32) = 0LL;
          tqh_last = a6->tqh_last;
          *(void *)(v11 + 40) = tqh_last;
          *tqh_last = (nw_frame *)v11;
          a6->tqh_last = (nw_frame **)(v11 + 32);
          return 1LL;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        int v80 = "nw_protocol_ipv4_create_output_frame";
        __int16 v81 = 1024;
        *(_DWORD *)os_log_type_t v82 = v8;
        int v33 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v77 = 0;
        if (__nwlog_fault(v33, &type, &v77))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v34 = (os_log_s *)gLogObj;
            os_log_type_t v35 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)buf = 136446466;
              int v80 = "nw_protocol_ipv4_create_output_frame";
              __int16 v81 = 1024;
              *(_DWORD *)os_log_type_t v82 = v8;
              int v36 = "%{public}s nw_frame_create(%u) failed";
LABEL_60:
              _os_log_impl(&dword_181A5C000, v34, v35, v36, buf, 0x12u);
            }
          }

          else if (v77)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v34 = (os_log_s *)gLogObj;
            os_log_type_t v35 = type;
            BOOL v38 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (backtrace_string)
            {
              if (v38)
              {
                *(_DWORD *)buf = 136446722;
                int v80 = "nw_protocol_ipv4_create_output_frame";
                __int16 v81 = 1024;
                *(_DWORD *)os_log_type_t v82 = v8;
                *(_WORD *)&v82[4] = 2082;
                *(void *)&v82[6] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s nw_frame_create(%u) failed, dumping backtrace:%{public}s",  buf,  0x1Cu);
              }

              free(backtrace_string);
              goto LABEL_61;
            }

            if (v38)
            {
              *(_DWORD *)buf = 136446466;
              int v80 = "nw_protocol_ipv4_create_output_frame";
              __int16 v81 = 1024;
              *(_DWORD *)os_log_type_t v82 = v8;
              int v36 = "%{public}s nw_frame_create(%u) failed, no backtrace";
              goto LABEL_60;
            }
          }

          else
          {
            int v34 = (os_log_s *)__nwlog_obj();
            os_log_type_t v35 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446466;
              int v80 = "nw_protocol_ipv4_create_output_frame";
              __int16 v81 = 1024;
              *(_DWORD *)os_log_type_t v82 = v8;
              int v36 = "%{public}s nw_frame_create(%u) failed, backtrace limit exceeded";
              goto LABEL_60;
            }
          }
        }

LABEL_155:
          free(v42);
          goto LABEL_156;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        int v80 = "__nw_protocol_get_output_frames";
        int v42 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v77 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v55 = (os_log_s *)__nwlog_obj();
          os_log_type_t v56 = type;
          if (!os_log_type_enabled(v55, type)) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          int v80 = "__nw_protocol_get_output_frames";
          int v46 = "%{public}s called with null return_array";
        }

        else if (v77)
        {
          BOOL v66 = (char *)__nw_create_backtrace_string();
          int v55 = (os_log_s *)__nwlog_obj();
          os_log_type_t v56 = type;
          BOOL v67 = os_log_type_enabled(v55, type);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446466;
              int v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)os_log_type_t v82 = v66;
              _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s called with null return_array, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v66);
            if (!v42) {
              goto LABEL_156;
            }
            goto LABEL_155;
          }

          if (!v67) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          int v80 = "__nw_protocol_get_output_frames";
          int v46 = "%{public}s called with null return_array, no backtrace";
        }

        else
        {
          int v55 = (os_log_s *)__nwlog_obj();
          os_log_type_t v56 = type;
          if (!os_log_type_enabled(v55, type)) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          int v80 = "__nw_protocol_get_output_frames";
          int v46 = "%{public}s called with null return_array, backtrace limit exceeded";
        }

        os_log_type_t v70 = v55;
        os_log_type_t v71 = v56;
        uint32_t v72 = 12;
        goto LABEL_153;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v80 = "__nw_protocol_get_output_frames";
      int v51 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v77 = 0;
      if (__nwlog_fault(v51, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            int v80 = "__nw_protocol_get_output_frames";
            int v54 = "%{public}s called with null protocol";
LABEL_146:
            _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
          }
        }

        else if (v77)
        {
          BOOL v64 = (char *)__nw_create_backtrace_string();
          __int16 v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          BOOL v65 = os_log_type_enabled(v52, type);
          if (v64)
          {
            if (v65)
            {
              *(_DWORD *)buf = 136446466;
              int v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)os_log_type_t v82 = v64;
              _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v64);
            goto LABEL_147;
          }

          if (v65)
          {
            *(_DWORD *)buf = 136446210;
            int v80 = "__nw_protocol_get_output_frames";
            int v54 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_146;
          }
        }

        else
        {
          __int16 v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            int v80 = "__nw_protocol_get_output_frames";
            int v54 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_146;
          }
        }
      }

        if (v81) {
          free(v81);
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
        __int16 v87 = (char *)_os_log_send_and_compose_impl();
        type[0] = 16;
        v151 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v87, type, &v151))
        {
          if (type[0] == 17)
          {
            __int16 v88 = (os_log_s *)__nwlog_obj();
            uint64_t v89 = type[0];
            if (!os_log_type_enabled(v88, (os_log_type_t)type[0])) {
              goto LABEL_171;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
            __int16 v90 = "%{public}s called with null protocol";
LABEL_170:
            _os_log_impl(&dword_181A5C000, v88, v89, v90, buf, 0xCu);
            goto LABEL_171;
          }

          if (v151 == OS_LOG_TYPE_DEFAULT)
          {
            __int16 v88 = (os_log_s *)__nwlog_obj();
            uint64_t v89 = type[0];
            if (!os_log_type_enabled(v88, (os_log_type_t)type[0])) {
              goto LABEL_171;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
            __int16 v90 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_170;
          }

          BOOL v91 = (char *)__nw_create_backtrace_string();
          __int16 v88 = (os_log_s *)__nwlog_obj();
          uint64_t v89 = type[0];
          __int16 v92 = os_log_type_enabled(v88, (os_log_type_t)type[0]);
          if (!v91)
          {
            if (!v92) {
              goto LABEL_171;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
            __int16 v90 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_170;
          }

          if (v92)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_local_endpoint";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v91;
            _os_log_impl( &dword_181A5C000,  v88,  v89,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v91);
        }

            if (v67) {
              free(v67);
            }
            goto LABEL_65;
          }

          if ((nw_protocol_shoes_send_request_inner(a1) & 1) != 0) {
            return;
          }
LABEL_73:
          int v31 = (os_log_s *)__nwlog_obj();
          int v30 = v31;
LABEL_74:
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            BOOL v91 = "nw_shoes_internal_disconnect";
            __int16 v92 = 2082;
            v93 = handle + 151;
            _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
          }

          handle[150] = 7;
          (*(void (**)(char *, void))(*((void *)handle + 3) + 48LL))(handle, 0LL);
          return;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        BOOL v91 = "nw_protocol_shoes_send_request";
        int v60 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v102) = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v60, &v102, &type))
        {
          if (v102 == 17)
          {
            BOOL v61 = (os_log_s *)__nwlog_obj();
            uint64_t v62 = v102;
            if (!os_log_type_enabled(v61, (os_log_type_t)v102)) {
              goto LABEL_147;
            }
            *(_DWORD *)buf = 136446210;
            BOOL v91 = "nw_protocol_shoes_send_request";
            BOOL v63 = "%{public}s called with null shoes";
            goto LABEL_146;
          }

          if (type == OS_LOG_TYPE_DEFAULT)
          {
            BOOL v61 = (os_log_s *)__nwlog_obj();
            uint64_t v62 = v102;
            if (!os_log_type_enabled(v61, (os_log_type_t)v102)) {
              goto LABEL_147;
            }
            *(_DWORD *)buf = 136446210;
            BOOL v91 = "nw_protocol_shoes_send_request";
            BOOL v63 = "%{public}s called with null shoes, backtrace limit exceeded";
            goto LABEL_146;
          }

          BOOL v75 = (char *)__nw_create_backtrace_string();
          BOOL v61 = (os_log_s *)__nwlog_obj();
          uint64_t v62 = v102;
          BOOL v76 = os_log_type_enabled(v61, (os_log_type_t)v102);
          if (v75)
          {
            if (v76)
            {
              *(_DWORD *)buf = 136446466;
              BOOL v91 = "nw_protocol_shoes_send_request";
              __int16 v92 = 2082;
              v93 = v75;
              _os_log_impl( &dword_181A5C000,  v61,  v62,  "%{public}s called with null shoes, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v75);
            goto LABEL_147;
          }

          if (v76)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v91 = "nw_protocol_shoes_send_request";
            BOOL v63 = "%{public}s called with null shoes, no backtrace";
LABEL_146:
            _os_log_impl(&dword_181A5C000, v61, v62, v63, buf, 0xCu);
          }
        }

        free(v46);
        goto LABEL_156;
      }

      if (v67)
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v47,  v66,  "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyRemoteCID, &rcid), no backtrace",  access_value,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v78 = v100[0];
      if (os_log_type_enabled(v47, v100[0]))
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v47,  v78,  "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyRemoteCID, &rcid), backtrace limit exceeded",  access_value,  0xCu);
      }
    }

    goto LABEL_154;
  }

  __int16 v88 = 0LL;
  int v7 = MEMORY[0x1895F87A8];
  *(void *)access_xpc_object_t value = MEMORY[0x1895F87A8];
  *(void *)&access_value[8] = 3221225472LL;
  *(void *)&access_value[16] = ___ZL34nw_txt_record_get_key_uint64_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPy_block_invoke;
  *(void *)__int16 v92 = &__block_descriptor_40_e19_B36__0r_8i16r_20Q28l;
  *(void *)&v92[8] = &v88;
  if (!nw_txt_record_access_key(v6, "rift", access_value))
  {
    __nwlog_obj();
    os_log_type_t v49 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_xpc_object_t value = 136446210;
    *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    int v46 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v100[0]) = 16;
    LOBYTE(v99) = 0;
    if (LOBYTE(v100[0]) == 17)
    {
      __nwlog_obj();
      int v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v51 = v100[0];
      if (os_log_type_enabled(v50, v100[0]))
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift)",  access_value,  0xCu);
      }
    }

    else if ((_BYTE)v99)
    {
      BOOL v68 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v69 = v100[0];
      os_log_type_t v70 = os_log_type_enabled(v50, v100[0]);
      if (v68)
      {
        if (v70)
        {
          *(_DWORD *)access_xpc_object_t value = 136446466;
          *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          *(_WORD *)&access_value[12] = 2082;
          *(void *)&access_value[14] = v68;
          _os_log_impl( &dword_181A5C000,  v50,  v69,  "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift), dumping backtrace:%{public}s",  access_value,  0x16u);
        }

        goto LABEL_108;
      }

      if (v70)
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v50,  v69,  "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift), no backtrace",  access_value,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v79 = v100[0];
      if (os_log_type_enabled(v50, v100[0]))
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v50,  v79,  "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift), b acktrace limit exceeded",  access_value,  0xCu);
      }
    }

    goto LABEL_154;
  }

  v100[0] = 0LL;
  v100[1] = 0LL;
  *(void *)access_xpc_object_t value = v7;
  *(void *)&access_value[8] = 3221225472LL;
  *(void *)&access_value[16] = ___ZL32nw_txt_record_get_key_uuid_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPh_block_invoke;
  *(void *)__int16 v92 = &__block_descriptor_40_e19_B36__0r_8i16r_20Q28l;
  *(void *)&v92[8] = v100;
  if (!nw_txt_record_access_key(v6, "eval", access_value))
  {
    __nwlog_obj();
    __int16 v52 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_xpc_object_t value = 136446210;
    *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    int v46 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v99) = 16;
    __int16 v87 = 0;
    if (v99 == 17)
    {
      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v54 = v99;
      if (os_log_type_enabled(v53, (os_log_type_t)v99))
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id)",  access_value,  0xCu);
      }

  uint64_t v11 = 0;
LABEL_49:
  if (*((_DWORD *)v3 + 2) == 2)
  {
    nw_resolver_cancel_delayed_reporting_timer((NWConcrete_nw_resolver *)v3);
    nw_resolver_cancel_query_timer((NWConcrete_nw_resolver *)v3);
  }

  if (*((void *)v3 + 12)) {
    int v18 = v11;
  }
  else {
    int v18 = 1;
  }
  if ((v18 & 1) == 0) {
    nw_resolver_update_client(v3, v4);
  }
}

  os_log_type_t v104 = *(unsigned __int16 **)(a1 + 56);
  if (!v104) {
    goto LABEL_172;
  }
  uint64_t v105 = *v104;
  if (v105 != 4) {
    goto LABEL_162;
  }
  uint64_t v106 = *(void **)(a1 + 40);
  if (v106)
  {
    v107 = v106;
    v108 = v107[29];

    if (v108 == 3) {
      *(_DWORD *)(*(void *)(a1 + 32) + 504LL) = nw_endpoint_handler_get_proxy_privacy_stance(*(void **)(a1 + 40));
    }
  }

  id v109 = *(unsigned __int16 **)(a1 + 56);
  if (v109)
  {
    uint64_t v105 = *v109;
LABEL_162:
    BOOL v110 = *(_WORD **)(a1 + 56);
    if (v110)
    {
      if (*v110 == 5 && v110[1] == 1)
      {
        if (*(void *)(*(void *)(a1 + 32) + 288LL))
        {
          uint64_t v111 = *(void **)(a1 + 40);
          if (v111)
          {
            uint64_t v112 = v111;
            uint64_t v113 = v112[29];

            if (v113 == 4) {
              nw_endpoint_handler_reset_expected_progress_target( *(void **)(a1 + 40),  *(void *)(*(void *)(a1 + 32) + 288LL),  (const unsigned __int8 *)(*(void *)(a1 + 32) + 452LL));
            }
          }
        }
      }
    }
  }

      _os_log_impl(&dword_181A5C000, v55, v56, v57, buf, 0x26u);
      goto LABEL_156;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v55 = (os_log_s *)gLogObj;
    os_log_type_t v56 = v161[0];
    if (os_log_type_enabled((os_log_t)gLogObj, v161[0]))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http_connect_send_bytes";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      LOWORD(v172) = 1024;
      *(_DWORD *)((char *)&v172 + 2) = v20;
      unint64_t v57 = "%{public}s %{public}s%sClaiming frame with %u bytes failed";
      goto LABEL_155;
    }

    if (v136) {
      free(v136);
    }
    goto LABEL_128;
  }

  nw_interface_t v1 = (NWConcrete_nw_endpoint_handler *)v170;
  mode = v1->mode;

  if ((_DWORD)mode == 4)
  {
    uint64_t v3 = nw_endpoint_handler_copy_fallback(v1);
    v179 = 0LL;
    v180 = 0LL;
    v178 = 0;
    v169 = v3;
    if (nw_endpoint_handler_fillout_data_transfer_snapshot(*((void **)v3 + 5), (uint64_t *)&v180, &v179, &v178, 2)
      && v180 != 0LL
      && v179 != 0)
    {
      int v22 = *((void *)v180 + 6);
      int v23 = *((void *)v3 + 1);
      char v24 = v23 >= v22;
      int v25 = v23 - v22;
      if (v24 && *((void *)v180 + 9) <= v25)
      {
        int v39 = *((void *)v3 + 11);
        int v40 = dispatch_time(0x8000000000000000LL, 1000000LL * *((void *)v3 + 2));
        nw_queue_set_timer_values(v39, v40, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        goto LABEL_124;
      }

      v168 = v1;
      if (nw_endpoint_handler_get_minimize_logging(v1))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) != 0)
        {
LABEL_63:
          BOOL v58 = v168;
          v166 = v58[4];

          nw_parameters_get_e_proc_uuid(v166, &v181);
          nw_parameters_get_pid(v166);
          nw_parameters_get_effective_bundle_id(v166);
          int v59 = nw_queue_copy_current_workloop();
          *(void *)v173 = MEMORY[0x1895F87A8];
          v174 = 3221225472LL;
          v175 = ___ZL36nw_endpoint_fallback_check_usage_capP30NWConcrete_nw_endpoint_handler_block_invoke;
          v176 = &unk_189BBCC40;
          int v60 = v58;
          v177 = v60;
          BOOL v61 = _symptoms_daemon_fallback_subseq_disposition();

          if ((v61 & 1) != 0)
          {
LABEL_123:

            uint64_t v3 = v169;
LABEL_124:
            if (v178 && v180) {
              free(v180);
            }

            goto LABEL_128;
          }

          uint64_t v62 = v60;
          BOOL v63 = (*((_BYTE *)v62 + 268) & 0x20) == 0;

          BOOL v65 = v169;
          if (!v63)
          {
LABEL_120:
            v134 = *((void *)v65 + 11);
            if (v134)
            {
              nw_queue_cancel_source(v134, v64);
              BOOL v65 = v169;
              *((void *)v169 + 11) = 0LL;
            }

            nw_endpoint_handler_cancel(*((void **)v65 + 5), 0LL, 1);
            goto LABEL_123;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v66 = (id)gconnectionLogObj;
          BOOL v67 = v62;

          BOOL v68 = v67;
          BOOL v69 = (*((_BYTE *)v62 + 268) & 1) == 0;

          if (v69) {
            os_log_type_t v70 = "";
          }
          else {
            os_log_type_t v70 = "dry-run ";
          }
          os_log_type_t v71 = nw_endpoint_handler_copy_endpoint(v68);
          logging_description = nw_endpoint_get_logging_description(v71);
          BOOL v73 = v68;
          v74 = v73;
          BOOL v75 = v73[30];
          v162 = logging_description;
          else {
            BOOL v76 = off_189BBBBF0[v75];
          }
          v161 = v76;

          char v77 = v74;
          BOOL v78 = v77;
          char v79 = "path";
          switch(v168->mode)
          {
            case 0:
              break;
            case 1:
              char v79 = "resolver";
              break;
            case 2:
              char v79 = nw_endpoint_flow_mode_string(v77[31]);
              break;
            case 3:
              char v79 = "proxy";
              break;
            case 4:
              char v79 = "fallback";
              break;
            case 5:
              char v79 = "transform";
              break;
            default:
              char v79 = "unknown-mode";
              break;
          }

          int v80 = v71;
          __int16 v81 = v62;
          os_log_type_t v82 = v74;
          __int16 v83 = v78;
          os_unfair_lock_lock((os_unfair_lock_t)v83 + 28);
          uint64_t v84 = v83[8];
          lock = (os_unfair_lock_s *)(v83 + 14);
          os_unfair_lock_unlock((os_unfair_lock_t)v83 + 28);
          v160 = v83;

          uint64_t v85 = v66;
          __int16 v86 = v82;
          __int16 v87 = v81;
          *(_DWORD *)buf = 136447746;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          v184 = 2082;
          v158 = v67 + 168;
          id_str = v67 + 168;
          v186 = 2082;
          v187 = v70;
          v188 = 2082;
          v189 = v162;
          v190 = 2082;
          v191 = v161;
          v192 = 2082;
          v193 = v79;
          v194 = 2114;
          v195 = v84;
          v164 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v171 = 0;
          __int16 v88 = (char *)v164;
          if (!__nwlog_fault(v164, &type, &v171))
          {
LABEL_118:
            BOOL v65 = v169;
            if (v88) {
              free(v88);
            }
            goto LABEL_120;
          }

          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v89 = (os_log_s *)(id)gconnectionLogObj;
            __int16 v90 = type;
            if (os_log_type_enabled(v89, type))
            {
              BOOL v91 = v160;

              __int16 v92 = v91;
              v93 = (*((_BYTE *)v87 + 268) & 1) == 0;

              if (v93) {
                uint64_t v94 = "";
              }
              else {
                uint64_t v94 = "dry-run ";
              }
              os_log_type_t v95 = nw_endpoint_handler_copy_endpoint(v92);
              os_log_type_t v96 = nw_endpoint_get_logging_description(v95);
              v163 = v94;
              v97 = v92;
              BOOL v98 = v97;
              int v99 = v86[30];
              BOOL v100 = v96;
              else {
                os_log_type_t v101 = off_189BBBBF0[v99];
              }

              uint64_t v121 = v98;
              uint64_t v122 = v121;
              v123 = "path";
              switch(v168->mode)
              {
                case 0:
                  break;
                case 1:
                  v123 = "resolver";
                  break;
                case 2:
                  v123 = nw_endpoint_flow_mode_string(v121[31]);
                  break;
                case 3:
                  v123 = "proxy";
                  break;
                case 4:
                  v123 = "fallback";
                  break;
                case 5:
                  v123 = "transform";
                  break;
                default:
                  v123 = "unknown-mode";
                  break;
              }

              v132 = v122;
              os_unfair_lock_lock(lock);
              uint64_t v133 = v160[8];
              os_unfair_lock_unlock(lock);

              *(_DWORD *)buf = 136447746;
              v183 = "nw_endpoint_fallback_check_usage_cap";
              v184 = 2082;
              id_str = v158;
              v186 = 2082;
              v187 = v163;
              v188 = 2082;
              v189 = v100;
              v190 = 2082;
              v191 = v101;
              v192 = 2082;
              v193 = v123;
              v194 = 2114;
              v195 = v133;
              _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fallba ck_subseq_disposition failed, cancelling fallback",  buf,  0x48u);
            }
          }

          else if (v171)
          {
            BOOL v102 = __nw_create_backtrace_string();
            if (v102)
            {
              os_log_type_t v103 = (char *)v102;
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              os_log_type_t v104 = (os_log_s *)(id)gconnectionLogObj;
              uint64_t v105 = type;
              if (os_log_type_enabled(v104, type))
              {
                id_string = nw_endpoint_handler_get_id_string(v160);
                v107 = nw_endpoint_handler_dry_run_string(v160);
                v108 = nw_endpoint_handler_copy_endpoint(v160);
                id v109 = nw_endpoint_get_logging_description(v108);
                BOOL v110 = nw_endpoint_handler_state_string(v160);
                uint64_t v111 = nw_endpoint_handler_mode_string(v160);
                uint64_t v112 = nw_endpoint_handler_copy_current_path(v160);
                *(_DWORD *)buf = 136448002;
                v183 = "nw_endpoint_fallback_check_usage_cap";
                v184 = 2082;
                id_str = (char *)id_string;
                v186 = 2082;
                v187 = v107;
                v188 = 2082;
                v189 = v109;
                v190 = 2082;
                v191 = v110;
                v192 = 2082;
                v193 = v111;
                v194 = 2114;
                v195 = v112;
                v196 = 2082;
                v197 = v103;
                _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fall back_subseq_disposition failed, cancelling fallback, dumping backtrace:%{public}s",  buf,  0x52u);
              }

              free(v103);
              goto LABEL_117;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v89 = (os_log_s *)(id)gconnectionLogObj;
            __int16 v124 = type;
            if (os_log_type_enabled(v89, type))
            {
              v125 = nw_endpoint_handler_get_id_string(v160);
              __int16 v126 = nw_endpoint_handler_dry_run_string(v160);
              __int128 v127 = nw_endpoint_handler_copy_endpoint(v160);
              __int16 v128 = nw_endpoint_get_logging_description(v127);
              uint64_t v129 = nw_endpoint_handler_state_string(v160);
              __int16 v130 = nw_endpoint_handler_mode_string(v160);
              int v131 = nw_endpoint_handler_copy_current_path(v160);
              *(_DWORD *)buf = 136447746;
              v183 = "nw_endpoint_fallback_check_usage_cap";
              v184 = 2082;
              id_str = (char *)v125;
              v186 = 2082;
              v187 = v126;
              v188 = 2082;
              v189 = v128;
              v190 = 2082;
              v191 = v129;
              v192 = 2082;
              v193 = v130;
              v194 = 2114;
              v195 = v131;
              _os_log_impl( &dword_181A5C000,  v89,  v124,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fallba ck_subseq_disposition failed, cancelling fallback, no backtrace",  buf,  0x48u);
            }
          }

          else
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            uint64_t v89 = (os_log_s *)(id)gconnectionLogObj;
            uint64_t v113 = type;
            if (os_log_type_enabled(v89, type))
            {
              uint64_t v114 = nw_endpoint_handler_get_id_string(v160);
              v115 = nw_endpoint_handler_dry_run_string(v160);
              v116 = nw_endpoint_handler_copy_endpoint(v160);
              BOOL v117 = nw_endpoint_get_logging_description(v116);
              char v118 = nw_endpoint_handler_state_string(v160);
              os_log_type_t v119 = nw_endpoint_handler_mode_string(v160);
              uint64_t v120 = nw_endpoint_handler_copy_current_path(v160);
              *(_DWORD *)buf = 136447746;
              v183 = "nw_endpoint_fallback_check_usage_cap";
              v184 = 2082;
              id_str = (char *)v114;
              v186 = 2082;
              v187 = v115;
              v188 = 2082;
              v189 = v117;
              v190 = 2082;
              v191 = v118;
              v192 = 2082;
              v193 = v119;
              v194 = 2114;
              v195 = v120;
              _os_log_impl( &dword_181A5C000,  v89,  v113,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fallba ck_subseq_disposition failed, cancelling fallback, backtrace limit exceeded",  buf,  0x48u);
            }
          }

LABEL_117:
          __int16 v88 = (char *)v164;
          goto LABEL_118;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v28 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          v150 = nw_endpoint_handler_get_id_string(v1);
          v151 = nw_endpoint_handler_dry_run_string(v1);
          v152 = nw_endpoint_handler_copy_endpoint(v1);
          v153 = nw_endpoint_get_logging_description(v152);
          v154 = nw_endpoint_handler_state_string(v1);
          v155 = nw_endpoint_handler_mode_string(v1);
          v156 = nw_endpoint_handler_copy_current_path(v1);
          v157 = (char *)*((void *)v169 + 1);
          *(_DWORD *)buf = 136448002;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          v184 = 2082;
          id_str = (char *)v150;
          v186 = 2082;
          v187 = v151;
          v188 = 2082;
          v189 = v153;
          v190 = 2082;
          v191 = v154;
          v192 = 2082;
          v193 = v155;
          v194 = 2114;
          v195 = v156;
          v196 = 2048;
          v197 = v157;
          _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback reached usage cap of %llu bytes, asking for an update from symptoms",  buf,  0x52u);
        }
      }

      else
      {
        int v26 = v1;
        int v27 = (*((_BYTE *)v26 + 268) & 0x20) == 0;

        if (!v27) {
          goto LABEL_63;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v28 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          int v29 = v26;

          int v30 = v29;
          int v31 = (*((_BYTE *)v26 + 268) & 1) == 0;

          if (v31) {
            int v32 = "";
          }
          else {
            int v32 = "dry-run ";
          }
          int v33 = nw_endpoint_handler_copy_endpoint(v30);
          int v34 = nw_endpoint_get_logging_description(v33);
          os_log_type_t v35 = v30;
          int v36 = v35;
          int v37 = v35[30];
          else {
            BOOL v38 = off_189BBBBF0[v37];
          }

          os_log_type_t v44 = v36;
          int v45 = "path";
          switch(v168->mode)
          {
            case 0:
              break;
            case 1:
              int v45 = "resolver";
              break;
            case 2:
              int v45 = nw_endpoint_flow_mode_string(v44[31]);
              break;
            case 3:
              int v45 = "proxy";
              break;
            case 4:
              int v45 = "fallback";
              break;
            case 5:
              int v45 = "transform";
              break;
            default:
              int v45 = "unknown-mode";
              break;
          }

          v165 = v45;

          os_log_type_t v49 = v28;
          int v50 = v33;
          int v51 = v38;
          __int16 v52 = v32;
          os_log_type_t v53 = v34;
          int v54 = v44;
          os_unfair_lock_lock((os_unfair_lock_t)v54 + 28);
          int v55 = v54[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v54 + 28);

          os_log_type_t v56 = v50;
          int v28 = v49;
          unint64_t v57 = (char *)*((void *)v169 + 1);
          *(_DWORD *)buf = 136448002;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          v184 = 2082;
          id_str = v29->id_str;
          v186 = 2082;
          v187 = v52;
          v188 = 2082;
          v189 = v53;
          v190 = 2082;
          v191 = v51;
          v192 = 2082;
          v193 = v165;
          v194 = 2114;
          v195 = v55;
          v196 = 2048;
          v197 = v57;
          _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback reached usage cap of %llu bytes, asking for an update from symptoms",  buf,  0x52u);
        }
      }

      goto LABEL_63;
    }

    v167 = v1;
    if (nw_endpoint_handler_get_minimize_logging(v1))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) != 0)
      {
LABEL_54:
        uint64_t v3 = v169;
        int v48 = *((void *)v169 + 11);
        if (v48)
        {
          nw_queue_cancel_source(v48, v8);
          *((void *)v169 + 11) = 0LL;
        }

        goto LABEL_124;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v9 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v142 = nw_endpoint_handler_get_id_string(v1);
        v143 = nw_endpoint_handler_dry_run_string(v1);
        v144 = nw_endpoint_handler_copy_endpoint(v1);
        v145 = nw_endpoint_get_logging_description(v144);
        v146 = nw_endpoint_handler_state_string(v1);
        v147 = nw_endpoint_handler_mode_string(v1);
        v148 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        v183 = "nw_endpoint_fallback_check_usage_cap";
        v184 = 2082;
        id_str = (char *)v142;
        v186 = 2082;
        v187 = v143;
        v188 = 2082;
        v189 = v145;
        v190 = 2082;
        v191 = v146;
        v192 = 2082;
        v193 = v147;
        v194 = 2114;
        v195 = v148;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to get byte count for fallback connection with data cap, ignoring",  buf,  0x48u);
      }
    }

    else
    {
      int v6 = v1;
      int v7 = (*((_BYTE *)v6 + 268) & 0x20) == 0;

      if (!v7) {
        goto LABEL_54;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v9 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = v6;

        uint64_t v11 = v10;
        os_log_type_t v12 = (*((_BYTE *)v6 + 268) & 1) == 0;

        if (v12) {
          uint64_t v13 = "";
        }
        else {
          uint64_t v13 = "dry-run ";
        }
        uint64_t v14 = nw_endpoint_handler_copy_endpoint(v11);
        int v15 = nw_endpoint_get_logging_description(v14);
        int v16 = v11;
        __int16 v17 = v16;
        int v18 = v16[30];
        else {
          uint64_t v19 = off_189BBBBF0[v18];
        }

        int v41 = v17;
        int v42 = v41;
        unint64_t v43 = "path";
        switch(v167->mode)
        {
          case 0:
            break;
          case 1:
            unint64_t v43 = "resolver";
            break;
          case 2:
            unint64_t v43 = nw_endpoint_flow_mode_string(v41[31]);
            break;
          case 3:
            unint64_t v43 = "proxy";
            break;
          case 4:
            unint64_t v43 = "fallback";
            break;
          case 5:
            unint64_t v43 = "transform";
            break;
          default:
            unint64_t v43 = "unknown-mode";
            break;
        }

        int v46 = v42;
        os_unfair_lock_lock((os_unfair_lock_t)v46 + 28);
        int v47 = v46[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v46 + 28);

        *(_DWORD *)buf = 136447746;
        v183 = "nw_endpoint_fallback_check_usage_cap";
        v184 = 2082;
        id_str = v10->id_str;
        v186 = 2082;
        v187 = v13;
        v188 = 2082;
        v189 = v15;
        v190 = 2082;
        v191 = v19;
        v192 = 2082;
        v193 = v43;
        v194 = 2114;
        v195 = v47;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to get byte count for fallback connection with data cap, ignoring",  buf,  0x48u);
      }
    }

    goto LABEL_54;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v20 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v21 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    v183 = "nw_endpoint_fallback_check_usage_cap";
    v184 = 2082;
    id_str = (char *)v21;
    v186 = 2082;
    v187 = "fallback";
    _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_128:
}

    if (v171) {
      free(v171);
    }
    a3 = 0xFFFFFFFFLL;
    goto LABEL_158;
  }

          free(v73);
          goto LABEL_156;
        }

        if (v6) {
          int v37 = (char *)&v126[1] + v23 + 1;
        }
        else {
          int v37 = (char *)v126 + 4;
        }
        -[__CFData getBytes:length:](v35, "getBytes:length:", v37, 64LL);
        BOOL v38 = dispatch_data_create(buf, (unsigned __int16)v22 + 2LL, 0LL, 0LL);
        int v39 = v38;
        if (v38)
        {
          int v40 = v38;
LABEL_125:
          BOOL v68 = v39;

          goto LABEL_126;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v51 = (id)gLogObj;
        *(_DWORD *)os_log_type_t type = 136446210;
        uint64_t v121 = "nw_service_connector_create_initial_payload_for_request";
        __int16 v52 = (char *)_os_log_send_and_compose_impl();

        char v118 = OS_LOG_TYPE_ERROR;
        BOOL v117 = 0;
        if (__nwlog_fault(v52, &v118, &v117))
        {
          if (v118 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v53 = (os_log_s *)(id)gLogObj;
            int v54 = v118;
            if (os_log_type_enabled(v53, v118))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              uint64_t v121 = "nw_service_connector_create_initial_payload_for_request";
              _os_log_impl(&dword_181A5C000, v53, v54, "%{public}s dispatch_data_create failed", (uint8_t *)type, 0xCu);
            }
          }

          else if (v117)
          {
            int v60 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v110 = v118;
            BOOL v61 = os_log_type_enabled(v53, v118);
            if (v60)
            {
              if (v61)
              {
                *(_DWORD *)os_log_type_t type = 136446466;
                uint64_t v121 = "nw_service_connector_create_initial_payload_for_request";
                uint64_t v122 = 2082;
                v123 = (CFErrorRef)v60;
                _os_log_impl( &dword_181A5C000,  v53,  v110,  "%{public}s dispatch_data_create failed, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
              }

              free(v60);
              if (!v52) {
                goto LABEL_124;
              }
              goto LABEL_123;
            }

            if (v61)
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              uint64_t v121 = "nw_service_connector_create_initial_payload_for_request";
              _os_log_impl( &dword_181A5C000,  v53,  v110,  "%{public}s dispatch_data_create failed, no backtrace",  (uint8_t *)type,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v67 = v118;
            if (os_log_type_enabled(v53, v118))
            {
              *(_DWORD *)os_log_type_t type = 136446210;
              uint64_t v121 = "nw_service_connector_create_initial_payload_for_request";
              _os_log_impl( &dword_181A5C000,  v53,  v67,  "%{public}s dispatch_data_create failed, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
            }
          }
        }

        if (!v52)
        {
LABEL_124:
          int v39 = 0LL;
          goto LABEL_125;
        }

  v235 = 0LL;
  nw_parameters_get_upper_transport_protocol_options(v92[6]);
  parameters = (nw_parameters_t)objc_claimAutoreleasedReturnValue();
  if (nw_protocol_options_is_quic_stream(parameters))
  {
    v93 = nw_quic_stream_copy_shared_connection_options(parameters);
    source_connection_id_length = nw_quic_connection_get_source_connection_id_length(v93);
  }

  else if (nw_protocol_options_is_quic_connection(parameters))
  {
    source_connection_id_length = nw_quic_connection_get_source_connection_id_length(parameters);
  }

  else
  {
    source_connection_id_length = 0LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v103 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = source_connection_id_length;
    _os_log_impl(&dword_181A5C000, v103, OS_LOG_TYPE_DEBUG, "%{public}s Using CID length %u", buf, 0x12u);
  }

  *(_DWORD *)buf = 0;
  os_log_type_t v104 = nw_frame_unclaimed_bytes((uint64_t)v10, buf);
  uint64_t v105 = (*(_DWORD *)buf - 8);
  if (*(_DWORD *)buf <= 8u
    || (*(_DWORD *)buf -= 8,
        !nw_quic_parse_internal( (const unsigned __int8 *)(v104 + 8),  v105,  source_connection_id_length,  &v235)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v108 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      _os_log_impl(&dword_181A5C000, v108, OS_LOG_TYPE_DEBUG, "%{public}s Unable to parse connection ID", buf, 0xCu);
    }

    goto LABEL_253;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v106 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
  {
    v107 = v92[5];
    *(_DWORD *)buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&_BYTE buf[12] = 2112;
    *(void *)&buf[14] = v107;
    *(_WORD *)&buf[22] = 2112;
    *(void *)&_BYTE buf[24] = v235;
    *(_WORD *)&_BYTE buf[32] = 2112;
    *(void *)&buf[34] = logc;
    *(_WORD *)&buf[42] = 2112;
    *(void *)&buf[44] = v87;
    _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEFAULT,  "%{public}s Received QUIC short header packet on interface %@ with CID %@ [%@->%@]",  buf,  0x34u);
  }

  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
  }
  v108 = (os_log_s *)(id)nw_protocol_copy_quic_stream_definition::quic_definition;
  identifier = (__int128 *)nw_protocol_definition_get_identifier(v108);
  *(void *)&address[4] = 0LL;
  *(void *)&address[12] = 0LL;
  v245 = 0LL;
  *(_WORD *)&address[2] = *((_WORD *)v92 + 82);
  *(_WORD *)address = 7708;
  v219 = nw_parameters_copy_context(v92[6]);
  v217 = nw_endpoint_create_address((const sockaddr *)address);
  os_log_type_t type = nw_context_copy_registered_endpoint(v219, v217);
  BOOL v110 = nw_endpoint_copy_registrar_for_identifier(type, identifier, 0);
  uint64_t v111 = v110;
  if (!v110) {
    goto LABEL_252;
  }
  quic_instance_by_id = nw_protocol_instance_registrar_find_quic_instance_by_id(v110, v235);
  if (!quic_instance_by_id) {
    goto LABEL_252;
  }
  v210 = (void *)quic_instance_by_id;
  v211 = v111;
  __nwlog_obj();
  uint64_t v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v113, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    _os_log_impl( &dword_181A5C000,  v113,  OS_LOG_TYPE_INFO,  "%{public}s Found an existing QUIC connection, adding a new path",  buf,  0xCu);
  }

  uint64_t v111 = v211;
  uint64_t v114 = v210[3];
  if (!v114 || (v115 = *(void (**)(void))(v114 + 120)) == 0LL)
  {
LABEL_252:

LABEL_253:
LABEL_254:
    __int16 v139 = v92[6];
    parametersa = (nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v139,  0,  0);

    if (__dst[0].sa_family == 2)
    {
      if ((__dst[0].sa_data[2] & 0xF0) == 0xE0) {
        goto LABEL_270;
      }
      v140 = v92[5];
      uint64_t v141 = &__dst[0].sa_data[2];
    }

    else
    {
      if (__dst[0].sa_family != 30)
      {
        v140 = v92[5];
        goto LABEL_281;
      }

      v140 = v92[5];
      if (*(_DWORD *)&__dst[0].sa_data[6] || *(_DWORD *)&__dst[0].sa_data[10] || *(_DWORD *)&__dst[1].sa_len != -65536)
      {
LABEL_281:

        nw_parameters_set_local_endpoint(parametersa, v87);
        nw_parameters_set_reuse_local_address(parametersa, 1);
        v149 = v92[4];
        if (v149)
        {
          *(void *)buf = 0LL;
          *(void *)&buf[8] = 0LL;
          v150 = v149;
          *(_OWORD *)buf = *(_OWORD *)(v150 + 28);

          if (!uuid_is_null(buf)) {
            nw_parameters_require_netagent_uuid(parametersa, buf);
          }
        }

        if (!objc_msgSend(v92[1], "canHandleNewConnection:", v92, v199, v200))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v168 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v168, OS_LOG_TYPE_INFO))
          {
            v169 = nw_endpoint_get_description(v87);
            v170 = nw_endpoint_get_logging_description(logc);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v169;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&_BYTE buf[24] = v170;
            _os_log_impl( &dword_181A5C000,  v168,  OS_LOG_TYPE_INFO,  "%{public}s Dropping %{public}s<-%{public}s, listener can't handle new connections",  buf,  0x20u);
          }

          goto LABEL_324;
        }

        v151 = v92;
        __int16 v87 = v87;
        v220 = logc;
        v152 = parametersa;
        v218 = object;
        v213 = v151;
        uuid_clear(address);
        nw_path_get_client_id(v151[8], v242);
        nw_parameters_set_parent_id_inner(v152, v242, 0);
        nw_parameters_set_server_mode(v152, 1);
        typea = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v152);
        v153 = nw_protocol_stack_copy_transport_protocol(typea);
        if (nw_protocol_options_is_tcp(v153) && !nw_tcp_options_get_connection_timeout(v153))
        {
          int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_tcp_accept_timeout_seconds,  5LL);
        }

        [v92[1] updateParametersForNewConnection:v152];
        v155 = nw_parameters_copy_description_internal(v152, 1);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v156 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v156, OS_LOG_TYPE_INFO))
        {
          v157 = v92[1];
          v158 = nw_endpoint_get_description(v87);
          v159 = nw_endpoint_get_logging_description(v220);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_new_flow";
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v157;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&_BYTE buf[24] = v158;
          *(_WORD *)&_BYTE buf[32] = 2082;
          *(void *)&buf[34] = v159;
          *(_WORD *)&buf[42] = 2082;
          *(void *)&buf[44] = v155;
          _os_log_impl( &dword_181A5C000,  v156,  OS_LOG_TYPE_INFO,  "%{public}s Listener %@ received new flow %{public}s<-%{public}s %{public}s",  buf,  0x34u);
        }

        if (v155) {
          free(v155);
        }
        v160 = (char *)[v92[1] getPeerDeviceID];
        if (v160)
        {
          nw_endpoint_set_device_id(v220, v160);
          free(v160);
        }

        v161 = nw_connection_create_from_protocol_on_nw_queue(v220, v152, 0LL);
        v162 = v161;
        if (v161)
        {
          v163 = v161;
          nw_context_assert_queue(v163[3]);
          flow_id = nw_endpoint_handler_get_flow_id(v163[18], address);

          if ((flow_id & 1) != 0)
          {
            if (object) {
              nw_array_append((uint64_t)v218, v163);
            }
            [v92[1] handleInbound:v163 addProtocolInbox:nw_parameters_get_attach_protocol_listener(v152)];

            if (uuid_is_null(address))
            {
              __nwlog_obj();
              v165 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v165, OS_LOG_TYPE_INFO))
              {
                v166 = nw_endpoint_get_description(v87);
                v167 = nw_endpoint_get_logging_description(v220);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v166;
                *(_WORD *)&buf[22] = 2082;
                *(void *)&_BYTE buf[24] = v167;
                *(_WORD *)&_BYTE buf[32] = 1024;
                *(_DWORD *)&buf[34] = v224;
                _os_log_impl( &dword_181A5C000,  v165,  OS_LOG_TYPE_INFO,  "%{public}s No flow id for new inbound connection %{public}s<-%{public}s %u",  buf,  0x26u);
              }

              goto LABEL_311;
            }

            nw_frame_reclassify((uint64_t)v10, (uint64_t)address);

LABEL_316:
LABEL_325:

            return;
          }

          __nwlog_obj();
          v171 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_new_flow";
            v172 = "%{public}s nw_connection_get_flow_id_on_nw_queue failed";
            goto LABEL_309;
          }
        }

        else
        {
          __nwlog_obj();
          v171 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_new_flow";
            v172 = "%{public}s nw_connection_create_from_protocol_on_nw_queue failed";
LABEL_309:
            _os_log_impl(&dword_181A5C000, v171, OS_LOG_TYPE_ERROR, v172, buf, 0xCu);
          }
        }

        v165 = (os_log_s *)v213;
LABEL_311:

        goto LABEL_324;
      }

      uint64_t v141 = &__dst[1].sa_data[2];
    }

    v142 = *(_DWORD *)v141;
    if (*(_DWORD *)v141 == -1
      || v140
      && (buf[0] = 0,
          v242[0] = 0,
          ipv4_netmask = nw_interface_get_ipv4_netmask(v140, buf),
          ipv4_broadcast = nw_interface_get_ipv4_broadcast(v140, v242),
          v242[0])
      && (v142 == ipv4_broadcast || buf[0] && (ipv4_broadcast & ipv4_netmask) == v142))
    {

LABEL_270:
      int address_family = nw_endpoint_get_address_family(logc);
      if (address_family == 30)
      {
        memset(&buf[4], 0, 24);
        *(_WORD *)buf = 7708;
        *(_WORD *)&buf[2] = *(_WORD *)__dst[0].sa_data;
        v146 = nw_endpoint_create_address((const sockaddr *)buf);
      }

      else
      {
        if (address_family != 2) {
          goto LABEL_276;
        }
        *(_WORD *)buf = 528;
        *(_WORD *)&buf[2] = *(_WORD *)__dst[0].sa_data;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(void *)&buf[8] = 0LL;
        v146 = nw_endpoint_create_address((const sockaddr *)buf);
      }

      __int16 v87 = v146;
LABEL_276:
      v140 = nw_parameters_copy_default_protocol_stack(parametersa);
      v147 = nw_protocol_stack_copy_transport_protocol(v140);
      if (!nw_protocol_options_is_udp(v147))
      {
LABEL_280:

        goto LABEL_281;
      }

      v148 = v147;
      if (nw_protocol_options_is_udp(v148))
      {
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = __nw_udp_options_set_ignore_inbound_checksum_block_invoke;
        *(void *)&_BYTE buf[24] = &__block_descriptor_33_e9_B16__0_v8l;
        _BYTE buf[32] = 1;
        nw_protocol_options_access_handle(v148, buf);
LABEL_279:

        goto LABEL_280;
      }

      __nwlog_obj();
      v177 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
      LODWORD(v200) = 12;
      v199 = buf;
      v221 = (char *)_os_log_send_and_compose_impl();

      v242[0] = 16;
      address[0] = 0;
      if ((__nwlog_fault(v221, v242, address) & 1) != 0)
      {
        if (v242[0] == 17)
        {
          __nwlog_obj();
          v178 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v179 = v242[0];
          if (os_log_type_enabled(v178, (os_log_type_t)v242[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
            _os_log_impl( &dword_181A5C000,  v178,  v179,  "%{public}s called with null nw_protocol_options_is_udp(options)",  buf,  0xCu);
          }
        }

        else if (address[0])
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v178 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          typeb = v242[0];
          v183 = os_log_type_enabled(v178, (os_log_type_t)v242[0]);
          if (backtrace_string)
          {
            if (v183)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v178,  typeb,  "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_358;
          }

          if (v183)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
            _os_log_impl( &dword_181A5C000,  v178,  typeb,  "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v178 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v186 = v242[0];
          if (os_log_type_enabled(v178, (os_log_type_t)v242[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
            _os_log_impl( &dword_181A5C000,  v178,  v186,  "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

            if (v94) {
              free(v94);
            }
            uint64_t v89 = v91;
            uint64_t v3 = v93;
            if (!v91) {
              goto LABEL_3;
            }
          }
        }

        if ((v5 & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v174 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v175 = *(_DWORD *)(a1 + 1280);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v3;
            *(_WORD *)&buf[22] = 2080;
            v282 = " ";
            v283 = 1024;
            v284 = v175;
            v285 = 2048;
            v286 = v6;
            _os_log_impl( &dword_181A5C000,  v174,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Invalid frame %llu on control stream",  buf,  0x30u);
          }
        }

        v176 = (void *)*((void *)v272 + 5);
        if (!v176)
        {
LABEL_304:
          v162 = a1;
          v163 = 261LL;
          goto LABEL_305;
        }

        while (1)
        {
          v177 = (void (*)(void *, uint64_t, uint64_t))v176[10];
          v178 = (void *)v176[4];
          if (!v177) {
            break;
          }
          v179 = v176[11];
          v176[10] = 0LL;
          v176[11] = 0LL;
          v177(v176, 1LL, v179);
LABEL_286:
          v176 = v178;
          if (!v178) {
            goto LABEL_304;
          }
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v180 = (const char *)_os_log_send_and_compose_impl();
        v279[0] = 16;
        LOBYTE(error) = 0;
        v253 = (char *)v180;
        if (__nwlog_fault(v180, v279, &error))
        {
          if (v279[0] == 17)
          {
            v244 = (os_log_s *)__nwlog_obj();
            logi = v279[0];
            if (!os_log_type_enabled(v244, (os_log_type_t)v279[0])) {
              goto LABEL_302;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            v181 = v244;
            v182 = logi;
            v183 = "%{public}s called with null frame->finalizer";
            goto LABEL_301;
          }

          if (!(_BYTE)error)
          {
            v246 = (os_log_s *)__nwlog_obj();
            logk = v279[0];
            if (!os_log_type_enabled(v246, (os_log_type_t)v279[0])) {
              goto LABEL_302;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            v181 = v246;
            v182 = logk;
            v183 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_301;
          }

          v245 = __nw_create_backtrace_string();
          logj = (os_log_s *)__nwlog_obj();
          v217 = v279[0];
          v184 = os_log_type_enabled(logj, (os_log_type_t)v279[0]);
          v185 = (char *)v245;
          if (v245)
          {
            if (v184)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v245;
              _os_log_impl( &dword_181A5C000,  logj,  v217,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
              v185 = (char *)v245;
            }

            free(v185);
            goto LABEL_302;
          }

          if (v184)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            v181 = logj;
            v182 = v217;
            v183 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_301:
            _os_log_impl(&dword_181A5C000, v181, v182, v183, buf, 0xCu);
          }
        }

              if ((v4 & 0x400) == 0) {
                goto LABEL_169;
              }
              if ((*v2 & 0x80) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                BOOL v64 = (os_log_s *)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)os_log_type_t type = 136446466;
                  *(void *)&type[4] = "nw_socket_handle_socket_event";
                  *(_WORD *)&type[12] = 2082;
                  *(void *)&type[14] = v1 + 308;
                  _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Socket received ADAPTIVE_READ_TIMEOUT event",  type,  0x16u);
                }
              }

              if (_nw_signposts_once == -1)
              {
                if (_nw_signposts_enabled) {
                  goto LABEL_163;
                }
              }

              else
              {
                dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
                if (_nw_signposts_enabled)
                {
LABEL_163:
                }
              }

              BOOL v65 = *(void *)(v1 + 48);
              if (v65)
              {
                BOOL v66 = *(void *)(v65 + 24);
                if (v66)
                {
                  BOOL v67 = *(void (**)(uint64_t, uint64_t))(v66 + 160);
                  if (v67) {
                    v67(v65, v1 - 96);
                  }
                }
              }

      free(backtrace_string);
      goto LABEL_201;
    }

    if (!v62) {
      goto LABEL_201;
    }
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "nw_http_decrypt_oblivious_response";
    os_log_type_t v44 = "%{public}s called with null (response_length > response_nonce_length + tag_length), no backtrace";
LABEL_200:
    _os_log_impl(&dword_181A5C000, v42, v43, v44, (uint8_t *)__str, 0xCu);
LABEL_201:
    if (v41) {
      free(v41);
    }
    return 0LL;
  }

  uint64_t v85 = v15 + v14;
  __int16 v86 = a2;
  if (!(v15 + a7))
  {
    int v45 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "strict_calloc";
    int v46 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v46);
    if (result) {
      goto LABEL_215;
    }
    free(v46);
  }

  int v16 = (char *)calloc(1uLL, v15 + a7);
  if (!v16)
  {
    int v47 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1LL;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = v15 + a7;
    __int16 v83 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v83);
    if (result) {
      goto LABEL_215;
    }
    free(v83);
  }

  memcpy(v16, a6, a7);
  memcpy(&v16[a7], a1, v15);
  if (!v15)
  {
    int v48 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "strict_calloc";
    os_log_type_t v49 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v49);
    if (result) {
      goto LABEL_215;
    }
    free(v49);
  }

  __int16 v17 = calloc(1uLL, v15);
  if (!v17)
  {
    int v50 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1LL;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = v15;
    int v51 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v51);
    if (result) {
      goto LABEL_215;
    }
    free(v51);
  }

  uint64_t v105 = 0u;
  uint64_t v106 = 0u;
  os_log_type_t v103 = 0u;
  os_log_type_t v104 = 0u;
  os_log_type_t v101 = 0u;
  BOOL v102 = 0u;
  int v99 = 0u;
  BOOL v100 = 0u;
  v97 = 0u;
  BOOL v98 = 0u;
  os_log_type_t v95 = 0u;
  os_log_type_t v96 = 0u;
  v93 = 0u;
  uint64_t v94 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s response", a3);
  strlen(__str);
  int v18 = cchpke_initiator_export();
  if (v18)
  {
    uint64_t v19 = v18;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v20 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v108 = "nw_http_decrypt_oblivious_response";
      id v109 = 1024;
      LODWORD(v110) = v19;
      _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (v17) {
      free(v17);
    }
    if (!v16) {
      return 0LL;
    }
    goto LABEL_23;
  }

  int v22 = cchpke_params_sizeof_kdf_hash();
  if (!v22)
  {
    BOOL v63 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v108 = "strict_calloc";
    BOOL v64 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v64);
    if (result) {
      goto LABEL_215;
    }
    free(v64);
  }

  int v23 = calloc(1uLL, v22);
  if (!v23)
  {
    BOOL v65 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v108 = "strict_calloc";
    id v109 = 2048;
    BOOL v110 = 1LL;
    uint64_t v111 = 2048;
    uint64_t v112 = v22;
    BOOL v66 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v66);
    if (result) {
      goto LABEL_215;
    }
    free(v66);
  }

  ccsha256_di();
  char v24 = cchkdf_extract();
  if (v16) {
    free(v16);
  }
  if (v17) {
    free(v17);
  }
  if (v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v25 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v108 = "nw_http_decrypt_oblivious_response";
      id v109 = 1024;
      LODWORD(v110) = v24;
      _os_log_impl(&dword_181A5C000, v25, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (!v23) {
      return 0LL;
    }
    uint64_t v21 = v23;
    goto LABEL_35;
  }

  int v28 = v89;
  if (!v12)
  {
    BOOL v67 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v108 = "strict_calloc";
    BOOL v68 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v68);
    if (result) {
      goto LABEL_215;
    }
    free(v68);
  }

  int v16 = (char *)calloc(1uLL, v12);
  if (!v16)
  {
    BOOL v69 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v108 = "strict_calloc";
    id v109 = 2048;
    BOOL v110 = 1LL;
    uint64_t v111 = 2048;
    uint64_t v112 = v12;
    os_log_type_t v70 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v70);
    if (result) {
      goto LABEL_215;
    }
    free(v70);
  }

  int v29 = cchkdf_expand();
  if (v29)
  {
    int v30 = v29;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v31 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v108 = "nw_http_decrypt_oblivious_response";
      id v109 = 1024;
      LODWORD(v110) = v30;
      _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (v23) {
      free(v23);
    }
    if (!v16) {
      return 0LL;
    }
LABEL_23:
    uint64_t v21 = v16;
LABEL_35:
    free(v21);
    return 0LL;
  }

  if (!v89)
  {
    os_log_type_t v71 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v108 = "strict_calloc";
    uint32_t v72 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_215;
    }
    free(v72);
    int v28 = v89;
  }

  int v32 = calloc(1uLL, v28);
  if (!v32)
  {
    BOOL v73 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v108 = "strict_calloc";
    id v109 = 2048;
    BOOL v110 = 1LL;
    uint64_t v111 = 2048;
    uint64_t v112 = v28;
    v74 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v74);
    if (result) {
      goto LABEL_215;
    }
    free(v74);
  }

  int v33 = cchkdf_expand();
  if (v23) {
    free(v23);
  }
  if (v33)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v34 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v108 = "nw_http_decrypt_oblivious_response";
      id v109 = 1024;
      LODWORD(v110) = v33;
      _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_ERROR,  "%{public}s Nonce expand error: %d",  (uint8_t *)&buf,  0x12u);
    }

    if (v16) {
      free(v16);
    }
    if (!v32) {
      return 0LL;
    }
    uint64_t v21 = v32;
    goto LABEL_35;
  }

  os_log_type_t v35 = __size;
  if (!__size)
  {
    BOOL v75 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v108 = "strict_calloc";
    BOOL v76 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v76);
    if (result) {
      goto LABEL_215;
    }
    free(v76);
    os_log_type_t v35 = 0LL;
  }

  int v36 = calloc(1uLL, v35);
  if (!v36)
  {
    char v77 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    v108 = "strict_calloc";
    id v109 = 2048;
    BOOL v110 = 1LL;
    uint64_t v111 = 2048;
    uint64_t v112 = v35;
    BOOL v78 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v78);
    if (result) {
      goto LABEL_215;
    }
    free(v78);
    os_log_type_t v35 = __size;
  }

  int v37 = &a1[v15];
  BOOL v38 = v87;
  memcpy(v36, &v37[v87], v35);
  if (v86 == v85)
  {
    char v79 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v79, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    v108 = "strict_calloc";
    int v80 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v80);
    if (result) {
      goto LABEL_215;
    }
    free(v80);
    BOOL v38 = v87;
  }

  int v26 = calloc(1uLL, v38);
  if (v26)
  {
LABEL_62:
    ccaes_gcm_decrypt_mode();
    int v39 = ccgcm_one_shot();
    if (v16) {
      free(v16);
    }
    if (v32) {
      free(v32);
    }
    if (v36) {
      free(v36);
    }
    if (!v39)
    {
      *a8 = v38;
      return (BOOL)v26;
    }

    int v40 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v108 = "nw_http_decrypt_oblivious_response";
      id v109 = 1024;
      LODWORD(v110) = v39;
      _os_log_impl(&dword_181A5C000, v40, OS_LOG_TYPE_ERROR, "%{public}s Decrypt error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (!v26) {
      return (BOOL)v26;
    }
    uint64_t v21 = v26;
    goto LABEL_35;
  }

  __int16 v81 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
  buf = 136446722;
  v108 = "strict_calloc";
  id v109 = 2048;
  BOOL v110 = 1LL;
  uint64_t v111 = 2048;
  uint64_t v112 = v38;
  os_log_type_t v82 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v82);
  if (!result)
  {
    free(v82);
    BOOL v38 = v87;
    goto LABEL_62;
  }

      *((_BYTE *)v11 + 475) |= 0x20u;
      if ((v201->override_flags & 8) == 0)
      {
LABEL_144:
        resolver_configs = (unsigned __int8 *)v201->resolver_configs;
        if (!resolver_configs) {
          goto LABEL_192;
        }
        goto LABEL_157;
      }

        if (*(_BYTE *)(a2 + *v8)) {
          __int16 v81 = 0;
        }
LABEL_157:
        *(_DWORD *)(a1 + 56) = v81;
        goto LABEL_4;
      case 5u:
        __int16 v52 = objc_alloc_init(&OBJC_CLASS___NWPBInterface);
        os_log_type_t v53 = 32LL;
        goto LABEL_104;
      case 6u:
        __int16 v52 = objc_alloc_init(&OBJC_CLASS___NWPBInterface);
        os_log_type_t v53 = 24LL;
LABEL_104:
        objc_storeStrong((id *)(a1 + v53), v52);
        goto LABEL_3;
      case 7u:
        __int16 v52 = objc_alloc_init(&OBJC_CLASS___NWPBAgent);
        if (a1)
        {
          v116 = *(void **)(a1 + 8);
          if (!v116)
          {
            BOOL v117 = objc_alloc_init(MEMORY[0x189603FA8]);
            char v118 = *(void **)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(va, 8) = v117;

            v116 = *(void **)(a1 + 8);
          }

          [v116 addObject:v52];
        }

        if (PBReaderPlaceMark() && (NWPBAgentReadFrom((uint64_t)v52, a2) & 1) != 0)
        {
LABEL_3:
          PBReaderRecallMark();

LABEL_4:
          id v4 = *v3;
          int v5 = *(void *)(a2 + v4);
          int v7 = *(void *)(a2 + *v6);
          if (v5 >= v7) {
            return *(_BYTE *)(a2 + *v8) == 0;
          }
          continue;
        }

          free(v42);
          goto LABEL_156;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        __int16 v81 = "__nw_protocol_get_output_frames";
        int v42 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        BOOL v78 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v55 = (os_log_s *)__nwlog_obj();
          os_log_type_t v56 = type;
          if (!os_log_type_enabled(v55, type)) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v81 = "__nw_protocol_get_output_frames";
          int v46 = "%{public}s called with null return_array";
        }

        else if (v78)
        {
          BOOL v66 = (char *)__nw_create_backtrace_string();
          int v55 = (os_log_s *)__nwlog_obj();
          os_log_type_t v56 = type;
          BOOL v67 = os_log_type_enabled(v55, type);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446466;
              __int16 v81 = "__nw_protocol_get_output_frames";
              os_log_type_t v82 = 2082;
              *(void *)__int16 v83 = v66;
              _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s called with null return_array, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v66);
            if (!v42) {
              goto LABEL_156;
            }
            goto LABEL_155;
          }

          if (!v67) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v81 = "__nw_protocol_get_output_frames";
          int v46 = "%{public}s called with null return_array, no backtrace";
        }

        else
        {
          int v55 = (os_log_s *)__nwlog_obj();
          os_log_type_t v56 = type;
          if (!os_log_type_enabled(v55, type)) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v81 = "__nw_protocol_get_output_frames";
          int v46 = "%{public}s called with null return_array, backtrace limit exceeded";
        }

        os_log_type_t v70 = v55;
        os_log_type_t v71 = v56;
        uint32_t v72 = 12;
        goto LABEL_153;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v81 = "__nw_protocol_get_output_frames";
      int v51 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      BOOL v78 = 0;
      if (__nwlog_fault(v51, &type, &v78))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v81 = "__nw_protocol_get_output_frames";
            int v54 = "%{public}s called with null protocol";
LABEL_146:
            _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
          }
        }

        else if (v78)
        {
          BOOL v64 = (char *)__nw_create_backtrace_string();
          __int16 v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          BOOL v65 = os_log_type_enabled(v52, type);
          if (v64)
          {
            if (v65)
            {
              *(_DWORD *)buf = 136446466;
              __int16 v81 = "__nw_protocol_get_output_frames";
              os_log_type_t v82 = 2082;
              *(void *)__int16 v83 = v64;
              _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v64);
            goto LABEL_147;
          }

          if (v65)
          {
            *(_DWORD *)buf = 136446210;
            __int16 v81 = "__nw_protocol_get_output_frames";
            int v54 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_146;
          }
        }

        else
        {
          __int16 v52 = (os_log_s *)__nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v81 = "__nw_protocol_get_output_frames";
            int v54 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_146;
          }
        }
      }

LABEL_107:
    free(v60);
    goto LABEL_141;
  }

  int v48 = (os_log_s *)__nwlog_obj();
  os_log_type_t v49 = type;
  if (os_log_type_enabled(v48, type))
  {
    *(_DWORD *)buf = 136446210;
    int v80 = "nw_protocol_ipv4_get_output_frames";
    int v50 = "%{public}s called with null protocol";
LABEL_140:
    _os_log_impl(&dword_181A5C000, v48, v49, v50, buf, 0xCu);
  }

                      unint64_t v43 = 1LL;
LABEL_122:

                      goto LABEL_123;
                    }
                  }

                  else
                  {

                    if ((*((_BYTE *)v52 + 268) & 0x20) == 0)
                    {
LABEL_83:
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      unint64_t v43 = 1LL;
                      BOOL v67 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
                      {
                        if ((*((_BYTE *)v52 + 268) & 1) != 0) {
                          BOOL v68 = "dry-run ";
                        }
                        else {
                          BOOL v68 = "";
                        }
                        BOOL v69 = nw_endpoint_handler_copy_endpoint(v52);
                        os_log_type_t v70 = nw_endpoint_get_logging_description(v69);
                        os_log_type_t v71 = v52 + 21;
                        uint32_t v72 = *((unsigned int *)v52 + 30);
                        v168 = v70;
                        else {
                          BOOL v73 = off_189BBBBF0[v72];
                        }
                        v165 = v73;
                        __int16 v83 = v52;
                        uint64_t v84 = v83;
                        uint64_t v85 = "path";
                        switch(*((_DWORD *)v174 + 29))
                        {
                          case 0:
                            break;
                          case 1:
                            uint64_t v85 = "resolver";
                            break;
                          case 2:
                            uint64_t v85 = nw_endpoint_flow_mode_string(*(void **)&v83[62]._os_unfair_lock_opaque);
                            break;
                          case 3:
                            uint64_t v85 = "proxy";
                            break;
                          case 4:
                            uint64_t v85 = "fallback";
                            break;
                          case 5:
                            uint64_t v85 = "transform";
                            break;
                          default:
                            uint64_t v85 = "unknown-mode";
                            break;
                        }

                        __int16 v92 = v84 + 28;
                        v93 = v84;
                        os_unfair_lock_lock(v84 + 28);
                        uint64_t v94 = v93[8];
                        os_unfair_lock_unlock(v92);

                        *(_DWORD *)buf = 136448258;
                        v179 = "nw_endpoint_handler_get_alternate_path_state";
                        v180 = 2082;
                        v181 = v71;
                        v182 = 2082;
                        v183 = v68;
                        v184 = 2082;
                        v185 = (void *)v168;
                        v186 = 2082;
                        v187 = v165;
                        v188 = 2082;
                        v189 = v85;
                        v190 = 2114;
                        v191 = v94;
                        v192 = 2114;
                        v193 = (nw_endpoint *)v35;
                        v194 = 2114;
                        v195 = v38;
                        _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path % {public}@ due to non-viable current path %{public}@",  buf,  0x5Cu);

                        unint64_t v43 = 1LL;
                      }

                      os_log_type_t v56 = v67;
                      goto LABEL_122;
                    }
                  }

                  goto LABEL_191;
                }

                if (v18)
                {
                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v174);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v174);
                  if (minimize_logging)
                  {
                    if ((logging_disabled & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      os_log_type_t v56 = (os_log_s *)(id)gconnectionLogObj;
                      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
                      {
                        v149 = nw_endpoint_handler_get_id_string(v174);
                        v150 = nw_endpoint_handler_dry_run_string(v174);
                        v151 = nw_endpoint_handler_copy_endpoint(v174);
                        v152 = nw_endpoint_get_logging_description(v151);
                        v153 = nw_endpoint_handler_state_string(v174);
                        v154 = nw_endpoint_handler_mode_string(v174);
                        v155 = nw_endpoint_handler_copy_current_path(v174);
                        *(_DWORD *)buf = 136448002;
                        v179 = "nw_endpoint_handler_get_alternate_path_state";
                        v180 = 2082;
                        v181 = (void *)v149;
                        v182 = 2082;
                        v183 = v150;
                        v184 = 2082;
                        v185 = (void *)v152;
                        v186 = 2082;
                        v187 = v153;
                        v188 = 2082;
                        v189 = v154;
                        v190 = 2114;
                        v191 = v155;
                        v192 = 2114;
                        v193 = (nw_endpoint *)v35;
                        _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path % {public}@ due non-reusable flow",  buf,  0x52u);
                      }

                      goto LABEL_107;
                    }
                  }

                  else if ((logging_disabled & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    unint64_t v43 = 1LL;
                    os_log_type_t v56 = (os_log_s *)(id)gconnectionLogObj;
                    if (!os_log_type_enabled(v56, OS_LOG_TYPE_INFO)) {
                      goto LABEL_122;
                    }
                    BOOL v76 = nw_endpoint_handler_get_id_string(v174);
                    char v77 = nw_endpoint_handler_dry_run_string(v174);
                    BOOL v78 = nw_endpoint_handler_copy_endpoint(v174);
                    char v79 = nw_endpoint_get_logging_description(v78);
                    int v80 = nw_endpoint_handler_state_string(v174);
                    __int16 v81 = nw_endpoint_handler_mode_string(v174);
                    os_log_type_t v82 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448002;
                    v179 = "nw_endpoint_handler_get_alternate_path_state";
                    v180 = 2082;
                    v181 = (void *)v76;
                    v182 = 2082;
                    v183 = v77;
                    v184 = 2082;
                    v185 = (void *)v79;
                    v186 = 2082;
                    v187 = v80;
                    v188 = 2082;
                    v189 = v81;
                    v190 = 2114;
                    v191 = v82;
                    v192 = 2114;
                    v193 = (nw_endpoint *)v35;
                    _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{pub lic}@ due non-reusable flow",  buf,  0x52u);

                    goto LABEL_107;
                  }

    char v79 = alternate_port;
    address = nw_endpoint_get_address(v2);
    if (address->sa_family == 30)
    {
      if ((*(_BYTE *)(a1 + 235) & 2) != 0) {
        BOOL v65 = 5;
      }
      else {
        BOOL v65 = 2;
      }
      *((_BYTE *)v35 + 2) = v65;
      *(sockaddr *)((char *)v35 + 5) = *(sockaddr *)&address->sa_data[6];
      unint64_t v57 = 19;
      if (!v26) {
        goto LABEL_121;
      }
    }

    else
    {
      if ((*(_BYTE *)(a1 + 235) & 2) != 0) {
        BOOL v66 = 6;
      }
      else {
        BOOL v66 = 3;
      }
      *((_BYTE *)v35 + 2) = v66;
      *(_DWORD *)((char *)v35 + 5) = *(_DWORD *)&address->sa_data[2];
      unint64_t v57 = 7;
      if (!v26) {
        goto LABEL_121;
      }
    }

    goto LABEL_117;
  }

                LOBYTE(v26) = 1;
LABEL_108:
                _Block_object_dispose(buf, 8);
                if (SHIBYTE(v163) < 0) {
                  operator delete(*((void **)&v161 + 1));
                }
                goto LABEL_46;
              }

              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
              int v30 = (char *)_os_log_send_and_compose_impl();
              type.__r_.__value_.__s.__data_[0] = 16;
              LOBYTE(v151[0]) = 0;
              if (type.__r_.__value_.__s.__data_[0] == 17)
              {
                int v31 = (os_log_s *)__nwlog_obj();
                int v32 = type.__r_.__value_.__s.__data_[0];
                if (os_log_type_enabled(v31, (os_log_type_t)type.__r_.__value_.__s.__data_[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http_sniffing_should_sniff";
                  int v33 = "%{public}s called with null header_fields";
                  goto LABEL_278;
                }

    if (v27) {
      free(v27);
    }
    goto LABEL_3;
  }

  __nwlog_obj();
  int v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v59 = "nw_context_cancel";
  __int16 v17 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v56) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v17, &v56, &type))
  {
    if (v56 == 17)
    {
      __nwlog_obj();
      int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = v56;
      if (os_log_type_enabled(v18, (os_log_type_t)v56))
      {
        *(_DWORD *)buf = 136446210;
        int v59 = "nw_context_cancel";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (type)
    {
      int v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v31 = v56;
      int v32 = os_log_type_enabled(v18, (os_log_type_t)v56);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          int v59 = "nw_context_cancel";
          int v60 = 2082;
          BOOL v61 = (__uint64_t)v30;
          _os_log_impl( &dword_181A5C000,  v18,  v31,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
        goto LABEL_86;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        int v59 = "nw_context_cancel";
        _os_log_impl(&dword_181A5C000, v18, v31, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v45 = v56;
      if (os_log_type_enabled(v18, (os_log_type_t)v56))
      {
        *(_DWORD *)buf = 136446210;
        int v59 = "nw_context_cancel";
        _os_log_impl( &dword_181A5C000,  v18,  v45,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        if (v71) {
          free(v71);
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = -1;
LABEL_110:
        __int16 v81 = *(void *)(*(void *)(a1 + 48) + 8LL);
        if (*(_BYTE *)(a1 + 80))
        {
          *(void *)(a2 + 32) = 0LL;
          os_log_type_t v82 = a2 + 32;
        }

        else
        {
          *(void *)(a2 + 16) = 0LL;
          os_log_type_t v82 = a2 + 16;
        }

        __int16 v83 = *(uint64_t **)(v81 + 48);
        *(void *)(v82 + _Block_object_dispose(va, 8) = v83;
        *__int16 v83 = a2;
        *(void *)(v81 + 4_Block_object_dispose(va, 8) = v82;
        return 1LL;
      }
    }

    else
    {
      BOOL v65 = *(void *)(a2 + 16);
      BOOL v66 = *(void **)(a2 + 24);
      BOOL v64 = (void *)(a2 + 16);
      if (v65)
      {
        *(void *)(v65 + 24) = v66;
        BOOL v66 = *(void **)(a2 + 24);
LABEL_89:
        char *v66 = v65;
        goto LABEL_90;
      }
    }

    *(void *)(*(void *)(a1 + 64) + 8LL) = v66;
    goto LABEL_89;
  }

  if (*(_BYTE *)(a1 + 81))
  {
    __int16 v17 = v16 - *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    if (*(_BYTE *)(a1 + 80))
    {
      uint64_t v19 = *(void *)(a2 + 32);
      int v20 = *(void **)(a2 + 40);
      int v18 = (void *)(a2 + 32);
      if (v19)
      {
        *(void *)(v19 + 40) = v20;
        **(void **)(a2 + 40) = v19;
        goto LABEL_45;
      }
    }

    else
    {
      uint64_t v19 = *(void *)(a2 + 16);
      int v20 = *(void **)(a2 + 24);
      int v18 = (void *)(a2 + 16);
      if (v19)
      {
        *(void *)(v19 + 24) = v20;
        int v20 = *(void **)(a2 + 24);
LABEL_44:
        char *v20 = v19;
LABEL_45:
        *int v18 = 0LL;
        v18[1] = 0LL;
        *(void *)os_log_type_t type = a2;
        os_log_type_t v35 = nw_frame_split((uint64_t *)type, v17);
        if (v35)
        {
          int v36 = v35;
          int v37 = *(uint64_t **)(a1 + 64);
          BOOL v38 = *(void *)type;
          int v39 = v37 + 1;
          int v40 = *v37;
          if (*(_BYTE *)(a1 + 80))
          {
            *(void *)(*(void *)type + 32LL) = v40;
            int v41 = v38 + 32;
            int v42 = (void *)(v40 + 40);
          }

          else
          {
            *(void *)(*(void *)type + 16LL) = v40;
            int v41 = v38 + 16;
            int v42 = (void *)(v40 + 24);
          }

          if (v40) {
            int v39 = v42;
          }
          *int v39 = v41;
          const void *v37 = v38;
          *(void *)(v41 + _Block_object_dispose(va, 8) = v37;
          int v48 = *(void *)(*(void *)(a1 + 40) + 8LL);
          os_log_type_t v49 = *(_DWORD *)(v48 + 24);
          *(_DWORD *)(v48 + 24) = v49 + v17;
          if (!__CFADD__(v49, (_DWORD)v17))
          {
LABEL_130:
            if (gLogDatapath)
            {
              os_log_type_t v104 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v105 = nw_frame_unclaimed_length(*(_DWORD **)type);
                uint64_t v106 = *(_DWORD *)(v36 + 52);
                if (v106) {
                  v106 -= *(_DWORD *)(v36 + 56) + *(_DWORD *)(v36 + 60);
                }
                *(_DWORD *)buf = 136447234;
                uint64_t v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                uint64_t v112 = 1024;
                *(_DWORD *)uint64_t v113 = v17;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v6;
                LOWORD(v114) = 1024;
                *(_DWORD *)((char *)&v114 + 2) = v105;
                HIWORD(v114) = 1024;
                *(_DWORD *)v115 = v106;
                _os_log_impl( &dword_181A5C000,  v104,  OS_LOG_TYPE_DEBUG,  "%{public}s Moving split frame (%u bytes of %u, %u bytes remaining, delivering %u bytes)",  buf,  0x24u);
              }
            }

            __int16 v86 = *(void *)(*(void *)(a1 + 32) + 8LL);
            __int16 v87 = *(unsigned int *)(v86 + 24) + 1LL;
            __int16 v88 = v87 << 31 >> 31;
            *(_DWORD *)(v86 + 24) = v87;
            if (v88 == v87 && (v88 & 0x8000000000000000LL) == 0) {
              goto LABEL_150;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v89 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
            *(_DWORD *)buf = 136446978;
            uint64_t v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            uint64_t v112 = 2082;
            *(void *)uint64_t v113 = "frame_count";
            *(_WORD *)&v113[8] = 2048;
            uint64_t v114 = 1LL;
            *(_WORD *)v115 = 2048;
            *(void *)&v115[2] = v89;
            __int16 v90 = (char *)_os_log_send_and_compose_impl();
            id v109 = OS_LOG_TYPE_ERROR;
            v107 = 0;
            if (__nwlog_fault(v90, &v109, &v107))
            {
              if (v109 == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v91 = (os_log_s *)v8[131];
                __int16 v92 = v109;
                if (os_log_type_enabled(v91, v109))
                {
                  v93 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                  *(_DWORD *)buf = 136446978;
                  uint64_t v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  uint64_t v112 = 2082;
                  *(void *)uint64_t v113 = "frame_count";
                  *(_WORD *)&v113[8] = 2048;
                  uint64_t v114 = 1LL;
                  *(_WORD *)v115 = 2048;
                  *(void *)&v115[2] = v93;
                  uint64_t v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_146:
                  _os_log_impl(&dword_181A5C000, v91, v92, v94, buf, 0x2Au);
                }
              }

              else if (v107)
              {
                os_log_type_t v95 = (char *)__nw_create_backtrace_string();
                BOOL v91 = (os_log_s *)__nwlog_obj();
                __int16 v92 = v109;
                os_log_type_t v96 = os_log_type_enabled(v91, v109);
                if (v95)
                {
                  if (v96)
                  {
                    v97 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                    *(_DWORD *)buf = 136447234;
                    uint64_t v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                    uint64_t v112 = 2082;
                    *(void *)uint64_t v113 = "frame_count";
                    *(_WORD *)&v113[8] = 2048;
                    uint64_t v114 = 1LL;
                    *(_WORD *)v115 = 2048;
                    *(void *)&v115[2] = v97;
                    v116 = 2082;
                    BOOL v117 = v95;
                    _os_log_impl( &dword_181A5C000,  v91,  v92,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(v95);
                  goto LABEL_147;
                }

                if (v96)
                {
                  int v99 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                  *(_DWORD *)buf = 136446978;
                  uint64_t v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  uint64_t v112 = 2082;
                  *(void *)uint64_t v113 = "frame_count";
                  *(_WORD *)&v113[8] = 2048;
                  uint64_t v114 = 1LL;
                  *(_WORD *)v115 = 2048;
                  *(void *)&v115[2] = v99;
                  uint64_t v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                  goto LABEL_146;
                }
              }

              else
              {
                BOOL v91 = (os_log_s *)__nwlog_obj();
                __int16 v92 = v109;
                if (os_log_type_enabled(v91, v109))
                {
                  BOOL v98 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                  *(_DWORD *)buf = 136446978;
                  uint64_t v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  uint64_t v112 = 2082;
                  *(void *)uint64_t v113 = "frame_count";
                  *(_WORD *)&v113[8] = 2048;
                  uint64_t v114 = 1LL;
                  *(_WORD *)v115 = 2048;
                  *(void *)&v115[2] = v98;
                  uint64_t v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_146;
                }
              }
            }

LABEL_108:
    if (v29) {
      free(v29);
    }
    return 0LL;
  }

  if (!gLogDatapath)
  {
    uint64_t v14 = *(_WORD *)((char *)a1 + 225);
    if ((v14 & 1) == 0) {
      goto LABEL_4;
    }
    return 1LL;
  }

  __nwlog_obj();
  int v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
  {
    int v34 = *(_WORD *)((char *)a1 + 225);
    os_log_type_t v35 = "output";
    *(_DWORD *)buf = 136448514;
    unint64_t v43 = "nw_ws_validate_frame";
    os_log_type_t v44 = 2082;
    int v45 = (char *)a1 + 227;
    int v46 = 2082;
    if ((v34 & 4) != 0) {
      int v36 = "server";
    }
    else {
      int v36 = "client";
    }
    if (a7) {
      os_log_type_t v35 = "input";
    }
    int v47 = v35;
    int v48 = 2082;
    os_log_type_t v49 = v36;
    int v37 = "reads";
    int v50 = 2082;
    if (!a7) {
      int v37 = "sends";
    }
    int v51 = v37;
    __int16 v52 = 1024;
    os_log_type_t v53 = a2;
    int v54 = 1024;
    int v55 = a3;
    os_log_type_t v56 = 1024;
    unint64_t v57 = a4;
    BOOL v58 = 1024;
    int v59 = a5;
    int v60 = 1024;
    BOOL v61 = a6;
    _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s %{public}s  %{public}s %{public}s {fin: %u, rsv1: %u, op: %u, msk: %u, len: %u}",  buf,  0x52u);
  }

  uint64_t v14 = *(_WORD *)((char *)a1 + 225);
  if ((v14 & 1) != 0) {
    return 1LL;
  }
LABEL_4:
  if (a4 - 8 <= 2)
  {
    if (a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v16 = "output";
        unint64_t v43 = "nw_ws_validate_frame";
        *(_DWORD *)buf = 136446722;
        os_log_type_t v44 = 2082;
        int v45 = (char *)a1 + 227;
        if (a7) {
          int v16 = "input";
        }
        int v46 = 2082;
        int v47 = v16;
        __int16 v17 = "%{public}s %{public}s %{public}s control frame can not be compressed";
LABEL_35:
        int v22 = v15;
        int v23 = 32;
LABEL_36:
        _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_ERROR, v17, buf, v23);
        goto LABEL_37;
      }

      goto LABEL_37;
    }

    if ((a2 & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        char v24 = "output";
        unint64_t v43 = "nw_ws_validate_frame";
        *(_DWORD *)buf = 136446722;
        os_log_type_t v44 = 2082;
        int v45 = (char *)a1 + 227;
        if (a7) {
          char v24 = "input";
        }
        int v46 = 2082;
        int v47 = v24;
        __int16 v17 = "%{public}s %{public}s %{public}s control frame was not marked final";
        goto LABEL_35;
      }

      goto LABEL_37;
    }

    if (a6 >= 0x7E)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v20 = "output";
        unint64_t v43 = "nw_ws_validate_frame";
        *(_DWORD *)buf = 136446722;
        os_log_type_t v44 = 2082;
        int v45 = (char *)a1 + 227;
        if (a7) {
          int v20 = "input";
        }
        int v46 = 2082;
        int v47 = v20;
        __int16 v17 = "%{public}s %{public}s %{public}s control frame has length >125 bytes";
        goto LABEL_35;
      }

LABEL_38:
  nw_frame_claim((uint64_t)v3, v16, *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL), 0);
  *(_DWORD *)(a1[4] + 600LL) += *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
  *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = 0LL;
  if (gLogDatapath)
  {
    __nwlog_obj();
    BOOL v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
    {
LABEL_95:

      goto LABEL_55;
    }

    BOOL v65 = a1[4];
    BOOL v66 = (const char *)(v65 + 609);
    if (!v65) {
      BOOL v66 = "";
    }
LABEL_94:
    uint64_t v105 = *(_DWORD *)(v65 + 600);
    uint64_t v106 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
    *(_DWORD *)buf = 136446978;
    v132 = "nw_framer_write_output_no_copy_block_invoke";
    uint64_t v133 = 2080;
    v134 = v66;
    __int16 v135 = 1024;
    *(_DWORD *)v136 = v105;
    *(_WORD *)&v136[4] = 2048;
    *(void *)&v136[6] = v106;
    _os_log_impl( &dword_181A5C000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Pending output cursor %u, remaining output %zu",  buf,  0x26u);
    goto LABEL_95;
  }

  if (v49) {
    free(v49);
  }
LABEL_56:
}

        if (!v25) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      unint64_t v57 = "__nw_protocol_get_input_frames";
      int v25 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v54 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v38 = (os_log_s *)__nwlog_obj();
        int v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v57 = "__nw_protocol_get_input_frames";
        int v29 = "%{public}s called with null return_array";
      }

      else if (v54)
      {
        int v47 = (char *)__nw_create_backtrace_string();
        BOOL v38 = (os_log_s *)__nwlog_obj();
        int v39 = type;
        int v48 = os_log_type_enabled(v38, type);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v57 = "__nw_protocol_get_input_frames";
            BOOL v58 = 2082;
            int v59 = v47;
            _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s called with null return_array, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v47);
          if (!v25)
          {
LABEL_109:
            uint64_t v14 = 0LL;
            if (v10 == &nw_protocol_ref_counted_handle) {
              goto LABEL_13;
            }
            goto LABEL_14;
          }

        if (!v25) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      unint64_t v57 = "__nw_protocol_get_output_frames";
      int v25 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v54 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v38 = (os_log_s *)__nwlog_obj();
        int v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v57 = "__nw_protocol_get_output_frames";
        int v29 = "%{public}s called with null return_array";
      }

      else if (v54)
      {
        int v47 = (char *)__nw_create_backtrace_string();
        BOOL v38 = (os_log_s *)__nwlog_obj();
        int v39 = type;
        int v48 = os_log_type_enabled(v38, type);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v57 = "__nw_protocol_get_output_frames";
            BOOL v58 = 2082;
            int v59 = v47;
            _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s called with null return_array, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v47);
          if (!v25)
          {
LABEL_109:
            uint64_t v14 = 0LL;
            if (v10 == &nw_protocol_ref_counted_handle) {
              goto LABEL_13;
            }
            goto LABEL_14;
          }

        if (!v22) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v54 = "__nw_protocol_register_notification";
      int v22 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v51 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v35 = (os_log_s *)__nwlog_obj();
        int v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        int v54 = "__nw_protocol_register_notification";
        int v26 = "%{public}s called with null type";
      }

      else if (v51)
      {
        os_log_type_t v44 = (char *)__nw_create_backtrace_string();
        os_log_type_t v35 = (os_log_s *)__nwlog_obj();
        int v36 = type;
        int v45 = os_log_type_enabled(v35, type);
        if (v44)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            int v54 = "__nw_protocol_register_notification";
            int v55 = 2082;
            os_log_type_t v56 = v44;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v44);
          if (!v22)
          {
LABEL_109:
            uint64_t v11 = 0LL;
            if (v7 == &nw_protocol_ref_counted_handle) {
              goto LABEL_13;
            }
            goto LABEL_14;
          }

        if (!v22) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v54 = "__nw_protocol_unregister_notification";
      int v22 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v51 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v35 = (os_log_s *)__nwlog_obj();
        int v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        int v54 = "__nw_protocol_unregister_notification";
        int v26 = "%{public}s called with null type";
      }

      else if (v51)
      {
        os_log_type_t v44 = (char *)__nw_create_backtrace_string();
        os_log_type_t v35 = (os_log_s *)__nwlog_obj();
        int v36 = type;
        int v45 = os_log_type_enabled(v35, type);
        if (v44)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            int v54 = "__nw_protocol_unregister_notification";
            int v55 = 2082;
            os_log_type_t v56 = v44;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v44);
          if (!v22)
          {
LABEL_109:
            uint64_t v11 = 0LL;
            if (v7 == &nw_protocol_ref_counted_handle) {
              goto LABEL_13;
            }
            goto LABEL_14;
          }

        if (!v22) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v54 = "__nw_protocol_updated_path";
      int v22 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int v51 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v35 = (os_log_s *)__nwlog_obj();
        int v36 = type;
        if (!os_log_type_enabled(v35, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        int v54 = "__nw_protocol_updated_path";
        int v26 = "%{public}s called with null path";
      }

      else if (v51)
      {
        os_log_type_t v44 = (char *)__nw_create_backtrace_string();
        os_log_type_t v35 = (os_log_s *)__nwlog_obj();
        int v36 = type;
        int v45 = os_log_type_enabled(v35, type);
        if (v44)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            int v54 = "__nw_protocol_updated_path";
            int v55 = 2082;
            os_log_type_t v56 = v44;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v44);
          if (!v22)
          {
LABEL_109:
            uint64_t v11 = 0LL;
            if (v7 == &nw_protocol_ref_counted_handle) {
              goto LABEL_13;
            }
            goto LABEL_14;
          }

    free(backtrace_string);
    if (!v41) {
      goto LABEL_134;
    }
    goto LABEL_133;
  }

  if (v4 == (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_18956)
  {
    __nwlog_obj();
    int v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v62 = "nw_parameters_create_secure_tcp";
    int v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v59 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v47 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl( &dword_181A5C000,  v42,  v47,  "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable))",  buf,  0xCu);
      }
    }

    else if (v59)
    {
      os_log_type_t v53 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v54 = type;
      int v55 = os_log_type_enabled(v42, type);
      if (v53)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v62 = "nw_parameters_create_secure_tcp";
          BOOL v63 = 2082;
          BOOL v64 = v53;
          _os_log_impl( &dword_181A5C000,  v42,  v54,  "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v53);
LABEL_132:
        if (!v41)
        {
LABEL_134:
          uint64_t v10 = 0LL;
          goto LABEL_82;
        }

    goto LABEL_108;
  }

  if (nw_protocol_copy_webtransport_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_60063);
  }
  options = nw_protocol_create_options((void *)nw_protocol_copy_webtransport_definition::definition);
  secure_http_messaging = nw_parameters_create_secure_http_messaging( v8,  v9,  &__block_literal_global_91,  v11,  &__block_literal_global_125);
  uint64_t v14 = nw_parameters_copy_default_protocol_stack(secure_http_messaging);
  int v15 = v14;
  if (!v14)
  {
    __nwlog_obj();
    int v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v58 = "nw_parameters_create_webtransport_http";
    int v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v55 = 0;
    if (__nwlog_fault(v31, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v58 = "nw_parameters_create_webtransport_http";
          _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null stack", buf, 0xCu);
        }
      }

      else if (v55)
      {
        int v46 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v54 = type;
        int v47 = os_log_type_enabled(v32, type);
        if (v46)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v58 = "nw_parameters_create_webtransport_http";
            int v59 = 2082;
            int v60 = v46;
            _os_log_impl( &dword_181A5C000,  v32,  v54,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v46);
          goto LABEL_114;
        }

        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v58 = "nw_parameters_create_webtransport_http";
          _os_log_impl(&dword_181A5C000, v32, v54, "%{public}s called with null stack, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v53 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v58 = "nw_parameters_create_webtransport_http";
          _os_log_impl( &dword_181A5C000,  v32,  v53,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        nw_masque_send_connect((uint64_t)handle);
        return;
      }

      __nwlog_obj();
      os_log_type_t v82 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_http_connection_metadata_get_message_counts";
      __int16 v83 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v101) = 0;
      if (__nwlog_fault(v83, type, &v101))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v85 = type[0];
          if (os_log_type_enabled(v84, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_http_connection_metadata_get_message_counts";
            _os_log_impl( &dword_181A5C000,  v84,  v85,  "%{public}s metadata must be http_connection",  (uint8_t *)buf,  0xCu);
          }
        }

        else if ((_BYTE)v101)
        {
          BOOL v91 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v92 = type[0];
          v93 = os_log_type_enabled(v84, type[0]);
          if (v91)
          {
            if (v93)
            {
              LODWORD(buf[0]) = 136446466;
              *(void *)((char *)buf + 4) = "nw_http_connection_metadata_get_message_counts";
              WORD6(buf[0]) = 2082;
              *(void *)((char *)buf + 14) = v91;
              _os_log_impl( &dword_181A5C000,  v84,  v92,  "%{public}s metadata must be http_connection, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
            }

            free(v91);
            goto LABEL_223;
          }

          if (v93)
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_http_connection_metadata_get_message_counts";
            _os_log_impl( &dword_181A5C000,  v84,  v92,  "%{public}s metadata must be http_connection, no backtrace",  (uint8_t *)buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v97 = type[0];
          if (os_log_type_enabled(v84, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_http_connection_metadata_get_message_counts";
            _os_log_impl( &dword_181A5C000,  v84,  v97,  "%{public}s metadata must be http_connection, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
          }
        }
      }

              _os_log_impl(&dword_181A5C000, v68, v69, v70, buf, 0x16u);
              goto LABEL_108;
            }

            os_log_type_t v71 = *(void *)(v63 + 112);
            uint32_t v72 = *(void **)(v63 + 120);
            if (v71)
            {
              *(void *)(v71 + 120) = v72;
              uint32_t v72 = *(void **)(v63 + 120);
            }

            else
            {
              *(void *)(v13 + 336) = v72;
            }

            char *v72 = v71;
            *(void *)(v63 + 112) = 0LL;
            *(void *)(v63 + 120) = 0LL;
            char v77 = *(_DWORD *)(v13 + 456);
            *(_DWORD *)(v13 + 456) = v77 - 1;
            if (!v77) {
              break;
            }
LABEL_118:
            v97 = *(_BYTE *)(v63 + 276);
            *(_BYTE *)(v63 + 276) = v97 & 0xDF;
            if ((v97 & 0x10) == 0)
            {
              if (gLogDatapath)
              {
                v212 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v212, OS_LOG_TYPE_DEBUG))
                {
                  v213 = *(void *)(v63 + 88);
                  if (v213) {
                    v214 = *(_DWORD *)(v213 + 460);
                  }
                  else {
                    v214 = -1;
                  }
                  v229 = *(void *)(v63 + 64);
                  v230 = *(_DWORD *)(v13 + 456);
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v214;
                  *(_WORD *)&v532[6] = 2048;
                  *(void *)&v532[8] = v229;
                  *(_WORD *)&v532[16] = 2048;
                  *(void *)&v532[18] = v63;
                  *(_WORD *)&v532[26] = 1024;
                  *(_DWORD *)&v532[28] = v230;
                  _os_log_impl( &dword_181A5C000,  v212,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams",  buf,  0x40u);
                }
              }
            }

            uint32_t v72 = *(unsigned int *)(v9 + 336) + 1LL;
            BOOL v73 = v72 << 31 >> 31;
            *(_DWORD *)(v9 + 336) = v72;
            if (v73 == v72 && (v73 & 0x8000000000000000LL) == 0) {
              goto LABEL_259;
            }
            __nwlog_obj();
            v74 = *(unsigned int *)(v9 + 336);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "http1->connections_count";
            *(_WORD *)&buf[22] = 2048;
            v783 = 1LL;
            *(_WORD *)v784 = 2048;
            *(void *)&v784[2] = v74;
            BOOL v75 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(aBlock) = 0;
            if (__nwlog_fault(v75, type, &aBlock))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                BOOL v76 = (os_log_s *)__nwlog_obj();
                char v77 = type[0];
                if (os_log_type_enabled(v76, type[0]))
                {
                  BOOL v78 = *(unsigned int *)(v9 + 336);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = "http1->connections_count";
                  *(_WORD *)&buf[22] = 2048;
                  v783 = 1LL;
                  *(_WORD *)v784 = 2048;
                  *(void *)&v784[2] = v78;
                  char v79 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_255:
                  _os_log_impl(&dword_181A5C000, v76, v77, v79, buf, 0x2Au);
                }
              }

              else if ((_BYTE)aBlock)
              {
                uint64_t v114 = v31;
                v115 = (char *)__nw_create_backtrace_string();
                BOOL v76 = (os_log_s *)__nwlog_obj();
                char v77 = type[0];
                v116 = os_log_type_enabled(v76, type[0]);
                if (v115)
                {
                  if (v116)
                  {
                    BOOL v117 = *(unsigned int *)(v9 + 336);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = "http1->connections_count";
                    *(_WORD *)&buf[22] = 2048;
                    v783 = 1LL;
                    *(_WORD *)v784 = 2048;
                    *(void *)&v784[2] = v117;
                    *(_WORD *)&v784[10] = 2082;
                    *(void *)&v784[12] = v115;
                    _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(v115);
                  int v31 = v114;
                  goto LABEL_256;
                }

                int v31 = v114;
                if (v116)
                {
                  v177 = *(unsigned int *)(v9 + 336);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = "http1->connections_count";
                  *(_WORD *)&buf[22] = 2048;
                  v783 = 1LL;
                  *(_WORD *)v784 = 2048;
                  *(void *)&v784[2] = v177;
                  char v79 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                  goto LABEL_255;
                }
              }

              else
              {
                BOOL v76 = (os_log_s *)__nwlog_obj();
                char v77 = type[0];
                if (os_log_type_enabled(v76, type[0]))
                {
                  v132 = *(unsigned int *)(v9 + 336);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = "http1->connections_count";
                  *(_WORD *)&buf[22] = 2048;
                  v783 = 1LL;
                  *(_WORD *)v784 = 2048;
                  *(void *)&v784[2] = v132;
                  char v79 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_255;
                }
              }
            }

  if (v31) {
    free(v31);
  }
  return 0LL;
}

    if (v20) {
      free(v20);
    }
    return 0LL;
  }

  uint64_t v3 = *a1;
  if (!*a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v67 = "nw_frame_split";
    int v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v64 = 0;
    if (__nwlog_fault(v20, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v21 = (os_log_s *)__nwlog_obj();
        int v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v67 = "nw_frame_split";
          int v23 = "%{public}s called with null *frame";
          goto LABEL_66;
        }
      }

      else if (v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v21 = (os_log_s *)__nwlog_obj();
        int v22 = type;
        int v54 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (!v54) {
            goto LABEL_38;
          }
          *(_DWORD *)buf = 136446466;
          BOOL v67 = "nw_frame_split";
          BOOL v68 = 2082;
          BOOL v69 = (uint64_t)backtrace_string;
          int v26 = "%{public}s called with null *frame, dumping backtrace:%{public}s";
          goto LABEL_36;
        }

        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v67 = "nw_frame_split";
          int v23 = "%{public}s called with null *frame, no backtrace";
          goto LABEL_66;
        }
      }

      else
      {
        uint64_t v21 = (os_log_s *)__nwlog_obj();
        int v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v67 = "nw_frame_split";
          int v23 = "%{public}s called with null *frame, backtrace limit exceeded";
          goto LABEL_66;
        }
      }
    }

    goto LABEL_107;
  }

  if (a2)
  {
    if (!*(void *)(v3 + 112)
      || (*(_WORD *)(v3 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(*a1, *(void *)(v3 + 88))
      || (int v5 = *(_DWORD *)(v3 + 52)) == 0
      || ((int v6 = *(unsigned int *)(v3 + 56),
           int v7 = *(_DWORD *)(v3 + 60) + v6,
           int v8 = v5 - v7,
           uint64_t v10 = v5 == v7,
           BOOL v9 = *(void *)(v3 + 112),
           !v10)
        ? (uint64_t v10 = v9 == 0)
        : (uint64_t v10 = 1),
          v10))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v67 = "nw_frame_split";
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s there are no unclaimed bytes from which to create a subframe",  buf,  0xCu);
      }

      return 0LL;
    }

    if (v8 > a2)
    {
      int v16 = v9 + v6;
      if (*(void *)(v3 + 88) == 16435934LL)
      {
        __int16 v17 = v3;
      }

      else
      {
        __int16 v17 = nw_frame_create(16, v16, a2, (uint64_t)__nw_frame_split_finalizer, 16435934LL);
        metadata = nw_frame_get_metadata(v17);
        if (!metadata)
        {
          __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          BOOL v67 = "nw_frame_split";
          BOOL v68 = 2048;
          BOOL v69 = v17;
          int v20 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          BOOL v64 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v40 = (os_log_s *)__nwlog_obj();
            int v41 = type;
            if (!os_log_type_enabled(v40, type)) {
              goto LABEL_107;
            }
LABEL_52:
            *(_DWORD *)buf = 136446466;
            BOOL v67 = "nw_frame_split";
            BOOL v68 = 2048;
            BOOL v69 = v17;
            int v23 = "%{public}s frame %p has no split metadata";
LABEL_104:
            int v46 = v40;
            int v47 = v41;
            goto LABEL_105;
          }

          if (v64)
          {
            os_log_type_t v49 = (char *)__nw_create_backtrace_string();
            int v40 = (os_log_s *)__nwlog_obj();
            int v41 = type;
            int v50 = os_log_type_enabled(v40, type);
            if (v49)
            {
              if (v50) {
                goto LABEL_82;
              }
              goto LABEL_83;
            }

            if (!v50) {
              goto LABEL_107;
            }
LABEL_103:
            *(_DWORD *)buf = 136446466;
            BOOL v67 = "nw_frame_split";
            BOOL v68 = 2048;
            BOOL v69 = v17;
            int v23 = "%{public}s frame %p has no split metadata, no backtrace";
            goto LABEL_104;
          }

          int v40 = (os_log_s *)__nwlog_obj();
          int v41 = type;
          if (!os_log_type_enabled(v40, type)) {
            goto LABEL_107;
          }
LABEL_87:
          *(_DWORD *)buf = 136446466;
          BOOL v67 = "nw_frame_split";
          BOOL v68 = 2048;
          BOOL v69 = v17;
          int v23 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
          goto LABEL_104;
        }

        *(void *)metadata = v3;
        *(_BYTE *)(metadata + _Block_object_dispose(va, 8) = 3;
        nw_frame_inherit_metadata(v3, v17, 1);
        if (gLogDatapath)
        {
          uint64_t v19 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            BOOL v67 = "nw_frame_split";
            BOOL v68 = 2048;
            BOOL v69 = v17;
            os_log_type_t v70 = 2048;
            *(void *)os_log_type_t v71 = v3;
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s inserted top of tree split frame %p with parent %p",  buf,  0x20u);
          }
        }
      }

      os_log_type_t v12 = nw_frame_create(16, v16, a2, (uint64_t)__nw_frame_split_finalizer, 16435934LL);
      int v30 = nw_frame_create(16, v16 + a2, v8 - a2, (uint64_t)__nw_frame_split_finalizer, 16435934LL);
      nw_frame_inherit_metadata(v17, v12, 0);
      nw_frame_inherit_metadata(v17, v30, 1);
      int v31 = nw_frame_get_metadata(v12);
      if (v31)
      {
        int v32 = v31;
        int v33 = nw_frame_get_metadata(v30);
        if (v33)
        {
          int v34 = v33;
          os_log_type_t v35 = nw_frame_get_metadata(v17);
          if (v35)
          {
            *(_BYTE *)(v32 + _Block_object_dispose(va, 8) = 1;
            *(_BYTE *)(v34 + _Block_object_dispose(va, 8) = 2;
            *(void *)int v32 = v17;
            *(void *)int v34 = v17;
            *(_BYTE *)(v35 + 9) |= 3u;
            if (gLogDatapath)
            {
              uint64_t v62 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
              {
                BOOL v63 = *a1;
                *(_DWORD *)buf = 136447746;
                BOOL v67 = "nw_frame_split";
                BOOL v68 = 2048;
                BOOL v69 = v63;
                os_log_type_t v70 = 1024;
                *(_DWORD *)os_log_type_t v71 = v8;
                *(_WORD *)&v71[4] = 2048;
                *(void *)&v71[6] = v12;
                uint32_t v72 = 1024;
                BOOL v73 = a2;
                v74 = 2048;
                BOOL v75 = v30;
                BOOL v76 = 1024;
                char v77 = v8 - a2;
                _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_DEBUG,  "%{public}s split frame %p (%u bytes) into start child %p (%u bytes) and end child %p (%u bytes)",  buf,  0x3Cu);
              }
            }

            *a1 = v30;
            return v12;
          }

          __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          BOOL v67 = "nw_frame_split";
          BOOL v68 = 2048;
          BOOL v69 = v17;
          int v20 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          BOOL v64 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v40 = (os_log_s *)__nwlog_obj();
            int v41 = type;
            if (!os_log_type_enabled(v40, type)) {
              goto LABEL_107;
            }
            goto LABEL_52;
          }

          if (v64)
          {
            os_log_type_t v49 = (char *)__nw_create_backtrace_string();
            int v40 = (os_log_s *)__nwlog_obj();
            int v41 = type;
            __int16 v52 = os_log_type_enabled(v40, type);
            if (v49)
            {
              if (v52)
              {
LABEL_82:
                *(_DWORD *)buf = 136446722;
                BOOL v67 = "nw_frame_split";
                BOOL v68 = 2048;
                BOOL v69 = v17;
                os_log_type_t v70 = 2082;
                *(void *)os_log_type_t v71 = v49;
                _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s",  buf,  0x20u);
              }

    free(v45);
    goto LABEL_108;
  }

  uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_unique_connection_request);
  v222 = (char *)v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
    int v15 = (char *)_os_log_send_and_compose_impl();

    applier[0] = 16;
    __dst[0].sa_len = 0;
    if (__nwlog_fault(v15, applier, __dst))
    {
      if (applier[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v16 = (os_log_s *)(id)gLogObj;
        __int16 v17 = applier[0];
        if (os_log_type_enabled(v16, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s [nw_unique_connection_request init:] failed", buf, 0xCu);
        }
      }

      else if (__dst[0].sa_len)
      {
        int v48 = __nw_create_backtrace_string();
        if (v48)
        {
          os_log_type_t v49 = (char *)v48;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v50 = (os_log_s *)(id)gLogObj;
          int v51 = applier[0];
          if (os_log_type_enabled(v50, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v49;
            _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s [nw_unique_connection_request init:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v49);
          if (!v15) {
            goto LABEL_102;
          }
          goto LABEL_101;
        }

        __nwlog_obj();
        int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v87 = applier[0];
        if (os_log_type_enabled(v16, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v16,  v87,  "%{public}s [nw_unique_connection_request init:] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v16 = (os_log_s *)(id)gLogObj;
        __int16 v81 = applier[0];
        if (os_log_type_enabled(v16, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v16,  v81,  "%{public}s [nw_unique_connection_request init:] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v15)
    {
LABEL_102:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      BOOL v65 = 0LL;
LABEL_270:

LABEL_271:
      return;
    }

LABEL_108:
      if (!v54) {
        goto LABEL_72;
      }
LABEL_109:
      free(v54);
      goto LABEL_72;
    }

    if (!v77)
    {
      __nwlog_obj();
      int v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)buf = 136446210;
        int v80 = "nw_http_alt_svc_parse_and_set";
        unint64_t v57 = "%{public}s called with null port, backtrace limit exceeded";
        goto LABEL_106;
      }

      goto LABEL_107;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v62 = v78;
    BOOL v66 = os_log_type_enabled(v61, v78);
    if (backtrace_string)
    {
      if (!v66) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446466;
      int v80 = "nw_http_alt_svc_parse_and_set";
      __int16 v81 = 2082;
      os_log_type_t v82 = backtrace_string;
      BOOL v64 = "%{public}s called with null port, dumping backtrace:%{public}s";
LABEL_97:
      _os_log_impl(&dword_181A5C000, v61, v62, v64, buf, 0x16u);
LABEL_98:

      free(backtrace_string);
      if (!v54) {
        goto LABEL_72;
      }
      goto LABEL_109;
    }

    if (v66)
    {
      *(_DWORD *)buf = 136446210;
      int v80 = "nw_http_alt_svc_parse_and_set";
      BOOL v67 = "%{public}s called with null port, no backtrace";
      goto LABEL_116;
    }

  if (v54) {
    free(v54);
  }
  uint64_t v21 = 0LL;
LABEL_90:

  return v21;
}

  if (v27) {
    free(v27);
  }
  return 0LL;
}

      if (v52) {
        free(v52);
      }
      return 1LL;
    }

    int v37 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v38 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v74 = 136446722;
      *(void *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
      *(_WORD *)&v74[12] = 2080;
      *(void *)&v74[14] = a1 + 308;
      *(_WORD *)&v74[22] = 1024;
      *(_DWORD *)&v74[24] = v37;
      _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d",  v74,  0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v39 = (os_log_s *)gLogObj;
    if (v37 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v74 = 136446466;
        *(void *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = 22;
        _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d",  v74,  0x12u);
      }

      goto LABEL_82;
    }

    *(_DWORD *)v74 = 136446466;
    *(void *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = v37;
    int v42 = (char *)_os_log_send_and_compose_impl();
    v61[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v66) = 0;
    if (__nwlog_fault(v42, v61, &v66))
    {
      if (v61[0] == OS_LOG_TYPE_FAULT)
      {
        unint64_t v43 = (os_log_s *)__nwlog_obj();
        os_log_type_t v44 = v61[0];
        if (!os_log_type_enabled(v43, v61[0])) {
          goto LABEL_80;
        }
        *(_DWORD *)v74 = 136446466;
        *(void *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = v37;
        int v45 = "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d";
        goto LABEL_79;
      }

      if (!(_BYTE)v66)
      {
        unint64_t v43 = (os_log_s *)__nwlog_obj();
        os_log_type_t v44 = v61[0];
        if (!os_log_type_enabled(v43, v61[0])) {
          goto LABEL_80;
        }
        *(_DWORD *)v74 = 136446466;
        *(void *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = v37;
        int v45 = "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_79;
      }

      int v46 = (char *)__nw_create_backtrace_string();
      unint64_t v43 = (os_log_s *)__nwlog_obj();
      os_log_type_t v44 = v61[0];
      int v47 = os_log_type_enabled(v43, v61[0]);
      if (v46)
      {
        if (v47)
        {
          *(_DWORD *)v74 = 136446722;
          *(void *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
          *(_WORD *)&v74[12] = 1024;
          *(_DWORD *)&v74[14] = v37;
          *(_WORD *)&v74[18] = 2082;
          *(void *)&v74[20] = v46;
          _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d, dumping backtrace:%{public}s",  v74,  0x1Cu);
        }

        free(v46);
        goto LABEL_80;
      }

      if (v47)
      {
        *(_DWORD *)v74 = 136446466;
        *(void *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = v37;
        int v45 = "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d, no backtrace";
LABEL_79:
        _os_log_impl(&dword_181A5C000, v43, v44, v45, v74, 0x12u);
      }
    }

      free(v35);
      goto LABEL_108;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v22 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)address = 136446466;
      *(void *)&address[2] = "nw_listener_socket_inbox_create_socket";
      address[6] = 1024;
      *(_DWORD *)&address[7] = v20;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s IP Protocol %u unrecognized",  (uint8_t *)address,  0x12u);
    }
  }

      return;
    default:
      goto LABEL_107;
  }

  return v51;
}

        goto LABEL_108;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __int16 v83 = nw_endpoint_handler_get_id_string(v3);
        uint64_t v84 = nw_endpoint_handler_dry_run_string(v3);
        uint64_t v85 = nw_endpoint_handler_copy_endpoint(v3);
        __int16 v86 = nw_endpoint_get_logging_description(v85);
        __int16 v87 = nw_endpoint_handler_state_string(v3);
        __int16 v88 = nw_endpoint_handler_mode_string(v3);
        uint64_t v89 = nw_endpoint_handler_copy_current_path(v3);
        *(_DWORD *)buf = 136447746;
        uint64_t v133 = "nw_endpoint_handler_remove_all_interface_options";
        v134 = 2082;
        id_str = (void *)v83;
        v136 = 2082;
        __int16 v137 = v84;
        v138 = 2082;
        __int16 v139 = (void *)v86;
        v140 = 2082;
        uint64_t v141 = v87;
        v142 = 2082;
        v143 = v88;
        v144 = 2114;
        v145 = v89;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removing all interface option details",  buf,  0x48u);

        int v5 = &qword_18C45F000;
      }
    }

    else
    {
      int v6 = v3;
      int v7 = *((_BYTE *)v6 + 268);

      if ((v7 & 0x20) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v8 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        BOOL v9 = v6;

        uint64_t v10 = v9;
        uint64_t v11 = *((_BYTE *)v6 + 268);

        if ((v11 & 1) != 0) {
          os_log_type_t v12 = "dry-run ";
        }
        else {
          os_log_type_t v12 = "";
        }
        uint64_t v13 = nw_endpoint_handler_copy_endpoint(v10);
        uint64_t v14 = nw_endpoint_get_logging_description(v13);
        v123 = v9->id_str;
        int v15 = v10;
        int v16 = v15;
        __int16 v17 = v15[30];
        else {
          int v18 = off_189BBBBF0[v17];
        }

        int v30 = v16;
        int v31 = v30;
        int v32 = "path";
        switch(v3->mode)
        {
          case 0:
            break;
          case 1:
            int v32 = "resolver";
            break;
          case 2:
            int v32 = nw_endpoint_flow_mode_string(v30[31]);
            break;
          case 3:
            int v32 = "proxy";
            break;
          case 4:
            int v32 = "fallback";
            break;
          case 5:
            int v32 = "transform";
            break;
          default:
            int v32 = "unknown-mode";
            break;
        }

        int v36 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v36 + 28);
        int v37 = v36[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v36 + 28);

        *(_DWORD *)buf = 136447746;
        uint64_t v133 = "nw_endpoint_handler_remove_all_interface_options";
        v134 = 2082;
        id_str = v123;
        v136 = 2082;
        __int16 v137 = v12;
        v138 = 2082;
        __int16 v139 = (void *)v14;
        v140 = 2082;
        uint64_t v141 = v18;
        v142 = 2082;
        v143 = v32;
        v144 = 2114;
        v145 = v37;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removing all interface option details",  buf,  0x48u);

        int v5 = &qword_18C45F000;
      }
    }

    goto LABEL_45;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v19 = (id)gLogObj;
  int v20 = v2;
  else {
    uint64_t v21 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  uint64_t v133 = "nw_endpoint_handler_remove_all_interface_options";
  v134 = 2082;
  id_str = (void *)v21;
  v136 = 2082;
  __int16 v137 = "flow";
  int v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v12_Block_object_dispose(va, 8) = 0;
  if (__nwlog_fault(v22, type, &v128))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v23 = (os_log_s *)(id)gLogObj;
      char v24 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        else {
          int v25 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v133 = "nw_endpoint_handler_remove_all_interface_options";
        v134 = 2082;
        id_str = (void *)v25;
        v136 = 2082;
        __int16 v137 = "flow";
        _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    else if ((_BYTE)v128)
    {
      int v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v23 = (os_log_s *)(id)gLogObj;
      int v27 = type[0];
      int v28 = os_log_type_enabled(v23, type[0]);
      if (v26)
      {
        if (v28)
        {
          else {
            int v29 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446978;
          uint64_t v133 = "nw_endpoint_handler_remove_all_interface_options";
          v134 = 2082;
          id_str = (void *)v29;
          v136 = 2082;
          __int16 v137 = "flow";
          v138 = 2082;
          __int16 v139 = v26;
          _os_log_impl( &dword_181A5C000,  v23,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v26);
        if (v22) {
          goto LABEL_100;
        }
        goto LABEL_109;
      }

      if (v28)
      {
        else {
          os_log_type_t v35 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v133 = "nw_endpoint_handler_remove_all_interface_options";
        v134 = 2082;
        id_str = (void *)v35;
        v136 = 2082;
        __int16 v137 = "flow";
        _os_log_impl( &dword_181A5C000,  v23,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v23 = (os_log_s *)(id)gLogObj;
      int v33 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        else {
          int v34 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v133 = "nw_endpoint_handler_remove_all_interface_options";
        v134 = 2082;
        id_str = (void *)v34;
        v136 = 2082;
        __int16 v137 = "flow";
        _os_log_impl( &dword_181A5C000,  v23,  v33,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v22) {
LABEL_100:
  }
    free(v22);
LABEL_109:
}

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            int v41 = (os_log_s *)gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_113;
            }
            BOOL v73 = *(_DWORD *)(a2 + 176);
            uint32_t v72 = *(_DWORD *)(a2 + 180);
            *(_DWORD *)buf = 136447490;
            v107 = "nw_http2_stream_close";
            v108 = 2082;
            id v109 = (const char *)(a2 + 191);
            BOOL v110 = 2080;
            uint64_t v111 = (uint64_t)" ";
            uint64_t v112 = 1024;
            *(_DWORD *)uint64_t v113 = v72;
            *(_WORD *)&v113[4] = 1024;
            *(_DWORD *)&v113[6] = v73;
            uint64_t v114 = 1024;
            v115 = v73;
            os_log_type_t v44 = "%{public}s %{public}s%s<i%u:s%d> did not remove stream %d from id table";
            goto LABEL_112;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v53 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
            goto LABEL_107;
          }
          int v55 = *(_DWORD *)(a2 + 176);
          int v54 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447490;
          v107 = "nw_http2_remove_from_id_table";
          v108 = 2082;
          id v109 = (const char *)(a2 + 191);
          BOOL v110 = 2080;
          uint64_t v111 = (uint64_t)" ";
          uint64_t v112 = 1024;
          *(_DWORD *)uint64_t v113 = v54;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v55;
          uint64_t v114 = 1024;
          v115 = v55;
          int v50 = "%{public}s %{public}s%s<i%u:s%d> stream %d is not present in id based table, will not remove";
          int v51 = (os_log_s *)v53;
          __int16 v52 = OS_LOG_TYPE_INFO;
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          int v47 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_107;
          }
          os_log_type_t v49 = *(_DWORD *)(a2 + 176);
          int v48 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447490;
          v107 = "nw_http2_remove_from_id_table";
          v108 = 2082;
          id v109 = (const char *)(a2 + 191);
          BOOL v110 = 2080;
          uint64_t v111 = (uint64_t)" ";
          uint64_t v112 = 1024;
          *(_DWORD *)uint64_t v113 = v48;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v49;
          uint64_t v114 = 1024;
          v115 = v49;
          int v50 = "%{public}s %{public}s%s<i%u:s%d> id based table is NULL, cannot remove stream %d";
          int v51 = (os_log_s *)v47;
          __int16 v52 = OS_LOG_TYPE_ERROR;
        }

        _os_log_impl(&dword_181A5C000, v51, v52, v50, buf, 0x32u);
        goto LABEL_107;
      }

      if ((v36 & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v9 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v46 = *(_DWORD *)(a2 + 176);
          int v45 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447234;
          v107 = "nw_http2_stream_close";
          v108 = 2082;
          id v109 = (const char *)(a2 + 191);
          BOOL v110 = 2080;
          uint64_t v111 = (uint64_t)" ";
          uint64_t v112 = 1024;
          *(_DWORD *)uint64_t v113 = v45;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v46;
          os_log_type_t v12 = "%{public}s %{public}s%s<i%u:s%d> stream id is -1, skipping removal from id based table";
          goto LABEL_70;
        }
      }

      return;
    }

    *(_BYTE *)(a2 + 190) = BYTE2(v5);
    *(_WORD *)(a2 + 18_Block_object_dispose(va, 8) = v5 & 0xFFFE;
    if ((v5 & 0x80000) != 0 || !gLogDatapath) {
      goto LABEL_22;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v95 = (os_log_s *)gconnectionLogObj;
    os_log_type_t v96 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
    v97 = *v4;
    if (v96)
    {
      BOOL v98 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447234;
      v107 = "nw_http2_stream_send_rst_stream";
      v108 = 2082;
      id v109 = (const char *)(a2 + 191);
      BOOL v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      uint64_t v112 = 1024;
      *(_DWORD *)uint64_t v113 = v98;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v97;
      _os_log_impl(&dword_181A5C000, v95, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", buf, 0x2Cu);
      v97 = *(_DWORD *)(a2 + 176);
    }

    if (v97 == -1)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v99 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_37;
      }
      os_log_type_t v101 = *(_DWORD *)(a2 + 176);
      BOOL v100 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v107 = "nw_http2_stream_send_rst_stream";
      v108 = 2082;
      id v109 = (const char *)(a2 + 191);
      BOOL v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      uint64_t v112 = 1024;
      *(_DWORD *)uint64_t v113 = v100;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v101;
      uint64_t v114 = 1024;
      v115 = v101;
      int v20 = "%{public}s %{public}s%s<i%u:s%d> cannot send RST_STREAM for stream with invalid stream id %d";
      uint64_t v21 = (os_log_s *)v99;
      int v22 = OS_LOG_TYPE_ERROR;
    }

    else
    {
LABEL_22:
      uint64_t v13 = *(void *)(a1 + 264);
      if (v13) {
        (*(void (**)(void))(v13 + 16))();
      }
      uint64_t v14 = nghttp2_submit_rst_stream();
      int v15 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
      if (v14)
      {
        if ((v15 & 0x80000) != 0) {
          goto LABEL_37;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v16 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_37;
        }
        int v18 = *(_DWORD *)(a2 + 176);
        __int16 v17 = *(_DWORD *)(a2 + 180);
        uint64_t v19 = nghttp2_strerror();
        *(_DWORD *)buf = 136447746;
        v107 = "nw_http2_stream_send_rst_stream";
        v108 = 2082;
        id v109 = (const char *)(a2 + 191);
        BOOL v110 = 2080;
        uint64_t v111 = (uint64_t)" ";
        uint64_t v112 = 1024;
        *(_DWORD *)uint64_t v113 = v17;
        *(_WORD *)&v113[4] = 1024;
        *(_DWORD *)&v113[6] = v18;
        uint64_t v114 = 1024;
        v115 = v18;
        v116 = 2082;
        BOOL v117 = v19;
        int v20 = "%{public}s %{public}s%s<i%u:s%d> Failed to submit RST_STREAM on stream %d: %{public}s";
        uint64_t v21 = (os_log_s *)v16;
        int v22 = OS_LOG_TYPE_ERROR;
        int v23 = 60;
LABEL_36:
        _os_log_impl(&dword_181A5C000, v21, v22, v20, buf, v23);
LABEL_37:
        nw_http2_session_send(a1);
        goto LABEL_38;
      }

      if ((v15 & 0x80000) != 0) {
        goto LABEL_37;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      char v24 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_37;
      }
      int v26 = *(_DWORD *)(a2 + 176);
      int v25 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v107 = "nw_http2_stream_send_rst_stream";
      v108 = 2082;
      id v109 = (const char *)(a2 + 191);
      BOOL v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      uint64_t v112 = 1024;
      *(_DWORD *)uint64_t v113 = v25;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v26;
      uint64_t v114 = 1024;
      v115 = v26;
      int v20 = "%{public}s %{public}s%s<i%u:s%d> Submitted RST_STREAM on stream %d";
      uint64_t v21 = (os_log_s *)v24;
      int v22 = OS_LOG_TYPE_INFO;
    }

    int v23 = 50;
    goto LABEL_36;
  }

  *(_BYTE *)(a2 + 190) = BYTE2(v5);
  *(_WORD *)(a2 + 18_Block_object_dispose(va, 8) = v5 & 0xFFFE;
  *(_DWORD *)(a2 + 176) = -1;
  if ((v5 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v9 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = *(_DWORD *)(a2 + 176);
      uint64_t v10 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447234;
      v107 = "nw_http2_stream_close";
      v108 = 2082;
      id v109 = (const char *)(a2 + 191);
      BOOL v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      uint64_t v112 = 1024;
      *(_DWORD *)uint64_t v113 = v10;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v11;
      os_log_type_t v12 = "%{public}s %{public}s%s<i%u:s%d> stream id is -1, skipping rst_stream and removal from id based table";
LABEL_70:
      _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_DEBUG, v12, buf, 0x2Cu);
    }
  }

    if (!v50) {
      return 0LL;
    }
    int v31 = (char *)v50;
    goto LABEL_56;
  }

  int v8 = v7;
  if (a3)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      unint64_t v43 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v45 = *(_DWORD *)(a3 + 176);
        os_log_type_t v44 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447490;
        BOOL v64 = "nw_http2_add_to_protocol_table";
        BOOL v65 = 2082;
        BOOL v66 = (char *)(a3 + 191);
        BOOL v67 = 2080;
        BOOL v68 = " ";
        BOOL v69 = 1024;
        os_log_type_t v70 = v44;
        os_log_type_t v71 = 1024;
        *(_DWORD *)uint32_t v72 = v45;
        *(_WORD *)&v72[4] = 2048;
        *(void *)&v72[6] = a2;
        _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> added protocol %p to protocol hash table",  buf,  0x36u);
      }
    }

    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v46 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v48 = *(_DWORD *)(a3 + 176);
        int v47 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136448002;
        BOOL v64 = "nw_http2_add_to_protocol_table";
        BOOL v65 = 2082;
        BOOL v66 = (char *)(a3 + 191);
        BOOL v67 = 2080;
        BOOL v68 = " ";
        BOOL v69 = 1024;
        os_log_type_t v70 = v47;
        os_log_type_t v71 = 1024;
        *(_DWORD *)uint32_t v72 = v48;
        *(_WORD *)&v72[4] = 2048;
        *(void *)&v72[6] = a2;
        *(_WORD *)&v72[14] = 2048;
        *(void *)&v72[16] = v8;
        *(_WORD *)&v72[24] = 2048;
        *(void *)&v72[26] = a3;
        _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> connecting protocol %p node %p with stream %p",  buf,  0x4Au);
      }
    }

    *(void *)nw_hash_node_get_extra(v_Block_object_dispose(va, 8) = a3;
  }

  else if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v41 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v42 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      BOOL v64 = "nw_http2_add_to_protocol_table";
      BOOL v65 = 2082;
      BOOL v66 = (char *)(a1 + 390);
      BOOL v67 = 2080;
      BOOL v68 = " ";
      BOOL v69 = 1024;
      os_log_type_t v70 = v42;
      os_log_type_t v71 = 2048;
      *(void *)uint32_t v72 = a2;
      _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> added protocol %p to protocol hash table",  buf,  0x30u);
    }
  }

  return v8;
}

    if (!a20) {
      return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
    }
LABEL_108:
    if (a21) {
      HIDWORD(v52) = a21;
    }
    return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
  int v27 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v44 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v28 = (os_log_s *)gLogObj;
    int v29 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      int v30 = "%{public}s called with null netagent_uuid";
LABEL_121:
      _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      goto LABEL_122;
    }

    goto LABEL_122;
  }

  if (v44)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v28 = (os_log_s *)gLogObj;
    int v29 = type;
    int v36 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
        int v30 = "%{public}s called with null netagent_uuid, no backtrace";
        goto LABEL_121;
      }

      goto LABEL_122;
    }

    if (!v36)
    {
LABEL_116:
      free(backtrace_string);
      goto LABEL_122;
    }

    goto LABEL_114;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v28 = (os_log_s *)gLogObj;
  int v29 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
    int v30 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
    goto LABEL_121;
  }

    free(v60);
    goto LABEL_141;
  }

  int v48 = (os_log_s *)__nwlog_obj();
  os_log_type_t v49 = type;
  if (os_log_type_enabled(v48, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v81 = "nw_protocol_ipv6_get_output_frames";
    int v50 = "%{public}s called with null protocol";
LABEL_140:
    _os_log_impl(&dword_181A5C000, v48, v49, v50, buf, 0xCu);
  }

    if (v56) {
      free(v56);
    }
    goto LABEL_109;
  }

  __nwlog_obj();
  int v51 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)label = 136446210;
  *(void *)&label[4] = "nw_masque_server_create";
  __int16 v52 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  LOBYTE(v73.receiver) = 0;
  if (__nwlog_fault(v52, buf, &v73))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v54 = buf[0];
      if (os_log_type_enabled(v53, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)label = 136446210;
        *(void *)&label[4] = "nw_masque_server_create";
        _os_log_impl(&dword_181A5C000, v53, v54, "%{public}s called with null queue", (uint8_t *)label, 0xCu);
      }
    }

    else
    {
      if (LOBYTE(v73.receiver))
      {
        int v59 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v61 = buf[0];
        uint64_t v62 = os_log_type_enabled(v60, (os_log_type_t)buf[0]);
        if (v59)
        {
          if (v62)
          {
            *(_DWORD *)label = 136446466;
            *(void *)&label[4] = "nw_masque_server_create";
            *(_WORD *)&label[12] = 2082;
            *(void *)&label[14] = v59;
            _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s called with null queue, dumping backtrace:%{public}s",  (uint8_t *)label,  0x16u);
          }

          free(v59);
        }

        else
        {
          if (v62)
          {
            *(_DWORD *)label = 136446210;
            *(void *)&label[4] = "nw_masque_server_create";
            _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s called with null queue, no backtrace",  (uint8_t *)label,  0xCu);
          }
        }

        goto LABEL_101;
      }

      __nwlog_obj();
      os_log_type_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v67 = buf[0];
      if (os_log_type_enabled(v53, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)label = 136446210;
        *(void *)&label[4] = "nw_masque_server_create";
        _os_log_impl( &dword_181A5C000,  v53,  v67,  "%{public}s called with null queue, backtrace limit exceeded",  (uint8_t *)label,  0xCu);
      }
    }
  }

uint64_t nw_channel_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v115 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
    int v25 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(packet) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v85 = (os_log_s *)__nwlog_obj();
      os_log_type_t v86 = type[0];
      if (!os_log_type_enabled(v85, type[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      int v28 = "%{public}s called with null channel_protocol";
      goto LABEL_189;
    }

    if ((_BYTE)packet)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v85 = (os_log_s *)__nwlog_obj();
      os_log_type_t v86 = type[0];
      BOOL v92 = os_log_type_enabled(v85, type[0]);
      if (backtrace_string)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          v93 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_168:
          _os_log_impl(&dword_181A5C000, v85, v86, v93, buf, 0x16u);
        }

void nw_frame_reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v6 = *(unsigned __int16 *)(a1 + 204);
    *(void *)(a1 + 80) = a4;
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = a5;
    *(void *)(a1 + 112) = a2;
    *(void *)(a1 + 104) = 0LL;
    *(_WORD *)(a1 + 196) = 0;
    *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = a3;
    *(_DWORD *)(a1 + 52) = a3;
    *(void *)(a1 + 56) = 0LL;
    *(_DWORD *)(a1 + 192) = 0;
    *(_BYTE *)(a1 + 200) = 0;
    unsigned int v7 = v6 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
    *(_WORD *)(a1 + 204) = v7;
    *(_BYTE *)(a1 + 206) = BYTE2(v7);
    uint64_t v9 = a1 + 64;
    int v8 = *(void **)(a1 + 64);
    if (v8)
    {
      uint64_t v10 = (void *)(a1 + 120);
      do
      {
        uint64_t v11 = (void *)*v8;
        int v12 = (void *)v8[6];
        unsigned int v13 = (void *)*v8;
        if (v12)
        {
          os_release(v12);
          v8[6] = 0LL;
          unsigned int v13 = (void *)*v8;
        }

        unsigned int v14 = (void *)v8[1];
        if (v13)
        {
          v13[1] = v14;
          unsigned int v14 = (void *)v8[1];
        }

        else
        {
          *(void *)(a1 + 72) = v14;
        }

        void *v14 = v13;
        if (v8 != v10) {
          free(v8);
        }
        int v8 = v11;
      }

      while (v11);
    }

    *(void *)(a1 + 64) = 0LL;
    *(void *)(a1 + 72) = v9;
    uint64_t v15 = *(void **)(a1 + 168);
    if (v15) {
      os_release(v15);
    }
    __int16 v17 = *(_WORD *)(a1 + 204);
    int v16 = (_WORD *)(a1 + 204);
    *(void *)(v16 - 10) = 0LL;
    *(_OWORD *)(v16 - 1_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v16 - 26) = 0u;
    *(_OWORD *)(v16 - 34) = 0u;
    *(_OWORD *)(v16 - 42) = 0u;
    *int v16 = v17 & 0x213F;
    *((_BYTE *)v16 - 1) = 0;
    *(v16 - 3) = 0;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v27 = "__nw_frame_reset";
  int v18 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v18, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "__nw_frame_reset";
      unsigned int v21 = "%{public}s called with null frame";
      goto LABEL_29;
    }

    if (!v24)
    {
      int v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "__nw_frame_reset";
      unsigned int v21 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_29;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v19 = (os_log_s *)__nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v23 = os_log_type_enabled(v19, type);
    if (backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v27 = "__nw_frame_reset";
        __int16 v28 = 2082;
        unsigned int v29 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_30;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "__nw_frame_reset";
      unsigned int v21 = "%{public}s called with null frame, no backtrace";
LABEL_29:
      _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
    }
  }

BOOL nw_frame_claim(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x80) == 0) {
      goto LABEL_21;
    }
    if (!a4)
    {
LABEL_20:
      *(_WORD *)(a1 + 196) -= a3;
LABEL_21:
      unsigned int v13 = *(_DWORD *)(a1 + 56) + a3;
      int v14 = *(_DWORD *)(a1 + 60) + a4;
      if (v13 <= *(_DWORD *)(a1 + 52) - v14)
      {
        *(_DWORD *)(a1 + 56) = v13;
        *(_DWORD *)(a1 + 60) = v14;
        return 1LL;
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = (os_log_s *)gLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          int v17 = *(_DWORD *)(a1 + 52);
          *(_DWORD *)buf = 136446978;
          os_log_type_t v27 = "__nw_frame_claim_internal";
          __int16 v28 = 1024;
          LODWORD(v29) = v13;
          WORD2(v29) = 1024;
          *(_DWORD *)((char *)&v29 + 6) = v17;
          WORD5(v29) = 1024;
          HIDWORD(v29) = v14;
          _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
          return 0LL;
        }
      }

      return result;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v27 = "__nw_frame_claim_internal";
    __int16 v28 = 1024;
    LODWORD(v29) = a4;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v7, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v8 = (os_log_s *)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v27 = "__nw_frame_claim_internal";
        __int16 v28 = 1024;
        LODWORD(v29) = a4;
        uint64_t v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate";
        goto LABEL_17;
      }

      if (!v24)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v8 = (os_log_s *)gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v27 = "__nw_frame_claim_internal";
        __int16 v28 = 1024;
        LODWORD(v29) = a4;
        uint64_t v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, backtrace limit exceeded";
        goto LABEL_17;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = (os_log_s *)gLogObj;
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v27 = "__nw_frame_claim_internal";
          __int16 v28 = 1024;
          LODWORD(v29) = a4;
          WORD2(v29) = 2082;
          *(void *)((char *)&v29 + 6) = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v27 = "__nw_frame_claim_internal";
        __int16 v28 = 1024;
        LODWORD(v29) = a4;
        uint64_t v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, no backtrace";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0x12u);
      }
    }

uint64_t nw_channel_frame_check_validity(nw_frame *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v13 = "nw_channel_frame_check_validity";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v13 = "nw_channel_frame_check_validity";
      unsigned int v7 = "%{public}s called with null context";
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v13 = "nw_channel_frame_check_validity";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (!v9)
      {
LABEL_26:
        if (v4) {
          free(v4);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      unsigned int v13 = "nw_channel_frame_check_validity";
      unsigned int v7 = "%{public}s called with null context, no backtrace";
    }

    else
    {
      int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v13 = "nw_channel_frame_check_validity";
      unsigned int v7 = "%{public}s called with null context, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_26;
  }

  if (a2[17])
  {
    if (((*((unsigned __int16 *)a2 + 222) | (*((unsigned __int8 *)a2 + 446) << 16)) & 0x80000) == 0)
    {
      nw_channel_handle_defunct((uint64_t)a2);
    }
  }

  else
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
    }
    if (_nw_signposts_enabled)
    {
      uint64_t result = kdebug_is_enabled();
      if (!(_DWORD)result) {
        return result;
      }
      kdebug_trace();
    }
  }

  return 0LL;
}

uint64_t in_pseudo(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3 = a2 + (unint64_t)a1 + a3;
  return (unsigned __int16)(((WORD1(v3) + (unsigned __int16)v3) >> 16)
                          + WORD1(v3)
                          + v3
}

uint64_t in_addword(int a1, int a2)
{
  unsigned int v2 = ((a2 + a1) >> 16) + (unsigned __int16)(a2 + a1);
  return (unsigned __int16)(HIWORD(v2) + v2 + ((HIWORD(v2) + (unsigned __int16)v2) >> 16));
}

uint64_t nw_channel_set_internet_checksum_handler(nw_frame *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t metadata = nw_frame_get_metadata((uint64_t)a1);
  if (metadata)
  {
    if ((*(_BYTE *)(metadata + 24) & 1) != 0) {
      return os_packet_set_inet_checksum();
    }
    else {
      return 45LL;
    }
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v12 = "nw_channel_set_internet_checksum_handler";
  unint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v12 = "nw_channel_set_internet_checksum_handler";
        os_log_type_t v6 = "%{public}s called with null frame_info";
LABEL_18:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v12 = "nw_channel_set_internet_checksum_handler";
          __int16 v13 = 2082;
          __int16 v14 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame_info, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v12 = "nw_channel_set_internet_checksum_handler";
        os_log_type_t v6 = "%{public}s called with null frame_info, no backtrace";
        goto LABEL_18;
      }
    }

    else
    {
      id v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v12 = "nw_channel_set_internet_checksum_handler";
        os_log_type_t v6 = "%{public}s called with null frame_info, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }

uint64_t nw_frame_get_metadata(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 4) != 0) {
      return a1 + 208;
    }
    else {
      return 0LL;
    }
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "__nw_frame_get_metadata";
  unsigned int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_frame_get_metadata";
        os_log_type_t v5 = "%{public}s called with null frame";
LABEL_19:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "__nw_frame_get_metadata";
          __int16 v12 = 2082;
          __int16 v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_frame_get_metadata";
        os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_19;
      }
    }

    else
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "__nw_frame_get_metadata";
        os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }

uint64_t nw_protocol_ipv4_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v47 = "nw_protocol_ipv4_finalize_output_frames";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446210;
      int v47 = "nw_protocol_ipv4_finalize_output_frames";
      os_log_type_t v27 = "%{public}s called with null protocol";
LABEL_89:
      _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
      goto LABEL_90;
    }

    if (!v44)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        int v47 = "nw_protocol_ipv4_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v32 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        int v47 = "nw_protocol_ipv4_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (!v32) {
      goto LABEL_63;
    }
    *(_DWORD *)buf = 136446466;
    int v47 = "nw_protocol_ipv4_finalize_output_frames";
    __int16 v48 = 2082;
    os_log_type_t v49 = backtrace_string;
    int v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_62:
    _os_log_impl(&dword_181A5C000, v25, v26, v33, buf, 0x16u);
    goto LABEL_63;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v47 = "nw_protocol_ipv4_finalize_output_frames";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446210;
      int v47 = "nw_protocol_ipv4_finalize_output_frames";
      os_log_type_t v27 = "%{public}s called with null ipv4";
      goto LABEL_89;
    }

    if (!v44)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        int v47 = "nw_protocol_ipv4_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v34 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        int v47 = "nw_protocol_ipv4_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_89;
      }

      goto LABEL_90;
    }

    if (!v34) {
      goto LABEL_63;
    }
    *(_DWORD *)buf = 136446466;
    int v47 = "nw_protocol_ipv4_finalize_output_frames";
    __int16 v48 = 2082;
    os_log_type_t v49 = backtrace_string;
    int v33 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
    goto LABEL_62;
  }

  v38[0] = MEMORY[0x1895F87A8];
  v38[1] = 0x40000000LL;
  unsigned int v39 = ___ZL39nw_protocol_ipv4_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  unsigned int v40 = &__block_descriptor_tmp_32_86116;
  p_output_handler = &a1[1].output_handler;
  uint64_t v42 = a2;
  unint64_t v43 = a1;
  tqh_first = a2->tqh_first;
  do
  {
    if (!tqh_first) {
      break;
    }
    os_log_type_t v5 = (nw_frame *)*((void *)tqh_first + 4);
    char v6 = ((uint64_t (*)(void *))v39)(v38);
    tqh_first = v5;
  }

  while ((v6 & 1) != 0);
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v47 = "__nw_protocol_finalize_output_frames";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        int v47 = "__nw_protocol_finalize_output_frames";
        os_log_type_t v27 = "%{public}s called with null protocol";
        goto LABEL_89;
      }

uint64_t nw_frame_get_finalizer_context(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 88);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "nw_frame_get_finalizer_context";
  unsigned int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_frame_get_finalizer_context";
        os_log_type_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "nw_frame_get_finalizer_context";
          __int16 v12 = 2082;
          __int16 v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_frame_get_finalizer_context";
        os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_frame_get_finalizer_context";
        os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

BOOL nw_frame_unclaim(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  *(void *)&v36[13] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v34 = "__nw_frame_unclaim_internal";
    int v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v25, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v26 = (os_log_s *)__nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "__nw_frame_unclaim_internal";
          __int16 v28 = "%{public}s called with null frame";
LABEL_43:
          _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v26 = (os_log_s *)__nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v30 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v34 = "__nw_frame_unclaim_internal";
            __int16 v35 = 2082;
            *(void *)unsigned int v36 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }

        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "__nw_frame_unclaim_internal";
          __int16 v28 = "%{public}s called with null frame, no backtrace";
          goto LABEL_43;
        }
      }

      else
      {
        os_log_type_t v26 = (os_log_s *)__nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v34 = "__nw_frame_unclaim_internal";
          __int16 v28 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_43;
        }
      }
    }

uint64_t nw_frame_unclaimed_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v15 = "__nw_frame_unclaimed_bytes";
    char v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v15 = "__nw_frame_unclaimed_bytes";
      os_log_type_t v9 = "%{public}s called with null frame";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v15 = "__nw_frame_unclaimed_bytes";
          __int16 v16 = 2082;
          int v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (!v11)
      {
LABEL_27:
        if (v6) {
          free(v6);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      unsigned int v15 = "__nw_frame_unclaimed_bytes";
      os_log_type_t v9 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v15 = "__nw_frame_unclaimed_bytes";
      os_log_type_t v9 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_27;
  }

  if (!*(void *)(a1 + 112)) {
    return 0LL;
  }
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0
    && g_channel_check_validity
    && (g_channel_check_validity(a1, *(void *)(a1 + 88)) & 1) == 0)
  {
    uint64_t result = 0LL;
    if (a2) {
      *a2 = 0;
    }
  }

  else
  {
    if (a2)
    {
      int v4 = *(_DWORD *)(a1 + 52);
      if (v4) {
        v4 -= *(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60);
      }
      *a2 = v4;
    }

    return *(void *)(a1 + 112) + *(unsigned int *)(a1 + 56);
  }

  return result;
}

uint64_t nw_channel_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      unsigned int v4 = ((unsigned __int16)handle[222] | (*((unsigned __int8 *)handle + 446) << 16)) & 0xFFF9FFFF | 0x20000;
      handle[222] = handle[222];
      *((_BYTE *)handle + 446) = BYTE2(v4);
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
      }
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000LL;
      uint64_t v28 = 0LL;
      if (_nw_signposts_once == -1)
      {
        if (!_nw_signposts_enabled) {
          goto LABEL_12;
        }
      }

      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
        if (!_nw_signposts_enabled) {
          goto LABEL_12;
        }
      }

      if (kdebug_is_enabled())
      {
        *(_DWORD *)os_log_type_t type = 0;
        nw_frame_array_get_frame_count((uint64_t *)a2, 1, type);
      }

void nw_frame_finalize(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v13 = "__nw_frame_finalize";
    unsigned int v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v13 = "__nw_frame_finalize";
      os_log_type_t v5 = "%{public}s called with null frame";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      goto LABEL_32;
    }

    if (!v10)
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v13 = "__nw_frame_finalize";
      os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!backtrace_string)
    {
      if (!v7) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v13 = "__nw_frame_finalize";
      os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
      goto LABEL_31;
    }

    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      unsigned int v13 = "__nw_frame_finalize";
      __int16 v14 = 2082;
      unsigned int v15 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_32:
    if (!v2) {
      return;
    }
    goto LABEL_33;
  }

  nw_interface_t v1 = *(void (**)(void))(a1 + 80);
  if (v1)
  {
    *(void *)(a1 + 80) = 0LL;
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
    v1();
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v13 = "__nw_frame_finalize";
  unsigned int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    unint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v13 = "__nw_frame_finalize";
    os_log_type_t v5 = "%{public}s called with null frame->finalizer";
    goto LABEL_31;
  }

  if (!v10)
  {
    unint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v13 = "__nw_frame_finalize";
    os_log_type_t v5 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_31;
  }

  uint64_t v8 = (char *)__nw_create_backtrace_string();
  unint64_t v3 = (os_log_s *)__nwlog_obj();
  os_log_type_t v4 = type;
  BOOL v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v13 = "__nw_frame_finalize";
    os_log_type_t v5 = "%{public}s called with null frame->finalizer, no backtrace";
    goto LABEL_31;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    unsigned int v13 = "__nw_frame_finalize";
    __int16 v14 = 2082;
    unsigned int v15 = v8;
    _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v8);
  if (v2) {
LABEL_33:
  }
    free(v2);
}

void nw_channel_finalize_output_frame(nw_frame *a1, int a2, unsigned __int16 *a3)
{
  uint64_t v225 = *MEMORY[0x1895F89C0];
  uint64_t metadata = (void *)nw_frame_get_metadata((uint64_t)a1);
  BOOL v7 = metadata;
  if (!metadata || !*metadata)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    BOOL v11 = "%{public}s Frame has no packet";
LABEL_13:
    char v12 = (os_log_s *)v10;
    os_log_type_t v13 = OS_LOG_TYPE_ERROR;
    goto LABEL_14;
  }

  if (!metadata[1])
  {
    if ((a3[222] & 0x1000) == 0) {
      goto LABEL_113;
    }
    if (!*((void *)a3 + 17)) {
      goto LABEL_113;
    }
    int v23 = os_channel_packet_free();
    if (!v23) {
      goto LABEL_113;
    }
    int v24 = v23;
    if (!*((void *)a3 + 17))
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
      }
      goto LABEL_113;
    }

    if (((a3[222] | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
    {
LABEL_113:
      *BOOL v7 = 0LL;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
      BOOL v11 = "%{public}s Frame has no buflet";
      goto LABEL_13;
    }

    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_113;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    __int16 v221 = 1024;
    *(_DWORD *)v222 = v24;
    v175 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v175, &v223, type))
    {
      if (v223 == 17)
      {
        v176 = (os_log_s *)__nwlog_obj();
        os_log_type_t v177 = v223;
        if (!os_log_type_enabled(v176, (os_log_type_t)v223)) {
          goto LABEL_478;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v24;
        v178 = "%{public}s os_channel_packet_free failed %{darwin.errno}d";
        goto LABEL_477;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v176 = (os_log_s *)__nwlog_obj();
        os_log_type_t v177 = v223;
        if (!os_log_type_enabled(v176, (os_log_type_t)v223)) {
          goto LABEL_478;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v24;
        v178 = "%{public}s os_channel_packet_free failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_477;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      v176 = (os_log_s *)__nwlog_obj();
      os_log_type_t v177 = v223;
      BOOL v184 = os_log_type_enabled(v176, (os_log_type_t)v223);
      if (backtrace_string)
      {
        if (v184)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v24;
          *(_WORD *)&v222[4] = 2082;
          *(void *)&v222[6] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v176,  v177,  "%{public}s os_channel_packet_free failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_478;
      }

      if (v184)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v24;
        v178 = "%{public}s os_channel_packet_free failed %{darwin.errno}d, no backtrace";
LABEL_477:
        _os_log_impl(&dword_181A5C000, v176, v177, v178, buf, 0x12u);
      }
    }

LABEL_478:
    if (v175) {
      free(v175);
    }
    goto LABEL_113;
  }

  if (!*((void *)a3 + 17))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v25 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_15;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    BOOL v11 = "%{public}s Channel is defunct, cannot write frame";
    char v12 = (os_log_s *)v25;
    os_log_type_t v13 = OS_LOG_TYPE_DEBUG;
LABEL_14:
    _os_log_impl(&dword_181A5C000, v12, v13, v11, buf, 0xCu);
    goto LABEL_15;
  }

  if (!a2)
  {
    int v26 = os_buflet_set_data_length();
    if (!v26) {
      goto LABEL_91;
    }
    int v27 = v26;
    if (!*((void *)a3 + 17))
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
      }
LABEL_91:
      LOWORD(v223) = 0;
      *(_WORD *)os_log_type_t type = 0;
      LOWORD(v216) = 0;
      if (a1)
      {
        int internet_checksum_handler = g_channel_get_internet_checksum_handler(a1, &v223, type, &v216);
        if (!internet_checksum_handler)
        {
          unsigned int v40 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
            __int16 v221 = 1024;
            *(_DWORD *)v222 = (unsigned __int16)v223;
            *(_WORD *)&v222[4] = 1024;
            *(_DWORD *)&v222[6] = *(unsigned __int16 *)type;
            *(_WORD *)&v222[10] = 1024;
            *(_DWORD *)&v222[12] = (unsigned __int16)v216;
            _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_INFO,  "%{public}s Bleaching partial checksum bits: is_partial=%d; start=%u; stuff=%u",
              buf,
              0x1Eu);
          }

          int v41 = 45;
          if ((*((_WORD *)a1 + 102) & 0x100) != 0)
          {
            uint64_t v42 = g_channel_set_internet_checksum_handler;
            if (g_channel_set_internet_checksum_handler)
            {
              *((_BYTE *)a1 + 203) |= 4u;
              int v43 = ((uint64_t (*)(nw_frame *, uint64_t, void, void))v42)(a1, 4LL, 0LL, 0LL);
              if (!v43) {
                goto LABEL_132;
              }
              int v41 = v43;
            }
          }

          char v44 = (os_log_s *)__nwlog_obj();
          if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
            goto LABEL_132;
          }
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = (unsigned __int16)v223;
          *(_WORD *)&v222[4] = 1024;
          *(_DWORD *)&v222[6] = *(unsigned __int16 *)type;
          *(_WORD *)&v222[10] = 1024;
          *(_DWORD *)&v222[12] = (unsigned __int16)v216;
          *(_WORD *)&v222[16] = 1024;
          *(_DWORD *)&v222[18] = v41;
          unsigned int v36 = "%{public}s __nw_frame_set_internet_checksum failed: is_partial=%d; start=%u; stuff=%u %{darwin.errno}d";
          unsigned int v37 = v44;
          os_log_type_t v38 = OS_LOG_TYPE_ERROR;
          uint32_t v39 = 36;
          goto LABEL_98;
        }

        int v34 = internet_checksum_handler;
        goto LABEL_96;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
      v145 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v219 = OS_LOG_TYPE_ERROR;
      char v218 = 0;
      if (__nwlog_fault(v145, &v219, &v218))
      {
        if (v219 == OS_LOG_TYPE_FAULT)
        {
          v146 = (os_log_s *)__nwlog_obj();
          os_log_type_t v147 = v219;
          if (os_log_type_enabled(v146, v219))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
            v148 = "%{public}s called with null frame";
LABEL_383:
            _os_log_impl(&dword_181A5C000, v146, v147, v148, buf, 0xCu);
          }
        }

        else if (v218)
        {
          v157 = (char *)__nw_create_backtrace_string();
          v146 = (os_log_s *)__nwlog_obj();
          os_log_type_t v147 = v219;
          BOOL v158 = os_log_type_enabled(v146, v219);
          if (v157)
          {
            if (v158)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
              __int16 v221 = 2082;
              *(void *)v222 = v157;
              _os_log_impl( &dword_181A5C000,  v146,  v147,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v157);
            goto LABEL_384;
          }

          if (v158)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
            v148 = "%{public}s called with null frame, no backtrace";
            goto LABEL_383;
          }
        }

        else
        {
          v146 = (os_log_s *)__nwlog_obj();
          os_log_type_t v147 = v219;
          if (os_log_type_enabled(v146, v219))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
            v148 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_383;
          }
        }
      }

                                  if (*(void *)type) {
                                    free(*(void **)type);
                                  }
                                }
                              }
                            }
                          }

                          else
                          {
                          }

                          int v24 = 1LL;
                          goto LABEL_474;
                        }
    }

    if (!v174) {
      goto LABEL_480;
    }
LABEL_479:
    free(v174);
    goto LABEL_480;
  }

  os_log_type_t v4 = (unsigned int *)v3;
  os_log_type_t v5 = v4[29];

  if ((_DWORD)v5 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v172 = (id)gLogObj;
    else {
      v173 = off_189BBBBC0[v5];
    }
    *(_DWORD *)buf = 136446722;
    v378 = "nw_endpoint_handler_modify_protocol_stack";
    v379 = 2082;
    v380 = (char *)v173;
    v381 = 2082;
    v382 = "flow";
    BOOL v174 = (char *)_os_log_send_and_compose_impl();

    v375[0] = OS_LOG_TYPE_ERROR;
    v373[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v174, v375, v373))
    {
      if (v375[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v175 = (os_log_s *)(id)gLogObj;
        v176 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          else {
            os_log_type_t v177 = off_189BBBBC0[v5];
          }
          *(_DWORD *)buf = 136446722;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          v379 = 2082;
          v380 = (char *)v177;
          v381 = 2082;
          v382 = "flow";
          _os_log_impl( &dword_181A5C000,  v175,  v176,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v373[0])
      {
        v178 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v175 = (os_log_s *)(id)gLogObj;
        v179 = v375[0];
        BOOL v180 = os_log_type_enabled(v175, v375[0]);
        if (v178)
        {
          if (v180)
          {
            else {
              v181 = off_189BBBBC0[v5];
            }
            *(_DWORD *)buf = 136446978;
            v378 = "nw_endpoint_handler_modify_protocol_stack";
            v379 = 2082;
            v380 = (char *)v181;
            v381 = 2082;
            v382 = "flow";
            v383 = 2082;
            v384 = v178;
            _os_log_impl( &dword_181A5C000,  v175,  v179,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v178);
          if (!v174) {
            goto LABEL_480;
          }
          goto LABEL_479;
        }

        if (v180)
        {
          else {
            BOOL v184 = off_189BBBBC0[v5];
          }
          *(_DWORD *)buf = 136446722;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          v379 = 2082;
          v380 = (char *)v184;
          v381 = 2082;
          v382 = "flow";
          _os_log_impl( &dword_181A5C000,  v175,  v179,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v175 = (os_log_s *)(id)gLogObj;
        BOOL v182 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          else {
            v183 = off_189BBBBC0[v5];
          }
          *(_DWORD *)buf = 136446722;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          v379 = 2082;
          v380 = (char *)v183;
          v381 = 2082;
          v382 = "flow";
          _os_log_impl( &dword_181A5C000,  v175,  v182,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }

      goto LABEL_477;
    }

    goto LABEL_478;
  }

  if (!v367)
  {
    __nwlog_obj();
    v316 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v378 = "nw_endpoint_handler_modify_protocol_stack";
    BOOL v174 = (char *)_os_log_send_and_compose_impl();

    v375[0] = OS_LOG_TYPE_ERROR;
    v373[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v174, v375, v373))
    {
      if (v375[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v175 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v317 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          *(_DWORD *)buf = 136446210;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          _os_log_impl(&dword_181A5C000, v175, v317, "%{public}s called with null modifier", buf, 0xCu);
        }

LABEL_384:
      if (v145) {
        free(v145);
      }
      int v34 = 22;
LABEL_96:
      __int16 v35 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
      __int16 v221 = 1024;
      *(_DWORD *)v222 = v34;
      unsigned int v36 = "%{public}s __nw_frame_get_internet_checksum failed %{darwin.errno}d";
      unsigned int v37 = v35;
      os_log_type_t v38 = OS_LOG_TYPE_ERROR;
      uint32_t v39 = 18;
LABEL_98:
      _os_log_impl(&dword_181A5C000, v37, v38, v36, buf, v39);
      goto LABEL_132;
    }

    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_91;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    __int16 v221 = 1024;
    *(_DWORD *)v222 = v27;
    v169 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v169, &v223, type))
    {
      if (v223 == 17)
      {
        v170 = (os_log_s *)__nwlog_obj();
        os_log_type_t v171 = v223;
        if (!os_log_type_enabled(v170, (os_log_type_t)v223)) {
          goto LABEL_471;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v27;
        v172 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d";
        goto LABEL_470;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v170 = (os_log_s *)__nwlog_obj();
        os_log_type_t v171 = v223;
        if (!os_log_type_enabled(v170, (os_log_type_t)v223)) {
          goto LABEL_471;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v27;
        v172 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_470;
      }

      v181 = (char *)__nw_create_backtrace_string();
      v170 = (os_log_s *)__nwlog_obj();
      os_log_type_t v171 = v223;
      BOOL v182 = os_log_type_enabled(v170, (os_log_type_t)v223);
      if (v181)
      {
        if (v182)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v27;
          *(_WORD *)&v222[4] = 2082;
          *(void *)&v222[6] = v181;
          _os_log_impl( &dword_181A5C000,  v170,  v171,  "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v181);
        goto LABEL_471;
      }

      if (v182)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v27;
        v172 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, no backtrace";
LABEL_470:
        _os_log_impl(&dword_181A5C000, v170, v171, v172, buf, 0x12u);
      }
    }

  __break(1u);
  return result;
}

      _os_log_impl(&dword_181A5C000, v174, v175, v176, buf, 0xCu);
      goto LABEL_385;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
    v163 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v228[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v164 = (os_log_s *)__nwlog_obj();
      v165 = type[0];
      if (!os_log_type_enabled(v164, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v166 = "%{public}s called with null parameters";
      goto LABEL_374;
    }

    if (!v228[0])
    {
      BOOL v164 = (os_log_s *)__nwlog_obj();
      v165 = type[0];
      if (!os_log_type_enabled(v164, type[0])) {
        goto LABEL_375;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
      v166 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_374;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v164 = (os_log_s *)__nwlog_obj();
    v165 = type[0];
    v185 = os_log_type_enabled(v164, type[0]);
    if (backtrace_string)
    {
      if (v185)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_add_input_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v169 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
        goto LABEL_299;
      }

    goto LABEL_385;
  }

  uint64_t v74 = v72;
  BOOL v75 = v74[1];

  if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
  }
  int v76 = nw_protocol_definition_is_equal_unsafe( (uint64_t)v75,  nw_protocol_copy_http_cookie_definition_http_cookie_definition);

  if (!v76)
  {
    __nwlog_obj();
    BOOL v162 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_is_top_level_navigation";
    LODWORD(v389) = 12;
    v388 = buf;
    v153 = (char *)_os_log_send_and_compose_impl();

    v427 = OS_LOG_TYPE_ERROR;
    v426 = 0;
    if (v427 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v154 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v163 = v427;
      if (os_log_type_enabled(v154, v427))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_is_top_level_navigation";
        _os_log_impl(&dword_181A5C000, v154, v163, "%{public}s protocol options are not http_cookie", buf, 0xCu);
      }
    }

    else if (v426)
    {
      os_log_type_t v197 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v154 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v198 = v427;
      v199 = os_log_type_enabled(v154, v427);
      if (v197)
      {
        if (v199)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_is_top_level_navigation";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v197;
          _os_log_impl( &dword_181A5C000,  v154,  v198,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v197);
        if (!v153) {
          goto LABEL_72;
        }
        goto LABEL_386;
      }

      if (v199)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_is_top_level_navigation";
        _os_log_impl( &dword_181A5C000,  v154,  v198,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v154 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v233 = v427;
      if (os_log_type_enabled(v154, v427))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_is_top_level_navigation";
        _os_log_impl( &dword_181A5C000,  v154,  v233,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_384;
  }

  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = v2;
  *(void *)&buf[16] = __nw_http_cookie_options_set_is_top_level_navigation_block_invoke;
  *(void *)&v434 = &__block_descriptor_33_e9_B16__0_v8l;
  BYTE8(v434) = v71;
  nw_protocol_options_access_handle(v74, buf);
LABEL_72:

LABEL_73:
  int v77 = *(void *)(a1 + 40);
  if (!v77
    || (([*(id *)(v77 + 32) _explicitlySetShouldHandleCookies] & 1) == 0
      ? (unsigned int v78 = [*(id *)(v77 + 16) HTTPShouldSetCookies])
      : (unsigned int v78 = [*(id *)(v77 + 32) HTTPShouldHandleCookies]),
        (v78 & 1) == 0))
  {
    int v80 = v35;
    os_log_type_t v81 = v80;
    if (v80)
    {
      int v82 = v80;
      uint64_t v83 = v82[1];

      if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
      }
      unsigned int v84 = nw_protocol_definition_is_equal_unsafe( (uint64_t)v83,  nw_protocol_copy_http_cookie_definition_http_cookie_definition);

      if (v84)
      {
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = v2;
        *(void *)&buf[16] = __nw_http_cookie_options_set_should_not_send_cookies_block_invoke;
        *(void *)&v434 = &__block_descriptor_33_e9_B16__0_v8l;
        BYTE8(v434) = 1;
        nw_protocol_options_access_handle(v82, buf);
LABEL_85:

        goto LABEL_86;
      }

      __nwlog_obj();
      BOOL v174 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
      LODWORD(v389) = 12;
      v388 = buf;
      v169 = (char *)_os_log_send_and_compose_impl();

      v427 = OS_LOG_TYPE_ERROR;
      v426 = 0;
      if (v427 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v175 = v427;
        if (os_log_type_enabled(v170, v427))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
          _os_log_impl(&dword_181A5C000, v170, v175, "%{public}s protocol options are not http_cookie", buf, 0xCu);
        }
      }

      else if (v426)
      {
        v217 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v218 = v427;
        os_log_type_t v219 = os_log_type_enabled(v170, v427);
        if (v217)
        {
          if (v219)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v217;
            _os_log_impl( &dword_181A5C000,  v170,  v218,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v217);
          if (!v169) {
            goto LABEL_85;
          }
          goto LABEL_402;
        }

        if (v219)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
          _os_log_impl( &dword_181A5C000,  v170,  v218,  "%{public}s protocol options are not http_cookie, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v237 = v427;
        if (os_log_type_enabled(v170, v427))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
          _os_log_impl( &dword_181A5C000,  v170,  v237,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      v168 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
      LODWORD(v389) = 12;
      v388 = buf;
      v169 = (char *)_os_log_send_and_compose_impl();

      v427 = OS_LOG_TYPE_ERROR;
      v426 = 0;
      if (v427 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v171 = v427;
        if (os_log_type_enabled(v170, v427))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
          _os_log_impl(&dword_181A5C000, v170, v171, "%{public}s called with null options", buf, 0xCu);
        }
      }

      else if (v426)
      {
        v209 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v210 = v427;
        v211 = os_log_type_enabled(v170, v427);
        if (v209)
        {
          if (v211)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v209;
            _os_log_impl( &dword_181A5C000,  v170,  v210,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v209);
LABEL_401:
          if (!v169) {
            goto LABEL_85;
          }
LABEL_402:
          free(v169);
          goto LABEL_85;
        }

        if (v211)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
          _os_log_impl(&dword_181A5C000, v170, v210, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v235 = v427;
        if (os_log_type_enabled(v170, v427))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_cookie_options_set_should_not_send_cookies";
          _os_log_impl( &dword_181A5C000,  v170,  v235,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_401;
  }

                            if (v293) {
                              free(v293);
                            }
                            BOOL v158 = 0;
                            if ((v154 & 1) == 0)
                            {
LABEL_214:
                              if ((v353 & 1) != 0)
                              {
                                nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                                if (v158)
                                {
LABEL_216:
                                  if (output_handler != (nw_protocol *)v49)
                                  {
                                    v159 = output_handler->callbacks;
                                    if (v159 && v159->add_input_handler)
                                    {
                                      if (nw_protocol_add_input_handler((uint64_t)output_handler, v49))
                                      {
                                        int minimize_logging = nw_endpoint_handler_get_minimize_logging(v45);
                                        v161 = nw_endpoint_handler_get_logging_disabled(v45);
                                        if (minimize_logging)
                                        {
                                          if ((v161 & 1) != 0) {
                                            goto LABEL_197;
                                          }
                                          if (__nwlog_connection_log::onceToken != -1) {
                                            dispatch_once( &__nwlog_connection_log::onceToken,  &__block_literal_global_24_44325);
                                          }
                                          BOOL v162 = (os_log_s *)(id)gconnectionLogObj;
                                          if (os_log_type_enabled(v162, OS_LOG_TYPE_DEBUG))
                                          {
                                            v313 = nw_endpoint_handler_get_id_string(v45);
                                            v314 = nw_endpoint_handler_dry_run_string(v45);
                                            v315 = nw_endpoint_handler_copy_endpoint(v45);
                                            v316 = nw_endpoint_get_logging_description(v315);
                                            v317 = v45;
                                            v318 = nw_endpoint_handler_state_string(v45);
                                            v319 = nw_endpoint_handler_mode_string(v317);
                                            v320 = nw_endpoint_handler_copy_current_path(v317);
                                            *(_DWORD *)buf = 136447746;
                                            v355 = "nw_endpoint_start_tls_while_connected";
                                            v356 = 2082;
                                            v357 = (char *)v313;
                                            v358 = 2082;
                                            v359 = v314;
                                            v360 = 2082;
                                            v361 = (void *)v316;
                                            v362 = 2082;
                                            v363 = v318;
                                            v364 = 2082;
                                            v365 = v319;
                                            v366 = 2114;
                                            v367 = v320;
                                            _os_log_impl( &dword_181A5C000,  v162,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{publ ic}@)] Successfully repaired protocol stack after failed TLS insertion",  buf,  0x48u);
                                          }

                                          goto LABEL_226;
                                        }

                                        if ((v161 & 1) == 0)
                                        {
                                          if (__nwlog_connection_log::onceToken != -1) {
                                            dispatch_once( &__nwlog_connection_log::onceToken,  &__block_literal_global_24_44325);
                                          }
                                          BOOL v162 = (os_log_s *)(id)gconnectionLogObj;
                                          if (os_log_type_enabled(v162, OS_LOG_TYPE_DEFAULT))
                                          {
                                            v163 = nw_endpoint_handler_get_id_string(v45);
                                            BOOL v164 = nw_endpoint_handler_dry_run_string(v45);
                                            v165 = nw_endpoint_handler_copy_endpoint(v45);
                                            v166 = nw_endpoint_get_logging_description(v165);
                                            os_log_type_t v167 = v45;
                                            v168 = nw_endpoint_handler_state_string(v45);
                                            v169 = nw_endpoint_handler_mode_string(v167);
                                            v170 = nw_endpoint_handler_copy_current_path(v167);
                                            *(_DWORD *)buf = 136447746;
                                            v355 = "nw_endpoint_start_tls_while_connected";
                                            v356 = 2082;
                                            v357 = (char *)v163;
                                            v358 = 2082;
                                            v359 = v164;
                                            v360 = 2082;
                                            v361 = (void *)v166;
                                            v362 = 2082;
                                            v363 = v168;
                                            v364 = 2082;
                                            v365 = v169;
                                            v366 = 2114;
                                            v367 = v170;
                                            _os_log_impl( &dword_181A5C000,  v162,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{publ ic}@)] Successfully repaired protocol stack after failed TLS insertion",  buf,  0x48u);
                                          }

LABEL_390:
  if (v149) {
    free(v149);
  }
LABEL_68:
  os_packet_set_service_class();
  if ((a3[222] & 0x400) != 0)
  {
    if (a1)
    {
      if ((*((_BYTE *)a1 + 186) & 3) == 1)
      {
        os_packet_set_l4s_flag();
        if (*((void *)a1 + 20)) {
          os_packet_set_tx_timestamp();
        }
      }

      if ((*((_BYTE *)a1 + 186) & 4) != 0)
      {
        os_packet_set_transport_retransmit();
        if ((*((_BYTE *)a1 + 186) & 8) == 0) {
          goto LABEL_73;
        }
      }

      else if ((*((_BYTE *)a1 + 186) & 8) == 0)
      {
        goto LABEL_73;
      }

      os_packet_set_transport_last_packet();
LABEL_73:
      if ((*((_BYTE *)a1 + 186) & 0x10) != 0)
      {
        os_packet_set_transport_traffic_background();
        if ((*((_BYTE *)a1 + 186) & 0x20) == 0) {
          goto LABEL_75;
        }
      }

      else if ((*((_BYTE *)a1 + 186) & 0x20) == 0)
      {
        goto LABEL_75;
      }

      os_packet_set_transport_traffic_realtime();
LABEL_75:
      LOBYTE(v2_Block_object_dispose(va, 8) = *((_WORD *)a1 + 102);
      if ((*((_WORD *)a1 + 102) & 0x20) != 0)
      {
        os_packet_set_packetid();
        LOBYTE(v2_Block_object_dispose(va, 8) = *((_WORD *)a1 + 102);
        if ((*((_WORD *)a1 + 102) & 0x10) == 0) {
          goto LABEL_79;
        }
      }

      else if ((*((_WORD *)a1 + 102) & 0x10) == 0)
      {
        goto LABEL_79;
      }

      if (*((void *)a1 + 19))
      {
        os_packet_set_expire_time();
        __int16 v28 = *((_WORD *)a1 + 102);
      }

                            free(v242);
                            if (!v225) {
                              goto LABEL_339;
                            }
                            goto LABEL_411;
                          }

                          if (!v372)
                          {
LABEL_410:
                            if (!v225) {
                              goto LABEL_339;
                            }
LABEL_411:
                            free(v225);
                            goto LABEL_339;
                          }

                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                          v229 = "%{public}s called with null http1_stream->protocol_http1, no backtrace";
                        }

                        else
                        {
                          v361 = (os_log_s *)__nwlog_obj();
                          v362 = aBlock[0];
                          if (!os_log_type_enabled(v361, (os_log_type_t)aBlock[0])) {
                            goto LABEL_410;
                          }
                          *(_DWORD *)buf = 136446210;
                          *(void *)&uint8_t buf[4] = "nw_http1_stream_associate_with_connection";
                          v229 = "%{public}s called with null http1_stream->protocol_http1, backtrace limit exceeded";
                        }
                      }

                      v259 = v361;
                      v260 = v362;
                      v261 = 12;
                      goto LABEL_409;
                    }

                    if (!v349) {
                      goto LABEL_573;
                    }
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
                    v347 = "%{public}s called with null http1_stream, no backtrace";
                  }

                  else
                  {
                    v345 = (os_log_s *)__nwlog_obj();
                    v346 = aBlock[0];
                    if (!os_log_type_enabled(v345, (os_log_type_t)aBlock[0])) {
                      goto LABEL_573;
                    }
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_replace_protocol_instance";
                    v347 = "%{public}s called with null http1_stream, backtrace limit exceeded";
                  }

                  _os_log_impl(&dword_181A5C000, v345, v346, v347, buf, 0xCu);
                  goto LABEL_573;
                }

                if (v280) {
                  free(v280);
                }
                os_log_type_t v95 = 0;
                goto LABEL_151;
              }

LABEL_418:
    if (v153) {
      free(v153);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
    v185 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v185, &v223, type))
    {
      if (v223 == 17)
      {
        v186 = (os_log_s *)__nwlog_obj();
        os_log_type_t v187 = v223;
        if (!os_log_type_enabled(v186, (os_log_type_t)v223)) {
          goto LABEL_434;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        v188 = "%{public}s called with null frame";
LABEL_433:
        _os_log_impl(&dword_181A5C000, v186, v187, v188, buf, 0xCu);
        goto LABEL_434;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v186 = (os_log_s *)__nwlog_obj();
        os_log_type_t v187 = v223;
        if (!os_log_type_enabled(v186, (os_log_type_t)v223)) {
          goto LABEL_434;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        v188 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_433;
      }

      v189 = (char *)__nw_create_backtrace_string();
      v186 = (os_log_s *)__nwlog_obj();
      os_log_type_t v187 = v223;
      BOOL v190 = os_log_type_enabled(v186, (os_log_type_t)v223);
      if (!v189)
      {
        if (!v190) {
          goto LABEL_434;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        v188 = "%{public}s called with null frame, no backtrace";
        goto LABEL_433;
      }

      if (v190)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        __int16 v221 = 2082;
        *(void *)v222 = v189;
        _os_log_impl( &dword_181A5C000,  v186,  v187,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v189);
    }

    free(v88);
    goto LABEL_419;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  os_log_type_t v205 = "_http_vle_encode";
  v206 = 2048;
  os_log_type_t v207 = (const char *)v31;
  uint64_t v62 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v62);
  if (result) {
    goto LABEL_529;
  }
  free(v62);
  if (!v199[3])
  {
LABEL_420:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v205 = "nw_http_fillout_binary_message_inner";
    v159 = (char *)_os_log_send_and_compose_impl();
    v178[0] = OS_LOG_TYPE_ERROR;
    v203 = OS_LOG_TYPE_DEFAULT;
    if (v178[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v160 = (os_log_s *)__nwlog_obj();
      v161 = v178[0];
      if (!os_log_type_enabled(v160, v178[0])) {
        goto LABEL_525;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v205 = "nw_http_fillout_binary_message_inner";
      BOOL v162 = "%{public}s called with null cursor";
    }

    else if (v203)
    {
      v165 = (char *)__nw_create_backtrace_string();
      BOOL v160 = (os_log_s *)__nwlog_obj();
      v161 = v178[0];
      v166 = os_log_type_enabled(v160, v178[0]);
      if (v165)
      {
        if (v166)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v205 = "nw_http_fillout_binary_message_inner";
          v206 = 2082;
          os_log_type_t v207 = v165;
          _os_log_impl( &dword_181A5C000,  v160,  v161,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v165);
LABEL_525:
        if (!v159) {
          goto LABEL_527;
        }
        goto LABEL_526;
      }

      if (!v166) {
        goto LABEL_525;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v205 = "nw_http_fillout_binary_message_inner";
      BOOL v162 = "%{public}s called with null cursor, no backtrace";
    }

    else
    {
      BOOL v160 = (os_log_s *)__nwlog_obj();
      v161 = v178[0];
      if (!os_log_type_enabled(v160, v178[0])) {
        goto LABEL_525;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v205 = "nw_http_fillout_binary_message_inner";
      BOOL v162 = "%{public}s called with null cursor, backtrace limit exceeded";
    }

    tls = nw_parameters_get_tls(v381);
    goto LABEL_419;
  }

          if (v152) {
            free(v152);
          }
          BOOL v91 = 0;
          if ((v65 & 1) != 0) {
            goto LABEL_208;
          }
          goto LABEL_209;
        }

        if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v74 = *(void *)(v21 + 88);
          if (v74) {
            *(void *)(v21 + 8_Block_object_dispose(va, 8) = v74 + 1;
          }
          *(void *)v375 = v21;
          BOOL v32 = v376 | 1;
        }

        else
        {
          *(void *)v375 = *(void *)(v10 + 32);
          BOOL v32 = v376 & 0xFE;
        }

        v376 = v32;
        if (*(_UNKNOWN **)(v10 + 40) == &nw_protocol_ref_counted_handle)
        {
          int v76 = *(void *)(v10 + 88);
          if (v76) {
            *(void *)(v10 + 8_Block_object_dispose(va, 8) = v76 + 1;
          }
          *(void *)v373 = v10;
          BOOL v75 = v374 | 1;
        }

        else
        {
          *(void *)v373 = v10;
          BOOL v75 = v374 & 0xFE;
        }

        v374 = v75;
        if (v359)
        {
          if (*(_UNKNOWN **)(v359 + 40) == &nw_protocol_ref_counted_handle)
          {
            unsigned int v78 = *(void *)(v359 + 88);
            if (v78) {
              *(void *)(v359 + 8_Block_object_dispose(va, 8) = v78 + 1;
            }
            *(void *)v370 = v359;
            int v77 = v371 | 1;
          }

          else
          {
            *(void *)v370 = v359;
            int v77 = v371 & 0xFE;
          }

          v371 = v77;
          uint64_t v79 = *(void *)(v21 + 24);
          if (v79)
          {
            int v80 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v79 + 16);
            if (v80)
            {
              os_log_type_t v81 = v80(v21, v10, v359);
              if ((v371 & 1) != 0) {
                goto LABEL_178;
              }
              goto LABEL_179;
            }
          }

          __nwlog_obj();
          v125 = (void *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v126 = *(const char **)(v21 + 16);
          if (!v126) {
            os_log_type_t v126 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v378 = "__nw_protocol_replace_input_handler";
          v379 = 2082;
          v380 = (char *)v126;
          v381 = 2048;
          v382 = (const char *)v21;
          __int128 v127 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v369 = 0;
          if (__nwlog_fault(v127, &type, &v369))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v129 = type;
              if (os_log_type_enabled(v128, type))
              {
                uint64_t v130 = *(const char **)(v21 + 16);
                if (!v130) {
                  uint64_t v130 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                v378 = "__nw_protocol_replace_input_handler";
                v379 = 2082;
                v380 = (char *)v130;
                v381 = 2048;
                v382 = (const char *)v21;
                _os_log_impl( &dword_181A5C000,  v128,  v129,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback",  buf,  0x20u);
              }

              goto LABEL_286;
            }

            if (v369)
            {
              v143 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v144 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v354 = type;
              v145 = os_log_type_enabled(v144, type);
              if (v143)
              {
                if (v145)
                {
                  v146 = *(const char **)(v21 + 16);
                  if (!v146) {
                    v146 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  v378 = "__nw_protocol_replace_input_handler";
                  v379 = 2082;
                  v380 = (char *)v146;
                  v381 = 2048;
                  v382 = (const char *)v21;
                  v383 = 2082;
                  v384 = v143;
                  _os_log_impl( &dword_181A5C000,  v144,  v354,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                }

                free(v143);
              }

              else
              {
                if (v145)
                {
                  v166 = *(const char **)(v21 + 16);
                  if (!v166) {
                    v166 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v378 = "__nw_protocol_replace_input_handler";
                  v379 = 2082;
                  v380 = (char *)v166;
                  v381 = 2048;
                  v382 = (const char *)v21;
                  _os_log_impl( &dword_181A5C000,  v144,  v354,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace",  buf,  0x20u);
                }
              }
            }

            else
            {
              __nwlog_obj();
              os_log_type_t v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v162 = type;
              if (os_log_type_enabled(v128, type))
              {
                v163 = *(const char **)(v21 + 16);
                if (!v163) {
                  v163 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                v378 = "__nw_protocol_replace_input_handler";
                v379 = 2082;
                v380 = (char *)v163;
                v381 = 2048;
                v382 = (const char *)v21;
                _os_log_impl( &dword_181A5C000,  v128,  v162,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded",  buf,  0x20u);
              }

LABEL_434:
    if (v185) {
      free(v185);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
    v191 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v223 == 17)
    {
      v192 = (os_log_s *)__nwlog_obj();
      os_log_type_t v193 = v223;
      if (!os_log_type_enabled(v192, (os_log_type_t)v223)) {
        goto LABEL_450;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
      v194 = "%{public}s called with null frame";
    }

    else if (type[0])
    {
      v195 = (char *)__nw_create_backtrace_string();
      v192 = (os_log_s *)__nwlog_obj();
      os_log_type_t v193 = v223;
      BOOL v196 = os_log_type_enabled(v192, (os_log_type_t)v223);
      if (v195)
      {
        if (v196)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
          __int16 v221 = 2082;
          *(void *)v222 = v195;
          _os_log_impl( &dword_181A5C000,  v192,  v193,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v195);
        goto LABEL_450;
      }

      if (!v196)
      {
LABEL_450:
        if (v191) {
          free(v191);
        }
        goto LABEL_73;
      }

      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
      v194 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      v192 = (os_log_s *)__nwlog_obj();
      os_log_type_t v193 = v223;
      if (!os_log_type_enabled(v192, (os_log_type_t)v223)) {
        goto LABEL_450;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
      v194 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v192, v193, v194, buf, 0xCu);
    goto LABEL_450;
  }

LABEL_396:
    if (v140) {
      free(v140);
    }
    goto LABEL_25;
  }

    if (!v154) {
      goto LABEL_398;
    }
    goto LABEL_397;
  }

  char v6 = *((void *)handle + 1);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    v154 = (char *)_os_log_send_and_compose_impl();
    v265[0] = 16;
    v257[0] = OS_LOG_TYPE_DEFAULT;
    if (v265[0] == 17)
    {
      os_log_type_t v155 = (os_log_s *)__nwlog_obj();
      v156 = v265[0];
      if (!os_log_type_enabled(v155, (os_log_type_t)v265[0])) {
        goto LABEL_396;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v157 = "%{public}s called with null handle->http1_stream";
      goto LABEL_395;
    }

    if (v257[0] == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v155 = (os_log_s *)__nwlog_obj();
      v156 = v265[0];
      if (!os_log_type_enabled(v155, (os_log_type_t)v265[0])) {
        goto LABEL_396;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v157 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_395;
    }

    BOOL v164 = (char *)__nw_create_backtrace_string();
    os_log_type_t v155 = (os_log_s *)__nwlog_obj();
    v156 = v265[0];
    v195 = os_log_type_enabled(v155, (os_log_type_t)v265[0]);
    if (!v164)
    {
      if (!v195) {
        goto LABEL_396;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
      v157 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_395;
    }

    if (!v195) {
      goto LABEL_272;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http1_get_http1_protocol";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v164;
    v166 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
LABEL_271:
    _os_log_impl(&dword_181A5C000, v155, v156, v166, buf, 0x16u);
    goto LABEL_272;
  }

  os_log_type_t v4 = (void *)(v6 + 248);
LABEL_10:
  if (!*v4) {
    goto LABEL_398;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_finished";
    BOOL v158 = (char *)_os_log_send_and_compose_impl();
    v265[0] = 16;
    v257[0] = OS_LOG_TYPE_DEFAULT;
    if (v265[0] == 17)
    {
      v159 = (os_log_s *)__nwlog_obj();
      BOOL v160 = v265[0];
      if (!os_log_type_enabled(v159, (os_log_type_t)v265[0])) {
        goto LABEL_432;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_finished";
      v161 = "%{public}s called with null other_protocol";
    }

    else if (v257[0])
    {
      v168 = (char *)__nw_create_backtrace_string();
      v159 = (os_log_s *)__nwlog_obj();
      BOOL v160 = v265[0];
      v169 = os_log_type_enabled(v159, (os_log_type_t)v265[0]);
      if (v168)
      {
        if (!v169) {
          goto LABEL_425;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_finished";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v168;
        v170 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_424;
      }

      if (!v169) {
        goto LABEL_432;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_finished";
      v161 = "%{public}s called with null other_protocol, no backtrace";
    }

    else
    {
      v159 = (os_log_s *)__nwlog_obj();
      BOOL v160 = v265[0];
      if (!os_log_type_enabled(v159, (os_log_type_t)v265[0])) {
        goto LABEL_432;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_finished";
      v161 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }

      if (!v38) {
        goto LABEL_398;
      }
      goto LABEL_397;
    }

              _os_log_impl(&dword_181A5C000, v226, v227, v228, buf, 0x12u);
              goto LABEL_397;
            }

            v226 = (os_log_s *)__nwlog_obj();
            v227 = v257[0];
            if (os_log_type_enabled(v226, v257[0]))
            {
              *(_DWORD *)buf = 136446466;
              v254 = "nw_channel_add_input_frames";
              v255 = 1024;
              LODWORD(v256[0]) = v224;
              v228 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d";
              goto LABEL_396;
            }

LABEL_246:
              _os_log_impl(&dword_181A5C000, v87, v88, v89, buf, 0x1Cu);
              goto LABEL_247;
            }

            if (*(_DWORD *)type) {
              BOOL v61 = v216 == 0;
            }
            else {
              BOOL v61 = 1;
            }
            if (v61) {
              continue;
            }
            unint64_t v223 = __PAIR64__(v216, *(unsigned int *)type);
            if (v59)
            {
              uint64_t v62 = *(void **)(v59 + 40);
              if (v62 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v63 = *(void *)(v59 + 88);
                if (v63) {
                  *(void *)(v59 + 8_Block_object_dispose(va, 8) = v63 + 1;
                }
              }

              BOOL v64 = (void *)*((void *)a3 + 8);
              if (v64 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v65 = *((void *)a3 + 14);
                if (v65) {
                  *((void *)a3 + 14) = v65 + 1;
                }
              }

              uint64_t v66 = *(void *)(v59 + 24);
              if (v66)
              {
                BOOL v67 = *(void (**)(uint64_t, unsigned __int16 *, uint64_t, unint64_t *, uint64_t))(v66 + 160);
                if (v67)
                {
                  v67(v59, a3 + 12, 20LL, &v223, 8LL);
LABEL_165:
                  if (v64 == &nw_protocol_ref_counted_handle
                    && *((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v73 = *((void *)a3 + 14);
                    if (v73)
                    {
                      uint64_t v74 = v73 - 1;
                      *((void *)a3 + 14) = v74;
                      if (!v74)
                      {
                        BOOL v75 = (void (**)(void))*((void *)a3 + 11);
                        if (v75)
                        {
                          *((void *)a3 + 11) = 0LL;
                          v75[2](v75);
                          _Block_release(v75);
                        }

                        if ((a3[48] & 1) != 0)
                        {
                          int v76 = (const void *)*((void *)a3 + 11);
                          if (v76) {
                            _Block_release(v76);
                          }
                        }

                        free(a3 + 12);
                      }
                    }
                  }

                  if (v62 != &nw_protocol_ref_counted_handle) {
                    continue;
                  }
                  if (*(_UNKNOWN **)(v59 + 40) != &nw_protocol_ref_counted_handle) {
                    continue;
                  }
                  uint64_t v68 = *(void *)(v59 + 88);
                  if (!v68) {
                    continue;
                  }
                  uint64_t v69 = v68 - 1;
                  *(void *)(v59 + 8_Block_object_dispose(va, 8) = v69;
                  if (v69) {
                    continue;
                  }
                  os_log_type_t v70 = *(void (***)(void))(v59 + 64);
                  if (v70)
                  {
                    *(void *)(v59 + 64) = 0LL;
                    v70[2](v70);
                    _Block_release(v70);
                  }

                  if ((*(_BYTE *)(v59 + 72) & 1) != 0)
                  {
                    os_log_type_t v71 = *(const void **)(v59 + 64);
                    if (v71) {
                      _Block_release(v71);
                    }
                  }

                  uint32_t v72 = (char *)v59;
                  goto LABEL_177;
                }
              }

              __nwlog_obj();
              int v77 = *(const char **)(v59 + 16);
              if (!v77) {
                int v77 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
              __int16 v221 = 2082;
              *(void *)v222 = v77;
              *(_WORD *)&v222[8] = 2048;
              *(void *)&v222[10] = v59;
              unsigned int v78 = (const char *)_os_log_send_and_compose_impl();
              os_log_type_t v219 = OS_LOG_TYPE_ERROR;
              char v218 = 0;
              os_log_t log = (os_log_t)v78;
              if (v219 == OS_LOG_TYPE_FAULT)
              {
                v203 = (os_log_s *)__nwlog_obj();
                os_log_type_t v198 = v219;
                if (os_log_type_enabled(v203, v219))
                {
                  uint64_t v79 = *(const char **)(v59 + 16);
                  if (!v79) {
                    uint64_t v79 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  __int16 v221 = 2082;
                  *(void *)v222 = v79;
                  *(_WORD *)&v222[8] = 2048;
                  *(void *)&v222[10] = v59;
                  int v80 = v203;
                  os_log_type_t v81 = v198;
                  int v82 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
                  goto LABEL_232;
                }

                goto LABEL_233;
              }

              if (v218)
              {
                v204 = (char *)__nw_create_backtrace_string();
                v199 = (os_log_s *)__nwlog_obj();
                os_log_type_t v197 = v219;
                BOOL v96 = os_log_type_enabled(v199, v219);
                if (v204)
                {
                  if (v96)
                  {
                    v97 = *(const char **)(v59 + 16);
                    if (!v97) {
                      v97 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                    __int16 v221 = 2082;
                    *(void *)v222 = v97;
                    *(_WORD *)&v222[8] = 2048;
                    *(void *)&v222[10] = v59;
                    *(_WORD *)&v222[18] = 2082;
                    *(void *)&v222[20] = v204;
                    _os_log_impl( &dword_181A5C000,  v199,  v197,  "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                  }

                  free(v204);
                  goto LABEL_233;
                }

                if (!v96)
                {
LABEL_233:
                  if (log) {
                    free(log);
                  }
                  goto LABEL_165;
                }

                os_log_type_t v106 = *(const char **)(v59 + 16);
                if (!v106) {
                  os_log_type_t v106 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                __int16 v221 = 2082;
                *(void *)v222 = v106;
                *(_WORD *)&v222[8] = 2048;
                *(void *)&v222[10] = v59;
                int v80 = v199;
                os_log_type_t v81 = v197;
                int v82 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
              }

              else
              {
                v206 = (os_log_s *)__nwlog_obj();
                os_log_type_t v200 = v219;
                if (!os_log_type_enabled(v206, v219)) {
                  goto LABEL_233;
                }
                unsigned int v103 = *(const char **)(v59 + 16);
                if (!v103) {
                  unsigned int v103 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                __int16 v221 = 2082;
                *(void *)v222 = v103;
                *(_WORD *)&v222[8] = 2048;
                *(void *)&v222[10] = v59;
                int v80 = v206;
                os_log_type_t v81 = v200;
                int v82 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
              }

    free(backtrace_string);
    if (!v116) {
      goto LABEL_318;
    }
    goto LABEL_317;
  }

  if (!v177)
  {
    __nwlog_obj();
    v125 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_candidate_endpoint_for_ids_connection";
    int v116 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (type[0] == 17)
    {
      __nwlog_obj();
      uint64_t v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v126 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_181A5C000, v117, v126, "%{public}s called with null completion", buf, 0xCu);
      }
    }

    else if (LOBYTE(__str[0]))
    {
      v148 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v117 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v149 = type[0];
      v150 = os_log_type_enabled(v117, (os_log_type_t)type[0]);
      if (v148)
      {
        if (v150)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v148;
          _os_log_impl( &dword_181A5C000,  v117,  v149,  "%{public}s called with null completion, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v148);
LABEL_316:
        if (!v116)
        {
LABEL_318:
          BOOL v96 = 0LL;
          goto LABEL_181;
        }

    goto LABEL_247;
  }

  if (!a2)
  {
    __nwlog_obj();
    char v131 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
    os_log_type_t v128 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst) = 16;
    LOBYTE(v219) = 0;
    if (__dst == 17)
    {
      __nwlog_obj();
      uint64_t v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v132 = __dst;
      if (os_log_type_enabled(v129, (os_log_type_t)__dst))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
        _os_log_impl(&dword_181A5C000, v129, v132, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if ((_BYTE)v219)
    {
      v136 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v137 = __dst;
      v138 = os_log_type_enabled(v129, (os_log_type_t)__dst);
      if (v136)
      {
        if (v138)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v136;
          _os_log_impl( &dword_181A5C000,  v129,  v137,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v136);
        if (!v128) {
          goto LABEL_18;
        }
        goto LABEL_248;
      }

      if (v138)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
        _os_log_impl(&dword_181A5C000, v129, v137, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v129 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v140 = __dst;
      if (os_log_type_enabled(v129, (os_log_type_t)__dst))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
        _os_log_impl( &dword_181A5C000,  v129,  v140,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_246;
  }

  os_log_type_t v5 = v3[37];
  if (!v5)
  {
    if ((v4[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v4 + 407;
        *(_WORD *)&buf[22] = 2080;
        v208 = " ";
        _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo path table found", buf, 0x20u);
      }

      goto LABEL_17;
    }

    goto LABEL_18;
  }

  uint64_t node = nw_hash_table_get_node(v5, a2, 8LL);
  if (node)
  {
    BOOL v7 = node;
    if (*(void *)(node + 56))
    {
      if ((v4[405] & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v8 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v4 + 407;
          *(_WORD *)&buf[22] = 2080;
          v208 = " ";
          v209 = 2048;
          v210 = a2;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sPath %lx already has registered flow",  buf,  0x2Au);
        }

        if (!v100)
        {
LABEL_248:
          int v18 = v95;
          int v33 = log;
          goto LABEL_60;
        }

LABEL_232:
              _os_log_impl(&dword_181A5C000, v80, v81, v82, buf, 0x20u);
              goto LABEL_233;
            }

            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
            __int16 v90 = (const char *)_os_log_send_and_compose_impl();
            os_log_type_t v219 = OS_LOG_TYPE_ERROR;
            char v218 = 0;
            if (__nwlog_fault(v90, &v219, &v218))
            {
              if (v219 == OS_LOG_TYPE_FAULT)
              {
                BOOL v91 = (os_log_s *)__nwlog_obj();
                os_log_type_t v92 = v219;
                if (os_log_type_enabled(v91, v219))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  v93 = v91;
                  os_log_type_t v94 = v92;
                  os_log_type_t v95 = "%{public}s called with null protocol";
LABEL_239:
                  _os_log_impl(&dword_181A5C000, v93, v94, v95, buf, 0xCu);
                }
              }

              else if (v218)
              {
                os_log_type_t v101 = (char *)__nw_create_backtrace_string();
                logb = (os_log_s *)__nwlog_obj();
                os_log_type_t v205 = v219;
                BOOL v102 = os_log_type_enabled(logb, v219);
                if (v101)
                {
                  if (v102)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                    __int16 v221 = 2082;
                    *(void *)v222 = v101;
                    _os_log_impl( &dword_181A5C000,  logb,  v205,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v101);
                  goto LABEL_240;
                }

                if (v102)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  v93 = logb;
                  os_log_type_t v94 = v205;
                  os_log_type_t v95 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_239;
                }
              }

              else
              {
                v107 = (os_log_s *)__nwlog_obj();
                os_log_type_t v108 = v219;
                if (os_log_type_enabled(v107, v219))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  v93 = v107;
                  os_log_type_t v94 = v108;
                  os_log_type_t v95 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_239;
                }
              }
            }

      goto LABEL_233;
    }

    if ((*(_BYTE *)(v109 + 346) & 0x20) == 0)
    {
      if (*(_BYTE *)(v109 + 256))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v110 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v110, OS_LOG_TYPE_INFO)) {
          goto LABEL_232;
        }
        uint64_t v111 = *(void *)(v278 + 32) + 256LL;
        *(_DWORD *)v299 = 136446978;
        *(void *)&v299[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
        *(_WORD *)&v299[12] = 2082;
        *(void *)&v299[14] = v111;
        *(_WORD *)&v299[22] = 1024;
        *(_DWORD *)&v299[24] = extended_dns_error_code;
        *(_WORD *)&v299[28] = 2082;
        *(void *)&v299[30] = extended_dns_error_text;
        uint64_t v112 = v110;
        __int128 v113 = "%{public}s [C%{public}s] Got Extended DNS Error: %u %{public}s";
        uint64_t v114 = 38;
        goto LABEL_231;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v110 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v110, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v171 = *(_DWORD *)(*(void *)(v278 + 32) + 340LL);
        *(_DWORD *)v299 = 136446978;
        *(void *)&v299[4] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
        *(_WORD *)&v299[12] = 1024;
        *(_DWORD *)&v299[14] = v171;
        *(_WORD *)&v299[18] = 1024;
        *(_DWORD *)&v299[20] = extended_dns_error_code;
        *(_WORD *)&v299[24] = 2082;
        *(void *)&v299[26] = extended_dns_error_text;
        uint64_t v112 = v110;
        __int128 v113 = "%{public}s [R%u] Got Extended DNS Error: %u %{public}s";
        uint64_t v114 = 34;
        goto LABEL_231;
      }

      goto LABEL_232;
    }

    goto LABEL_233;
  }

  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    uint64_t v16 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      BOOL v17 = *(void *)(a1 + 40);
      int v18 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_connection_group_read_on_connection_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v18;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v17;
      _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] reads cancelled for connection %@",  buf,  0x1Cu);
    }
  }

          if (v78) {
            free(v78);
          }
          goto LABEL_41;
        }

        __nwlog_obj();
        BOOL v61 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        BOOL v135 = "nw_protocol_implementation_connected";
        uint64_t v45 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v129[0] = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v62 = type[0];
          if (os_log_type_enabled(v57, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v135 = "nw_protocol_implementation_connected";
            _os_log_impl( &dword_181A5C000,  v57,  v62,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
          }

          goto LABEL_202;
        }

        if (v129[0] == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v99 = type[0];
          if (os_log_type_enabled(v57, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v135 = "nw_protocol_implementation_connected";
            _os_log_impl( &dword_181A5C000,  v57,  v99,  "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_202;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v81 = type[0];
        int v82 = os_log_type_enabled(v57, type[0]);
        if (!backtrace_string)
        {
          if (v82)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v135 = "nw_protocol_implementation_connected";
            _os_log_impl( &dword_181A5C000,  v57,  v81,  "%{public}s called with null instance->parent_definition->extended_state, no backtrace",  buf,  0xCu);
          }

          goto LABEL_202;
        }

        if (v82)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v135 = "nw_protocol_implementation_connected";
          v136 = 2082;
          os_log_type_t v137 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v57,  v81,  "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        BOOL v135 = "nw_protocol_implementation_connected";
        uint64_t v45 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v129[0] = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v60 = type[0];
          if (os_log_type_enabled(v57, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v135 = "nw_protocol_implementation_connected";
            _os_log_impl( &dword_181A5C000,  v57,  v60,  "%{public}s called with null instance->parent_definition",  buf,  0xCu);
          }

          goto LABEL_202;
        }

        if (v129[0] == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v98 = type[0];
          if (os_log_type_enabled(v57, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v135 = "nw_protocol_implementation_connected";
            _os_log_impl( &dword_181A5C000,  v57,  v98,  "%{public}s called with null instance->parent_definition, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_202;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v75 = type[0];
        int v76 = os_log_type_enabled(v57, type[0]);
        if (!backtrace_string)
        {
          if (v76)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v135 = "nw_protocol_implementation_connected";
            _os_log_impl( &dword_181A5C000,  v57,  v75,  "%{public}s called with null instance->parent_definition, no backtrace",  buf,  0xCu);
          }

          goto LABEL_202;
        }

        if (v76)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v135 = "nw_protocol_implementation_connected";
          v136 = 2082;
          os_log_type_t v137 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v57,  v75,  "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

LABEL_77:
      free(backtrace_string);
      if (!v45) {
        goto LABEL_42;
      }
      goto LABEL_86;
    }

    __nwlog_obj();
    os_log_type_t v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v135 = "nw_protocol_implementation_connected";
    uint64_t v45 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v129[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v58 = type[0];
      if (os_log_type_enabled(v57, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v135 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_181A5C000, v57, v58, "%{public}s called with null instance", buf, 0xCu);
      }
    }

    else if (v129[0])
    {
      uint32_t v72 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v73 = type[0];
      uint64_t v74 = os_log_type_enabled(v57, type[0]);
      if (v72)
      {
        if (v74)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v135 = "nw_protocol_implementation_connected";
          v136 = 2082;
          os_log_type_t v137 = v72;
          _os_log_impl( &dword_181A5C000,  v57,  v73,  "%{public}s called with null instance, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v72);
        goto LABEL_85;
      }

      if (v74)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v135 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_181A5C000, v57, v73, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v97 = type[0];
      if (os_log_type_enabled(v57, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v135 = "nw_protocol_implementation_connected";
        _os_log_impl( &dword_181A5C000,  v57,  v97,  "%{public}s called with null instance, backtrace limit exceeded",  buf,  0xCu);
      }
    }

          unsigned int v21 = v264;
          int v60 = v115;
          goto LABEL_270;
        }

        uint64_t v115 = v60;
        v146 = v20;
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_parse_binary_http_response";
        os_log_type_t v147 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v27_Block_object_dispose(va, 8) = 16;
        LOBYTE(__size[0]) = 0;
        if (v278 == 17)
        {
          v148 = (os_log_s *)__nwlog_obj();
          v149 = v278;
          if (os_log_type_enabled(v148, (os_log_type_t)v278))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_parse_binary_http_response";
            v150 = v148;
            os_log_type_t v151 = v149;
            v152 = "%{public}s called with null response_length";
            goto LABEL_304;
          }

          goto LABEL_305;
        }

        if (LOBYTE(__size[0]))
        {
          BOOL v160 = (char *)__nw_create_backtrace_string();
          v161 = (os_log_s *)__nwlog_obj();
          BOOL v162 = v278;
          v163 = os_log_type_enabled(v161, (os_log_type_t)v278);
          if (v160)
          {
            if (v163)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_parse_binary_http_response";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v160;
              _os_log_impl( &dword_181A5C000,  v161,  v162,  "%{public}s called with null response_length, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v160);
            goto LABEL_305;
          }

          if (!v163)
          {
LABEL_305:
            if (v147) {
              free(v147);
            }
            int v20 = v146;
            goto LABEL_232;
          }

          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_parse_binary_http_response";
          v150 = v161;
          os_log_type_t v151 = v162;
          v152 = "%{public}s called with null response_length, no backtrace";
        }

        else
        {
          v166 = (os_log_s *)__nwlog_obj();
          os_log_type_t v167 = v278;
          if (!os_log_type_enabled(v166, (os_log_type_t)v278)) {
            goto LABEL_305;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_parse_binary_http_response";
          v150 = v166;
          os_log_type_t v151 = v167;
          v152 = "%{public}s called with null response_length, backtrace limit exceeded";
        }

      if (v250) {
        free(v250);
      }
      goto LABEL_216;
    }

    goto LABEL_304;
  }

  *(_DWORD *)buf = 0;
  nw_frame_array_get_frame_count((uint64_t *)v272 + 5, 1, buf);
  int v8 = *(_WORD *)buf;
  int v9 = *(unsigned __int16 *)buf;
  error = 0LL;
  *(void *)(a1 + 1176) = dispatch_data_create_alloc();
  *(_WORD *)error = v8;
  BOOL v11 = (_DWORD *)((char *)error + 2);
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  LODWORD(v282) = 0;
  *(void *)&buf[16] = 0x2000000000LL;
  v262[0] = MEMORY[0x1895F87A8];
  v262[1] = 0x40000000LL;
  v263 = (uint64_t (*)(void *))___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke;
  v264 = &unk_189BC4108;
  v266 = buf;
  v267 = (char *)error + 2;
  v265 = v271;
  char v12 = *((void *)v272 + 5);
  do
  {
    if (!v12) {
      break;
    }
    os_log_type_t v13 = *(void *)(v12 + 32);
    __int16 v14 = v263(v262);
    char v12 = v13;
  }

  while ((v14 & 1) != 0);
  if (nw_http3_parse_settings(a1, v11, v9, v10))
  {
    nw_http3_try_persist_0rtt_state(a1);
    uint64_t v15 = buf;
    goto LABEL_136;
  }

  BOOL v164 = (void *)*((void *)v272 + 5);
  if (v164)
  {
    while (2)
    {
      v165 = (void (*)(void *, uint64_t, uint64_t))v164[10];
      v166 = (void *)v164[4];
      if (v165)
      {
        os_log_type_t v167 = v164[11];
        v164[10] = 0LL;
        v164[11] = 0LL;
        v165(v164, 1LL, v167);
        goto LABEL_262;
      }

      __nwlog_obj();
      *(_DWORD *)v279 = 136446210;
      *(void *)&v279[4] = "__nw_frame_finalize";
      v168 = (const char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v278 = 0;
      v252 = (char *)v168;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v241 = (os_log_s *)__nwlog_obj();
        logf = type[0];
        if (os_log_type_enabled(v241, type[0]))
        {
          *(_DWORD *)v279 = 136446210;
          *(void *)&v279[4] = "__nw_frame_finalize";
          v169 = v241;
          v170 = logf;
          os_log_type_t v171 = "%{public}s called with null frame->finalizer";
          break;
        }

        goto LABEL_278;
      }

      if (v278)
      {
        v242 = __nw_create_backtrace_string();
        logg = (os_log_s *)__nwlog_obj();
        unsigned int v216 = type[0];
        v172 = os_log_type_enabled(logg, type[0]);
        v173 = (char *)v242;
        if (v242)
        {
          if (v172)
          {
            *(_DWORD *)v279 = 136446466;
            *(void *)&v279[4] = "__nw_frame_finalize";
            *(_WORD *)&v279[12] = 2082;
            *(void *)&v279[14] = v242;
            _os_log_impl( &dword_181A5C000,  logg,  v216,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  v279,  0x16u);
            v173 = (char *)v242;
          }

          free(v173);
          goto LABEL_278;
        }

        if (!v172)
        {
LABEL_278:
          if (v252) {
            free(v252);
          }
LABEL_262:
          BOOL v164 = v166;
          if (!v166) {
            goto LABEL_306;
          }
          continue;
        }

        *(_DWORD *)v279 = 136446210;
        *(void *)&v279[4] = "__nw_frame_finalize";
        v169 = logg;
        v170 = v216;
        os_log_type_t v171 = "%{public}s called with null frame->finalizer, no backtrace";
      }

      else
      {
        v243 = (os_log_s *)__nwlog_obj();
        logh = type[0];
        if (!os_log_type_enabled(v243, type[0])) {
          goto LABEL_278;
        }
        *(_DWORD *)v279 = 136446210;
        *(void *)&v279[4] = "__nw_frame_finalize";
        v169 = v243;
        v170 = logh;
        os_log_type_t v171 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }

      break;
    }

    _os_log_impl(&dword_181A5C000, v169, v170, v171, v279, 0xCu);
    goto LABEL_278;
  }

    if (v83) {
      free(v83);
    }
    int v8 = &qword_18C45F000;
    goto LABEL_235;
  }

  unsigned int v21 = *(_DWORD *)(v20 + 176);
  *(void *)v149 = v11;
  v150 = data_source_read_callback;
  uint64_t v22 = *(void *)(v11 + 64);
  if (v22)
  {
    int v23 = *(_BYTE *)(v22 + 66);
    int v24 = (unsigned __int16 *)(v20 + 188);
    uint64_t v25 = *(unsigned __int16 *)(v20 + 188) | (*(unsigned __int8 *)(v20 + 190) << 16);
    if ((v23 & 0x40) != 0)
    {
      int v26 = (v25 >> 19) & 1;
      if (!gLogDatapath) {
        LOBYTE(v26) = 1;
      }
      if ((*(_WORD *)(v20 + 188) & 0x200) == 0)
      {
        if ((v26 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          os_log_type_t v106 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v108 = *(_DWORD *)(v20 + 176);
            v107 = *(_DWORD *)(v20 + 180);
            *(_DWORD *)buf = 136447234;
            v153 = "nw_http2_submit_data";
            v154 = 2082;
            os_log_type_t v155 = v20 + 191;
            v156 = 2080;
            *(void *)v157 = " ";
            *(_WORD *)&v157[8] = 1024;
            *(_DWORD *)&v157[10] = v107;
            BOOL v158 = 1024;
            v159 = v108;
            _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> frame is complete, marking end stream",  buf,  0x2Cu);
          }
        }

        goto LABEL_49;
      }

      if ((v26 & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v27 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v110 = *(_DWORD *)(v20 + 176);
          id v109 = *(_DWORD *)(v20 + 180);
          *(_DWORD *)buf = 136447234;
          v153 = "nw_http2_submit_data";
          v154 = 2082;
          os_log_type_t v155 = v20 + 191;
          v156 = 2080;
          *(void *)v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v109;
          BOOL v158 = 1024;
          v159 = v110;
          BOOL v30 = "%{public}s %{public}s%s<i%u:s%d> stream is in CONNECT mode, not marking end stream";
          goto LABEL_47;
        }
      }

      goto LABEL_49;
    }
  }

  else
  {
    int v24 = (unsigned __int16 *)(v20 + 188);
    uint64_t v25 = *(unsigned __int16 *)(v20 + 188) | (*(unsigned __int8 *)(v20 + 190) << 16);
  }

  if ((v25 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    int v27 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v29 = *(_DWORD *)(v20 + 176);
      __int16 v28 = *(_DWORD *)(v20 + 180);
      *(_DWORD *)buf = 136447234;
      v153 = "nw_http2_submit_data";
      v154 = 2082;
      os_log_type_t v155 = v20 + 191;
      v156 = 2080;
      *(void *)v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v28;
      BOOL v158 = 1024;
      v159 = v29;
      BOOL v30 = "%{public}s %{public}s%s<i%u:s%d> frame is not complete, not marking end stream";
LABEL_47:
      _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_DEBUG, v30, buf, 0x2Cu);
    }
  }

LABEL_240:
            if (!v90) {
              continue;
            }
            uint32_t v72 = (char *)v90;
LABEL_177:
            free(v72);
          }
        }
      }
    }

    if (*((void *)a3 + 17))
    {
      if (*((void *)a3 + 27))
      {
        uint64_t v112 = *((void *)a3 + 46);
        if (v112)
        {
          do
          {
            uint64_t v114 = *(void *)(v112 + 40);
            uint64_t v115 = *(void *)(v112 + 24);
            int v116 = os_channel_flow_admissible();
            if (v116)
            {
              int v118 = v116;
              if (v116 == 55)
              {
                if (nw_link_set_flow_control_status(*(void **)(v112 + 72), 1))
                {
                  os_log_type_t v119 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v119, OS_LOG_TYPE_INFO))
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                    __int16 v221 = 2082;
                    *(void *)v222 = v112 + 84;
                    _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_INFO,  "%{public}s Flow controlled for flow id %{public}s",  buf,  0x16u);
                  }
                }

                if (v115)
                {
                  uint64_t v120 = *(void *)(v115 + 24);
                  if (v120)
                  {
                    uint64_t v121 = *(void (**)(uint64_t, unsigned __int16 *))(v120 + 104);
                    if (v121 && *(void *)(v112 + 72) != 0LL)
                    {
                      if (*(_UNKNOWN **)(v115 + 40) == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v130 = *(void *)(v115 + 88);
                        if (v130) {
                          *(void *)(v115 + 8_Block_object_dispose(va, 8) = v130 + 1;
                        }
                        *(void *)buf = v115;
                        char v123 = buf[8] | 1;
                      }

                      else
                      {
                        *(void *)buf = v115;
                        char v123 = buf[8] & 0xFE;
                      }

                      buf[8] = v123;
                      if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v132 = *((void *)a3 + 14);
                        if (v132) {
                          *((void *)a3 + 14) = v132 + 1;
                        }
                        unint64_t v223 = (unint64_t)(a3 + 12);
                        char v131 = v224 | 1;
                      }

                      else
                      {
                        unint64_t v223 = (unint64_t)(a3 + 12);
                        char v131 = v224 & 0xFE;
                      }

                      char v224 = v131;
                      v121(v115, a3 + 12);
                      nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)&v223);
                      nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)buf);
                    }
                  }
                }

                *(void *)(v112 + 56) = 0LL;
                uint64_t v133 = (uint64_t *)*((void *)a3 + 49);
                *(void *)(v112 + 64) = v133;
                *uint64_t v133 = v112;
                *((void *)a3 + 49) = v112 + 56;
                *(_BYTE *)(v112 + 121) |= 2u;
              }

              else if (v116 == 2)
              {
                if (gLogDatapath)
                {
                  v138 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                    __int16 v221 = 2082;
                    *(void *)v222 = v112 + 84;
                    _os_log_impl( &dword_181A5C000,  v138,  OS_LOG_TYPE_DEBUG,  "%{public}s Flow(%{public}s) is no longer present, disconnecting",  buf,  0x16u);
                  }
                }

                nw_channel_disconnect_flow((uint64_t)a3, v112);
              }

              else if ((nw_channel_check_defunct((uint64_t)a3) & 1) == 0)
              {
                __nwlog_obj();
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                __int16 v221 = 2082;
                *(void *)v222 = v112 + 84;
                *(_WORD *)&v222[8] = 1024;
                *(_DWORD *)&v222[10] = v118;
                __int16 v124 = (const char *)_os_log_send_and_compose_impl();
                LOBYTE(v223) = 16;
                type[0] = OS_LOG_TYPE_DEFAULT;
                v215 = (char *)v124;
                if (v223 == 17)
                {
                  v125 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v126 = v223;
                  *(void *)v208 = v125;
                  if (os_log_type_enabled(v125, (os_log_type_t)v223))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                    __int16 v221 = 2082;
                    __int128 v127 = *(os_log_s **)v208;
                    *(void *)v222 = v112 + 84;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = v118;
                    os_log_type_t v128 = v126;
                    uint64_t v129 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d";
                    goto LABEL_302;
                  }

                  goto LABEL_303;
                }

                if (type[0])
                {
                  v134 = (char *)__nw_create_backtrace_string();
                  v209 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v202 = v223;
                  BOOL v135 = os_log_type_enabled(v209, (os_log_type_t)v223);
                  if (v134)
                  {
                    if (v135)
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                      __int16 v221 = 2082;
                      *(void *)v222 = v112 + 84;
                      *(_WORD *)&v222[8] = 1024;
                      *(_DWORD *)&v222[10] = v118;
                      *(_WORD *)&v222[14] = 2082;
                      *(void *)&v222[16] = v134;
                      _os_log_impl( &dword_181A5C000,  v209,  v202,  "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
                    }

                    free(v134);
                    goto LABEL_303;
                  }

                  if (!v135)
                  {
LABEL_303:
                    if (v215) {
                      free(v215);
                    }
                    goto LABEL_260;
                  }

                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                  __int16 v221 = 2082;
                  __int128 v127 = v209;
                  *(void *)v222 = v112 + 84;
                  *(_WORD *)&v222[8] = 1024;
                  *(_DWORD *)&v222[10] = v118;
                  os_log_type_t v128 = v202;
                  uint64_t v129 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, no backtrace";
                }

                else
                {
                  v136 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v137 = v223;
                  *(void *)v210 = v136;
                  if (!os_log_type_enabled(v136, (os_log_type_t)v223)) {
                    goto LABEL_303;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                  __int16 v221 = 2082;
                  __int128 v127 = *(os_log_s **)v210;
                  *(void *)v222 = v112 + 84;
                  *(_WORD *)&v222[8] = 1024;
                  *(_DWORD *)&v222[10] = v118;
                  os_log_type_t v128 = v137;
                  uint64_t v129 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, backtrace limit exceeded";
                }

  if (v72) {
    free(v72);
  }
  a1->__r_.__value_.__r.__words[0] = 0LL;
  a1->__r_.__value_.__l.__size_ = 0LL;
  a1->__r_.__value_.__l.__cap_ = 0LL;
}

          if (v108) {
            free(v108);
          }
          int v27 = 0LL;
          goto LABEL_22;
        }

        unsigned int v36 = v18[8];
        if (!v36) {
          goto LABEL_39;
        }
        unsigned int v37 = v36;
        os_log_type_t v38 = v37[2];

        if (v38 == 2)
        {
LABEL_35:
          unsigned int v40 = (nw_listener *)*((void *)v3 + 11);
          *(void *)buf = v17;
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL52nw_connection_group_set_up_and_start_listener_lockedP30NWConcrete_nw_connection_group_block_invoke_2_168;
          os_log_type_t v147 = (char *)&unk_189BB7400;
          v148 = v18;
          nw_listener_set_new_connection_handler(v40, buf);

          goto LABEL_58;
        }

        uint32_t v39 = v18[8];
        if (!v39) {
          goto LABEL_39;
        }
        if (!v18[8])
        {
LABEL_39:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v44 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
          uint64_t v45 = (char *)_os_log_send_and_compose_impl();

          type[0] = 16;
          v137[0] = OS_LOG_TYPE_DEFAULT;
          if (type[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v46 = (os_log_s *)(id)gLogObj;
            int v47 = type[0];
            if (os_log_type_enabled(v46, (os_log_type_t)type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
              _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s Group descriptor is not set", buf, 0xCu);
            }
          }

          else if (v137[0])
          {
            __int16 v48 = __nw_create_backtrace_string();
            if (v48)
            {
              uint64_t v49 = (char *)v48;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v50 = (os_log_s *)(id)gLogObj;
              uint64_t v51 = type[0];
              if (os_log_type_enabled(v50, (os_log_type_t)type[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v49;
                _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s Group descriptor is not set, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v49);
              if (!v45) {
                goto LABEL_58;
              }
              goto LABEL_57;
            }

            __nwlog_obj();
            BOOL v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            int v53 = type[0];
            if (os_log_type_enabled(v46, (os_log_type_t)type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
              _os_log_impl( &dword_181A5C000,  v46,  v53,  "%{public}s Group descriptor is not set, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v46 = (os_log_s *)(id)gLogObj;
            int v52 = type[0];
            if (os_log_type_enabled(v46, (os_log_type_t)type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
              _os_log_impl( &dword_181A5C000,  v46,  v52,  "%{public}s Group descriptor is not set, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          goto LABEL_55;
        }

        __nwlog_obj();
        int v41 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v42 = nw_group_descriptor_get_type(v18[8]);
        if (v42 > 4) {
          int v43 = "unknown";
        }
        else {
          int v43 = off_189BB74C8[v42];
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
        *(_WORD *)&_BYTE buf[12] = 2080;
        *(void *)&buf[14] = v43;
        uint64_t v45 = (char *)_os_log_send_and_compose_impl();

        type[0] = 16;
        v137[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v45, type, v137))
        {
          if (type[0] == 17)
          {
            __nwlog_obj();
            BOOL v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v54 = type[0];
            if (os_log_type_enabled(v46, (os_log_type_t)type[0]))
            {
              int v55 = nw_group_descriptor_get_type(v18[8]);
              if (v55 > 4) {
                os_log_type_t v56 = "unknown";
              }
              else {
                os_log_type_t v56 = off_189BB74C8[v55];
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_group_set_up_and_start_listener_locked";
              *(_WORD *)&_BYTE buf[12] = 2080;
              *(void *)&buf[14] = v56;
              _os_log_impl(&dword_181A5C000, v46, v54, "%{public}s Unsupported group descriptor type: %s", buf, 0x16u);
            }

LABEL_302:
                _os_log_impl(&dword_181A5C000, v127, v128, v129, buf, 0x1Cu);
                goto LABEL_303;
              }
            }

            if (typeb) {
              free(typeb);
            }
            uint64_t v58 = 0LL;
            goto LABEL_69;
          }

          __nwlog_obj();
          char v131 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)handler = 136446210;
          *(void *)&handler[4] = "nw_connection_group_copy_workloop";
          uint64_t v132 = (char *)_os_log_send_and_compose_impl();

          v169[0] = OS_LOG_TYPE_ERROR;
          BOOL v174 = 0;
          if (__nwlog_fault(v132, v169, &v174))
          {
            if (v169[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              uint64_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v134 = v169[0];
              if (os_log_type_enabled(v133, v169[0]))
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_181A5C000, v133, v134, "%{public}s called with null parameters", handler, 0xCu);
              }
            }

            else if (v174)
            {
              v145 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v157 = v169[0];
              v146 = os_log_type_enabled(v133, v169[0]);
              if (v145)
              {
                if (v146)
                {
                  *(_DWORD *)handler = 136446466;
                  *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                  *(_WORD *)&handler[12] = 2082;
                  *(void *)&handler[14] = v145;
                  _os_log_impl( &dword_181A5C000,  v133,  v157,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  handler,  0x16u);
                }

                free(v145);
                goto LABEL_293;
              }

              if (v146)
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v133,  v157,  "%{public}s called with null parameters, no backtrace",  handler,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              uint64_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v152 = v169[0];
              if (os_log_type_enabled(v133, v169[0]))
              {
                *(_DWORD *)handler = 136446210;
                *(void *)&handler[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v133,  v152,  "%{public}s called with null parameters, backtrace limit exceeded",  handler,  0xCu);
              }
            }
          }

              if ((v9[405] & 0x80000000) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v146 = (os_log_s *)(id)gLogObj;
                if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v9 + 407;
                  *(_WORD *)&buf[22] = 2080;
                  v166 = " ";
                  *(_WORD *)os_log_type_t v167 = 2048;
                  *(void *)&v167[2] = a2;
                  _os_log_impl( &dword_181A5C000,  v146,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p",  buf,  0x2Au);
                }
              }

              goto LABEL_306;
            }

              if ((v449 & 0x100000000LL) == 0)
              {
                v281 = v471;
                v281->privacy_stance = 4;

                int v9 = v474;
                uint64_t v42 = loga;
              }

              v204 = 0;
              *((_BYTE *)v42 + 96) |= 8u;
              v203 = 1;
LABEL_305:
              if (error_code && (*((_BYTE *)v42 + 97) & 4) == 0 && !uuid_is_null(uu))
              {
                v194 = nw_endpoint_handler_copy_current_path(v471);
                nw_path_report_error_to_agent(v194, uu, error_code);
                goto LABEL_227;
              }

    _os_log_impl(&dword_181A5C000, v187, v188, v189, buf, 0xCu);
    goto LABEL_303;
  }
          }

        if (v253) {
          free(v253);
        }
        goto LABEL_286;
      }

      if (v270 != 4287504053LL) {
        goto LABEL_87;
      }
      uint64_t v59 = *(dispatch_object_s **)(a1 + 1184);
      if (v59)
      {
        dispatch_release(v59);
        *(void *)(a1 + 1184) = 0LL;
      }

      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)v272 + 5, 1, buf);
      int v60 = *(_WORD *)buf;
      *(void *)os_log_type_t type = 0LL;
      *(void *)(a1 + 1184) = dispatch_data_create_alloc();
      **(_WORD **)os_log_type_t type = v60;
      *(void *)v279 = 0LL;
      *(void *)&v279[8] = v279;
      v280 = 0;
      *(void *)&v279[16] = 0x2000000000LL;
      v255[0] = MEMORY[0x1895F87A8];
      v255[1] = 0x40000000LL;
      v256 = (uint64_t (*)(void *))___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke_68;
      v257 = &unk_189BC4130;
      v259 = v279;
      v260 = *(void *)type + 2LL;
      v258 = v271;
      BOOL v61 = *((void *)v272 + 5);
      do
      {
        if (!v61) {
          break;
        }
        uint64_t v62 = *(void *)(v61 + 32);
        uint64_t v63 = v256(v255);
        BOOL v61 = v62;
      }

      while ((v63 & 1) != 0);
      BOOL v64 = nw_quic_connection_copy_sec_protocol_metadata(*(void **)(a1 + 1240));
      if (v64)
      {
        uint64_t v65 = v64;
        uint64_t v66 = sec_protocol_metadata_copy_authenticator_trust();
        BOOL v67 = *v2 | (*((unsigned __int8 *)v2 + 2) << 16);
        trust = (sec_trust *)v66;
        if (v66)
        {
          if ((v67 & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              os_log_type_t v119 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v120 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v3;
                *(_WORD *)&buf[22] = 2080;
                v282 = " ";
                v283 = 1024;
                v284 = v120;
                v285 = 2112;
                v286 = trust;
                _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Received trust %@",  buf,  0x30u);
              }
            }
          }

          object = v65;
          uint64_t v68 = *(void **)(a1 + 1096);
          if (v68) {
            uint64_t v69 = (nw_endpoint *)os_retain(v68);
          }
          else {
            uint64_t v69 = 0LL;
          }
          v213 = sec_trust_copy_ref(trust);
          if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              uint64_t v121 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v122 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v3;
                *(_WORD *)&buf[22] = 2080;
                v282 = " ";
                v283 = 1024;
                v284 = v122;
                v285 = 2112;
                v286 = v213;
                _os_log_impl( &dword_181A5C000,  v121,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Received Authenticator trustRef: %@",  buf,  0x30u);
              }
            }
          }

          if (*(void *)(a1 + 1248))
          {
            if ((nw_parameters_get_should_trust_invalid_certificates(*(void **)(a1 + 1120)) & 1) != 0
              || (error = 0LL, v72 = SecTrustEvaluateWithError(v213, &error), uint64_t v73 = error, v72) && !error)
            {
              if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
              {
                if (gLogDatapath)
                {
                  __int128 v127 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                  {
                    os_log_type_t v128 = *(_DWORD *)(a1 + 1280);
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v3;
                    *(_WORD *)&buf[22] = 2080;
                    v282 = " ";
                    v283 = 1024;
                    v284 = v128;
                    _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Trusted incoming secondary certificate",  buf,  0x26u);
                  }
                }
              }

              v210 = v3;
              if (v213)
              {
                uint64_t v74 = SecTrustCopyCertificateChain(v213);
                for (i = 0LL; CFArrayGetCount(v74) > i; ++i)
                {
                  CFArrayGetValueAtIndex(v74, 0LL);
                  int v76 = (const __CFArray *)SecCertificateCopyDNSNames();
                  for (j = 0LL; CFArrayGetCount(v76) > j; ++j)
                  {
                    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v76, j);
                    c_string_from_cfstring = (char *)nw_utilities_create_c_string_from_cfstring(ValueAtIndex);
                    if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
                    {
                      if (gLogDatapath)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        int v82 = (os_log_s *)gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                        {
                          uint64_t v83 = *(_DWORD *)(a1 + 1280);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v210;
                          *(_WORD *)&buf[22] = 2080;
                          v282 = " ";
                          v283 = 1024;
                          v284 = v83;
                          v285 = 2080;
                          v286 = (CFErrorRef)c_string_from_cfstring;
                          _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Received name in cert %s",  buf,  0x30u);
                        }
                      }
                    }

                    port = nw_endpoint_get_port(v69);
                    host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(c_string_from_cfstring, port);
                    if (c_string_from_cfstring) {
                      free(c_string_from_cfstring);
                    }
                    nw_http_connection_metadata_store_secondary_certificate( *(void **)(a1 + 1248),  (void *)host_with_numeric_port);
                    if (host_with_numeric_port) {
                      os_release((void *)host_with_numeric_port);
                    }
                  }

                  if (v76) {
                    CFRelease(v76);
                  }
                }

                if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
                {
                  if (gLogDatapath)
                  {
                    uint64_t v133 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
                    {
                      v134 = *(_DWORD *)(a1 + 1280);
                      *(_DWORD *)buf = 136447234;
                      *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v210;
                      *(_WORD *)&buf[22] = 2080;
                      v282 = " ";
                      v283 = 1024;
                      v284 = v134;
                      v285 = 2112;
                      v286 = v74;
                      _os_log_impl( &dword_181A5C000,  v133,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> Received Authenticator certChain: %@",  buf,  0x30u);
                    }
                  }
                }

                if (v74) {
                  CFRelease(v74);
                }
              }

              unint64_t v3 = v210;
              if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
              {
                if (gLogDatapath)
                {
                  uint64_t v129 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v130 = *(_DWORD *)(a1 + 1280);
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_http3_all_streams_metadata_changed";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v210;
                    *(_WORD *)&buf[22] = 2080;
                    v282 = " ";
                    v283 = 1024;
                    v284 = v130;
                    _os_log_impl( &dword_181A5C000,  v129,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called",  buf,  0x26u);
                  }
                }
              }

              unsigned int v84 = *(void *)(a1 + 880);
              if (v84)
              {
                do
                {
                  uint64_t v85 = *(void *)(v84 + 544);
                  unsigned int v84 = v85;
                }

                while (v85);
              }
            }

            else
            {
              if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v86 = (os_log_s *)gLogObj;
                __int16 v87 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
                uint64_t v73 = error;
                if (v87)
                {
                  os_log_type_t v88 = *(_DWORD *)(a1 + 1280);
                  *(_DWORD *)buf = 136447234;
                  *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v3;
                  *(_WORD *)&buf[22] = 2080;
                  v282 = " ";
                  v283 = 1024;
                  v284 = v88;
                  v285 = 2112;
                  v286 = error;
                  _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Trust evaluation on secondary certificate failed with error: %@, ignori ng secondary certificates",  buf,  0x30u);
                  uint64_t v73 = error;
                }
              }

              if (v73) {
                CFRelease(v73);
              }
            }
          }

          if (v213) {
            CFRelease(v213);
          }
          os_release(trust);
          os_release(object);
          uint64_t v15 = v279;
LABEL_136:
          _Block_object_dispose(v15, 8);
          goto LABEL_137;
        }

        if ((v67 & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v187 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v188 = *(_DWORD *)(a1 + 1280);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v3;
            *(_WORD *)&buf[22] = 2080;
            v282 = " ";
            v283 = 1024;
            v284 = v188;
            v285 = 2112;
            v286 = (CFErrorRef)v65;
            _os_log_impl( &dword_181A5C000,  v187,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> failed to copy authenticator trust from received certificate, sec_protocol_metadata: %@",  buf,  0x30u);
          }
        }

        os_release(v65);
        goto LABEL_311;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
      os_log_type_t v202 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(error) = 16;
      v278 = 0;
      if (__nwlog_fault(v202, &error, &v278))
      {
        if (error == 17)
        {
          v203 = (os_log_s *)__nwlog_obj();
          v204 = error;
          if (!os_log_type_enabled(v203, (os_log_type_t)error)) {
            goto LABEL_366;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
          os_log_type_t v205 = "%{public}s called with null sec_metadata";
          goto LABEL_365;
        }

        if (!v278)
        {
          v203 = (os_log_s *)__nwlog_obj();
          v204 = error;
          if (!os_log_type_enabled(v203, (os_log_type_t)error)) {
            goto LABEL_366;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
          os_log_type_t v205 = "%{public}s called with null sec_metadata, backtrace limit exceeded";
          goto LABEL_365;
        }

        v208 = (char *)__nw_create_backtrace_string();
        v203 = (os_log_s *)__nwlog_obj();
        v204 = error;
        v209 = os_log_type_enabled(v203, (os_log_type_t)error);
        if (v208)
        {
          if (v209)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v208;
            _os_log_impl( &dword_181A5C000,  v203,  v204,  "%{public}s called with null sec_metadata, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v208);
          goto LABEL_366;
        }

        if (v209)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http3_parse_certificate";
          os_log_type_t v205 = "%{public}s called with null sec_metadata, no backtrace";
LABEL_365:
          _os_log_impl(&dword_181A5C000, v203, v204, v205, buf, 0xCu);
        }
      }

  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
  }
  return v20;
}

LABEL_260:
            if ((*(_BYTE *)(v112 + 121) & 1) != 0)
            {
              uint64_t v117 = *(void *)(v112 + 40);
              __int128 v113 = *(void **)(v112 + 48);
              if (v117)
              {
                *(void *)(v117 + 4_Block_object_dispose(va, 8) = v113;
                __int128 v113 = *(void **)(v112 + 48);
              }

              else
              {
                *((void *)a3 + 47) = v113;
              }

              void *v113 = v117;
              *(_BYTE *)(v112 + 121) &= ~1u;
            }

            uint64_t v112 = v114;
          }

          while (v114);
        }
      }
    }
  }

    if (v105) {
      free(v105);
    }
LABEL_10:
    char v12 = *(void **)(a1[6] + 448LL);
    os_log_type_t v13 = MEMORY[0x1895F87A8];
    if (v12)
    {
      __int16 v14 = nw_http_metadata_copy_header_fields(v12);
      if (v14)
      {
        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x4002000000LL;
        BOOL v160 = __Block_byref_object_copy__19;
        *(void *)&v161 = __Block_byref_object_dispose__20;
        BOOL v162 = 0LL;
        v163 = 0LL;
        *((void *)&v161 + 1) = 0LL;
        v150[0] = v13;
        v150[1] = 0x40000000LL;
        v150[2] = ___ZL31nw_http_sniffing_get_media_typeP25nw_protocol_http_sniffingP20nw_protocol_metadata_block_invoke;
        v150[3] = &unk_189BB5A58;
        v150[4] = buf;
        uint64_t v15 = v14;
        uint64_t v16 = v150;
        _nw_http_fields_enumerate_by_name((uint64_t)v15, (unint64_t)"Content-Type", v16);

        BOOL v17 = *(void *)&buf[8];
        int v18 = (_OWORD *)(*(void *)&buf[8] + 40LL);
        BOOL v19 = *(_BYTE *)(*(void *)&buf[8] + 63LL);
        if (v19 < 0)
        {
          int v20 = *(const void **)(*(void *)&buf[8] + 40LL);
          unsigned int v21 = *(void *)(*(void *)&buf[8] + 48LL);
          if (!v21) {
            goto LABEL_20;
          }
        }

        else
        {
          int v20 = (const void *)(*(void *)&buf[8] + 40LL);
          unsigned int v21 = *(unsigned __int8 *)(*(void *)&buf[8] + 63LL);
          if (!*(_BYTE *)(*(void *)&buf[8] + 63LL)) {
            goto LABEL_20;
          }
        }

        uint64_t v22 = memchr(v20, 47, v21);
        if (v22 && v22 - (_BYTE *)v20 != -1)
        {
          if (v19 < 0)
          {
            std::string::__init_copy_ctor_external( &v149,  *(const std::string::value_type **)(v17 + 40),  *(void *)(v17 + 48));
          }

          else
          {
            *(_OWORD *)&v149.__r_.__value_.__l.__data_ = *v18;
            v149.__r_.__value_.__l.__cap_ = *(void *)(v17 + 56);
          }

                  if (v126) {
                    free(v126);
                  }
                  BOOL v11 = v1042;
                  *(_DWORD *)(v1042 + 36_Block_object_dispose(va, 8) = 0;
                  uint64_t v15 = &qword_18C45F000;
                  os_log_type_t v81 = v124;
                  uint64_t v85 = v1037;
                  goto LABEL_263;
                }

                v93 = v81;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v94 = *(unsigned int *)(v11 + 336);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "http1->connections_count";
                *(_WORD *)&buf[22] = 2048;
                v1051 = 1LL;
                *(_WORD *)v1052 = 2048;
                *(void *)&v1052[2] = v94;
                os_log_type_t v95 = (char *)_os_log_send_and_compose_impl();
                aBlock[0] = 16;
                type[0] = 0;
                if (__nwlog_fault(v95, aBlock, type))
                {
                  if (aBlock[0] == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    BOOL v96 = (os_log_s *)gLogObj;
                    v97 = aBlock[0];
                    if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock[0]))
                    {
                      BOOL v98 = *(unsigned int *)(v1042 + 336);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = "http1->connections_count";
                      *(_WORD *)&buf[22] = 2048;
                      v1051 = 1LL;
                      *(_WORD *)v1052 = 2048;
                      *(void *)&v1052[2] = v98;
                      BOOL v99 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_198:
                      _os_log_impl(&dword_181A5C000, v96, v97, v99, buf, 0x2Au);
                    }
                  }

                  else if (type[0])
                  {
                    os_log_type_t v106 = (char *)__nw_create_backtrace_string();
                    BOOL v96 = (os_log_s *)__nwlog_obj();
                    v97 = aBlock[0];
                    v107 = os_log_type_enabled(v96, (os_log_type_t)aBlock[0]);
                    if (v106)
                    {
                      if (v107)
                      {
                        os_log_type_t v108 = *(unsigned int *)(v1042 + 336);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = "http1->connections_count";
                        *(_WORD *)&buf[22] = 2048;
                        v1051 = 1LL;
                        *(_WORD *)v1052 = 2048;
                        *(void *)&v1052[2] = v108;
                        *(_WORD *)&v1052[10] = 2082;
                        *(void *)&v1052[12] = v106;
                        _os_log_impl( &dword_181A5C000,  v96,  v97,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                      }

                      free(v106);
                      goto LABEL_199;
                    }

                    if (v107)
                    {
                      uint64_t v122 = *(unsigned int *)(v1042 + 336);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = "http1->connections_count";
                      *(_WORD *)&buf[22] = 2048;
                      v1051 = 1LL;
                      *(_WORD *)v1052 = 2048;
                      *(void *)&v1052[2] = v122;
                      BOOL v99 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                      goto LABEL_198;
                    }
                  }

                  else
                  {
                    BOOL v96 = (os_log_s *)__nwlog_obj();
                    v97 = aBlock[0];
                    if (os_log_type_enabled(v96, (os_log_type_t)aBlock[0]))
                    {
                      uint64_t v114 = *(unsigned int *)(v1042 + 336);
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = "http1->connections_count";
                      *(_WORD *)&buf[22] = 2048;
                      v1051 = 1LL;
                      *(_WORD *)v1052 = 2048;
                      *(void *)&v1052[2] = v114;
                      BOOL v99 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                      goto LABEL_198;
                    }
                  }
                }

        if (v71) {
          free(v71);
        }
        LODWORD(v21) = 0;
        goto LABEL_263;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446978;
      v256 = "send_data_callback_block_invoke";
      v257 = 2082;
      v258 = "bodyCopySize";
      v259 = 2048;
      v260 = v47;
      v261 = 2048;
      *(void *)v262 = v48;
      uint64_t v49 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v253 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v49, type, &v253))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __int16 v50 = (os_log_s *)__nwlog_obj();
          uint64_t v51 = type[0];
          if (os_log_type_enabled(v50, type[0]))
          {
            *(_DWORD *)buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v47;
            v261 = 2048;
            *(void *)v262 = v48;
            int v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_142:
            _os_log_impl(&dword_181A5C000, v50, v51, v52, buf, 0x2Au);
          }
        }

        else if (v253)
        {
          int v53 = (char *)__nw_create_backtrace_string();
          __int16 v50 = (os_log_s *)__nwlog_obj();
          uint64_t v51 = type[0];
          uint64_t v54 = os_log_type_enabled(v50, type[0]);
          if (v53)
          {
            if (v54)
            {
              *(_DWORD *)buf = 136447234;
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              v258 = "bodyCopySize";
              v259 = 2048;
              v260 = v47;
              v261 = 2048;
              *(void *)v262 = v48;
              *(_WORD *)&v262[8] = 2082;
              *(void *)&v262[10] = v53;
              _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v53);
            goto LABEL_143;
          }

          if (v54)
          {
            *(_DWORD *)buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v47;
            v261 = 2048;
            *(void *)v262 = v48;
            int v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_142;
          }
        }

        else
        {
          __int16 v50 = (os_log_s *)__nwlog_obj();
          uint64_t v51 = type[0];
          if (os_log_type_enabled(v50, type[0]))
          {
            *(_DWORD *)buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v47;
            v261 = 2048;
            *(void *)v262 = v48;
            int v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_142;
          }
        }
      }

uint64_t nw_frame_effective_length(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(unsigned int *)(a1 + 52);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v11 = "__nw_frame_effective_length";
  unsigned int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_effective_length";
        os_log_type_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v11 = "__nw_frame_effective_length";
          __int16 v12 = 2082;
          os_log_type_t v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_effective_length";
        os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_effective_length";
        os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_protocol_ipv4_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v206 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
    v125 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (v192 == 17)
    {
      uint64_t v122 = (os_log_s *)__nwlog_obj();
      os_log_type_t v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        __int16 v124 = "%{public}s called with null protocol";
LABEL_244:
        _os_log_impl(&dword_181A5C000, v122, v123, v124, buf, 0xCu);
      }

LABEL_235:
    free(backtrace_string);
    goto LABEL_245;
  }

  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle) {
    char v8 = &a1[1].output_handler;
  }
  else {
    char v8 = 0LL;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
    v125 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (v192 == 17)
    {
      uint64_t v122 = (os_log_s *)__nwlog_obj();
      os_log_type_t v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        __int16 v124 = "%{public}s called with null ipv4";
        goto LABEL_244;
      }

      goto LABEL_245;
    }

    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v122 = (os_log_s *)__nwlog_obj();
      os_log_type_t v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        __int16 v124 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_244;
      }

      goto LABEL_245;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v122 = (os_log_s *)__nwlog_obj();
    os_log_type_t v123 = v192;
    BOOL v131 = os_log_type_enabled(v122, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v131)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        __int16 v124 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_244;
      }

      goto LABEL_245;
    }

    if (v131)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v130 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_234;
    }

    goto LABEL_235;
  }

  if (a3 >= 0xFFFFFFEC) {
    int v9 = -1;
  }
  else {
    int v9 = a3 + 20;
  }
  int v10 = a4 + 20;
  if (a4 >= 0xFFFFFFEC) {
    int v10 = -1;
  }
  unsigned int v149 = v10;
  unsigned int v150 = v9;
  uint64_t v192 = 0LL;
  os_log_type_t v193 = &v192;
  int v195 = 0;
  uint64_t v194 = 0x2000000000LL;
  v146 = (char *)&a1[3].handle + 1;
  output_handler = a1->output_handler;
  if (!output_handler)
  {
LABEL_195:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
    uint64_t v114 = (char *)_os_log_send_and_compose_impl();
    v188[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v186[0]) = 0;
    if (v188[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v115 = (os_log_s *)__nwlog_obj();
      os_log_type_t v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0])) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v117 = "%{public}s called with null protocol";
    }

    else if (LOBYTE(v186[0]))
    {
      int v118 = (char *)__nw_create_backtrace_string();
      uint64_t v115 = (os_log_s *)__nwlog_obj();
      os_log_type_t v116 = v188[0];
      BOOL v119 = os_log_type_enabled(v115, v188[0]);
      if (v118)
      {
        if (v119)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v118;
          _os_log_impl( &dword_181A5C000,  v115,  v116,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v118);
LABEL_209:
        if (v114) {
          free(v114);
        }
        *((_DWORD *)v193 + 6) = 0;
LABEL_212:
        if (((uint64_t)a1[3].handle & 1) == 0)
        {
          if (gLogDatapath)
          {
            __int128 v127 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v146;
              *(_WORD *)&buf[22] = 2080;
              v199 = " ";
              __int16 v200 = 2048;
              v201 = (char *)p_output_handler;
              _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p No IPv4 input frame",  buf,  0x2Au);
            }
          }
        }

        goto LABEL_214;
      }

      if (!v119) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v117 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v115 = (os_log_s *)__nwlog_obj();
      os_log_type_t v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0])) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v117 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v115, v116, v117, buf, 0xCu);
    goto LABEL_209;
  }

  __int16 v12 = a6;
  while (2)
  {
    os_log_type_t v13 = output_handler->handle;
    if (v13 == &nw_protocol_ref_counted_handle)
    {
      callbacks = output_handler[1].callbacks;
      if (callbacks) {
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
    }

    uint64_t v15 = a1->handle;
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v16 = a1[1].callbacks;
      if (v16) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v16->add_input_handler + 1);
      }
    }

    if (!v12)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      BOOL v96 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      v145 = (char *)v96;
      if (v188[0] == OS_LOG_TYPE_FAULT)
      {
        v97 = (os_log_s *)__nwlog_obj();
        os_log_type_t v98 = v188[0];
        *(void *)typed = v97;
        if (!os_log_type_enabled(v97, v188[0])) {
          goto LABEL_186;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
        v93 = *(os_log_s **)typed;
        os_log_type_t v94 = v98;
        os_log_type_t v95 = "%{public}s called with null return_array";
        uint32_t v99 = 12;
        goto LABEL_185;
      }

      if (LOBYTE(v186[0]))
      {
        BOOL v100 = (char *)__nw_create_backtrace_string();
        logb = (os_log_s *)__nwlog_obj();
        os_log_type_t typef = v188[0];
        BOOL v107 = os_log_type_enabled(logb, v188[0]);
        if (v100)
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v100;
            unsigned int v103 = logb;
            os_log_type_t v104 = typef;
            BOOL v105 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
            uint32_t v106 = 22;
LABEL_174:
            _os_log_impl(&dword_181A5C000, v103, v104, v105, buf, v106);
          }

    if (v44 && v243)
    {
      if (*v234 == v44)
      {
        *v234 = 0LL;
      }

      else
      {
        os_log_type_t v128 = *((void *)handle + 32);
        if (v128) {
          nw_dictionary_set_value(v128, out, 0LL);
        }
      }
    }

    BOOL v129 = *(void *)(v37 + 32);
    uint64_t v130 = *(nw_frame ***)(v37 + 40);
    if (v129)
    {
      *(void *)(v129 + 40) = v130;
      uint64_t v130 = *(nw_frame ***)(v37 + 40);
    }

    else
    {
      v225->tqh_last = v130;
    }

    *uint64_t v130 = (nw_frame *)v129;
    *v236 = 0LL;
    *(void *)(v37 + 40) = 0LL;
    nw_frame_finalize(v37);
    __int16 v12 = v246;

    handle = v251;
    int v26 = (void *)*((void *)v251 + 27);
    if (!v26) {
      goto LABEL_346;
    }
    uint64_t v37 = (uint64_t)v12;
    alloc = (uint64_t)data;
    char v36 = v234;
    if (!v12) {
      goto LABEL_347;
    }
  }

  BOOL v64 = 0;
  if (!v62 || !v41) {
    goto LABEL_234;
  }
  BOOL v64 = 0;
  int v65 = a5;
  if (!v246) {
    int v65 = 1;
  }
  v227 = v65;
  BOOL v67 = v44 == (nw_content_context *)&__block_literal_global_41831
     || v44 == (nw_content_context *)&__block_literal_global_5_41854;
  os_log_type_t v69 = v44 == (nw_content_context *)&__block_literal_global_3_41839
     || v44 == (nw_content_context *)&__block_literal_global_4;
  v230 = v69;
  v231 = v67;
  size = v41;
  while (2)
  {
    BOOL v70 = nw_read_request_get_next_max_size(v62);
    os_log_type_t v71 = v70;
    if (!v70) {
      goto LABEL_234;
    }
    uint32_t v72 = v41 - v64;
    if (v41 - v64 >= v70) {
      uint64_t v73 = v70;
    }
    else {
      uint64_t v73 = v72;
    }
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v105 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
      {
        os_log_t log = v105;
        uint32_t v106 = nw_endpoint_handler_get_id_string(v229);
        BOOL v107 = nw_endpoint_handler_dry_run_string(v229);
        v217 = nw_endpoint_handler_copy_endpoint(v229);
        os_log_type_t v108 = nw_endpoint_get_logging_description(v217);
        unsigned int v216 = nw_endpoint_handler_state_string(v229);
        v215 = nw_endpoint_handler_mode_string(v229);
        os_log_type_t v109 = nw_endpoint_handler_copy_current_path(v229);
        *(_DWORD *)buf = 136448770;
        *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v106;
        *(_WORD *)&buf[22] = 2082;
        v273 = (uint64_t (*)(uint64_t, uint64_t))v107;
        *(_WORD *)v274 = 2082;
        *(void *)&v274[2] = v108;
        *(_WORD *)&v274[10] = 2082;
        *(void *)&v274[12] = v216;
        v275 = 2082;
        v276 = v215;
        v277 = 2114;
        v278 = v109;
        v279 = 1024;
        *(_DWORD *)v280 = v73;
        *(_WORD *)&v280[4] = 1024;
        *(_DWORD *)&v280[6] = v249;
        *(_WORD *)&v280[10] = 1024;
        *(_DWORD *)&v280[12] = v71;
        *(_WORD *)&v280[16] = 1024;
        *(_DWORD *)&v280[18] = v64;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reading %u bytes out of a %u byte frame (max %u, %u so far)",  buf,  0x60u);

        BOOL v105 = log;
      }

      handle = v251;
      char v44 = v63;
    }

    uint64_t v74 = data;
    if (data)
    {
      if (v238 >= v252 && v73 <= v238 - v252)
      {
        memcpy((void *)(v268 + v252), &buffer[v64], v73);
        os_log_type_t v75 = v73;
        goto LABEL_152;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v120 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v73;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v238;
      LOWORD(v273) = 1024;
      *(_DWORD *)((char *)&v273 + 2) = v252;
      uint64_t v121 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v270 = 0;
      if (__nwlog_fault((const char *)v121, &type, &v270))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v122 = (os_log_s *)(id)gLogObj;
          os_log_type_t v123 = type;
          if (os_log_type_enabled(v122, type))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v73;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v238;
            LOWORD(v273) = 1024;
            *(_DWORD *)((char *)&v273 + 2) = v252;
            _os_log_impl( &dword_181A5C000,  v122,  v123,  "%{public}s Trying to write beyond buffer: %u > %u - %u",  buf,  0x1Eu);
          }

          goto LABEL_218;
        }

        if (v270)
        {
          BOOL v131 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v132 = (os_log_s *)(id)gLogObj;
          uint64_t v133 = type;
          v134 = os_log_type_enabled(v132, type);
          if (v131)
          {
            if (v134)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v73;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v238;
              LOWORD(v273) = 1024;
              *(_DWORD *)((char *)&v273 + 2) = v252;
              HIWORD(v273) = 2082;
              *(void *)v274 = v131;
              _os_log_impl( &dword_181A5C000,  v132,  v133,  "%{public}s Trying to write beyond buffer: %u > %u - %u, dumping backtrace:%{public}s",  buf,  0x28u);
            }

            free(v131);
            char v44 = v63;
            if (!v121) {
              goto LABEL_263;
            }
LABEL_262:
            free(v121);
LABEL_263:
            handle = v251;
            goto LABEL_233;
          }

          if (v134)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v73;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v238;
            LOWORD(v273) = 1024;
            *(_DWORD *)((char *)&v273 + 2) = v252;
            _os_log_impl( &dword_181A5C000,  v132,  v133,  "%{public}s Trying to write beyond buffer: %u > %u - %u, no backtrace",  buf,  0x1Eu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v122 = (os_log_s *)(id)gLogObj;
          BOOL v135 = type;
          if (os_log_type_enabled(v122, type))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v73;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v238;
            LOWORD(v273) = 1024;
            *(_DWORD *)((char *)&v273 + 2) = v252;
            _os_log_impl( &dword_181A5C000,  v122,  v135,  "%{public}s Trying to write beyond buffer: %u > %u - %u, backtrace limit exceeded",  buf,  0x1Eu);
          }

                if (v86) {
                  free(v86);
                }
                goto LABEL_100;
              }

              if (a2)
              {
                char v22 = *(unsigned int *)(a2 + 52);
LABEL_57:
                *(void *)(v21 + 40) += v22;
                goto LABEL_58;
              }

              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              v97 = "__nw_frame_effective_length";
              uint64_t v54 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              os_log_type_t v94 = 0;
              if (__nwlog_fault(v54, &type, &v94))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  int v55 = (os_log_s *)__nwlog_obj();
                  uint64_t v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    os_log_type_t v57 = "%{public}s called with null frame";
LABEL_205:
                    _os_log_impl(&dword_181A5C000, v55, v56, v57, buf, 0xCu);
                  }
                }

                else if (v94)
                {
                  int v76 = (char *)__nw_create_backtrace_string();
                  int v55 = (os_log_s *)__nwlog_obj();
                  uint64_t v56 = type;
                  int v77 = os_log_type_enabled(v55, type);
                  if (v76)
                  {
                    if (v77)
                    {
                      *(_DWORD *)buf = 136446466;
                      v97 = "__nw_frame_effective_length";
                      os_log_type_t v98 = 2082;
                      uint32_t v99 = v76;
                      _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v76);
                    goto LABEL_206;
                  }

                  if (v77)
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    os_log_type_t v57 = "%{public}s called with null frame, no backtrace";
                    goto LABEL_205;
                  }
                }

                else
                {
                  int v55 = (os_log_s *)__nwlog_obj();
                  uint64_t v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    os_log_type_t v57 = "%{public}s called with null frame, backtrace limit exceeded";
                    goto LABEL_205;
                  }
                }
              }

      if (a1 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v110 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v140 = "nw_browse_result_get_change_description";
          uint64_t v141 = 2048;
          os_log_type_t v142 = a1;
          _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_ERROR,  "%{public}s unexpected value for change %llu",  buf,  0x16u);
        }
      }

      return (BOOL)v2;
    }

            free(v86);
            goto LABEL_294;
          }

          __nwlog_obj();
          os_log_type_t v109 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          uint64_t v141 = "__nw_protocol_disconnected";
          int v76 = (const char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v136) = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            int v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v110 = type[0];
            if (os_log_type_enabled(v77, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v141 = "__nw_protocol_disconnected";
              _os_log_impl(&dword_181A5C000, v77, v110, "%{public}s called with null protocol", buf, 0xCu);
            }

            goto LABEL_306;
          }

          if (!(_BYTE)v136)
          {
            __nwlog_obj();
            int v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v132 = type[0];
            if (os_log_type_enabled(v77, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v141 = "__nw_protocol_disconnected";
              _os_log_impl( &dword_181A5C000,  v77,  v132,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_306;
          }

          BOOL v96 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          int v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v120 = type[0];
          uint64_t v121 = os_log_type_enabled(v77, type[0]);
          if (!v96)
          {
            if (v121)
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v141 = "__nw_protocol_disconnected";
              _os_log_impl(&dword_181A5C000, v77, v120, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
            }

            goto LABEL_306;
          }

          if (v121)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v141 = "__nw_protocol_disconnected";
            os_log_type_t v142 = 2082;
            v143 = (nw_protocol *)v96;
            _os_log_impl( &dword_181A5C000,  v77,  v120,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          if (!v3) {
            return 1LL;
          }
          goto LABEL_236;
        }

        if (LOBYTE(__dst[0]) == 17)
        {
          v172 = (os_log_s *)__nwlog_obj();
          v173 = (os_log_type_t)__dst[0];
          if (!os_log_type_enabled(v172, (os_log_type_t)__dst[0])) {
            goto LABEL_422;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_get_cached_geohash_value";
          BOOL v174 = "%{public}s called with null globals";
          goto LABEL_421;
        }

        if (!(_BYTE)v196)
        {
          v172 = (os_log_s *)__nwlog_obj();
          v173 = (os_log_type_t)__dst[0];
          if (!os_log_type_enabled(v172, (os_log_type_t)__dst[0])) {
            goto LABEL_422;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_get_cached_geohash_value";
          BOOL v174 = "%{public}s called with null globals, backtrace limit exceeded";
          goto LABEL_421;
        }

        v181 = (char *)__nw_create_backtrace_string();
        v172 = (os_log_s *)__nwlog_obj();
        v173 = (os_log_type_t)__dst[0];
        v185 = os_log_type_enabled(v172, (os_log_type_t)__dst[0]);
        if (!v181)
        {
          if (!v185) {
            goto LABEL_422;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_get_cached_geohash_value";
          BOOL v174 = "%{public}s called with null globals, no backtrace";
          goto LABEL_421;
        }

        if (v185)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_masque_get_cached_geohash_value";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v181;
          char v183 = "%{public}s called with null globals, dumping backtrace:%{public}s";
          goto LABEL_398;
        }

      if (!v52) {
        return;
      }
      goto LABEL_236;
    }

    os_log_type_t v75 = (os_log_s *)__nwlog_obj();
    int v76 = v105[0];
    if (!os_log_type_enabled(v75, v105[0])) {
      goto LABEL_235;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v108 = "nw_http1_connection_send_final_chunk";
    int v55 = "%{public}s called with null output_handler, backtrace limit exceeded";
LABEL_233:
    uint64_t v68 = v75;
    os_log_type_t v69 = v76;
    BOOL v70 = 12;
    goto LABEL_234;
  }

  *(void *)BOOL v105 = 0LL;
  uint32_t v106 = v105;
  output_frames = nw_protocol_get_output_frames(v34, v10, 5LL, 5LL, 1LL, (uint64_t)v105);
  char v36 = output_frames;
  uint64_t v37 = *(void *)v105;
  if (*(void *)v105 && output_frames)
  {
    *(_DWORD *)os_log_type_t type = 0;
    uint64_t v38 = nw_frame_unclaimed_bytes(*(uint64_t *)v105, type);
    *(_DWORD *)uint64_t v38 = 218762544;
    *(_BYTE *)(v38 + 4) = 10;
    if (nw_frame_claim(v37, v39, 5, 0))
    {
      nw_frame_collapse(v37);
      nw_frame_unclaim(v37, v40, 5u, 0);
      if (nw_protocol_finalize_output_frames(v34, (uint64_t)v105))
      {
        *(_WORD *)(*(void *)(v10 + 488) + 428LL) |= 0x400u;
        *(_WORD *)(v10 + 872) |= 0x20u;
        nw_http_transaction_metadata_mark_outbound_message_end(*(void **)(*(void *)(v10 + 488) + 352LL));
        int v41 = *(void *)(v10 + 488);
        if (*(_BYTE *)(v41 + 168))
        {
          if (*(void *)(v41 + 160) != *(void *)(v41 + 176))
          {
            if ((*(_BYTE *)(v41 + 158) & 1) == 0)
            {
              uint64_t v42 = (os_log_s *)__nwlog_obj();
              int v43 = os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
              int v41 = *(void *)(v10 + 488);
              if (v43)
              {
                char v44 = *(void *)(v41 + 256);
                if (v44) {
                  LODWORD(v44) = *(_DWORD *)(v44 + 860);
                }
                uint64_t v45 = *(_DWORD *)(*(void *)(v41 + 248) + 372LL);
                BOOL v46 = *(_DWORD *)(v41 + 424);
                if (*(_BYTE *)(v41 + 168)) {
                  int v47 = *(void *)(v41 + 160);
                }
                else {
                  int v47 = -1LL;
                }
                int v82 = *(void *)(v41 + 176);
                *(_DWORD *)buf = 136448002;
                os_log_type_t v108 = "nw_http1_connection_send_final_chunk";
                os_log_type_t v109 = 2082;
                *(void *)os_log_type_t v110 = v41 + 74;
                *(_WORD *)&v110[8] = 2080;
                *(void *)&v110[10] = " ";
                uint64_t v111 = 1024;
                uint64_t v112 = v45;
                os_log_type_t v113 = 1024;
                uint64_t v114 = v44;
                uint64_t v115 = 1024;
                os_log_type_t v116 = v46;
                uint64_t v117 = 2048;
                *(void *)int v118 = v47;
                *(_WORD *)&v118[8] = 2048;
                *(void *)&v118[10] = v82;
                _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> Content length header %llu does not equal body size %llu",  buf,  0x46u);
                int v41 = *(void *)(v10 + 488);
              }
            }

            nw_protocol_error(*(void **)(v41 + 48), v41);
            nw_protocol_disconnected(*(void **)(*(void *)(v10 + 488) + 48LL), *(void *)(v10 + 488));
          }
        }
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v108 = "nw_http1_connection_send_final_chunk";
    os_log_type_t v109 = 1024;
    *(_DWORD *)os_log_type_t v110 = 5;
    int v52 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v104 = OS_LOG_TYPE_ERROR;
    BOOL v102 = 0;
    if (v104 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      uint64_t v54 = v104;
      if (!os_log_type_enabled(v53, v104)) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v108 = "nw_http1_connection_send_final_chunk";
      os_log_type_t v109 = 1024;
      *(_DWORD *)os_log_type_t v110 = 5;
      int v55 = "%{public}s claiming frame with %u bytes failed";
LABEL_97:
      uint64_t v68 = v53;
      os_log_type_t v69 = v54;
      BOOL v70 = 18;
LABEL_234:
      _os_log_impl(&dword_181A5C000, v68, v69, v55, buf, v70);
      goto LABEL_235;
    }

    if (!v102)
    {
      os_log_type_t v53 = (os_log_s *)__nwlog_obj();
      uint64_t v54 = v104;
      if (!os_log_type_enabled(v53, v104)) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v108 = "nw_http1_connection_send_final_chunk";
      os_log_type_t v109 = 1024;
      *(_DWORD *)os_log_type_t v110 = 5;
      int v55 = "%{public}s claiming frame with %u bytes failed, backtrace limit exceeded";
      goto LABEL_97;
    }

    uint64_t v58 = (char *)__nw_create_backtrace_string();
    os_log_type_t v53 = (os_log_s *)__nwlog_obj();
    uint64_t v54 = v104;
    os_log_type_t v59 = os_log_type_enabled(v53, v104);
    if (!v58)
    {
      if (!v59) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v108 = "nw_http1_connection_send_final_chunk";
      os_log_type_t v109 = 1024;
      *(_DWORD *)os_log_type_t v110 = 5;
      int v55 = "%{public}s claiming frame with %u bytes failed, no backtrace";
      goto LABEL_97;
    }

    if (v59)
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v108 = "nw_http1_connection_send_final_chunk";
      os_log_type_t v109 = 1024;
      *(_DWORD *)os_log_type_t v110 = 5;
      *(_WORD *)&v110[4] = 2082;
      *(void *)&v110[6] = v58;
      int v60 = "%{public}s claiming frame with %u bytes failed, dumping backtrace:%{public}s";
      BOOL v61 = v53;
      BOOL v62 = v54;
      uint64_t v63 = 28;
LABEL_226:
      _os_log_impl(&dword_181A5C000, v61, v62, v60, buf, v63);
    }

      if (!v54)
      {
LABEL_237:
        nw_socket_internal_error((uint64_t)p_output_handler, v53);
        return 0LL;
      }

    BOOL v11 = v286;
  }

          if (v107) {
            free(v107);
          }
          goto LABEL_109;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        frame_count = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0LL);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = frame_count;
        int v47 = (char *)_os_log_send_and_compose_impl();
        v134 = OS_LOG_TYPE_ERROR;
        os_log_type_t v128 = 0;
        if (__nwlog_fault(v47, &v134, &v128))
        {
          if (v134 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v48 = (os_log_s *)gLogObj;
            uint64_t v49 = v134;
            if (!os_log_type_enabled((os_log_t)gLogObj, v134)) {
              goto LABEL_92;
            }
            os_log_type_t v50 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0LL);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v50;
            uint64_t v51 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames";
            goto LABEL_91;
          }

          if (!v128)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v48 = (os_log_s *)gLogObj;
            uint64_t v49 = v134;
            if (!os_log_type_enabled((os_log_t)gLogObj, v134)) {
              goto LABEL_92;
            }
            int v55 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0LL);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v55;
            uint64_t v51 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, backtrace limit exceeded";
            goto LABEL_91;
          }

          int v52 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v48 = (os_log_s *)gLogObj;
          uint64_t v49 = v134;
          os_log_type_t v53 = os_log_type_enabled((os_log_t)gLogObj, v134);
          if (v52)
          {
            if (v53)
            {
              uint64_t v54 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0LL);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v54;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v52;
              _os_log_impl( &dword_181A5C000,  v48,  v49,  "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v52);
            goto LABEL_92;
          }

          if (v53)
          {
            uint64_t v56 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0LL);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v56;
            uint64_t v51 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, no backtrace";
LABEL_91:
            _os_log_impl(&dword_181A5C000, v48, v49, v51, buf, 0x12u);
          }
        }

    free(backtrace_string);
    goto LABEL_245;
  }

  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle) {
    char v8 = &a1[1].output_handler;
  }
  else {
    char v8 = 0LL;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_get_input_frames";
    v125 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (v192 == 17)
    {
      uint64_t v122 = (os_log_s *)__nwlog_obj();
      os_log_type_t v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_get_input_frames";
        __int16 v124 = "%{public}s called with null ipv6";
        goto LABEL_244;
      }

      goto LABEL_245;
    }

    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v122 = (os_log_s *)__nwlog_obj();
      os_log_type_t v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_get_input_frames";
        __int16 v124 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_244;
      }

      goto LABEL_245;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v122 = (os_log_s *)__nwlog_obj();
    os_log_type_t v123 = v192;
    BOOL v131 = os_log_type_enabled(v122, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v131)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_get_input_frames";
        __int16 v124 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_244;
      }

      goto LABEL_245;
    }

    if (v131)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_get_input_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v130 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_234;
    }

    goto LABEL_235;
  }

  if (a3 >= 0xFFFFFFD8) {
    int v9 = -1;
  }
  else {
    int v9 = a3 + 40;
  }
  int v10 = a4 + 40;
  if (a4 >= 0xFFFFFFD8) {
    int v10 = -1;
  }
  unsigned int v149 = v10;
  unsigned int v150 = v9;
  uint64_t v192 = 0LL;
  os_log_type_t v193 = &v192;
  int v195 = 0;
  uint64_t v194 = 0x2000000000LL;
  v146 = (char *)&a1[3].output_handler_context + 7;
  output_handler = a1->output_handler;
  if (!output_handler)
  {
LABEL_195:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
    uint64_t v114 = (char *)_os_log_send_and_compose_impl();
    v188[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v186[0]) = 0;
    if (v188[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v115 = (os_log_s *)__nwlog_obj();
      os_log_type_t v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0])) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v117 = "%{public}s called with null protocol";
    }

    else if (LOBYTE(v186[0]))
    {
      int v118 = (char *)__nw_create_backtrace_string();
      uint64_t v115 = (os_log_s *)__nwlog_obj();
      os_log_type_t v116 = v188[0];
      BOOL v119 = os_log_type_enabled(v115, v188[0]);
      if (v118)
      {
        if (v119)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v118;
          _os_log_impl( &dword_181A5C000,  v115,  v116,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v118);
LABEL_209:
        if (v114) {
          free(v114);
        }
        *((_DWORD *)v193 + 6) = 0;
LABEL_212:
        if ((BYTE6(a1[3].output_handler_context) & 1) == 0)
        {
          if (gLogDatapath)
          {
            __int128 v127 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_get_input_frames";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v146;
              *(_WORD *)&buf[22] = 2080;
              v199 = " ";
              __int16 v200 = 2048;
              v201 = (char *)p_output_handler;
              _os_log_impl( &dword_181A5C000,  v127,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p No IPv6 input frames",  buf,  0x2Au);
            }
          }
        }

        goto LABEL_214;
      }

      if (!v119) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v117 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v115 = (os_log_s *)__nwlog_obj();
      os_log_type_t v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0])) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v117 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v115, v116, v117, buf, 0xCu);
    goto LABEL_209;
  }

  __int16 v12 = a6;
  while (2)
  {
    os_log_type_t v13 = output_handler->handle;
    if (v13 == &nw_protocol_ref_counted_handle)
    {
      callbacks = output_handler[1].callbacks;
      if (callbacks) {
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
    }

    uint64_t v15 = a1->handle;
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v16 = a1[1].callbacks;
      if (v16) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v16->add_input_handler + 1);
      }
    }

    if (!v12)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      BOOL v96 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      v145 = (char *)v96;
      if (v188[0] == OS_LOG_TYPE_FAULT)
      {
        v97 = (os_log_s *)__nwlog_obj();
        os_log_type_t v98 = v188[0];
        *(void *)typed = v97;
        if (!os_log_type_enabled(v97, v188[0])) {
          goto LABEL_186;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
        v93 = *(os_log_s **)typed;
        os_log_type_t v94 = v98;
        os_log_type_t v95 = "%{public}s called with null return_array";
        uint32_t v99 = 12;
        goto LABEL_185;
      }

      if (LOBYTE(v186[0]))
      {
        BOOL v100 = (char *)__nw_create_backtrace_string();
        logb = (os_log_s *)__nwlog_obj();
        os_log_type_t typef = v188[0];
        BOOL v107 = os_log_type_enabled(logb, v188[0]);
        if (v100)
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v100;
            unsigned int v103 = logb;
            os_log_type_t v104 = typef;
            BOOL v105 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
            uint32_t v106 = 22;
LABEL_174:
            _os_log_impl(&dword_181A5C000, v103, v104, v105, buf, v106);
          }

LABEL_175:
          free(v100);
          goto LABEL_186;
        }

        if (v107)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          v93 = logb;
          os_log_type_t v94 = typef;
          os_log_type_t v95 = "%{public}s called with null return_array, no backtrace";
          uint32_t v99 = 12;
          goto LABEL_185;
        }
      }

      else
      {
        uint64_t v112 = (os_log_s *)__nwlog_obj();
        os_log_type_t v113 = v188[0];
        *(void *)typeh = v112;
        if (os_log_type_enabled(v112, v188[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          v93 = *(os_log_s **)typeh;
          os_log_type_t v94 = v113;
          os_log_type_t v95 = "%{public}s called with null return_array, backtrace limit exceeded";
          uint32_t v99 = 12;
          goto LABEL_185;
        }
      }

        goto LABEL_68;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v32 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      BOOL v7 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v94 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v13 = (os_log_s *)(id)gLogObj;
        int v33 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_181A5C000, v13, v33, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }

        goto LABEL_175;
      }

      if (!v94)
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v69 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl( &dword_181A5C000,  v13,  v69,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_175;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v48 = type;
      uint64_t v49 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl( &dword_181A5C000,  v13,  v48,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace",  buf,  0xCu);
        }

        goto LABEL_175;
      }

      if (v49)
      {
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        os_log_type_t v98 = 2082;
        *(void *)uint32_t v99 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v48,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      if (!v35) {
        goto LABEL_135;
      }
      goto LABEL_176;
    }

    __nwlog_obj();
    int v52 = (void *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v53 = networkd_privileged_result_to_string(v33);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
    int v76 = 2048;
    *(void *)int v77 = v33;
    *(_WORD *)&v77[8] = 2082;
    *(void *)&v77[10] = v53;
    uint64_t v35 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint32_t v72 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        int v76 = 2048;
        *(void *)int v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(void *)&v77[10] = v53;
        _os_log_impl( &dword_181A5C000,  v54,  v55,  "%{public}s received internal failure result code: [%lld] %{public}s",  buf,  0x20u);
      }
    }

    else if (v72)
    {
      int v65 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v66 = type;
      BOOL v67 = os_log_type_enabled(v54, type);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446978;
          os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          int v76 = 2048;
          *(void *)int v77 = v33;
          *(_WORD *)&v77[8] = 2082;
          *(void *)&v77[10] = v53;
          int v78 = 2082;
          uint64_t v79 = v65;
          _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v65);
        goto LABEL_175;
      }

      if (v67)
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        int v76 = 2048;
        *(void *)int v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(void *)&v77[10] = v53;
        _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v71 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        int v76 = 2048;
        *(void *)int v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(void *)&v77[10] = v53;
        _os_log_impl( &dword_181A5C000,  v54,  v71,  "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }

    goto LABEL_175;
  }

  if (Class == (Class)MEMORY[0x1895F9268])
  {
    if (v3 == (void *)MEMORY[0x1895F9198])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v30 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint32_t v72 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_181A5C000, v11, v31, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }

        goto LABEL_73;
      }

      if (!v72)
      {
        __nwlog_obj();
        BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v60 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl( &dword_181A5C000,  v11,  v60,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_73;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v45 = type;
      BOOL v46 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl( &dword_181A5C000,  v11,  v45,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace",  buf,  0xCu);
        }

        goto LABEL_73;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        int v76 = 2082;
        *(void *)int v77 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v45,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_25;
    }

    if (v3 != (void *)MEMORY[0x1895F91A0])
    {
      if (v3 != (void *)MEMORY[0x1895F91C8])
      {
        os_log_type_t v5 = (char *)MEMORY[0x186E12534](v3);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        int v76 = 2082;
        *(void *)int v77 = v5;
        BOOL v7 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint32_t v72 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v23 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            int v76 = 2082;
            *(void *)int v77 = v5;
            _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s received returned unknown XPC error %{public}s",  buf,  0x16u);
          }

          goto LABEL_63;
        }

        if (!v72)
        {
          __nwlog_obj();
          char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v68 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            int v76 = 2082;
            *(void *)int v77 = v5;
            _os_log_impl( &dword_181A5C000,  v8,  v68,  "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded",  buf,  0x16u);
          }

          goto LABEL_63;
        }

        uint64_t v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type;
        uint64_t v51 = os_log_type_enabled(v8, type);
        if (!v49)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            int v76 = 2082;
            *(void *)int v77 = v5;
            _os_log_impl( &dword_181A5C000,  v8,  v50,  "%{public}s received returned unknown XPC error %{public}s, no backtrace",  buf,  0x16u);
          }

          goto LABEL_63;
        }

        if (v51)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          int v76 = 2082;
          *(void *)int v77 = v5;
          *(_WORD *)&v77[8] = 2082;
          *(void *)&v77[10] = v49;
          _os_log_impl( &dword_181A5C000,  v8,  v50,  "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v49);
        if (!v7) {
          goto LABEL_74;
        }
LABEL_65:
        free(v7);
        goto LABEL_74;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v47 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint32_t v72 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v48 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_181A5C000, v11, v48, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }

      if (!v35) {
        goto LABEL_135;
      }
      goto LABEL_176;
    }

    __nwlog_obj();
    int v52 = (void *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v53 = networkd_privileged_result_to_string(v33);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
    int v76 = 2048;
    *(void *)int v77 = v33;
    *(_WORD *)&v77[8] = 2082;
    *(void *)&v77[10] = v53;
    uint64_t v35 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint32_t v72 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
        int v76 = 2048;
        *(void *)int v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(void *)&v77[10] = v53;
        _os_log_impl( &dword_181A5C000,  v54,  v55,  "%{public}s received internal failure result code: [%lld] %{public}s",  buf,  0x20u);
      }
    }

    else if (v72)
    {
      int v65 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v66 = type;
      BOOL v67 = os_log_type_enabled(v54, type);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446978;
          os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
          int v76 = 2048;
          *(void *)int v77 = v33;
          *(_WORD *)&v77[8] = 2082;
          *(void *)&v77[10] = v53;
          int v78 = 2082;
          uint64_t v79 = v65;
          _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v65);
        goto LABEL_175;
      }

      if (v67)
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
        int v76 = 2048;
        *(void *)int v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(void *)&v77[10] = v53;
        _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v71 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
        int v76 = 2048;
        *(void *)int v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(void *)&v77[10] = v53;
        _os_log_impl( &dword_181A5C000,  v54,  v71,  "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }

    goto LABEL_175;
  }

  if (Class == (Class)MEMORY[0x1895F9268])
  {
    if (v3 == (void *)MEMORY[0x1895F9198])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v30 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
      os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint32_t v72 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_181A5C000, v11, v31, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }

        goto LABEL_73;
      }

      if (!v72)
      {
        __nwlog_obj();
        BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v60 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl( &dword_181A5C000,  v11,  v60,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_73;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v45 = type;
      BOOL v46 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl( &dword_181A5C000,  v11,  v45,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace",  buf,  0xCu);
        }

        goto LABEL_73;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
        int v76 = 2082;
        *(void *)int v77 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v45,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_25;
    }

    if (v3 != (void *)MEMORY[0x1895F91A0])
    {
      if (v3 != (void *)MEMORY[0x1895F91C8])
      {
        os_log_type_t v5 = (char *)MEMORY[0x186E12534](v3);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
        int v76 = 2082;
        *(void *)int v77 = v5;
        BOOL v7 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint32_t v72 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v23 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
            int v76 = 2082;
            *(void *)int v77 = v5;
            _os_log_impl( &dword_181A5C000,  v8,  v23,  "%{public}s received returned unknown XPC error %{public}s",  buf,  0x16u);
          }

          goto LABEL_63;
        }

        if (!v72)
        {
          __nwlog_obj();
          char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v68 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
            int v76 = 2082;
            *(void *)int v77 = v5;
            _os_log_impl( &dword_181A5C000,  v8,  v68,  "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded",  buf,  0x16u);
          }

          goto LABEL_63;
        }

        uint64_t v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type;
        uint64_t v51 = os_log_type_enabled(v8, type);
        if (!v49)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
            int v76 = 2082;
            *(void *)int v77 = v5;
            _os_log_impl( &dword_181A5C000,  v8,  v50,  "%{public}s received returned unknown XPC error %{public}s, no backtrace",  buf,  0x16u);
          }

          goto LABEL_63;
        }

        if (v51)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
          int v76 = 2082;
          *(void *)int v77 = v5;
          *(_WORD *)&v77[8] = 2082;
          *(void *)&v77[10] = v49;
          _os_log_impl( &dword_181A5C000,  v8,  v50,  "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v49);
        if (!v7) {
          goto LABEL_74;
        }
LABEL_65:
        free(v7);
        goto LABEL_74;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v47 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
      os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint32_t v72 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v48 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_181A5C000, v11, v48, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }

    if (v65) {
      free(v65);
    }
    goto LABEL_38;
  }

  int v23 = nw_context_copy_registered_endpoint_internal(v25, v21, 0);

  if (gLogDatapath)
  {
    __nwlog_obj();
    uint32_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v73 = *(void *)(a3 + 16);
      *(_DWORD *)buf = 136448002;
      BOOL v101 = "nw_protocol_instance_registrar_add_edge_for_endpoint";
      BOOL v102 = 2112;
      unsigned int v103 = v95;
      os_log_type_t v104 = 2048;
      BOOL v105 = a3;
      uint32_t v106 = 2080;
      BOOL v107 = v73;
      os_log_type_t v108 = 2112;
      os_log_type_t v109 = (os_log_s *)v21;
      os_log_type_t v110 = 2048;
      uint64_t v111 = v21;
      uint64_t v112 = 2112;
      os_log_type_t v113 = v23;
      uint64_t v114 = 2048;
      uint64_t v115 = v23;
      _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s replacing unregistered endpoint %@ (%p) with endpoint %@ (%p)",  buf,  0x52u);
    }
  }

LABEL_19:
  int v26 = v96;
  int v27 = v26;
  if (!v26)
  {
    __nwlog_obj();
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v101 = "nw_endpoint_is_registered";
    os_log_t log = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v98 = 0;
    os_log_type_t v57 = (char *)log;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "nw_endpoint_is_registered";
        _os_log_impl(&dword_181A5C000, v58, v59, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v98)
    {
      int v76 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v91 = type;
      int v77 = os_log_type_enabled(v58, type);
      if (v76)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "nw_endpoint_is_registered";
          BOOL v102 = 2082;
          unsigned int v103 = v76;
          _os_log_impl( &dword_181A5C000,  v58,  v91,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v76);
        goto LABEL_157;
      }

      if (v77)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "nw_endpoint_is_registered";
        _os_log_impl(&dword_181A5C000, v58, v91, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v88 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "nw_endpoint_is_registered";
        _os_log_impl( &dword_181A5C000,  v58,  v88,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_157:
    os_log_type_t v57 = (char *)log;
LABEL_158:
    if (v57) {
      free(v57);
    }
    goto LABEL_21;
  }

  __int16 v28 = (v26[231] & 4) == 0;

  if (!v28)
  {
    os_log_type_t v31 = v27;
    goto LABEL_29;
  }
}

        goto LABEL_101;
      }

      if (v40 != 3 || !v9[106])
      {
        if (size == 1)
        {
          type[0].sa_len = 0;
          nw_dispatch_data_copyout(v11, (uint64_t)type, 1LL);
          int v41 = type[0].sa_len;
          __nwlog_obj();
          uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v43 = v42;
          if (v41)
          {
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&_BYTE buf[12] = 2114;
              *(void *)&buf[14] = v9;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&_BYTE buf[24] = type[0].sa_len;
              _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}@ client request has address length %u",  buf,  0x1Cu);
            }

            char v44 = type[0].sa_len;
            v9[106] = type[0].sa_len;
            nw_socks5_connection_inner_connection_read_range_on_queue((NWConcrete_nw_socks5_connection *)v9, v44, v44);
          }

          else
          {
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socks5_connection_inner_connection_read_handler_on_queue";
              *(_WORD *)&_BYTE buf[12] = 2114;
              *(void *)&buf[14] = v9;
              _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ address length is zero",  buf,  0x16u);
            }

      v138 = *v111++;
      *(void *)uint64_t v85 = v138;
      v85 += 8;
      os_log_type_t v110 = (uint64_t *)j;
    }
  }

  j = (unint64_t)v110;
LABEL_138:
  uint64_t v112 = (void *)a2->i64[0];
  a2->i64[0] = v18;
  a2->i64[1] = j;
  a2[1].i64[0] = (uint64_t)v85;
  a2[1].i64[1] = v15;
  uint64_t v15 = v407;
  a2[2].i64[0] += v405;
  j = v410;
  if (v112) {
    free(v112);
  }
LABEL_140:
  os_log_type_t v5 = a2[2].u64[0];
  int v9 = (unint64_t *)a2->i64[1];
  int v10 = (unint64_t *)a2[1].i64[0];
  int v20 = v5 >> 8;
  int v18 = v409;
  BOOL v24 = v412;
LABEL_141:
  os_log_type_t v113 = &v9[v20];
  if (v10 == v9)
  {
    uint64_t v114 = 0LL;
    uint64_t v115 = j - v24;
    if (j <= v24) {
      goto LABEL_202;
    }
LABEL_143:
    if (v24 >= j >> 1)
    {
      os_log_type_t v116 = v115 + ((uint64_t)&v16[-*(void *)v15] >> 4);
      if (v116 >= 1)
      {
        v15 += 8 * ((unint64_t)v116 >> 8);
LABEL_206:
        v161 = *(void *)v15 + 16LL * v116;
LABEL_218:
        v159 = v114;
        BOOL v160 = (char **)v113;
        goto LABEL_219;
      }

      os_log_type_t v167 = 255 - v116;
      uint64_t v168 = ~(_BYTE)v167;
      v15 -= 8 * (v167 >> 8);
    }

    else
    {
      if (!v24)
      {
        uint64_t v15 = (uint64_t)v419;
        v161 = v18;
        goto LABEL_207;
      }

      os_log_type_t v116 = ((uint64_t)(v18 - *v419) >> 4) - v24;
      if (v116 >= 1)
      {
        uint64_t v15 = (uint64_t)&v419[(unint64_t)v116 >> 8];
        goto LABEL_206;
      }

      int v169 = 255 - v116;
      uint64_t v168 = ~(_BYTE)v169;
      uint64_t v15 = (uint64_t)&v419[-(v169 >> 8)];
    }

    v161 = *(void *)v15 + 16LL * v168;
LABEL_207:
    BOOL v162 = (const void **)v15;
    v163 = (char *)v161;
    BOOL v160 = (char **)v113;
    v159 = v114;
    do
    {
      if (v159 == *v160)
      {
        v165 = (uint64_t)*--v160;
        v159 = (char *)(v165 + 4096);
      }

      if (v163 == *v162)
      {
        uint64_t v166 = (uint64_t)*--v162;
        v163 = (char *)(v166 + 4096);
      }

      BOOL v164 = *((_OWORD *)v163 - 1);
      v163 -= 16;
      *((_OWORD *)v159 - 1) = v164;
      v159 -= 16;
      a2[2] = vaddq_s64(a2[2], (int64x2_t)xmmword_18272D780);
    }

    while (v163 != v16);
LABEL_219:
    j = v24;
    uint64_t v16 = (char *)v161;
    if (!v24) {
      return;
    }
LABEL_220:
    v170 = j + ((uint64_t)&v114[-*v113] >> 4);
    if (v170 < 1)
    {
      v173 = 255 - v170;
      char v171 = &v113[-(v173 >> 8)];
      v172 = (char *)(*v171 + 16LL * ~(_BYTE)v173);
      if (v172 == v114) {
        goto LABEL_230;
      }
    }

    else
    {
      char v171 = &v113[(unint64_t)v170 >> 8];
      v172 = (char *)(*v171 + 16LL * v170);
      if (v172 == v114) {
        goto LABEL_230;
      }
    }

    BOOL v174 = (void **)v171;
    v175 = v172;
    do
    {
      if (v159 == *v160)
      {
        os_log_type_t v177 = (uint64_t)*--v160;
        v159 = (char *)(v177 + 4096);
      }

      if (v175 == *v174)
      {
        v178 = (uint64_t)*--v174;
        v175 = (char *)(v178 + 4096);
      }

      v176 = *((_OWORD *)v175 - 1);
      v175 -= 16;
      *((_OWORD *)v159 - 1) = v176;
      v159 -= 16;
      a2[2] = vaddq_s64(a2[2], (int64x2_t)xmmword_18272D780);
    }

    while (v175 != v114);
LABEL_230:
    if (j < v24)
    {
      v179 = (char *)*v113;
      BOOL v180 = v24 + ((uint64_t)&v114[-*v113] >> 4);
      if (v180 < 1)
      {
        char v183 = 255 - v180;
        v181 = (char **)&v113[-(v183 >> 8)];
        BOOL v182 = (uint64_t)&(*v181)[16 * ~(_BYTE)v183];
      }

      else
      {
        v181 = (char **)&v113[(unint64_t)v180 >> 8];
        BOOL v182 = (uint64_t)&(*v181)[16 * v180];
      }

      __srcb = (char *)v182;
      if (v171 != (unint64_t *)v181)
      {
        uint64_t v184 = *v171 + 4096;
        if ((char *)v184 != v172)
        {
          v185 = v16;
          v186 = v15;
          while (1)
          {
            char v187 = (v179 - v114 + 4096) >> 4;
            else {
              v188 = (v184 - (uint64_t)v172) >> 4;
            }
            if (v188) {
              memmove(v114, v172, 16 * v188);
            }
            v172 += 16 * v188;
            v189 = (char *)v113[1];
            ++v113;
            v179 = v189;
            uint64_t v114 = v189;
          }

          v114 += 16 * v188;
          v179 = (char *)*v113;
          if ((char *)(*v113 + 4096) == v114)
          {
            uint64_t v190 = (char *)v113[1];
            ++v113;
            v179 = v190;
            uint64_t v114 = v190;
          }

          uint64_t v15 = v186;
          uint64_t v16 = v185;
        }

        int v191 = (char **)(v171 + 1);
        if (v171 + 1 != (unint64_t *)v181)
        {
          v413 = v16;
          do
          {
            uint64_t v192 = v15;
            os_log_type_t v193 = v18;
            uint64_t v194 = 0LL;
            int v195 = *v191;
            while (1)
            {
              char v196 = (v179 - v114 + 4096) >> 4;
              if ((4096 - 16 * v194) >> 4 >= v196) {
                os_log_type_t v197 = v196;
              }
              else {
                os_log_type_t v197 = (4096 - 16 * v194) >> 4;
              }
              if (v197) {
                memmove(v114, &v195[16 * v194], 16 * v197);
              }
              v194 += v197;
              if (v194 == 256) {
                break;
              }
              os_log_type_t v198 = (char *)v113[1];
              ++v113;
              v179 = v198;
              uint64_t v114 = v198;
            }

            v114 += 16 * v197;
            v179 = (char *)*v113;
            if ((char *)(*v113 + 4096) == v114)
            {
              v199 = (char *)v113[1];
              ++v113;
              v179 = v199;
              uint64_t v114 = v199;
            }

            int v18 = v193;
            uint64_t v15 = v192;
            ++v191;
          }

          while (v191 != v181);
          uint64_t v16 = v413;
        }

        __int16 v200 = *v181;
        if (*v181 == __srcb) {
          goto LABEL_283;
        }
        v201 = (char *)*v113;
        while (1)
        {
          __int16 v202 = (v201 - v114 + 4096) >> 4;
          if ((__srcb - v200) >> 4 >= v202) {
            int v203 = v202;
          }
          else {
            int v203 = (__srcb - v200) >> 4;
          }
          if (v203) {
            memmove(v114, v200, 16 * v203);
          }
          v200 += 16 * v203;
          if (v200 == __srcb) {
            break;
          }
          __int16 v204 = (char *)v113[1];
          ++v113;
          v201 = v204;
          uint64_t v114 = v204;
        }

        v114 += 16 * v203;
        goto LABEL_281;
      }

      if (v172 != (char *)v182)
      {
        while (1)
        {
          uint64_t v206 = (v179 - v114 + 4096) >> 4;
          if ((__srcb - v172) >> 4 >= v206) {
            os_log_type_t v207 = v206;
          }
          else {
            os_log_type_t v207 = (__srcb - v172) >> 4;
          }
          if (v207) {
            memmove(v114, v172, 16 * v207);
          }
          v172 += 16 * v207;
          if (v172 == __srcb) {
            break;
          }
          os_log_type_t v205 = (char *)v113[1];
          ++v113;
          v179 = v205;
          uint64_t v114 = v205;
        }

        v114 += 16 * v207;
LABEL_281:
        if ((char *)(*v113 + 4096) == v114)
        {
          v208 = (char *)v113[1];
          ++v113;
          uint64_t v114 = v208;
        }
      }
    }

                free(v179);
                goto LABEL_251;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint32_t v72 = (os_log_s *)(id)gconnectionLogObj;
              v296 = type;
              if (os_log_type_enabled(v72, type))
              {
                v297 = nw_endpoint_handler_get_id_string(v356);
                v298 = nw_endpoint_handler_dry_run_string(v356);
                v299 = nw_endpoint_handler_copy_endpoint(v356);
                v300 = nw_endpoint_get_logging_description(v299);
                v301 = nw_endpoint_handler_state_string(v356);
                v302 = nw_endpoint_handler_mode_string(v356);
                v303 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v297;
                v376 = 2082;
                v377 = v298;
                v378 = 2082;
                v379 = v300;
                v380 = 2082;
                v381 = v301;
                v382 = 2082;
                v383 = v302;
                v384 = 2114;
                v385 = v303;
                v386 = 2080;
                v387 = "migration";
                _os_log_impl( &dword_181A5C000,  v72,  v296,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pass ed to %s notification, no backtrace",  buf,  0x52u);
              }
            }

            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint32_t v72 = (os_log_s *)(id)gconnectionLogObj;
              v272 = type;
              if (os_log_type_enabled(v72, type))
              {
                v273 = nw_endpoint_handler_get_id_string(v356);
                v274 = nw_endpoint_handler_dry_run_string(v356);
                v275 = nw_endpoint_handler_copy_endpoint(v356);
                v276 = nw_endpoint_get_logging_description(v275);
                v277 = nw_endpoint_handler_state_string(v356);
                v278 = nw_endpoint_handler_mode_string(v356);
                v279 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v273;
                v376 = 2082;
                v377 = v274;
                v378 = 2082;
                v379 = v276;
                v380 = 2082;
                v381 = v277;
                v382 = 2082;
                v383 = v278;
                v384 = 2114;
                v385 = v279;
                v386 = 2080;
                v387 = "migration";
                _os_log_impl( &dword_181A5C000,  v72,  v272,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument pass ed to %s notification, backtrace limit exceeded",  buf,  0x52u);
              }
            }

  if (*(_DWORD *)(v12 + 864) == 1)
  {
    if (v16)
    {
      a2 = *(nw_protocol **)(v12 + 488);
      if (a2) {
        nw_protocol_input_available(a2->default_input_handler->flow_id, (uint64_t)a2);
      }
    }
  }

          if ((*(_BYTE *)(v3 + 158) & 1) == 0)
          {
            if (*((_BYTE *)v4 + 1537))
            {
              v397 = v4;
              v398 = (os_log_s *)__nwlog_obj();
              v399 = os_log_type_enabled(v398, OS_LOG_TYPE_DEBUG);
              os_log_type_t v4 = v397;
              unint64_t v3 = v580;
              if (v399)
              {
                v400 = *(_DWORD *)(v580 + 372);
                v401 = *(_DWORD *)(v5 + 424);
                *(_DWORD *)buf = 136447490;
                *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v574;
                *(_WORD *)&buf[22] = 2080;
                v608 = (uint64_t)" ";
                *(_WORD *)v609 = 1024;
                *(_DWORD *)&v609[2] = v400;
                *(_WORD *)&v609[6] = 1024;
                *(_DWORD *)&v609[8] = v401;
                *(_WORD *)&v609[12] = 2048;
                *(void *)&v609[14] = v5;
                _os_log_impl( &dword_181A5C000,  v398,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called for stream %u (%p)",  buf,  0x36u);
                os_log_type_t v4 = v397;
                unint64_t v3 = v580;
              }
            }
          }

          if ((*(_WORD *)(v5 + 428) & 0x1000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(void *)&buf[14] = v5;
            BOOL v131 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(aBlock) = 0;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v132 = (os_log_s *)gLogObj;
              uint64_t v133 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                goto LABEL_205;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v5;
              v134 = "%{public}s stream %p not in pending list, cannot remove";
            }

            else if ((_BYTE)aBlock)
            {
              os_log_type_t v137 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v132 = (os_log_s *)gLogObj;
              uint64_t v133 = type[0];
              v138 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
              if (v137)
              {
                if (v138)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2048;
                  *(void *)&buf[14] = v5;
                  *(_WORD *)&buf[22] = 2082;
                  v608 = (uint64_t)v137;
                  _os_log_impl( &dword_181A5C000,  v132,  v133,  "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(v137);
                goto LABEL_205;
              }

              if (!v138)
              {
LABEL_205:
                if (v131) {
                  free(v131);
                }
                goto LABEL_217;
              }

              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v5;
              v134 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            }

            else
            {
              uint64_t v132 = (os_log_s *)__nwlog_obj();
              uint64_t v133 = type[0];
              if (!os_log_type_enabled(v132, type[0])) {
                goto LABEL_205;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v5;
              v134 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            }

            _os_log_impl(&dword_181A5C000, v132, v133, v134, buf, 0x16u);
            goto LABEL_205;
          }

          BOOL v135 = *(void *)(v5 + 296);
          v136 = *(void **)(v5 + 304);
          if (v135)
          {
            *(void *)(v135 + 304) = v136;
            v136 = *(void **)(v5 + 304);
          }

          else
          {
            *(void *)(v3 + 256) = v136;
          }

          os_log_s *v136 = v135;
          *(void *)(v5 + 296) = 0LL;
          *(void *)(v5 + 304) = 0LL;
          int v139 = *(_DWORD *)(v3 + 348);
          *(_DWORD *)(v3 + 34_Block_object_dispose(va, 8) = v139 - 1;
          if (v139)
          {
LABEL_215:
            *(_WORD *)(v5 + 428) &= ~0x1000u;
            if ((*(_BYTE *)(v5 + 158) & 1) == 0)
            {
              if (*((_BYTE *)v4 + 1537))
              {
                v409 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v409, OS_LOG_TYPE_DEBUG))
                {
                  v410 = v5 + 74;
                  v411 = *(void *)(v5 + 256);
                  v412 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
                  if (v411) {
                    LODWORD(v411) = *(_DWORD *)(v411 + 860);
                  }
                  os_log_type_t v5 = v579;
                  v413 = *(_DWORD *)(v579 + 424);
                  v414 = *(_DWORD *)(v580 + 348);
                  *(_DWORD *)buf = 136448258;
                  *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v410;
                  *(_WORD *)&buf[22] = 2080;
                  v608 = (uint64_t)" ";
                  *(_WORD *)v609 = 1024;
                  *(_DWORD *)&v609[2] = v412;
                  *(_WORD *)&v609[6] = 1024;
                  *(_DWORD *)&v609[8] = v411;
                  *(_WORD *)&v609[12] = 1024;
                  *(_DWORD *)&v609[14] = v413;
                  *(_WORD *)&v609[18] = 1024;
                  *(_DWORD *)&v609[20] = v413;
                  *(_WORD *)&v609[24] = 2048;
                  *(void *)&v609[26] = v579;
                  *(_WORD *)&v609[34] = 1024;
                  *(_DWORD *)&v609[36] = v414;
                  _os_log_impl( &dword_181A5C000,  v409,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed pending stream %u (%p), now have %u pending streams",  buf,  0x48u);
                }
              }
            }

          if (!v62)
          {
LABEL_177:
            char v8 = &qword_18C45F000;
LABEL_178:
            os_release(v21);
LABEL_179:
            char v22 = 0;
            goto LABEL_180;
          }

    if (v132) {
      free(v132);
    }
    goto LABEL_16;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446722;
  os_log_type_t v147 = "nw_http1_connection_process_input_frames_block_invoke";
  v148 = 2048;
  unsigned int v149 = (const char *)a2;
  unsigned int v150 = 1024;
  *(_DWORD *)os_log_type_t v151 = a3;
  BOOL v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v144 = 0;
  if (__nwlog_fault(v11, &type, &v144))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v147 = "nw_http1_connection_process_input_frames_block_invoke";
      v148 = 2048;
      unsigned int v149 = (const char *)a2;
      unsigned int v150 = 1024;
      *(_DWORD *)os_log_type_t v151 = a3;
      uint64_t v14 = "%{public}s unexpected values for body_start (%p) or body_length (%u)";
      goto LABEL_54;
    }

    if (!v144)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v147 = "nw_http1_connection_process_input_frames_block_invoke";
      v148 = 2048;
      unsigned int v149 = (const char *)a2;
      unsigned int v150 = 1024;
      *(_DWORD *)os_log_type_t v151 = a3;
      uint64_t v14 = "%{public}s unexpected values for body_start (%p) or body_length (%u), backtrace limit exceeded";
      goto LABEL_54;
    }

    BOOL v24 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v12 = (os_log_s *)gLogObj;
    os_log_type_t v13 = type;
    int v25 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v147 = "nw_http1_connection_process_input_frames_block_invoke";
        v148 = 2048;
        unsigned int v149 = (const char *)a2;
        unsigned int v150 = 1024;
        *(_DWORD *)os_log_type_t v151 = a3;
        *(_WORD *)&v151[4] = 2082;
        *(void *)&v151[6] = v24;
        _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s unexpected values for body_start (%p) or body_length (%u), dumping backtrace:%{public}s",  buf,  0x26u);
      }

      free(v24);
      goto LABEL_55;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v147 = "nw_http1_connection_process_input_frames_block_invoke";
      v148 = 2048;
      unsigned int v149 = (const char *)a2;
      unsigned int v150 = 1024;
      *(_DWORD *)os_log_type_t v151 = a3;
      uint64_t v14 = "%{public}s unexpected values for body_start (%p) or body_length (%u), no backtrace";
LABEL_54:
      _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0x1Cu);
    }
  }

    if (v70) {
      free(v70);
    }
    int v65 = *v68;
    LODWORD(type) = *v68;
    int v9 = (char *)v165;
    goto LABEL_178;
  }

  if (identifier != 1)
  {
    int v20 = 0LL;
    LODWORD(v10) = 0;
    goto LABEL_242;
  }

  uint64_t v166 = v10;
  LODWORD(v10) = 0;
  int v20 = 0LL;
  if (a4 >= 0x2400) {
    unsigned int v21 = 9216LL;
  }
  else {
    unsigned int v21 = a4;
  }
  __count = v21;
  BOOL v160 = v9 - 96;
  BOOL v162 = v12;
  while (1)
  {
    output_handler_context = (uint64_t)a1[5].output_handler_context;
    if (!output_handler_context) {
      break;
    }
    int v25 = *(void *)(output_handler_context + 16);
    int v26 = *(void **)(output_handler_context + 24);
    int v27 = (int)v10;
    if (v25)
    {
      *(void *)(v25 + 24) = v26;
      int v26 = *(void **)(output_handler_context + 24);
    }

    else
    {
      *(void *)a1[6].flow_id = v26;
    }

    LODWORD(v10) = 0;
    *int v26 = v25;
    *(void *)(output_handler_context + 16) = 0LL;
    *(void *)(output_handler_context + 24) = 0LL;
LABEL_86:
    if (((*(unsigned __int16 *)v13 | (a1[6].flow_id[15] << 16)) & 0x100000) == 0)
    {
      singleton = nw_protocol_metadata_create_singleton((void *)g_udp_definition);
      if (singleton)
      {
        int v55 = singleton;
        nw_frame_set_metadata(output_handler_context, (nw_protocol_metadata *)singleton, 1, 1);
        os_release(v55);
      }
    }

    LODWORD(v10) = v27 + (_DWORD)v10;
    *(void *)(output_handler_context + 16) = 0LL;
    char v22 = a1[5].default_input_handler;
    *(void *)(output_handler_context + 24) = v22;
    *(void *)v22->flow_id = output_handler_context;
    a1[5].default_input_handler = (nw_protocol *)(output_handler_context + 16);
    *(void *)(output_handler_context + 32) = 0LL;
    int v23 = (uint64_t *)v166->tqh_last;
    *(void *)(output_handler_context + 40) = v23;
    *int v23 = output_handler_context;
    v166->tqh_last = (nw_frame **)(output_handler_context + 32);
    int v20 = (v20 + 1);
    if ((_DWORD)v20 == (_DWORD)v12)
    {
      int v20 = v12;
      goto LABEL_242;
    }
  }

  int v27 = (int)v10;
  __int16 v28 = nw_calloc_type<unsigned char>(__count);
  *(void *)&uint64_t v190 = v28;
  *((void *)&v190 + 1) = __count;
  v188 = 0u;
  v189 = 0u;
  v186 = 0u;
  char v187 = 0u;
  uint64_t v184 = 0u;
  v185 = 0u;
  BOOL v182 = 0u;
  char v183 = 0u;
  BOOL v180 = 0u;
  v181 = 0u;
  v178 = 0u;
  v179 = 0u;
  memset(v177, 0, sizeof(v177));
  v168.msg_name = 0LL;
  v168.msg_namelen = 0;
  v168.msg_iov = (iovec *)&v190;
  v168.msg_iovlen = 1;
  v168.msg_control = v177;
  *(void *)&v168.msg_controllen = 0x8000000100LL;
  uint64_t v29 = recvmsg(*(_DWORD *)&a1[4].flow_id[12], &v168, 0);
  if (v29 < 0)
  {
    int v76 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if ((_DWORD)v76 == 35)
    {
      if ((*(_WORD *)v13 & 0x80) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v77 = (os_log_s *)gconnectionLogObj;
        int v9 = (char *)v165;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_get_input_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&char v171 = (char *)a1 + 404;
          _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Received EWOULDBLOCK",  buf,  0x16u);
        }
      }
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v81 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v82 = *(_DWORD *)&a1[4].flow_id[12];
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_socket_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2080;
        *(void *)&char v171 = (char *)a1 + 404;
        WORD4(v171) = 1024;
        *(_DWORD *)((char *)&v171 + 10) = v82;
        HIWORD(v171) = 1024;
        *(_DWORD *)v172 = __count;
        *(_WORD *)&v172[4] = 1024;
        *(_DWORD *)&v172[6] = v76;
        _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_ERROR,  "%{public}s %s recvmsg(fd %d, %u bytes) %{darwin.errno}d",  buf,  0x28u);
      }

      a1[6].flow_id[15] = (*(unsigned __int16 *)v13 | (a1[6].flow_id[15] << 16) | 0x80000u) >> 16;
      nw_socket_internal_error((uint64_t)v9, v76);
    }

    if (v28) {
      free((void *)v28);
    }
    goto LABEL_242;
  }

  int v10 = (nw_frame_array_s *)v29;
  os_log_type_t v31 = *(unsigned __int16 *)v13 | (a1[6].flow_id[15] << 16);
  if ((v31 & 0x80000) != 0)
  {
    nw_socket_internal_error((uint64_t)v9, 0LL);
    os_log_type_t v31 = (*(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16)) & 0xFFF7FFFF;
    *(_WORD *)os_log_type_t v13 = *(_WORD *)v13;
    a1[6].flow_id[15] = BYTE2(v31);
  }

  if ((v31 & 0x100) != 0)
  {
    os_log_type_t type = 0uLL;
    nw_protocol_get_flow_id(v160, &type);
    if ((*(_WORD *)v13 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v33 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = *(void *)v9;
        uint64_t v35 = ((_DWORD)v10 - 1);
        if (!v10) {
          uint64_t v35 = 0LL;
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_socket_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&char v171 = (char *)a1 + 404;
        WORD4(v171) = 1024;
        *(_DWORD *)((char *)&v171 + 10) = (_DWORD)v10;
        HIWORD(v171) = 2048;
        *(void *)v172 = v34;
        *(_WORD *)&v172[8] = 2048;
        *(void *)v173 = v34 + v35;
        _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s Received %u bytes (overall bytes %llu -> %llu)",  buf,  0x30u);
      }
    }

    pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
    char v36 = (os_log_s *)gMpklLogObj;
    if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = *(void *)v9;
      uint64_t v38 = ((_DWORD)v10 - 1);
      if (!v10) {
        uint64_t v38 = 0LL;
      }
      char v39 = BYTE2(a1[6].identifier);
      *(_DWORD *)buf = 67110658;
      *(_DWORD *)&uint8_t buf[4] = 100;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = 150;
      LOWORD(v171) = 1042;
      *(_DWORD *)((char *)&v171 + 2) = 16;
      WORD3(v171) = 2098;
      *((void *)&v171 + 1) = &type;
      *(_WORD *)v172 = 2048;
      *(void *)&void v172[2] = v37;
      *(_WORD *)v173 = 2048;
      *(void *)&v173[2] = v37 + v38;
      BOOL v174 = 1024;
      v175 = v39;
      _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEFAULT,  "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %llu, logSeqn: %hhu}",  buf,  0x38u);
    }

    ++BYTE2(a1[6].identifier);
  }

  else if ((v31 & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v32 = (os_log_s *)gconnectionLogObj;
    int v9 = (char *)v165;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_socket_get_input_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&char v171 = (char *)a1 + 404;
      WORD4(v171) = 1024;
      *(_DWORD *)((char *)&v171 + 10) = (_DWORD)v10;
      _os_log_impl(&dword_181A5C000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Received %u bytes", buf, 0x1Cu);
    }
  }

  *(void *)v9 += v10;
  ++a1[1].default_input_handler;
  if (!v10)
  {
    if (v28) {
      free((void *)v28);
    }
    nw_socket_input_finished(a1, v30);
    nw_socket_cancel_input_source((uint64_t)v9, v78);
    LODWORD(v10) = v27;
    goto LABEL_242;
  }

  unsigned int v40 = v28;
  int v41 = 0;
  uint64_t v42 = 0LL;
  if (v168.msg_controllen < 0xC)
  {
    char v44 = 0;
    output_handler_context = (uint64_t)a1[5].callbacks;
    if (!output_handler_context) {
      goto LABEL_72;
    }
    goto LABEL_76;
  }

  msg_control = (unsigned int *)v168.msg_control;
  char v44 = 0;
  if (!v168.msg_control)
  {
LABEL_75:
    output_handler_context = (uint64_t)a1[5].callbacks;
    if (!output_handler_context) {
      goto LABEL_72;
    }
LABEL_76:
    uint64_t v51 = *(void *)(output_handler_context + 16);
    int v52 = *(nw_protocol **)(output_handler_context + 24);
    if (v51)
    {
      *(void *)(v51 + 24) = v52;
      int v52 = *(nw_protocol **)(output_handler_context + 24);
    }

    else
    {
      a1[5].output_handler = v52;
    }

    *(void *)v52->flow_id = v51;
    *(void *)(output_handler_context + 16) = 0LL;
    *(void *)(output_handler_context + 24) = 0LL;
    nw_frame_reset(output_handler_context, v40, (int)v10, (uint64_t)nw_socket_frame_input_finalizer, v165);
    goto LABEL_80;
  }

  uint64_t v42 = 0LL;
  while (1)
  {
    int v47 = msg_control[1];
    if (v47 != 0xFFFF) {
      break;
    }
    if (msg_control[2] == 7) {
      uint64_t v42 = *(void *)(msg_control + 3);
    }
LABEL_54:
    uint64_t v45 = (unsigned int *)((char *)msg_control + ((*msg_control + 3LL) & 0x1FFFFFFFCLL));
    if ((char *)(v45 + 3) <= (char *)v168.msg_control + v168.msg_controllen)
    {
      BOOL v46 = v45 == msg_control;
    }

    else
    {
      uint64_t v45 = 0LL;
      BOOL v46 = 1;
    }

    msg_control = v45;
    if (v46)
    {
      int v41 = 0;
      char v44 = 0;
      output_handler_context = (uint64_t)a1[5].callbacks;
      if (output_handler_context) {
        goto LABEL_76;
      }
      goto LABEL_72;
    }
  }

  if (v47 != 41)
  {
    if (!v47)
    {
      __int16 v48 = msg_control[2];
      if (v48 == 24) {
        goto LABEL_91;
      }
      if (v48 == 27)
      {
LABEL_74:
        int v41 = 0;
        char v44 = msg_control[3];
        goto LABEL_75;
      }
    }

    goto LABEL_54;
  }

  uint64_t v49 = msg_control[2];
  if (v49 != 47)
  {
    if (v49 == 36) {
      goto LABEL_74;
    }
    goto LABEL_54;
  }

  __break(1u);
  return result;
}

      __break(1u);
      return result;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v58 = "nw_http_decrypt_chunked_oblivious_request_header";
    uint64_t v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v55 = 0;
    if (!__nwlog_fault(v29, &type, &v55))
    {
LABEL_173:
      if (v29) {
        free(v29);
      }
      return 0LL;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_173;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length == (hdr_length + enc_length))";
      goto LABEL_172;
    }

    if (!v55)
    {
      BOOL v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_173;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length == (hdr_length + enc_length)), backtrace limit exceeded";
      goto LABEL_172;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v30 = (os_log_s *)__nwlog_obj();
    os_log_type_t v31 = type;
    __int16 v48 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (!v48) {
        goto LABEL_173;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      BOOL v32 = "%{public}s called with null (header_length == (hdr_length + enc_length)), no backtrace";
      goto LABEL_172;
    }

    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v58 = "nw_http_decrypt_chunked_oblivious_request_header";
      os_log_type_t v59 = 2082;
      int v60 = (uint64_t)backtrace_string;
      uint64_t v35 = "%{public}s called with null (header_length == (hdr_length + enc_length)), dumping backtrace:%{public}s";
      goto LABEL_110;
    }

  BOOL v131 = v382;
  v382->privacy_proxy_client = v130;
  v382->protocol_establishment_reports[0].protocol_index = -1;
  v382->protocol_establishment_reports[1].protocol_index = -1;
  v382->protocol_establishment_reports[2].protocol_index = -1;
  v382->protocol_establishment_reports[3].protocol_index = -1;
  v382->protocol_establishment_reports[4].protocol_index = -1;
  v382->protocol_establishment_reports[5].protocol_index = -1;
  v382->protocol_establishment_reports[6].protocol_index = -1;
  v382->protocol_establishment_reports[7].protocol_index = -1;
  v382->protocol_establishment_reports[8].protocol_index = -1;
  v382->protocol_establishment_reports[9].protocol_index = -1;
  uint64_t v132 = nw_connection_copy_establishment_report_on_queue(v126);
  v379 = v132;
  if (v132)
  {
    uint64_t v133 = v132;
    v134 = v133[1];

    v382->attempt_delay_msecs = v134;
    BOOL v135 = v133;
    v136 = v135[2];

    v382->attempt_establishment_msecs = v136;
    *(void *)v425 = 0LL;
    *(void *)&v425[8] = v425;
    *(void *)&v425[16] = 0x2020000000LL;
    v426 = 0;
    os_log_type_t v137 = MEMORY[0x1895F87A8];
    v401[0] = MEMORY[0x1895F87A8];
    v401[1] = 3221225472LL;
    v401[2] = ___ZL49nw_connection_stats_fill_in_nw_report_on_nw_queueP24NWConcrete_nw_connectionP22nw_connection_report_s_block_invoke_3;
    v401[3] = &unk_189BC72E8;
    v403 = v425;
    v404 = v382;
    v138 = v126;
    v402 = v138;
    int v139 = v135;
    v140 = v401;
    uint64_t v141 = (unsigned __int8 *)v139[8];
    *(void *)buf = v137;
    *(void *)&buf[2] = 3221225472LL;
    *(void *)&uint8_t buf[4] = __nw_establishment_report_enumerate_protocols_block_invoke;
    *(void *)&buf[6] = &unk_189BC8628;
    os_log_type_t v142 = v140;
    *(void *)&buf[8] = v142;
    nw_array_apply(v141, (uint64_t)buf);

    if ((v382->privacy_stance & 0xFE) == 2)
    {
      *(_BYTE *)(*(void *)&v425[8] + 24LL) = 0;
      v143 = MEMORY[0x1895F87A8];
      v397[0] = MEMORY[0x1895F87A8];
      v397[1] = 3221225472LL;
      v397[2] = ___ZL49nw_connection_stats_fill_in_nw_report_on_nw_queueP24NWConcrete_nw_connectionP22nw_connection_report_s_block_invoke_46;
      v397[3] = &unk_189BC7310;
      v399 = v425;
      v400 = v382;
      v398 = v138;
      v144 = v139;
      v145 = v397;
      v146 = (unsigned __int8 *)v144[5];
      *(void *)buf = v143;
      *(void *)&buf[2] = 3221225472LL;
      *(void *)&uint8_t buf[4] = __nw_establishment_report_enumerate_proxy_endpoints_block_invoke;
      *(void *)&buf[6] = &unk_189BC8628;
      os_log_type_t v147 = v145;
      *(void *)&buf[8] = v147;
      nw_array_apply(v146, (uint64_t)buf);
    }

    _Block_object_dispose(v425, 8);
LABEL_186:
    BOOL v131 = v382;
    goto LABEL_187;
  }

  v148 = v380->parameters;
  if (v148 && !nw_path_parameters_get_logging_disabled(*((void *)v148 + 13)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    unsigned int v149 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
    {
      top_id = v126->top_id;
      buf[0] = 136446466;
      *(void *)&buf[1] = "nw_connection_stats_fill_in_nw_report_on_nw_queue";
      LOWORD(buf[3]) = 1024;
      *(_DWORD *)((char *)&buf[3] + 2) = top_id;
      _os_log_impl( &dword_181A5C000,  v149,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] did not receive establishment report",  (uint8_t *)buf,  0x12u);
    }

    goto LABEL_186;
  }

      if (v83) {
        free(v83);
      }
      goto LABEL_177;
    }

    uint64_t v68 = *(void *)(v25 + 24);
    if (v68)
    {
      os_log_type_t v69 = *(void (**)(uint64_t, void *))(v68 + 96);
      if (v69)
      {
        v69(v25, v228);
        goto LABEL_129;
      }
    }

    __nwlog_obj();
    os_log_type_t v128 = *(const char **)(v25 + 16);
    if (!v128) {
      os_log_type_t v128 = "invalid";
    }
    buf = 136446466;
    v231 = "send_data_callback";
    v232 = 2082;
    v233 = (unint64_t)v128;
    BOOL v129 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v172 = 0;
    if (__nwlog_fault(v129, &type, &v172))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v130 = (os_log_s *)__nwlog_obj();
        BOOL v131 = type;
        if (!os_log_type_enabled(v130, type)) {
          goto LABEL_317;
        }
        uint64_t v132 = *(const char **)(v25 + 16);
        if (!v132) {
          uint64_t v132 = "invalid";
        }
        buf = 136446466;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = (unint64_t)v132;
        uint64_t v133 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
LABEL_315:
        os_log_type_t v151 = v130;
        v152 = v131;
LABEL_316:
        _os_log_impl(&dword_181A5C000, v151, v152, v133, (uint8_t *)&buf, 0x16u);
        goto LABEL_317;
      }

      if (!v172)
      {
        uint64_t v130 = (os_log_s *)__nwlog_obj();
        BOOL v131 = type;
        if (!os_log_type_enabled(v130, type)) {
          goto LABEL_317;
        }
        unsigned int v150 = *(const char **)(v25 + 16);
        if (!v150) {
          unsigned int v150 = "invalid";
        }
        buf = 136446466;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = (unint64_t)v150;
        uint64_t v133 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_315;
      }

      os_log_type_t v142 = (char *)__nw_create_backtrace_string();
      v143 = (os_log_s *)__nwlog_obj();
      v144 = type;
      os_log_t loga = v143;
      v145 = os_log_type_enabled(v143, type);
      if (v142)
      {
        if (v145)
        {
          v146 = *(const char **)(v25 + 16);
          if (!v146) {
            v146 = "invalid";
          }
          buf = 136446722;
          v231 = "send_data_callback";
          v232 = 2082;
          v233 = (unint64_t)v146;
          v234 = 2082;
          v235 = v142;
          _os_log_impl( &dword_181A5C000,  loga,  v144,  "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x20u);
        }

        free(v142);
        goto LABEL_317;
      }

      if (v145)
      {
        v153 = *(const char **)(v25 + 16);
        if (!v153) {
          v153 = "invalid";
        }
        buf = 136446466;
        v231 = "send_data_callback";
        v232 = 2082;
        v233 = (unint64_t)v153;
        uint64_t v133 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
        os_log_type_t v151 = loga;
        v152 = v144;
        goto LABEL_316;
      }
    }

          free(v100);
          goto LABEL_186;
        }

        if (v107)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          v93 = logb;
          os_log_type_t v94 = typef;
          os_log_type_t v95 = "%{public}s called with null return_array, no backtrace";
          uint32_t v99 = 12;
          goto LABEL_185;
        }
      }

      else
      {
        uint64_t v112 = (os_log_s *)__nwlog_obj();
        os_log_type_t v113 = v188[0];
        *(void *)typeh = v112;
        if (os_log_type_enabled(v112, v188[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          v93 = *(os_log_s **)typeh;
          os_log_type_t v94 = v113;
          os_log_type_t v95 = "%{public}s called with null return_array, backtrace limit exceeded";
          uint32_t v99 = 12;
          goto LABEL_185;
        }
      }

      if (v90) {
        free(v90);
      }
      v239 = 1;
      char v8 = v233;
      char v6 = v234;
LABEL_178:
      BOOL v61 = v236;
      goto LABEL_179;
    }
  }

  BOOL v119 = v32;
  __nwlog_obj();
  *(_DWORD *)buf = 136446466;
  v254 = "nw_channel_add_input_frames";
  v255 = 1024;
  LODWORD(v256[0]) = v119;
  uint64_t v120 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v252 = OS_LOG_TYPE_DEFAULT;
  os_log_type_t v5 = v238;
  char v6 = v234;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (v252)
    {
      os_log_type_t v126 = (char *)__nw_create_backtrace_string();
      __int128 v127 = (os_log_s *)__nwlog_obj();
      os_log_type_t v128 = type[0];
      BOOL v129 = os_log_type_enabled(v127, type[0]);
      if (v126)
      {
        if (v129)
        {
          *(_DWORD *)buf = 136446722;
          v254 = "nw_channel_add_input_frames";
          v255 = 1024;
          LODWORD(v256[0]) = v119;
          WORD2(v256[0]) = 2082;
          *(void *)((char *)v256 + 6) = v126;
          _os_log_impl( &dword_181A5C000,  v127,  v128,  "%{public}s os_packet_increment_use_count() %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v126);
        goto LABEL_217;
      }

      if (!v129) {
        goto LABEL_217;
      }
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = v119;
      os_log_type_t v123 = v127;
      __int16 v124 = v128;
      v125 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d, no backtrace";
    }

    else
    {
      v144 = (os_log_s *)__nwlog_obj();
      v145 = type[0];
      if (!os_log_type_enabled(v144, type[0])) {
        goto LABEL_217;
      }
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = v119;
      os_log_type_t v123 = v144;
      __int16 v124 = v145;
      v125 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d, backtrace limit exceeded";
    }

uint64_t nw_channel_get_input_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, int a5, nw_frame_array_s *a6)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    int v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null channel_protocol";
      goto LABEL_51;
    }

    if (!v41)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v24 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v24) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null channel_protocol, no backtrace";
      goto LABEL_51;
    }

    if (!v24) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    int v25 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_37:
    _os_log_impl(&dword_181A5C000, v20, v21, v25, buf, 0x16u);
    goto LABEL_38;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    int v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null channel";
      goto LABEL_51;
    }

    if (!v41)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v26 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null channel, no backtrace";
      goto LABEL_51;
    }

    if (!v26) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    int v25 = "%{public}s called with null channel, dumping backtrace:%{public}s";
    goto LABEL_37;
  }

  a6->tqh_first = 0LL;
  a6->tqh_last = &a6->tqh_first;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    int v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null input_protocol";
      goto LABEL_51;
    }

    if (!v41)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      char v22 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v27 = os_log_type_enabled(v20, type[0]);
    if (backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        int v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }

void nw_channel_update_input_source(uint64_t a1, uint64_t a2, int a3)
{
  if ((*(_WORD *)(a1 + 444) & 1) == 0 && *(void *)(a1 + 168) && *(void *)(a1 + 224))
  {
    if (!uuid_is_null((const unsigned __int8 *)(a1 + 352))
      && (unint64_t)*(unsigned int *)(a1 + 416) >= *(void *)(a1 + 112) >> 1)
    {
      v23[0] = MEMORY[0x1895F87A8];
      v23[1] = 0x40000000LL;
      BOOL v24 = ___ZL30nw_channel_update_input_sourceP10nw_channelP11nw_protocolb_block_invoke;
      int v25 = &__block_descriptor_tmp_60;
      uint64_t v26 = a1;
      uint64_t v6 = *(void *)(a1 + 336);
      do
      {
        if (!v6) {
          break;
        }
        uint64_t v7 = *(void *)(v6 + 32);
        char v8 = ((uint64_t (*)(void *))v24)(v23);
        uint64_t v6 = v7;
      }

      while ((v8 & 1) != 0);
    }

    if (*(void *)(a1 + 224))
    {
      int v9 = (_WORD *)(a1 + 444);
      *(_WORD *)(a1 + 444) |= 1u;
      unsigned int v10 = os_channel_available_slot_count();
      if (v10) {
        BOOL v12 = 1;
      }
      else {
        BOOL v12 = a3 == 0;
      }
      if (v12)
      {
        unsigned int v13 = v10;
        if (*(_DWORD *)(a1 + 416) - 1 >= v10) {
          int v14 = 0;
        }
        else {
          int v14 = *(_DWORD *)(a1 + 416);
        }
        if (v10)
        {
          int v15 = (unsigned __int16)*v9;
          int v16 = v15 | (*(unsigned __int8 *)(a1 + 446) << 16);
          if ((v15 & 8) == 0)
          {
            *(_BYTE *)(a1 + 446) = BYTE2(v16);
            _WORD *v9 = v16 | 8;
            nw_queue_suspend_source(*(void *)(a1 + 168));
          }
        }

        if (v13 != v14)
        {
          do
          {
            char v17 = nw_channel_add_input_frames(a1, a2);
            if (!*(void *)(a1 + 224)) {
              break;
            }
            unsigned int v18 = os_channel_available_slot_count();
            unsigned int v13 = v18;
            if ((v17 & 1) == 0) {
              break;
            }
            int v19 = *(_DWORD *)(a1 + 416);
            if (v19 - 1 >= v18) {
              int v19 = 0;
            }
          }

          while (v18 != v19);
        }

        if (v13) {
          goto LABEL_30;
        }
      }

      else
      {
        char v22 = nw_channel_check_defunct(a1);
        if ((v22 & 1) != 0) {
          goto LABEL_30;
        }
      }

      int v20 = (unsigned __int16)*v9;
      if ((v20 & 8) != 0)
      {
        unsigned int v21 = v20 & 0xFFFFFFF7 | (*(unsigned __int8 *)(a1 + 446) << 16);
        _WORD *v9 = v20 & 0xFFF7;
        *(_BYTE *)(a1 + 446) = BYTE2(v21);
        nw_queue_resume_source(*(void *)(a1 + 168), v11);
      }

uint64_t nw_endpoint_handler_get_child_timeout_nanos(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  nw_interface_t v1 = a1;
  unsigned int v2 = v1;
  if (v1)
  {
    unint64_t v3 = nw_endpoint_handler_copy_endpoint(v1);
    else {
      address = 0LL;
    }
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v30 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_t v5 = v2;
    os_unfair_lock_lock(v2 + 28);
    id v6 = v5[8];
    os_unfair_lock_unlock(v2 + 28);

    if (v6 && nw_path_fillout_route_stats(v6, (uint64_t)buf, 0LL))
    {
      if (DWORD2(v34))
      {
        LODWORD(v7) = 8 * HIDWORD(v34) + (DWORD2(v34) >> 2);
        else {
          uint64_t v7 = v7;
        }
        unint64_t v8 = 31250 * (v7 + DWORD2(v34));
        goto LABEL_23;
      }
    }

    else
    {
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v30 = 0u;
      memset(buf, 0, sizeof(buf));
    }

    if (address && address->sa_family == 2)
    {
      unint64_t v8 = 250000000LL;
      int v9 = (const char *)nw_setting_tcpconn_ipv4_delay;
    }

    else
    {
      unint64_t v8 = 250000000LL;
      int v9 = (const char *)nw_setting_tcpconn_ipv6_delay;
    }

    networkd_settings_init();
    if (sCachedSettings)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (sCachedSettings)
      {
        int64_t int64 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v9);
        pthread_mutex_unlock(&sSettingsMutex);
      }

      else
      {
        pthread_mutex_unlock(&sSettingsMutex);
      }
    }

void sub_181B565A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_fillout_route_stats(void *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  os_log_type_t v5 = a1;
  id v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    char v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uint64_t v49 = 136446210;
    *(void *)&v49[4] = "nw_path_fillout_route_stats";
    __int16 v28 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v49 = 136446210;
        *(void *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null path", v49, 0xCu);
      }

      goto LABEL_65;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v49 = 136446210;
        *(void *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl( &dword_181A5C000,  v29,  v38,  "%{public}s called with null path, backtrace limit exceeded",  v49,  0xCu);
      }

      goto LABEL_65;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v34 = buf[0];
    BOOL v35 = os_log_type_enabled(v29, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)uint64_t v49 = 136446210;
        *(void *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_181A5C000, v29, v34, "%{public}s called with null path, no backtrace", v49, 0xCu);
      }

      goto LABEL_65;
    }

    if (v35)
    {
      *(_DWORD *)uint64_t v49 = 136446466;
      *(void *)&v49[4] = "nw_path_fillout_route_stats";
      *(_WORD *)&v49[12] = 2082;
      *(void *)&v49[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null path, dumping backtrace:%{public}s",  v49,  0x16u);
    }

    goto LABEL_53;
  }

  if (!a2)
  {
    __nwlog_obj();
    __int128 v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uint64_t v49 = 136446210;
    *(void *)&v49[4] = "nw_path_fillout_route_stats";
    __int16 v28 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v32 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v49 = 136446210;
        *(void *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null return_stats", v49, 0xCu);
      }

void sub_181B56E38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_queue_suspend_source(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    os_log_type_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_queue_suspend_source";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_queue_suspend_source";
        int v8 = "%{public}s called with null source";
LABEL_29:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v15 = "nw_queue_suspend_source";
            __int16 v16 = 2082;
            uint64_t v17 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null source, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_31;
        }

        if (!v10) {
          goto LABEL_30;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_queue_suspend_source";
        int v8 = "%{public}s called with null source, no backtrace";
        goto LABEL_29;
      }

      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_queue_suspend_source";
        int v8 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_29;
      }
    }

void nw_protocol_default_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_protocol_default_input_available";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_default_input_available";
      int v8 = "%{public}s called with null protocol";
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_protocol_default_input_available";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v5) {
          return;
        }
        goto LABEL_35;
      }

      if (!v10) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_default_input_available";
      int v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      id v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_default_input_available";
      int v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_frame_unclaimed_length(_DWORD *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v12 = "__nw_frame_unclaimed_length";
    unint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v12 = "__nw_frame_unclaimed_length";
      id v6 = "%{public}s called with null frame";
    }

    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v12 = "__nw_frame_unclaimed_length";
          __int16 v13 = 2082;
          __int128 v14 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (!v8)
      {
LABEL_18:
        if (v3) {
          free(v3);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      BOOL v12 = "__nw_frame_unclaimed_length";
      id v6 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v12 = "__nw_frame_unclaimed_length";
      id v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_18;
  }

  int v1 = a1[13];
  if (v1) {
    return (v1 - (a1[14] + a1[15]));
  }
  return 0LL;
}

BOOL nw_protocol_ipv4_process_input_frame( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t v158 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    os_log_type_t v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v147)
      {
        __int16 v90 = (os_log_s *)__nwlog_obj();
        os_log_type_t v91 = type[0];
        if (os_log_type_enabled(v90, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          os_log_type_t v92 = "%{public}s called with null ipv4, backtrace limit exceeded";
          goto LABEL_251;
        }

        goto LABEL_252;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v112 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (v112)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          os_log_type_t v92 = "%{public}s called with null ipv4, no backtrace";
          goto LABEL_251;
        }

        goto LABEL_252;
      }

      if (!v112) {
        goto LABEL_215;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      os_log_type_t v113 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_214;
    }

    __int16 v90 = (os_log_s *)__nwlog_obj();
    os_log_type_t v91 = type[0];
    if (!os_log_type_enabled(v90, type[0])) {
      goto LABEL_252;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    os_log_type_t v92 = "%{public}s called with null ipv4";
LABEL_251:
    _os_log_impl(&dword_181A5C000, v90, v91, v92, buf, 0xCu);
    goto LABEL_252;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    os_log_type_t v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v147)
      {
        __int16 v90 = (os_log_s *)__nwlog_obj();
        os_log_type_t v91 = type[0];
        if (os_log_type_enabled(v90, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          os_log_type_t v92 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_251;
        }

        goto LABEL_252;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v114 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (v114)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          os_log_type_t v92 = "%{public}s called with null frame, no backtrace";
          goto LABEL_251;
        }

        goto LABEL_252;
      }

      if (!v114) {
        goto LABEL_215;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      os_log_type_t v113 = "%{public}s called with null frame, dumping backtrace:%{public}s";
      goto LABEL_214;
    }

    __int16 v90 = (os_log_s *)__nwlog_obj();
    os_log_type_t v91 = type[0];
    if (!os_log_type_enabled(v90, type[0])) {
      goto LABEL_252;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    os_log_type_t v92 = "%{public}s called with null frame";
    goto LABEL_251;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    os_log_type_t v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = type[0];
      if (!os_log_type_enabled(v90, type[0])) {
        goto LABEL_252;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      os_log_type_t v92 = "%{public}s called with null count";
      goto LABEL_251;
    }

    if (!v147)
    {
      __int16 v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        os_log_type_t v92 = "%{public}s called with null count, backtrace limit exceeded";
        goto LABEL_251;
      }

      goto LABEL_252;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v90 = (os_log_s *)__nwlog_obj();
    os_log_type_t v91 = type[0];
    BOOL v115 = os_log_type_enabled(v90, type[0]);
    if (!backtrace_string)
    {
      if (v115)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        os_log_type_t v92 = "%{public}s called with null count, no backtrace";
        goto LABEL_251;
      }

      goto LABEL_252;
    }

    if (!v115) {
      goto LABEL_215;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    os_log_type_t v113 = "%{public}s called with null count, dumping backtrace:%{public}s";
LABEL_214:
    _os_log_impl(&dword_181A5C000, v90, v91, v113, buf, 0x16u);
    goto LABEL_215;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    os_log_type_t v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v90 = (os_log_s *)__nwlog_obj();
      os_log_type_t v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        os_log_type_t v92 = "%{public}s called with null reassembly_count";
        goto LABEL_251;
      }

LABEL_215:
    free(backtrace_string);
    goto LABEL_252;
  }

  if (!*(void *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
    unsigned int v14 = 0;
    uint64_t v15 = 0LL;
  }

  else
  {
    int v13 = *(_DWORD *)(a2 + 52);
    uint64_t v12 = *(unsigned int *)(a2 + 56);
    if (v13) {
      unsigned int v14 = v13 - (v12 + *(_DWORD *)(a2 + 60));
    }
    else {
      unsigned int v14 = 0;
    }
    uint64_t v15 = (uint32x4_t *)(*(void *)(a2 + 112) + v12);
  }

  if ((*(_WORD *)(a2 + 204) & 0x80) != 0) {
    unsigned int v14 = *(unsigned __int16 *)(a2 + 196);
  }
  if (!v15)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) != 0) {
      goto LABEL_227;
    }
    v93 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v93, OS_LOG_TYPE_INFO)) {
      goto LABEL_227;
    }
    goto LABEL_226;
  }

  if (v14 <= 0x13)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      os_log_type_t v94 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        unsigned int v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v14;
        _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p Received IPv4 packet with incorrect length %u",  buf,  0x30u);
      }
    }

    uint64_t v95 = *(void *)(a1 + 48);
    if (v95)
    {
      BOOL result = 0LL;
      ++*(void *)(v95 + 40);
      return result;
    }

    return 0LL;
  }

  if ((v15->i8[0] & 0xF0) != 0x40)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      BOOL v96 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      {
        int v97 = v15->u8[0] >> 4;
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        unsigned int v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v97;
        _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p Invalid IPv4 version: %u",  buf,  0x30u);
      }
    }

    uint64_t v98 = *(void *)(a1 + 48);
    if (v98)
    {
      BOOL result = 0LL;
      ++*(void *)(v98 + 96);
      return result;
    }

    return 0LL;
  }

  unsigned int v16 = 4 * (v15->i8[0] & 0xF);
  if (v16 <= 0x13)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      uint32_t v99 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        unsigned int v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v16;
        BOOL v100 = "%{public}s %{public}s%s%p Invalid header length: %u";
        BOOL v101 = v99;
        uint32_t v102 = 48;
LABEL_195:
        _os_log_impl(&dword_181A5C000, v101, OS_LOG_TYPE_ERROR, v100, buf, v102);
        goto LABEL_196;
      }
    }

    goto LABEL_196;
  }

  if (v14 < v16)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      unsigned int v103 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        unsigned int v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v16;
        __int16 v154 = 1024;
        *(_DWORD *)os_log_type_t v155 = v14;
        BOOL v100 = "%{public}s %{public}s%s%p Invalid header length: %u > %u";
LABEL_194:
        BOOL v101 = v103;
        uint32_t v102 = 54;
        goto LABEL_195;
      }
    }

  if (v53) {
    free(v53);
  }
}

        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v82 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = a1 + 531;
          *(_WORD *)&buf[22] = 2080;
          uint32_t v102 = " ";
          _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived ACK_CLIENT_CID capsule, server supports forwarding",  buf,  0x20u);
        }

        goto LABEL_219;
      case 16770051LL:
        if (*(void *)(a1 + 392))
        {
          os_log_type_t v24 = dispatch_data_get_size(v5);
          if (v24)
          {
            os_log_type_t v25 = v24;
            v106[0] = 0;
            *(void *)&length[0].sa_len = 0LL;
            *(void *)&length[0].sa_data[6] = length;
            length[1] = (sockaddr)0x2000000000uLL;
            address = 0LL;
            *(void *)&address_8.sa_len = &address;
            *(void *)&address_8.sa_data[6] = 0x2000000000LL;
            uint64_t v110 = 0LL;
            *(void *)buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&buf[16] = __nw_dispatch_data_copyout_from_offset_block_invoke;
            uint32_t v102 = (const char *)&unk_189BBF5C0;
            *(void *)&unsigned int v103 = &address;
            *((void *)&v103 + 1) = length;
            os_log_type_t v104 = 1LL;
            __int32 v105 = v106;
            dispatch_data_apply(v6, buf);
            _Block_object_dispose(&address, 8);
            _Block_object_dispose(length, 8);
            if (v25 <= v106[0])
            {
              if ((*(_BYTE *)(a1 + 529) & 1) == 0)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                uint64_t v15 = gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = a1 + 531;
                  *(_WORD *)&_BYTE buf[12] = 2080;
                  *(void *)&buf[14] = " ";
                  *(_WORD *)&buf[22] = 2048;
                  uint32_t v102 = (const char *)v25;
                  BOOL v8 = "%{public}s%sReceived short ACK_TARGET_CID capsule (%zu bytes)";
                  goto LABEL_48;
                }
              }
            }

            else
            {
              subrange = dispatch_data_create_subrange(v6, 1uLL, v106[0]);
              if (subrange)
              {
                uint64_t v27 = subrange;
                is_equal = nw_dispatch_data_is_equal(*(dispatch_data_t *)(a1 + 392), subrange);
                dispatch_release(v27);
                int v29 = *(_DWORD *)(a1 + 527);
                if (is_equal)
                {
                  if ((v29 & 0x10000) == 0)
                  {
                    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                    }
                    os_log_type_t v30 = (os_log_s *)gprivacy_proxyLogObj;
                    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = a1 + 531;
                      *(_WORD *)&buf[22] = 2080;
                      uint32_t v102 = " ";
                      _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived ACK_TARGET_CID capsule, forwarding allowed",  buf,  0x20u);
                    }
                  }

                  *(_DWORD *)(a1 + 527) |= 0x100u;
                  length[0].sa_len = 0;
                  nw_dispatch_data_copyout_from_offset(v6, (uint64_t)length, 1LL, v106[0] + 1LL);
                  char v31 = v106[0] + 2LL;
                  uint64_t v32 = length[0].sa_len;
                  if (v25 >= v31 + length[0].sa_len)
                  {
                    __int128 v33 = *(dispatch_object_s **)(a1 + 408);
                    if (v33)
                    {
                      dispatch_release(v33);
                      *(void *)(a1 + 40_Block_object_dispose(va, 8) = 0LL;
                      uint64_t v32 = length[0].sa_len;
                      char v31 = v106[0] + 2LL;
                    }

                    *(void *)(a1 + 40_Block_object_dispose(va, 8) = dispatch_data_create_subrange(v6, v31, v32);
                    if ((*(_BYTE *)(a1 + 529) & 1) == 0)
                    {
                      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                      }
                      uint64_t v34 = (os_log_s *)gprivacy_proxyLogObj;
                      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = a1 + 531;
                        *(_WORD *)&buf[22] = 2080;
                        uint32_t v102 = " ";
                        LOWORD(v103) = 1024;
                        *(_DWORD *)((char *)&v103 + 2) = length[0].sa_len;
                        _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived ACK_TARGET_CID virtual CID of length %u",  buf,  0x26u);
                      }
                    }
                  }
                }

                else if ((v29 & 0x10000) == 0)
                {
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  unsigned int v16 = (os_log_s *)gprivacy_proxyLogObj;
                  if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = a1 + 531;
                    *(_WORD *)&_BYTE buf[12] = 2080;
                    *(void *)&buf[14] = " ";
                    __int32 v17 = "%{public}s%sReceived ACK_TARGET_CID capsule with mismatched CID, ignoring";
                    goto LABEL_252;
                  }
                }
              }

              else if ((*(_BYTE *)(a1 + 529) & 1) == 0)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                uint64_t v15 = gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = a1 + 531;
                  *(_WORD *)&_BYTE buf[12] = 2080;
                  *(void *)&buf[14] = " ";
                  *(_WORD *)&buf[22] = 2048;
                  uint32_t v102 = (const char *)v25;
                  BOOL v8 = "%{public}s%sFailed to parse ACK_TARGET_CID capsule (%zu bytes)";
                  goto LABEL_48;
                }
              }
            }
          }

          else if ((*(_BYTE *)(a1 + 529) & 1) == 0)
          {
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            int v18 = gprivacy_proxyLogObj;
            if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = a1 + 531;
              *(_WORD *)&_BYTE buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&buf[22] = 2048;
              uint32_t v102 = 0LL;
              BOOL v8 = "%{public}s%sReceived short ACK_TARGET_CID capsule (%zu bytes)";
              goto LABEL_59;
            }
          }
        }

        else if ((*(_BYTE *)(a1 + 529) & 1) == 0)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          unsigned int v16 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = a1 + 531;
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = " ";
            __int32 v17 = "%{public}s%sReceived ACK_TARGET_CID capsule without a stored server CID, ignoring";
            goto LABEL_252;
          }
        }

        goto LABEL_266;
      case 16770052LL:
        if ((*(_BYTE *)(a1 + 529) & 1) != 0 || !gLogDatapath) {
          goto LABEL_266;
        }
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        os_log_type_t v7 = gprivacy_proxyLogObj;
        if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_266;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 531;
        *(_WORD *)&buf[22] = 2080;
        uint32_t v102 = " ";
        BOOL v8 = "%{public}s %{public}s%sReceived CLOSE_CLIENT_CID capsule, ignoring";
        goto LABEL_14;
      case 16770053LL:
        if ((*(_BYTE *)(a1 + 529) & 1) == 0 && gLogDatapath)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          BOOL v96 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = a1 + 531;
            *(_WORD *)&buf[22] = 2080;
            uint32_t v102 = " ";
            _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReceived CLOSE_TARGET_CID capsule",  buf,  0x20u);
          }
        }

        BOOL v35 = *(dispatch_object_s **)(a1 + 392);
        if (v35)
        {
          dispatch_release(v35);
          *(void *)(a1 + 392) = 0LL;
        }

        goto LABEL_266;
      default:
        switch(capsule_type)
        {
          case 0LL:
            if ((*(_BYTE *)(a1 + 529) & 1) != 0 || !gLogDatapath) {
              goto LABEL_266;
            }
            if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
              dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
            }
            os_log_type_t v7 = gprivacy_proxyLogObj;
            if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_266;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = a1 + 531;
            *(_WORD *)&buf[22] = 2080;
            uint32_t v102 = " ";
            BOOL v8 = "%{public}s %{public}s%sReceived DATAGRAM capsule";
            goto LABEL_14;
          case 1LL:
            memset(v106, 0, 18);
            os_log_type_t v36 = MEMORY[0x1895F87A8];
            while (2)
            {
              int v97 = 0LL;
              *(void *)&length[0].sa_len = 0LL;
              *(void *)&length[0].sa_data[6] = length;
              length[1] = (sockaddr)0x2000000000uLL;
              address = 0LL;
              *(void *)&address_8.sa_len = &address;
              *(void *)&address_8.sa_data[6] = 0x2000000000LL;
              uint64_t v110 = &v97;
              *(void *)buf = v36;
              *(void *)&buf[8] = 0x40000000LL;
              *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
              uint32_t v102 = (const char *)&unk_189BBF598;
              *((void *)&v103 + 1) = &address;
              os_log_type_t v104 = 8LL;
              *(void *)&unsigned int v103 = length;
              dispatch_data_apply(v6, buf);
              os_log_type_t v41 = *(void *)(*(void *)&length[0].sa_data[6] + 24LL);
              _Block_object_dispose(&address, 8);
              _Block_object_dispose(length, 8);
              if (v41)
              {
                uint64_t v42 = v97;
                if (v97 > 0x3Fu)
                {
                  if (v97 >> 6 == 2)
                  {
                    if (v41 < 4) {
                      break;
                    }
                    uint64_t v42 = bswap32(v97 & 0xFFFFFF7F);
                    uint64_t v43 = 4LL;
                  }

                  else if (v97 >> 6 == 1)
                  {
                    if (v41 < 2) {
                      break;
                    }
                    uint64_t v42 = bswap32(v97 & 0xFFBF) >> 16;
                    uint64_t v43 = 2LL;
                  }

                  else
                  {
                    if (v41 < 8) {
                      break;
                    }
                    uint64_t v42 = bswap64(v97 & 0xFFFFFFFFFFFFFF3FLL);
                    uint64_t v43 = 8LL;
                  }
                }

                else
                {
                  uint64_t v43 = 1LL;
                }

                if ((*(_BYTE *)(a1 + 529) & 1) == 0 && gLogDatapath)
                {
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  uint64_t v55 = (os_log_s *)gprivacy_proxyLogObj;
                  if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_masque_handle_capsule";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = a1 + 531;
                    *(_WORD *)&buf[22] = 2080;
                    uint32_t v102 = " ";
                    LOWORD(v103) = 2048;
                    *(void *)((char *)&v103 + 2) = v42;
                    _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sADDRESS_ASSIGN capsule contains request ID %llu",  buf,  0x2Au);
                  }
                }

                BOOL v44 = dispatch_data_get_size(v6);
                int v45 = v43 + 6;
                if (v44 < v43 + 6)
                {
                  if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
                    goto LABEL_265;
                  }
                  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                  }
                  int32x4_t v83 = gprivacy_proxyLogObj;
                  if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_265;
                  }
                }

                else
                {
                  *(void *)&length[0].sa_len = 0LL;
                  *(void *)&length[0].sa_data[6] = length;
                  length[1] = (sockaddr)0x2000000000uLL;
                  address = 0LL;
                  *(void *)&address_8.sa_len = &address;
                  *(void *)&address_8.sa_data[6] = 0x2000000000LL;
                  uint64_t v110 = (uint64_t *)v43;
                  *(void *)buf = v36;
                  *(void *)&buf[8] = 0x40000000LL;
                  *(void *)&buf[16] = __nw_dispatch_data_copyout_from_offset_block_invoke;
                  uint32_t v102 = (const char *)&unk_189BBF5C0;
                  *(void *)&unsigned int v103 = &address;
                  *((void *)&v103 + 1) = length;
                  os_log_type_t v104 = 1LL;
                  __int32 v105 = v106;
                  dispatch_data_apply(v6, buf);
                  _Block_object_dispose(&address, 8);
                  _Block_object_dispose(length, 8);
                  if (v106[0] != 6)
                  {
                    if (v106[0] != 4)
                    {
                      if ((*(_BYTE *)(a1 + 529) & 1) == 0)
                      {
                        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                        }
                        uint64_t v54 = (os_log_s *)gprivacy_proxyLogObj;
                        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 136446722;
                          *(void *)&uint8_t buf[4] = a1 + 531;
                          *(_WORD *)&_BYTE buf[12] = 2080;
                          *(void *)&buf[14] = " ";
                          *(_WORD *)&buf[22] = 1024;
                          LODWORD(v102) = v106[0];
                          _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_ERROR,  "%{public}s%sUnknown ADDRESS_ASSIGN version %u",  buf,  0x1Cu);
                        }
                      }

                      if (!v6) {
                        goto LABEL_265;
                      }
                      continue;
                    }

                    *(void *)&length[0].sa_len = 0LL;
                    *(void *)&length[0].sa_data[6] = length;
                    length[1] = (sockaddr)0x2000000000uLL;
                    address = 0LL;
                    *(void *)&address_8.sa_len = &address;
                    *(void *)&address_8.sa_data[6] = 0x2000000000LL;
                    uint64_t v110 = (uint64_t *)v43;
                    *(void *)buf = v36;
                    *(void *)&buf[8] = 0x40000000LL;
                    *(void *)&buf[16] = __nw_dispatch_data_copyout_from_offset_block_invoke;
                    uint32_t v102 = (const char *)&unk_189BBF5C0;
                    *(void *)&unsigned int v103 = &address;
                    *((void *)&v103 + 1) = length;
                    os_log_type_t v104 = 6LL;
                    __int32 v105 = v106;
                    dispatch_data_apply(v6, buf);
                    _Block_object_dispose(&address, 8);
                    _Block_object_dispose(length, 8);
                    *(_DWORD *)&length[0].sa_len = 528;
                    *(_DWORD *)&length[0].sa_data[2] = *(_DWORD *)&v106[1];
                    *(void *)&length[0].sa_data[6] = 0LL;
                    int v46 = nw_endpoint_create_address(length);
                    if ((*(_BYTE *)(a1 + 529) & 1) == 0)
                    {
                      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                      }
                      __int16 v47 = (os_log_s *)gprivacy_proxyLogObj;
                      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
                      {
                        logging_description = nw_endpoint_get_logging_description(v46);
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = a1 + 531;
                        *(_WORD *)&_BYTE buf[12] = 2080;
                        *(void *)&buf[14] = " ";
                        *(_WORD *)&buf[22] = 2082;
                        uint32_t v102 = logging_description;
                        _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived ADDRESS_ASSIGN capsule for %{public}s",  buf,  0x20u);
                      }
                    }

                    if (v46)
                    {
                      uint64_t v49 = *(void **)(a1 + 360);
                      if (v49) {
                        os_release(v49);
                      }
                      *(void *)(a1 + 360) = v46;
                    }

                    nw_protocol_notify(*(void **)(a1 + 48), a1, 17);
                    os_log_type_t v38 = v44 - v45;
                    if (v44 > v45)
                    {
                      os_log_type_t v39 = v6;
                      os_log_type_t v37 = v45;
LABEL_105:
                      int v40 = dispatch_data_create_subrange(v39, v37, v38);
                      dispatch_release(v6);
                      id v6 = v40;
                      if (!v40) {
                        goto LABEL_265;
                      }
                      continue;
                    }

                    goto LABEL_265;
                  }

                  if (v44 > 0x11)
                  {
                    *(void *)&length[0].sa_len = 0LL;
                    *(void *)&length[0].sa_data[6] = length;
                    length[1] = (sockaddr)0x2000000000uLL;
                    address = 0LL;
                    *(void *)&address_8.sa_len = &address;
                    *(void *)&address_8.sa_data[6] = 0x2000000000LL;
                    uint64_t v110 = (uint64_t *)v43;
                    *(void *)buf = v36;
                    *(void *)&buf[8] = 0x40000000LL;
                    *(void *)&buf[16] = __nw_dispatch_data_copyout_from_offset_block_invoke;
                    uint32_t v102 = (const char *)&unk_189BBF5C0;
                    *(void *)&unsigned int v103 = &address;
                    *((void *)&v103 + 1) = length;
                    os_log_type_t v104 = 18LL;
                    __int32 v105 = v106;
                    dispatch_data_apply(v6, buf);
                    _Block_object_dispose(&address, 8);
                    _Block_object_dispose(length, 8);
                    *(void *)&length[0].sa_len = 7708LL;
                    *(sockaddr *)&length[0].sa_data[6] = *(sockaddr *)&v106[1];
                    *(_DWORD *)&length[1].sa_data[6] = 0;
                    __int128 v50 = nw_endpoint_create_address(length);
                    if ((*(_BYTE *)(a1 + 529) & 1) == 0)
                    {
                      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                      }
                      uint64_t v51 = (os_log_s *)gprivacy_proxyLogObj;
                      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
                      {
                        uint64_t v52 = nw_endpoint_get_logging_description(v50);
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = a1 + 531;
                        *(_WORD *)&_BYTE buf[12] = 2080;
                        *(void *)&buf[14] = " ";
                        *(_WORD *)&buf[22] = 2082;
                        uint32_t v102 = v52;
                        _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_INFO,  "%{public}s%sReceived ADDRESS_ASSIGN capsule for %{public}s",  buf,  0x20u);
                      }
                    }

                    if (v50)
                    {
                      char v53 = *(void **)(a1 + 360);
                      if (v53) {
                        os_release(v53);
                      }
                      *(void *)(a1 + 360) = v50;
                    }

                    nw_protocol_notify(*(void **)(a1 + 48), a1, 17);
                    os_log_type_t v37 = v43 + 18;
                    os_log_type_t v38 = v44 - (v43 + 18);
                    if (v44 > v43 + 18)
                    {
                      os_log_type_t v39 = v6;
                      goto LABEL_105;
                    }

    if (v84) {
      free(v84);
    }
    goto LABEL_217;
  }

  BOOL v8 = (uint64_t *)(handle + 8);
LABEL_17:
  char v9 = *v8;
  if (!*v8) {
    goto LABEL_217;
  }
  if (!*(void *)(v9 + 248))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v108 = "nw_protocol_http1_output_finished";
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v105[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v75 = (os_log_s *)__nwlog_obj();
      unint64_t v76 = v105[0];
      if (!os_log_type_enabled(v75, v105[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v108 = "nw_protocol_http1_output_finished";
      uint64_t v55 = "%{public}s called with null http1_stream->protocol_http1";
    }

    else if (type[0])
    {
      int v58 = (char *)__nw_create_backtrace_string();
      unint64_t v75 = (os_log_s *)__nwlog_obj();
      unint64_t v76 = v105[0];
      uint64_t v88 = os_log_type_enabled(v75, v105[0]);
      if (v58)
      {
        if (!v88) {
          goto LABEL_227;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v108 = "nw_protocol_http1_output_finished";
        BOOL v109 = 2082;
        *(void *)uint64_t v110 = v58;
        int v60 = "%{public}s called with null http1_stream->protocol_http1, dumping backtrace:%{public}s";
        goto LABEL_225;
      }

      if (!v88) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v108 = "nw_protocol_http1_output_finished";
      uint64_t v55 = "%{public}s called with null http1_stream->protocol_http1, no backtrace";
    }

    else
    {
      unint64_t v75 = (os_log_s *)__nwlog_obj();
      unint64_t v76 = v105[0];
      if (!os_log_type_enabled(v75, v105[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v108 = "nw_protocol_http1_output_finished";
      uint64_t v55 = "%{public}s called with null http1_stream->protocol_http1, backtrace limit exceeded";
    }

    goto LABEL_233;
  }

  BOOL v10 = *(void *)(v9 + 256);
  if (!v10 || (*(_WORD *)(v9 + 428) & 0x100) == 0)
  {
    if ((*(_BYTE *)(v9 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v11 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(v9 + 256);
        int v13 = *(_DWORD *)(*(void *)(v9 + 248) + 372LL);
        if (v12) {
          unsigned int v14 = *(_DWORD *)(v12 + 860);
        }
        else {
          unsigned int v14 = 0;
        }
        unsigned int v20 = *(_DWORD *)(v9 + 424);
        int v21 = HIBYTE(*(unsigned __int16 *)(v9 + 428)) & 1;
        *(_DWORD *)buf = 136448002;
        uint64_t v108 = "nw_protocol_http1_output_finished";
        BOOL v109 = 2082;
        *(void *)uint64_t v110 = v9 + 74;
        *(_WORD *)&v110[8] = 2080;
        *(void *)&v110[10] = " ";
        uint64_t v111 = 1024;
        BOOL v112 = v13;
        os_log_type_t v113 = 1024;
        BOOL v114 = v14;
        BOOL v115 = 1024;
        BOOL v116 = v20;
        uint64_t v117 = 1024;
        *(_DWORD *)unsigned int v118 = v21;
        *(_WORD *)&v118[4] = 2048;
        *(void *)&v118[6] = v12;
        unsigned int v22 = "%{public}s %{public}s%s<i%u:c%u:s%u> dropping output_finished, chunked: %u, current_connection: %p";
        uint64_t v23 = (os_log_s *)v11;
        os_log_type_t v24 = 66;
LABEL_34:
        _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, v22, buf, v24);
        return;
      }
    }

    return;
  }

  if (*(void *)(v10 + 648))
  {
    if ((*(_BYTE *)(v10 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)gLogObj;
      unsigned int v16 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
      BOOL v10 = *(void *)(v9 + 256);
      if (v16)
      {
        __int32 v17 = *(void *)(v10 + 488);
        int v18 = *(_DWORD *)(*(void *)(v10 + 480) + 372LL);
        int v19 = *(_DWORD *)(v10 + 860);
        if (v17) {
          LODWORD(v17) = *(_DWORD *)(v17 + 424);
        }
        *(_DWORD *)buf = 136447490;
        uint64_t v108 = "nw_protocol_http1_output_finished";
        BOOL v109 = 2082;
        *(void *)uint64_t v110 = v10 + 74;
        *(_WORD *)&v110[8] = 2080;
        *(void *)&v110[10] = " ";
        uint64_t v111 = 1024;
        BOOL v112 = v18;
        os_log_type_t v113 = 1024;
        BOOL v114 = v19;
        BOOL v115 = 1024;
        BOOL v116 = v17;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> have pending output frames, deferring final chunk",  buf,  0x32u);
        BOOL v10 = *(void *)(v9 + 256);
      }
    }

    *(_WORD *)(v10 + 872) |= 0x8000u;
    return;
  }

  if ((*(_WORD *)(v9 + 428) & 0x400) != 0)
  {
    if ((*(_BYTE *)(v9 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v29 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v30 = *(void *)(v9 + 256);
        char v31 = *(_DWORD *)(*(void *)(v9 + 248) + 372LL);
        if (v30) {
          LODWORD(v30) = *(_DWORD *)(v30 + 860);
        }
        uint64_t v32 = *(_DWORD *)(v9 + 424);
        *(_DWORD *)buf = 136447490;
        uint64_t v108 = "nw_protocol_http1_output_finished";
        BOOL v109 = 2082;
        *(void *)uint64_t v110 = v9 + 74;
        *(_WORD *)&v110[8] = 2080;
        *(void *)&v110[10] = " ";
        uint64_t v111 = 1024;
        BOOL v112 = v31;
        os_log_type_t v113 = 1024;
        BOOL v114 = v30;
        BOOL v115 = 1024;
        BOOL v116 = v32;
        unsigned int v22 = "%{public}s %{public}s%s<i%u:c%u:s%u> dropping output_finished, outbound message already complete";
        uint64_t v23 = (os_log_s *)v29;
        os_log_type_t v24 = 50;
        goto LABEL_34;
      }
    }

    return;
  }

  if ((*(_BYTE *)(v9 + 158) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (os_log_s *)gLogObj;
    int v26 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
    BOOL v10 = *(void *)(v9 + 256);
    if (v26)
    {
      uint64_t v27 = *(_DWORD *)(*(void *)(v9 + 248) + 372LL);
      if (v10) {
        __int8 v28 = *(_DWORD *)(v10 + 860);
      }
      else {
        __int8 v28 = 0;
      }
      __int128 v33 = *(_DWORD *)(v9 + 424);
      *(_DWORD *)buf = 136447490;
      uint64_t v108 = "nw_protocol_http1_output_finished";
      BOOL v109 = 2082;
      *(void *)uint64_t v110 = v9 + 74;
      *(_WORD *)&v110[8] = 2080;
      *(void *)&v110[10] = " ";
      uint64_t v111 = 1024;
      BOOL v112 = v27;
      os_log_type_t v113 = 1024;
      BOOL v114 = v28;
      BOOL v115 = 1024;
      BOOL v116 = v33;
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> Sending final chunk immediately, no pending output",  buf,  0x32u);
      BOOL v10 = *(void *)(v9 + 256);
    }

    if (!v10)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v108 = "nw_http1_connection_send_final_chunk";
      uint64_t v52 = (char *)_os_log_send_and_compose_impl();
      v105[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (v105[0] == OS_LOG_TYPE_FAULT)
      {
        unint64_t v75 = (os_log_s *)__nwlog_obj();
        unint64_t v76 = v105[0];
        if (!os_log_type_enabled(v75, v105[0])) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v108 = "nw_http1_connection_send_final_chunk";
        uint64_t v55 = "%{public}s called with null http1_connection";
        goto LABEL_233;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        unint64_t v75 = (os_log_s *)__nwlog_obj();
        unint64_t v76 = v105[0];
        if (!os_log_type_enabled(v75, v105[0])) {
          goto LABEL_235;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v108 = "nw_http1_connection_send_final_chunk";
        uint64_t v55 = "%{public}s called with null http1_connection, backtrace limit exceeded";
        goto LABEL_233;
      }

      int v58 = (char *)__nw_create_backtrace_string();
      unint64_t v75 = (os_log_s *)__nwlog_obj();
      unint64_t v76 = v105[0];
      BOOL v101 = os_log_type_enabled(v75, v105[0]);
      if (!v58)
      {
        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v108 = "nw_http1_connection_send_final_chunk";
          uint64_t v55 = "%{public}s called with null http1_connection, no backtrace";
          goto LABEL_233;
        }

        goto LABEL_235;
      }

      if (!v101) {
        goto LABEL_227;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v108 = "nw_http1_connection_send_final_chunk";
      BOOL v109 = 2082;
      *(void *)uint64_t v110 = v58;
      int v60 = "%{public}s called with null http1_connection, dumping backtrace:%{public}s";
LABEL_225:
      BOOL v61 = v75;
      BOOL v62 = v76;
      uint32_t v63 = 22;
      goto LABEL_226;
    }
  }

  if ((*(_BYTE *)(v10 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v93 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v94 = *(void *)(v10 + 488);
        uint64_t v95 = *(_DWORD *)(*(void *)(v10 + 480) + 372LL);
        BOOL v96 = *(_DWORD *)(v10 + 860);
        if (v94) {
          LODWORD(v94) = *(_DWORD *)(v94 + 424);
        }
        *(_DWORD *)buf = 136447490;
        uint64_t v108 = "nw_http1_connection_send_final_chunk";
        BOOL v109 = 2082;
        *(void *)uint64_t v110 = v10 + 74;
        *(_WORD *)&v110[8] = 2080;
        *(void *)&v110[10] = " ";
        uint64_t v111 = 1024;
        BOOL v112 = v95;
        os_log_type_t v113 = 1024;
        BOOL v114 = v96;
        BOOL v115 = 1024;
        BOOL v116 = v94;
        _os_log_impl( &dword_181A5C000,  v93,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> requesting new frame for final chunk",  buf,  0x32u);
      }
    }
  }

  uint64_t v34 = *(void *)(v10 + 32);
  if (!v34)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v108 = "nw_http1_connection_send_final_chunk";
    uint64_t v52 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v105[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v75 = (os_log_s *)__nwlog_obj();
      unint64_t v76 = v105[0];
      if (!os_log_type_enabled(v75, v105[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v108 = "nw_http1_connection_send_final_chunk";
      uint64_t v55 = "%{public}s called with null output_handler";
      goto LABEL_233;
    }

    if (type[0])
    {
      int v58 = (char *)__nw_create_backtrace_string();
      unint64_t v75 = (os_log_s *)__nwlog_obj();
      unint64_t v76 = v105[0];
      BOOL v100 = os_log_type_enabled(v75, v105[0]);
      if (v58)
      {
        if (!v100) {
          goto LABEL_227;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v108 = "nw_http1_connection_send_final_chunk";
        BOOL v109 = 2082;
        *(void *)uint64_t v110 = v58;
        int v60 = "%{public}s called with null output_handler, dumping backtrace:%{public}s";
        goto LABEL_225;
      }

      if (v100)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v108 = "nw_http1_connection_send_final_chunk";
        uint64_t v55 = "%{public}s called with null output_handler, no backtrace";
        goto LABEL_233;
      }

    if (!v18) {
      return;
    }
    goto LABEL_216;
  }

  uint64_t v110 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v110 == 22 || v110 == 42)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v111 = (os_log_s *)gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_215;
    }
    BOOL v112 = *(_DWORD *)(v171 + 172);
    *(_DWORD *)buf = 136447234;
    v179 = "nw_protocol_socket_set_necp_attributes";
    BOOL v180 = 1024;
    *(_DWORD *)v181 = v112;
    *(_WORD *)&v181[4] = 1040;
    *(_DWORD *)&v181[6] = v8;
    *(_WORD *)BOOL v182 = 2096;
    *(void *)&v182[2] = v18;
    *(_WORD *)&v182[10] = 1024;
    *(_DWORD *)&v182[12] = v110;
    _os_log_impl( &dword_181A5C000,  v111,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n%{network:data}.*P %{darwin.errno}d",  buf,  0x28u);
    if (!v18) {
      return;
    }
LABEL_216:
    free(v18);
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v113 = *(_DWORD *)(v171 + 172);
  *(_DWORD *)buf = 136447234;
  v179 = "nw_protocol_socket_set_necp_attributes";
  BOOL v180 = 1024;
  *(_DWORD *)v181 = v113;
  *(_WORD *)&v181[4] = 1040;
  *(_DWORD *)&v181[6] = v8;
  *(_WORD *)BOOL v182 = 2096;
  *(void *)&v182[2] = v18;
  *(_WORD *)&v182[10] = 1024;
  *(_DWORD *)&v182[12] = v110;
  BOOL v114 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v176 = 0;
  if ((__nwlog_fault(v114, &type, &v176) & 1) != 0)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v115 = (os_log_s *)gLogObj;
      BOOL v116 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_226;
      }
      uint64_t v117 = *(_DWORD *)(v171 + 172);
      *(_DWORD *)buf = 136447234;
      v179 = "nw_protocol_socket_set_necp_attributes";
      BOOL v180 = 1024;
      *(_DWORD *)v181 = v117;
      *(_WORD *)&v181[4] = 1040;
      *(_DWORD *)&v181[6] = v8;
      *(_WORD *)BOOL v182 = 2096;
      *(void *)&v182[2] = v174;
      *(_WORD *)&v182[10] = 1024;
      *(_DWORD *)&v182[12] = v110;
      unsigned int v118 = "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n%{network:data}.*P %{darwin.errno}d";
LABEL_224:
      v125 = v115;
      unsigned int v126 = v116;
LABEL_225:
      _os_log_impl(&dword_181A5C000, v125, v126, v118, buf, 0x28u);
      goto LABEL_226;
    }

    if (!v176)
    {
      BOOL v115 = (os_log_s *)__nwlog_obj();
      BOOL v116 = type;
      if (!os_log_type_enabled(v115, type)) {
        goto LABEL_226;
      }
      uint64_t v124 = *(_DWORD *)(v171 + 172);
      *(_DWORD *)buf = 136447234;
      v179 = "nw_protocol_socket_set_necp_attributes";
      BOOL v180 = 1024;
      *(_DWORD *)v181 = v124;
      *(_WORD *)&v181[4] = 1040;
      *(_DWORD *)&v181[6] = v8;
      *(_WORD *)BOOL v182 = 2096;
      *(void *)&v182[2] = v174;
      *(_WORD *)&v182[10] = 1024;
      *(_DWORD *)&v182[12] = v110;
      unsigned int v118 = "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n"
             "%{network:data}.*P %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_224;
    }

    int v119 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v120 = (os_log_s *)gLogObj;
    uint64_t v121 = type;
    unsigned int v122 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v119)
    {
      if (v122)
      {
        unsigned int v123 = *(_DWORD *)(v171 + 172);
        *(_DWORD *)buf = 136447490;
        v179 = "nw_protocol_socket_set_necp_attributes";
        BOOL v180 = 1024;
        *(_DWORD *)v181 = v123;
        *(_WORD *)&v181[4] = 1040;
        *(_DWORD *)&v181[6] = v8;
        *(_WORD *)BOOL v182 = 2096;
        *(void *)&v182[2] = v174;
        *(_WORD *)&v182[10] = 1024;
        *(_DWORD *)&v182[12] = v110;
        *(_WORD *)&v182[16] = 2082;
        *(void *)&v182[18] = v119;
        _os_log_impl( &dword_181A5C000,  v120,  v121,  "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n %{network:data}.*P %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x32u);
      }

      free(v119);
    }

    else if (v122)
    {
      uint64_t v127 = *(_DWORD *)(v171 + 172);
      *(_DWORD *)buf = 136447234;
      v179 = "nw_protocol_socket_set_necp_attributes";
      BOOL v180 = 1024;
      *(_DWORD *)v181 = v127;
      *(_WORD *)&v181[4] = 1040;
      *(_DWORD *)&v181[6] = v8;
      *(_WORD *)BOOL v182 = 2096;
      *(void *)&v182[2] = v174;
      *(_WORD *)&v182[10] = 1024;
      *(_DWORD *)&v182[12] = v110;
      unsigned int v118 = "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n%{network:data}.*P %{darwin.errno}d, no backtrace";
      v125 = v120;
      unsigned int v126 = v121;
      goto LABEL_225;
    }
  }

  __break(1u);
  return result;
}

        free(v88);
        goto LABEL_216;
      }

      if (v125)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl( &dword_181A5C000,  v89,  v124,  "%{public}s called with null (strlen(description) < 128), no backtrace",  location,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int64x2_t v133 = type;
      if (os_log_type_enabled(v89, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl( &dword_181A5C000,  v89,  v133,  "%{public}s called with null (strlen(description) < 128), backtrace limit exceeded",  location,  0xCu);
      }
    }

          uint64_t v158 = v7;
          if (v7)
          {
            v159 = v158;
            BOOL v160 = (*((_BYTE *)v158 + 268) & 0x20) == 0;

            if (v160)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v161 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
              {
                os_log_t logc = v161;
                BOOL v162 = v159;

                v163 = v162;
                BOOL v164 = (*((_BYTE *)v159 + 268) & 1) == 0;

                if (v164) {
                  v165 = "";
                }
                else {
                  v165 = "dry-run ";
                }
                uint64_t v166 = nw_endpoint_handler_copy_endpoint(v163);
                os_log_type_t v167 = nw_endpoint_get_logging_description(v166);
                uint64_t v168 = v163;
                int v169 = v168;
                v170 = v168[30];
                else {
                  char v171 = off_189BBBBF0[v170];
                }
                v201 = v171;

                v172 = v169;
                v173 = v172;
                BOOL v174 = "path";
                switch(*((_DWORD *)v172 + 29))
                {
                  case 0:
                    break;
                  case 1:
                    BOOL v174 = "resolver";
                    break;
                  case 2:
                    BOOL v174 = nw_endpoint_flow_mode_string(v172[31]);
                    break;
                  case 3:
                    BOOL v174 = "proxy";
                    break;
                  case 4:
                    BOOL v174 = "fallback";
                    break;
                  case 5:
                    BOOL v174 = "transform";
                    break;
                  default:
                    BOOL v174 = "unknown-mode";
                    break;
                }

                v175 = v173;
                os_unfair_lock_lock((os_unfair_lock_t)v175 + 28);
                v176 = v175[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v175 + 28);

                os_log_type_t v177 = v176;
                v178 = v177;
                os_log_type_t v219 = "nw_endpoint_flow_rebuild_stack";
                v179 = "invalid";
                identifier = a2->identifier;
                *(_DWORD *)buf = 136448258;
                if (identifier) {
                  v179 = (const char *)identifier;
                }
                v220 = 2082;
                __int16 v221 = v162 + 168;
                v222 = 2082;
                unint64_t v223 = (nw_protocol *)v165;
                char v224 = 2082;
                uint64_t v225 = (void *)v167;
                v226 = 2082;
                v227 = v201;
                v228 = 2082;
                v229 = v174;
                v230 = 2114;
                v231 = v177;
                v232 = 2080;
                v233 = v179;
                v234 = 2048;
                v235 = a2;
                _os_log_impl( &dword_181A5C000,  logc,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unable to remove inpu t handler for %s:%p",  buf,  0x5Cu);

                v161 = logc;
              }
            }

            goto LABEL_237;
          }

          __nwlog_obj();
          v181 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v219 = "nw_endpoint_handler_get_logging_disabled";
          BOOL v182 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v214) = 0;
          if (__nwlog_fault(v182, type, &v214))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              char v183 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v184 = type[0];
              if (os_log_type_enabled(v183, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v219 = "nw_endpoint_handler_get_logging_disabled";
                _os_log_impl(&dword_181A5C000, v183, v184, "%{public}s called with null handler", buf, 0xCu);
              }
            }

            else if ((_BYTE)v214)
            {
              v185 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              char v183 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v186 = type[0];
              char v187 = os_log_type_enabled(v183, type[0]);
              if (v185)
              {
                if (v187)
                {
                  *(_DWORD *)buf = 136446466;
                  os_log_type_t v219 = "nw_endpoint_handler_get_logging_disabled";
                  v220 = 2082;
                  __int16 v221 = v185;
                  _os_log_impl( &dword_181A5C000,  v183,  v186,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v185);
                goto LABEL_273;
              }

              if (v187)
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v219 = "nw_endpoint_handler_get_logging_disabled";
                _os_log_impl( &dword_181A5C000,  v183,  v186,  "%{public}s called with null handler, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              char v183 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              int v195 = type[0];
              if (os_log_type_enabled(v183, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v219 = "nw_endpoint_handler_get_logging_disabled";
                _os_log_impl( &dword_181A5C000,  v183,  v195,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

LABEL_129:
        unint64_t v76 = ((HIDWORD(v75) + v75) >> 16) + (unsigned __int16)(WORD2(v75) + v75);
        int v77 = (v76 >> 16) + (unsigned __int16)v76;
        goto LABEL_136;
      }

      if ((*(_BYTE *)(a1 + 136) & 1) == 0)
      {
        unsigned int v103 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = a1 + 137;
          *(_WORD *)&buf[22] = 2080;
          unsigned int v149 = " ";
          __int16 v150 = 2048;
          uint64_t v151 = a1;
          __int16 v152 = 1024;
          unsigned int v153 = v16;
          __int16 v154 = 1024;
          *(_DWORD *)os_log_type_t v155 = v20;
          BOOL v100 = "%{public}s %{public}s%s%p Invalid header length (greater than IP length): %u > %u";
          goto LABEL_194;
        }
      }

      goto LABEL_196;
    }

    if ((*(_BYTE *)(a1 + 136) & 1) != 0) {
      return 0LL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v55 = gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int32 v57 = v15[1].i32[0];
    int v58 = *(_DWORD *)(a1 + 56);
    int v60 = *(_DWORD *)(a1 + 124);
    int v59 = *(_DWORD *)(a1 + 128);
    *(_DWORD *)buf = 136448002;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = a1 + 137;
    *(_WORD *)&buf[22] = 2080;
    unsigned int v149 = " ";
    __int16 v150 = 2048;
    uint64_t v151 = a1;
    __int16 v152 = 1024;
    unsigned int v153 = v57;
    __int16 v154 = 1024;
    *(_DWORD *)os_log_type_t v155 = v58;
    *(_WORD *)&v155[4] = 1024;
    *(_DWORD *)&v155[6] = v59;
    __int16 v156 = 1024;
    int v157 = v60;
    BOOL v61 = "%{public}s %{public}s%s%p Received local address 0x%x != 0x%x (broadcast %x, netmask %x)";
    BOOL v62 = (os_log_s *)v55;
    uint32_t v63 = 66;
LABEL_88:
    _os_log_impl(&dword_181A5C000, v62, OS_LOG_TYPE_ERROR, v61, buf, v63);
    return 0LL;
  }

  if ((*(_BYTE *)(a1 + 136) & 1) != 0) {
    return 0LL;
  }
  os_log_type_t v104 = (os_log_s *)__nwlog_obj();
  BOOL result = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __int32 v105 = v15->i32[3];
    int v106 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = a1 + 137;
    *(_WORD *)&buf[22] = 2080;
    unsigned int v149 = " ";
    __int16 v150 = 2048;
    uint64_t v151 = a1;
    __int16 v152 = 1024;
    unsigned int v153 = v105;
    __int16 v154 = 1024;
    *(_DWORD *)os_log_type_t v155 = v106;
    BOOL v61 = "%{public}s %{public}s%s%p Received remote address 0x%x != 0x%x";
    BOOL v62 = v104;
    uint32_t v63 = 54;
    goto LABEL_88;
  }

  return result;
}

          uint64_t v88 = v70;
          os_log_type_t v89 = v50[9];

          if (v89)
          {
            if (!data) {
              goto LABEL_138;
            }
            __int16 v90 = data;
            os_log_type_t v91 = dispatch_data_get_size(data);
            goto LABEL_137;
          }

          else {
            os_log_type_t v91 = v83;
          }
          if (data)
          {
            __int16 v90 = data;
LABEL_137:
            applier[0] = MEMORY[0x1895F87A8];
            applier[1] = 3221225472LL;
            applier[2] = ___ZL29nw_flow_prepare_output_framesP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sjP30nw_protocol_message_properties_block_invoke;
            applier[3] = &unk_189BB8500;
            v333 = v91;
            applier[4] = &v321;
            applier[5] = v47;
            applier[6] = v86;
            dispatch_data_apply(v90, applier);
          }

                if (v47) {
                  free(v47);
                }
LABEL_89:
                int v46 = *(void **)(*(void *)&buf[8] + 24LL);
                if (v46)
                {
                  os_release(v46);
                  *(void *)(*(void *)&buf[8] + 24LL) = 0LL;
                }

                goto LABEL_108;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              unsigned int v20 = (os_log_s *)gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "remove_input_handler";
                _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s nw_hash_table_remove_node failed",  buf,  0xCu);
              }

              goto LABEL_36;
            }

                  return;
                }

                if (v44)
                {
                  *(_DWORD *)buf = 136446466;
                  uint64_t v141 = "nw_protocol_implementation_disconnect";
                  os_log_type_t v142 = 2048;
                  v143 = a2;
                  _os_log_impl( &dword_181A5C000,  v17,  v43,  "%{public}s Output handler context doesn't exist on protocol %p, no backtrace",  buf,  0x16u);
                }
              }

              else
              {
                __nwlog_obj();
                __int32 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                uint32_t v63 = type[0];
                if (os_log_type_enabled(v17, type[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  uint64_t v141 = "nw_protocol_implementation_disconnect";
                  os_log_type_t v142 = 2048;
                  v143 = a2;
                  _os_log_impl( &dword_181A5C000,  v17,  v63,  "%{public}s Output handler context doesn't exist on protocol %p, backtrace limit exceeded",  buf,  0x16u);
                }
              }

              goto LABEL_138;
            }

            __nwlog_obj();
            unsigned int v122 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            uint64_t v141 = "__nw_protocol_get_output_handler_context";
            unsigned int v123 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v136) = 0;
            if (__nwlog_fault(v123, type, &v136))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                uint64_t v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v125 = type[0];
                if (os_log_type_enabled(v124, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  uint64_t v141 = "__nw_protocol_get_output_handler_context";
                  _os_log_impl(&dword_181A5C000, v124, v125, "%{public}s called with null protocol", buf, 0xCu);
                }
              }

              else if ((_BYTE)v136)
              {
                BOOL v129 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                uint64_t v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                int64x2_t v130 = type[0];
                uint64_t v131 = os_log_type_enabled(v124, type[0]);
                if (v129)
                {
                  if (v131)
                  {
                    *(_DWORD *)buf = 136446466;
                    uint64_t v141 = "__nw_protocol_get_output_handler_context";
                    os_log_type_t v142 = 2082;
                    v143 = (nw_protocol *)v129;
                    _os_log_impl( &dword_181A5C000,  v124,  v130,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v129);
                  goto LABEL_315;
                }

                if (v131)
                {
                  *(_DWORD *)buf = 136446210;
                  uint64_t v141 = "__nw_protocol_get_output_handler_context";
                  _os_log_impl( &dword_181A5C000,  v124,  v130,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                uint64_t v124 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                int64x2_t v133 = type[0];
                if (os_log_type_enabled(v124, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  uint64_t v141 = "__nw_protocol_get_output_handler_context";
                  _os_log_impl( &dword_181A5C000,  v124,  v133,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
                }
              }
            }

  if (v24) {
    free(v24);
  }
}

    goto LABEL_130;
  }

  id v6 = nw_parameters_create();
  if (v6)
  {
    os_log_type_t v7 = (void *)nw_protocol_boringssl_copy_definition();
    options = nw_protocol_create_options(v7);

    if (options)
    {
      if (nw_parameters_add_protocol_stack_member(v6, 4, 0, options))
      {

LABEL_11:
        char v9 = nw_protocol_create_options((void *)g_udp_definition);
        if (v9)
        {
          if (nw_parameters_add_protocol_stack_member(v6, 3, 0, v9))
          {
            *((_BYTE *)v6 + 92) = 1;
            BOOL v10 = v6;
            goto LABEL_78;
          }

                      free(v55);
                      goto LABEL_130;
                    }

                    __nwlog_obj();
                    unsigned int v123 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 136446210;
                    __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                    uint64_t v124 = (char *)_os_log_send_and_compose_impl();

                    os_log_type_t type = OS_LOG_TYPE_ERROR;
                    char v147 = 0;
                    if (__nwlog_fault(v124, &type, &v147))
                    {
                      if (type == OS_LOG_TYPE_FAULT)
                      {
                        __nwlog_obj();
                        v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        unsigned int v126 = type;
                        if (os_log_type_enabled(v125, type))
                        {
                          *(_DWORD *)buf = 136446210;
                          __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                          _os_log_impl(&dword_181A5C000, v125, v126, "%{public}s called with null stack", buf, 0xCu);
                        }
                      }

                      else
                      {
                        if (v147)
                        {
                          int64x2_t v134 = (char *)__nw_create_backtrace_string();
                          __nwlog_obj();
                          uint32x4_t v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          unsigned int v136 = type;
                          os_log_type_t v137 = os_log_type_enabled(v135, type);
                          if (v134)
                          {
                            if (v137)
                            {
                              *(_DWORD *)buf = 136446466;
                              __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                              uint64_t v151 = 2082;
                              __int16 v152 = v134;
                              _os_log_impl( &dword_181A5C000,  v135,  v136,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
                            }

                            free(v134);
                          }

                          else
                          {
                            if (v137)
                            {
                              *(_DWORD *)buf = 136446210;
                              __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                              _os_log_impl( &dword_181A5C000,  v135,  v136,  "%{public}s called with null stack, no backtrace",  buf,  0xCu);
                            }
                          }

                          goto LABEL_288;
                        }

                        __nwlog_obj();
                        v125 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        v138 = type;
                        if (os_log_type_enabled(v125, type))
                        {
                          *(_DWORD *)buf = 136446210;
                          __int16 v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                          _os_log_impl( &dword_181A5C000,  v125,  v138,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
                        }
                      }
                    }

                xpc_dictionary_set_BOOL(v2, "never_open_listener_socket", 1);
                BOOL v35 = *((void *)v1 + 12);
                if ((v35 & 0x20000000) == 0)
                {
LABEL_94:
                  if ((v35 & 0x40000000) == 0) {
                    goto LABEL_96;
                  }
                  goto LABEL_95;
                }

            if ((*((_BYTE *)v14 + 98) & 1) == 0 || (*((_BYTE *)v14 + 97) & 1) != 0) {
              goto LABEL_153;
            }
            goto LABEL_131;
          }

          int v58 = nw_proxy_config_copy(*((void **)v165 + 5));
          int v59 = (void *)*((void *)v165 + 5);
          *((void *)v165 + 5) = v58;

          uint64_t v15 = 2002;
          nw_proxy_config_set_type(*((void **)v165 + 5), 2002);
        }

        else
        {
          uint64_t v15 = 4001;
        }

        int v60 = nw_endpoint_handler_get_minimize_logging(v11);
        BOOL v61 = nw_endpoint_handler_get_logging_disabled(v11);
        if (v60)
        {
          v148 = v14;
          if ((v61 & 1) != 0)
          {
            if (v15 == 4001) {
              goto LABEL_129;
            }
LABEL_49:
            if (v15 != 2002)
            {
              goto LABEL_131;
            }

            goto LABEL_129;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v101 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
          {
            v140 = nw_endpoint_handler_get_id_string(v11);
            uint32_t v102 = nw_endpoint_handler_dry_run_string(v11);
            os_log_t loga = nw_endpoint_handler_copy_endpoint(v11);
            unsigned int v103 = nw_endpoint_get_logging_description(loga);
            os_log_type_t v104 = nw_endpoint_handler_state_string(v11);
            __int32 v105 = nw_endpoint_handler_mode_string(v11);
            int v106 = nw_endpoint_handler_copy_current_path(v11);
            BOOL v107 = v106;
            *(_DWORD *)buf = 136448002;
            v173 = "nw_endpoint_proxy_add_config_if_applicable";
            uint64_t v108 = "not ";
            v175 = (void *)v140;
            BOOL v174 = 2082;
            if (v17) {
              uint64_t v108 = "";
            }
            v176 = 2082;
            os_log_type_t v177 = v102;
            v178 = 2082;
            v179 = v103;
            BOOL v180 = 2082;
            v181 = v104;
            BOOL v182 = 2082;
            char v183 = v105;
            uint64_t v184 = 2114;
            v185 = v106;
            v186 = 2082;
            char v187 = v108;
            BOOL v62 = v101;
            _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] HTTP Connect proxies are %{public}sopaque",  buf,  0x52u);

            unsigned int v14 = v148;
          }

          else
          {
            BOOL v62 = v101;
          }
        }

        else
        {
          if ((v61 & 1) != 0) {
            goto LABEL_48;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v62 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
          {
            __int16 v146 = v14;
            uint32_t v63 = nw_endpoint_handler_get_id_string(v11);
            uint64_t v64 = nw_endpoint_handler_dry_run_string(v11);
            os_log_t log = v62;
            int v139 = nw_endpoint_handler_copy_endpoint(v11);
            int v65 = nw_endpoint_get_logging_description(v139);
            uint64_t v66 = nw_endpoint_handler_state_string(v11);
            BOOL v67 = nw_endpoint_handler_mode_string(v11);
            uint64_t v68 = nw_endpoint_handler_copy_current_path(v11);
            os_log_type_t v69 = v68;
            *(_DWORD *)buf = 136448002;
            v173 = "nw_endpoint_proxy_add_config_if_applicable";
            __int16 v70 = "not ";
            v175 = (void *)v63;
            BOOL v174 = 2082;
            if (v17) {
              __int16 v70 = "";
            }
            v176 = 2082;
            os_log_type_t v177 = v64;
            v178 = 2082;
            v179 = v65;
            BOOL v180 = 2082;
            v181 = v66;
            BOOL v182 = 2082;
            char v183 = v67;
            uint64_t v184 = 2114;
            v185 = v68;
            v186 = 2082;
            char v187 = v70;
            BOOL v62 = log;
            _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] HTTP Connect proxies are %{public}sopaque",  buf,  0x52u);

            unsigned int v14 = v146;
          }
        }
      }

    _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
    goto LABEL_130;
  }

  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        char v9 = *((void *)handle + 11);
        if (v9) {
          BOOL v10 = *(_DWORD *)(v9 + 460);
        }
        else {
          BOOL v10 = -1;
        }
        uint64_t v43 = *((void *)handle + 8);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447746;
        BOOL v101 = "nw_protocol_webtransport_http3_stream_connected";
        uint32_t v102 = 2082;
        unsigned int v103 = (char *)(handle + 192);
        os_log_type_t v104 = 2080;
        __int32 v105 = " ";
        int v106 = 1024;
        BOOL v107 = v10;
        uint64_t v108 = 2048;
        BOOL v109 = v43;
        uint64_t v110 = 2048;
        uint64_t v111 = a2;
        BOOL v112 = 2080;
        os_log_type_t v113 = identifier;
        int v45 = "%{public}s %{public}s%s<i%u:s%lld> connected protocol %p (%s) is not our output_handler, ignoring";
        int v46 = v8;
        __int16 v47 = OS_LOG_TYPE_DEBUG;
        uint64_t v48 = 68;
        goto LABEL_178;
      }
    }
  }

      if (v32) {
        free(v32);
      }
      unint64_t v75 = *(void *)(a2 + 16);
      unint64_t v76 = *(void **)(a2 + 24);
      if (v75)
      {
        *(void *)(v75 + 24) = v76;
        unint64_t v76 = *(void **)(a2 + 24);
      }

      else
      {
        *(void *)(*(void *)(a1 + 40) + 168LL) = v76;
      }

      const void *v76 = v75;
      *(void *)(a2 + 16) = 0LL;
      *(void *)(a2 + 24) = 0LL;
      __int32 v57 = *(void *)(a1 + 40);
      int v58 = *(_DWORD *)(v57 + 192);
      if (v58)
      {
LABEL_135:
        *(_DWORD *)(v57 + 192) = v58 - 1;
LABEL_160:
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(a2, *(void *)(a2 + 88)))
        {
          int32x4_t v81 = *(void **)(a2 + 112);
          if (v81) {
            free(v81);
          }
        }

        nw_frame_reset(a2, 0LL, 0, 0LL, 0LL);
        os_release((void *)a2);
        return 1LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "http2_transport_create_input_frame_block_invoke";
      int v59 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint64_t v98 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v60 = (os_log_s *)gLogObj;
        BOOL v61 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_158;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "http2_transport_create_input_frame_block_invoke";
        BOOL v62 = "%{public}s http2_transport count attempted to decrement below zero";
        goto LABEL_157;
      }

      if (!v98)
      {
        int v60 = (os_log_s *)__nwlog_obj();
        BOOL v61 = type;
        if (!os_log_type_enabled(v60, type)) {
          goto LABEL_158;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "http2_transport_create_input_frame_block_invoke";
        BOOL v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
        goto LABEL_157;
      }

      int v77 = (char *)__nw_create_backtrace_string();
      int v60 = (os_log_s *)__nwlog_obj();
      BOOL v61 = type;
      uint64_t v78 = os_log_type_enabled(v60, type);
      if (v77)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_input_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = v77;
          _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v77);
        if (!v59) {
          goto LABEL_160;
        }
        goto LABEL_159;
      }

      if (v78)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "http2_transport_create_input_frame_block_invoke";
        BOOL v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_157:
        _os_log_impl(&dword_181A5C000, v60, v61, v62, buf, 0xCu);
        goto LABEL_158;
      }

      goto LABEL_158;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v18 = *(void *)(a1 + 40);
    if (v18) {
      int v19 = (const char *)(v18 + 205);
    }
    else {
      int v19 = "";
    }
    *(_DWORD *)buf = 136446466;
    BOOL v101 = "http2_transport_create_input_frame_block_invoke";
    uint32_t v102 = 2082;
    unsigned int v103 = (void *)v19;
    unsigned int v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v98 = 0;
    if (__nwlog_fault(v20, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)gLogObj;
        unsigned int v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v23 = *(void *)(a1 + 40);
          if (v23) {
            os_log_type_t v24 = (const char *)(v23 + 205);
          }
          else {
            os_log_type_t v24 = "";
          }
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_input_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = (void *)v24;
          os_log_type_t v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying";
LABEL_93:
          _os_log_impl(&dword_181A5C000, v21, v22, v25, buf, 0x16u);
        }
      }

      else if (v98)
      {
        os_log_type_t v38 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)gLogObj;
        unsigned int v22 = type;
        os_log_type_t v39 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v38)
        {
          if (v39)
          {
            int v40 = *(void *)(a1 + 40);
            if (v40) {
              os_log_type_t v41 = (const char *)(v40 + 205);
            }
            else {
              os_log_type_t v41 = "";
            }
            *(_DWORD *)buf = 136446722;
            BOOL v101 = "http2_transport_create_input_frame_block_invoke";
            uint32_t v102 = 2082;
            unsigned int v103 = (void *)v41;
            os_log_type_t v104 = 2082;
            *(void *)__int32 v105 = v38;
            _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v38);
          goto LABEL_94;
        }

        if (v39)
        {
          char v53 = *(void *)(a1 + 40);
          if (v53) {
            uint64_t v54 = (const char *)(v53 + 205);
          }
          else {
            uint64_t v54 = "";
          }
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_input_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = (void *)v54;
          os_log_type_t v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, no backtrace";
          goto LABEL_93;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)gLogObj;
        unsigned int v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v48 = *(void *)(a1 + 40);
          if (v48) {
            uint64_t v49 = (const char *)(v48 + 205);
          }
          else {
            uint64_t v49 = "";
          }
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_input_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = (void *)v49;
          os_log_type_t v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, backtrace limit exceeded";
          goto LABEL_93;
        }
      }
    }

      if (v32) {
        free(v32);
      }
      unint64_t v75 = *(void *)(a2 + 16);
      unint64_t v76 = *(void **)(a2 + 24);
      if (v75)
      {
        *(void *)(v75 + 24) = v76;
        unint64_t v76 = *(void **)(a2 + 24);
      }

      else
      {
        *(void *)(*(void *)(a1 + 40) + 184LL) = v76;
      }

      const void *v76 = v75;
      *(void *)(a2 + 16) = 0LL;
      *(void *)(a2 + 24) = 0LL;
      __int32 v57 = *(void *)(a1 + 40);
      int v58 = *(_DWORD *)(v57 + 196);
      if (v58)
      {
LABEL_135:
        *(_DWORD *)(v57 + 196) = v58 - 1;
LABEL_160:
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(a2, *(void *)(a2 + 88)))
        {
          int32x4_t v81 = *(void **)(a2 + 112);
          if (v81) {
            free(v81);
          }
        }

        nw_frame_reset(a2, 0LL, 0, 0LL, 0LL);
        os_release((void *)a2);
        return 1LL;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      BOOL v101 = "http2_transport_create_output_frame_block_invoke";
      int v59 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint64_t v98 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v60 = (os_log_s *)gLogObj;
        BOOL v61 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_158;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "http2_transport_create_output_frame_block_invoke";
        BOOL v62 = "%{public}s http2_transport count attempted to decrement below zero";
        goto LABEL_157;
      }

      if (!v98)
      {
        int v60 = (os_log_s *)__nwlog_obj();
        BOOL v61 = type;
        if (!os_log_type_enabled(v60, type)) {
          goto LABEL_158;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "http2_transport_create_output_frame_block_invoke";
        BOOL v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
        goto LABEL_157;
      }

      int v77 = (char *)__nw_create_backtrace_string();
      int v60 = (os_log_s *)__nwlog_obj();
      BOOL v61 = type;
      uint64_t v78 = os_log_type_enabled(v60, type);
      if (v77)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_output_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = v77;
          _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v77);
        if (!v59) {
          goto LABEL_160;
        }
        goto LABEL_159;
      }

      if (v78)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v101 = "http2_transport_create_output_frame_block_invoke";
        BOOL v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_157:
        _os_log_impl(&dword_181A5C000, v60, v61, v62, buf, 0xCu);
        goto LABEL_158;
      }

      goto LABEL_158;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v18 = *(void *)(a1 + 40);
    if (v18) {
      int v19 = (const char *)(v18 + 205);
    }
    else {
      int v19 = "";
    }
    *(_DWORD *)buf = 136446466;
    BOOL v101 = "http2_transport_create_output_frame_block_invoke";
    uint32_t v102 = 2082;
    unsigned int v103 = (void *)v19;
    unsigned int v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v98 = 0;
    if (__nwlog_fault(v20, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)gLogObj;
        unsigned int v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v23 = *(void *)(a1 + 40);
          if (v23) {
            os_log_type_t v24 = (const char *)(v23 + 205);
          }
          else {
            os_log_type_t v24 = "";
          }
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_output_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = (void *)v24;
          os_log_type_t v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying";
LABEL_93:
          _os_log_impl(&dword_181A5C000, v21, v22, v25, buf, 0x16u);
        }
      }

      else if (v98)
      {
        os_log_type_t v38 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)gLogObj;
        unsigned int v22 = type;
        os_log_type_t v39 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v38)
        {
          if (v39)
          {
            int v40 = *(void *)(a1 + 40);
            if (v40) {
              os_log_type_t v41 = (const char *)(v40 + 205);
            }
            else {
              os_log_type_t v41 = "";
            }
            *(_DWORD *)buf = 136446722;
            BOOL v101 = "http2_transport_create_output_frame_block_invoke";
            uint32_t v102 = 2082;
            unsigned int v103 = (void *)v41;
            os_log_type_t v104 = 2082;
            *(void *)__int32 v105 = v38;
            _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v38);
          goto LABEL_94;
        }

        if (v39)
        {
          char v53 = *(void *)(a1 + 40);
          if (v53) {
            uint64_t v54 = (const char *)(v53 + 205);
          }
          else {
            uint64_t v54 = "";
          }
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_output_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = (void *)v54;
          os_log_type_t v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, no backtrace";
          goto LABEL_93;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = (os_log_s *)gLogObj;
        unsigned int v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v48 = *(void *)(a1 + 40);
          if (v48) {
            uint64_t v49 = (const char *)(v48 + 205);
          }
          else {
            uint64_t v49 = "";
          }
          *(_DWORD *)buf = 136446466;
          BOOL v101 = "http2_transport_create_output_frame_block_invoke";
          uint32_t v102 = 2082;
          unsigned int v103 = (void *)v49;
          os_log_type_t v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, backtrace limit exceeded";
          goto LABEL_93;
        }
      }
    }

                int32x4_t v81 = MEMORY[0x1895F87A8];
                *(void *)buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 0x40000000LL;
                *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_39716;
                v1051 = (uint64_t)&__block_descriptor_tmp_55_39717;
                *(void *)v1052 = v16 + 616;
                v1052[8] = 0;
                uint64_t v82 = *(void *)(v16 + 616);
                do
                {
                  if (!v82) {
                    break;
                  }
                  int32x4_t v83 = *(void *)(v82 + 32);
                  int32x4_t v84 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                  uint64_t v82 = v83;
                }

                while ((v84 & 1) != 0);
                if ((*(_BYTE *)(v16 + 158) & 1) == 0)
                {
                  if (!gLogDatapath) {
                    goto LABEL_134;
                  }
                  v599 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v599, OS_LOG_TYPE_DEBUG))
                  {
                    v600 = *(void *)(v16 + 488);
                    v601 = *(_DWORD *)(*(void *)(v16 + 480) + 372LL);
                    v602 = *(_DWORD *)(v16 + 860);
                    if (v600) {
                      LODWORD(v600) = *(_DWORD *)(v600 + 424);
                    }
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = "nw_http1_tear_down_connection";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v16 + 74;
                    *(_WORD *)&buf[22] = 2080;
                    v1051 = (uint64_t)" ";
                    *(_WORD *)v1052 = 1024;
                    *(_DWORD *)&v1052[2] = v601;
                    *(_WORD *)&v1052[6] = 1024;
                    *(_DWORD *)&v1052[8] = v602;
                    *(_WORD *)&v1052[12] = 1024;
                    *(_DWORD *)&v1052[14] = v600;
                    _os_log_impl( &dword_181A5C000,  v599,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> finalizing processed_input_frames",  buf,  0x32u);
                    int v11 = v1042;
                    uint64_t v15 = &qword_18C45F000;
                  }
                }

                if (gLogDatapath)
                {
                  v603 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v603, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)v1065 = 136446210;
                    *(void *)&v1065[4] = "nw_protocol_finalize_temp_frame_array";
                    _os_log_impl(&dword_181A5C000, v603, OS_LOG_TYPE_DEBUG, "%{public}s called", v1065, 0xCu);
                  }
                }

    goto LABEL_130;
  }

  cached_content_for_protocol = (unsigned int *)nw_association_get_cached_content_for_protocol(v5, v6);
  if (cached_content_for_protocol || (cached_content_for_protocol = (unsigned int *)calloc(1uLL, 0x30uLL)) != 0LL)
  {
    if (a2)
    {
      BOOL v8 = cached_content_for_protocol[6] + 1LL;
      char v9 = v8 << 31 >> 31;
      cached_content_for_protocol[6] = v8;
      if (v9 == v8 && (v9 & 0x8000000000000000LL) == 0) {
        goto LABEL_75;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (id)gLogObj;
      int v11 = cached_content_for_protocol[6];
      *(_DWORD *)buf = 136446978;
      uint16x8_t v86 = "nw_quic_report_race_result_on_queue";
      int v87 = 2082;
      uint64_t v88 = "association_cache->success_count";
      os_log_type_t v89 = 2048;
      __int16 v90 = 1LL;
      os_log_type_t v91 = 2048;
      os_log_type_t v92 = v11;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      int32x4_t v83 = 0;
      if (__nwlog_fault(v12, &type, &v83))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v13 = (os_log_s *)(id)gLogObj;
          unsigned int v14 = type;
          if (os_log_type_enabled(v13, type))
          {
            uint64_t v15 = cached_content_for_protocol[6];
            *(_DWORD *)buf = 136446978;
            uint16x8_t v86 = "nw_quic_report_race_result_on_queue";
            int v87 = 2082;
            uint64_t v88 = "association_cache->success_count";
            os_log_type_t v89 = 2048;
            __int16 v90 = 1LL;
            os_log_type_t v91 = 2048;
            os_log_type_t v92 = v15;
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
          }
        }

        else if (v83)
        {
          uint64_t v32 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v13 = (os_log_s *)(id)gLogObj;
          __int128 v33 = type;
          uint64_t v34 = os_log_type_enabled(v13, type);
          if (v32)
          {
            if (v34)
            {
              BOOL v35 = cached_content_for_protocol[6];
              *(_DWORD *)buf = 136447234;
              uint16x8_t v86 = "nw_quic_report_race_result_on_queue";
              int v87 = 2082;
              uint64_t v88 = "association_cache->success_count";
              os_log_type_t v89 = 2048;
              __int16 v90 = 1LL;
              os_log_type_t v91 = 2048;
              os_log_type_t v92 = v35;
              v93 = 2082;
              os_log_type_t v94 = v32;
              _os_log_impl( &dword_181A5C000,  v13,  v33,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v32);
            if (!v12) {
              goto LABEL_56;
            }
            goto LABEL_55;
          }

          if (v34)
          {
            uint64_t v48 = cached_content_for_protocol[6];
            *(_DWORD *)buf = 136446978;
            uint16x8_t v86 = "nw_quic_report_race_result_on_queue";
            int v87 = 2082;
            uint64_t v88 = "association_cache->success_count";
            os_log_type_t v89 = 2048;
            __int16 v90 = 1LL;
            os_log_type_t v91 = 2048;
            os_log_type_t v92 = v48;
            _os_log_impl( &dword_181A5C000,  v13,  v33,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace",  buf,  0x2Au);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v13 = (os_log_s *)(id)gLogObj;
          int v46 = type;
          if (os_log_type_enabled(v13, type))
          {
            __int16 v47 = cached_content_for_protocol[6];
            *(_DWORD *)buf = 136446978;
            uint16x8_t v86 = "nw_quic_report_race_result_on_queue";
            int v87 = 2082;
            uint64_t v88 = "association_cache->success_count";
            os_log_type_t v89 = 2048;
            __int16 v90 = 1LL;
            os_log_type_t v91 = 2048;
            os_log_type_t v92 = v47;
            _os_log_impl( &dword_181A5C000,  v13,  v46,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded",  buf,  0x2Au);
          }
        }
      }

      if (!v12)
      {
LABEL_56:
        cached_content_for_protocol[6] = -1;
LABEL_75:
        int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_quic_failure_cache_seconds,  1800LL);
        int v58 = time(0LL);
        nw_association_set_cached_content_for_protocol( v5,  v6,  (uint64_t)cached_content_for_protocol,  v58 + int64_with_default);
LABEL_76:

LABEL_77:
        return;
      }

  if (v47) {
    free(v47);
  }
  BOOL v10 = 0LL;
LABEL_82:

  return v10;
}

        _os_log_impl(&dword_181A5C000, v78, v79, v80, buf, 0x16u);
        goto LABEL_130;
      }

      v43(v41, v37);
    }

    _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
    goto LABEL_130;
  }

  handle = a1->handle;
  if (handle == &nw_protocol_ref_counted_handle) {
    p_output_handler = &a1[1].output_handler;
  }
  else {
    p_output_handler = 0LL;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v71 = "nw_socket_get_output_frames";
    uint64_t v56 = (char *)_os_log_send_and_compose_impl();
    v69[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v6_Block_object_dispose(va, 8) = 0;
    if (__nwlog_fault(v56, v69, &v68))
    {
      if (v69[0] == OS_LOG_TYPE_FAULT)
      {
        char v53 = (os_log_s *)__nwlog_obj();
        uint64_t v54 = v69[0];
        if (!os_log_type_enabled(v53, v69[0])) {
          goto LABEL_130;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v71 = "nw_socket_get_output_frames";
        uint64_t v55 = "%{public}s called with null socket_handler";
      }

      else if ((_BYTE)v68)
      {
        int v60 = (char *)__nw_create_backtrace_string();
        char v53 = (os_log_s *)__nwlog_obj();
        uint64_t v54 = v69[0];
        BOOL v61 = os_log_type_enabled(v53, v69[0]);
        if (v60)
        {
          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            unsigned int v71 = "nw_socket_get_output_frames";
            uint32_t v72 = 2082;
            *(void *)unsigned int v73 = v60;
            _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null socket_handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v60);
          if (!v56) {
            return 0LL;
          }
          goto LABEL_131;
        }

        if (!v61) {
          goto LABEL_130;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v71 = "nw_socket_get_output_frames";
        uint64_t v55 = "%{public}s called with null socket_handler, no backtrace";
      }

      else
      {
        char v53 = (os_log_s *)__nwlog_obj();
        uint64_t v54 = v69[0];
        if (!os_log_type_enabled(v53, v69[0])) {
          goto LABEL_130;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v71 = "nw_socket_get_output_frames";
        uint64_t v55 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      }

      goto LABEL_129;
    }

      if (v19) {
        free(v19);
      }
      return 0LL;
    }

    if (!v41)
    {
      unsigned int v20 = (os_log_s *)__nwlog_obj();
      int v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        unsigned int v22 = "%{public}s called with null (request_length > tag_length), backtrace limit exceeded";
        goto LABEL_128;
      }

      goto LABEL_129;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v20 = (os_log_s *)__nwlog_obj();
    int v21 = type;
    int v40 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
        unsigned int v22 = "%{public}s called with null (request_length > tag_length), no backtrace";
        goto LABEL_128;
      }

      goto LABEL_129;
    }

    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v44 = "nw_http_decrypt_chunked_oblivious_request_chunk";
      int v45 = 2082;
      int v46 = (uint64_t)backtrace_string;
      __int128 v33 = "%{public}s called with null (request_length > tag_length), dumping backtrace:%{public}s";
      goto LABEL_94;
    }
          }

          if (!v44) {
            goto LABEL_132;
          }
          goto LABEL_131;
        }

        os_log_type_t v36 = (_DWORD)v22 == 16 && v28 != 0LL && v21 == 1;
        v18 += v22 + 5;
        if (v36)
        {
          *(_OWORD *)__int128 uu = *(_OWORD *)v28;
          os_unfair_lock_lock(lock);
          if (*(void *)globals_for_path == *(void *)uu && *(void *)(globals_for_path + 8) == *(void *)&uu[8])
          {
            os_log_type_t v37 = *(void *)(globals_for_path + 48);
            os_log_type_t v38 = (unsigned __int8 *)nw_array_create();
            os_log_type_t v39 = v38;
            if (v37)
            {
              else {
                std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( (uint64_t)(v38 + 16),  *(void ***)(v37 + 16),  *(void ***)(v37 + 24),  (uint64_t)(*(void *)(v37 + 24) - *(void *)(v37 + 16)) >> 3);
              }
            }

            os_unfair_lock_unlock(lock);
            *(void *)buf = 0LL;
            *(void *)&buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000LL;
            LOBYTE(v153) = 1;
            v146[0] = MEMORY[0x1895F87A8];
            v146[1] = 3221225472LL;
            v146[2] = ___ZL30nw_path_necp_check_for_updatesPU24objcproto13OS_nw_context8NSObjectPA16_hj_block_invoke_2;
            v146[3] = &unk_189BC5588;
            v146[5] = uu;
            v146[6] = v145;
            char v147 = v6;
            v146[4] = buf;
            nw_array_apply(v39, (uint64_t)v146);
            _Block_object_dispose(buf, 8);
          }

          else if (*(void *)(globals_for_path + 32))
          {
            uuid_unparse(uu, buf);
            __int16 v47 = nw_dictionary_copy_value(*(void *)(globals_for_path + 32), (uint64_t)buf);
            uint64_t v48 = v47;
            if (v47 && v47[10] == *(void *)uu && v47[11] == *(void *)&uu[8])
            {
              uint64_t v49 = v47;
              os_unfair_lock_unlock(lock);
              nw_path_necp_update_evaluator(v49, v145, v6, 1);
            }

            else
            {
              os_unfair_lock_unlock(lock);
              uint64_t v49 = 0LL;
            }
          }

          else
          {
            os_unfair_lock_unlock(lock);
          }

          goto LABEL_198;
        }
      }
    }

    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    BOOL v10 = **(_DWORD **)(StatusReg + 8);
    if (v137 < 5 || v10 != 22) {
      goto LABEL_14;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_necp_check_for_updates";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v137;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s Trying to copy result again for %u flows",  buf,  0x12u);
    }

    if (!(_DWORD)__size)
    {
      __nwlog_obj();
      BOOL v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v114, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "strict_calloc";
      BOOL v115 = (void *)_os_log_send_and_compose_impl();

      free(v115);
    }

    os_log_type_t v7 = (char *)calloc(1uLL, __size);
    if (!v7)
    {
      __nwlog_obj();
      BOOL v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v116, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "strict_calloc";
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = 1LL;
      *(_WORD *)&buf[22] = 2048;
      unsigned int v153 = __size;
      uint64_t v117 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v117))
      {
LABEL_292:
        __break(1u);
        return;
      }

      free(v117);
      os_log_type_t v7 = 0LL;
    }

    nw_path_shared_necp_fd(v141);
    id v6 = necp_client_action();
LABEL_19:
    BOOL v8 = (unsigned __int8 *)v7;
    if (v7) {
      goto LABEL_20;
    }
    __nwlog_obj();
    uint32_t v99 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_parse_necp_client_id";
    BOOL v100 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v148 = 0;
    if (__nwlog_fault(v100, &type, &v148))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint32_t v102 = type;
        if (os_log_type_enabled(v101, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_parse_necp_client_id";
          _os_log_impl(&dword_181A5C000, v101, v102, "%{public}s called with null result", buf, 0xCu);
        }

        BOOL v62 = *(void *)(v10 + 32);
        uint32_t v63 = v62 == v21 || v62 == 0;
        int v11 = 1;
        if (v63 && v62 != v26)
        {
          if (v62)
          {
            if (*(_UNKNOWN **)(v62 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v66 = *(void *)(v62 + 88);
              if (v66)
              {
                BOOL v67 = v66 - 1;
                *(void *)(v62 + 8_Block_object_dispose(va, 8) = v67;
                if (!v67)
                {
                  uint64_t v68 = *(void (***)(void))(v62 + 64);
                  if (v68)
                  {
                    *(void *)(v62 + 64) = 0LL;
                    v68[2](v68);
                    _Block_release(v68);
                  }

                  if ((*(_BYTE *)(v62 + 72) & 1) != 0)
                  {
                    os_log_type_t v69 = *(const void **)(v62 + 64);
                    if (v69) {
                      _Block_release(v69);
                    }
                  }

                  free((void *)v62);
                }
              }
            }
          }

          *(void *)(v10 + 32) = v26;
          if (*(_UNKNOWN **)(v26 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v64 = *(void *)(v26 + 88);
            if (v64) {
              *(void *)(v26 + 8_Block_object_dispose(va, 8) = v64 + 1;
            }
          }
        }

  if (v95) {
    free(v95);
  }
  unsigned int v20 = 0;
  if (v16 == &nw_protocol_ref_counted_handle)
  {
LABEL_14:
    if ((_UNKNOWN *)*(a3 - 7) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v42 = *(a3 - 1);
      if (v42)
      {
        uint64_t v43 = v42 - 1;
        *(a3 - 1) = v43;
        if (!v43)
        {
          BOOL v44 = (void (**)(void))*(a3 - 4);
          if (v44)
          {
            *(a3 - 4) = 0LL;
            v44[2](v44);
            _Block_release(v44);
          }

          if ((*(_BYTE *)(a3 - 3) & 1) != 0)
          {
            int v45 = (const void *)*(a3 - 4);
            if (v45) {
              _Block_release(v45);
            }
          }

          free(a3 - 12);
        }
      }
    }
  }

      if (v79) {
        free(v79);
      }
      uint64_t v15 = 0LL;
LABEL_10:

      if (v15)
      {
        int v29 = v15;
LABEL_31:

        goto LABEL_32;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v30 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
      char v31 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(aBlock.receiver) = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if ((__nwlog_fault(v31, &aBlock, type) & 1) != 0)
      {
        if (LOBYTE(aBlock.receiver) == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v32 = (os_log_s *)(id)gLogObj;
          __int128 v33 = (os_log_type_t)aBlock.receiver;
          if (os_log_type_enabled(v32, (os_log_type_t)aBlock.receiver))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
            _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed",  buf,  0xCu);
          }
        }

        else if (type[0])
        {
          uint64_t v34 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v32 = (os_log_s *)(id)gLogObj;
          BOOL v35 = (os_log_type_t)aBlock.receiver;
          os_log_type_t v36 = os_log_type_enabled(v32, (os_log_type_t)aBlock.receiver);
          if (v34)
          {
            if (v36)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v34;
              _os_log_impl( &dword_181A5C000,  v32,  v35,  "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v34);
            if (!v31) {
              goto LABEL_31;
            }
            goto LABEL_30;
          }

          if (v36)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
            _os_log_impl( &dword_181A5C000,  v32,  v35,  "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v32 = (os_log_s *)(id)gLogObj;
          os_log_type_t v37 = (os_log_type_t)aBlock.receiver;
          if (os_log_type_enabled(v32, (os_log_type_t)aBlock.receiver))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
            _os_log_impl( &dword_181A5C000,  v32,  v37,  "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v31) {
        goto LABEL_31;
      }
LABEL_30:
      free(v31);
      goto LABEL_31;
    }

    __nwlog_obj();
    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
    unint64_t v75 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock.receiver) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v75, &aBlock, type))
    {
      if (LOBYTE(aBlock.receiver) == 17)
      {
        __nwlog_obj();
        unint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v77 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v76, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
          _os_log_impl(&dword_181A5C000, v76, v77, "%{public}s called with null queue", buf, 0xCu);
        }
      }

      else if (type[0])
      {
        uint64_t v88 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v89 = (os_log_type_t)aBlock.receiver;
        __int16 v90 = os_log_type_enabled(v76, (os_log_type_t)aBlock.receiver);
        if (v88)
        {
          if (v90)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v88;
            _os_log_impl( &dword_181A5C000,  v76,  v89,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v88);
          goto LABEL_123;
        }

        if (v90)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
          _os_log_impl(&dword_181A5C000, v76, v89, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unint64_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v96 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v76, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_create";
          _os_log_impl( &dword_181A5C000,  v76,  v96,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_protocol_ipv4_process_reassembly(uint64_t a1, int a2, uint64_t a3, int a4, _BYTE *a5)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  uint64_t v8 = *(void *)(a1 + 64);
  if (!v8)
  {
    uint64_t v12 = 0LL;
    goto LABEL_85;
  }

  if (!a5 && *(unsigned __int16 *)(a1 + 132) == a2 && a4 == 0)
  {
    uint64_t v12 = 0LL;
LABEL_86:
    *(_WORD *)(a1 + 132) = a2;
    return v12;
  }

  if (!a3)
  {
    uint64_t v12 = 0LL;
    if (!a4) {
      goto LABEL_85;
    }
    goto LABEL_75;
  }

  uint64_t v87 = 0LL;
  uint64_t v88 = &v87;
  uint64_t v89 = 0x2000000000LL;
  char v90 = 0;
  uint64_t v83 = 0LL;
  int32x4_t v84 = &v83;
  uint64_t v85 = 0x2000000000LL;
  __int16 v86 = 0;
  uint64_t v13 = MEMORY[0x1895F87A8];
  v77[0] = MEMORY[0x1895F87A8];
  v77[1] = 0x40000000LL;
  uint64_t v78 = (uint64_t (*)(void *))___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke;
  int v79 = &unk_189BC8948;
  int32x4_t v81 = &v87;
  uint64_t v82 = a1;
  int v80 = &v83;
  do
  {
    if (!v8) {
      break;
    }
    uint64_t v14 = *(void *)(v8 + 32);
    char v15 = v78(v77);
    uint64_t v8 = v14;
  }

  while ((v15 & 1) != 0);
  if (*((_BYTE *)v88 + 24))
  {
    int v16 = *((unsigned __int16 *)v84 + 12) + 20;
    uint64_t v17 = nw_calloc_type<unsigned char>(*((unsigned __int16 *)v84 + 12) + 20LL);
    uint64_t v18 = nw_frame_create(0, v17, v16, (uint64_t)nw_protocol_ipv4_frame_input_finalizer, a1);
    if (v18)
    {
      uint64_t v19 = v18;
      if ((*(_BYTE *)(a1 + 136) & 1) == 0)
      {
        if (gLogDatapath)
        {
          uint64_t v54 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          {
            int v55 = *(unsigned __int16 *)(a1 + 132);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&_BYTE buf[24] = " ";
            LOWORD(v92) = 2048;
            *(void *)((char *)&v92 + 2) = a1;
            WORD5(v92) = 1024;
            HIDWORD(v92) = v55;
            *(_WORD *)v93 = 1024;
            *(_DWORD *)&v93[2] = v16;
            _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p Fragments for IP ID %u are complete, aggregate length %u",  buf,  0x36u);
          }
        }
      }

      uint64_t v20 = *(void *)(a1 + 64);
      unsigned int v76 = 0;
      uint64_t v21 = nw_frame_unclaimed_bytes(v20, &v76);
      if (!v21)
      {
        if ((*(_BYTE *)(a1 + 136) & 1) == 0)
        {
          uint64_t v56 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&_BYTE buf[24] = " ";
            LOWORD(v92) = 2048;
            *(void *)((char *)&v92 + 2) = a1;
            _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s%p Frame is no longer valid",  buf,  0x2Au);
          }
        }

        *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
        goto LABEL_115;
      }

      if (v76 > 0x13)
      {
        int v23 = *(_DWORD *)(v21 + 16);
        *(_OWORD *)uint64_t v17 = *(_OWORD *)v21;
        *(_DWORD *)(v17 + 16) = v23;
        *(_WORD *)(v17 + 2) = bswap32(v16) >> 16;
        *(_WORD *)(v17 + 6) = 0;
        if ((*(_WORD *)(v19 + 204) & 8) == 0)
        {
          uint64_t v24 = v19 + 120;
          os_log_type_t v25 = *(void **)(v19 + 168);
          if (v25)
          {
            os_release(v25);
            uint64_t v24 = v19 + 120;
            *(void *)(v19 + 16_Block_object_dispose(va, 8) = 0LL;
          }

          uint64_t v26 = *(void *)(v19 + 64);
          *(_BYTE *)(v19 + 186) |= 0x40u;
          if (v26)
          {
            if (v26 != v24)
            {
              uint64_t v27 = v24;
              __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v26;
              *(_WORD *)&buf[22] = 2048;
              uint64_t v67 = v27;
              *(void *)&_BYTE buf[24] = v27;
              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v74[0]) = 0;
              uint64_t v68 = (char *)_os_log_send_and_compose_impl();
              if (__nwlog_fault(v68, type, v74))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  __int8 v28 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v66 = type[0];
                  if (os_log_type_enabled(v28, type[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v26;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)&_BYTE buf[24] = v67;
                    int v29 = "%{public}s Existing metadata %p doesn't match expected %p";
LABEL_62:
                    os_log_type_t v38 = v28;
LABEL_63:
                    _os_log_impl(&dword_181A5C000, v38, v66, v29, buf, 0x20u);
                  }
                }

                else if (LOBYTE(v74[0]))
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  os_log_t log = (os_log_s *)__nwlog_obj();
                  os_log_type_t v66 = type[0];
                  BOOL v37 = os_log_type_enabled(log, type[0]);
                  if (backtrace_string)
                  {
                    if (v37)
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                      *(_WORD *)&_BYTE buf[12] = 2048;
                      *(void *)&buf[14] = v26;
                      *(_WORD *)&buf[22] = 2048;
                      *(void *)&_BYTE buf[24] = v67;
                      LOWORD(v92) = 2082;
                      *(void *)((char *)&v92 + 2) = backtrace_string;
                      _os_log_impl( &dword_181A5C000,  log,  v66,  "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    free(backtrace_string);
                    goto LABEL_64;
                  }

                  if (v37)
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v26;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)&_BYTE buf[24] = v67;
                    int v29 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
                    os_log_type_t v38 = log;
                    goto LABEL_63;
                  }
                }

                else
                {
                  __int8 v28 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v66 = type[0];
                  if (os_log_type_enabled(v28, type[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v26;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)&_BYTE buf[24] = v67;
                    int v29 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
                    goto LABEL_62;
                  }
                }
              }

uint64_t nw_channel_get_internet_checksum_handler( nw_frame *a1, BOOL *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t metadata = nw_frame_get_metadata((uint64_t)a1);
  if (a4 && a3 && a2 && metadata)
  {
    if ((*(_BYTE *)(metadata + 24) & 1) == 0) {
      return 45LL;
    }
    __int16 inet_checksum = os_packet_get_inet_checksum();
    uint64_t result = 0LL;
    *a2 = inet_checksum & 1;
    int v12 = *((unsigned __int16 *)a1 + 102);
    int v11 = (char *)a1 + 204;
    unsigned int v13 = v12 & 0xFFFFE1FF | (v11[2] << 16);
    *(_WORD *)int v11 = v12 & 0xE1FF | (2 * inet_checksum) & 0x1E00;
    v11[2] = BYTE2(v13);
    return result;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v23 = "nw_channel_get_internet_checksum_handler";
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v14, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        int v23 = "nw_channel_get_internet_checksum_handler";
        uint64_t v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL)";
LABEL_22:
        _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          int v23 = "nw_channel_get_internet_checksum_handler";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && ch ecksum_value != NULL), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        int v23 = "nw_channel_get_internet_checksum_handler";
        uint64_t v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL), no backtrace";
        goto LABEL_22;
      }
    }

    else
    {
      char v15 = (os_log_s *)__nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        int v23 = "nw_channel_get_internet_checksum_handler";
        uint64_t v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL), backtrace limit exceeded";
        goto LABEL_22;
      }
    }
  }

uint64_t nw_frame_array_first(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t validate_tcp_cksum( uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4, unsigned int a5, unsigned int a6, int a7)
{
  unsigned int v8 = a6;
  uint64_t v110 = *MEMORY[0x1895F89C0];
  unsigned __int8 v93 = 0;
  unsigned __int16 v91 = 0;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v95 = "__nw_frame_get_internet_checksum";
    __int128 v50 = (char *)_os_log_send_and_compose_impl();
    v109[0] = 16;
    v108[0] = 0;
    if (__nwlog_fault(v50, v109, v108))
    {
      if (v109[0] == 17)
      {
        uint64_t v51 = (os_log_s *)__nwlog_obj();
        os_log_type_t v52 = v109[0];
        if (os_log_type_enabled(v51, (os_log_type_t)v109[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v95 = "__nw_frame_get_internet_checksum";
          char v53 = "%{public}s called with null frame";
LABEL_67:
          __int32 v57 = v51;
LABEL_68:
          _os_log_impl(&dword_181A5C000, v57, v52, v53, buf, 0xCu);
        }
      }

      else if (v108[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v55 = (os_log_s *)__nwlog_obj();
        os_log_type_t v52 = v109[0];
        BOOL v56 = os_log_type_enabled(v55, (os_log_type_t)v109[0]);
        if (backtrace_string)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v95 = "__nw_frame_get_internet_checksum";
            __int16 v96 = 2082;
            *(void *)int v97 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v55,  v52,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_69;
        }

        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v95 = "__nw_frame_get_internet_checksum";
          char v53 = "%{public}s called with null frame, no backtrace";
          __int32 v57 = v55;
          goto LABEL_68;
        }
      }

      else
      {
        uint64_t v51 = (os_log_s *)__nwlog_obj();
        os_log_type_t v52 = v109[0];
        if (os_log_type_enabled(v51, (os_log_type_t)v109[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v95 = "__nw_frame_get_internet_checksum";
          char v53 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_67;
        }
      }
    }

void nw_path_flow_registration_set_ecn_cache(void *a1, void *a2, uint64_t a3)
{
  *(void *)&v43[13] = *MEMORY[0x1895F89C0];
  os_log_type_t v5 = a1;
  id v6 = a2;
  os_log_type_t v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v41 = "nw_path_flow_registration_set_ecn_cache";
    unsigned int v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null path", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl( &dword_181A5C000,  v21,  v33,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v27 = v37[0];
    BOOL v28 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        char v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_181A5C000, v21, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      char v41 = "nw_path_flow_registration_set_ecn_cache";
      __int16 v42 = 2082;
      *(void *)uint64_t v43 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v27,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_60;
  }

  if (!v6)
  {
    __nwlog_obj();
    int v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v41 = "nw_path_flow_registration_set_ecn_cache";
    unsigned int v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null flow_registration", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl( &dword_181A5C000,  v21,  v34,  "%{public}s called with null flow_registration, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v29 = v37[0];
    BOOL v30 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        char v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl( &dword_181A5C000,  v21,  v29,  "%{public}s called with null flow_registration, no backtrace",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      char v41 = "nw_path_flow_registration_set_ecn_cache";
      __int16 v42 = 2082;
      *(void *)uint64_t v43 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v29,  "%{public}s called with null flow_registration, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_60;
  }

  if (!a3)
  {
    __nwlog_obj();
    os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v41 = "nw_path_flow_registration_set_ecn_cache";
    unsigned int v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_181A5C000, v21, v26, "%{public}s called with null ecn_cache_buffer", buf, 0xCu);
      }

void sub_181B5BD38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_channel_finalize_input_frame(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *((void *)a1 + 2);
  id v6 = (void *)*((void *)a1 + 3);
  os_log_type_t v7 = (void *)((char *)a1 + 16);
  if (v5)
  {
    *(void *)(v5 + 24) = v6;
    id v6 = (void *)*((void *)a1 + 3);
  }

  else
  {
    a3[41] = v6;
  }

  void *v6 = v5;
  *os_log_type_t v7 = 0LL;
  *((void *)a1 + 3) = 0LL;
  uint64_t metadata = (void *)nw_frame_get_metadata((uint64_t)a1);
  if (metadata)
  {
    int v9 = metadata;
    if (*metadata)
    {
      int v10 = *((unsigned __int16 *)a3 + 222);
      if ((v10 & 0x1000) == 0) {
        goto LABEL_22;
      }
      if (!a3[17])
      {
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_65_86685);
        }
        goto LABEL_22;
      }

      if (((v10 | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
      {
LABEL_22:
        void *v9 = 0LL;
        v9[1] = 0LL;
        goto LABEL_23;
      }

      if (os_channel_is_defunct())
      {
        nw_channel_handle_defunct((uint64_t)a3);
        goto LABEL_22;
      }

      *(_WORD *)os_log_type_t type = 0;
      if ((*((_WORD *)a1 + 102) & 0x2000) == 0 || (int v11 = os_packet_decrement_use_count()) == 0)
      {
LABEL_18:
        goto LABEL_22;
      }

      int v27 = v11;
      os_log_type_t v34 = v7;
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      unsigned int v39 = "nw_channel_finalize_input_frame";
      __int16 v40 = 1024;
      int v41 = v27;
      BOOL v28 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v36 = OS_LOG_TYPE_ERROR;
      char v35 = 0;
      if (__nwlog_fault(v28, &v36, &v35))
      {
        if (v36 == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v29 = (os_log_s *)__nwlog_obj();
          os_log_type_t v30 = v36;
          if (os_log_type_enabled(v29, v36))
          {
            *(_DWORD *)buf = 136446466;
            unsigned int v39 = "nw_channel_finalize_input_frame";
            __int16 v40 = 1024;
            int v41 = v27;
            os_log_type_t v31 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d";
LABEL_78:
            _os_log_impl(&dword_181A5C000, v29, v30, v31, buf, 0x12u);
          }
        }

        else if (v35)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v29 = (os_log_s *)__nwlog_obj();
          os_log_type_t v30 = v36;
          BOOL v33 = os_log_type_enabled(v29, v36);
          if (backtrace_string)
          {
            if (v33)
            {
              *(_DWORD *)buf = 136446722;
              unsigned int v39 = "nw_channel_finalize_input_frame";
              __int16 v40 = 1024;
              int v41 = v27;
              __int16 v42 = 2082;
              uint64_t v43 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(backtrace_string);
            goto LABEL_79;
          }

          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            unsigned int v39 = "nw_channel_finalize_input_frame";
            __int16 v40 = 1024;
            int v41 = v27;
            os_log_type_t v31 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, no backtrace";
            goto LABEL_78;
          }
        }

        else
        {
          os_log_type_t v29 = (os_log_s *)__nwlog_obj();
          os_log_type_t v30 = v36;
          if (os_log_type_enabled(v29, v36))
          {
            *(_DWORD *)buf = 136446466;
            unsigned int v39 = "nw_channel_finalize_input_frame";
            __int16 v40 = 1024;
            int v41 = v27;
            os_log_type_t v31 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_78;
          }
        }
      }

void nw_queue_resume_source(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v16 = "nw_queue_resume_source";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_queue_resume_source";
        int v9 = "%{public}s called with null source";
LABEL_26:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }
    }

    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            int v16 = "nw_queue_resume_source";
            __int16 v17 = 2082;
            int v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null source, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (!v11) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_queue_resume_source";
        int v9 = "%{public}s called with null source, no backtrace";
        goto LABEL_26;
      }

      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_queue_resume_source";
        int v9 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_26;
      }
    }

void nw_flow_connected(nw_protocol *a1, nw_protocol *a2)
{
  unint64_t v3 = a1;
  uint64_t v250 = *MEMORY[0x1895F89C0];
  handle = (id *)a1->handle;
  id v5 = handle[20];
  if (v5)
  {
    id v221 = v5;
    id v6 = (NWConcrete_nw_endpoint_handler *)v5;
    uint64_t mode = v6->mode;

    if ((_DWORD)mode != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v27 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        else {
          BOOL v28 = off_189BBBBC0[mode];
        }
        *(_DWORD *)buf = 136446722;
        v232 = "nw_flow_connected";
        __int16 v233 = 2082;
        v234 = (void *)v28;
        __int16 v235 = 2082;
        v236 = "flow";
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }

      goto LABEL_118;
    }

    v220 = nw_endpoint_handler_copy_flow(v6);
    if ((*((_WORD *)handle + 166) & 0x200) != 0)
    {
      os_log_type_t v29 = v6;
      char v30 = *((_BYTE *)v29 + 268);

      os_log_type_t v31 = v220;
      if ((v30 & 0x20) != 0)
      {
LABEL_117:

LABEL_118:
        int v119 = v221;
        goto LABEL_119;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v32 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        BOOL v33 = v29;

        os_log_type_t v34 = v33;
        char v35 = *((_BYTE *)v29 + 268);

        if ((v35 & 1) != 0) {
          os_log_type_t v36 = "dry-run ";
        }
        else {
          os_log_type_t v36 = "";
        }
        nw_endpoint_t v37 = nw_endpoint_handler_copy_endpoint(v34);
        logging_description = nw_endpoint_get_logging_description(v37);
        id_str = v33->id_str;
        __int16 v40 = v34;
        int v41 = v40;
        uint64_t v42 = v40[30];
        else {
          uint64_t v43 = off_189BBBBF0[v42];
        }

        __int32 v57 = v41;
        char v58 = v57;
        int v59 = v6->mode;
        unsigned int v60 = "path";
        switch(v59)
        {
          case 0:
            break;
          case 1:
            unsigned int v60 = "resolver";
            break;
          case 2:
            unsigned int v60 = nw_endpoint_flow_mode_string(v57[31]);
            break;
          case 3:
            unsigned int v60 = "proxy";
            break;
          case 4:
            unsigned int v60 = "fallback";
            break;
          case 5:
            unsigned int v60 = "transform";
            break;
          default:
            unsigned int v60 = "unknown-mode";
            break;
        }

        uint64_t v78 = v58;
        os_unfair_lock_lock((os_unfair_lock_t)v78 + 28);
        id v79 = v78[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v78 + 28);

        *(_DWORD *)buf = 136447746;
        v232 = "nw_flow_connected";
        __int16 v233 = 2082;
        v234 = id_str;
        __int16 v235 = 2082;
        v236 = v36;
        __int16 v237 = 2082;
        v238 = (void *)logging_description;
        __int16 v239 = 2082;
        v240 = v43;
        __int16 v241 = 2082;
        v242 = v60;
        __int16 v243 = 2114;
        id v244 = v79;
        _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow was disconnected, skipping connected",  buf,  0x48u);
      }

LABEL_116:
      os_log_type_t v31 = v220;
      goto LABEL_117;
    }

    memset(__str, 0, sizeof(__str));
    if (a2 && a2->identifier) {
      snprintf(__str, 0x23uLL, " (%s)", a2->identifier->name);
    }
    char v218 = a2;
    if (v3->output_handler != a2)
    {
      if (*((nw_protocol **)v220 + 90) == a2)
      {
        int v75 = "Transport";
      }

      else
      {
        if (*((nw_protocol **)v220 + 92) != a2)
        {
          if (*((nw_protocol **)v220 + 93) != a2) {
            goto LABEL_8;
          }
          v215 = v3;
          if (a2)
          {
            callbacks = a2->callbacks;
            if (callbacks)
            {
              waiting_for_output = (unsigned int (*)(nw_protocol *, nw_protocol *))callbacks->waiting_for_output;
              if (waiting_for_output)
              {
                if (waiting_for_output(a2, v3))
                {
                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v6);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v6);
                  if (minimize_logging)
                  {
                    a2 = v218;
                    if ((logging_disabled & 1) != 0) {
                      goto LABEL_8;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    os_log_type_t v52 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v6);
                      v188 = nw_endpoint_handler_dry_run_string(v6);
                      nw_endpoint_t v189 = nw_endpoint_handler_copy_endpoint(v6);
                      uint64_t v190 = nw_endpoint_get_logging_description(v189);
                      int v191 = nw_endpoint_handler_state_string(v6);
                      uint64_t v192 = nw_endpoint_handler_mode_string(v6);
                      id v193 = nw_endpoint_handler_copy_current_path(v6);
                      *(_DWORD *)buf = 136448002;
                      v232 = "nw_flow_connected";
                      __int16 v233 = 2082;
                      v234 = (void *)id_string;
                      __int16 v235 = 2082;
                      v236 = v188;
                      __int16 v237 = 2082;
                      v238 = (void *)v190;
                      __int16 v239 = 2082;
                      v240 = v191;
                      __int16 v241 = 2082;
                      v242 = v192;
                      __int16 v243 = 2114;
                      id v244 = v193;
                      __int16 v245 = 2082;
                      v246 = __str;
                      _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol% {public}s waiting for output, ignore",  buf,  0x52u);
                    }

void sub_181B5E458( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_is_probe(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  unsigned int v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[97] >> 2) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_is_probe";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_is_probe";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_is_probe";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_sensitive_redacted_for_endpoint(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (!v3) {
    goto LABEL_18;
  }
  id v5 = v3;
  id v6 = *(id *)(v5[13] + 136LL);
  os_log_type_t v7 = v6;
  if (v6)
  {
    int v8 = v6[31];
    if ((v8 - 2) >= 2)
    {
      if (v8 == 1)
      {

        goto LABEL_10;
      }

LABEL_17:
      goto LABEL_18;
    }
  }

  if (nwlog_get_sensitive_redacted::onceToken != -1) {
    dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
  }
  int v9 = nwlog_get_sensitive_redacted::sensitiveRedacted;

  if (v9) {
    goto LABEL_17;
  }
LABEL_10:
  if (*(unsigned __int8 *)(v5[13] + 102LL) - 1 < 2)
  {
    if (nwlog_get_sensitive_redacted::onceToken != -1) {
      dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
    }
    int v10 = nwlog_get_sensitive_redacted::sensitiveRedacted;

    if (!v10)
    {
LABEL_20:
      uint64_t v11 = 0LL;
      goto LABEL_22;
    }

void sub_181B5E9CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_get_do_not_redact(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  unsigned int v2 = v1;
  if (v1)
  {
    if ((*((_BYTE *)v1 + 231) & 0x20) != 0)
    {
      BOOL v6 = 1LL;
    }

    else
    {
      id v3 = v1[1];
      id v4 = v3;
      if (v3 && (int v5 = *((_DWORD *)v3 + 31), (v5 - 2) >= 2))
      {
        BOOL v6 = v5 == 1;
      }

      else
      {
        if (nwlog_get_sensitive_redacted::onceToken != -1) {
          dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
        }
        BOOL v6 = nwlog_get_sensitive_redacted::sensitiveRedacted == 0;
      }
    }

    goto LABEL_11;
  }

  __nwlog_obj();
  int v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_endpoint_get_do_not_redact";
  int v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_endpoint_get_do_not_redact";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_endpoint_get_do_not_redact";
          __int16 v20 = 2082;
          nw_endpoint_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_endpoint_get_do_not_redact";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_endpoint_get_do_not_redact";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_endpoint_get_parent_endpoint_domain(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1) {
    return nw_endpoint_get_domain_for_policy(*(void **)(a1 + 112));
  }
  __nwlog_obj();
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v13 = "nw_endpoint_get_parent_endpoint_domain";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v13 = "nw_endpoint_get_parent_endpoint_domain";
        _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v13 = "nw_endpoint_get_parent_endpoint_domain";
          __int16 v14 = 2082;
          os_log_type_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v13 = "nw_endpoint_get_parent_endpoint_domain";
        _os_log_impl(&dword_181A5C000, v4, v7, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v13 = "nw_endpoint_get_parent_endpoint_domain";
        _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_endpoint_copy_parent_endpoint(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  unsigned int v2 = v1;
  if (v1)
  {
    id v3 = v1[14];
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_endpoint_copy_parent_endpoint";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_copy_parent_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_endpoint_copy_parent_endpoint";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_copy_parent_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_copy_parent_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_enable_tls_keylog()
{
  uint64_t result = os_variant_allows_internal_security_policies();
  if ((_DWORD)result) {
    return networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_enable_tls_keylog);
  }
  return result;
}

id nw_protocol_stack_copy_original_proxied_transport_protocol(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  unsigned int v2 = v1;
  if (v1)
  {
    id v3 = v1[5];
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id nw_protocol_copy_quic_stream_definition()
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
  }
  return (id)nw_protocol_copy_quic_stream_definition::quic_definition;
}

BOOL nw_endpoint_copy_original_endpoint(void *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
            __int16 v24 = 2082;
            uint64_t v25 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B5F8D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_context_2k_buffer_length()
{
  return dword_18C58F2D8;
}

uint64_t nw_context_2k_buffer_manager(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  if (v1)
  {
    unsigned int v2 = v1;
    uint64_t v3 = nw_context_copy_globals_context(v1);

    uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 180LL);
    if (!v4)
    {
      *(void *)(*(void *)(v3 + 32) + 180LL) = nw_mem_buffer_manager_initialize( *(dispatch_object_s **)(v3 + 8),  aNwcontextbuffe,  dword_18C58F2D8,  (unsigned __int16)word_18C58F2DC);
      uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 180LL);
    }

    goto LABEL_4;
  }

  __nwlog_obj();
  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_context_2k_buffer_manager";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_context_2k_buffer_manager";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_context_2k_buffer_manager";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B5FBD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_mem_buffer_allocate(uint64_t a1)
{
  info[6] = *(mach_timebase_info *)MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    info[0].numer = 136446210;
    *(void *)&info[0].denom = "nw_mem_buffer_allocate";
    __int128 v50 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v65) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v51 = (os_log_s *)__nwlog_obj();
      os_log_type_t v52 = type[0];
      if (!os_log_type_enabled(v51, type[0])) {
        goto LABEL_86;
      }
      info[0].numer = 136446210;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      char v53 = "%{public}s called with null buffer_manager";
    }

    else if ((_BYTE)v65)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v51 = (os_log_s *)__nwlog_obj();
      os_log_type_t v52 = type[0];
      BOOL v55 = os_log_type_enabled(v51, type[0]);
      if (backtrace_string)
      {
        if (v55)
        {
          info[0].numer = 136446466;
          *(void *)&info[0].denom = "nw_mem_buffer_allocate";
          LOWORD(info[1].denom) = 2082;
          *(void *)((char *)&info[1].denom + 2) = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s called with null buffer_manager, dumping backtrace:%{public}s",  (uint8_t *)info,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_86;
      }

      if (!v55)
      {
LABEL_86:
        if (v50) {
          free(v50);
        }
        return 0LL;
      }

      info[0].numer = 136446210;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      char v53 = "%{public}s called with null buffer_manager, no backtrace";
    }

    else
    {
      nw_endpoint_t v51 = (os_log_s *)__nwlog_obj();
      os_log_type_t v52 = type[0];
      if (!os_log_type_enabled(v51, type[0])) {
        goto LABEL_86;
      }
      info[0].numer = 136446210;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      char v53 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v51, v52, v53, (uint8_t *)info, 0xCu);
    goto LABEL_86;
  }

  if (!*(void *)(a1 + 88))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      info[0].numer = 136446466;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      LOWORD(info[1].denom) = 2082;
      *(void *)((char *)&info[1].denom + 2) = a1 + 96;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s buffer cache is NULL for %{public}s",  (uint8_t *)info,  0x16u);
    }

    return 0LL;
  }

  g_transaction_touched = 1;
  nw_mem_cache_update_set_timer();
  uint64_t v2 = *(void *)(a1 + 88);
  *(_OWORD *)os_log_type_t type = 0u;
  __int128 v68 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  nw_mem_cache_operations_during_interval = 1;
  info[0] = 0LL;
  if (!mach_timebase_info(info))
  {
    uint64_t v3 = mach_absolute_time() * info[0].numer / info[0].denom;
    *(void *)&nw_mem_get_current_time::current_time = v3 / 0x3B9ACA00;
    *((void *)&nw_mem_get_current_time::current_time + 1) = v3 % 0x3B9ACA00;
    *(_OWORD *)(v2 + 40_Block_object_dispose(va, 8) = nw_mem_get_current_time::current_time;
  }

  int v4 = *(_DWORD *)(v2 + 552);
  if (v4 < 1)
  {
    int v11 = *(_DWORD *)(v2 + 556);
    while (1)
    {
      int v12 = v4;
      if (v11 >= 1)
      {
        os_log_type_t v5 = *(void **)(v2 + 528);
        *(void *)(v2 + 52_Block_object_dispose(va, 8) = *(void *)(v2 + 520);
        *(_DWORD *)(v2 + 556) = v4;
        *(void *)(v2 + 520) = v5;
        int v4 = v11;
        goto LABEL_7;
      }

      int v4 = *(_DWORD *)(v2 + 560);
      if (!v4) {
        break;
      }
      os_log_type_t v5 = *(void **)(v2 + 352);
      if (!v5) {
        break;
      }
      *(void *)(v2 + 352) = *v5;
      unsigned int v13 = *(_DWORD *)(v2 + 360) - 1;
      *(_DWORD *)(v2 + 360) = v13;
      if (v13 < *(_DWORD *)(v2 + 364)) {
        *(_DWORD *)(v2 + 364) = v13;
      }
      ++*(void *)(v2 + 344);
      char v14 = *(void **)(v2 + 528);
      if (v14)
      {
        void *v14 = *(void *)(v2 + 384);
        *(void *)(v2 + 384) = v14;
        ++*(_DWORD *)(v2 + 392);
      }

      *(void *)(v2 + 52_Block_object_dispose(va, 8) = *(void *)(v2 + 520);
      *(_DWORD *)(v2 + 556) = v12;
      *(void *)(v2 + 520) = v5;
      *(_DWORD *)(v2 + 552) = v4;
      int v11 = v12;
      if (v4 > 0) {
        goto LABEL_7;
      }
    }

    ++*(void *)(v2 + 48);
    os_log_type_t v15 = *(_DWORD **)(v2 + 296);
    if (v15)
    {
      LODWORD(v16) = v15[17];
    }

    else
    {
      uint64_t v17 = *(void *)(v2 + 216);
      unint64_t v18 = *(void *)(v17 + 120);
      unint64_t v19 = *(void *)(v2 + 248);
      uint64_t v70 = 0LL;
      uint64_t v71 = 0LL;
      uint64_t v69 = 0LL;
      BOOL v20 = nw_mem_region_alloc(v17, &v69, &v71, &v70, 1);
      if (!v20)
      {
        if (gLogDatapath)
        {
          int v63 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
          {
            info[0].numer = 136446210;
            *(void *)&info[0].denom = "nw_mem_slab_create";
            _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s nw mem region alloc failure",  (uint8_t *)info,  0xCu);
          }
        }

        unint64_t v7 = 0LL;
        ++*(void *)v2;
        return v7;
      }

      BOOL v21 = v20;
      os_log_type_t v15 = malloc_zone_memalign((malloc_zone_t *)g_slab_zone, 8uLL, 0x48uLL);
      if (!v15)
      {
        char v58 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v58, OS_LOG_TYPE_ERROR);
        info[0].numer = 136446722;
        *(void *)&info[0].denom = "strict_malloc_zone_memalign";
        LOWORD(info[1].denom) = 2048;
        *(void *)((char *)&info[1].denom + 2) = 8LL;
        HIWORD(info[2].denom) = 2048;
        info[3] = (mach_timebase_info)72LL;
        int v59 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v59);
        if (result) {
          goto LABEL_99;
        }
        free(v59);
      }

      *((void *)v15 + _Block_object_dispose(va, 8) = 0LL;
      *((_OWORD *)v15 + 2) = 0u;
      *((_OWORD *)v15 + 3) = 0u;
      *(_OWORD *)os_log_type_t v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      *((void *)v15 + 2) = v2;
      *((void *)v15 + 3) = v21;
      uint64_t v22 = v69;
      unint64_t v23 = v19 / v18;
      v15[17] = v19 / v18;
      uint64_t v24 = v71;
      *((void *)v15 + 4) = v22;
      *((void *)v15 + 5) = v24;
      *((void *)v15 + 6) = v70;
      if ((nw_mem_debug & 2) != 0) {
        size_t v25 = 176LL;
      }
      else {
        size_t v25 = 40LL;
      }
      uint64_t v26 = (v19 / v18);
      if ((_DWORD)v23)
      {
        uint64_t v27 = v21;
        do
        {
          BOOL v28 = malloc_zone_memalign((malloc_zone_t *)g_slab_zone, 8uLL, v25);
          if (!v28)
          {
            os_log_type_t v29 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
            info[0].numer = 136446722;
            *(void *)&info[0].denom = "strict_malloc_zone_memalign";
            LOWORD(info[1].denom) = 2048;
            *(void *)((char *)&info[1].denom + 2) = 8LL;
            HIWORD(info[2].denom) = 2048;
            info[3] = (mach_timebase_info)v25;
            char v64 = (void *)_os_log_send_and_compose_impl();
            BOOL result = __nwlog_abort((uint64_t)v64);
            if (result) {
              goto LABEL_99;
            }
            free(v64);
          }

          bzero(v28, v25);
          v28[1] = v27;
          void v28[2] = v22;
          v28[3] = v15;
          *((_DWORD *)v28 + _Block_object_dispose(va, 8) = v15[17] - v26;
          *BOOL v28 = *((void *)v15 + 7);
          *((void *)v15 + 7) = v28;
          v27 += v18;
          if (v22) {
            v22 += v18;
          }
          else {
            uint64_t v22 = 0LL;
          }
          --v26;
        }

        while (v26);
      }

      if (gLogDatapath)
      {
        unsigned int v60 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          info[0].numer = 136446722;
          *(void *)&info[0].denom = "nw_mem_slab_create";
          LOWORD(info[1].denom) = 2048;
          *(void *)((char *)&info[1].denom + 2) = v2;
          HIWORD(info[2].denom) = 2048;
          info[3] = (mach_timebase_info)v15;
          _os_log_impl(&dword_181A5C000, v60, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p sl %p", (uint8_t *)info, 0x20u);
        }

        if (gLogDatapath)
        {
          BOOL v61 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
          {
            uint32_t v62 = *(_DWORD *)(*((void *)v15 + 5) + 40LL);
            info[0].numer = 136446978;
            *(void *)&info[0].denom = "nw_mem_slab_create";
            LOWORD(info[1].denom) = 1024;
            *(uint32_t *)((char *)&info[1].denom + 2) = v62;
            HIWORD(info[2].numer) = 2048;
            *(void *)&info[2].denom = v21;
            LOWORD(info[3].denom) = 2048;
            *(void *)((char *)&info[3].denom + 2) = v21 + v18;
            _os_log_impl(&dword_181A5C000, v61, OS_LOG_TYPE_DEBUG, "%{public}s   [%u] [%p-%p)", (uint8_t *)info, 0x26u);
          }
        }
      }

      ++*(void *)(v2 + 32);
      uint64_t v16 = v15[17];
      unint64_t v30 = *(void *)(v2 + 16);
      unint64_t v31 = *(void *)(v2 + 8) + v16;
      *(void *)(v2 + _Block_object_dispose(va, 8) = v31;
      if (v31 > v30) {
        *(void *)(v2 + 16) = v31;
      }
    }

    int v32 = v15[16];
    v15[16] = v32 + 1;
    BOOL v33 = (uint64_t *)*((void *)v15 + 7);
    uint64_t v34 = *v33;
    *((void *)v15 + 7) = *v33;
    unint64_t v7 = v33[1];
    uint64_t v35 = *(void *)(v2 + 240);
    *(void *)os_log_type_t type = v7;
    *(void *)&os_log_type_t type[8] = v35;
    uint64_t v36 = *((void *)v15 + 5);
    unsigned int v37 = *((_DWORD *)v33 + 8);
    unsigned int v38 = v37 + v16 * *(_DWORD *)(v36 + 40);
    *(void *)&__int128 v68 = __PAIR64__(v37, v38);
    *((void *)&v68 + 1) = v36;
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    uint64_t v39 = v33[2];
    if (v39)
    {
      *(void *)&__int128 v65 = v33[2];
      *((void *)&v65 + 1) = v35;
      *(void *)&__int128 v66 = __PAIR64__(v37, v38);
      *((void *)&v66 + 1) = *((void *)v15 + 6);
    }

    uint64_t v40 = *(void *)(v2 + 288);
    uint64_t v41 = 8 * ((v7 >> *(void *)(v2 + 272)) & *(void *)(v2 + 280));
    uint64_t *v33 = *(void *)(v40 + v41);
    *(void *)(v40 + v41) = v33;
    if (v34)
    {
      if (v32)
      {
        if ((*(_BYTE *)(v2 + 176) & 2) == 0) {
          goto LABEL_51;
        }
        goto LABEL_68;
      }

      uint32_t v46 = (void *)(v2 + 296);
      uint64_t v47 = *(void *)(v2 + 296);
      *(void *)os_log_type_t v15 = v47;
      id v48 = (void *)(v2 + 304);
    }

    else
    {
      if (v32)
      {
        uint64_t v44 = *(void *)v15;
        os_log_type_t v45 = (void *)*((void *)v15 + 1);
        if (*(void *)v15)
        {
          *(void *)(v44 + _Block_object_dispose(va, 8) = v45;
          os_log_type_t v45 = (void *)*((void *)v15 + 1);
        }

        else
        {
          *(void *)(v2 + 304) = v45;
        }

        *os_log_type_t v45 = v44;
      }

      uint32_t v46 = (void *)(v2 + 312);
      uint64_t v47 = *(void *)(v2 + 312);
      *(void *)os_log_type_t v15 = v47;
      id v48 = (void *)(v2 + 320);
    }

    if (v47) {
      int v49 = (void *)(v47 + 8);
    }
    else {
      int v49 = v48;
    }
    void *v49 = v15;
    void *v46 = v15;
    *((void *)v15 + 1) = v46;
    if ((*(_BYTE *)(v2 + 176) & 2) == 0)
    {
LABEL_51:
      uint64_t v42 = *(unsigned int (**)(os_log_type_t *, __int128 *, void, uint64_t))(v2 + 184);
      if (!v42) {
        return v7;
      }
      goto LABEL_52;
    }

BOOL nw_frame_array_is_empty(void *a1)
{
  return *a1 == 0LL;
}

uint64_t nw_frame_array_next(int a1, void *a2)
{
  if (a1)
  {
    uint64_t result = a2[4];
    if (!result && !a2[5]) {
      return 0LL;
    }
  }

  else
  {
    uint64_t result = a2[2];
    if (!result && !a2[3]) {
      return 0LL;
    }
  }

  return result;
}

void nw_frame_collapse(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v30 = "__nw_frame_collapse";
    BOOL v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v30 = "__nw_frame_collapse";
      uint64_t v24 = "%{public}s called with null frame";
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v26 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v30 = "__nw_frame_collapse";
          __int16 v31 = 2082;
          int v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }

      if (!v26)
      {
LABEL_43:
        if (v21) {
          free(v21);
        }
        return;
      }

      *(_DWORD *)buf = 136446210;
      unint64_t v30 = "__nw_frame_collapse";
      uint64_t v24 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v30 = "__nw_frame_collapse";
      uint64_t v24 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
    goto LABEL_43;
  }

  int v2 = *(_DWORD *)(a1 + 52);
  if (v2)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 56);
    size_t v3 = *(unsigned int *)(a1 + 60);
    uint64_t v5 = (v2 - (v3 + v4));
    if (v2 != (_DWORD)v3 + (_DWORD)v4)
    {
      if ((_DWORD)v3)
      {
        uint64_t v6 = *(void *)(a1 + 112);
        if (v6)
        {
          memmove((void *)(v6 + v4), (const void *)(v6 + v4 + v5), v3);
          int v2 = *(_DWORD *)(a1 + 52);
        }
      }

      *(_DWORD *)(a1 + 52) = v2 - v5;
      if ((*(_WORD *)(a1 + 204) & 0x80) != 0)
      {
        unsigned int v7 = *(unsigned __int16 *)(a1 + 196);
        BOOL v8 = v7 >= v5;
        unsigned int v9 = v7 - v5;
        *(_WORD *)(a1 + 196) = v9;
        if (!v8 || v9 >= 0x10000)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v10 = *(unsigned __int16 *)(a1 + 196);
          *(_DWORD *)buf = 136446978;
          unint64_t v30 = "__nw_frame_collapse";
          __int16 v31 = 2082;
          int v32 = "frame->aggregate_buffer_length";
          __int16 v33 = 2048;
          uint64_t v34 = v5;
          __int16 v35 = 2048;
          uint64_t v36 = v10;
          int v11 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v27 = 0;
          if (__nwlog_fault(v11, &type, &v27))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v12 = (os_log_s *)gLogObj;
              os_log_type_t v13 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                uint64_t v14 = *(unsigned __int16 *)(a1 + 196);
                *(_DWORD *)buf = 136446978;
                unint64_t v30 = "__nw_frame_collapse";
                __int16 v31 = 2082;
                int v32 = "frame->aggregate_buffer_length";
                __int16 v33 = 2048;
                uint64_t v34 = v5;
                __int16 v35 = 2048;
                uint64_t v36 = v14;
                os_log_type_t v15 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_24:
                _os_log_impl(&dword_181A5C000, v12, v13, v15, buf, 0x2Au);
              }
            }

            else if (v27)
            {
              uint64_t v16 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v12 = (os_log_s *)gLogObj;
              os_log_type_t v13 = type;
              BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
              if (v16)
              {
                if (v17)
                {
                  uint64_t v18 = *(unsigned __int16 *)(a1 + 196);
                  *(_DWORD *)buf = 136447234;
                  unint64_t v30 = "__nw_frame_collapse";
                  __int16 v31 = 2082;
                  int v32 = "frame->aggregate_buffer_length";
                  __int16 v33 = 2048;
                  uint64_t v34 = v5;
                  __int16 v35 = 2048;
                  uint64_t v36 = v18;
                  __int16 v37 = 2082;
                  unsigned int v38 = v16;
                  _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v16);
                goto LABEL_25;
              }

              if (v17)
              {
                uint64_t v20 = *(unsigned __int16 *)(a1 + 196);
                *(_DWORD *)buf = 136446978;
                unint64_t v30 = "__nw_frame_collapse";
                __int16 v31 = 2082;
                int v32 = "frame->aggregate_buffer_length";
                __int16 v33 = 2048;
                uint64_t v34 = v5;
                __int16 v35 = 2048;
                uint64_t v36 = v20;
                os_log_type_t v15 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                goto LABEL_24;
              }
            }

            else
            {
              int v12 = (os_log_s *)__nwlog_obj();
              os_log_type_t v13 = type;
              if (os_log_type_enabled(v12, type))
              {
                uint64_t v19 = *(unsigned __int16 *)(a1 + 196);
                *(_DWORD *)buf = 136446978;
                unint64_t v30 = "__nw_frame_collapse";
                __int16 v31 = 2082;
                int v32 = "frame->aggregate_buffer_length";
                __int16 v33 = 2048;
                uint64_t v34 = v5;
                __int16 v35 = 2048;
                uint64_t v36 = v19;
                os_log_type_t v15 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_24;
              }
            }
          }

uint64_t nw_frame_array_remove(uint64_t result, int a2, void *a3)
{
  if (!a2)
  {
    uint64_t v4 = a3[2];
    uint64_t v5 = (void *)a3[3];
    size_t v3 = a3 + 2;
    if (v4)
    {
      *(void *)(v4 + 24) = v5;
      uint64_t v5 = (void *)a3[3];
      goto LABEL_7;
    }

uint64_t nw_frame_array_append(uint64_t result, int a2, uint64_t a3)
{
  if (a2)
  {
    *(void *)(a3 + 32) = 0LL;
    uint64_t v3 = a3 + 32;
  }

  else
  {
    *(void *)(a3 + 16) = 0LL;
    uint64_t v3 = a3 + 16;
  }

  uint64_t v4 = *(void **)(result + 8);
  *(void *)(v3 + _Block_object_dispose(va, 8) = v4;
  void *v4 = a3;
  *(void *)(result + _Block_object_dispose(va, 8) = v3;
  return result;
}

void nw_protocol_default_input_flush(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_flush = (void (*)(void))callbacks->input_flush;
        if (input_flush) {
          input_flush();
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v14 = "nw_protocol_default_input_flush";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_default_input_flush";
      BOOL v8 = "%{public}s called with null protocol";
      goto LABEL_19;
    }

    if (!v11)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_default_input_flush";
      BOOL v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_19;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v14 = "nw_protocol_default_input_flush";
        __int16 v15 = 2082;
        uint64_t v16 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_20;
    }

    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_default_input_flush";
      BOOL v8 = "%{public}s called with null protocol, no backtrace";
LABEL_19:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    }
  }

void nw_mem_buffer_free(uint64_t a1, unint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer_manager";
      goto LABEL_74;
    }

    if (!v38)
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v31 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (!v31) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer_manager, no backtrace";
      goto LABEL_74;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null buffer_manager, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_75:
    if (!v23) {
      return;
    }
    goto LABEL_76;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer";
      goto LABEL_74;
    }

    if (!v38)
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_74;
    }

    int v32 = (char *)__nw_create_backtrace_string();
    uint64_t v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v33 = os_log_type_enabled(v24, type);
    if (v32)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v32;
        _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null buffer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v32);
      if (!v23) {
        return;
      }
LABEL_76:
      free(v23);
      return;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer, no backtrace";
LABEL_74:
      _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
      goto LABEL_75;
    }

    goto LABEL_75;
  }

  if (*(void *)(a1 + 88))
  {
    g_transaction_touched = 1;
    nw_mem_cache_update_set_timer();
    uint64_t v4 = *(void *)(a1 + 88);
    nw_mem_cache_operations_during_interval = 1;
    if ((*(_BYTE *)(v4 + 176) & 2) != 0)
    {
      uint64_t v27 = *(void *)(v4 + 288) + 8 * ((a2 >> *(void *)(v4 + 272)) & *(void *)(v4 + 280));
      while (1)
      {
        uint64_t v27 = *(void *)v27;
        if (!v27) {
          break;
        }
        if (*(void *)(v27 + 8) == a2)
        {
          *(void *)buf = 0LL;
          *(void *)&buf[8] = 0LL;
          gettimeofday((timeval *)buf, 0LL);
          *(void *)(v27 + 32) = 1000LL * *(void *)buf + *(_DWORD *)&buf[8] / 1000;
          *(_DWORD *)(v27 + 44) = backtrace((void **)(v27 + 48), 16);
          goto LABEL_5;
        }
      }

      BOOL v28 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_mem_audit_buf";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v4 + 96;
      __int16 v41 = 2048;
      unint64_t v42 = a2;
      os_log_type_t v29 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v29))
      {
LABEL_77:
        __break(1u);
        return;
      }

      free(v29);
      *(void *)buf = 0LL;
      *(void *)&buf[8] = 0LL;
      gettimeofday((timeval *)buf, 0LL);
      MEMORY[0x20] = 1000LL * *(void *)buf + *(_DWORD *)&buf[8] / 1000;
      MEMORY[0x2C] = backtrace((void **)0x30, 16);
    }

uint64_t nw_context_8k_buffer_length()
{
  return dword_18C58F320;
}

uint64_t nw_context_8k_buffer_manager(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  if (v1)
  {
    int v2 = v1;
    uint64_t v3 = nw_context_copy_globals_context(v1);

    uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 172LL);
    if (!v4)
    {
      *(void *)(*(void *)(v3 + 32) + 172LL) = nw_mem_buffer_manager_initialize( *(dispatch_object_s **)(v3 + 8),  aNwcontextbuffe_0,  dword_18C58F320,  (unsigned __int16)word_18C58F324);
      uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 172LL);
    }

    goto LABEL_4;
  }

  __nwlog_obj();
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_context_8k_buffer_manager";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_context_8k_buffer_manager";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_context_8k_buffer_manager";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_context_8k_buffer_manager";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_context_8k_buffer_manager";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B61BE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_mem_region_alloc(uint64_t a1, uint64_t *a2, void *a3, void *a4, char a5)
{
  unsigned int v5 = a4;
  unsigned int v6 = a2;
  uint64_t v72 = *MEMORY[0x1895F89C0];
  uint64_t v65 = 0LL;
  if (a3) {
    *a3 = 0LL;
  }
  if (a4) {
    *a4 = 0LL;
  }
  uint64_t v8 = *(void *)(a1 + 368);
  if (v8)
  {
LABEL_6:
    nw_segment_freelist_remove((void *)a1, (uint64_t *)v8, 0);
    unint64_t v9 = *(void *)(v8 + 24);
    unsigned int v10 = (void *)(*(void *)(a1 + 360)
                   + 16
                   * (((v9 >> *(void *)(a1 + 344)) + v9 + (v9 >> (2 * *(void *)(a1 + 344)))) & *(void *)(a1 + 352)));
    os_log_type_t v11 = (void *)*v10;
    *(void *)uint64_t v8 = *v10;
    if (!v11) {
      os_log_type_t v11 = v10;
    }
    v11[1] = v8;
    *unsigned int v10 = v8;
    *(void *)(v8 + _Block_object_dispose(va, 8) = v10;
    unint64_t v12 = *(void *)(a1 + 16) + 1LL;
    *(void *)(a1 + 16) = v12;
    if (v12 > *(void *)(a1 + 48)) {
      *(void *)(a1 + 4_Block_object_dispose(va, 8) = v12;
    }
    *(void *)(a1 + 8) += *(void *)(a1 + 88);
    os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_region_lock);
    g_total_memory_usage += *(void *)(a1 + 88);
    if ((unint64_t)g_total_memory_usage >= 0x4B000)
    {
      g_transaction_touched = 1;
      if (!g_process_transaction)
      {
        g_process_transaction = os_transaction_create();
        if (gLogDatapath)
        {
          char v58 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            __int128 v68 = "nw_mem_region_alloc";
            _os_log_impl(&dword_181A5C000, v58, OS_LOG_TYPE_DEBUG, "%{public}s os transaction enabled", buf, 0xCu);
          }
        }
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_region_lock);
LABEL_14:
    if (gLogDatapath)
    {
      char v53 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        __int128 v68 = "nw_mem_region_alloc";
        __int16 v69 = 2048;
        *(void *)uint64_t v70 = a1;
        *(_WORD *)&v70[8] = 2048;
        *(void *)&v70[10] = v8;
        _os_log_impl(&dword_181A5C000, v53, OS_LOG_TYPE_DEBUG, "%{public}s nwr %p sg %p", buf, 0x20u);
      }
    }

    uint64_t v13 = *(void *)(a1 + 392);
    if (v13)
    {
      if ((*(_DWORD *)(v13 + 240) & 0x80000000) != 0)
      {
        if (!gLogDatapath || (uint64_t v54 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)))
        {
LABEL_64:
          uint64_t v51 = *(void *)(a1 + 392);
          if (v51) {
            uint64_t v51 = nw_mem_region_alloc(v51, 0LL, &v65, 0LL, 3LL);
          }
          if (v9)
          {
            if (a3) {
              *a3 = v8;
            }
            if (v5) {
              *unsigned int v5 = v65;
            }
          }

LABEL_84:
  __break(1u);
  return result;
}
}

    if (v41) {
      free(v41);
    }
    goto LABEL_26;
  }

  uint64_t v3 = (unsigned int *)v1;
  uint64_t v4 = v3[29];

  if ((_DWORD)v4 == 2)
  {
    unsigned int v5 = v3;
    unsigned int v6 = v5->parameters;

    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(id *)(*((void *)v7 + 13) + 136LL);

      if (v8)
      {
        unint64_t v9 = (dispatch_queue_t *)v8;
        unsigned int v10 = v9;
        if (((_BYTE)v9[17] & 8) == 0) {
          dispatch_assert_queue_V2(v9[1]);
        }

        os_log_type_t v11 = nw_endpoint_handler_copy_flow(v5);
        unint64_t v12 = (void *)*((void *)v11 + 51);
        if (v12)
        {
          uint64_t v13 = v12[3];
          if (v13)
          {
            char v14 = *(uint64_t (**)(void))(v13 + 224);
            if (v14)
            {
              uint64_t v15 = (void *)v12[5];
              if (v15 == &nw_protocol_ref_counted_handle)
              {
                mach_vm_address_t v33 = v12[11];
                if (v33) {
                  v12[11] = v33 + 1;
                }
                uint64_t v16 = -1;
              }

              else
              {
                uint64_t v16 = 0;
              }

              *(void *)buf = v12;
              buf[8] = v16;
              mach_vm_address_t v32 = v14();
              if (v15 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              }
              goto LABEL_43;
            }
          }
        }

        else
        {
          uint64_t v70 = v6;
          uint64_t v19 = v5;
          unsigned int v20 = *((_BYTE *)v19 + 268);

          if ((v20 & 0x20) != 0)
          {
            mach_vm_address_t v32 = 0LL;
            unsigned int v6 = v70;
            goto LABEL_43;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v21 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            __int16 v69 = v21;
            unint64_t v22 = v19;

            int v23 = v22;
            int v24 = *((_BYTE *)v19 + 268);

            os_log_type_t v25 = "dry-run ";
            if ((v24 & 1) == 0) {
              os_log_type_t v25 = "";
            }
            __int128 v68 = v25;
            uint64_t v26 = nw_endpoint_handler_copy_endpoint(v23);
            logging_description = nw_endpoint_get_logging_description(v26);
            id_str = v22->id_str;
            uint64_t v28 = v23;
            uint64_t v29 = v28;
            uint64_t v30 = v28[30];
            else {
              BOOL v31 = off_189BBBBF0[v30];
            }
            __int128 v66 = v31;

            uint64_t v34 = v29;
            __int16 v35 = v34;
            uint64_t v36 = "path";
            switch(v3[29])
            {
              case 0u:
                break;
              case 1u:
                uint64_t v36 = "resolver";
                break;
              case 2u:
                uint64_t v36 = nw_endpoint_flow_mode_string(v34[31]);
                break;
              case 3u:
                uint64_t v36 = "proxy";
                break;
              case 4u:
                uint64_t v36 = "fallback";
                break;
              case 5u:
                uint64_t v36 = "transform";
                break;
              default:
                uint64_t v36 = "unknown-mode";
                break;
            }

            __int16 v37 = v35;
            os_unfair_lock_lock((os_unfair_lock_t)v37 + 28);
            char v38 = v37[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v37 + 28);

            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            id v74 = 2082;
            int v75 = id_str;
            unsigned int v76 = 2082;
            char v21 = v69;
            unsigned int v77 = v68;
            uint64_t v78 = 2082;
            id v79 = logging_description;
            int v80 = 2082;
            char v81 = v66;
            unsigned int v82 = 2082;
            uint64_t v83 = v36;
            int32x4_t v84 = 2114;
            nw_endpoint_t v85 = v38;
            _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] could not find valid output protocol",  buf,  0x48u);
          }

          unsigned int v6 = v70;
        }

        mach_vm_address_t v32 = 0LL;
LABEL_43:

LABEL_44:
LABEL_45:

        goto LABEL_46;
      }

      __nwlog_obj();
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
      os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      uint64_t v71 = 0;
      if (__nwlog_fault(v52, &type, &v71))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v54 = type;
          if (os_log_type_enabled(v53, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            _os_log_impl(&dword_181A5C000, v53, v54, "%{public}s called with null context", buf, 0xCu);
          }
        }

        else
        {
          if (v71)
          {
            int v59 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            unsigned int v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v61 = type;
            uint32_t v62 = os_log_type_enabled(v60, type);
            if (v59)
            {
              if (v62)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
                id v74 = 2082;
                int v75 = v59;
                _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v59);
            }

            else
            {
              if (v62)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
                _os_log_impl(&dword_181A5C000, v60, v61, "%{public}s called with null context, no backtrace", buf, 0xCu);
              }
            }

            goto LABEL_101;
          }

          __nwlog_obj();
          char v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v65 = type;
          if (os_log_type_enabled(v53, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            _os_log_impl( &dword_181A5C000,  v53,  v65,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    goto LABEL_136;
  }

  unsigned int v5 = (char *)MEMORY[0x186E12534](v3);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  int v75 = "networkd_privileged_check_mobile_asset_block_invoke";
  unsigned int v76 = 2082;
  *(void *)unsigned int v77 = v5;
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v72 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)(id)gLogObj;
    unint64_t v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      int v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      unsigned int v76 = 2082;
      *(void *)unsigned int v77 = v5;
      _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }

    goto LABEL_136;
  }

  unsigned int v5 = (char *)MEMORY[0x186E12534](v3);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  int v75 = "networkd_privileged_run_probes_block_invoke";
  unsigned int v76 = 2082;
  *(void *)unsigned int v77 = v5;
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v72 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)(id)gLogObj;
    unint64_t v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      int v75 = "networkd_privileged_run_probes_block_invoke";
      unsigned int v76 = 2082;
      *(void *)unsigned int v77 = v5;
      _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }

        free(v43);
        if (!v17) {
          goto LABEL_138;
        }
LABEL_136:
        __int128 v68 = (char *)v17;
LABEL_137:
        free(v68);
        goto LABEL_138;
      }

      xpc_object_t value = xpc_int64_get_value(v15);
      uint64_t v36 = value;
      if (!value)
      {
        unint64_t v42 = 0;
LABEL_139:

        goto LABEL_175;
      }

      if (!(value >> 31))
      {
        __nwlog_obj();
        __int16 v37 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446466;
        unsigned __int16 v91 = "networkd_privileged_reload_managed_network_settings";
        int v92 = 1024;
        *(_DWORD *)char v93 = v36;
        char v38 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        unsigned int v88 = 0;
        if (__nwlog_fault(v38, &type, &v88))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v40 = type;
            if (os_log_type_enabled(v39, type))
            {
              *(_DWORD *)buf = 136446466;
              unsigned __int16 v91 = "networkd_privileged_reload_managed_network_settings";
              int v92 = 1024;
              *(_DWORD *)char v93 = v36;
              _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s received failure result code %{darwin.errno}d",  buf,  0x12u);
            }
          }

          else if (v88)
          {
            __int16 v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v70 = type;
            uint64_t v71 = os_log_type_enabled(v39, type);
            if (v69)
            {
              if (v71)
              {
                *(_DWORD *)buf = 136446722;
                unsigned __int16 v91 = "networkd_privileged_reload_managed_network_settings";
                int v92 = 1024;
                *(_DWORD *)char v93 = v36;
                *(_WORD *)&v93[4] = 2082;
                *(void *)&v93[6] = v69;
                _os_log_impl( &dword_181A5C000,  v39,  v70,  "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
              }

              free(v69);
              if (!v38) {
                goto LABEL_138;
              }
LABEL_185:
              __int128 v68 = (char *)v38;
              goto LABEL_137;
            }

            if (v71)
            {
              *(_DWORD *)buf = 136446466;
              unsigned __int16 v91 = "networkd_privileged_reload_managed_network_settings";
              int v92 = 1024;
              *(_DWORD *)char v93 = v36;
              _os_log_impl( &dword_181A5C000,  v39,  v70,  "%{public}s received failure result code %{darwin.errno}d, no backtrace",  buf,  0x12u);
            }
          }

          else
          {
            __nwlog_obj();
            uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            unsigned int v77 = type;
            if (os_log_type_enabled(v39, type))
            {
              *(_DWORD *)buf = 136446466;
              unsigned __int16 v91 = "networkd_privileged_reload_managed_network_settings";
              int v92 = 1024;
              *(_DWORD *)char v93 = v36;
              _os_log_impl( &dword_181A5C000,  v39,  v77,  "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
            }
          }
        }

              _Block_object_dispose(buf, 8);
              if ((v121 & 1) != 0 && v120) {
                os_release(v120);
              }
              os_release(v24);
LABEL_219:
              _Block_object_dispose(&v99, 8);
              if ((v105 & 1) != 0 && v104) {
                os_release(v104);
              }
              os_release(v12);
              if (v33)
              {
                (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 2LL, a3);
                return;
              }

              goto LABEL_15;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)unsigned int v122 = 136446210;
            *(void *)&v122[4] = "nw_http_redirect_process";
            char v53 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v109[0]) = 0;
            if (__nwlog_fault(v53, type, v109))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v54 = (os_log_s *)gLogObj;
                int v55 = type[0];
                if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                  goto LABEL_82;
                }
                *(_DWORD *)unsigned int v122 = 136446210;
                *(void *)&v122[4] = "nw_http_redirect_process";
                uint64_t v56 = "%{public}s Unable to create new request metadata";
                goto LABEL_81;
              }

              if (!LOBYTE(v109[0]))
              {
                uint64_t v54 = (os_log_s *)__nwlog_obj();
                int v55 = type[0];
                if (!os_log_type_enabled(v54, type[0])) {
                  goto LABEL_82;
                }
                *(_DWORD *)unsigned int v122 = 136446210;
                *(void *)&v122[4] = "nw_http_redirect_process";
                uint64_t v56 = "%{public}s Unable to create new request metadata, backtrace limit exceeded";
                goto LABEL_81;
              }

              uint64_t v57 = (char *)__nw_create_backtrace_string();
              uint64_t v54 = (os_log_s *)__nwlog_obj();
              int v55 = type[0];
              char v58 = os_log_type_enabled(v54, type[0]);
              if (v57)
              {
                if (v58)
                {
                  *(_DWORD *)unsigned int v122 = 136446466;
                  *(void *)&v122[4] = "nw_http_redirect_process";
                  *(_WORD *)&v122[12] = 2082;
                  *(void *)&v122[14] = v57;
                  _os_log_impl( &dword_181A5C000,  v54,  v55,  "%{public}s Unable to create new request metadata, dumping backtrace:%{public}s",  v122,  0x16u);
                }

                free(v57);
                goto LABEL_82;
              }

              if (v58)
              {
                *(_DWORD *)unsigned int v122 = 136446210;
                *(void *)&v122[4] = "nw_http_redirect_process";
                uint64_t v56 = "%{public}s Unable to create new request metadata, no backtrace";
LABEL_81:
                _os_log_impl(&dword_181A5C000, v54, v55, v56, v122, 0xCu);
              }
            }

        free(v37);
        goto LABEL_85;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v38 = (os_log_s *)(id)gLogObj;
      unsigned int v76 = type[0];
      if (os_log_type_enabled(v38, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_framer_prepend_application_protocol_inner";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v15;
        _os_log_impl( &dword_181A5C000,  v38,  v76,  "%{public}s nw_framer_create_protocol_for_definition(%{public}@) failed, backtrace limit exceeded",  buf,  0x16u);
      }
    }

    goto LABEL_83;
  }

  os_log_type_t v25 = *((unsigned __int16 *)v5 + 302);
  if (v25 != 0xFFFF) {
    *((_WORD *)v5 + 302) = v25 + 1;
  }
  unsigned int v149 = nw_parameters_copy_default_protocol_stack(*((nw_parameters_t *)v5 + 45));
  uint64_t v26 = nw_framer_copy_options((nw_framer_t)v5);
  uint64_t v27 = v149;
  uint64_t v28 = v150;
  uint64_t v29 = v26;
  os_log_type_t v151 = v27;
  __int16 v152 = v29;
  if (!v27)
  {
    __nwlog_obj();
    nw_endpoint_t v114 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
    BOOL v115 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v167) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v117 = type[0];
      if (os_log_type_enabled(v116, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
        _os_log_impl(&dword_181A5C000, v116, v117, "%{public}s called with null stack", buf, 0xCu);
      }
    }

    else if ((_BYTE)v167)
    {
      unsigned int v123 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v124 = type[0];
      nw_endpoint_t v125 = os_log_type_enabled(v116, type[0]);
      if (v123)
      {
        if (v125)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v123;
          _os_log_impl( &dword_181A5C000,  v116,  v124,  "%{public}s called with null stack, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v123);
LABEL_242:
        if (!v115) {
          goto LABEL_32;
        }
        goto LABEL_243;
      }

      if (v125)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
        _os_log_impl(&dword_181A5C000, v116, v124, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v144 = type[0];
      if (os_log_type_enabled(v116, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_insert_application_protocol_before";
        _os_log_impl( &dword_181A5C000,  v116,  v144,  "%{public}s called with null stack, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v40) {
      free(v40);
    }
    uint64_t v27 = 0;
    goto LABEL_22;
  }

  if ((v11[405] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_attach_protocol";
      char v63 = 2082;
      uint64_t v64 = v11 + 407;
      uint64_t v65 = 2080;
      __int128 v66 = " ";
      uint64_t v67 = 2048;
      __int128 v68 = a5;
      __int16 v69 = 2114;
      uint64_t v70 = v12;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sPath %lx could not create protocol for %{public}@",  buf,  0x34u);
    }
  }

  unsigned int v20 = 0LL;
LABEL_36:

  return v20;
}

                      goto LABEL_85;
                    }

                    if (v129[0] == OS_LOG_TYPE_DEFAULT)
                    {
                      __nwlog_obj();
                      uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      uint64_t v51 = type[0];
                      if (os_log_type_enabled(v46, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        uint32x4_t v135 = "nw_protocol_implementation_connected";
                        _os_log_impl( &dword_181A5C000,  v46,  v51,  "%{public}s called with null instance->parent_definition->start, backtrace limit exceeded",  buf,  0xCu);
                      }

                      goto LABEL_84;
                    }

                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    int v49 = type[0];
                    uint32_t v50 = os_log_type_enabled(v46, type[0]);
                    if (!backtrace_string)
                    {
                      if (v50)
                      {
                        *(_DWORD *)buf = 136446210;
                        uint32x4_t v135 = "nw_protocol_implementation_connected";
                        _os_log_impl( &dword_181A5C000,  v46,  v49,  "%{public}s called with null instance->parent_definition->start, no backtrace",  buf,  0xCu);
                      }

                      goto LABEL_84;
                    }

                    if (v50)
                    {
                      *(_DWORD *)buf = 136446466;
                      uint32x4_t v135 = "nw_protocol_implementation_connected";
                      unsigned int v136 = 2082;
                      os_log_type_t v137 = backtrace_string;
                      _os_log_impl( &dword_181A5C000,  v46,  v49,  "%{public}s called with null instance->parent_definition->start, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    goto LABEL_76;
                  }

                  v7[402] = v31 | 0x28;
                  __int16 v35 = a1->default_input_handler;
                  if (v35)
                  {
                    uint64_t v36 = v35->handle;
                    if (v36 == &nw_protocol_ref_counted_handle)
                    {
                      char v38 = v35[1].callbacks;
                      if (v38) {
                        v35[1].callbacks = (nw_protocol_callbacks *)((char *)&v38->add_input_handler + 1);
                      }
                      __int16 v37 = -1;
                    }

                    else
                    {
                      __int16 v37 = 0;
                    }

                    *(void *)os_log_type_t type = v35;
                    int64x2_t v133 = v37;
                    uint64_t v39 = a1->handle;
                    if (v39 == &nw_protocol_ref_counted_handle)
                    {
                      __int16 v41 = a1[1].callbacks;
                      if (v41) {
                        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v41->add_input_handler + 1);
                      }
                      uint64_t v40 = -1;
                    }

                    else
                    {
                      uint64_t v40 = 0;
                    }

                    *(void *)BOOL v129 = a1;
                    int64x2_t v130 = v40;
                    unint64_t v42 = v35->callbacks;
                    if (v42)
                    {
                      uint64_t v43 = (void (*)(nw_protocol *, nw_protocol *))v42->connected;
                      if (v43)
                      {
                        v43(v35, a1);
LABEL_63:
                        if (v39 == &nw_protocol_ref_counted_handle) {
                          nw::release_if_needed<nw_protocol *>((uint64_t *)v129);
                        }
                        if (v36 == &nw_protocol_ref_counted_handle) {
                          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                        }
                        goto LABEL_42;
                      }
                    }

                    __nwlog_obj();
                    id v100 = (void *)objc_claimAutoreleasedReturnValue();
                    name = v35->identifier->name;
                    *(_DWORD *)buf = 136446722;
                    uint32x4_t v135 = "__nw_protocol_connected";
                    if (!name) {
                      name = "invalid";
                    }
                    unsigned int v136 = 2082;
                    os_log_type_t v137 = (void *)name;
                    int v138 = 2048;
                    char v139 = (const char *)v35;
                    char v102 = (char *)_os_log_send_and_compose_impl();

                    id v131 = OS_LOG_TYPE_ERROR;
                    int v128 = 0;
                    if (__nwlog_fault(v102, &v131, &v128))
                    {
                      if (v131 == OS_LOG_TYPE_FAULT)
                      {
                        __nwlog_obj();
                        unsigned int v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        __int16 v104 = v131;
                        if (os_log_type_enabled(v103, v131))
                        {
                          __int32 v105 = v35->identifier->name;
                          if (!v105) {
                            __int32 v105 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          uint32x4_t v135 = "__nw_protocol_connected";
                          unsigned int v136 = 2082;
                          os_log_type_t v137 = (void *)v105;
                          int v138 = 2048;
                          char v139 = (const char *)v35;
                          _os_log_impl( &dword_181A5C000,  v103,  v104,  "%{public}s protocol %{public}s (%p) has invalid connected callback",  buf,  0x20u);
                        }
                      }

                      else if (v128)
                      {
                        id v113 = (char *)__nw_create_backtrace_string();
                        __nwlog_obj();
                        unsigned int v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        nw_endpoint_t v114 = v131;
                        BOOL v115 = os_log_type_enabled(v103, v131);
                        if (v113)
                        {
                          if (v115)
                          {
                            id v116 = v35->identifier->name;
                            if (!v116) {
                              id v116 = "invalid";
                            }
                            *(_DWORD *)buf = 136446978;
                            uint32x4_t v135 = "__nw_protocol_connected";
                            unsigned int v136 = 2082;
                            os_log_type_t v137 = (void *)v116;
                            int v138 = 2048;
                            char v139 = (const char *)v35;
                            v140 = 2082;
                            uint64_t v141 = v113;
                            _os_log_impl( &dword_181A5C000,  v103,  v114,  "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                          }

                          free(v113);
                          goto LABEL_254;
                        }

                        if (v115)
                        {
                          char v121 = v35->identifier->name;
                          if (!v121) {
                            char v121 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          uint32x4_t v135 = "__nw_protocol_connected";
                          unsigned int v136 = 2082;
                          os_log_type_t v137 = (void *)v121;
                          int v138 = 2048;
                          char v139 = (const char *)v35;
                          _os_log_impl( &dword_181A5C000,  v103,  v114,  "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace",  buf,  0x20u);
                        }
                      }

                      else
                      {
                        __nwlog_obj();
                        unsigned int v103 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        int v119 = v131;
                        if (os_log_type_enabled(v103, v131))
                        {
                          int v120 = v35->identifier->name;
                          if (!v120) {
                            int v120 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          uint32x4_t v135 = "__nw_protocol_connected";
                          unsigned int v136 = 2082;
                          os_log_type_t v137 = (void *)v120;
                          int v138 = 2048;
                          char v139 = (const char *)v35;
                          _os_log_impl( &dword_181A5C000,  v103,  v119,  "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded",  buf,  0x20u);
                        }
                      }
                    }

  return 1LL;
}

            nw_protocol_stack_prepend_application_protocol((nw_protocol_stack_t)stack, (nw_protocol_options_t)options);
            uint64_t v57 = nw_array_create();
            if (!v26 || !v32)
            {
LABEL_88:
              if (!v21 || !v32) {
                goto LABEL_97;
              }
              if (nw_get_http3_override_onceToken != -1) {
                dispatch_once(&nw_get_http3_override_onceToken, &__block_literal_global_8_72852);
              }
              if (nw_get_http3_override_value != 1)
              {
                uint32_t v62 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_transform);
                if (!v62)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  int v92 = (id)gLogObj;
                  *(_DWORD *)buf = 136446210;
                  v163 = "nw_parameters_create_secure_http_messaging";
                  int32x4_t v84 = (const char *)_os_log_send_and_compose_impl();

                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  id v160 = 0;
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    nw_endpoint_t v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    char v93 = type;
                    if (os_log_type_enabled(v85, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      v163 = "nw_parameters_create_secure_http_messaging";
                      _os_log_impl( &dword_181A5C000,  v85,  v93,  "%{public}s nw_protocol_transform_create failed",  buf,  0xCu);
                    }

                    goto LABEL_193;
                  }

                  if (!v160)
                  {
                    __nwlog_obj();
                    nw_endpoint_t v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    int v107 = type;
                    if (os_log_type_enabled(v85, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      v163 = "nw_parameters_create_secure_http_messaging";
                      _os_log_impl( &dword_181A5C000,  v85,  v107,  "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded",  buf,  0xCu);
                    }

                    goto LABEL_193;
                  }

                  int v101 = __nw_create_backtrace_string();
                  __nwlog_obj();
                  uint64_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  char v102 = type;
                  unsigned int v103 = os_log_type_enabled(v95, type);
                  os_log_type_t v153 = (char *)v101;
                  if (v101)
                  {
                    if (v103)
                    {
                      *(_DWORD *)buf = 136446466;
                      v163 = "nw_parameters_create_secure_http_messaging";
                      nw_endpoint_t v164 = 2082;
                      v165 = (char *)v101;
                      _os_log_impl( &dword_181A5C000,  v95,  v102,  "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    goto LABEL_163;
                  }

                  if (v103)
                  {
                    *(_DWORD *)buf = 136446210;
                    v163 = "nw_parameters_create_secure_http_messaging";
                    _os_log_impl( &dword_181A5C000,  v95,  v102,  "%{public}s nw_protocol_transform_create failed, no backtrace",  buf,  0xCu);
                  }

                  goto LABEL_196;
                }

                char v63 = v62;
                *((_BYTE *)v63 + 8) |= 2u;

                uint64_t v64 = nw_protocol_options_copy(v21);
                nw_protocol_transform_append_protocol(v63, 4, v64);

                nw_protocol_transform_append_protocol(v63, 3, v32);
                nw_protocol_transform_add_match_url_scheme(v63, "https");
                nw_protocol_transform_add_match_url_scheme(v63, "wss");
                uint64_t v65 = v63;
                *((_BYTE *)v63 + 8) |= 0x10u;

                nw_array_append(v57, v65);
              }

              __int128 v66 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_transform);
              if (v66)
              {
                uint64_t v67 = v66;
                *((_BYTE *)v67 + 8) |= 2u;

                nw_protocol_transform_append_protocol(v67, 3, v32);
                nw_protocol_transform_add_match_url_scheme(v67, "http");
                nw_protocol_transform_add_match_url_scheme(v67, "ws");
                __int128 v68 = v67;
                *((_BYTE *)v67 + 8) |= 0x10u;

                nw_array_append(v57, v68);
LABEL_97:
                if (v57 && *(void *)(v57 + 24) != *(void *)(v57 + 16)) {
                  nw_parameters_set_transform_array(v14, (void *)v57);
                }
                nw_parameters_set_data_mode(v14, 2u);
                __int16 v69 = v14;
                goto LABEL_201;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v83 = (id)gLogObj;
              *(_DWORD *)buf = 136446210;
              v163 = "nw_parameters_create_secure_http_messaging";
              int32x4_t v84 = (const char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              id v160 = 0;
              if (!__nwlog_fault(v84, &type, &v160))
              {
LABEL_197:
                if (v84)
                {
                  nw_endpoint_t v106 = (char *)v84;
                  goto LABEL_199;
                }

                goto LABEL_200;
              }

              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                nw_endpoint_t v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                unsigned int v86 = type;
                if (os_log_type_enabled(v85, type))
                {
                  *(_DWORD *)buf = 136446210;
                  v163 = "nw_parameters_create_secure_http_messaging";
                  _os_log_impl(&dword_181A5C000, v85, v86, "%{public}s nw_protocol_transform_create failed", buf, 0xCu);
                }

      if (!v16) {
        return 0LL;
      }
      uint64_t v15 = (char *)v16;
      goto LABEL_30;
    }

    if (!v26)
    {
      unint64_t v17 = (os_log_s *)__nwlog_obj();
      uint64_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_http_client_bottom_replace_input_handler";
        uint64_t v19 = "%{public}s called with null new_input_protocol, backtrace limit exceeded";
        goto LABEL_83;
      }

      goto LABEL_84;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v17 = (os_log_s *)__nwlog_obj();
    uint64_t v18 = type;
    os_log_type_t v25 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_http_client_bottom_replace_input_handler";
        uint64_t v19 = "%{public}s called with null new_input_protocol, no backtrace";
        goto LABEL_83;
      }

      goto LABEL_84;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_http_client_bottom_replace_input_handler";
      uint64_t v30 = 2082;
      BOOL v31 = (nw_protocol *)backtrace_string;
      unint64_t v22 = "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s";
      goto LABEL_65;
    }

    if (!v6) {
      return;
    }
    goto LABEL_85;
  }

  multipath_service = nw_parameters_get_multipath_service((nw_parameters_t)v3);
  os_log_type_t v11 = *(uint64_t **)(*(void *)(a1 + 32) + 16LL);
  if (multipath_service)
  {
    if ((nw_parameters_get_server_mode(v11) & 1) != 0)
    {
      unint64_t v12 = *(void *)(a1 + 32);
      if (*(void *)(a1 + 40) && !*(void *)(v12 + 56))
      {
        uint64_t v13 = *(void *)(v12 + 16);
        if (v13 && !nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v14 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            uint64_t v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)buf = 136446466;
            int v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
            uint64_t v46 = 1024;
            uint64_t v47 = v15;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Starting server side candidate manager",  buf,  0x12u);
          }
        }

        uint64_t v16 = nw_candidate_manager_create_with_connection(*(void **)(a1 + 32), 0LL);
        unint64_t v17 = *(void **)(*(void *)(a1 + 32) + 56LL);
        *(void *)(*(void *)(a1 + 32) + 56LL) = v16;

        unint64_t v12 = *(void *)(a1 + 32);
        if (!*(void *)(v12 + 56))
        {
          uint64_t v18 = *(void *)(v12 + 16);
          if (!v18 || nw_path_parameters_get_logging_disabled(*(void *)(v18 + 104))) {
            return;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v19 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            unsigned int v20 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)buf = 136446466;
            int v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
            uint64_t v46 = 1024;
            uint64_t v47 = v20;
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Failed to create candidate manager",  buf,  0x12u);
          }

          goto LABEL_31;
        }
      }
    }

    else
    {
      unint64_t v12 = *(void *)(a1 + 32);
    }

    uint64_t v29 = *(void **)(v12 + 56);
    if (v29)
    {
      nw_candidate_manager_set_internet_fallback(v29, *(void **)(a1 + 40));
      return;
    }

    uint64_t v30 = *(void *)(v12 + 16);
    if (!v30 || nw_path_parameters_get_logging_disabled(*(void *)(v30 + 104))) {
      return;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v19 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      BOOL v31 = *(char **)(a1 + 40);
      mach_vm_address_t v32 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446722;
      int v45 = "nw_connection_set_internet_fallback_endpoint_block_invoke";
      uint64_t v46 = 1024;
      uint64_t v47 = v32;
      id v48 = 2112;
      int v49 = v31;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] No candidate manager present, can't set internet fallback %@",  buf,  0x1Cu);
    }

    goto LABEL_85;
  }

  unsigned int v6 = (unsigned int *)v4;
  uint64_t v7 = v6[29];

  if ((_DWORD)v7 != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v20 = (id)gLogObj;
    else {
      char v21 = off_189BBBBC0[v7];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v21;
    *(_WORD *)&_BYTE buf[22] = 2082;
    id v116 = "proxy";
    unint64_t v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    uint64_t v110 = 0;
    if (__nwlog_fault(v22, type, &v110))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v23 = (os_log_s *)(id)gLogObj;
        int v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          else {
            os_log_type_t v25 = off_189BBBBC0[v7];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v25;
          *(_WORD *)&_BYTE buf[22] = 2082;
          id v116 = "proxy";
          _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v110)
      {
        uint64_t v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v23 = (os_log_s *)(id)gLogObj;
        uint64_t v40 = type[0];
        __int16 v41 = os_log_type_enabled(v23, type[0]);
        if (v39)
        {
          if (v41)
          {
            else {
              unint64_t v42 = off_189BBBBC0[v7];
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v42;
            *(_WORD *)&_BYTE buf[22] = 2082;
            id v116 = "proxy";
            *(_WORD *)nw_endpoint_t v117 = 2082;
            *(void *)&v117[2] = v39;
            _os_log_impl( &dword_181A5C000,  v23,  v40,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v39);
          if (!v22) {
            goto LABEL_87;
          }
LABEL_86:
          free(v22);
          goto LABEL_87;
        }

        if (v41)
        {
          else {
            int v49 = off_189BBBBC0[v7];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v49;
          *(_WORD *)&_BYTE buf[22] = 2082;
          id v116 = "proxy";
          _os_log_impl( &dword_181A5C000,  v23,  v40,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v23 = (os_log_s *)(id)gLogObj;
        uint64_t v43 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          else {
            uint64_t v44 = off_189BBBBC0[v7];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v44;
          *(_WORD *)&_BYTE buf[22] = 2082;
          id v116 = "proxy";
          _os_log_impl( &dword_181A5C000,  v23,  v43,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }

      goto LABEL_84;
    }

LABEL_85:
      if (!v206)
      {
LABEL_109:
        id v116 = *((void *)v5 + 1);
        if (v116
          && ((unsigned int v118 = v116 + 16,
               id v116 = *(void *)(v116 + 16),
               nw_endpoint_t v117 = *(void *)(v118 + 8),
               int v119 = v117 == v116,
               LOBYTE(v116) = v117 != v116,
               !v119)
            ? (int v120 = has_unresolved_proxies)
            : (int v120 = 0),
              v120))
        {
          if (nw_endpoint_handler_get_minimize_logging(v192))
          {
            if ((nw_endpoint_handler_get_logging_disabled(v192) & 1) == 0)
            {
              id v168 = v5;
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              int v169 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v169, OS_LOG_TYPE_DEBUG))
              {
                id_string = nw_endpoint_handler_get_id_string(v192);
                char v171 = nw_endpoint_handler_dry_run_string(v192);
                v172 = nw_endpoint_handler_copy_endpoint(v192);
                v173 = nw_endpoint_get_logging_description(v172);
                id v174 = nw_endpoint_handler_state_string(v192);
                v175 = nw_endpoint_handler_mode_string(v192);
                nw_endpoint_t v176 = nw_endpoint_handler_copy_current_path(v192);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = id_string;
                *(_WORD *)&_BYTE buf[22] = 2082;
                v208 = (uint64_t (*)(uint64_t, uint64_t))v171;
                *(_WORD *)v209 = 2082;
                *(void *)&v209[2] = v173;
                *(_WORD *)&v209[10] = 2082;
                *(void *)&v209[12] = v174;
                v210 = 2082;
                v211 = (void *)v175;
                v212 = 2114;
                v213 = v176;
                _os_log_impl( &dword_181A5C000,  v169,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] direct already adding , still waiting for proxy resolution",  buf,  0x48u);
              }

              unsigned int v5 = v168;
            }
          }

          else
          {
            char v121 = v192;
            unsigned int v122 = (*((_BYTE *)v121 + 268) & 0x20) == 0;

            if (v122)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              unsigned int v123 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v123, OS_LOG_TYPE_INFO))
              {
                uint64_t v124 = v121;

                nw_endpoint_t v125 = v124;
                unsigned int v126 = (*((_BYTE *)v121 + 268) & 1) == 0;

                if (v126) {
                  uint64_t v127 = "";
                }
                else {
                  uint64_t v127 = "dry-run ";
                }
                int v128 = nw_endpoint_handler_copy_endpoint(v125);
                BOOL v129 = nw_endpoint_get_logging_description(v128);
                int64x2_t v130 = v125;
                id v131 = v130;
                id v132 = v130[30];
                else {
                  int64x2_t v133 = off_189BBBBF0[v132];
                }

                os_log_type_t v137 = v131;
                int v138 = "path";
                switch(v192->mode)
                {
                  case 0:
                    break;
                  case 1:
                    int v138 = "resolver";
                    break;
                  case 2:
                    int v138 = nw_endpoint_flow_mode_string(v137[31]);
                    break;
                  case 3:
                    int v138 = "proxy";
                    break;
                  case 4:
                    int v138 = "fallback";
                    break;
                  case 5:
                    int v138 = "transform";
                    break;
                  default:
                    int v138 = "unknown-mode";
                    break;
                }

                uint64_t v194 = v138;

                char v139 = v5;
                v140 = v137;
                os_unfair_lock_lock((os_unfair_lock_t)v140 + 28);
                uint64_t v141 = v140[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v140 + 28);

                unsigned int v5 = v139;
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v124->id_str;
                *(_WORD *)&_BYTE buf[22] = 2082;
                v208 = (uint64_t (*)(uint64_t, uint64_t))v127;
                *(_WORD *)v209 = 2082;
                *(void *)&v209[2] = v129;
                *(_WORD *)&v209[10] = 2082;
                *(void *)&v209[12] = v133;
                v210 = 2082;
                v211 = (void *)v194;
                v212 = 2114;
                v213 = v141;
                _os_log_impl( &dword_181A5C000,  v123,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] direct already adding , still waiting for proxy resolution",  buf,  0x48u);
              }
            }
          }
        }

        else
        {
          *(void *)os_log_type_t type = 0LL;
          int v203 = type;
          __int16 v204 = 0x2020000000LL;
          os_log_type_t v205 = 0;
          *(void *)buf = 0LL;
          *(void *)&buf[8] = buf;
          *(void *)&buf[16] = 0x3032000000LL;
          v208 = __Block_byref_object_copy__26348;
          *(void *)v209 = __Block_byref_object_dispose__26349;
          *(void *)&v209[8] = 0LL;
          int64x2_t v134 = v5;
          uint32x4_t v135 = (unsigned __int8 *)*((void *)v5 + 7);
          v195[0] = MEMORY[0x1895F87A8];
          v195[1] = 3221225472LL;
          v195[2] = ___ZL34nw_endpoint_proxy_complete_resolveP30NWConcrete_nw_endpoint_handler_block_invoke_147;
          v195[3] = &unk_189BB9F18;
          id v199 = v116;
          os_log_type_t v197 = type;
          unsigned int v136 = v192;
          char v196 = v136;
          os_log_type_t v198 = buf;
          __int16 v200 = has_unresolved_proxies;
          nw_array_apply(v135, (uint64_t)v195);
          nw_endpoint_proxy_start_next_child(v136);

          unsigned int v5 = v134;
          _Block_object_dispose(buf, 8);

          _Block_object_dispose(type, 8);
        }

        goto LABEL_143;
      }

      if (nw_endpoint_handler_get_minimize_logging(v192))
      {
        __int16 v152 = v5;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint32_t v99 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v153 = nw_endpoint_handler_get_id_string(v192);
          BOOL v154 = nw_endpoint_handler_dry_run_string(v192);
          os_log_type_t v155 = nw_endpoint_handler_copy_endpoint(v192);
          nw_endpoint_t v156 = nw_endpoint_get_logging_description(v155);
          int v157 = nw_endpoint_handler_state_string(v192);
          uint64_t v158 = nw_endpoint_handler_mode_string(v192);
          v159 = nw_endpoint_handler_copy_current_path(v192);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v153;
          *(_WORD *)&_BYTE buf[22] = 2082;
          v208 = (uint64_t (*)(uint64_t, uint64_t))v154;
          *(_WORD *)v209 = 2082;
          *(void *)&v209[2] = v156;
          *(_WORD *)&v209[10] = 2082;
          *(void *)&v209[12] = v157;
          v210 = 2082;
          v211 = (void *)v158;
          v212 = 2114;
          v213 = v159;
          _os_log_impl( &dword_181A5C000,  v99,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no resolved proxies, adding direct attempt",  buf,  0x48u);

          unsigned int v5 = v152;
        }
      }

      else
      {
        int v97 = v192;
        uint64_t v98 = (*((_BYTE *)v97 + 268) & 0x20) == 0;

        if (!v98)
        {
LABEL_106:
          direct = nw_proxy_config_create_direct();
          if (direct) {
            nw_array_append(*((void *)v5 + 7), direct);
          }

          goto LABEL_109;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint32_t v99 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
        {
          id v100 = v97;

          int v101 = v100;
          char v102 = (*((_BYTE *)v97 + 268) & 1) == 0;

          if (v102) {
            unsigned int v103 = "";
          }
          else {
            unsigned int v103 = "dry-run ";
          }
          __int16 v104 = nw_endpoint_handler_copy_endpoint(v101);
          __int32 v105 = nw_endpoint_get_logging_description(v104);
          nw_endpoint_t v106 = v101;
          int v107 = v106;
          uint64_t v108 = v106[30];
          else {
            BOOL v109 = off_189BBBBF0[v108];
          }

          uint64_t v110 = v107;
          id v111 = "path";
          switch(v192->mode)
          {
            case 0:
              break;
            case 1:
              id v111 = "resolver";
              break;
            case 2:
              id v111 = nw_endpoint_flow_mode_string(v110[31]);
              break;
            case 3:
              id v111 = "proxy";
              break;
            case 4:
              id v111 = "fallback";
              break;
            case 5:
              id v111 = "transform";
              break;
            default:
              id v111 = "unknown-mode";
              break;
          }

          parametersa = (nw_parameters_t)v111;

          BOOL v112 = v5;
          id v113 = v110;
          os_unfair_lock_lock((os_unfair_lock_t)v113 + 28);
          nw_endpoint_t v114 = v113[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v113 + 28);

          unsigned int v5 = v112;
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v100->id_str;
          *(_WORD *)&_BYTE buf[22] = 2082;
          v208 = (uint64_t (*)(uint64_t, uint64_t))v103;
          *(_WORD *)v209 = 2082;
          *(void *)&v209[2] = v105;
          *(_WORD *)&v209[10] = 2082;
          *(void *)&v209[12] = v109;
          v210 = 2082;
          v211 = parametersa;
          v212 = 2114;
          v213 = v114;
          _os_log_impl( &dword_181A5C000,  v99,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no resolved proxies, adding direct attempt",  buf,  0x48u);
        }
      }

      goto LABEL_106;
    }

    unsigned int v6 = v3;
    parameters = (os_log_s *)v6[4];

    if (nw_parameters_get_prefer_no_proxy(parameters))
    {
      *(void *)os_log_type_t type = 0LL;
      int v203 = type;
      __int16 v204 = 0x2020000000LL;
      os_log_type_t v205 = 0;
      uint64_t v7 = (unsigned __int8 *)*((void *)v5 + 7);
      v201[0] = MEMORY[0x1895F87A8];
      v201[1] = 3221225472LL;
      v201[2] = ___ZL34nw_endpoint_proxy_complete_resolveP30NWConcrete_nw_endpoint_handler_block_invoke;
      v201[3] = &unk_189BC50D0;
      v201[4] = type;
      nw_array_apply(v7, (uint64_t)v201);
      if (!*((_BYTE *)v203 + 24))
      {
        uint64_t v51 = v6;
        os_log_type_t v52 = (*((_BYTE *)v51 + 268) & 0x20) == 0;

        if (v52)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v53 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            uint64_t v54 = v51;

            int v55 = v54;
            uint64_t v56 = (*((_BYTE *)v51 + 268) & 1) == 0;

            if (v56) {
              uint64_t v57 = "";
            }
            else {
              uint64_t v57 = "dry-run ";
            }
            char v58 = nw_endpoint_handler_copy_endpoint(v55);
            int v59 = nw_endpoint_get_logging_description(v58);
            unsigned int v60 = v55;
            BOOL v61 = v60;
            uint32_t v62 = v60[30];
            else {
              char v63 = off_189BBBBF0[v62];
            }
            char v187 = v63;

            id v74 = v61;
            int v75 = v74;
            unsigned int v76 = "path";
            switch(v192->mode)
            {
              case 0:
                break;
              case 1:
                unsigned int v76 = "resolver";
                break;
              case 2:
                unsigned int v76 = nw_endpoint_flow_mode_string(v74[31]);
                break;
              case 3:
                unsigned int v76 = "proxy";
                break;
              case 4:
                unsigned int v76 = "fallback";
                break;
              case 5:
                unsigned int v76 = "transform";
                break;
              default:
                unsigned int v76 = "unknown-mode";
                break;
            }

            nw_endpoint_t v142 = v5;
            v143 = v75;
            os_unfair_lock_lock((os_unfair_lock_t)v143 + 28);
            uint64_t v144 = v143[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v143 + 28);

            unsigned int v5 = v142;
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v54 + 21;
            *(_WORD *)&_BYTE buf[22] = 2082;
            v208 = (uint64_t (*)(uint64_t, uint64_t))v57;
            *(_WORD *)v209 = 2082;
            *(void *)&v209[2] = v59;
            *(_WORD *)&v209[10] = 2082;
            *(void *)&v209[12] = v187;
            v210 = 2082;
            v211 = (void *)v76;
            v212 = 2114;
            v213 = v144;
            _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unresolved proxies and pr efer no proxy, but no direct config found",  buf,  0x48u);
          }
        }

        _Block_object_dispose(type, 8);

        goto LABEL_143;
      }

      if (nw_endpoint_handler_get_minimize_logging(v6))
      {
        os_log_type_t v177 = v6;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unsigned int v10 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v178 = nw_endpoint_handler_get_id_string(v177);
          v179 = nw_endpoint_handler_dry_run_string(v177);
          id v180 = nw_endpoint_handler_copy_endpoint(v177);
          v181 = nw_endpoint_get_logging_description(v180);
          nw_endpoint_t v182 = nw_endpoint_handler_state_string(v177);
          char v183 = nw_endpoint_handler_mode_string(v177);
          uint64_t v184 = nw_endpoint_handler_copy_current_path(v177);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v178;
          *(_WORD *)&_BYTE buf[22] = 2082;
          v208 = (uint64_t (*)(uint64_t, uint64_t))v179;
          *(_WORD *)v209 = 2082;
          *(void *)&v209[2] = v181;
          *(_WORD *)&v209[10] = 2082;
          *(void *)&v209[12] = v182;
          v210 = 2082;
          v211 = (void *)v183;
          v212 = 2114;
          v213 = v184;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unresolved proxies, but wil l add direct due to prefer no proxy",  buf,  0x48u);
        }
      }

      else
      {
        uint64_t v8 = v6;
        unint64_t v9 = (*((_BYTE *)v8 + 268) & 0x20) == 0;

        if (!v9)
        {
LABEL_83:
          _Block_object_dispose(type, 8);
          goto LABEL_84;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unsigned int v10 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v11 = v8;

          unint64_t v12 = v11;
          uint64_t v13 = (*((_BYTE *)v8 + 268) & 1) == 0;

          if (v13) {
            char v14 = "";
          }
          else {
            char v14 = "dry-run ";
          }
          uint64_t v15 = nw_endpoint_handler_copy_endpoint(v12);
          uint64_t v16 = nw_endpoint_get_logging_description(v15);
          unint64_t v17 = v12;
          uint64_t v18 = v17;
          uint64_t v19 = v17[30];
          else {
            unsigned int v20 = off_189BBBBF0[v19];
          }

          __int128 v66 = v18;
          uint64_t v67 = "path";
          switch(v3->mode)
          {
            case 0:
              break;
            case 1:
              uint64_t v67 = "resolver";
              break;
            case 2:
              uint64_t v67 = nw_endpoint_flow_mode_string(v66[31]);
              break;
            case 3:
              uint64_t v67 = "proxy";
              break;
            case 4:
              uint64_t v67 = "fallback";
              break;
            case 5:
              uint64_t v67 = "transform";
              break;
            default:
              uint64_t v67 = "unknown-mode";
              break;
          }

          v185 = v67;

          unsigned int v86 = v66;
          uint64_t v87 = (uint64_t (*)(uint64_t, uint64_t))v14;
          unsigned int v88 = v10;
          id v89 = v16;
          int v90 = v15;
          unsigned __int16 v91 = (id *)v86;
          int v92 = v5;
          char v93 = v86 + 28;
          os_unfair_lock_lock(v86 + 28);
          uint64_t v94 = v91[8];
          uint64_t v95 = v93;
          unsigned int v5 = v92;
          os_unfair_lock_unlock(v95);

          nw_endpoint_t v96 = v89;
          unsigned int v10 = v88;
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v11 + 21;
          *(_WORD *)&_BYTE buf[22] = 2082;
          v208 = v87;
          *(_WORD *)v209 = 2082;
          *(void *)&v209[2] = v96;
          *(_WORD *)&v209[10] = 2082;
          *(void *)&v209[12] = v20;
          v210 = 2082;
          v211 = (void *)v185;
          v212 = 2114;
          v213 = v94;
          _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unresolved proxies, but wil l add direct due to prefer no proxy",  buf,  0x48u);
        }
      }

      goto LABEL_83;
    }

    if (nw_endpoint_handler_get_minimize_logging(v6))
    {
      v161 = v6;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v37 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        v188 = nw_endpoint_handler_get_id_string(v6);
        BOOL v162 = nw_endpoint_handler_dry_run_string(v6);
        v163 = nw_endpoint_handler_copy_endpoint(v6);
        nw_endpoint_t v164 = nw_endpoint_get_logging_description(v163);
        v165 = nw_endpoint_handler_state_string(v161);
        uint64_t v166 = nw_endpoint_handler_mode_string(v161);
        os_log_type_t v167 = nw_endpoint_handler_copy_current_path(v161);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v188;
        *(_WORD *)&_BYTE buf[22] = 2082;
        v208 = (uint64_t (*)(uint64_t, uint64_t))v162;
        *(_WORD *)v209 = 2082;
        *(void *)&v209[2] = v164;
        *(_WORD *)&v209[10] = 2082;
        *(void *)&v209[12] = v165;
        v210 = 2082;
        v211 = (void *)v166;
        v212 = 2114;
        v213 = v167;
        _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unresolved proxies, waiting for resolution",  buf,  0x48u);
      }
    }

    else
    {
      __int16 v35 = v6;
      uint64_t v36 = (*((_BYTE *)v35 + 268) & 0x20) == 0;

      if (!v36)
      {
LABEL_75:

LABEL_143:
        int v2 = v189;
        goto LABEL_144;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v37 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
      {
        char v38 = v35;

        uint64_t v39 = v38;
        uint64_t v40 = (*((_BYTE *)v35 + 268) & 1) == 0;

        if (v40) {
          __int16 v41 = "";
        }
        else {
          __int16 v41 = "dry-run ";
        }
        unint64_t v42 = nw_endpoint_handler_copy_endpoint(v39);
        uint64_t v43 = nw_endpoint_get_logging_description(v42);
        uint64_t v44 = v39;
        int v45 = v44;
        uint64_t v46 = v44[30];
        else {
          uint64_t v47 = off_189BBBBF0[v46];
        }

        uint64_t v64 = v45;
        uint64_t v65 = "path";
        switch(v192->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v65 = "resolver";
            break;
          case 2:
            uint64_t v65 = nw_endpoint_flow_mode_string(v64[31]);
            break;
          case 3:
            uint64_t v65 = "proxy";
            break;
          case 4:
            uint64_t v65 = "fallback";
            break;
          case 5:
            uint64_t v65 = "transform";
            break;
          default:
            uint64_t v65 = "unknown-mode";
            break;
        }

        id v193 = v65;

        unsigned int v77 = v37;
        uint64_t v78 = v42;
        id v79 = v47;
        int v80 = v43;
        char v81 = (uint64_t (*)(uint64_t, uint64_t))v41;
        unsigned int v82 = v5;
        uint64_t v83 = v64;
        os_unfair_lock_lock((os_unfair_lock_t)v83 + 28);
        int32x4_t v84 = v83[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v83 + 28);

        unsigned int v5 = v82;
        nw_endpoint_t v85 = v78;
        __int16 v37 = v77;
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v38 + 21;
        *(_WORD *)&_BYTE buf[22] = 2082;
        v208 = v81;
        *(_WORD *)v209 = 2082;
        *(void *)&v209[2] = v80;
        *(_WORD *)&v209[10] = 2082;
        *(void *)&v209[12] = v79;
        v210 = 2082;
        v211 = (void *)v193;
        v212 = 2114;
        v213 = v84;
        _os_log_impl( &dword_181A5C000,  v77,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unresolved proxies, waiting for resolution",  buf,  0x48u);
      }
    }

    goto LABEL_75;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v21 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    else {
      unint64_t v22 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_complete_resolve";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v22;
    *(_WORD *)&_BYTE buf[22] = 2082;
    v208 = (uint64_t (*)(uint64_t, uint64_t))"proxy";
    _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_144:
}

    free(backtrace_string);
    goto LABEL_105;
  }

  unsigned int v5 = v3;
  unsigned int v6 = [v5 type];

  domain_for_policy = nw_endpoint_get_domain_for_policy(v5);
  if (v6 != 2)
  {
    if (v6 == 1)
    {
      mach_vm_address_t address = nw_endpoint_get_address((nw_endpoint_t)v5);
      unint64_t v9 = 0LL;
      goto LABEL_7;
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      uint32_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEBUG,  "%{public}s Invalid proxy endpoint type %u for matching",  buf,  0x12u);
      }
    }

      if (*((void *)handle + 48))
      {
        uint64_t v34 = nw_protocol_options_copy(v14);
        __int16 v35 = v34;
        if (*((void *)handle + 50)) {
          uint64_t v36 = (dispatch_data_s *)*((void *)handle + 50);
        }
        else {
          uint64_t v36 = (dispatch_data_s *)*((void *)handle + 48);
        }
        nw_demux_options_add_pattern_data(v34, 1, v36);
      }

      else
      {
        __int16 v37 = (void *)*((void *)handle + 56);
        if (v37) {
          __int16 v35 = nw_protocol_options_copy(v37);
        }
        else {
          __int16 v35 = 0LL;
        }
      }

      nw_parameters_set_protocol_instance(v35, v18, (uint64_t)v11);
      nw_protocol_options_inherit_log_id(v14, v35);
      char v38 = nw_parameters_copy_default_protocol_stack(*((nw_parameters_t *)handle + 53));
      uint64_t v39 = v38;
      if (v13) {
        nw_protocol_stack_replace_protocol_with_handle(v38, (uint64_t)v11, v35);
      }
      else {
        nw_protocol_stack_replace_protocol(v38, v12, v35);
      }
      if (v39) {
        os_release(v39);
      }
      if (v35) {
        os_release(v35);
      }
      goto LABEL_99;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v48 = "nw_protocol_masque_get_parameters";
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v45 = 0;
    if (__nwlog_fault(v26, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v27 = (os_log_s *)__nwlog_obj();
        uint64_t v28 = type;
        if (!os_log_type_enabled(v27, type)) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446210;
        id v48 = "nw_protocol_masque_get_parameters";
        uint64_t v29 = "%{public}s called with null masque->parameters";
        goto LABEL_78;
      }

      if (v45)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v27 = (os_log_s *)__nwlog_obj();
        uint64_t v28 = type;
        uint64_t v44 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (!v44) {
            goto LABEL_65;
          }
          *(_DWORD *)buf = 136446466;
          id v48 = "nw_protocol_masque_get_parameters";
          int v49 = 2082;
          uint32_t v50 = backtrace_string;
          mach_vm_address_t v32 = "%{public}s called with null masque->parameters, dumping backtrace:%{public}s";
          goto LABEL_64;
        }

        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          id v48 = "nw_protocol_masque_get_parameters";
          uint64_t v29 = "%{public}s called with null masque->parameters, no backtrace";
          goto LABEL_78;
        }
      }

      else
      {
        uint64_t v27 = (os_log_s *)__nwlog_obj();
        uint64_t v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          id v48 = "nw_protocol_masque_get_parameters";
          uint64_t v29 = "%{public}s called with null masque->parameters, backtrace limit exceeded";
LABEL_78:
          _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
        }
      }
    }

  uint32_t v50 = v7 + 120 * v8;
  *(void *)(v50 + 20_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(v50 + 216) = 0;
  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);

  return 1LL;
}

      free(backtrace_string);
      goto LABEL_98;
    }

    if (!v60) {
      goto LABEL_98;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
    int v55 = "%{public}s called with null return_array, no backtrace";
LABEL_97:
    _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
LABEL_98:
    if (v52) {
      free(v52);
    }
    return 0LL;
  }

  context_for_protocol = nw_protocol_ohttp_get_context_for_protocol((uint64_t)a1->handle, (uint64_t)a2);
  if (!context_for_protocol)
  {
    if ((handle[348] & 1) != 0) {
      return 0LL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v20 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)buf = 136446978;
    uint64_t v65 = "nw_protocol_ohttp_get_input_frames";
    __int128 v66 = 2082;
    uint64_t v67 = handle + 349;
    __int128 v68 = 2080;
    __int16 v69 = " ";
    uint64_t v70 = 2048;
    uint64_t v71 = a2;
    char v21 = "%{public}s %{public}s%sfailed to find context for %p";
    unint64_t v22 = (os_log_s *)v20;
    int v23 = OS_LOG_TYPE_ERROR;
    int v24 = 42;
    goto LABEL_22;
  }

  os_log_type_t v11 = context_for_protocol;
  if (*(_DWORD *)(context_for_protocol + 224) != 4)
  {
    os_log_type_t v25 = 0LL;
    if ((handle[348] & 1) != 0 || !gLogDatapath) {
      return v25;
    }
    uint64_t v26 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
      return 0LL;
    }
    uint64_t v27 = *(_DWORD *)(v11 + 224);
    *(_DWORD *)buf = 136446978;
    uint64_t v65 = "nw_ohttp_context_get_input_frames";
    __int128 v66 = 2082;
    uint64_t v67 = handle + 349;
    __int128 v68 = 2080;
    __int16 v69 = " ";
    uint64_t v70 = 1024;
    LODWORD(v71) = v27;
    char v21 = "%{public}s %{public}s%sskipping, state %u";
    unint64_t v22 = v26;
    int v23 = OS_LOG_TYPE_DEBUG;
    int v24 = 38;
LABEL_22:
    _os_log_impl(&dword_181A5C000, v22, v23, v21, buf, v24);
    return 0LL;
  }

  uint64_t v13 = *(void *)(context_for_protocol + 168);
  unint64_t v12 = *(void *)(context_for_protocol + 176);
  if ((*(_BYTE *)(context_for_protocol + 228) & 0x44) == 0x40 && v13 == v12)
  {
    os_log_type_t v25 = 0LL;
    if ((handle[348] & 1) != 0 || !gLogDatapath) {
      return v25;
    }
    uint64_t v28 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v65 = "nw_ohttp_context_get_input_frames";
      __int128 v66 = 2082;
      uint64_t v67 = handle + 349;
      __int128 v68 = 2080;
      __int16 v69 = " ";
      char v21 = "%{public}s %{public}s%sskipping, no new bytes to read";
      unint64_t v22 = v28;
      int v23 = OS_LOG_TYPE_DEBUG;
      int v24 = 32;
      goto LABEL_22;
    }

    return 0LL;
  }

  uint64_t v15 = a4;
  if (v12) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = v13 > a4;
  }
  if (v16)
  {
    unint64_t v17 = v13 - v12;
    if (v13 - v12 <= a4)
    {
      if (v13 == v12)
      {
        uint64_t v36 = 0LL;
      }

      else
      {
        __int16 v41 = nw_calloc_type<unsigned char>(v13 - v12);
        uint64_t v36 = v41;
        if (v41) {
          memcpy((void *)v41, (const void *)(*(void *)(v11 + 160) + *(void *)(v11 + 176)), v17);
        }
      }

      unint64_t v42 = nw_frame_create(0, v36, v17, (uint64_t)nw_protocol_ohttp_input_frame_finalizer, v11);
      nw_frame_set_buffer_used_malloc(v42, 1);
      *(void *)(v11 + 176) += v17;
      nw_frame_set_metadata(v42, *(nw_protocol_metadata **)(v11 + 80), 1, (*(unsigned __int8 *)(v11 + 228) >> 2) & 1);
      *(_BYTE *)(v11 + 228) |= 0x40u;
      *(void *)(v42 + 16) = 0LL;
      uint64_t v43 = *(uint64_t **)(v11 + 48);
      *(void *)(v42 + 24) = v43;
      __int128 *v43 = v42;
      *(void *)(v11 + 4_Block_object_dispose(va, 8) = v42 + 16;
      *(void *)(v42 + 32) = 0LL;
      tqh_last = a6->tqh_last;
      *(void *)(v42 + 40) = tqh_last;
      *tqh_last = (nw_frame *)v42;
      a6->tqh_last = (nw_frame **)(v42 + 32);
      if ((*(_BYTE *)(v11 + 228) & 4) != 0)
      {
        *(_DWORD *)(v11 + 224) = 5;
        if ((handle[348] & 1) != 0) {
          return 1LL;
        }
        uint64_t v46 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG)) {
          return 1LL;
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v65 = "nw_ohttp_context_get_input_frames";
        __int128 v66 = 2082;
        uint64_t v67 = handle + 349;
        __int128 v68 = 2080;
        __int16 v69 = " ";
        char v38 = "%{public}s %{public}s%sDelivered end of response";
        uint64_t v39 = v46;
        uint64_t v40 = 32;
        goto LABEL_51;
      }

      os_log_type_t v25 = 1LL;
      if ((handle[348] & 1) != 0) {
        return v25;
      }
      if (!gLogDatapath) {
        return v25;
      }
      int v45 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
        return v25;
      }
    }

    else
    {
      if (a4)
      {
        uint64_t v18 = nw_calloc_type<unsigned char>(a4);
        uint64_t v19 = v18;
        if (v18) {
          memcpy((void *)v18, (const void *)(*(void *)(v11 + 160) + *(void *)(v11 + 176)), a4);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      uint64_t v47 = nw_frame_create(0, v19, a4, (uint64_t)nw_protocol_ohttp_input_frame_finalizer, v11);
      os_log_type_t v25 = 1LL;
      nw_frame_set_buffer_used_malloc(v47, 1);
      *(void *)(v11 + 176) += v15;
      nw_frame_set_metadata(v47, *(nw_protocol_metadata **)(v11 + 80), 1, 0);
      *(_BYTE *)(v11 + 228) |= 0x40u;
      *(void *)(v47 + 16) = 0LL;
      id v48 = *(uint64_t **)(v11 + 48);
      *(void *)(v47 + 24) = v48;
      *id v48 = v47;
      *(void *)(v11 + 4_Block_object_dispose(va, 8) = v47 + 16;
      *(void *)(v47 + 32) = 0LL;
      int v49 = a6->tqh_last;
      *(void *)(v47 + 40) = v49;
      os_log_s *v49 = (nw_frame *)v47;
      a6->tqh_last = (nw_frame **)(v47 + 32);
      if ((handle[348] & 1) != 0) {
        return v25;
      }
      if (!gLogDatapath) {
        return v25;
      }
      int v45 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
        return v25;
      }
    }

    uint64_t v51 = *(void *)(v11 + 168);
    uint32_t v50 = *(nw_protocol **)(v11 + 176);
    *(_DWORD *)buf = 136447234;
    uint64_t v65 = "nw_ohttp_context_get_input_frames";
    __int128 v66 = 2082;
    uint64_t v67 = handle + 349;
    __int128 v68 = 2080;
    __int16 v69 = " ";
    uint64_t v70 = 2048;
    uint64_t v71 = v50;
    uint64_t v72 = 2048;
    unsigned int v73 = v51;
    mach_vm_address_t v33 = "%{public}s %{public}s%sDelivered partial response (%zu/%zu)";
    uint64_t v34 = v45;
    __int16 v35 = 52;
    goto LABEL_58;
  }

  uint64_t v29 = nw_frame_create( 0,  *(void *)(context_for_protocol + 160),  *(void *)(context_for_protocol + 168),  (uint64_t)nw_protocol_ohttp_input_frame_finalizer,  context_for_protocol);
  nw_frame_set_buffer_used_malloc(v29, 1);
  *(void *)(v11 + 160) = 0LL;
  *(void *)(v11 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v11 + 176) = 0LL;
  nw_frame_set_metadata(v29, *(nw_protocol_metadata **)(v11 + 80), 1, (*(unsigned __int8 *)(v11 + 228) >> 2) & 1);
  *(_BYTE *)(v11 + 228) |= 0x40u;
  *(void *)(v29 + 16) = 0LL;
  uint64_t v30 = *(uint64_t **)(v11 + 48);
  *(void *)(v29 + 24) = v30;
  const char *v30 = v29;
  *(void *)(v11 + 4_Block_object_dispose(va, 8) = v29 + 16;
  *(void *)(v29 + 32) = 0LL;
  BOOL v31 = a6->tqh_last;
  *(void *)(v29 + 40) = v31;
  void *v31 = (nw_frame *)v29;
  a6->tqh_last = (nw_frame **)(v29 + 32);
  if ((*(_BYTE *)(v11 + 228) & 4) != 0)
  {
    *(_DWORD *)(v11 + 224) = 5;
    if ((handle[348] & 1) != 0) {
      return 1LL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v37 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      return 1LL;
    }
    *(_DWORD *)buf = 136446978;
    uint64_t v65 = "nw_ohttp_context_get_input_frames";
    __int128 v66 = 2082;
    uint64_t v67 = handle + 349;
    __int128 v68 = 2080;
    __int16 v69 = " ";
    uint64_t v70 = 2048;
    uint64_t v71 = (nw_protocol *)v13;
    char v38 = "%{public}s %{public}s%sDelivered complete response (%zu)";
    uint64_t v39 = (os_log_s *)v37;
    uint64_t v40 = 42;
LABEL_51:
    _os_log_impl(&dword_181A5C000, v39, OS_LOG_TYPE_DEBUG, v38, buf, v40);
    return 1LL;
  }

  os_log_type_t v25 = 1LL;
  if ((handle[348] & 1) == 0)
  {
    if (gLogDatapath)
    {
      mach_vm_address_t v32 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        uint64_t v65 = "nw_ohttp_context_get_input_frames";
        __int128 v66 = 2082;
        uint64_t v67 = handle + 349;
        __int128 v68 = 2080;
        __int16 v69 = " ";
        uint64_t v70 = 2048;
        uint64_t v71 = (nw_protocol *)v13;
        mach_vm_address_t v33 = "%{public}s %{public}s%sDelivered partial response (%zu)";
        uint64_t v34 = v32;
        __int16 v35 = 42;
LABEL_58:
        _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_DEBUG, v33, buf, v35);
      }
    }
  }

  return v25;
}

        protocol_uint64_t metadata = nw_http_create_metadata_for_response(v30);
        BOOL v115 = v29;
        unsigned int v86 = nw_content_context_create("response");
        nw_content_context_set_metadata_for_protocol(v86, (nw_protocol_metadata_t)protocol_metadata);
        nw_connection_send( *(nw_connection_t *)(*(void *)(*(void *)(a1 + 32) + 16LL) + 48LL),  v29,  v86,  *(_BYTE *)(*(void *)(a1 + 32) + 219LL),  &__block_literal_global_24170);
        objc_storeStrong((id *)(*(void *)(a1 + 32) + 56LL), v86);
        uint64_t v87 = *(void *)(a1 + 32);
        if (*(void *)(v87 + 240) && !*(_BYTE *)(v87 + 248))
        {
          unsigned int v88 = *(nw_connection **)(*(void *)(v87 + 16) + 48LL);
          id v89 = (nw_protocol_definition *)nw_protocol_copy_http_connection_definition();
          int v90 = nw_connection_copy_protocol_metadata(v88, v89);

          nw_http_connection_metadata_send_certificate(v90, *(void **)(*(void *)(a1 + 32) + 240LL));
        }

        if (!*(_BYTE *)(a1 + 49)) {
          goto LABEL_113;
        }
        id v113 = (nw_endpoint *)nw_connection_copy_connected_local_endpoint(*(void **)(*(void *)(a1 + 32) + 48LL));
        unsigned __int16 v91 = (nw_endpoint *)nw_connection_copy_connected_remote_endpoint(*(void **)(*(void *)(a1 + 32) + 48LL));
        nw_endpoint_t v114 = v91;
        mach_vm_address_t address = nw_endpoint_get_address(v113);
        char v93 = address;
        if (address)
        {
          sa_family = address->sa_family;
          if (sa_family == 30)
          {
            uint64_t v95 = objc_alloc_init(MEMORY[0x189603FB8]);
            buf[0] = 0;
            [v95 appendBytes:buf length:1];
            v130[0] = 6;
            [v95 appendBytes:v130 length:1];
            [v95 appendBytes:&v93->sa_data[6] length:16];
            uint64_t v124 = 0x80;
            [v95 appendBytes:&v124 length:1];
            if (v95)
            {
LABEL_95:
              nw_endpoint_t v96 = (void *)[v95 _createDispatchData];
LABEL_97:

              unsigned __int16 v91 = v114;
LABEL_98:
              int v97 = nw_endpoint_get_address(v91);
              uint64_t v98 = (sockaddr *)v97;
              if (v97)
              {
                uint32_t v99 = v97->sa_family;
                if (v99 == 30)
                {
                  id v100 = objc_alloc_init(MEMORY[0x189603FB8]);
                  buf[0] = 6;
                  [v100 appendBytes:buf length:1];
                  [v100 appendBytes:&v98->sa_data[6] length:16];
                  [v100 appendBytes:&v98->sa_data[6] length:16];
                  v130[0] = *(_BYTE *)(a1 + 48);
                  [v100 appendBytes:v130 length:1];
                  if (v100)
                  {
LABEL_104:
                    uint64_t v98 = (sockaddr *)[v100 _createDispatchData];
LABEL_107:

                    goto LABEL_108;
                  }

    uint64_t v57 = v220[3];
    if ((v57 & 0x8000000000000000LL) == 0) {
      break;
    }
    char v58 = *(void *)&buf[8];
    if (gLogDatapath)
    {
      uint64_t v83 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t v227 = 136446210;
        *(void *)&v227[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v83, OS_LOG_TYPE_DEBUG, "%{public}s called", v227, 0xCu);
      }
    }

    *(void *)uint64_t v227 = v46;
    *(void *)&v227[8] = 0x40000000LL;
    *(void *)&v227[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33165;
    v228 = (const char *)&__block_descriptor_tmp_38_33166;
    *(void *)uint64_t v229 = v58 + 40;
    v229[8] = 0;
    int v59 = *(void *)(v58 + 40);
    do
    {
      if (!v59) {
        break;
      }
      unsigned int v60 = *(void *)(v59 + 32);
      BOOL v61 = (*(uint64_t (**)(_BYTE *))&v227[16])(v227);
      int v59 = v60;
    }

    while ((v61 & 1) != 0);
    uint32_t v62 = *v29;
    if (*(_DWORD *)(*v29 + 644) == 1)
    {
      unsigned int v5 = v207;
      if ((*(_BYTE *)(*v29 + 198) & 1) != 0) {
        goto LABEL_181;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int64x2_t v130 = (os_log_s *)gLogObj;
      id v131 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      uint32_t v62 = *v29;
      if (v131)
      {
        *(_DWORD *)uint64_t v227 = 136446722;
        *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        *(_WORD *)&v227[12] = 2082;
        *(void *)&v227[14] = v62 + 114;
        *(_WORD *)&v227[22] = 2080;
        v228 = " ";
        _os_log_impl(&dword_181A5C000, v130, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sdecoding failed", v227, 0x20u);
        uint32_t v62 = *v29;
      }

      if (v62)
      {
LABEL_181:
        nw_protocol_error(*(void **)(v62 + 48), v62);
        nw_protocol_disconnect(*(void **)(v62 + 32), v62);
        goto LABEL_233;
      }

      __nwlog_obj();
      *(_DWORD *)uint64_t v227 = 136446210;
      *(void *)&v227[4] = "nw_http_encoding_close";
      v178 = (char *)_os_log_send_and_compose_impl();
      v226 = OS_LOG_TYPE_ERROR;
      id v225 = 0;
      if (v226 == OS_LOG_TYPE_FAULT)
      {
        v179 = (os_log_s *)__nwlog_obj();
        id v180 = v226;
        if (os_log_type_enabled(v179, v226))
        {
          *(_DWORD *)uint64_t v227 = 136446210;
          *(void *)&v227[4] = "nw_http_encoding_close";
          v181 = "%{public}s called with null http_encoding";
          goto LABEL_272;
        }

        goto LABEL_274;
      }

      if (v225)
      {
        nw_endpoint_t v182 = (char *)__nw_create_backtrace_string();
        char v183 = (os_log_s *)__nwlog_obj();
        uint64_t v184 = v226;
        v185 = os_log_type_enabled(v183, v226);
        if (v182)
        {
          if (v185)
          {
            *(_DWORD *)uint64_t v227 = 136446466;
            *(void *)&v227[4] = "nw_http_encoding_close";
            *(_WORD *)&v227[12] = 2082;
            *(void *)&v227[14] = v182;
            _os_log_impl( &dword_181A5C000,  v183,  v184,  "%{public}s called with null http_encoding, dumping backtrace:%{public}s",  v227,  0x16u);
          }

          free(v182);
          goto LABEL_274;
        }

        if (!v185)
        {
LABEL_274:
          if (v178) {
            free(v178);
          }
          goto LABEL_233;
        }

        *(_DWORD *)uint64_t v227 = 136446210;
        *(void *)&v227[4] = "nw_http_encoding_close";
        v181 = "%{public}s called with null http_encoding, no backtrace";
        uint64_t v194 = v183;
        nw_endpoint_t v195 = v184;
      }

      else
      {
        v179 = (os_log_s *)__nwlog_obj();
        id v180 = v226;
        if (!os_log_type_enabled(v179, v226)) {
          goto LABEL_274;
        }
        *(_DWORD *)uint64_t v227 = 136446210;
        *(void *)&v227[4] = "nw_http_encoding_close";
        v181 = "%{public}s called with null http_encoding, backtrace limit exceeded";
LABEL_272:
        uint64_t v194 = v179;
        nw_endpoint_t v195 = v180;
      }

      _os_log_impl(&dword_181A5C000, v194, v195, v181, v227, 0xCu);
      goto LABEL_274;
    }

    if ((*(_BYTE *)(*v29 + 198) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v63 = (os_log_s *)gLogObj;
      uint64_t v64 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      uint32_t v62 = *v29;
      if (v64)
      {
        uint64_t v65 = *(unsigned int *)(v62 + 644);
        __int128 v66 = "<unknown>";
        *(_DWORD *)uint64_t v227 = 136446978;
        *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        *(_WORD *)&v227[12] = 2082;
        *(void *)&v227[14] = v62 + 114;
        *(_WORD *)&v227[22] = 2080;
        v228 = " ";
        *(_WORD *)uint64_t v229 = 2080;
        *(void *)&v229[2] = v66;
        _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sdecoding failed, trying alternative encoding %s",  v227,  0x2Au);
        uint32_t v62 = *v29;
      }
    }

    uint64_t v67 = *(_DWORD *)(v62 + 644);
    *(_DWORD *)(v62 + 644) = 1;
    switch(v67)
    {
      case 2:
        deflate = nw_decoder_create_gzip();
        goto LABEL_101;
      case 3:
        *(_DWORD *)(v62 + 644) = 4;
        deflate = nw_decoder_create_deflate();
        goto LABEL_101;
      case 4:
        deflate = nw_decoder_create_raw_deflate();
        goto LABEL_101;
      case 5:
        deflate = nw_decoder_create_brotli();
LABEL_101:
        __int16 v69 = (void (***)(void, uint64_t))deflate;
        break;
      default:
        __int16 v69 = 0LL;
        break;
    }

    uint64_t v44 = *v29;
    uint64_t v70 = *(void (****)(void, uint64_t))(*v29 + 544);
    if (v70 != v69)
    {
      if (v70)
      {
        (**v70)(*(void *)(*v29 + 544), v59);
        free(v70);
      }

      *(void *)(v44 + 544) = v69;
      uint64_t v44 = *v29;
    }
  }

  char v121 = *(void *)(*v29 + 472);
  *(void *)(*v29 + 472) = v121 + v57;
  if (__OFADD__(v121, v57))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v122 = (const char *)v220[3];
    unsigned int v123 = *(void *)(*v29 + 472);
    *(_DWORD *)uint64_t v227 = 136446978;
    *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    *(_WORD *)&v227[12] = 2082;
    *(void *)&v227[14] = "http_encoding->decoded_length";
    *(_WORD *)&v227[22] = 2048;
    v228 = v122;
    *(_WORD *)uint64_t v229 = 2048;
    *(void *)&v229[2] = v123;
    uint64_t v124 = (char *)_os_log_send_and_compose_impl();
    v226 = OS_LOG_TYPE_ERROR;
    id v225 = 0;
    if (v226 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v125 = (os_log_s *)gLogObj;
      unsigned int v126 = v226;
      if (!os_log_type_enabled((os_log_t)gLogObj, v226)) {
        goto LABEL_217;
      }
      uint64_t v127 = (const char *)v220[3];
      int v128 = *(void *)(*v29 + 472);
      *(_DWORD *)uint64_t v227 = 136446978;
      *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
      *(_WORD *)&v227[12] = 2082;
      *(void *)&v227[14] = "http_encoding->decoded_length";
      *(_WORD *)&v227[22] = 2048;
      v228 = v127;
      *(_WORD *)uint64_t v229 = 2048;
      *(void *)&v229[2] = v128;
      BOOL v129 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
    }

    else if (v225)
    {
      unsigned int v149 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v125 = (os_log_s *)gLogObj;
      unsigned int v126 = v226;
      __int16 v150 = os_log_type_enabled((os_log_t)gLogObj, v226);
      if (v149)
      {
        if (v150)
        {
          os_log_type_t v151 = (const char *)v220[3];
          __int16 v152 = *(void *)(*v29 + 472);
          *(_DWORD *)uint64_t v227 = 136447234;
          *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&v227[12] = 2082;
          *(void *)&v227[14] = "http_encoding->decoded_length";
          *(_WORD *)&v227[22] = 2048;
          v228 = v151;
          *(_WORD *)uint64_t v229 = 2048;
          *(void *)&v229[2] = v152;
          *(_WORD *)&v229[10] = 2082;
          char v230 = v149;
          _os_log_impl( &dword_181A5C000,  v125,  v126,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  v227,  0x34u);
        }

        free(v149);
LABEL_217:
        v143 = v206;
        unsigned int v5 = v207;
        if (v124) {
          free(v124);
        }
        BOOL v162 = *v29;
        *(void *)(v162 + 472) = 0x7FFFFFFFFFFFFFFFLL;
        if ((*(_BYTE *)(v162 + 198) & 1) != 0) {
          goto LABEL_221;
        }
        goto LABEL_220;
      }

      if (!v150) {
        goto LABEL_217;
      }
      id v160 = (const char *)v220[3];
      v161 = *(void *)(*v29 + 472);
      *(_DWORD *)uint64_t v227 = 136446978;
      *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
      *(_WORD *)&v227[12] = 2082;
      *(void *)&v227[14] = "http_encoding->decoded_length";
      *(_WORD *)&v227[22] = 2048;
      v228 = v160;
      *(_WORD *)uint64_t v229 = 2048;
      *(void *)&v229[2] = v161;
      BOOL v129 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v125 = (os_log_s *)gLogObj;
      unsigned int v126 = v226;
      if (!os_log_type_enabled((os_log_t)gLogObj, v226)) {
        goto LABEL_217;
      }
      uint64_t v158 = (const char *)v220[3];
      v159 = *(void *)(*v29 + 472);
      *(_DWORD *)uint64_t v227 = 136446978;
      *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
      *(_WORD *)&v227[12] = 2082;
      *(void *)&v227[14] = "http_encoding->decoded_length";
      *(_WORD *)&v227[22] = 2048;
      v228 = v158;
      *(_WORD *)uint64_t v229 = 2048;
      *(void *)&v229[2] = v159;
      BOOL v129 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v125, v126, v129, v227, 0x2Au);
    goto LABEL_217;
  }

  v143 = v206;
  unsigned int v5 = v207;
  if ((*(_BYTE *)(*v29 + 198) & 1) == 0)
  {
LABEL_220:
    if (gLogDatapath)
    {
      id v174 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
      {
        v175 = *v29 + 114;
        nw_endpoint_t v176 = *(void *)(a2 + 64);
        if (v176) {
          LODWORD(v176) = (*(unsigned __int8 *)(v176 + 66) >> 6) & 1;
        }
        os_log_type_t v177 = *(unsigned __int8 *)(a2 + 186) >> 7;
        *(_DWORD *)uint64_t v227 = 136447234;
        *(void *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        *(_WORD *)&v227[12] = 2082;
        *(void *)&v227[14] = v175;
        *(_WORD *)&v227[22] = 2080;
        v228 = " ";
        *(_WORD *)uint64_t v229 = 1024;
        *(_DWORD *)&v229[2] = v176;
        *(_WORD *)&v229[6] = 1024;
        *(_DWORD *)&v229[8] = v177;
        _os_log_impl( &dword_181A5C000,  v174,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%smetadata complete %{BOOL}d, connection complete %{BOOL}d",  v227,  0x2Cu);
      }
    }
  }

            if (*(void *)(v14 + 248))
            {
              int v49 = *(void *)(v14 + 256);
              if (v49)
              {
                if (*(void *)(v49 + 488) != v14)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint32_t v50 = *(void *)(v49 + 488);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
                  *(_WORD *)&_BYTE buf[12] = 2048;
                  *(void *)&buf[14] = v49;
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  v1051 = v14;
                  *(_WORD *)v1052 = 2048;
                  *(void *)&v1052[2] = v50;
                  uint64_t v51 = (char *)_os_log_send_and_compose_impl();
                  v1065[0] = 16;
                  aBlock[0] = 0;
                  if (__nwlog_fault(v51, v1065, aBlock))
                  {
                    if (v1065[0] == 17)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      char v53 = (os_log_s *)gLogObj;
                      uint64_t v54 = v1065[0];
                      if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v1065[0]))
                      {
                        int v55 = *(void *)(v49 + 488);
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
                        *(_WORD *)&_BYTE buf[12] = 2048;
                        *(void *)&buf[14] = v49;
                        *(_WORD *)&_BYTE buf[22] = 2048;
                        v1051 = v14;
                        *(_WORD *)v1052 = 2048;
                        *(void *)&v1052[2] = v55;
                        uint64_t v56 = "%{public}s Connection %p does not already have stream %p, has %p";
LABEL_110:
                        _os_log_impl(&dword_181A5C000, v53, v54, v56, buf, 0x2Au);
                      }
                    }

                    else if (aBlock[0])
                    {
                      uint64_t v64 = (char *)__nw_create_backtrace_string();
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      char v53 = (os_log_s *)gLogObj;
                      uint64_t v54 = v1065[0];
                      uint64_t v65 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v1065[0]);
                      if (v64)
                      {
                        if (v65)
                        {
                          __int128 v66 = *(void *)(v49 + 488);
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
                          *(_WORD *)&_BYTE buf[12] = 2048;
                          *(void *)&buf[14] = v49;
                          *(_WORD *)&_BYTE buf[22] = 2048;
                          v1051 = v14;
                          *(_WORD *)v1052 = 2048;
                          *(void *)&v1052[2] = v66;
                          *(_WORD *)&v1052[10] = 2082;
                          *(void *)&v1052[12] = v64;
                          _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s Connection %p does not already have stream %p, has %p, dumping backtrace:%{public}s",  buf,  0x34u);
                        }

                        free(v64);
                        goto LABEL_111;
                      }

                      if (v65)
                      {
                        __int128 v68 = *(void *)(v49 + 488);
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
                        *(_WORD *)&_BYTE buf[12] = 2048;
                        *(void *)&buf[14] = v49;
                        *(_WORD *)&_BYTE buf[22] = 2048;
                        v1051 = v14;
                        *(_WORD *)v1052 = 2048;
                        *(void *)&v1052[2] = v68;
                        uint64_t v56 = "%{public}s Connection %p does not already have stream %p, has %p, no backtrace";
                        goto LABEL_110;
                      }
                    }

                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      char v53 = (os_log_s *)gLogObj;
                      uint64_t v54 = v1065[0];
                      if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v1065[0]))
                      {
                        uint64_t v67 = *(void *)(v49 + 488);
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
                        *(_WORD *)&_BYTE buf[12] = 2048;
                        *(void *)&buf[14] = v49;
                        *(_WORD *)&_BYTE buf[22] = 2048;
                        v1051 = v14;
                        *(_WORD *)v1052 = 2048;
                        *(void *)&v1052[2] = v67;
                        uint64_t v56 = "%{public}s Connection %p does not already have stream %p, has %p, backtrace limit exceeded";
                        goto LABEL_110;
                      }
                    }
                  }

    if (v44) {
      free(v44);
    }
    goto LABEL_86;
  }

  objc_initWeak(&location, v9);
  [v6 internalParameters];
  unsigned int v10 = (nw_parameters *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v11 = nw_parameters_copy_default_protocol_stack(v10);

  options = nw_udp_create_options();
  nw_protocol_stack_set_transport_protocol(v11, options);

  [v6 internalParameters];
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  nw_parameters_set_data_mode(v13, 1u);

  [v6 internalParameters];
  char v14 = (nw_parameters *)objc_claimAutoreleasedReturnValue();
  uint64_t v15 = nw_listener_create(v14);
  internalListener = v9->_internalListener;
  v9->_internalListener = v15;

  unint64_t v17 = v9->_internalListener;
  if (v17)
  {
    if (NWCopyInternalQueue_init_once != -1) {
      dispatch_once(&NWCopyInternalQueue_init_once, &__block_literal_global_62911);
    }
    uint64_t v18 = (dispatch_queue_s *)(id)NWCopyInternalQueue_nwQueue;
    nw_listener_set_queue(v17, v18);

    uint64_t v19 = v9->_internalListener;
    unsigned int v20 = MEMORY[0x1895F87A8];
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = __45__NWUDPListener_initWithParameters_delegate___block_invoke;
    handler[3] = &unk_189BC8C38;
    objc_copyWeak(&v62, &location);
    nw_listener_set_state_changed_handler(v19, handler);
    char v21 = v9->_internalListener;
    v59[0] = v20;
    v59[1] = 3221225472LL;
    v59[2] = __45__NWUDPListener_initWithParameters_delegate___block_invoke_2;
    v59[3] = &unk_189BC8C10;
    objc_copyWeak(&v60, &location);
    nw_listener_set_new_connection_handler(v21, v59);
    unint64_t v22 = [v6 copy];
    parameters = v9->_parameters;
    v9->_parameters = (NWParameters *)v22;

    objc_storeWeak((id *)&v9->_delegate, v8);
    error = v9->_error;
    v9->_error = 0LL;

    nw_listener_start(v9->_internalListener);
    os_log_type_t v25 = v9;
    objc_destroyWeak(&v60);
    objc_destroyWeak(&v62);
    goto LABEL_16;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v26 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  __int128 v68 = "-[NWUDPListener initWithParameters:delegate:]";
  uint64_t v27 = (char *)_os_log_send_and_compose_impl();

  __int128 v66 = OS_LOG_TYPE_ERROR;
  char v63 = 0;
  if (__nwlog_fault(v27, &v66, &v63))
  {
    if (v66 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = (os_log_s *)(id)gLogObj;
      uint64_t v29 = v66;
      if (os_log_type_enabled(v28, v66))
      {
        *(_DWORD *)buf = 136446210;
        __int128 v68 = "-[NWUDPListener initWithParameters:delegate:]";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s nw_listener_create failed", buf, 0xCu);
      }
    }

    else if (v63)
    {
      BOOL v31 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = (os_log_s *)(id)gLogObj;
      mach_vm_address_t v32 = v66;
      mach_vm_address_t v33 = os_log_type_enabled(v28, v66);
      if (v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          __int128 v68 = "-[NWUDPListener initWithParameters:delegate:]";
          __int16 v69 = 2082;
          uint64_t v70 = v31;
          _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s nw_listener_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v31);
        if (!v27) {
          goto LABEL_15;
        }
        goto LABEL_14;
      }

      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        __int128 v68 = "-[NWUDPListener initWithParameters:delegate:]";
        _os_log_impl(&dword_181A5C000, v28, v32, "%{public}s nw_listener_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = (os_log_s *)(id)gLogObj;
      uint64_t v34 = v66;
      if (os_log_type_enabled(v28, v66))
      {
        *(_DWORD *)buf = 136446210;
        __int128 v68 = "-[NWUDPListener initWithParameters:delegate:]";
        _os_log_impl( &dword_181A5C000,  v28,  v34,  "%{public}s nw_listener_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v27) {
LABEL_14:
  }
    free(v27);
LABEL_15:
  os_log_type_t v25 = 0LL;
LABEL_16:

  objc_destroyWeak(&location);
LABEL_17:

  return v25;
}

      if (!v39) {
        return 0LL;
      }
LABEL_85:
      mach_vm_address_t v33 = (char *)v39;
      goto LABEL_86;
    }

    else {
      uint64_t v13 = 0LL;
    }
    bzero(&type[v11], v13);
    memcpy(type, a1 + 1, v11);
    if (inet_ntop(30, type, a2, a3))
    {
      char v14 = strlen(a2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v24 = (id)gLogObj;
      os_log_type_t v25 = *a1;
      *(_DWORD *)buf = 136447234;
      uint64_t v70 = "nw_nat64_write_prefix_to_string";
      uint64_t v71 = 1024;
      *(_DWORD *)uint64_t v72 = v25;
      *(_WORD *)&v72[4] = 1024;
      *(_DWORD *)&v72[6] = a3;
      *(_WORD *)&v72[10] = 2048;
      *(void *)&v72[12] = v14;
      unsigned int v73 = 2082;
      id v74 = a2;
      uint64_t v26 = (const char *)_os_log_send_and_compose_impl();

      __int128 v68 = OS_LOG_TYPE_ERROR;
      uint64_t v67 = 0;
      if (__nwlog_fault(v26, &v68, &v67))
      {
        if (v68 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v27 = (os_log_s *)(id)gLogObj;
          uint64_t v28 = v68;
          if (os_log_type_enabled(v27, v68))
          {
            uint64_t v29 = *a1;
            *(_DWORD *)buf = 136447234;
            uint64_t v70 = "nw_nat64_write_prefix_to_string";
            uint64_t v71 = 1024;
            *(_DWORD *)uint64_t v72 = v29;
            *(_WORD *)&v72[4] = 1024;
            *(_DWORD *)&v72[6] = a3;
            *(_WORD *)&v72[10] = 2048;
            *(void *)&v72[12] = v14;
            unsigned int v73 = 2082;
            id v74 = a2;
            uint64_t v30 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=%{public}s";
LABEL_75:
            _os_log_impl(&dword_181A5C000, v27, v28, v30, buf, 0x2Cu);
            goto LABEL_76;
          }

          goto LABEL_76;
        }

        if (!v67)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v27 = (os_log_s *)(id)gLogObj;
          uint64_t v28 = v68;
          if (os_log_type_enabled(v27, v68))
          {
            int v55 = *a1;
            *(_DWORD *)buf = 136447234;
            uint64_t v70 = "nw_nat64_write_prefix_to_string";
            uint64_t v71 = 1024;
            *(_DWORD *)uint64_t v72 = v55;
            *(_WORD *)&v72[4] = 1024;
            *(_DWORD *)&v72[6] = a3;
            *(_WORD *)&v72[10] = 2048;
            *(void *)&v72[12] = v14;
            unsigned int v73 = 2082;
            id v74 = a2;
            uint64_t v30 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=%{public}s, backt"
                  "race limit exceeded";
            goto LABEL_75;
          }

      free(v35);
      goto LABEL_22;
    }

    __nwlog_obj();
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_send_certificate";
    __int16 v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v37 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_send_certificate";
        _os_log_impl(&dword_181A5C000, v36, v37, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v52)
    {
      unint64_t v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v43 = type;
      uint64_t v44 = os_log_type_enabled(v36, type);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_send_certificate";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v42;
          _os_log_impl( &dword_181A5C000,  v36,  v43,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v42);
        goto LABEL_83;
      }

      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_send_certificate";
        _os_log_impl(&dword_181A5C000, v36, v43, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v48 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_connection_metadata_set_send_certificate";
        _os_log_impl( &dword_181A5C000,  v36,  v48,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }

  if (v44) {
    free(v44);
  }
  uint64_t v19 = 0LL;
LABEL_67:

  return v19;
}

      free(v56);
    }
  }

      if (!v16) {
        return 0LL;
      }
      uint64_t v15 = (char *)v16;
      goto LABEL_30;
    }

    if (!v26)
    {
      unint64_t v17 = (os_log_s *)__nwlog_obj();
      uint64_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_http_messaging_replace_input_handler";
        uint64_t v19 = "%{public}s called with null new_input_protocol, backtrace limit exceeded";
        goto LABEL_83;
      }

      goto LABEL_84;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v17 = (os_log_s *)__nwlog_obj();
    uint64_t v18 = type;
    os_log_type_t v25 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_protocol_http_messaging_replace_input_handler";
        uint64_t v19 = "%{public}s called with null new_input_protocol, no backtrace";
        goto LABEL_83;
      }

      goto LABEL_84;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "nw_protocol_http_messaging_replace_input_handler";
      uint64_t v30 = 2082;
      BOOL v31 = (nw_protocol *)backtrace_string;
      unint64_t v22 = "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s";
      goto LABEL_65;
    }

LABEL_85:
            os_unfair_lock_lock((os_unfair_lock_t)v4 + 220);
            BOOL v61 = (void *)*((void *)v4 + 2);
            *((void *)v4 + 2) = 0LL;

            os_unfair_lock_unlock((os_unfair_lock_t)v4 + 220);
            else {
              char v63 = (uint64_t)nw_endpoint_flow_copy_path(v17);
            }
            uint64_t v64 = (void *)v63;
            os_unfair_lock_lock((os_unfair_lock_t)v4 + 220);
            objc_storeStrong((id *)v4 + 1, v64);
            os_unfair_lock_unlock((os_unfair_lock_t)v4 + 220);
            uint64_t v65 = v17;
            v5->state = 3;

            if (_nw_signposts_once != -1) {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_80157);
            }
            nw_endpoint_flow_update_connected_metadata(v65, 0);
            nw_endpoint_flow_update_connected_metadata(v65, 1);
            nw_endpoint_flow_connected_path_change(v65);

            goto LABEL_119;
          }

BOOL nw_segment_freelist_remove(void *a1, uint64_t *a2, int a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *a2;
  uint64_t v7 = (void *)a2[1];
  if (*a2)
  {
    *(void *)(v6 + _Block_object_dispose(va, 8) = v7;
    uint64_t v7 = (void *)a2[1];
  }

  else
  {
    a1[47] = v7;
  }

  *uint64_t v7 = v6;
  *a2 = 0LL;
  a2[1] = 0LL;
  uint64_t v8 = a1[40];
  if (!v8)
  {
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    int v18 = 136446466;
    uint64_t v19 = "nw_segment_freelist_remove";
    __int16 v20 = 2082;
    char v21 = "VERIFY nwr->nwr_seg_free_cnt != 0 failed";
    unint64_t v12 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v12);
    if (result) {
      goto LABEL_20;
    }
    free(v12);
    uint64_t v8 = a1[40];
  }

  a1[40] = v8 - 1;
  if (a3)
  {
    *((_DWORD *)a2 + 11) = 3;
    return (BOOL)a2;
  }

  if (*((_DWORD *)a2 + 12) != 2)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    int v18 = 136446466;
    uint64_t v19 = "nw_segment_freelist_remove";
    __int16 v20 = 2082;
    char v21 = "VERIFY sg->sg_state == NW_SEG_STATE_UNMAPPED failed";
    char v14 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v14);
    if (result) {
      goto LABEL_20;
    }
    free(v14);
  }

  int state = 0;
  if (!mach_vm_purgable_control(*MEMORY[0x1895FBBE0], a2[3], 0, &state))
  {
    unint64_t v9 = (void (*)(uint64_t *, void))a1[35];
    if (!v9)
    {
LABEL_10:
      *(uint64_t *)((char *)a2 + 44) = 0x300000001LL;
      return (BOOL)a2;
    }

uint64_t nw_frame_array_foreach(uint64_t result, char a2, uint64_t a3)
{
  uint64_t v5 = *(void *)result;
  if ((a2 & 1) != 0)
  {
    do
    {
      if (!v5) {
        break;
      }
      uint64_t v6 = *(void *)(v5 + 32);
      BOOL result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      uint64_t v5 = v6;
    }

    while ((result & 1) != 0);
  }

  else
  {
    do
    {
      if (!v5) {
        break;
      }
      uint64_t v7 = *(void *)(v5 + 16);
      BOOL result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      uint64_t v5 = v7;
    }

    while ((result & 1) != 0);
  }

  return result;
}

BOOL nw_protocol_metadata_is_ip(nw_protocol_metadata_t metadata)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (metadata)
  {
    return nw_protocol_metadata_matches_definition((uint64_t)metadata, g_ip_definition);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_protocol_metadata_is_ip_unsafe";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_protocol_metadata_is_ip_unsafe";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_metadata_copy_identifier(void *a1, _OWORD *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *a2 = *((_OWORD *)v3 + 1);
      uint64_t v5 = 1LL;
      goto LABEL_4;
    }

    __nwlog_obj();
    char v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v23 = "nw_protocol_metadata_copy_identifier";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          int v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null out_identifier", buf, 0xCu);
        }

uint64_t nw_frame_is_wake_packet(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return (*(unsigned __int16 *)(a1 + 204) >> 14) & 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v11 = "__nw_frame_is_wake_packet";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "__nw_frame_is_wake_packet";
        uint64_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          char v11 = "__nw_frame_is_wake_packet";
          __int16 v12 = 2082;
          uint64_t v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "__nw_frame_is_wake_packet";
        uint64_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      id v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "__nw_frame_is_wake_packet";
        uint64_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_protocol_default_get_output_local(nw_protocol *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "nw_protocol_default_get_output_local";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_default_get_output_local";
      BOOL v9 = "%{public}s called with null protocol";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v15 = "nw_protocol_default_get_output_local";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (!v11)
      {
LABEL_22:
        if (v6) {
          free(v6);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_default_get_output_local";
      BOOL v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_default_get_output_local";
      BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_22;
  }

  output_handler = a1->output_handler;
  if (!output_handler
    || (callbacks = output_handler->callbacks) == 0LL
    || (get_output_local_endpoint = (uint64_t (*)(void))callbacks->get_output_local_endpoint) == 0LL
    || (uint64_t result = get_output_local_endpoint()) == 0)
  {
    if (a1->default_input_handler) {
      return nw_protocol_default_get_local(a1);
    }
    return 0LL;
  }

  return result;
}

uint64_t nw_protocol_default_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v15 = "nw_protocol_default_waiting_for_output";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_default_waiting_for_output";
      BOOL v9 = "%{public}s called with null protocol";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v15 = "nw_protocol_default_waiting_for_output";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v11)
      {
LABEL_20:
        if (v6) {
          free(v6);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_default_waiting_for_output";
      BOOL v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v15 = "nw_protocol_default_waiting_for_output";
      BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_20;
  }

  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      waiting_for_output = (uint64_t (*)(void))callbacks->waiting_for_output;
      if (waiting_for_output) {
        return waiting_for_output();
      }
    }
  }

  return 0LL;
}

void nw_endpoint_flow_add_initial_write_request(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  int v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    __int16 v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int128 v66 = "nw_endpoint_handler_get_mode";
    char v38 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (__nwlog_fault(v38, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v40 = type;
        if (os_log_type_enabled(v39, type))
        {
          *(_DWORD *)buf = 136446210;
          __int128 v66 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v39, v40, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v63)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v42 = type;
        BOOL v43 = os_log_type_enabled(v39, type);
        if (backtrace_string)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            __int128 v66 = "nw_endpoint_handler_get_mode";
            __int16 v67 = 2082;
            __int128 v68 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v39,  v42,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          __int128 v66 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v39, v42, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v39, type))
        {
          *(_DWORD *)buf = 136446210;
          __int128 v66 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v39,  v44,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B642DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_initial_data_payload(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    BOOL v3 = *((void *)v1 + 18) != 0LL;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_parameters_has_initial_data_payload";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_has_initial_data_payload";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_parameters_has_initial_data_payload";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_has_initial_data_payload";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_has_initial_data_payload";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_sleep_keepalive_interval(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[22];
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_parameters_get_sleep_keepalive_interval";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_parameters_get_sleep_keepalive_interval";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_flow_update_connected_metadata(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  os_log_type_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    int v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            __int16 v34 = 2082;
            BOOL v35 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_protocol_default_copy_info(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v14 = "nw_protocol_default_copy_info";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_default_copy_info";
      id v8 = "%{public}s called with null protocol";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_protocol_default_copy_info";
          __int16 v15 = 2082;
          __int16 v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v10)
      {
LABEL_20:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_default_copy_info";
      id v8 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      os_log_type_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      char v14 = "nw_protocol_default_copy_info";
      id v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_20;
  }

  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2)
    {
      uint64_t v3 = *(uint64_t (**)(void))(v2 + 224);
      if (v3) {
        return v3();
      }
    }
  }

  return 0LL;
}

BOOL nw_protocol_ipv4_copy_info(uint64_t a1, int a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_protocol_ipv4_copy_info";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        os_log_type_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_ipv4_copy_info";
        BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v11) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_protocol_ipv4_copy_info";
        BOOL v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v20 = "nw_protocol_ipv4_copy_info";
        __int16 v21 = 2082;
        uint64_t v22 = (uint64_t)backtrace_string;
        os_log_type_t v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
        _os_log_impl(&dword_181A5C000, v7, v8, v12, buf, 0x16u);
      }

void nw_endpoint_flow_connected_path_change(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v183 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    char v93 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v166 = "nw_endpoint_handler_get_mode";
    uint64_t v94 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v163 = 0;
    if (__nwlog_fault(v94, &type, &v163))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v96 = type;
        if (os_log_type_enabled(v95, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v166 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v95, v96, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v163)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v98 = type;
        BOOL v99 = os_log_type_enabled(v95, type);
        if (backtrace_string)
        {
          if (v99)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v166 = "nw_endpoint_handler_get_mode";
            __int16 v167 = 2082;
            id v168 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v95,  v98,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_119;
        }

        if (v99)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v166 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v95, v98, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v100 = type;
        if (os_log_type_enabled(v95, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v166 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v95,  v100,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_153:
    goto LABEL_154;
  }

  if (!v163)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v104 = (os_log_s *)(id)gLogObj;
    os_log_type_t v111 = type;
    if (os_log_type_enabled(v104, type))
    {
      if (mode > 5) {
        BOOL v112 = "unknown-mode";
      }
      else {
        BOOL v112 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v166 = "nw_endpoint_flow_connected_path_change";
      __int16 v167 = 2082;
      id v168 = (void *)v112;
      __int16 v169 = 2082;
      nw_endpoint_t v170 = "flow";
      _os_log_impl( &dword_181A5C000,  v104,  v111,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
    }

    goto LABEL_153;
  }

  int v107 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v104 = (os_log_s *)(id)gLogObj;
  os_log_type_t v108 = type;
  BOOL v109 = os_log_type_enabled(v104, type);
  if (!v107)
  {
    if (v109)
    {
      if (mode > 5) {
        id v113 = "unknown-mode";
      }
      else {
        id v113 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v166 = "nw_endpoint_flow_connected_path_change";
      __int16 v167 = 2082;
      id v168 = (void *)v113;
      __int16 v169 = 2082;
      nw_endpoint_t v170 = "flow";
      _os_log_impl( &dword_181A5C000,  v104,  v108,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
    }

    goto LABEL_153;
  }

  if (v109)
  {
    if (mode > 5) {
      uint64_t v110 = "unknown-mode";
    }
    else {
      uint64_t v110 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446978;
    uint64_t v166 = "nw_endpoint_flow_connected_path_change";
    __int16 v167 = 2082;
    id v168 = (void *)v110;
    __int16 v169 = 2082;
    nw_endpoint_t v170 = "flow";
    __int16 v171 = 2082;
    v172 = v107;
    _os_log_impl( &dword_181A5C000,  v104,  v108,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v107);
  if (v103) {
    goto LABEL_155;
  }
LABEL_156:
}

      goto LABEL_154;
    }

    if (!v87)
    {
      __nwlog_obj();
      BOOL v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      size_t v80 = v99;
      if (os_log_type_enabled(v53, (os_log_type_t)v99))
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v53,  v80,  "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id), ba cktrace limit exceeded",  access_value,  0xCu);
      }

      goto LABEL_153;
    }

    __int128 v68 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v71 = v99;
    uint64_t v72 = os_log_type_enabled(v53, (os_log_type_t)v99);
    if (!v68)
    {
      if (v72)
      {
        *(_DWORD *)access_xpc_object_t value = 136446210;
        *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl( &dword_181A5C000,  v53,  v71,  "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id), no backtrace",  access_value,  0xCu);
      }

      goto LABEL_153;
    }

    if (v72)
    {
      *(_DWORD *)access_xpc_object_t value = 136446466;
      *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
      *(_WORD *)&access_value[12] = 2082;
      *(void *)&access_value[14] = v68;
      _os_log_impl( &dword_181A5C000,  v53,  v71,  "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id), dump ing backtrace:%{public}s",  access_value,  0x16u);
    }

LABEL_108:
    free(v68);
    if (!v46) {
      goto LABEL_156;
    }
    goto LABEL_155;
  }

  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  }
  os_log_type_t v8 = (os_log_s *)(id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    BOOL v9 = *((void *)v85 + 1);
    *(_DWORD *)access_xpc_object_t value = 136446978;
    *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    *(_WORD *)&access_value[12] = 2048;
    *(void *)&access_value[14] = v9;
    *(_WORD *)&access_value[22] = 1040;
    *(_DWORD *)int v92 = 16;
    *(_WORD *)&v92[4] = 2096;
    *(void *)&v92[6] = v100;
    _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s [CM%zu] looking up evaluator for %{uuid_t}.16P",  access_value,  0x26u);
  }

  char v10 = nw_parameters_copy_context(*((void **)v85 + 10));
  evaluator_for_client_id = nw_path_create_evaluator_for_client_id((const unsigned __int8 *)v100, v10);

  if (!evaluator_for_client_id)
  {
    __nwlog_obj();
    os_log_type_t v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_xpc_object_t value = 136446210;
    *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    BOOL v56 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v99) = 16;
    uint64_t v87 = 0;
    if (__nwlog_fault(v56, &v99, &v87))
    {
      if (v99 == 17)
      {
        __nwlog_obj();
        uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v58 = v99;
        if (os_log_type_enabled(v57, (os_log_type_t)v99))
        {
          *(_DWORD *)access_xpc_object_t value = 136446210;
          *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_181A5C000, v57, v58, "%{public}s called with null evaluator", access_value, 0xCu);
        }
      }

      else if (v87)
      {
        __int16 v73 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v74 = v99;
        nw_endpoint_t v75 = os_log_type_enabled(v57, (os_log_type_t)v99);
        if (v73)
        {
          if (v75)
          {
            *(_DWORD *)access_xpc_object_t value = 136446466;
            *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
            *(_WORD *)&access_value[12] = 2082;
            *(void *)&access_value[14] = v73;
            _os_log_impl( &dword_181A5C000,  v57,  v74,  "%{public}s called with null evaluator, dumping backtrace:%{public}s",  access_value,  0x16u);
          }

          free(v73);
          goto LABEL_160;
        }

        if (v75)
        {
          *(_DWORD *)access_xpc_object_t value = 136446210;
          *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl( &dword_181A5C000,  v57,  v74,  "%{public}s called with null evaluator, no backtrace",  access_value,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v81 = v99;
        if (os_log_type_enabled(v57, (os_log_type_t)v99))
        {
          *(_DWORD *)access_xpc_object_t value = 136446210;
          *(void *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl( &dword_181A5C000,  v57,  v81,  "%{public}s called with null evaluator, backtrace limit exceeded",  access_value,  0xCu);
        }
      }
    }

      if (v112) {
        free(v112);
      }
      uint64_t v24 = 0;
LABEL_18:
      uint64_t v25 = (uint64_t)v23;
      id v26 = a9;
      if (v19 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v25 + 40) == &nw_protocol_ref_counted_handle)
      {
        char v44 = *(void *)(v25 + 88);
        if (v44)
        {
          id v45 = v44 - 1;
          *(void *)(v25 + 8_Block_object_dispose(va, 8) = v45;
          if (!v45)
          {
            uint64_t v46 = *(void (***)(void))(v25 + 64);
            if (v46)
            {
              *(void *)(v25 + 64) = 0LL;
              os_log_type_t v111 = (void *)v25;
              v46[2](v46);
              _Block_release(v46);
              uint64_t v25 = (uint64_t)v111;
            }

            if ((*(_BYTE *)(v25 + 72) & 1) != 0)
            {
              uint64_t v47 = *(const void **)(v25 + 64);
              if (v47)
              {
                id v48 = v25;
                _Block_release(v47);
                uint64_t v25 = v48;
              }
            }

            os_log_type_t v49 = v25;
            free((void *)v25);
            uint64_t v25 = v49;
          }
        }
      }

      char v27 = v17 == &nw_protocol_ref_counted_handle;
      BOOL v28 = v115;
      if (v27 && *(_UNKNOWN **)(v16 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint32_t v50 = *(void *)(v16 + 88);
        if (v50)
        {
          id v51 = v50 - 1;
          *(void *)(v16 + 8_Block_object_dispose(va, 8) = v51;
          if (!v51)
          {
            os_log_type_t v52 = v25;
            BOOL v53 = *(void (***)(void))(v16 + 64);
            if (v53)
            {
              *(void *)(v16 + 64) = 0LL;
              v53[2](v53);
              _Block_release(v53);
            }

            if ((*(_BYTE *)(v16 + 72) & 1) != 0)
            {
              uint64_t v54 = *(const void **)(v16 + 64);
              if (v54) {
                _Block_release(v54);
              }
            }

            free((void *)v16);
            uint64_t v25 = v52;
          }
        }
      }

      a8 = v116;
      if (!v24 || *(_BYTE *)(a1 + 140) == 2) {
        goto LABEL_69;
      }
      *(void *)os_log_type_t type = 0LL;
      char v121 = type;
      nw_endpoint_t v123 = 0;
      unsigned int v122 = 0x2000000000LL;
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
      nw_endpoint_t v125 = (const char *)&unk_189BB63E8;
      *(void *)&v126[16] = a1;
      id v127 = a6;
      uint32x4_t v135 = 1;
      int v128 = &v117;
      BOOL v129 = a11;
      nw_endpoint_t v130 = v115;
      id v131 = a9;
      id v132 = v25;
      *(void *)unsigned int v126 = type;
      *(void *)&v126[8] = v114;
      os_log_type_t v29 = v25;
      int64x2_t v133 = a10;
      id v134 = a3;
      uint64_t v30 = v117;
      do
      {
        if (!v30) {
          break;
        }
        char v31 = *(void *)(v30 + 32);
        mach_vm_address_t v32 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        uint64_t v30 = v31;
      }

      while ((v32 & 1) != 0);
      mach_vm_address_t v33 = (const char *)*((unsigned int *)v121 + 6);
      _Block_object_dispose(type, 8);
      __int16 v34 = __CFADD__(*v116, (_DWORD)v33);
      *v116 += v33;
      uint64_t v25 = v29;
      if (!v34)
      {
LABEL_69:
        size_t v60 = v117;
        if (!v117)
        {
LABEL_73:
          if (*a8 && *v28)
          {
            uint32_t v62 = v25;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v63 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 0;
              nw_frame_array_get_frame_count(a11, 1, buf);
              uint64_t v64 = *(_DWORD *)buf;
              uint64_t v65 = *a8;
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = a4;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v64;
              LOWORD(v125) = 1024;
              *(_DWORD *)((char *)&v125 + 2) = v65;
              _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s could not fulfill minimum byte requirement of %u bytes (have %u bytes in %u frames), saving i n input_frames_pending_delivery for later",  buf,  0x1Eu);
            }

            uint64_t v25 = v62;
            if (*a11)
            {
              **(void **)(a1 + 24) = *a11;
              *(void *)(*a11 + 40) = *(void *)(a1 + 24);
              *(void *)(a1 + 24) = a11[1];
            }

            __int128 v66 = 0LL;
            *a11 = 0LL;
            a11[1] = (uint64_t)a11;
            *a8 = 0;
            *id v26 = 0;
          }

          else
          {
            __int128 v66 = *v26;
          }

          nw_protocol_plugin_metadata_report_transfer(a1, v25, *(void *)(a1 + 48), v66, 1LL);
          return;
        }

      goto LABEL_66;
    }

    if (!(_BYTE)v68)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v41 = (os_log_s *)(id)gLogObj;
      __int16 v67 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
        _os_log_impl( &dword_181A5C000,  v41,  v67,  "%{public}s called with null initial_inbound_data, backtrace limit exceeded",  applier,  0xCu);
      }

      goto LABEL_153;
    }

    uint64_t v57 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v41 = (os_log_s *)(id)gLogObj;
    size_t v60 = type[0];
    nw_endpoint_t v61 = os_log_type_enabled(v41, type[0]);
    if (!v57)
    {
      if (v61)
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
        _os_log_impl( &dword_181A5C000,  v41,  v60,  "%{public}s called with null initial_inbound_data, no backtrace",  applier,  0xCu);
      }

      goto LABEL_153;
    }

    if (v61)
    {
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "nw_endpoint_handler_add_initial_inbound_data";
      *(_WORD *)&applier[12] = 2082;
      *(void *)&applier[14] = v57;
      _os_log_impl( &dword_181A5C000,  v41,  v60,  "%{public}s called with null initial_inbound_data, dumping backtrace:%{public}s",  applier,  0x16u);
    }

LABEL_154:
                _Block_object_dispose(type, 8);

                goto LABEL_155;
              }

              __nwlog_obj();
              int v97 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              __int16 v173 = "nw_endpoint_proxy_copy_tls_proxy_options";
              os_log_type_t v98 = (char *)_os_log_send_and_compose_impl();

              __int16 v171 = OS_LOG_TYPE_ERROR;
              nw_endpoint_t v170 = 0;
              if (__nwlog_fault(v98, &v171, &v170))
              {
                if (v171 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  BOOL v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v100 = v171;
                  if (os_log_type_enabled(v99, v171))
                  {
                    *(_DWORD *)buf = 136446210;
                    __int16 v173 = "nw_endpoint_proxy_copy_tls_proxy_options";
                    _os_log_impl(&dword_181A5C000, v99, v100, "%{public}s called with null parameters", buf, 0xCu);
                  }
                }

                else
                {
                  if (v170)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    uint64_t v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v111 = v171;
                    BOOL v112 = os_log_type_enabled(v110, v171);
                    if (backtrace_string)
                    {
                      if (v112)
                      {
                        *(_DWORD *)buf = 136446466;
                        __int16 v173 = "nw_endpoint_proxy_copy_tls_proxy_options";
                        id v174 = 2082;
                        __int16 v175 = backtrace_string;
                        _os_log_impl( &dword_181A5C000,  v110,  v111,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                      }

                      free(backtrace_string);
                    }

                    else
                    {
                      if (v112)
                      {
                        *(_DWORD *)buf = 136446210;
                        __int16 v173 = "nw_endpoint_proxy_copy_tls_proxy_options";
                        _os_log_impl( &dword_181A5C000,  v110,  v111,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
                      }
                    }

                    goto LABEL_125;
                  }

                  __nwlog_obj();
                  BOOL v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  int v120 = v171;
                  if (os_log_type_enabled(v99, v171))
                  {
                    *(_DWORD *)buf = 136446210;
                    __int16 v173 = "nw_endpoint_proxy_copy_tls_proxy_options";
                    _os_log_impl( &dword_181A5C000,  v99,  v120,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
                  }
                }
              }

      if (!v72) {
        return;
      }
      goto LABEL_154;
    }

    if (!LOBYTE(v106[0]))
    {
      __int16 v73 = (os_log_s *)__nwlog_obj();
      id v74 = v112[0];
      if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        nw_endpoint_t v75 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_152;
      }

      goto LABEL_153;
    }

    id v83 = (char *)__nw_create_backtrace_string();
    __int16 v73 = (os_log_s *)__nwlog_obj();
    id v74 = v112[0];
    char v102 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!v83)
    {
      if (v102)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        nw_endpoint_t v75 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_152;
      }

      goto LABEL_153;
    }

    if (!v102) {
      goto LABEL_142;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v83;
    id v85 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_141:
    _os_log_impl(&dword_181A5C000, v73, v74, v85, buf, 0x16u);
    goto LABEL_142;
  }

  if ((handle[548] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v42 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v43 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_establish";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&_BYTE buf[22] = 2080;
      os_log_type_t v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v43;
      _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Unknown webtransport session transport mode for establishment, failing",  buf,  0x26u);
    }
  }

    if (v50) {
      free(v50);
    }
    uint64_t v47 = 0LL;
    goto LABEL_71;
  }

  nw_endpoint_t v106 = 0LL;
  int v107 = &v106;
  os_log_type_t v108 = 0x2020000000LL;
  BOOL v109 = a2;
  iterate_block[0] = MEMORY[0x1895F87A8];
  iterate_block[1] = 3221225472LL;
  iterate_block[2] = ___ZL35nw_proxy_config_serialize_one_stackPU31objcproto20OS_nw_protocol_stack8NSObjectPhPKh_block_invoke;
  iterate_block[3] = &unk_189BBD140;
  iterate_block[4] = &v106;
  iterate_block[5] = a3;
  nw_protocol_stack_iterate_application_protocols(v5, iterate_block);
  os_log_type_t v7 = v6;
  unsigned int v103 = v7[3];

  os_log_type_t v8 = v103;
  if (!v103)
  {
LABEL_70:
    uint64_t v47 = v107[3];

    _Block_object_dispose(&v106, 8);
LABEL_71:

    return v47;
  }

  __n = 0LL;
  __src = (void *)nw_protocol_options_copy_serialized_bytes(v103, (uint64_t)&__n, 0);
  if (!__src || !__n)
  {
    __int16 v21 = (id *)v103;
    uint64_t v22 = v21[1];

    identifier = nw_protocol_definition_get_identifier(v22);
    *(_OWORD *)os_log_type_t type = *(_OWORD *)identifier;
    id v113 = *((_OWORD *)identifier + 1);
    nw_endpoint_t v114 = *((void *)identifier + 4);
    uint64_t v24 = (_BYTE *)v107[3];
    if (v24)
    {
      if (a3)
      {
        if ((unint64_t)v24 < a3)
        {
          if (a3 - (unint64_t)v24 <= 0x2E)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v25 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            id v116 = "nw_necp_append_tlv";
            nw_endpoint_t v117 = 2048;
            unsigned int v118 = (size_t)v24;
            id v119 = 2048;
            int v120 = 47LL;
            char v121 = 2048;
            *(void *)unsigned int v122 = a3;
            *(_WORD *)&v122[8] = 1024;
            *(_DWORD *)nw_endpoint_t v123 = 5;
            *(_WORD *)&v123[4] = 1024;
            *(_DWORD *)&v123[6] = 42;
            id v26 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v111 = OS_LOG_TYPE_ERROR;
            uint64_t v110 = 0;
            if (v111 == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v27 = (os_log_s *)(id)gLogObj;
              BOOL v28 = v111;
              if (os_log_type_enabled(v27, v111))
              {
                *(_DWORD *)buf = 136447490;
                id v116 = "nw_necp_append_tlv";
                nw_endpoint_t v117 = 2048;
                unsigned int v118 = (size_t)v24;
                id v119 = 2048;
                int v120 = 47LL;
                char v121 = 2048;
                *(void *)unsigned int v122 = a3;
                *(_WORD *)&v122[8] = 1024;
                *(_DWORD *)nw_endpoint_t v123 = 5;
                *(_WORD *)&v123[4] = 1024;
                *(_DWORD *)&v123[6] = 42;
                _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
              }
            }

            else if (v110)
            {
              mach_vm_address_t v32 = __nw_create_backtrace_string();
              if (v32)
              {
                mach_vm_address_t v33 = (char *)v32;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                __int16 v34 = (os_log_s *)(id)gLogObj;
                nw_endpoint_t v35 = v111;
                if (os_log_type_enabled(v34, v111))
                {
                  *(_DWORD *)buf = 136447746;
                  id v116 = "nw_necp_append_tlv";
                  nw_endpoint_t v117 = 2048;
                  unsigned int v118 = (size_t)v24;
                  id v119 = 2048;
                  int v120 = 47LL;
                  char v121 = 2048;
                  *(void *)unsigned int v122 = a3;
                  *(_WORD *)&v122[8] = 1024;
                  *(_DWORD *)nw_endpoint_t v123 = 5;
                  *(_WORD *)&v123[4] = 1024;
                  *(_DWORD *)&v123[6] = 42;
                  uint64_t v124 = 2082;
                  nw_endpoint_t v125 = v33;
                  _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
                }

                free(v33);
                if (!v26) {
                  goto LABEL_53;
                }
                goto LABEL_52;
              }

              __nwlog_obj();
              char v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v42 = v111;
              if (os_log_type_enabled(v27, v111))
              {
                *(_DWORD *)buf = 136447490;
                id v116 = "nw_necp_append_tlv";
                nw_endpoint_t v117 = 2048;
                unsigned int v118 = (size_t)v24;
                id v119 = 2048;
                int v120 = 47LL;
                char v121 = 2048;
                *(void *)unsigned int v122 = a3;
                *(_WORD *)&v122[8] = 1024;
                *(_DWORD *)nw_endpoint_t v123 = 5;
                *(_WORD *)&v123[4] = 1024;
                *(_DWORD *)&v123[6] = 42;
                _os_log_impl( &dword_181A5C000,  v27,  v42,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v27 = (os_log_s *)(id)gLogObj;
              os_log_type_t v40 = v111;
              if (os_log_type_enabled(v27, v111))
              {
                *(_DWORD *)buf = 136447490;
                id v116 = "nw_necp_append_tlv";
                nw_endpoint_t v117 = 2048;
                unsigned int v118 = (size_t)v24;
                id v119 = 2048;
                int v120 = 47LL;
                char v121 = 2048;
                *(void *)unsigned int v122 = a3;
                *(_WORD *)&v122[8] = 1024;
                *(_DWORD *)nw_endpoint_t v123 = 5;
                *(_WORD *)&v123[4] = 1024;
                *(_DWORD *)&v123[6] = 42;
                _os_log_impl( &dword_181A5C000,  v27,  v40,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
              }
            }

            goto LABEL_50;
          }

          *uint64_t v24 = 5;
          *(_DWORD *)(v24 + 1) = 42;
          *(_OWORD *)(v24 + 5) = *(_OWORD *)type;
          *(_OWORD *)(v24 + 21) = v113;
          *(void *)(v24 + 37) = v114;
          *(_WORD *)(v24 + 45) = 0;
          os_log_type_t v29 = v24 + 47;
LABEL_26:
          uint64_t v30 = __src;
          goto LABEL_54;
        }

        __nwlog_obj();
        id v74 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136447234;
        id v116 = "nw_necp_append_tlv";
        nw_endpoint_t v117 = 2048;
        unsigned int v118 = (size_t)v24;
        id v119 = 2048;
        int v120 = a3;
        char v121 = 1024;
        *(_DWORD *)unsigned int v122 = 5;
        *(_WORD *)&v122[4] = 1024;
        *(_DWORD *)&v122[6] = 42;
        id v26 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v111 = OS_LOG_TYPE_ERROR;
        uint64_t v110 = 0;
        if (__nwlog_fault(v26, &v111, &v110))
        {
          if (v111 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            char v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_t v75 = v111;
            if (os_log_type_enabled(v27, v111))
            {
              *(_DWORD *)buf = 136447234;
              id v116 = "nw_necp_append_tlv";
              nw_endpoint_t v117 = 2048;
              unsigned int v118 = (size_t)v24;
              id v119 = 2048;
              int v120 = a3;
              char v121 = 1024;
              *(_DWORD *)unsigned int v122 = 5;
              *(_WORD *)&v122[4] = 1024;
              *(_DWORD *)&v122[6] = 42;
              _os_log_impl( &dword_181A5C000,  v27,  v75,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  buf,  0x2Cu);
            }

          id v101 = *(_DWORD *)(a1 + 20);
          if (v101) {
            char v102 = ((int)v16 + *(_DWORD *)(a2 + 68) + 1) % (2 * v101);
          }
          else {
            char v102 = 0;
          }
          unsigned int v103 = header_out_dynamic_entry((unsigned int *)a1, a2, v102);
          __int16 v104 = *(_DWORD *)(a2 + 104);
          if ((v104 & 2) != 0)
          {
            *(_DWORD *)(a2 + 104) = v104 | (32 * (*(_DWORD *)(a2 + 64) == v102));
            if (v103)
            {
LABEL_261:
              v161 = 3816;
              goto LABEL_348;
            }
          }

          else
          {
            *(_DWORD *)(a2 + 104) = v104 | 0x40;
            if (v103) {
              goto LABEL_261;
            }
          }
        }

        goto LABEL_4;
      case 1:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_58;
        }
        nw_endpoint_t v12 = 0;
        char v13 = *(void *)(a2 + 176);
        char v14 = *(_DWORD *)(a2 + 164);
        os_log_type_t v7 = v10;
        goto LABEL_128;
      case 2:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_108;
        }
        __int16 v15 = 0;
        BOOL v16 = *(void *)(a2 + 176);
        uint64_t v17 = *(_DWORD *)(a2 + 164);
        os_log_type_t v7 = v10;
        goto LABEL_150;
      case 3:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_102;
        }
        uint64_t v18 = 0;
        uint64_t v19 = *(void *)(a2 + 176);
        char v14 = *(_DWORD *)(a2 + 164);
        os_log_type_t v7 = v10;
        goto LABEL_163;
      case 4:
        *(_DWORD *)(a2 + 152) = *v10 & 0x80;
        *(_DWORD *)(a2 + 160) = 0;
        *(_DWORD *)(a2 + 136) = 5;
        BOOL v9 = 7LL;
        goto LABEL_21;
      case 5:
        if (*(_DWORD *)(a2 + 160))
        {
          uint64_t v20 = 0;
          __int16 v21 = *(void *)(a2 + 176);
          char v14 = *(_DWORD *)(a2 + 164);
          os_log_type_t v7 = v10;
          goto LABEL_191;
        }

      free(backtrace_string);
      goto LABEL_232;
    }

    __int128 v68 = (os_log_s *)__nwlog_obj();
    __int16 v69 = type;
    if (!os_log_type_enabled(v68, type)) {
      goto LABEL_232;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    int v70 = "%{public}s called with null protocol";
LABEL_231:
    _os_log_impl(&dword_181A5C000, v68, v69, v70, buf, 0xCu);
LABEL_232:
    if (v67) {
      free(v67);
    }
    return 0LL;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    __int16 v67 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v148 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int128 v68 = (os_log_s *)__nwlog_obj();
      __int16 v69 = type;
      if (!os_log_type_enabled(v68, type)) {
        goto LABEL_232;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      int v70 = "%{public}s called with null http3_stream";
      goto LABEL_231;
    }

    if (!v148)
    {
      __int128 v68 = (os_log_s *)__nwlog_obj();
      __int16 v69 = type;
      if (!os_log_type_enabled(v68, type)) {
        goto LABEL_232;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      int v70 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_231;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int128 v68 = (os_log_s *)__nwlog_obj();
    __int16 v69 = type;
    os_log_type_t v100 = os_log_type_enabled(v68, type);
    if (backtrace_string)
    {
      if (v100)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        unsigned __int16 v91 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
        goto LABEL_152;
      }

      goto LABEL_153;
    }

    if (!v100) {
      goto LABEL_232;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
    int v70 = "%{public}s called with null http3_stream, no backtrace";
    goto LABEL_231;
  }

  if ((*((_WORD *)handle + 368) & 0x800) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      os_log_type_t v8 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
      BOOL v9 = *((void *)handle + 30);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136448002;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_remove_input_handler";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 636;
      *(_WORD *)&_BYTE buf[22] = 2080;
      os_log_type_t v151 = (uint64_t)" ";
      LOWORD(v152) = 1024;
      *(_DWORD *)((char *)&v152 + 2) = v8;
      WORD3(v152) = 2048;
      *((void *)&v152 + 1) = v9;
      os_log_type_t v153 = 2048;
      BOOL v154 = a1;
      os_log_type_t v155 = 2048;
      nw_endpoint_t v156 = default_input_handler;
      int v157 = 2048;
      uint64_t v158 = a2;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s%s<i%u:s%llu> protocol %p, default_input_handler %p, input protocol %p",  buf,  0x4Eu);
    }
  }

  BOOL v11 = handle + 736;
  nw_http_transaction_metadata_mark_end(*((void **)handle + 49));
  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if ((*v11 & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      char v71 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v72 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
        __int16 v73 = *((void *)handle + 30);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 636;
        *(_WORD *)&_BYTE buf[22] = 2080;
        os_log_type_t v151 = (uint64_t)" ";
        LOWORD(v152) = 1024;
        *(_DWORD *)((char *)&v152 + 2) = v72;
        WORD3(v152) = 2048;
        *((void *)&v152 + 1) = v73;
        _os_log_impl(&dword_181A5C000, v71, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }

  nw_endpoint_t v12 = (unsigned __int16)*v11;
  if ((v12 & 0x10) != 0)
  {
    char v13 = v12 & 0xFFFFFFEF | (handle[738] << 16);
    const char *v11 = v12 & 0xFFEF;
    handle[738] = BYTE2(v13);
    char v14 = *((void *)handle + 12);
    if (v14)
    {
      __int16 v15 = *(void *)(v14 + 24);
      if (v15)
      {
        BOOL v16 = *(void (**)(void, char *))(v15 + 32);
        if (v16)
        {
          v16(*((void *)handle + 12), handle + 64);
          goto LABEL_15;
        }
      }

      __nwlog_obj();
      id v74 = *(const char **)(v14 + 16);
      if (!v74) {
        id v74 = "invalid";
      }
    }

    else
    {
      __nwlog_obj();
      id v74 = "invalid";
    }

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v74;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v92 = (char *)_os_log_send_and_compose_impl();
    v148 = 0;
    if (__nwlog_fault(v92, &type, &v148))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v93 = (os_log_s *)__nwlog_obj();
        uint64_t v94 = type;
        nw_endpoint_t v142 = v93;
        if (!os_log_type_enabled(v93, type)) {
          goto LABEL_172;
        }
        uint64_t v95 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          uint64_t v95 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v95;
        os_log_type_t v96 = "%{public}s protocol %{public}s has invalid disconnect callback";
LABEL_170:
        BOOL v112 = v142;
        id v113 = v94;
LABEL_171:
        _os_log_impl(&dword_181A5C000, v112, v113, v96, buf, 0x16u);
        goto LABEL_172;
      }

      if (!v148)
      {
        uint64_t v110 = (os_log_s *)__nwlog_obj();
        uint64_t v94 = type;
        nw_endpoint_t v142 = v110;
        if (!os_log_type_enabled(v110, type)) {
          goto LABEL_172;
        }
        os_log_type_t v111 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          os_log_type_t v111 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v111;
        os_log_type_t v96 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        goto LABEL_170;
      }

      int v97 = (char *)__nw_create_backtrace_string();
      v143 = (os_log_s *)__nwlog_obj();
      os_log_t loga = type;
      os_log_type_t v98 = os_log_type_enabled(v143, type);
      if (v97)
      {
        if (v98)
        {
          BOOL v99 = "invalid";
          if (v14 && *(void *)(v14 + 16)) {
            BOOL v99 = *(const char **)(v14 + 16);
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v99;
          *(_WORD *)&_BYTE buf[22] = 2082;
          os_log_type_t v151 = (uint64_t)v97;
          _os_log_impl( &dword_181A5C000,  v143,  loga,  "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v97);
      }

      else if (v98)
      {
        id v131 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          id v131 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v131;
        os_log_type_t v96 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
        BOOL v112 = v143;
        id v113 = loga;
        goto LABEL_171;
      }
    }

void sub_181B66AC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

const char *nw_endpoint_handler_path_status_string(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void *)v1[8];
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = v3[94];

    else {
      uint64_t v5 = off_189BC5688[v4];
    }
  }

  else
  {
    uint64_t v5 = "null";
  }

  return v5;
}

void nw_association_mark_flow_connected(void *a1, void *a2)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v71 = "nw_association_mark_flow_connected";
    __int16 v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v57 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          char v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_181A5C000, v16, v57, "%{public}s called with null association", buf, 0xCu);
        }

        goto LABEL_89;
      }

      if (v68 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v65 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          char v71 = "nw_association_mark_flow_connected";
          _os_log_impl( &dword_181A5C000,  v16,  v65,  "%{public}s called with null association, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_89;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v61 = type;
      BOOL v62 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          char v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_181A5C000, v16, v61, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }

        goto LABEL_89;
      }

      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        char v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __int16 v73 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v16,  v61,  "%{public}s called with null association, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    goto LABEL_90;
  }

  if (!v4)
  {
    __nwlog_obj();
    char v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v71 = "nw_association_mark_flow_connected";
    __int16 v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v59 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          char v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_181A5C000, v16, v59, "%{public}s called with null handle", buf, 0xCu);
        }

        goto LABEL_89;
      }

      if (v68 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v66 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          char v71 = "nw_association_mark_flow_connected";
          _os_log_impl( &dword_181A5C000,  v16,  v66,  "%{public}s called with null handle, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_89;
      }

      uint64_t v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v63 = type;
      BOOL v64 = os_log_type_enabled(v16, type);
      if (!v24)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          char v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_181A5C000, v16, v63, "%{public}s called with null handle, no backtrace", buf, 0xCu);
        }

        goto LABEL_89;
      }

      if (v64)
      {
        *(_DWORD *)buf = 136446466;
        char v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __int16 v73 = v24;
        _os_log_impl( &dword_181A5C000,  v16,  v63,  "%{public}s called with null handle, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_60;
    }

LABEL_93:
}

    free(backtrace_string);
    goto LABEL_123;
  }

  if (!v11
    && (a4 & 1) == 0
    && (v12 == &__block_literal_global_3_41839
     || v12 == &__block_literal_global_41831
     || v12 == &__block_literal_global_4
     || v12 == &__block_literal_global_5_41854))
  {
    os_log_type_t v17 = 0LL;
    __nwlog_obj();
    os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v72 = "nw_write_request_create";
    __int16 v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v69 = 0;
    if (__nwlog_fault(v41, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v72 = "nw_write_request_create";
          _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s Send content may only be nil if the request is marked as complete",  buf,  0xCu);
        }
      }

      else if (v69)
      {
        uint32_t v50 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v51 = type;
        os_log_type_t v52 = os_log_type_enabled(v42, type);
        if (v50)
        {
          if (v52)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v72 = "nw_write_request_create";
            __int16 v73 = 2082;
            __int16 v74 = v50;
            _os_log_impl( &dword_181A5C000,  v42,  v51,  "%{public}s Send content may only be nil if the request is marked as complete, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v50);
          goto LABEL_103;
        }

        if (v52)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v72 = "nw_write_request_create";
          _os_log_impl( &dword_181A5C000,  v42,  v51,  "%{public}s Send content may only be nil if the request is marked as complete, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v58 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v72 = "nw_write_request_create";
          _os_log_impl( &dword_181A5C000,  v42,  v58,  "%{public}s Send content may only be nil if the request is marked as complete, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v29) {
    free(v29);
  }
  id v26 = 0LL;
LABEL_34:

  return v26;
}

      free(backtrace_string);
      goto LABEL_105;
    }

    id v45 = (os_log_s *)__nwlog_obj();
    uint64_t v46 = v62[0];
    if (!os_log_type_enabled(v45, (os_log_type_t)v62[0])) {
      goto LABEL_105;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
    os_log_type_t v47 = "%{public}s called with null protocol";
LABEL_104:
    _os_log_impl(&dword_181A5C000, v45, v46, v47, buf, 0xCu);
LABEL_105:
    if (v44) {
      free(v44);
    }
    return 0LL;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
    char v44 = (char *)_os_log_send_and_compose_impl();
    v62[0] = 16;
    __p.__r_.__value_.__s.__data_[0] = 0;
    if (v62[0] == 17)
    {
      id v45 = (os_log_s *)__nwlog_obj();
      uint64_t v46 = v62[0];
      if (!os_log_type_enabled(v45, (os_log_type_t)v62[0])) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      os_log_type_t v47 = "%{public}s called with null http_sniffing";
      goto LABEL_104;
    }

    if (!__p.__r_.__value_.__s.__data_[0])
    {
      id v45 = (os_log_s *)__nwlog_obj();
      uint64_t v46 = v62[0];
      if (!os_log_type_enabled(v45, (os_log_type_t)v62[0])) {
        goto LABEL_105;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      os_log_type_t v47 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
      goto LABEL_104;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v45 = (os_log_s *)__nwlog_obj();
    uint64_t v46 = v62[0];
    os_log_type_t v52 = os_log_type_enabled(v45, (os_log_type_t)v62[0]);
    if (backtrace_string)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        id v51 = "%{public}s called with null http_sniffing, dumping backtrace:%{public}s";
        goto LABEL_92;
      }

      goto LABEL_93;
    }

    if (!v52) {
      goto LABEL_105;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
    os_log_type_t v47 = "%{public}s called with null http_sniffing, no backtrace";
    goto LABEL_104;
  }

  if ((handle[198] & 1) == 0)
  {
    if (gLogDatapath)
    {
      id v48 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = handle + 114;
        *(_WORD *)&_BYTE buf[22] = 2080;
        char v67 = (__n128 (*)(uint64_t, uint64_t))" ";
        *(_WORD *)os_log_type_t v68 = 1024;
        *(_DWORD *)&v68[2] = a3;
        *(_WORD *)&v68[6] = 1024;
        *(_DWORD *)&v68[8] = a4;
        *(_WORD *)&v68[12] = 1024;
        *(_DWORD *)&v68[14] = a5;
        _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sminimum bytes %u, maximum bytes %u, maximum frame count %u",  buf,  0x32u);
      }
    }
  }

  if ((handle[428] & 1) != 0)
  {
    input_frames = 0LL;
    if ((handle[198] & 1) != 0 || !gLogDatapath) {
      return input_frames;
    }
    id v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = handle + 114;
      *(_WORD *)&_BYTE buf[22] = 2080;
      char v67 = (__n128 (*)(uint64_t, uint64_t))" ";
      _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%salready getting input frames, returning 0",  buf,  0x20u);
      return 0LL;
    }

    return 0LL;
  }

  handle[428] |= 1u;
  nw_endpoint_t v12 = handle[548];
  if ((v12 & 1) != 0)
  {
    do
    {
      *(void *)buf = 0LL;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3802000000LL;
      char v67 = __Block_byref_object_copy__519;
      *(void *)os_log_type_t v68 = __Block_byref_object_dispose__520;
      *(void *)&v68[8] = 0LL;
      *(void *)&v68[16] = &v68[8];
      uint64_t v24 = a5;
      os_log_type_t v25 = a4;
      id v26 = a3;
      if (*((void *)handle + 56))
      {
        uint64_t v27 = *((_DWORD *)handle + 136);
        else {
          id v26 = a3 - v27;
        }
        __int16 v15 = a4 >= v27;
        BOOL v28 = a4 - v27;
        if (v28 != 0 && v15)
        {
          id v29 = *((_DWORD *)handle + 130) - *((_DWORD *)handle + 132) + 512;
          if (v28 <= v29) {
            os_log_type_t v25 = v29;
          }
          else {
            os_log_type_t v25 = v28;
          }
        }

        else
        {
          os_log_type_t v25 = (*((_DWORD *)handle + 130) - *((_DWORD *)handle + 132) + 512);
        }

        uint64_t v24 = 0xFFFFFFFFLL;
      }

      if (nw_protocol_get_input_frames( (uint64_t)a1->output_handler,  (uint64_t)a1,  v26,  v25,  v24,  (uint64_t)&v68[8])
        && *(void *)(*(void *)&buf[8] + 40LL))
      {
        *(void *)BOOL v62 = 0LL;
        *(void *)&v62[8] = v62;
        *(void *)&v62[16] = 0x3802000000LL;
        os_log_type_t v63 = __Block_byref_object_copy__14;
        *(void *)&BOOL v64 = __Block_byref_object_dispose__15;
        if (nw_protocol_copy_http_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
        }
        *((void *)&v64 + 1) = (id)nw_protocol_copy_http_definition_http_definition;
        v65 |= 1u;
        v55[0] = MEMORY[0x1895F87A8];
        v55[1] = 0x40000000LL;
        BOOL v56 = (uint64_t (*)(void *))___ZL42nw_protocol_http_sniffing_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
        os_log_type_t v57 = &unk_189BB5A30;
        os_log_type_t v59 = buf;
        size_t v60 = handle;
        char v58 = v62;
        uint64_t v30 = *(void *)(*(void *)&buf[8] + 40LL);
        do
        {
          if (!v30) {
            break;
          }
          char v31 = *(void *)(v30 + 32);
          mach_vm_address_t v32 = v56(v55);
          uint64_t v30 = v31;
        }

        while ((v32 & 1) != 0);
        _Block_object_dispose(v62, 8);
        if ((v65 & 1) != 0 && *((void *)&v64 + 1)) {
          os_release(*((void **)&v64 + 1));
        }
        os_log_type_t v33 = 1;
      }

      else
      {
        __int16 v34 = handle[548];
        if ((~v34 & 3) == 0)
        {
          handle[548] = v34 & 0xFE;
          nw_http_sniffing_guess_media_type(&__p, (uint64_t)handle);
          size_t size = __p.__r_.__value_.__s.__size_;
          os_log_type_t v36 = __p.__r_.__value_.__s.__size_;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            size_t size = __p.__r_.__value_.__l.__size_;
          }
          if (size)
          {
            if ((handle[198] & 1) == 0)
            {
              if (gLogDatapath)
              {
                os_log_type_t v40 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
                {
                  p_p = &__p;
                  if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  *(_DWORD *)BOOL v62 = 136446978;
                  *(void *)&v62[4] = "nw_http_sniffing_stop";
                  *(_WORD *)&v62[12] = 2082;
                  *(void *)&v62[14] = handle + 114;
                  *(_WORD *)&v62[22] = 2080;
                  os_log_type_t v63 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  LOWORD(v64) = 2080;
                  *(void *)((char *)&v64 + 2) = p_p;
                  _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%smedia type %s",  v62,  0x2Au);
                }
              }
            }

            client_metadata_in_parameters = nw_http_messaging_options_find_or_create_client_metadata_in_parameters( *((void **)handle + 60),  (uint64_t)handle);
            os_log_type_t v36 = __p.__r_.__value_.__s.__size_;
            if (client_metadata_in_parameters)
            {
              os_log_type_t v38 = client_metadata_in_parameters;
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                id v39 = &__p;
              }
              else {
                id v39 = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              nw_http_client_metadata_set_sniffed_media_type(client_metadata_in_parameters, (uint64_t)v39);
              os_release(v38);
              os_log_type_t v36 = __p.__r_.__value_.__s.__size_;
            }
          }

          if ((v36 & 0x80) != 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }

        os_log_type_t v33 = 0;
      }

      _Block_object_dispose(buf, 8);
      nw_endpoint_t v12 = handle[548];
    }

    while (v33 && (handle[548] & 1) != 0);
  }

  if ((v12 & 1) != 0)
  {
    if (*((void *)handle + 56))
    {
      input_frames = 0LL;
      os_log_type_t v21 = &qword_18C45F000;
    }

    else
    {
      *(_DWORD *)BOOL v62 = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
      input_frames = nw_protocol_fulfill_frame_request( (void *)handle + 54,  (uint64_t)a6,  a3,  a4,  a5,  (unsigned int *)v62,  &__p);
      os_log_type_t v42 = *((_DWORD *)handle + 136);
      __int16 v15 = v42 >= *(_DWORD *)v62;
      *((_DWORD *)handle + 136) = v42 - *(_DWORD *)v62;
      os_log_type_t v21 = &qword_18C45F000;
      if (!v15)
      {
        if (!gLogDatapath) {
          goto LABEL_70;
        }
        uint64_t v22 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_70;
        }
        goto LABEL_109;
      }
    }
  }

  else
  {
    if (*((void *)handle + 54))
    {
      id v13 = *((_DWORD *)handle + 136);
      char v14 = a4 - v13;
      if (a4 > v13)
      {
        __int16 v15 = a3 >= v13;
        BOOL v16 = a3 - v13;
        os_log_type_t v17 = v15 ? v16 : 1LL;
        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        nw_protocol_get_input_frames((uint64_t)a1->output_handler, (uint64_t)a1, v17, v14, a5, (uint64_t)buf);
        if (*(void *)buf)
        {
          **((void **)handle + 55) = *(void *)buf;
          uint64_t v18 = *(void *)&buf[8];
          *(void *)(*(void *)buf + 40LL) = *((void *)handle + 55);
          *((void *)handle + 55) = v18;
        }
      }

      *(_DWORD *)BOOL v62 = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
      input_frames = nw_protocol_fulfill_frame_request( (void *)handle + 54,  (uint64_t)a6,  a3,  a4,  a5,  (unsigned int *)v62,  &__p);
      uint64_t v20 = *((_DWORD *)handle + 136);
      __int16 v15 = v20 >= *(_DWORD *)v62;
      *((_DWORD *)handle + 136) = v20 - *(_DWORD *)v62;
      os_log_type_t v21 = &qword_18C45F000;
      if (v15) {
        goto LABEL_71;
      }
      if (!gLogDatapath) {
        goto LABEL_70;
      }
      uint64_t v22 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_70;
      }
LABEL_109:
      os_log_type_t v54 = *((unsigned int *)handle + 136);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = "http_sniffing->pending_input_frames_byte_count";
      *(_WORD *)&_BYTE buf[22] = 2048;
      char v67 = (__n128 (*)(uint64_t, uint64_t))*(unsigned int *)v62;
      *(_WORD *)os_log_type_t v68 = 2048;
      *(void *)&v68[2] = v54;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
LABEL_70:
      *((_DWORD *)handle + 136) = 0;
      goto LABEL_71;
    }

    input_frames = nw_protocol_get_input_frames((uint64_t)a1->output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
    os_log_type_t v21 = &qword_18C45F000;
  }

      goto LABEL_94;
    }

    if (!v53)
    {
      __nwlog_obj();
      id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v51 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
        _os_log_impl( &dword_181A5C000,  v29,  v51,  "%{public}s called with null completion, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_93;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v44 = type;
    id v45 = os_log_type_enabled(v29, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
        _os_log_impl(&dword_181A5C000, v29, v44, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_93;
    }

    if (v45)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "network_config_set_opportunistic_blocked";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v29,  v44,  "%{public}s called with null completion, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_67;
  }

  if (v42) {
    free(v42);
  }
LABEL_6:
}

    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
    if ((v16 & 1) != 0) {
      goto LABEL_114;
    }
    goto LABEL_94;
  }

  __nwlog_obj();
  os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
  uint64_t v18 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v61) = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v22 = type[0];
    if (os_log_type_enabled(v19, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
      _os_log_impl(&dword_181A5C000, v19, v22, "%{public}s called with null path_state", buf, 0xCu);
    }

    goto LABEL_81;
  }

  if (!(_BYTE)v61)
  {
    __nwlog_obj();
    id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v40 = type[0];
    if (os_log_type_enabled(v19, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
      _os_log_impl( &dword_181A5C000,  v19,  v40,  "%{public}s called with null path_state, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_81;
  }

  os_log_type_t v33 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v34 = type[0];
  nw_endpoint_t v35 = os_log_type_enabled(v19, type[0]);
  if (!v33)
  {
    if (v35)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
      _os_log_impl(&dword_181A5C000, v19, v34, "%{public}s called with null path_state, no backtrace", buf, 0xCu);
    }

    goto LABEL_81;
  }

  if (v35)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_tear_down_path_inner";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v33;
    _os_log_impl( &dword_181A5C000,  v19,  v34,  "%{public}s called with null path_state, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v33);
  if (v18) {
    goto LABEL_83;
  }
LABEL_120:
}

    if (v36) {
      free(v36);
    }
    goto LABEL_143;
  }

  uint64_t v4 = BYTE6(v1->flow_in_connected);
  id v6 = (v1->flow_in_connected & 0x800000000000LL) != 0 || gLogDatapath == 0;
  if ((v1->flow_in_connected & 0x1000000000000LL) == 0)
  {
    if (!v6)
    {
      __nwlog_obj();
      os_log_type_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        char v89 = "nw_protocol_implementation_teardown";
        int v90 = 2082;
        unsigned __int16 v91 = (char *)&v3->flow_in_connected + 7;
        int v92 = 2080;
        char v93 = " ";
        _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sTearing down protocol",  buf,  0x20u);
      }

      uint64_t v4 = BYTE6(v3->flow_in_connected);
    }

    BYTE6(v3->flow_in_connected) = v4 | 1;
    internal_reference = (uint64_t)v3->internal_reference;
    if (internal_reference)
    {
      nw_queue_cancel_source(internal_reference, v2);
      v3->internal_reference = 0LL;
    }

    os_log_type_t v8 = *(void **)&v3->level;
    if (v8)
    {
      nw_protocol_instance_registrar_remove_instance(v8, (uint64_t)&v3[-1].paths_log_id_num);
      BOOL v9 = *(void **)&v3->level;
      *(void *)&v3->level = 0LL;
    }

    var16 = (uint64_t (*)(NWConcrete_nw_protocol_instance *, uint64_t, uint64_t))v3->parent_definition->extended_state->var16;
    if (!var16 || (var16(v3, -1LL, 3LL) & 1) != 0) {
      goto LABEL_39;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v89 = "nw_protocol_implementation_teardown";
    nw_endpoint_t v12 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(p_paths_log_id_num) = 0;
    if (__nwlog_fault(v12, type, &p_paths_log_id_num))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v13 = (os_log_s *)(id)gLogObj;
        char v14 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          char v89 = "nw_protocol_implementation_teardown";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS", buf, 0xCu);
        }
      }

      else if ((_BYTE)p_paths_log_id_num)
      {
        BOOL v16 = __nw_create_backtrace_string();
        if (v16)
        {
          os_log_type_t v17 = (char *)v16;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v18 = (os_log_s *)(id)gLogObj;
          id v19 = type[0];
          if (os_log_type_enabled(v18, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            char v89 = "nw_protocol_implementation_teardown";
            int v90 = 2082;
            unsigned __int16 v91 = v17;
            _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v17);
          if (v12) {
            goto LABEL_38;
          }
          goto LABEL_39;
        }

        __nwlog_obj();
        id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          char v89 = "nw_protocol_implementation_teardown";
          _os_log_impl( &dword_181A5C000,  v13,  v21,  "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v13 = (os_log_s *)(id)gLogObj;
        uint64_t v20 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          char v89 = "nw_protocol_implementation_teardown";
          _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v12) {
LABEL_38:
    }
      free(v12);
LABEL_39:
    BYTE4(v3->flow_in_connected) |= 4u;
    nw_protocol_remove_instance((uint64_t)&v3[-1].paths_log_id_num);
    uint64_t v22 = v3;
    nw_array_apply((unsigned __int8 *)v22->pending_outbound_frames.tqh_first, (uint64_t)&__block_literal_global_275);
    tqh_first = v22->pending_outbound_frames.tqh_first;
    v22->pending_outbound_frames.tqh_first = 0LL;

    uint64_t v24 = *(const char **)&v22[-1].log_str[25];
    if (!v24) {
      goto LABEL_133;
    }
    flow_registration = (char *)v22->flow_registration;
    if (flow_registration)
    {
      v80[0] = MEMORY[0x1895F87A8];
      v80[1] = 3221225472LL;
      v80[2] = ___ZL35nw_protocol_implementation_teardownP31NWConcrete_nw_protocol_instance_block_invoke;
      v80[3] = &unk_189BC86F0;
      uint64_t v81 = v22;
      nw_hash_table_apply(flow_registration, (uint64_t)v80);

      uint64_t v24 = *(const char **)&v22[-1].log_str[25];
      if (!v24)
      {
LABEL_133:
        char v67 = *(void *)&v22->_anon_0[8];
        if (v67)
        {
          if (*(void *)v67)
          {
            os_log_type_t v68 = *(void (**)(uint64_t, unsigned __int16 *))(*(void *)v67 + 8LL);
            if (v68) {
              v68(v67, &v3[-1].paths_log_id_num);
            }
          }

          *(void *)&v22->_anon_0[8] = 0LL;
        }

        ((void (*)(NWConcrete_nw_protocol_instance *))v3->parent_definition->extended_state->var6)(v22);
        __int16 v69 = nw_parameters_copy_context(v22->destroy_timer);
        nw_context_reset_timer_block_with_time(v69, (uint64_t)v22, -1LL, 0LL);

        new_flow_uint64_t metadata = v22->new_flow_metadata;
        v22->new_flow_uint64_t metadata = 0LL;

        BYTE4(v3->flow_in_connected) &= ~0x10u;
        handle = (uint64_t)v22->handle;
        if (handle)
        {
          do
          {
            __int16 v72 = *(void *)(handle + 16);
            nw_frame_finalize(handle);
            handle = v72;
          }

          while (v72);
        }

        __int16 v73 = (uint64_t)v22->inbound_frames.tqh_first;
        if (v73)
        {
          do
          {
            __int16 v74 = *(void *)(v73 + 16);
            nw_frame_finalize(v73);
            __int16 v73 = v74;
          }

          while (v74);
        }

        nw_protocol_implementation_destroy(v22);
        BYTE6(v3->flow_in_connected) &= ~1u;
        goto LABEL_143;
      }
    }

    id v26 = (void *)*((void *)v24 + 5);
    if (v26 == &nw_protocol_ref_counted_handle)
    {
      BOOL v28 = *((void *)v24 + 11);
      if (v28) {
        *((void *)v24 + 11) = v28 + 1;
      }
      uint64_t v27 = -1;
    }

    else
    {
      uint64_t v27 = 0;
    }

    *(void *)os_log_type_t type = v24;
    uint64_t v87 = v27;
    id v29 = *(void **)&v22[-1].log_str[33];
    if (v29 == &nw_protocol_ref_counted_handle)
    {
      char v31 = *(void *)&v22[-1].log_str[81];
      if (v31) {
        *(void *)&v22[-1].log_str[81] = v31 + 1;
      }
      uint64_t v30 = -1;
    }

    else
    {
      uint64_t v30 = 0;
    }

    p_paths_log_id_num = &v3[-1].paths_log_id_num;
    id v85 = v30;
    mach_vm_address_t v32 = *((void *)v24 + 3);
    if (v32)
    {
      os_log_type_t v33 = *(uint64_t (**)(const char *, unsigned __int16 *, uint64_t))(v32 + 8);
      if (v33)
      {
        __int16 v34 = v33(v24, &v3[-1].paths_log_id_num, 1LL);
        if (v29 != &nw_protocol_ref_counted_handle) {
          goto LABEL_55;
        }
        goto LABEL_108;
      }
    }

    __nwlog_obj();
    int v43 = (void *)objc_claimAutoreleasedReturnValue();
    char v44 = (const char *)*((void *)v24 + 2);
    *(_DWORD *)buf = 136446722;
    char v89 = "__nw_protocol_remove_input_handler";
    if (!v44) {
      char v44 = "invalid";
    }
    int v90 = 2082;
    unsigned __int16 v91 = (char *)v44;
    int v92 = 2048;
    char v93 = v24;
    id v45 = (char *)_os_log_send_and_compose_impl();

    id v83 = OS_LOG_TYPE_ERROR;
    unsigned int v82 = 0;
    if (__nwlog_fault(v45, &v83, &v82))
    {
      if (v83 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = v83;
        if (os_log_type_enabled(v46, v83))
        {
          id v48 = (const char *)*((void *)v24 + 2);
          if (!v48) {
            id v48 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          char v89 = "__nw_protocol_remove_input_handler";
          int v90 = 2082;
          unsigned __int16 v91 = (char *)v48;
          int v92 = 2048;
          char v93 = v24;
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback",  buf,  0x20u);
        }

LABEL_94:
    if (!v20) {
      goto LABEL_108;
    }
LABEL_95:
    BOOL v56 = (char *)v20;
LABEL_107:
    free(v56);
    goto LABEL_108;
  }

  nw_endpoint_t v12 = v9;
  id v13 = -[nw_endpoint port](v12, "port");

  if (!v13)
  {
    mach_vm_address_t address = (sockaddr *)nw_endpoint_get_address(v12);
    host = (nw_endpoint *)nw_endpoint_create_address_with_port(&address->sa_len, a2);
    if (host) {
      goto LABEL_14;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v39 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    BOOL v62 = "nw_listener_copy_parameters_with_port";
    __int16 v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v59 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v62 = "nw_listener_copy_parameters_with_port";
        _os_log_impl(&dword_181A5C000, v24, v40, "%{public}s nw_endpoint_create_address_with_port failed", buf, 0xCu);
      }
    }

    else if (v59)
    {
      id v51 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      BOOL v53 = os_log_type_enabled(v24, type);
      if (v51)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v62 = "nw_listener_copy_parameters_with_port";
          os_log_type_t v63 = 2082;
          BOOL v64 = v51;
          _os_log_impl( &dword_181A5C000,  v24,  v52,  "%{public}s nw_endpoint_create_address_with_port failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v51);
        if (!v15) {
          goto LABEL_108;
        }
        goto LABEL_106;
      }

      if (v53)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v62 = "nw_listener_copy_parameters_with_port";
        _os_log_impl( &dword_181A5C000,  v24,  v52,  "%{public}s nw_endpoint_create_address_with_port failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v62 = "nw_listener_copy_parameters_with_port";
        _os_log_impl( &dword_181A5C000,  v24,  v57,  "%{public}s nw_endpoint_create_address_with_port failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_104;
  }

  if (!strncmp(a2, "0", 2uLL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v37 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v62 = "nw_listener_copy_parameters_with_port";
      _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s Create with port used port 0, using port from local endpoint",  buf,  0xCu);
    }
  }

  else if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    BOOL v62 = "nw_listener_copy_parameters_with_port";
    os_log_type_t v63 = 2082;
    BOOL v64 = (char *)a2;
    os_log_type_t v65 = 2114;
    os_log_type_t v66 = (char *)v12;
    __int16 v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v59 = 0;
    if (__nwlog_fault(v15, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446722;
          BOOL v62 = "nw_listener_copy_parameters_with_port";
          os_log_type_t v63 = 2082;
          BOOL v64 = (char *)a2;
          os_log_type_t v65 = 2114;
          os_log_type_t v66 = (char *)v12;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Local endpoint has port set, cannot override to %{public}s: %{public}@",  buf,  0x20u);
        }
      }

      else if (v59)
      {
        uint64_t v46 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = type;
        id v48 = os_log_type_enabled(v16, type);
        if (v46)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446978;
            BOOL v62 = "nw_listener_copy_parameters_with_port";
            os_log_type_t v63 = 2082;
            BOOL v64 = (char *)a2;
            os_log_type_t v65 = 2114;
            os_log_type_t v66 = (char *)v12;
            char v67 = 2082;
            os_log_type_t v68 = v46;
            _os_log_impl( &dword_181A5C000,  v16,  v47,  "%{public}s Local endpoint has port set, cannot override to %{public}s: %{public}@, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v46);
          if (!v15) {
            goto LABEL_108;
          }
          goto LABEL_106;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446722;
          BOOL v62 = "nw_listener_copy_parameters_with_port";
          os_log_type_t v63 = 2082;
          BOOL v64 = (char *)a2;
          os_log_type_t v65 = 2114;
          os_log_type_t v66 = (char *)v12;
          _os_log_impl( &dword_181A5C000,  v16,  v47,  "%{public}s Local endpoint has port set, cannot override to %{public}s: %{public}@, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446722;
          BOOL v62 = "nw_listener_copy_parameters_with_port";
          os_log_type_t v63 = 2082;
          BOOL v64 = (char *)a2;
          os_log_type_t v65 = 2114;
          os_log_type_t v66 = (char *)v12;
          _os_log_impl( &dword_181A5C000,  v16,  v55,  "%{public}s Local endpoint has port set, cannot override to %{public}s: %{public}@, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    goto LABEL_94;
  }

  if (v10)
  {
    nw_endpoint_t v12 = (void **)v9[19];
    if (v12)
    {
      id v13 = (void **)v11[19];
      if (v13)
      {
        char v14 = v9[23];
        __int16 v15 = 3;
        if (v14)
        {
          BOOL v16 = v14;
          os_log_type_t v17 = v16[170];

          if ((v17 & 1) != 0) {
            __int16 v15 = 4;
          }
          else {
            __int16 v15 = 3;
          }
        }

        if (a4) {
          uint64_t v18 = 2;
        }
        else {
          uint64_t v18 = 1;
        }
        if (a5) {
          id v19 = v15;
        }
        else {
          id v19 = v18;
        }
        *(void *)buf = 0LL;
        *(void *)os_log_type_t type = 0LL;
        if (nw_protocol_stack_application_protocols_are_equal_below(v12, a2, v13, a4, v19, buf, type))
        {
          v62[0] = MEMORY[0x1895F87A8];
          v62[1] = 3221225472LL;
          v62[2] = __nw_parameters_inherit_protocol_instances_block_invoke;
          v62[3] = &unk_189BB8DB8;
          BOOL v64 = *(void *)buf;
          os_log_type_t v65 = *(void *)type;
          os_log_type_t v63 = v13;
          nw_protocol_stack_iterate_application_protocols_with_index(v12, v62);
        }

        uint64_t v20 = v12[3];
        if (v20 && v13[3])
        {
          os_log_type_t v21 = v20;
          uint64_t v22 = v21[1];

          if (nw_protocol_options_matches_definition(v13[3], v22))
          {
            nw_protocol_options_inherit_log_id(v13[3], v12[3]);
            protocol_handle = nw_protocol_options_get_protocol_handle(v13[3]);
            nw_protocol_options_set_instance(v12[3], protocol_handle);
          }
        }

        uint64_t v24 = v12[4];
        if (v24 && v13[4])
        {
          os_log_type_t v25 = v24;
          id v26 = v25[1];

          if (nw_protocol_options_matches_definition(v13[4], v26))
          {
            nw_protocol_options_inherit_log_id(v13[4], v12[4]);
            uint64_t v27 = nw_protocol_options_get_protocol_handle(v13[4]);
            nw_protocol_options_set_instance(v12[4], v27);
          }
        }

        BOOL v28 = v12[6];
        if (v28 && v13[6])
        {
          id v29 = v28;
          uint64_t v30 = v29[1];

          if (nw_protocol_options_matches_definition(v13[6], v30))
          {
            nw_protocol_options_inherit_log_id(v13[6], v12[6]);
            char v31 = nw_protocol_options_get_protocol_handle(v13[6]);
            nw_protocol_options_set_instance(v12[6], v31);
          }
        }

  if (v44) {
    free(v44);
  }
  return 0LL;
}

    free(backtrace_string);
    goto LABEL_58;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    os_log_type_t v47 = "nw_endpoint_create_apple_service";
    id v48 = 2082;
    os_log_type_t v49 = "apple_id";
    uint32_t v50 = 1024;
    LODWORD(v51) = 1024;
    _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", buf, 0x1Cu);
  }

    free(backtrace_string);
    goto LABEL_58;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    os_log_type_t v47 = "nw_endpoint_create_application_service_with_alias";
    id v48 = 2082;
    os_log_type_t v49 = "application_service";
    uint32_t v50 = 1024;
    LODWORD(v51) = 1024;
    _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", buf, 0x1Cu);
  }

  if (v38) {
    free(v38);
  }
LABEL_24:
}

    if (v54) {
      free(v54);
    }
    uint64_t v30 = 0LL;
    goto LABEL_98;
  }

  uint64_t v30 = calloc(1uLL, 0x118uLL);
  if (!v30)
  {
    id v221 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v221, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "strict_calloc";
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = 1LL;
    *(_WORD *)&_BYTE buf[22] = 2048;
    v344 = 280LL;
    v222 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v222);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v222);
  }

  v30[34] = 0LL;
  *((_OWORD *)v30 + 15) = 0u;
  *((_OWORD *)v30 + 16) = 0u;
  *((_OWORD *)v30 + 13) = 0u;
  *((_OWORD *)v30 + 14) = 0u;
  *((_OWORD *)v30 + 11) = 0u;
  *((_OWORD *)v30 + 12) = 0u;
  *((_OWORD *)v30 + 9) = 0u;
  *((_OWORD *)v30 + 10) = 0u;
  *((_OWORD *)v30 + 7) = 0u;
  *((_OWORD *)v30 + _Block_object_dispose(va, 8) = 0u;
  *((_OWORD *)v30 + 5) = 0u;
  *((_OWORD *)v30 + 6) = 0u;
  *((_OWORD *)v30 + 3) = 0u;
  *((_OWORD *)v30 + 4) = 0u;
  *((_OWORD *)v30 + 1) = 0u;
  *((_OWORD *)v30 + 2) = 0u;
  *(_OWORD *)uint64_t v30 = 0u;
  v30[2] = identifier;
  v30[3] = &nw_protocol_webtransport_stream_callbacks(void)::protocol_callbacks;
  v30[5] = v30;
  v30[9] = 0LL;
  v30[10] = v30 + 9;
  v30[11] = handle;
  char v31 = os_retain(v11);
  mach_vm_address_t v32 = *((_BYTE *)v30 + 136);
  if ((v32 & 1) != 0)
  {
    os_log_type_t v33 = (void *)v30[16];
    if (v33)
    {
      os_release(v33);
      mach_vm_address_t v32 = *((_BYTE *)v30 + 136);
    }
  }

  v30[16] = v31;
  *((_BYTE *)v30 + 136) = v32 | 1;
  __int16 v34 = os_retain(v9);
  nw_endpoint_t v35 = *((_BYTE *)v30 + 152);
  if ((v35 & 1) != 0)
  {
    os_log_type_t v36 = (void *)v30[18];
    if (v36)
    {
      os_release(v36);
      nw_endpoint_t v35 = *((_BYTE *)v30 + 152);
    }
  }

  v30[18] = v34;
  *((_BYTE *)v30 + 152) = v35 | 1;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_60063);
  }
  singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_webtransport_definition::definition);
  os_log_type_t v38 = *((_BYTE *)v30 + 168);
  if ((v38 & 1) != 0)
  {
    id v39 = (void *)v30[20];
    if (v39)
    {
      os_release(v39);
      os_log_type_t v38 = *((_BYTE *)v30 + 168);
    }
  }

  v30[20] = singleton;
  *((_BYTE *)v30 + 16_Block_object_dispose(va, 8) = v38 | 1;
  if (nw_path_parameters_get_logging_disabled(v9[13])) {
    os_log_type_t v40 = 16;
  }
  else {
    os_log_type_t v40 = 0;
  }
  *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xEF | v40;
  v30[8] = -1LL;
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000LL;
  v344 = (uint64_t)v30;
  aBlock = MEMORY[0x1895F87A8];
  v333 = 0x40000000LL;
  v334 = ___ZL38nw_protocol_webtransport_stream_createPK22nw_protocol_identifierP23nw_webtransport_sessionP11nw_endpointP13nw_parameters_block_invoke;
  v335 = &unk_189BBC3F8;
  v336 = (os_log_type_t *)buf;
  v30[22] = _Block_copy(&aBlock);
  _Block_object_dispose(buf, 8);
  if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v227 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v227, OS_LOG_TYPE_DEBUG))
      {
        if (v30) {
          v228 = (const char *)(v30 + 24);
        }
        else {
          v228 = "";
        }
        uint64_t v229 = " ";
        if (!v30) {
          uint64_t v229 = "";
        }
        char v230 = v30[11];
        if (v230) {
          v231 = *(_DWORD *)(v230 + 460);
        }
        else {
          v231 = -1;
        }
        v290 = v30[8];
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_stream_create";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v228;
        *(_WORD *)&_BYTE buf[22] = 2080;
        v344 = (uint64_t)v229;
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v231;
        *(_WORD *)&v345[6] = 2048;
        *(void *)&v345[8] = v290;
        *(_WORD *)&v345[16] = 2048;
        *(void *)&v345[18] = v30;
        _os_log_impl( &dword_181A5C000,  v227,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> created WebTransport stream with protocol pointer %p",  buf,  0x3Au);
      }
    }
  }

  os_release(v29);
  if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v232 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v232, OS_LOG_TYPE_DEBUG))
      {
        __int16 v233 = v30[11];
        if (v233) {
          v234 = *(_DWORD *)(v233 + 460);
        }
        else {
          v234 = -1;
        }
        v291 = v30[8];
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_add_input_handler";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v30 + 24;
        *(_WORD *)&_BYTE buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v234;
        *(_WORD *)&v345[6] = 2048;
        *(void *)&v345[8] = v291;
        _os_log_impl(&dword_181A5C000, v232, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }

  nw_protocol_set_input_handler((uint64_t)v30, (uint64_t)v329);
  *(_OWORD *)uint64_t v30 = *(_OWORD *)v329->flow_id;
  nw_protocol_set_output_handler((uint64_t)v329, (uint64_t)v30);
  __int16 v41 = (nw_protocol *)v30[11];
  if (!v41)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_stream_add_input_handler";
    unint64_t v223 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (aBlock == 17)
    {
      char v224 = (os_log_s *)__nwlog_obj();
      id v225 = aBlock;
      if (!os_log_type_enabled(v224, (os_log_type_t)aBlock)) {
        goto LABEL_498;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_add_input_handler";
      v226 = "%{public}s called with null options_protocol";
    }

    else if (v339[0])
    {
      v267 = (char *)__nw_create_backtrace_string();
      char v224 = (os_log_s *)__nwlog_obj();
      id v225 = aBlock;
      v268 = os_log_type_enabled(v224, (os_log_type_t)aBlock);
      if (v267)
      {
        if (v268)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_add_input_handler";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v267;
          _os_log_impl( &dword_181A5C000,  v224,  v225,  "%{public}s called with null options_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v267);
        goto LABEL_498;
      }

      if (!v268)
      {
LABEL_498:
        if (v223) {
          free(v223);
        }
        goto LABEL_98;
      }

      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_add_input_handler";
      v226 = "%{public}s called with null options_protocol, no backtrace";
    }

    else
    {
      char v224 = (os_log_s *)__nwlog_obj();
      id v225 = aBlock;
      if (!os_log_type_enabled(v224, (os_log_type_t)aBlock)) {
        goto LABEL_498;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_add_input_handler";
      v226 = "%{public}s called with null options_protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v224, v225, v226, buf, 0xCu);
    goto LABEL_498;
  }

  os_log_type_t v42 = (void *)v30[18];
  if (v42)
  {
    if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        __int16 v239 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v239, OS_LOG_TYPE_DEBUG))
        {
          v240 = v30[11];
          if (v240) {
            __int16 v241 = *(_DWORD *)(v240 + 460);
          }
          else {
            __int16 v241 = -1;
          }
          v292 = v30[8];
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_replace_protocol_instance";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v30 + 24;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v241;
          *(_WORD *)&v345[6] = 2048;
          *(void *)&v345[8] = v292;
          _os_log_impl( &dword_181A5C000,  v239,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> called",  buf,  0x30u);
        }
      }
    }

    int v43 = nw_parameters_copy_protocol_options_legacy(v42, v41);
    if (v43)
    {
      char v44 = v43;
      if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          id v244 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v244, OS_LOG_TYPE_DEBUG))
          {
            __int16 v245 = v30[11];
            if (v245) {
              v246 = *(_DWORD *)(v245 + 460);
            }
            else {
              v246 = -1;
            }
            v293 = v30[8];
            *(_DWORD *)buf = 136448514;
            *(void *)&uint8_t buf[4] = "nw_webtransport_stream_replace_protocol_instance";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v30 + 24;
            *(_WORD *)&_BYTE buf[22] = 2080;
            v344 = (uint64_t)" ";
            *(_WORD *)v345 = 1024;
            *(_DWORD *)&v345[2] = v246;
            *(_WORD *)&v345[6] = 2048;
            *(void *)&v345[8] = v293;
            *(_WORD *)&v345[16] = 2048;
            *(void *)&v345[18] = v30;
            *(_WORD *)&v345[26] = 2048;
            v346 = v30;
            v347 = 2048;
            v348 = v41;
            v349 = 2048;
            v350 = v42;
            v351 = 2048;
            v352 = v44;
            _os_log_impl( &dword_181A5C000,  v244,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%lld> webtransport_stream protocol %p, set protocol instance to %p instead of %p in parameters %p options %p",  buf,  0x62u);
          }
        }
      }

      if (nw_protocol_copy_webtransport_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_60063);
      }
      id v45 = (id)nw_protocol_copy_webtransport_definition::definition;
      uint64_t v46 = v44;
      *((void *)v46 + 2) = v30;

      if (v45) {
        os_release(v45);
      }
      os_release(v46);
    }

    goto LABEL_69;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_webtransport_stream_replace_protocol_instance";
  __int16 v235 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(aBlock) = 16;
  v339[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v235, &aBlock, v339))
  {
    if (aBlock == 17)
    {
      v236 = (os_log_s *)__nwlog_obj();
      __int16 v237 = aBlock;
      if (!os_log_type_enabled(v236, (os_log_type_t)aBlock)) {
        goto LABEL_503;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_replace_protocol_instance";
      v238 = "%{public}s called with null parameters";
      goto LABEL_502;
    }

    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v236 = (os_log_s *)__nwlog_obj();
      __int16 v237 = aBlock;
      if (!os_log_type_enabled(v236, (os_log_type_t)aBlock)) {
        goto LABEL_503;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_replace_protocol_instance";
      v238 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_502;
    }

    v269 = (char *)__nw_create_backtrace_string();
    v236 = (os_log_s *)__nwlog_obj();
    __int16 v237 = aBlock;
    v270 = os_log_type_enabled(v236, (os_log_type_t)aBlock);
    if (v269)
    {
      if (v270)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_webtransport_stream_replace_protocol_instance";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v269;
        _os_log_impl( &dword_181A5C000,  v236,  v237,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v269);
      goto LABEL_503;
    }

    if (v270)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_replace_protocol_instance";
      v238 = "%{public}s called with null parameters, no backtrace";
LABEL_502:
      _os_log_impl(&dword_181A5C000, v236, v237, v238, buf, 0xCu);
    }
  }

    size_t v60 = v10;
    os_log_type_t v61 = v11;
    BOOL v62 = 12;
LABEL_94:
    _os_log_impl(&dword_181A5C000, v60, v61, v12, buf, v62);
    goto LABEL_95;
  }

  if (CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(v8 + 200)))
  {
    id v13 = *(_DWORD *)(v8 + 260) + v2;
    *(_DWORD *)(v8 + 260) = v13;
    char v14 = *(_DWORD *)(v8 + 256);
    __int16 v15 = *(_WORD *)(v8 + 368);
    uint64_t v27 = __OFSUB__(v13, v14);
    BOOL v16 = v13 - v14;
    if (v16 < 0 != v27)
    {
      *(_WORD *)(v8 + 36_Block_object_dispose(va, 8) = v15 & 0xFFFD;
      *(_DWORD *)(v8 + 264) = 0;
    }

    else
    {
      *(_WORD *)(v8 + 36_Block_object_dispose(va, 8) = v15 | 2;
      *(_DWORD *)(v8 + 264) = v16;
    }

    goto LABEL_54;
  }

  if (!CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(v8 + 200), v7, v2))
  {
    if ((*(_WORD *)(v8 + 368) & 0x80) != 0) {
      goto LABEL_97;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v38 = *(void *)(v8 + 200);
    *(_DWORD *)buf = 136446978;
    id v168 = "nw_http_connect_append_bytes";
    __int16 v169 = 2082;
    nw_endpoint_t v170 = (void *)(v8 + 284);
    __int16 v171 = 2080;
    v172 = " ";
    __int16 v173 = 2048;
    *(void *)id v174 = v38;
    BOOL v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (__nwlog_fault(v9, &type, &v165))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v39 = (os_log_s *)gLogObj;
        os_log_type_t v40 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_95;
        }
        __int16 v41 = *(void *)(v8 + 200);
        *(_DWORD *)buf = 136446978;
        id v168 = "nw_http_connect_append_bytes";
        __int16 v169 = 2082;
        nw_endpoint_t v170 = (void *)(v8 + 284);
        __int16 v171 = 2080;
        v172 = " ";
        __int16 v173 = 2048;
        *(void *)id v174 = v41;
        nw_endpoint_t v12 = "%{public}s %{public}s%sFailed to apply bytes to response message %p";
        goto LABEL_239;
      }

      if (v165)
      {
        os_log_type_t v96 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v39 = (os_log_s *)gLogObj;
        os_log_type_t v40 = type;
        int v97 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v96)
        {
          if (v97)
          {
            os_log_type_t v98 = *(void *)(v8 + 200);
            *(_DWORD *)buf = 136447234;
            id v168 = "nw_http_connect_append_bytes";
            __int16 v169 = 2082;
            nw_endpoint_t v170 = (void *)(v8 + 284);
            __int16 v171 = 2080;
            v172 = " ";
            __int16 v173 = 2048;
            *(void *)id v174 = v98;
            *(_WORD *)&v174[8] = 2082;
            *(void *)&v174[10] = v96;
            _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s %{public}s%sFailed to apply bytes to response message %p, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(v96);
          goto LABEL_95;
        }

        if (!v97) {
          goto LABEL_95;
        }
        os_log_type_t v153 = *(void *)(v8 + 200);
        *(_DWORD *)buf = 136446978;
        id v168 = "nw_http_connect_append_bytes";
        __int16 v169 = 2082;
        nw_endpoint_t v170 = (void *)(v8 + 284);
        __int16 v171 = 2080;
        v172 = " ";
        __int16 v173 = 2048;
        *(void *)id v174 = v153;
        nw_endpoint_t v12 = "%{public}s %{public}s%sFailed to apply bytes to response message %p, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v39 = (os_log_s *)gLogObj;
        os_log_type_t v40 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_95;
        }
        __int16 v152 = *(void *)(v8 + 200);
        *(_DWORD *)buf = 136446978;
        id v168 = "nw_http_connect_append_bytes";
        __int16 v169 = 2082;
        nw_endpoint_t v170 = (void *)(v8 + 284);
        __int16 v171 = 2080;
        v172 = " ";
        __int16 v173 = 2048;
        *(void *)id v174 = v152;
        nw_endpoint_t v12 = "%{public}s %{public}s%sFailed to apply bytes to response message %p, backtrace limit exceeded";
      }

  requiredInterfaceType = self->_requiredInterfaceType;
  if (requiredInterfaceType >= 5)
  {
    objc_msgSend( NSString,  "stringWithFormat:",  @"(unknown: %i)",  self->_requiredInterfaceType);
    os_log_type_t v63 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }

  else
  {
    os_log_type_t v63 = off_189BBCB38[requiredInterfaceType];
  }

  [v4 setObject:v63 forKey:@"requiredInterfaceType"];

  has = (__int16)self->_has;
  if ((has & 0x400) == 0)
  {
LABEL_17:
    if ((has & 0x40) == 0) {
      goto LABEL_18;
    }
    goto LABEL_98;
  }

      free(v43);
      goto LABEL_94;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v44 = (os_log_s *)(id)gLogObj;
      BOOL v53 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
        _os_log_impl(&dword_181A5C000, v44, v53, "%{public}s nw_listener_create failed", buf, 0xCu);
      }
      }
}

      goto LABEL_94;
    }

    if (*((_DWORD *)v7 + 26))
    {
      os_log_type_t v54 = *((_BYTE *)v7 + 108);
      if ((v54 & 0x20) != 0)
      {
        os_log_type_t v55 = (id *)nw_endpoint_handler_copy_current_path(*((void **)v7 + 4));
        char v14 = (os_log_s *)v55;
        if (v55)
        {
          BOOL v56 = (nw_interface *)v55[12];
          os_log_type_t v57 = v56;
          if (v56 && nw_interface_get_type(v56) == nw_interface_type_cellular)
          {
            int minimize_logging = nw_endpoint_handler_get_minimize_logging(v3);
            char logging_disabled = nw_endpoint_handler_get_logging_disabled(v3);
            if (minimize_logging)
            {
              if ((logging_disabled & 1) != 0) {
                goto LABEL_53;
              }
              uint64_t v124 = v14;
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v110 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
              {
                os_log_t loga = nw_endpoint_handler_get_id_string(v3);
                nw_endpoint_t v117 = nw_endpoint_handler_dry_run_string(v3);
                os_log_type_t v111 = nw_endpoint_handler_copy_endpoint(v3);
                BOOL v112 = nw_endpoint_get_logging_description(v111);
                id v113 = nw_endpoint_handler_state_string(v3);
                nw_endpoint_t v114 = nw_endpoint_handler_mode_string(v3);
                nw_endpoint_t v115 = nw_endpoint_handler_copy_current_path(v3);
                *(_DWORD *)buf = 136447746;
                int64x2_t v133 = "nw_endpoint_fallback_start_fallback_child";
                id v134 = 2082;
                uint32x4_t v135 = (void *)loga;
                unsigned int v136 = 2082;
                nw_endpoint_t v137 = v117;
                int v138 = 2082;
                char v139 = v112;
                v140 = 2082;
                id v141 = v113;
                nw_endpoint_t v142 = 2082;
                v143 = v114;
                uint64_t v144 = 2114;
                uint64_t v145 = v115;
                size_t v60 = v110;
                _os_log_impl( &dword_181A5C000,  v110,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, because the primary child already uses cellular",  buf,  0x48u);

                char v14 = v124;
              }

              else
              {
                size_t v60 = v110;
              }
            }

            else
            {
              if ((logging_disabled & 1) != 0)
              {
LABEL_53:
                nw_endpoint_handler_cancel(*((void **)v7 + 5), 0LL, 1);

LABEL_92:
                goto LABEL_93;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              size_t v60 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
              {
                id_string = nw_endpoint_handler_get_id_string(v3);
                os_log_t log = v60;
                nw_endpoint_t v123 = nw_endpoint_handler_dry_run_string(v3);
                BOOL v62 = id_string;
                id v116 = nw_endpoint_handler_copy_endpoint(v3);
                os_log_type_t v63 = nw_endpoint_get_logging_description(v116);
                BOOL v64 = nw_endpoint_handler_state_string(v3);
                os_log_type_t v65 = nw_endpoint_handler_mode_string(v3);
                os_log_type_t v66 = nw_endpoint_handler_copy_current_path(v3);
                *(_DWORD *)buf = 136447746;
                int64x2_t v133 = "nw_endpoint_fallback_start_fallback_child";
                id v134 = 2082;
                uint32x4_t v135 = (void *)v62;
                unsigned int v136 = 2082;
                nw_endpoint_t v137 = v123;
                int v138 = 2082;
                char v139 = v63;
                v140 = 2082;
                id v141 = v64;
                nw_endpoint_t v142 = 2082;
                v143 = v65;
                uint64_t v144 = 2114;
                uint64_t v145 = v66;
                size_t v60 = log;
                _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, because the primary child already uses cellular",  buf,  0x48u);
              }
            }

            goto LABEL_53;
          }
        }

        else
        {
          os_log_type_t v57 = 0LL;
        }

        os_log_type_t v54 = *((_BYTE *)v7 + 108);
      }

      *((_BYTE *)v7 + 10_Block_object_dispose(va, 8) = v54 | 0x40;
      v3->event = (nw_endpoint_handler_event_s)131077;
      nw_endpoint_handler_report(v3, 0LL, &v3->event.domain, 0LL);
      nw_endpoint_handler_start(*((void **)v7 + 5));
      goto LABEL_93;
    }

    if (nw_endpoint_handler_get_minimize_logging(v3))
    {
      BOOL v129 = v7;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v73 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v103 = nw_endpoint_handler_get_id_string(v3);
        __int16 v104 = nw_endpoint_handler_dry_run_string(v3);
        os_log_type_t v105 = nw_endpoint_handler_copy_endpoint(v3);
        nw_endpoint_t v106 = nw_endpoint_get_logging_description(v105);
        int v107 = nw_endpoint_handler_state_string(v3);
        os_log_type_t v108 = nw_endpoint_handler_mode_string(v3);
        BOOL v109 = nw_endpoint_handler_copy_current_path(v3);
        *(_DWORD *)buf = 136447746;
        int64x2_t v133 = "nw_endpoint_fallback_start_fallback_child";
        id v134 = 2082;
        uint32x4_t v135 = (void *)v103;
        unsigned int v136 = 2082;
        nw_endpoint_t v137 = v104;
        int v138 = 2082;
        char v139 = v106;
        v140 = 2082;
        id v141 = v107;
        nw_endpoint_t v142 = 2082;
        v143 = v108;
        uint64_t v144 = 2114;
        uint64_t v145 = v109;
        _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, disposition is set to no",  buf,  0x48u);

        uint64_t v7 = v129;
      }
    }

    else
    {
      char v71 = v3;
      __int16 v72 = *((_BYTE *)v71 + 268);

      if ((v72 & 0x20) != 0)
      {
LABEL_64:
        nw_endpoint_handler_cancel(*((void **)v7 + 5), 0LL, 1);
        goto LABEL_93;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v73 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
      {
        __int16 v74 = nw_endpoint_handler_get_id_string(v71);
        nw_endpoint_t v75 = nw_endpoint_handler_dry_run_string(v71);
        int v128 = v7;
        __int16 v76 = nw_endpoint_handler_copy_endpoint(v71);
        __int16 v77 = nw_endpoint_get_logging_description(v76);
        __int16 v78 = nw_endpoint_handler_state_string(v71);
        id v79 = nw_endpoint_handler_mode_string(v71);
        uint64_t v80 = nw_endpoint_handler_copy_current_path(v71);
        *(_DWORD *)buf = 136447746;
        int64x2_t v133 = "nw_endpoint_fallback_start_fallback_child";
        id v134 = 2082;
        uint32x4_t v135 = (void *)v74;
        unsigned int v136 = 2082;
        nw_endpoint_t v137 = v75;
        int v138 = 2082;
        char v139 = v77;
        v140 = 2082;
        id v141 = v78;
        nw_endpoint_t v142 = 2082;
        v143 = v79;
        uint64_t v144 = 2114;
        uint64_t v145 = v80;
        _os_log_impl( &dword_181A5C000,  v73,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, disposition is set to no",  buf,  0x48u);

        uint64_t v7 = v128;
      }
    }

    goto LABEL_64;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v26 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v27 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    int64x2_t v133 = "nw_endpoint_fallback_start_fallback_child";
    id v134 = 2082;
    uint32x4_t v135 = (void *)v27;
    unsigned int v136 = 2082;
    nw_endpoint_t v137 = "fallback";
    _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_94:
}

            free(buffer);
            goto LABEL_94;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v33 = (nw_frame *)(v11 + 205);
          *(_DWORD *)buf = 136446466;
          os_log_type_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          os_log_type_t v55 = 2082;
          BOOL v56 = (nw_frame *)(v11 + 205);
          os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          id v51 = 0;
          if (__nwlog_fault(v25, &type, &v51))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              id v26 = (os_log_s *)__nwlog_obj();
              uint64_t v27 = type;
              if (!os_log_type_enabled(v26, type)) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 136446466;
              os_log_type_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              os_log_type_t v55 = 2082;
              BOOL v56 = v33;
              BOOL v28 = "%{public}s %{public}s stream not found";
              goto LABEL_86;
            }

            if (!v51)
            {
              id v26 = (os_log_s *)__nwlog_obj();
              uint64_t v27 = type;
              if (!os_log_type_enabled(v26, type)) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 136446466;
              os_log_type_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              os_log_type_t v55 = 2082;
              BOOL v56 = v33;
              BOOL v28 = "%{public}s %{public}s stream not found, backtrace limit exceeded";
              goto LABEL_86;
            }

            __int16 v34 = (char *)__nw_create_backtrace_string();
            id v26 = (os_log_s *)__nwlog_obj();
            uint64_t v27 = type;
            __int16 v37 = os_log_type_enabled(v26, type);
            if (!v34)
            {
              if (!v37) {
                goto LABEL_87;
              }
              *(_DWORD *)buf = 136446466;
              os_log_type_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              os_log_type_t v55 = 2082;
              BOOL v56 = v33;
              BOOL v28 = "%{public}s %{public}s stream not found, no backtrace";
              goto LABEL_86;
            }

            if (!v37) {
              goto LABEL_69;
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            os_log_type_t v55 = 2082;
            BOOL v56 = v33;
            os_log_type_t v57 = 2082;
            v58[0] = v34;
            os_log_type_t v36 = "%{public}s %{public}s stream not found, dumping backtrace:%{public}s";
            goto LABEL_68;
          }

      if (v24) {
        free(v24);
      }
      return 0LL;
    }

    if (v51 == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v25 = (os_log_s *)__nwlog_obj();
      id v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v53 = "http2_transport_create_input_frame";
        uint64_t v27 = "%{public}s called with null length, backtrace limit exceeded";
        goto LABEL_92;
      }

      goto LABEL_93;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v25 = (os_log_s *)__nwlog_obj();
    id v26 = type[0];
    nw_endpoint_t v35 = os_log_type_enabled(v25, type[0]);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v53 = "http2_transport_create_input_frame";
        uint64_t v27 = "%{public}s called with null length, no backtrace";
        goto LABEL_92;
      }

      goto LABEL_93;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v53 = "http2_transport_create_input_frame";
      os_log_type_t v54 = 2082;
      os_log_type_t v55 = (uint64_t)backtrace_string;
      os_log_type_t v33 = "%{public}s called with null length, dumping backtrace:%{public}s";
      goto LABEL_74;
    }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "nw_protocol_http1_remove_listen_handler";
  char v31 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v37 = 0;
  if (__nwlog_fault(v31, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      mach_vm_address_t v32 = (os_log_s *)gLogObj;
      os_log_type_t v33 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_http1_remove_listen_handler";
        __int16 v34 = "%{public}s called with null http1";
LABEL_106:
        _os_log_impl(&dword_181A5C000, v32, v33, v34, buf, 0xCu);
      }
    }

    else if (v37)
    {
      nw_endpoint_t v35 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      mach_vm_address_t v32 = (os_log_s *)gLogObj;
      os_log_type_t v33 = type;
      os_log_type_t v36 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "nw_protocol_http1_remove_listen_handler";
          __int16 v41 = 2082;
          os_log_type_t v42 = v35;
          _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null http1, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v35);
        goto LABEL_107;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_http1_remove_listen_handler";
        __int16 v34 = "%{public}s called with null http1, no backtrace";
        goto LABEL_106;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      mach_vm_address_t v32 = (os_log_s *)gLogObj;
      os_log_type_t v33 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_protocol_http1_remove_listen_handler";
        __int16 v34 = "%{public}s called with null http1, backtrace limit exceeded";
        goto LABEL_106;
      }
    }
  }

    if (v56) {
      free(v56);
    }
    LODWORD(v3_Block_object_dispose(va, 8) = -1;
    goto LABEL_52;
  }

    goto LABEL_94;
  }

    if (v23) {
      free(v23);
    }
    BOOL v11 = 0LL;
    if (v7 != &nw_protocol_ref_counted_handle) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  BOOL v11 = v10(v4, a2);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
LABEL_14:
    if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v18 = *(void *)(a2 + 88);
      if (v18)
      {
        id v19 = v18 - 1;
        *(void *)(a2 + 8_Block_object_dispose(va, 8) = v19;
        if (!v19)
        {
          uint64_t v20 = *(void (***)(void))(a2 + 64);
          if (v20)
          {
            *(void *)(a2 + 64) = 0LL;
            v20[2](v20);
            _Block_release(v20);
          }

          if ((*(_BYTE *)(a2 + 72) & 1) != 0)
          {
            os_log_type_t v21 = *(const void **)(a2 + 64);
            if (v21) {
              _Block_release(v21);
            }
          }

          free((void *)a2);
        }
      }
    }
  }

    uint64_t v27 = v53;
    BOOL v28 = v12;
    id v29 = v37;
    uint64_t v30 = 12;
    goto LABEL_35;
  }

  if (!__s1)
  {
    __nwlog_obj();
    os_log_type_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)BOOL v53 = 136446210;
    *(void *)&v53[4] = "nw_nat64_extract_v4";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0])) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      char v14 = "%{public}s called with null ipv6_addr";
      goto LABEL_93;
    }

    if (buf[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v37 = v51[0];
      int v43 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v43) {
          goto LABEL_79;
        }
        *(_DWORD *)BOOL v53 = 136446466;
        *(void *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 2082;
        *(void *)&v53[14] = backtrace_string;
        os_log_type_t v42 = "%{public}s called with null ipv6_addr, dumping backtrace:%{public}s";
        goto LABEL_78;
      }

      if (!v43) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      char v14 = "%{public}s called with null ipv6_addr, no backtrace";
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0])) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      char v14 = "%{public}s called with null ipv6_addr, backtrace limit exceeded";
    }

    goto LABEL_93;
  }

  if (!a3)
  {
    __nwlog_obj();
    id v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)BOOL v53 = 136446210;
    *(void *)&v53[4] = "nw_nat64_extract_v4";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0])) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      char v14 = "%{public}s called with null out_ipv4_addr";
      goto LABEL_93;
    }

    if (buf[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v37 = v51[0];
      char v44 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v44) {
          goto LABEL_79;
        }
        *(_DWORD *)BOOL v53 = 136446466;
        *(void *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 2082;
        *(void *)&v53[14] = backtrace_string;
        os_log_type_t v42 = "%{public}s called with null out_ipv4_addr, dumping backtrace:%{public}s";
LABEL_78:
        _os_log_impl(&dword_181A5C000, v12, v37, v42, v53, 0x16u);
LABEL_79:

        free(backtrace_string);
        if (!v11) {
          return 0LL;
        }
        goto LABEL_38;
      }

      if (!v44) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      char v14 = "%{public}s called with null out_ipv4_addr, no backtrace";
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0])) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      char v14 = "%{public}s called with null out_ipv4_addr, backtrace limit exceeded";
    }

    goto LABEL_93;
  }

  id v6 = *a1;
  if (!memcmp(__s1, a1 + 1, v6))
  {
    switch((int)v6)
    {
      case 4:
        os_log_type_t v8 = *((_DWORD *)__s1 + 1);
        goto LABEL_30;
      case 5:
        uint64_t v18 = *(_WORD *)(__s1 + 5);
        *(_BYTE *)(a3 + 2) = __s1[7];
        *(_WORD *)a3 = v18;
        *(_BYTE *)(a3 + 3) = __s1[9];
        return 1LL;
      case 6:
        *(_WORD *)a3 = *((_WORD *)__s1 + 3);
        *(_WORD *)(a3 + 2) = *(_WORD *)(__s1 + 9);
        return 1LL;
      case 7:
        *(_BYTE *)a3 = __s1[7];
        uint64_t v20 = *(_WORD *)(__s1 + 9);
        *(_BYTE *)(a3 + 3) = __s1[11];
        *(_WORD *)(a3 + 1) = v20;
        return 1LL;
      case 8:
        os_log_type_t v8 = *(_DWORD *)(__s1 + 9);
        goto LABEL_30;
      case 12:
        os_log_type_t v8 = *((_DWORD *)__s1 + 3);
LABEL_30:
        *(_DWORD *)a3 = v8;
        return 1LL;
      default:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v21 = (id)gLogObj;
        uint64_t v22 = *a1;
        *(_DWORD *)BOOL v53 = 136446466;
        *(void *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 1024;
        *(_DWORD *)&v53[14] = v22;
        BOOL v11 = (char *)_os_log_send_and_compose_impl();

        v51[0] = OS_LOG_TYPE_ERROR;
        buf[0] = 0;
        if (v51[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v23 = (os_log_s *)(id)gLogObj;
          uint64_t v24 = v51[0];
          if (os_log_type_enabled(v23, v51[0]))
          {
            os_log_type_t v25 = *a1;
            *(_DWORD *)BOOL v53 = 136446466;
            *(void *)&v53[4] = "nw_nat64_extract_v4";
            *(_WORD *)&v53[12] = 1024;
            *(_DWORD *)&v53[14] = v25;
            id v26 = "%{public}s invalid prefix length %d";
LABEL_52:
            _os_log_impl(&dword_181A5C000, v23, v24, v26, v53, 0x12u);
          }
        }

        else if (buf[0])
        {
          char v31 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v24 = v51[0];
          mach_vm_address_t v32 = os_log_type_enabled(v23, v51[0]);
          if (v31)
          {
            if (v32)
            {
              os_log_type_t v33 = *a1;
              *(_DWORD *)BOOL v53 = 136446722;
              *(void *)&v53[4] = "nw_nat64_extract_v4";
              *(_WORD *)&v53[12] = 1024;
              *(_DWORD *)&v53[14] = v33;
              *(_WORD *)&v53[18] = 2082;
              *(void *)&v53[20] = v31;
              _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s invalid prefix length %d, dumping backtrace:%{public}s",  v53,  0x1Cu);
            }

            free(v31);
            goto LABEL_37;
          }

          if (v32)
          {
            nw_endpoint_t v35 = *a1;
            *(_DWORD *)BOOL v53 = 136446466;
            *(void *)&v53[4] = "nw_nat64_extract_v4";
            *(_WORD *)&v53[12] = 1024;
            *(_DWORD *)&v53[14] = v35;
            id v26 = "%{public}s invalid prefix length %d, no backtrace";
            goto LABEL_52;
          }
        }

        else
        {
          __nwlog_obj();
          id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v24 = v51[0];
          if (os_log_type_enabled(v23, v51[0]))
          {
            __int16 v34 = *a1;
            *(_DWORD *)BOOL v53 = 136446466;
            *(void *)&v53[4] = "nw_nat64_extract_v4";
            *(_WORD *)&v53[12] = 1024;
            *(_DWORD *)&v53[14] = v34;
            id v26 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
            goto LABEL_52;
          }
        }

        goto LABEL_37;
    }
  }

  os_log_type_t v55 = 0;
  os_log_type_t v54 = 0u;
  memset(v53, 0, sizeof(v53));
  nw_nat64_write_prefix_to_string(a1, (char *)v53, 0x32u);
  *(_OWORD *)id v51 = 0u;
  memset(v52, 0, sizeof(v52));
  if (inet_ntop(30, __s1, (char *)v51, 0x2Eu))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446723;
      id v48 = "nw_nat64_extract_v4";
      os_log_type_t v49 = 2085;
      *(void *)uint32_t v50 = v53;
      *(_WORD *)&v50[8] = 2085;
      *(void *)&v50[10] = v51;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s prefix %{sensitive}s does not match address %{sensitive}s",  buf,  0x20u);
    }

    return 0LL;
  }

  BOOL v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v10 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  id v48 = "nw_nat64_extract_v4";
  os_log_type_t v49 = 1024;
  *(_DWORD *)uint32_t v50 = v9;
  BOOL v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  id v45 = 0;
  if (__nwlog_fault(v11, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v12 = (os_log_s *)(id)gLogObj;
      id v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446466;
        id v48 = "nw_nat64_extract_v4";
        os_log_type_t v49 = 1024;
        *(_DWORD *)uint32_t v50 = v9;
        char v14 = "%{public}s inet_ntop failed %{darwin.errno}d";
LABEL_33:
        uint64_t v27 = buf;
        BOOL v28 = v12;
        id v29 = v13;
LABEL_34:
        uint64_t v30 = 18;
LABEL_35:
        _os_log_impl(&dword_181A5C000, v28, v29, v14, v27, v30);
      }
    }

    else
    {
      if (v45)
      {
        __int16 v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        nw_endpoint_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v16 = type;
        os_log_type_t v17 = os_log_type_enabled(v12, type);
        if (v15)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446722;
            id v48 = "nw_nat64_extract_v4";
            os_log_type_t v49 = 1024;
            *(_DWORD *)uint32_t v50 = v9;
            *(_WORD *)&v50[4] = 2082;
            *(void *)&v50[6] = v15;
            _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s inet_ntop failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v15);
          if (!v11) {
            return 0LL;
          }
          goto LABEL_38;
        }

        if (!v17) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446466;
        id v48 = "nw_nat64_extract_v4";
        os_log_type_t v49 = 1024;
        *(_DWORD *)uint32_t v50 = v9;
        char v14 = "%{public}s inet_ntop failed %{darwin.errno}d, no backtrace";
        uint64_t v27 = buf;
        BOOL v28 = v12;
        id v29 = v16;
        goto LABEL_34;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v12 = (os_log_s *)(id)gLogObj;
      id v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446466;
        id v48 = "nw_nat64_extract_v4";
        os_log_type_t v49 = 1024;
        *(_DWORD *)uint32_t v50 = v9;
        char v14 = "%{public}s inet_ntop failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_33;
      }
    }

    if (v46) {
      free(v46);
    }
    goto LABEL_22;
  }

  __nwlog_obj();
  __int16 v41 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)key = 136446210;
  nw_endpoint_t v114 = "nw_browser_dns_service_query_record_callback";
  os_log_type_t v42 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  v123[0] = 0;
  if (__nwlog_fault(v42, buf, v123))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      int v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v44 = buf[0];
      if (os_log_type_enabled(v43, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)key = 136446210;
        nw_endpoint_t v114 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl(&dword_181A5C000, v43, v44, "%{public}s called with null dns_service", (uint8_t *)key, 0xCu);
      }
    }

    else if (v123[0])
    {
      os_log_type_t v49 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint32_t v50 = buf[0];
      id v51 = os_log_type_enabled(v43, (os_log_type_t)buf[0]);
      if (v49)
      {
        if (v51)
        {
          *(_DWORD *)key = 136446466;
          nw_endpoint_t v114 = "nw_browser_dns_service_query_record_callback";
          nw_endpoint_t v115 = 2082;
          id v116 = v49;
          _os_log_impl( &dword_181A5C000,  v43,  v50,  "%{public}s called with null dns_service, dumping backtrace:%{public}s",  (uint8_t *)key,  0x16u);
        }

        free(v49);
        goto LABEL_88;
      }

      if (v51)
      {
        *(_DWORD *)key = 136446210;
        nw_endpoint_t v114 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl( &dword_181A5C000,  v43,  v50,  "%{public}s called with null dns_service, no backtrace",  (uint8_t *)key,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v55 = buf[0];
      if (os_log_type_enabled(v43, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)key = 136446210;
        nw_endpoint_t v114 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl( &dword_181A5C000,  v43,  v55,  "%{public}s called with null dns_service, backtrace limit exceeded",  (uint8_t *)key,  0xCu);
      }
    }
  }

        goto LABEL_94;
      }

      if (!v45)
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v44 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          id v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl( &dword_181A5C000,  v27,  v44,  "%{public}s txt_record cannot have length > 65535, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_93;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      __int16 v41 = os_log_type_enabled(v27, type);
      if (!backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          id v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl( &dword_181A5C000,  v27,  v40,  "%{public}s txt_record cannot have length > 65535, no backtrace",  buf,  0xCu);
        }

        goto LABEL_93;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        id v48 = "nw_txt_record_create_with_bytes";
        os_log_type_t v49 = 2082;
        uint32_t v50 = (size_t)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v27,  v40,  "%{public}s txt_record cannot have length > 65535, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_75;
    }

          if (v10) {
            goto LABEL_94;
          }
          return;
        }

    free(backtrace_string);
    goto LABEL_107;
  }

  BOOL v28 = (os_log_s *)__nwlog_obj();
  id v29 = __src;
  if (os_log_type_enabled(v28, (os_log_type_t)__src))
  {
    *(_DWORD *)buf = 136446210;
    int v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    uint64_t v30 = "%{public}s called with null external_data";
    goto LABEL_106;
  }

    if (v89) {
      free(v89);
    }
LABEL_53:
    __int16 v37 = *(void *)(a1 + 944);
    if (!v37) {
      return;
    }
    if (*(_BYTE *)(v37 + 634)
      && nw_http3_stream_send_section_ack(*(void *)(a1 + 944))
      && !nw_http3_stream_received_fields_done(v37))
    {
      nw_protocol_http3_stream_input_available((nw_protocol *)v37, v38);
    }

    nw_http3_stream_send_stream_cancellation(v37);
    id v39 = *(unsigned __int16 *)(v37 + 736);
    if ((v39 & 0x400) != 0 && !*(void *)(v37 + 528) && !*(_BYTE *)(v37 + 634) && !*(_BYTE *)(v37 + 635))
    {
      os_log_type_t v40 = v39 & 0xFFFFFBFF | (*(unsigned __int8 *)(v37 + 738) << 16);
      *(_WORD *)(v37 + 736) = v39 & 0xFBFF;
      *(_BYTE *)(v37 + 73_Block_object_dispose(va, 8) = BYTE2(v40);
      __int16 v41 = *(void *)(v37 + 32);
      if (!v41
        || (os_log_type_t v42 = *(void *)(v41 + 24)) == 0
        || (int v43 = *(void (**)(uint64_t, uint64_t))(v42 + 32)) == 0LL)
      {
        __nwlog_obj();
        char v44 = *(void *)(v37 + 32);
        if (v44)
        {
          id v45 = *(const char **)(v44 + 16);
          if (!v45) {
            id v45 = "invalid";
          }
        }

        else
        {
          id v45 = "invalid";
        }

        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v45;
        BOOL v62 = (const char *)_os_log_send_and_compose_impl();
        LOBYTE(v105[0]) = 16;
        os_log_type_t v100 = 0;
        int v90 = (char *)v62;
        if (LOBYTE(v105[0]) == 17)
        {
          os_log_type_t v63 = (os_log_s *)__nwlog_obj();
          BOOL v64 = v105[0];
          if (os_log_type_enabled(v63, v105[0]))
          {
            os_log_type_t v65 = *(void *)(v37 + 32);
            if (v65)
            {
              os_log_type_t v66 = *(const char **)(v65 + 16);
              if (!v66) {
                os_log_type_t v66 = "invalid";
              }
            }

            else
            {
              os_log_type_t v66 = "invalid";
            }

            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v66;
            __int16 v78 = v63;
            id v79 = v64;
            uint64_t v80 = "%{public}s protocol %{public}s has invalid disconnect callback";
            goto LABEL_129;
          }

          goto LABEL_130;
        }

        if (v100)
        {
          char v67 = (char *)__nw_create_backtrace_string();
          os_log_type_t v68 = (os_log_s *)__nwlog_obj();
          char v88 = v105[0];
          __int16 v69 = os_log_type_enabled(v68, v105[0]);
          if (v67)
          {
            if (v69)
            {
              int v70 = *(void *)(v37 + 32);
              if (v70)
              {
                char v71 = *(const char **)(v70 + 16);
                if (!v71) {
                  char v71 = "invalid";
                }
              }

              else
              {
                char v71 = "invalid";
              }

              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v71;
              *(_WORD *)&_BYTE buf[22] = 2082;
              int v107 = v67;
              _os_log_impl( &dword_181A5C000,  v68,  v88,  "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v67);
            goto LABEL_130;
          }

          if (!v69)
          {
LABEL_130:
            if (v90) {
              free(v90);
            }
            goto LABEL_3;
          }

          __int16 v76 = *(void *)(v37 + 32);
          if (v76)
          {
            __int16 v77 = *(const char **)(v76 + 16);
            if (!v77) {
              __int16 v77 = "invalid";
            }
          }

          else
          {
            __int16 v77 = "invalid";
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v77;
          __int16 v78 = v68;
          id v79 = v88;
          uint64_t v80 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
        }

        else
        {
          __int16 v72 = (os_log_s *)__nwlog_obj();
          __int16 v73 = v105[0];
          if (!os_log_type_enabled(v72, v105[0])) {
            goto LABEL_130;
          }
          __int16 v74 = *(void *)(v37 + 32);
          if (v74)
          {
            nw_endpoint_t v75 = *(const char **)(v74 + 16);
            if (!v75) {
              nw_endpoint_t v75 = "invalid";
            }
          }

          else
          {
            nw_endpoint_t v75 = "invalid";
          }

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_decoder_stream_output_available";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v75;
          __int16 v78 = v72;
          id v79 = v73;
          uint64_t v80 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        }

        if (v33) {
          free(v33);
        }
        goto LABEL_95;
      }

      if (!v39) {
        goto LABEL_101;
      }
LABEL_94:
      BOOL v53 = v39;
      os_log_type_t v54 = *((_DWORD *)v53 + 25);

      if (v54 != 4001 || !setsockopt(sockfd_from_client, 0xFFFF, 4376, &v91, 4u)) {
        goto LABEL_101;
      }
      posix_error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
      os_log_type_t v55 = nw_error_get_error_code((nw_error_t)posix_error);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v56 = (id)gLogObj;
      *(_DWORD *)os_log_type_t type = 136446722;
      uint64_t v94 = "-[nw_listener_inbox_socket start]";
      uint64_t v95 = 1024;
      os_log_type_t v96 = sockfd_from_client;
      int v97 = 1024;
      *(_DWORD *)os_log_type_t v98 = v55;
      BOOL v9 = (char *)_os_log_send_and_compose_impl();

      v89[0] = OS_LOG_TYPE_ERROR;
      char v88 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v9, v89, &v88))
      {
        if (v89[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v58 = v89[0];
          if (os_log_type_enabled(v57, v89[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446722;
            uint64_t v94 = "-[nw_listener_inbox_socket start]";
            uint64_t v95 = 1024;
            os_log_type_t v96 = sockfd_from_client;
            int v97 = 1024;
            *(_DWORD *)os_log_type_t v98 = v55;
            _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d",  (uint8_t *)type,  0x18u);
          }
        }

        else if (v88)
        {
          id v26 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v71 = v89[0];
          __int16 v72 = os_log_type_enabled(v57, v89[0]);
          if (v26)
          {
            if (v72)
            {
              *(_DWORD *)os_log_type_t type = 136446978;
              uint64_t v94 = "-[nw_listener_inbox_socket start]";
              uint64_t v95 = 1024;
              os_log_type_t v96 = sockfd_from_client;
              int v97 = 1024;
              *(_DWORD *)os_log_type_t v98 = v55;
              *(_WORD *)&v98[4] = 2082;
              *(void *)&_BYTE v98[6] = v26;
              _os_log_impl( &dword_181A5C000,  v57,  v71,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)type,  0x22u);
            }

            goto LABEL_119;
          }

          if (v72)
          {
            *(_DWORD *)os_log_type_t type = 136446722;
            uint64_t v94 = "-[nw_listener_inbox_socket start]";
            uint64_t v95 = 1024;
            os_log_type_t v96 = sockfd_from_client;
            int v97 = 1024;
            *(_DWORD *)os_log_type_t v98 = v55;
            _os_log_impl( &dword_181A5C000,  v57,  v71,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, no backtrace",  (uint8_t *)type,  0x18u);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v74 = v89[0];
          if (os_log_type_enabled(v57, v89[0]))
          {
            *(_DWORD *)os_log_type_t type = 136446722;
            uint64_t v94 = "-[nw_listener_inbox_socket start]";
            uint64_t v95 = 1024;
            os_log_type_t v96 = sockfd_from_client;
            int v97 = 1024;
            *(_DWORD *)os_log_type_t v98 = v55;
            _os_log_impl( &dword_181A5C000,  v57,  v74,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)type,  0x18u);
          }
        }
      }

        unsigned int v82 = nw_protocol_definition_get_identifier(v347);
        id v83 = nw_endpoint_handler_copy_endpoint(v48);
        protocol_for_definition = nw_endpoint_handler_create_protocol_for_definition( (uint64_t)v82,  v347,  v83,  parameters);

        if (!protocol_for_definition)
        {
          char v88 = v48;
          char v89 = (*((_BYTE *)v88 + 268) & 0x20) == 0;

          if (v89)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            int v90 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
            {
              id_string = nw_endpoint_handler_get_id_string(v88);
              int v92 = nw_endpoint_handler_dry_run_string(v88);
              char v93 = nw_endpoint_handler_copy_endpoint(v88);
              uint64_t v94 = nw_endpoint_get_logging_description(v93);
              uint64_t v95 = nw_endpoint_handler_state_string(v88);
              os_log_type_t v96 = nw_endpoint_handler_mode_string(v88);
              int v97 = nw_endpoint_handler_copy_current_path(v88);
              *(_DWORD *)buf = 136448002;
              v358 = "nw_endpoint_handler_append_and_start_application_protocol";
              v359 = 2082;
              v360 = (char *)id_string;
              v361 = 2082;
              v362 = v92;
              v363 = 2082;
              v364 = (void *)v94;
              v365 = 2082;
              v366 = v95;
              v367 = 2082;
              v368 = v96;
              v369 = 2114;
              v370 = v97;
              v371 = 2114;
              v372 = v347;
              _os_log_impl( &dword_181A5C000,  v90,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create protoc ol handler for %{public}@",  buf,  0x52u);
            }
          }

          goto LABEL_206;
        }

        nw_endpoint_handler_set_protocol_instance(v48, v346, v347, protocol_for_definition);
        id v85 = *(void *)(v51 + 32);
        if (v85)
        {
          if (*(_UNKNOWN **)(v85 + 40) == &nw_protocol_ref_counted_handle)
          {
            unsigned int v103 = *(void *)(v85 + 88);
            if (v103)
            {
              __int16 v104 = v103 - 1;
              *(void *)(v85 + 8_Block_object_dispose(va, 8) = v104;
              if (!v104)
              {
                os_log_type_t v105 = *(void (***)(void))(v85 + 64);
                if (v105)
                {
                  *(void *)(v85 + 64) = 0LL;
                  v105[2](v105);
                  _Block_release(v105);
                }

                if ((*(_BYTE *)(v85 + 72) & 1) != 0)
                {
                  nw_endpoint_t v106 = *(const void **)(v85 + 64);
                  if (v106) {
                    _Block_release(v106);
                  }
                }

                free((void *)v85);
              }
            }
          }

          *(void *)(v51 + 32) = 0LL;
        }

        if (protocol_for_definition != v51)
        {
          unsigned int v86 = *(void **)(protocol_for_definition + 24);
          if (v86 && *v86)
          {
            if ((nw_protocol_add_input_handler(protocol_for_definition, v51) & 1) != 0)
            {
              if (output_handler->handle == &nw_protocol_ref_counted_handle)
              {
                callbacks = output_handler[1].callbacks;
                if (callbacks) {
                  output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                }
                *(void *)os_log_type_t type = output_handler;
                uint64_t v87 = v356 | 1;
              }

              else
              {
                *(void *)os_log_type_t type = output_handler;
                uint64_t v87 = v356 & 0xFE;
              }

              v356 = v87;
              if (*(_UNKNOWN **)(v51 + 40) == &nw_protocol_ref_counted_handle)
              {
                BOOL v112 = *(void *)(v51 + 88);
                if (v112) {
                  *(void *)(v51 + 8_Block_object_dispose(va, 8) = v112 + 1;
                }
                v353 = v51;
                os_log_type_t v111 = v354 | 1;
              }

              else
              {
                v353 = v51;
                os_log_type_t v111 = v354 & 0xFE;
              }

              v354 = v111;
              if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
              {
                nw_endpoint_t v114 = *(void *)(protocol_for_definition + 88);
                if (v114) {
                  *(void *)(protocol_for_definition + 8_Block_object_dispose(va, 8) = v114 + 1;
                }
                *(void *)v350 = protocol_for_definition;
                id v113 = v351 | 1;
              }

              else
              {
                *(void *)v350 = protocol_for_definition;
                id v113 = v351 & 0xFE;
              }

              v351 = v113;
              nw_endpoint_t v115 = output_handler->callbacks;
              if (v115)
              {
                replace_input_handler = (uint64_t (*)(nw_protocol *, uint64_t, uint64_t))v115->replace_input_handler;
                if (replace_input_handler)
                {
                  nw_endpoint_t v117 = replace_input_handler(output_handler, v51, protocol_for_definition);
                  if ((v351 & 1) == 0) {
                    goto LABEL_147;
                  }
                  goto LABEL_146;
                }
              }

              __nwlog_obj();
              v288 = (void *)objc_claimAutoreleasedReturnValue();
              name = output_handler->identifier->name;
              *(_DWORD *)buf = 136446722;
              v358 = "__nw_protocol_replace_input_handler";
              if (!name) {
                name = "invalid";
              }
              v359 = 2082;
              v360 = (char *)name;
              v361 = 2048;
              v362 = (const char *)output_handler;
              os_log_t log = (char *)_os_log_send_and_compose_impl();

              v352 = OS_LOG_TYPE_ERROR;
              v349 = 0;
              if (__nwlog_fault(log, &v352, &v349))
              {
                if (v352 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v290 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v291 = v352;
                  if (os_log_type_enabled(v290, v352))
                  {
                    v292 = output_handler->identifier->name;
                    if (!v292) {
                      v292 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    v358 = "__nw_protocol_replace_input_handler";
                    v359 = 2082;
                    v360 = (char *)v292;
                    v361 = 2048;
                    v362 = (const char *)output_handler;
                    _os_log_impl( &dword_181A5C000,  v290,  v291,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback",  buf,  0x20u);
                  }

      if (v32) {
        free(v32);
      }
      goto LABEL_18;
    }

    __nwlog_obj();
    id v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v54 = "nw_connection_create_interface_status_monitor";
    id v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v51 = 0;
    if (__nwlog_fault(v26, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v30 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v54 = "nw_connection_create_interface_status_monitor";
          _os_log_impl( &dword_181A5C000,  v27,  v30,  "%{public}s called with null connection->endpoint_handler_connected",  buf,  0xCu);
        }

void sub_181B67C9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_flow_passthrough_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
      if (!nw_protocols_are_equal(a2->identifier->name, &g_replay_protocol_identifier) && !a2->output_handler) {
        nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
      }
      output_handler = a1->output_handler;
      if (output_handler)
      {
        callbacks = output_handler->callbacks;
        if (callbacks)
        {
          notify = (void (*)(void))callbacks->notify;
          if (notify) {
            notify();
          }
        }
      }

      return 1LL;
    }

    __nwlog_obj();
    id v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v21 = "nw_flow_passthrough_add_input_handler";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v21 = "nw_flow_passthrough_add_input_handler";
          nw_endpoint_t v12 = "%{public}s called with null input_protocol";
          goto LABEL_38;
        }

        goto LABEL_39;
      }

      if (!v18)
      {
        __nwlog_obj();
        char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v21 = "nw_flow_passthrough_add_input_handler";
          nw_endpoint_t v12 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_38;
        }

        goto LABEL_39;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v17 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v21 = "nw_flow_passthrough_add_input_handler";
          nw_endpoint_t v12 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_38;
        }

        goto LABEL_39;
      }

      if (!v17) {
        goto LABEL_29;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v21 = "nw_flow_passthrough_add_input_handler";
      __int16 v22 = 2082;
      id v23 = backtrace_string;
      BOOL v16 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_28:
      _os_log_impl(&dword_181A5C000, v10, v11, v16, buf, 0x16u);
LABEL_29:

      free(backtrace_string);
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v21 = "nw_flow_passthrough_add_input_handler";
    BOOL v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v21 = "nw_flow_passthrough_add_input_handler";
          nw_endpoint_t v12 = "%{public}s called with null protocol";
LABEL_38:
          _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
        }

void nw_protocol_default_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v17 = "nw_protocol_default_notify";
    id v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_default_notify";
      BOOL v9 = "%{public}s called with null protocol";
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v17 = "nw_protocol_default_notify";
          __int16 v18 = 2082;
          id v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v6) {
          return;
        }
LABEL_42:
        free(v6);
        return;
      }

      if (!v11) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_default_notify";
      BOOL v9 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v17 = "nw_protocol_default_notify";
      BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

void nw_endpoint_handler_cancel(void *a1, uint64_t a2, int a3)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = v5;
  if (v5)
  {
    uint64_t v7 = (void *)v5[4];
    if (v7)
    {
      os_log_type_t v8 = v7;
      id v9 = *(id *)(v8[13] + 136LL);

      nw_context_assert_queue(v9);
    }

    char v10 = v6;
    BOOL v11 = v10;
    nw_endpoint_t v12 = (void *)v6[4];
    if (v12)
    {
      BOOL v13 = v12;
      uint64_t v14 = v13[12];

      if ((v14 & 0x4000000000LL) != 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v16 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v11);
          BOOL v53 = nw_endpoint_handler_dry_run_string(v11);
          os_log_type_t v66 = v6;
          nw_endpoint_t v64 = nw_endpoint_handler_copy_endpoint(v11);
          logging_description = nw_endpoint_get_logging_description(v64);
          os_log_type_t v55 = nw_endpoint_handler_state_string(v11);
          BOOL v56 = nw_endpoint_handler_mode_string(v11);
          id v57 = nw_endpoint_handler_copy_current_path(v11);
          *(_DWORD *)buf = 136447746;
          int v70 = "nw_endpoint_handler_cancel";
          __int16 v71 = 2082;
          __int16 v72 = (void *)id_string;
          __int16 v73 = 2082;
          __int16 v74 = v53;
          __int16 v75 = 2082;
          __int16 v76 = logging_description;
          __int16 v77 = 2082;
          __int16 v78 = v55;
          __int16 v79 = 2082;
          uint64_t v80 = v56;
          __int16 v81 = 2114;
          id v82 = v57;
          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);

          id v6 = v66;
        }

void sub_181B68DFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_service_writes(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v28 = "nw_endpoint_handler_service_writes";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v8, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          id v28 = "nw_endpoint_handler_service_writes";
          _os_log_impl(&dword_181A5C000, v9, v20, "%{public}s called with null handler", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (!v25)
      {
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          id v28 = "nw_endpoint_handler_service_writes";
          _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          id v28 = "nw_endpoint_handler_service_writes";
          _os_log_impl(&dword_181A5C000, v9, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        id v28 = "nw_endpoint_handler_service_writes";
        __int16 v29 = 2082;
        uint64_t v30 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v22,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181B694A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_flow_service_writes( NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2, nw_flow_protocol *a3)
{
  uint64_t v346 = *MEMORY[0x1895F89C0];
  v291 = a1;
  v296 = a2;
  if (!a3)
  {
    __nwlog_obj();
    v256 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
    v257 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(applier[0]) = 16;
    LOBYTE(foreach_block[0]) = 0;
    if (__nwlog_fault(v257, applier, foreach_block))
    {
      if (LOBYTE(applier[0]) == 17)
      {
        __nwlog_obj();
        v258 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v259 = applier[0];
        if (os_log_type_enabled(v258, applier[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
          _os_log_impl(&dword_181A5C000, v258, v259, "%{public}s called with null flow_protocol", buf, 0xCu);
        }
      }

      else if (LOBYTE(foreach_block[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v258 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v261 = applier[0];
        BOOL v262 = os_log_type_enabled(v258, applier[0]);
        if (backtrace_string)
        {
          if (v262)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v258,  v261,  "%{public}s called with null flow_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_361;
        }

        if (v262)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
          _os_log_impl( &dword_181A5C000,  v258,  v261,  "%{public}s called with null flow_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v258 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v270 = applier[0];
        if (os_log_type_enabled(v258, applier[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
          _os_log_impl( &dword_181A5C000,  v258,  v270,  "%{public}s called with null flow_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_361:
    if (v257) {
      free(v257);
    }
    goto LABEL_305;
  }

  output_handler = a3->protocol.output_handler;
  if (output_handler)
  {
    __int16 v6 = *((_WORD *)a3 + 166);
    if ((v6 & 8) == 0)
    {
      *((_WORD *)a3 + 166) = v6 | 8;
      uint64_t v320 = 0LL;
      get_message_properties = (void (*)(nw_protocol *, nw_flow_protocol *, uint64_t *))output_handler->callbacks->get_message_properties;
      if (get_message_properties) {
        get_message_properties(output_handler, a3, &v320);
      }
      v295 = a3;
      v288 = output_handler;
      lock = &v296->lock;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      while (1)
      {
        write_requests = v295->write_requests;
        initial_write_requests = v295->initial_write_requests;
        if (write_requests)
        {
          if (!initial_write_requests)
          {
            os_log_type_t v10 = v295;
            goto LABEL_13;
          }
        }

        else if (!initial_write_requests)
        {
          goto LABEL_337;
        }

        os_log_type_t v10 = v295;
        BOOL v11 = nw_write_request_copy_next_incomplete_request( v295->initial_write_requests,  (v320 & 0x200000000LL) != 0,  (*((unsigned __int16 *)v295 + 166) >> 1) & 1,  v295->last_output_context);
        if (v11) {
          goto LABEL_14;
        }
        write_requests = v295->write_requests;
        if (!write_requests) {
          goto LABEL_320;
        }
LABEL_13:
        BOOL v11 = nw_write_request_copy_next_incomplete_request( write_requests,  (v320 & 0x200000000LL) != 0,  (*((unsigned __int16 *)v10 + 166) >> 1) & 1,  v10->last_output_context);
        if (!v11)
        {
LABEL_320:
          if ((nw_flow_handle_send_complete(v291, v296, v10) & 1) != 0)
          {
LABEL_321:

            goto LABEL_337;
          }

          v242 = (OS_nw_write_request *)nw_write_request_list_prune(v295->initial_write_requests);
          __int16 v243 = v295->initial_write_requests;
          v295->initial_write_requests = v242;

          id v244 = (OS_nw_write_request *)nw_write_request_list_prune(v295->write_requests);
          __int16 v245 = v295->write_requests;
          v295->write_requests = v244;

          int minimize_logging = nw_endpoint_handler_get_minimize_logging(v291);
          char logging_disabled = nw_endpoint_handler_get_logging_disabled(v291);
          if (minimize_logging)
          {
            if ((logging_disabled & 1) != 0) {
              goto LABEL_321;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v234 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v234, OS_LOG_TYPE_DEBUG))
            {
              id_string = nw_endpoint_handler_get_id_string(v291);
              v279 = nw_endpoint_handler_dry_run_string(v291);
              nw_endpoint_t v280 = nw_endpoint_handler_copy_endpoint(v291);
              logging_description = nw_endpoint_get_logging_description(v280);
              v282 = nw_endpoint_handler_state_string(v291);
              v283 = nw_endpoint_handler_mode_string(v291);
              id v284 = nw_endpoint_handler_copy_current_path(v291);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = id_string;
              *(_WORD *)&_BYTE buf[22] = 2082;
              v338 = v279;
              *(_WORD *)v339 = 2082;
              *(void *)&v339[2] = logging_description;
              *(_WORD *)&v339[10] = 2082;
              *(void *)&v339[12] = v282;
              *(_WORD *)&v339[20] = 2082;
              *(void *)&v339[22] = v283;
              __int16 v340 = 2114;
              id v341 = v284;
              _os_log_impl( &dword_181A5C000,  v234,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No unblocked write requ ests, stopping servicing writes",  buf,  0x48u);
            }
          }

          else
          {
            if ((logging_disabled & 1) != 0) {
              goto LABEL_321;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v234 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v234, OS_LOG_TYPE_INFO))
            {
              v248 = nw_endpoint_handler_get_id_string(v291);
              v249 = nw_endpoint_handler_dry_run_string(v291);
              nw_endpoint_t v250 = nw_endpoint_handler_copy_endpoint(v291);
              v251 = nw_endpoint_get_logging_description(v250);
              v252 = nw_endpoint_handler_state_string(v291);
              v253 = nw_endpoint_handler_mode_string(v291);
              id v254 = nw_endpoint_handler_copy_current_path(v291);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v248;
              *(_WORD *)&_BYTE buf[22] = 2082;
              v338 = v249;
              *(_WORD *)v339 = 2082;
              *(void *)&v339[2] = v251;
              *(_WORD *)&v339[10] = 2082;
              *(void *)&v339[12] = v252;
              *(_WORD *)&v339[20] = 2082;
              *(void *)&v339[22] = v253;
              __int16 v340 = 2114;
              id v341 = v254;
              _os_log_impl( &dword_181A5C000,  v234,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No unblocked write requ ests, stopping servicing writes",  buf,  0x48u);
            }
          }

          v293 = 0LL;
          goto LABEL_335;
        }

        if (v32) {
          free(v32);
        }
        uint64_t v4 = v31;
        goto LABEL_376;
      }

      nw_endpoint_t v124 = *(void *)(v5 + 296);
      nw_endpoint_t v125 = *(void **)(v5 + 304);
      if (v124)
      {
        *(void *)(v124 + 304) = v125;
        nw_endpoint_t v125 = *(void **)(v5 + 304);
      }

      else
      {
        *(void *)(v3 + 256) = v125;
      }

      const char *v125 = v124;
      *(void *)(v5 + 296) = 0LL;
      *(void *)(v5 + 304) = 0LL;
      id v180 = *(_DWORD *)(v3 + 348);
      *(_DWORD *)(v3 + 34_Block_object_dispose(va, 8) = v180 - 1;
      if (v180)
      {
LABEL_374:
        *(_WORD *)(v5 + 428) &= ~0x1000u;
        if ((*(_BYTE *)(v5 + 158) & 1) == 0)
        {
          if (*((_BYTE *)v4 + 1537))
          {
            v541 = v4;
            v542 = (os_log_s *)__nwlog_obj();
            v543 = os_log_type_enabled(v542, OS_LOG_TYPE_DEBUG);
            uint64_t v4 = v541;
            if (v543)
            {
              v544 = v5 + 74;
              v545 = *(void *)(v5 + 256);
              v546 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
              if (v545) {
                LODWORD(v545) = *(_DWORD *)(v545 + 860);
              }
              uint64_t v5 = v579;
              v547 = *(_DWORD *)(v579 + 424);
              v548 = *(_DWORD *)(v580 + 348);
              *(_DWORD *)buf = 136448258;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v544;
              *(_WORD *)&_BYTE buf[22] = 2080;
              v608 = (uint64_t)" ";
              *(_WORD *)v609 = 1024;
              *(_DWORD *)&v609[2] = v546;
              *(_WORD *)&v609[6] = 1024;
              *(_DWORD *)&v609[8] = v545;
              *(_WORD *)&v609[12] = 1024;
              *(_DWORD *)&v609[14] = v547;
              *(_WORD *)&v609[18] = 1024;
              *(_DWORD *)&v609[20] = v547;
              *(_WORD *)&v609[24] = 2048;
              *(void *)&v609[26] = v579;
              *(_WORD *)&v609[34] = 1024;
              *(_DWORD *)&v609[36] = v548;
              _os_log_impl( &dword_181A5C000,  v542,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> removed pending stream %u (%p), now have %u pending streams",  buf,  0x48u);
              uint64_t v4 = v541;
            }
          }
        }

        goto LABEL_376;
      }

      nw_endpoint_t v181 = v4;
      nw_endpoint_t v182 = v3;
      __nwlog_obj();
      uint64_t v183 = *(unsigned int *)(v182 + 348);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = "http1->pending_stream_count";
      *(_WORD *)&_BYTE buf[22] = 2048;
      v608 = 1LL;
      *(_WORD *)v609 = 2048;
      *(void *)&v609[2] = v183;
      uint64_t v184 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(aBlock) = 0;
      if (__nwlog_fault(v184, type, &aBlock))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          id v185 = (os_log_s *)__nwlog_obj();
          unsigned int v186 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            char v187 = *(unsigned int *)(v580 + 348);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "http1->pending_stream_count";
            *(_WORD *)&_BYTE buf[22] = 2048;
            v608 = 1LL;
            *(_WORD *)v609 = 2048;
            *(void *)&v609[2] = v187;
            v188 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_370:
            _os_log_impl(&dword_181A5C000, v185, v186, v188, buf, 0x2Au);
          }
        }

        else if ((_BYTE)aBlock)
        {
          v251 = (char *)__nw_create_backtrace_string();
          id v185 = (os_log_s *)__nwlog_obj();
          unsigned int v186 = type[0];
          v252 = os_log_type_enabled(v185, type[0]);
          if (v251)
          {
            if (v252)
            {
              v253 = *(unsigned int *)(v580 + 348);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "http1->pending_stream_count";
              *(_WORD *)&_BYTE buf[22] = 2048;
              v608 = 1LL;
              *(_WORD *)v609 = 2048;
              *(void *)&v609[2] = v253;
              *(_WORD *)&v609[10] = 2082;
              *(void *)&v609[12] = v251;
              _os_log_impl( &dword_181A5C000,  v185,  v186,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v251);
            goto LABEL_371;
          }

          if (v252)
          {
            v258 = *(unsigned int *)(v580 + 348);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "http1->pending_stream_count";
            *(_WORD *)&_BYTE buf[22] = 2048;
            v608 = 1LL;
            *(_WORD *)v609 = 2048;
            *(void *)&v609[2] = v258;
            v188 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_370;
          }
        }

        else
        {
          id v185 = (os_log_s *)__nwlog_obj();
          unsigned int v186 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            id v254 = *(unsigned int *)(v580 + 348);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_remove_pending_stream";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "http1->pending_stream_count";
            *(_WORD *)&_BYTE buf[22] = 2048;
            v608 = 1LL;
            *(_WORD *)v609 = 2048;
            *(void *)&v609[2] = v254;
            v188 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_370;
          }
        }
      }

                  nw_endpoint_t v18 = (os_log_s *)__nwlog_obj();
                  if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_27;
                  }
                  *(_DWORD *)buf = 136446210;
                  __int16 v204 = "nw_http_copy_metadata_from_binary_message";
                  id v19 = "%{public}s Failed to decode integer";
                  goto LABEL_25;
                }

                if (v57 < 8) {
                  goto LABEL_361;
                }
                os_log_type_t v54 = bswap64(*(void *)v56 & 0xFFFFFFFFFFFFFF3FLL);
                unsigned int v85 = 8LL;
              }

LABEL_335:
              }
            }

            else if ((v233 & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v234 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v234, OS_LOG_TYPE_INFO))
              {
                __int16 v235 = nw_endpoint_handler_get_id_string(v291);
                v236 = nw_endpoint_handler_dry_run_string(v291);
                nw_endpoint_t v237 = nw_endpoint_handler_copy_endpoint(v291);
                v238 = nw_endpoint_get_logging_description(v237);
                __int16 v239 = nw_endpoint_handler_state_string(v291);
                v240 = nw_endpoint_handler_mode_string(v291);
                id v241 = nw_endpoint_handler_copy_current_path(v291);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v235;
                *(_WORD *)&_BYTE buf[22] = 2082;
                v338 = v236;
                *(_WORD *)v339 = 2082;
                *(void *)&v339[2] = v238;
                *(_WORD *)&v339[10] = 2082;
                *(void *)&v339[12] = v239;
                *(_WORD *)&v339[20] = 2082;
                *(void *)&v339[22] = v240;
                __int16 v340 = 2114;
                id v341 = v241;
                _os_log_impl( &dword_181A5C000,  v234,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Write request is not idempotent, stopping servicing writes",  buf,  0x48u);
              }

              goto LABEL_335;
            }

        free(v134);
        goto LABEL_336;
      }

      if (v162)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_181A5C000, v135, v161, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint32x4_t v135 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v171 = type[0];
      if (os_log_type_enabled(v135, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl( &dword_181A5C000,  v135,  v171,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      __int16 v171 = v173 - (void)v170;
LABEL_336:
      id v178 = lsqpack_enc_enc_str(7, v170, v171, (unsigned __int8 *)v307, v301);
      int v82 = v303;
      int v163 = v312;
      if (v178 < 0) {
        goto LABEL_32;
      }
LABEL_337:
      v172 = &v170[v178];
      goto LABEL_338;
    case 4uLL:
      char v164 = v293;
      if (v82 > *(_DWORD *)(v68 + 156)) {
        goto LABEL_258;
      }
      id *v293 = v266;
      __int16 v173 = v291;
      if (v292 <= 0) {
        goto LABEL_440;
      }
      id v174 = *(_DWORD *)(v68 + 156) - v82;
      if (v174 <= 0xE)
      {
        id *v293 = v266 | (*(_BYTE *)(v68 + 156) - v82);
        id v170 = v293 + 1;
        goto LABEL_335;
      }

      id *v293 = v263;
      __int16 v204 = v293 + 1;
      id v205 = v174 - 15;
      do
      {
        *v204++ = v205 | 0x80;
        uint64_t v206 = v205 >> 7;
        v211 = v205 >> 14;
        v205 >>= 7;
      }

      while (v211);
LABEL_331:
      v212 = v204 - 1;
      goto LABEL_334;
    case 5uLL:
      int v82 = *(_DWORD *)v68 + 1;
      char v164 = v293;
LABEL_258:
      *char v164 = v269;
      __int16 v175 = *(_DWORD *)(v68 + 156);
      if (v82 <= v175) {
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2045, "id > enc->qpe_cur_header.base_idx");
      }
      if (v292 <= 0) {
        goto LABEL_440;
      }
      nw_endpoint_t v176 = v82 + ~v175;
      if (v176 > 6)
      {
        *char v164 = v265;
        id v193 = v164 + 1;
        id v194 = v176 - 7;
        if (v176 - 7 < 0x80)
        {
          LOBYTE(v176) = v176 - 7;
          char v196 = v164;
        }

        else
        {
          do
          {
            *v193++ = v194 | 0x80;
            nw_endpoint_t v176 = v194 >> 7;
            nw_endpoint_t v195 = v194 >> 14;
            v194 >>= 7;
          }

          while (v195);
          char v196 = v193 - 1;
        }

        id v170 = v196 + 2;
        *id v193 = v176;
        if (v196 + 2 <= v164) {
          goto LABEL_32;
        }
      }

      else
      {
        *char v164 = v269 | (v82 + ~(_BYTE)v175);
        id v170 = v164 + 1;
      }

      char v177 = v82;
      id v178 = lsqpack_enc_enc_str(7, v170, v291 - (void)v170, (unsigned __int8 *)v307, v301);
      int v163 = v312;
      if (v178 < 0) {
        goto LABEL_32;
      }
      int v82 = v177;
      goto LABEL_337;
    case 6uLL:
      char v164 = v293;
      id *v293 = v267;
      __int16 v169 = lsqpack_enc_enc_str(3, v293, v292, (unsigned __int8 *)v313, v63);
      if (v169 < 0) {
        goto LABEL_32;
      }
      id v170 = &v293[v169];
      __int16 v171 = v291 - (void)v170;
      goto LABEL_336;
    default:
      goto LABEL_445;
  }

LABEL_221:
              }
            }

            else if ((v129 & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              nw_endpoint_t v130 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v130, OS_LOG_TYPE_INFO))
              {
                v309 = v130;
                id v131 = nw_endpoint_handler_get_id_string(v294);
                id v132 = nw_endpoint_handler_dry_run_string(v294);
                nw_endpoint_t v133 = nw_endpoint_handler_copy_endpoint(v294);
                id v134 = nw_endpoint_get_logging_description(v133);
                v303 = nw_endpoint_handler_state_string(v294);
                uint32x4_t v135 = nw_endpoint_handler_mode_string(v294);
                id v136 = nw_endpoint_handler_copy_current_path(v294);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_flow_prepare_output_frames";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v131;
                *(_WORD *)&_BYTE buf[22] = 2082;
                v338 = v132;
                *(_WORD *)v339 = 2082;
                *(void *)&v339[2] = v134;
                *(_WORD *)&v339[10] = 2082;
                nw_endpoint_t v130 = v309;
                *(void *)&v339[12] = v303;
                *(_WORD *)&v339[20] = 2082;
                *(void *)&v339[22] = v135;
                __int16 v340 = 2114;
                id v341 = v136;
                _os_log_impl( &dword_181A5C000,  v309,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Write request is not idempotent, stopping preparing frames",  buf,  0x48u);
              }

              goto LABEL_221;
            }

            id v46 = v48;
            goto LABEL_246;
          }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v188 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
              {
                nw_endpoint_t v189 = nw_endpoint_handler_get_id_string(v356);
                nw_endpoint_t v190 = nw_endpoint_handler_dry_run_string(v356);
                int v191 = nw_endpoint_handler_copy_endpoint(v356);
                uint64_t v192 = nw_endpoint_get_logging_description(v191);
                id v193 = nw_endpoint_handler_state_string(v356);
                id v194 = nw_endpoint_handler_mode_string(v356);
                nw_endpoint_t v195 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                v364 = 2082;
                v365 = (void *)v189;
                v366 = 2082;
                v367 = v190;
                v368 = 2082;
                v369 = (void *)v192;
                v370 = 2082;
                v371 = v193;
                v372 = 2082;
                v373 = v194;
                v374 = 2114;
                v375 = v195;
                _os_log_impl( &dword_181A5C000,  v188,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to remove repl ay protocol from the stack on cancellation",  buf,  0x48u);
              }

              goto LABEL_226;
            }

            v336 = *((void *)v6 + 65);
            v337 = *((void *)v6 + 63);
            os_log_type_t v98 = v356;
            BOOL v99 = (*((_BYTE *)v98 + 268) & 0x20) == 0;

            if (!v99)
            {
LABEL_264:
              nw_endpoint_t v218 = v336;
              v217 = (const char *)v337;
              if (v336)
              {
                os_log_type_t v219 = *(void *)(v336 + 32);
                if (v219)
                {
                  if (*(_UNKNOWN **)(v219 + 40) == &nw_protocol_ref_counted_handle)
                  {
                    v258 = *(void *)(v219 + 88);
                    if (v258)
                    {
                      os_log_type_t v259 = v258 - 1;
                      *(void *)(v219 + 8_Block_object_dispose(va, 8) = v259;
                      if (!v259)
                      {
                        v260 = *(void (***)(void))(v219 + 64);
                        if (v260)
                        {
                          *(void *)(v219 + 64) = 0LL;
                          v260[2](v260);
                          _Block_release(v260);
                        }

                        if ((*(_BYTE *)(v219 + 72) & 1) != 0)
                        {
                          os_log_type_t v261 = *(const void **)(v219 + 64);
                          if (v261) {
                            _Block_release(v261);
                          }
                        }

                        free((void *)v219);
                        nw_endpoint_t v218 = v336;
                        v217 = (const char *)v337;
                      }
                    }
                  }

                  *(void *)(v218 + 32) = 0LL;
                }
              }

              if (!v217) {
                goto LABEL_286;
              }
              v220 = (void *)*((void *)v217 + 5);
              if (v220 == &nw_protocol_ref_counted_handle)
              {
                id v222 = *((void *)v217 + 11);
                id v221 = (uint64_t)v6 + 472;
                if (v222) {
                  *((void *)v217 + 11) = v222 + 1;
                }
                *(void *)os_log_type_t type = v217;
                v362 |= 1u;
              }

              else
              {
                *(void *)os_log_type_t type = v217;
                v362 &= ~1u;
                id v221 = (uint64_t)v6 + 472;
              }

              unint64_t v223 = (void *)*((void *)v6 + 64);
              if (v223 == &nw_protocol_ref_counted_handle)
              {
                int v225 = *((void *)v6 + 70);
                if (v225) {
                  *((void *)v6 + 70) = v225 + 1;
                }
                v359 = v221;
                char v224 = v360 | 1;
              }

              else
              {
                v359 = v221;
                char v224 = v360 & 0xFE;
              }

              v360 = v224;
              v226 = *((void *)v217 + 3);
              if (v226)
              {
                uint64_t v227 = *(void (**)(const char *, uint64_t))(v226 + 8);
                if (v227)
                {
                  v227(v217, v221);
LABEL_282:
                  if (v223 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>(&v359);
                  }
                  if (v220 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
                  goto LABEL_286;
                }
              }

              v300 = v217;
              __nwlog_obj();
              size_t v301 = (void *)objc_claimAutoreleasedReturnValue();
              v302 = (const char *)*((void *)v300 + 2);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
              if (!v302) {
                v302 = "invalid";
              }
              v364 = 2082;
              v365 = (void *)v302;
              v366 = 2048;
              v367 = v300;
              v303 = (char *)_os_log_send_and_compose_impl();

              v358 = OS_LOG_TYPE_ERROR;
              v357 = 0;
              if (__nwlog_fault(v303, &v358, &v357))
              {
                if (v358 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v304 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  id v305 = v358;
                  if (os_log_type_enabled(v304, v358))
                  {
                    v306 = *(const char **)(v337 + 16);
                    if (!v306) {
                      v306 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                    v364 = 2082;
                    v365 = (void *)v306;
                    v366 = 2048;
                    v367 = (const char *)v337;
                    _os_log_impl( &dword_181A5C000,  v304,  v305,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback",  buf,  0x20u);
                  }
                }

                else if (v357)
                {
                  v307 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v304 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v308 = v358;
                  v309 = os_log_type_enabled(v304, v358);
                  if (v307)
                  {
                    if (v309)
                    {
                      v310 = *(const char **)(v337 + 16);
                      if (!v310) {
                        v310 = "invalid";
                      }
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                      v364 = 2082;
                      v365 = (void *)v310;
                      v366 = 2048;
                      v367 = (const char *)v337;
                      v368 = 2082;
                      v369 = v307;
                      _os_log_impl( &dword_181A5C000,  v304,  v308,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    free(v307);
                    goto LABEL_445;
                  }

                  if (v309)
                  {
                    uint64_t v323 = *(const char **)(v337 + 16);
                    if (!v323) {
                      uint64_t v323 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                    v364 = 2082;
                    v365 = (void *)v323;
                    v366 = 2048;
                    v367 = (const char *)v337;
                    _os_log_impl( &dword_181A5C000,  v304,  v308,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace",  buf,  0x20u);
                  }
                }

                else
                {
                  __nwlog_obj();
                  v304 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  uint64_t v321 = v358;
                  if (os_log_type_enabled(v304, v358))
                  {
                    uint64_t v322 = *(const char **)(v337 + 16);
                    if (!v322) {
                      uint64_t v322 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                    v364 = 2082;
                    v365 = (void *)v322;
                    v366 = 2048;
                    v367 = (const char *)v337;
                    _os_log_impl( &dword_181A5C000,  v304,  v321,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded",  buf,  0x20u);
                  }
                }
              }

    OS_nw_association *v91 = 0;
    return (BOOL)v2;
  }

  __nwlog_obj();
  uint64_t v111 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v111, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  nw_endpoint_t v140 = "_strict_strlcat";
  BOOL v112 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v112);
  if (!result)
  {
    free(v112);
    goto LABEL_197;
  }

  if (v107) {
LABEL_222:
  }
    free(v107);
LABEL_292:
}

              if (v97) {
                free(v97);
              }
              goto LABEL_129;
            }

            nw_protocol_metadata_t v79 = v4;
            uint64_t v80 = v79;
            if (v79)
            {
              *((void *)v79 + 12) |= 0x20000000000uLL;
LABEL_125:

              goto LABEL_126;
            }

            __nwlog_obj();
            uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)objects = 136446210;
            *(void *)&objects[4] = "nw_parameters_set_allow_private_access_tokens_for_third_party";
            LODWORD(v119) = 12;
            uint64_t v116 = objects;
            uint64_t v93 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            int v128 = 0;
            if (__nwlog_fault(v93, &type, &v128))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                size_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                __int16 v95 = type;
                if (os_log_type_enabled(v94, type))
                {
                  *(_DWORD *)objects = 136446210;
                  *(void *)&objects[4] = "nw_parameters_set_allow_private_access_tokens_for_third_party";
                  _os_log_impl(&dword_181A5C000, v94, v95, "%{public}s called with null parameters", objects, 0xCu);
                }
              }

              else if (v128)
              {
                int v107 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                size_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                nw_endpoint_t v123 = type;
                BOOL v108 = os_log_type_enabled(v94, type);
                if (v107)
                {
                  if (v108)
                  {
                    *(_DWORD *)objects = 136446466;
                    *(void *)&objects[4] = "nw_parameters_set_allow_private_access_tokens_for_third_party";
                    *(_WORD *)&objects[12] = 2082;
                    *(void *)&objects[14] = v107;
                    _os_log_impl( &dword_181A5C000,  v94,  v123,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  objects,  0x16u);
                  }

                  free(v107);
                  goto LABEL_216;
                }

                if (v108)
                {
                  *(_DWORD *)objects = 136446210;
                  *(void *)&objects[4] = "nw_parameters_set_allow_private_access_tokens_for_third_party";
                  _os_log_impl( &dword_181A5C000,  v94,  v123,  "%{public}s called with null parameters, no backtrace",  objects,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                size_t v94 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                BOOL v112 = type;
                if (os_log_type_enabled(v94, type))
                {
                  *(_DWORD *)objects = 136446210;
                  *(void *)&objects[4] = "nw_parameters_set_allow_private_access_tokens_for_third_party";
                  _os_log_impl( &dword_181A5C000,  v94,  v112,  "%{public}s called with null parameters, backtrace limit exceeded",  objects,  0xCu);
                }
              }
            }

    __break(1u);
    return;
  }

  if ((*(_BYTE *)(a1 + 348) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v68 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_prepare_request";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 349;
      *(_WORD *)&_BYTE buf[22] = 2080;
      nw_endpoint_t v140 = (uint64_t)" ";
      _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to prepare request",  buf,  0x20u);
    }
  }

  nw_ohttp_mark_failed_with_error(a1, 22);
}

  int v163 = *(void *)(a2 + 64);
  if (v163 && (*(_BYTE *)(v163 + 66) & 0x40) != 0)
  {
    char v164 = **(void **)(*(void *)(*(void *)&buf[8] + 48LL) + 8LL);
    if (v164) {
      nw_frame_inherit_metadata(a2, v164, 1);
    }
    *(_WORD *)(*v29 + 648) |= 0x80u;
    nw_http_encoding_check_http1_content_length(*v29);
  }

  v210[0] = v46;
  v210[1] = 0x40000000LL;
  v211 = (uint64_t (*)(void *))___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_26;
  v212 = &unk_189BBC040;
  unsigned int v216 = *(_OWORD *)(v143 + 7);
  id v213 = &v219;
  uint64_t v214 = buf;
  v217 = v143[9];
  v215 = v143[5];
  v165 = *(void *)(*(void *)&buf[8] + 40LL);
  do
  {
    if (!v165) {
      break;
    }
    uint64_t v166 = *(void *)(v165 + 32);
    __int16 v167 = v211(v210);
    v165 = v166;
  }

  while ((v167 & 1) != 0);
  nw_endpoint_t v168 = (uint64_t *)(*(void *)&buf[8] + 40LL);
  if (gLogDatapath)
  {
    __int16 v173 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t v227 = 136446210;
      *(void *)&v227[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_181A5C000, v173, OS_LOG_TYPE_DEBUG, "%{public}s called", v227, 0xCu);
    }
  }

  *(void *)uint64_t v227 = v46;
  *(void *)&v227[8] = 0x40000000LL;
  *(void *)&v227[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33165;
  v228 = (const char *)&__block_descriptor_tmp_38_33166;
  *(void *)uint64_t v229 = v168;
  v229[8] = 0;
  __int16 v169 = *v168;
  do
  {
    if (!v169) {
      break;
    }
    id v170 = *(void *)(v169 + 32);
    __int16 v171 = (*(uint64_t (**)(_BYTE *))&v227[16])(v227);
    __int16 v169 = v170;
  }

  while ((v171 & 1) != 0);
LABEL_233:
  id v156 = v57 >= 0;
  _Block_object_dispose(&v219, 8);
  _Block_object_dispose(buf, 8);
  if (v5) {
LABEL_234:
  }
    os_release(v5);
  return v156;
}

        a4 = v273;
        __int16 v29 = v194;
        goto LABEL_57;
      }
    }

    else
    {
      if (v19 != v10)
      {
        os_log_type_t v21 = 0LL;
        id v22 = 0LL;
LABEL_191:

        goto LABEL_192;
      }

      unsigned int v25 = v20;
      id v277 = v25;
      v275 = a3;
      if (!nw_endpoint_handler_get_minimize_logging(v12))
      {
        uint64_t v38 = v12;
        id v39 = *((_BYTE *)v38 + 268);

        if ((v39 & 0x20) != 0) {
          goto LABEL_59;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v29 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          os_log_t loga = v29;
          os_log_type_t v40 = v38;

          __int16 v41 = v40;
          os_log_type_t v42 = *((_BYTE *)v38 + 268);

          if ((v42 & 1) != 0) {
            int v43 = "dry-run ";
          }
          else {
            int v43 = "";
          }
          v256 = nw_endpoint_handler_copy_endpoint(v41);
          v252 = nw_endpoint_get_logging_description(v256);
          id v44 = v41;
          uint64_t v45 = v44;
          id v46 = v44[30];
          else {
            uint64_t v47 = off_189BBBBF0[v46];
          }
          id v244 = v47;

          int v52 = v45;
          int v53 = v52;
          os_log_type_t v54 = v12->mode;
          v271 = a4;
          v248 = v43;
          size_t v55 = "path";
          switch(v54)
          {
            case 0:
              break;
            case 1:
              size_t v55 = "resolver";
              break;
            case 2:
              size_t v55 = nw_endpoint_flow_mode_string(v52[31]);
              break;
            case 3:
              size_t v55 = "proxy";
              break;
            case 4:
              size_t v55 = "fallback";
              break;
            case 5:
              size_t v55 = "transform";
              break;
            default:
              size_t v55 = "unknown-mode";
              break;
          }

          id v67 = v53;
          os_unfair_lock_lock((os_unfair_lock_t)v67 + 28);
          size_t v68 = v67[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v67 + 28);

          size_t v69 = v68;
          int v70 = nw_endpoint_handler_get_id_string(v10);
          char v71 = nw_endpoint_handler_dry_run_string(v10);
          __int16 v72 = nw_endpoint_handler_copy_endpoint(v10);
          v260 = v20;
          __int16 v73 = nw_endpoint_get_logging_description(v72);
          uint64_t v74 = v40 + 168;
          BOOL v75 = nw_endpoint_handler_state_string(v10);
          __int16 v76 = nw_endpoint_handler_mode_string(v280);
          __int16 v77 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = v74;
          v289 = 2082;
          v290 = v248;
          v291 = 2082;
          v292 = v252;
          v293 = 2082;
          id v294 = v244;
          v295 = 2082;
          v296 = v55;
          v297 = 2114;
          v298 = v69;
          v299 = 2082;
          v300 = (unint64_t)v70;
          size_t v301 = 2082;
          v302 = v71;
          v303 = 2082;
          v304 = v73;
          id v305 = 2082;
          v306 = v75;
          v307 = 2082;
          v308 = v76;
          v309 = 2114;
          v310 = v77;
          __int16 v29 = loga;
          _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received fallback child rep ort:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x84u);

          size_t v20 = v260;
          a4 = v271;
        }

        goto LABEL_57;
      }

      nw_endpoint_t v273 = a4;
      if ((nw_endpoint_handler_get_logging_disabled(v12) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v194 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
        {
          v263 = nw_endpoint_handler_get_id_string(v12);
          v258 = nw_endpoint_handler_dry_run_string(v12);
          logd = nw_endpoint_handler_copy_endpoint(v12);
          id v254 = nw_endpoint_get_logging_description(logd);
          nw_endpoint_t v250 = nw_endpoint_handler_state_string(v12);
          v246 = nw_endpoint_handler_mode_string(v12);
          nw_endpoint_t v203 = nw_endpoint_handler_copy_current_path(v12);
          __int16 v204 = nw_endpoint_handler_get_id_string(v10);
          id v205 = nw_endpoint_handler_dry_run_string(v10);
          uint64_t v206 = nw_endpoint_handler_copy_endpoint(v10);
          os_log_type_t v207 = nw_endpoint_get_logging_description(v206);
          v208 = nw_endpoint_handler_state_string(v10);
          nw_endpoint_t v209 = nw_endpoint_handler_mode_string(v10);
          v210 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = (void *)v263;
          v289 = 2082;
          v290 = v258;
          v291 = 2082;
          v292 = v254;
          v293 = 2082;
          id v294 = v250;
          v295 = 2082;
          v296 = v246;
          v297 = 2114;
          v298 = v203;
          v299 = 2082;
          v300 = (unint64_t)v204;
          size_t v301 = 2082;
          v302 = v205;
          v303 = 2082;
          v304 = v207;
          id v305 = 2082;
          v306 = v208;
          v307 = 2082;
          v308 = v209;
          v309 = 2114;
          v310 = v210;
          __int16 v29 = v194;
          _os_log_impl( &dword_181A5C000,  v194,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received fallback child rep ort:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x84u);

          a4 = v273;
          goto LABEL_57;
        }

        goto LABEL_221;
      }
    }

    unsigned int v25 = v277;
    a4 = v273;
    goto LABEL_58;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v23 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    else {
      size_t v24 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    v286 = "nw_endpoint_fallback_receive_report";
    v287 = 2082;
    v288 = (void *)v24;
    v289 = 2082;
    v290 = "fallback";
    _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_28:
  id v22 = 0LL;
LABEL_192:

  return v22;
}

            free(v68);
            goto LABEL_222;
          }

        uint32x4_t v135 = (char *)*v9;
        id v136 = *((_DWORD *)*v9 + 2) - 1;
        *((_DWORD *)*v9 + 2) = v136;
        if (!v136) {
          free(v135);
        }
LABEL_223:
        os_log_s *v9 = 0LL;
        goto LABEL_231;
      }

      os_log_type_t v16 = &v3[v55];
      *(_DWORD *)(v5 + 792) += v55;
      __int16 v73 = HIDWORD(v53);
LABEL_93:
      *(_DWORD *)(v5 + 788) += v73;
      goto LABEL_7;
    case 0xE:
      BOOL v56 = *(unsigned int **)(v5 + 776);
      id v57 = *v56;
      uint64_t v58 = *(_DWORD *)(v5 + 768);
      os_log_type_t v59 = v58 + *v56;
      *(_DWORD *)(v5 + 784) = v59;
      BOOL v56 = (unsigned int *)realloc(v56, v59 + 28);
      if (!v56) {
        goto LABEL_231;
      }
      *(void *)(v5 + 776) = v56;
      uint64_t v58 = *(_DWORD *)(v5 + 768);
      id v57 = *v56;
LABEL_73:
      id v60 = *(unsigned int *)(v5 + 788);
      size_t v61 = v58 - v60;
      else {
        unsigned int v62 = v61;
      }
      memcpy((char *)v56 + v57 + v60 + 28, v3, v62);
      int v63 = *(_DWORD *)(v5 + 788) + v62;
      *(_DWORD *)(v5 + 78_Block_object_dispose(va, 8) = v63;
      os_log_type_t v16 = &v3[v62];
      if (v63 != *(_DWORD *)(v5 + 768)) {
        goto LABEL_7;
      }
      nw_endpoint_t v64 = *v9;
      goto LABEL_207;
    default:
      __assert_rtn("lsqpack_dec_enc_in", "lsqpack.c", 4981, "0");
  }

LABEL_173:
          if ((v96 & 1) != 0)
          {
            BOOL v108 = (*(_WORD *)(handle + 332) & 2) == 0;
            if (!v46) {
              goto LABEL_188;
            }
          }

          else
          {
            BOOL v108 = 0;
            if (!v46) {
              goto LABEL_188;
            }
          }

          BOOL v109 = (os_unfair_lock_s *)v46;
          uint64_t v110 = v109;
          if (v109 == (os_unfair_lock_s *)&__block_literal_global_5_41854
            || v109 == (os_unfair_lock_s *)&__block_literal_global_4
            || v109 == (os_unfair_lock_s *)&__block_literal_global_3_41839
            || v109 == (os_unfair_lock_s *)&__block_literal_global_41831)
          {

LABEL_188:
            if (!v108) {
              goto LABEL_197;
            }
            nw_frame_set_metadata(v45, 0LL, 0, 1);
            if (!v46) {
              goto LABEL_197;
            }
            goto LABEL_190;
          }

          os_unfair_lock_lock(v109 + 28);
          uint64_t v111 = *(void *)&v110[22]._os_unfair_lock_opaque;
          if (v111) {
            uint64_t v111 = (uint64_t)(*(void *)(v111 + 24) - *(void *)(v111 + 16)) >> 3;
          }
          BOOL v112 = v111 == 0;
          os_unfair_lock_unlock(v110 + 28);

          if (v112) {
            goto LABEL_188;
          }
          foreach_block[0] = MEMORY[0x1895F87A8];
          foreach_block[1] = 3221225472LL;
          foreach_block[2] = ___ZL29nw_flow_prepare_output_framesP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sjP30nw_protocol_message_properties_block_invoke_85;
          foreach_block[3] = &unk_189BB8528;
          id v330 = (id)v45;
          BOOL v331 = v108;
          nw_content_context_foreach_protocol_metadata((nw_content_context_t)v110, foreach_block);

LABEL_190:
          if (v108)
          {
            id v113 = v46;
            if (v113 == (_BYTE *)&__block_literal_global_41831 || v113 == (_BYTE *)&__block_literal_global_5_41854)
            {

              goto LABEL_197;
            }

            if (v113 == (_BYTE *)&__block_literal_global_3_41839 || v113 == (_BYTE *)&__block_literal_global_4)
            {

LABEL_196:
              *(_BYTE *)(v45 + 186) |= 0x80u;
              goto LABEL_197;
            }

            BOOL v114 = (v113[118] & 1) == 0;

            if (!v114) {
              goto LABEL_196;
            }
          }

    free(backtrace_string);
    goto LABEL_192;
  }

  uint64_t v7 = *(void *)(a1 + 40);
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
    unsigned int v101 = (char *)_os_log_send_and_compose_impl();
    v130[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v130[0] == 17)
    {
      char v102 = (os_log_s *)__nwlog_obj();
      unsigned int v103 = v130[0];
      if (os_log_type_enabled(v102, (os_log_type_t)v130[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
        __int16 v104 = "%{public}s called with null http_authentication";
        goto LABEL_191;
      }

      goto LABEL_192;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      char v102 = (os_log_s *)__nwlog_obj();
      unsigned int v103 = v130[0];
      if (os_log_type_enabled(v102, (os_log_type_t)v130[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
        __int16 v104 = "%{public}s called with null http_authentication, backtrace limit exceeded";
        goto LABEL_191;
      }

      goto LABEL_192;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v102 = (os_log_s *)__nwlog_obj();
    unsigned int v103 = v130[0];
    BOOL v108 = os_log_type_enabled(v102, (os_log_type_t)v130[0]);
    if (!backtrace_string)
    {
      if (v108)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
        __int16 v104 = "%{public}s called with null http_authentication, no backtrace";
        goto LABEL_191;
      }

      goto LABEL_192;
    }

    if (v108)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      int v107 = "%{public}s called with null http_authentication, dumping backtrace:%{public}s";
      goto LABEL_172;
    }

    goto LABEL_173;
  }

  if (!a2) {
    goto LABEL_29;
  }
  _CFHTTPAuthenticationUpdateFromResponse();
  if (!CFHTTPAuthenticationIsValid(a2, 0LL))
  {
    if (a3)
    {
      if (*(void *)(v7 + 640))
      {
        size_t v20 = a3;
        os_log_type_t v21 = v20[2];

        if (v21)
        {
          if (*(void *)(v7 + 688))
          {
            id v22 = -[NWConcrete_nw_authentication_credential initWithType:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_authentication_credential),  1);
            int v23 = v20;
            size_t v24 = (const char *)v20[2];

            nw_authentication_credential_set_username(v22, v24);
            nw_authentication_credential_set_persistence(v22, 1);
            nw_authentication_credential_storage_set_default_credential(*(void **)(v7 + 688), *(void **)(v7 + 640), v22);
            if (v22) {
              os_release(v22);
            }
          }
        }
      }
    }

    if (a4 != 5) {
      nw_array_remove_objects(*(void *)(v7 + 704), (uint64_t)&__block_literal_global_29);
    }
    if ((*(_WORD *)(v7 + 1062) & 0x10) != 0)
    {
      unsigned int v25 = (void **)(v7 + 864);
      id v26 = (char *)(v7 + 872);
      uint64_t v27 = *(_BYTE *)(v7 + 872);
      if ((v27 & 1) == 0) {
        goto LABEL_25;
      }
    }

    else
    {
      unsigned int v25 = (void **)(v7 + 848);
      id v26 = (char *)(v7 + 856);
      uint64_t v27 = *(_BYTE *)(v7 + 856);
      if ((v27 & 1) == 0)
      {
LABEL_25:
        *unsigned int v25 = 0LL;
        *id v26 = v27 | 1;
        id v28 = *(_BYTE *)(v7 + 648);
        if ((v28 & 1) != 0)
        {
          __int16 v29 = *(void **)(v7 + 640);
          if (v29)
          {
            os_release(v29);
            id v28 = *(_BYTE *)(v7 + 648);
          }
        }

        *(void *)(v7 + 640) = 0LL;
        *(_BYTE *)(v7 + 64_Block_object_dispose(va, 8) = v28 | 1;
        goto LABEL_29;
      }
    }

    if (*v25)
    {
      os_release(*v25);
      uint64_t v27 = *v26;
    }

    goto LABEL_25;
  }

  if (a3)
  {
    if (a4 == 5)
    {
      char v13 = a3;
      char v14 = v13[2];

      if (v14)
      {
        if (nw_http_authentication_apply_credentials(*(__CFHTTPMessage **)(v7 + 912), a2, v13))
        {
          NTLMHeaderForRequest = (const __CFString *)_CFHTTPAuthenticationCreateNTLMHeaderForRequest();
          if (NTLMHeaderForRequest)
          {
            os_log_type_t v16 = NTLMHeaderForRequest;
            id v17 = MEMORY[0x1895F87A8];
            v122[0] = MEMORY[0x1895F87A8];
            v122[1] = 0x40000000LL;
            v122[2] = ___ZL39nw_http_authentication_handle_challengeP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_30;
            v122[3] = &__block_descriptor_tmp_31;
            v122[4] = v7;
            nw_utilities_get_c_string_from_cfstring(NTLMHeaderForRequest, 0x201u, v122);
            nw_protocol_plugin_retry_begin_async(v7 + 344);
            nw_endpoint_t v18 = *(void **)(v7 + 832);
            v121[0] = v17;
            v121[1] = 0x40000000LL;
            v121[2] = ___ZL39nw_http_authentication_handle_challengeP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke_2;
            v121[3] = &unk_189BB7AD0;
            v121[4] = a6;
            v121[5] = v7;
            nw_queue_context_async(v18, v121);
            CFRelease(v16);
            return 2LL;
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v86 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
              _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to find authorization",  buf,  0xCu);
            }

            id v19 = 1LL;
            (*(void (**)(uint64_t, void, uint64_t, uint64_t))(a6 + 16))(a6, 0LL, 1LL, 1LL);
          }

          return v19;
        }

    if (v93) {
      free(v93);
    }
    goto LABEL_99;
  }

  BOOL v11 = v10;
  nw_endpoint_t v12 = v11[38];

  char v13 = v11;
  char v14 = v13;
  uint64_t v15 = 1;
  switch(v11[38])
  {
    case 1:
      uint64_t v15 = v13[39];
      break;
    case 2:
      uint64_t v15 = 1002;
      break;
    case 3:
      uint64_t v15 = 1001;
      break;
    case 4:
      break;
    default:
      uint64_t v15 = 0;
      break;
  }

  os_log_type_t v16 = nw_endpoint_handler_copy_endpoint(v171);
  id v17 = v16;
  os_log_type_t v155 = v16;
  char v164 = v12;
  obj = v8;
  if (v12 == 1)
  {
    nw_endpoint_t v18 = v14;
    id v19 = v18[5];

    __int16 v167 = (nw_endpoint_t)nw_endpoint_copy(v19);
    if (v15 != 2001) {
      nw_endpoint_set_parent_endpoint(v167, v17, 1);
    }
    nw_endpoint_set_do_not_redact(v167);
  }

  else if (v12 == 4)
  {
    __int16 v167 = v16;
  }

  else
  {
    if ((nw_endpoint_handler_get_logging_disabled(v171) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      size_t v20 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_endpoint_handler_get_id_string(v171);
        id v22 = nw_endpoint_handler_dry_run_string(v171);
        int v23 = nw_endpoint_handler_copy_endpoint(v171);
        nw_endpoint_t v168 = v15;
        logging_description = nw_endpoint_get_logging_description(v23);
        unsigned int v25 = nw_endpoint_handler_state_string(v171);
        id v26 = nw_endpoint_handler_mode_string(v171);
        uint64_t v27 = nw_endpoint_handler_copy_current_path(v171);
        *(_DWORD *)buf = 136448002;
        id v178 = "nw_endpoint_proxy_add_child_for_config";
        __int16 v179 = 2082;
        id v180 = (void *)id_string;
        nw_endpoint_t v181 = 2082;
        nw_endpoint_t v182 = v22;
        uint64_t v183 = 2082;
        uint64_t v184 = logging_description;
        id v185 = 2082;
        unsigned int v186 = v25;
        char v187 = 2082;
        v188 = v26;
        nw_endpoint_t v189 = 2114;
        nw_endpoint_t v190 = v27;
        int v191 = 1024;
        LODWORD(v192) = v164;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] invalid proxy mode %u",  buf,  0x4Eu);

        uint64_t v15 = v168;
      }
    }

    __int16 v167 = 0LL;
  }

  id v28 = nw_endpoint_handler_copy_parameters(v171);
  __int16 v29 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v28,  0,  0);

  id v30 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v29);
  options = nw_protocol_stack_copy_transport_protocol(v30);
  int v163 = v30;
  int v161 = nw_protocol_stack_copy_internet_protocol(v30);
  unsigned int v31 = nw_endpoint_handler_copy_current_path(v171);
  id v193 = 0uLL;
  id v156 = v31;
  if (nw_path_get_client_id(v31, &v193)) {
    nw_parameters_set_parent_id_inner((NWConcrete_nw_parameters *)v29, (const unsigned __int8 *)&v193, 0);
  }
  nw_parameters_set_proxy_applied((void *)v29, 1);
  nw_parameters_set_effective_proxy_config((void *)v29, v14);
  if (v166)
  {
    nw_endpoint_t v32 = v14;
    __int16 v33 = v11[38];

    if (v33 == 4)
    {
      __int16 v34 = v166;
      nw_endpoint_t v35 = (v34[171] & 0x40) == 0;

      if (!v35)
      {
        os_log_type_t v36 = (id *)(id)v29;
        id v37 = v34;
        if (v36)
        {
          objc_storeStrong(v36 + 24, obj);
LABEL_34:

          goto LABEL_35;
        }

        __nwlog_obj();
        id v131 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        id v178 = "nw_parameters_set_raced_proxy_config";
        id v132 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(iterate_block[0]) = 16;
        nw_endpoint_t v176 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v132, iterate_block, &v176))
        {
          if (LOBYTE(iterate_block[0]) == 17)
          {
            __nwlog_obj();
            nw_endpoint_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v134 = iterate_block[0];
            if (os_log_type_enabled(v133, iterate_block[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v178 = "nw_parameters_set_raced_proxy_config";
              _os_log_impl(&dword_181A5C000, v133, v134, "%{public}s called with null parameters", buf, 0xCu);
            }
          }

          else
          {
            if (v176)
            {
              v148 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              id v149 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              char v150 = iterate_block[0];
              os_log_type_t v151 = os_log_type_enabled(v149, iterate_block[0]);
              if (v148)
              {
                if (v151)
                {
                  *(_DWORD *)buf = 136446466;
                  id v178 = "nw_parameters_set_raced_proxy_config";
                  __int16 v179 = 2082;
                  id v180 = v148;
                  _os_log_impl( &dword_181A5C000,  v149,  v150,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v148);
              }

              else
              {
                if (v151)
                {
                  *(_DWORD *)buf = 136446210;
                  id v178 = "nw_parameters_set_raced_proxy_config";
                  _os_log_impl( &dword_181A5C000,  v149,  v150,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
                }
              }

              goto LABEL_206;
            }

            __nwlog_obj();
            nw_endpoint_t v133 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_t v153 = iterate_block[0];
            if (os_log_type_enabled(v133, iterate_block[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v178 = "nw_parameters_set_raced_proxy_config";
              _os_log_impl( &dword_181A5C000,  v133,  v153,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        uint64_t v81 = v63;
        int v82 = v64;
LABEL_174:
        _os_log_impl(&dword_181A5C000, v81, v82, v65, buf, 0xCu);
        goto LABEL_175;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_stream_save_outbound_message";
      id v39 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v643) = 16;
      LOBYTE(v647) = 0;
      if (__nwlog_fault(v39, &v643, &v647))
      {
        if (v643 == 17)
        {
          os_log_type_t v40 = (os_log_s *)__nwlog_obj();
          __int16 v41 = v643;
          if (!os_log_type_enabled(v40, (os_log_type_t)v643)) {
            goto LABEL_128;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_save_outbound_message";
          os_log_type_t v42 = "%{public}s did not find outbound message on frame, dropping";
LABEL_126:
          os_log_type_t v66 = v40;
          id v67 = v41;
LABEL_127:
          _os_log_impl(&dword_181A5C000, v66, v67, v42, buf, 0xCu);
          goto LABEL_128;
        }

        if (!(_BYTE)v647)
        {
          os_log_type_t v40 = (os_log_s *)__nwlog_obj();
          __int16 v41 = v643;
          if (!os_log_type_enabled(v40, (os_log_type_t)v643)) {
            goto LABEL_128;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_save_outbound_message";
          os_log_type_t v42 = "%{public}s did not find outbound message on frame, dropping, backtrace limit exceeded";
          goto LABEL_126;
        }

        BOOL v56 = (char *)__nw_create_backtrace_string();
        id v57 = (os_log_s *)__nwlog_obj();
        uint64_t v58 = v643;
        os_log_type_t v59 = os_log_type_enabled(v57, (os_log_type_t)v643);
        if (v56)
        {
          if (v59)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http1_stream_save_outbound_message";
            v638 = 2082;
            *(void *)v639 = v56;
            _os_log_impl( &dword_181A5C000,  v57,  v58,  "%{public}s did not find outbound message on frame, dropping, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v56);
          os_log_type_t v8 = &qword_18C45F000;
          goto LABEL_128;
        }

        os_log_type_t v8 = &qword_18C45F000;
        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_stream_save_outbound_message";
          os_log_type_t v42 = "%{public}s did not find outbound message on frame, dropping, no backtrace";
          os_log_type_t v66 = v57;
          id v67 = v58;
          goto LABEL_127;
        }
      }

    if (v83) {
      free(v83);
    }
    goto LABEL_257;
  }

  memset(__dst, 0, 28);
  if (address->sa_len >= 0x1Cu) {
    size_t v24 = 28LL;
  }
  else {
    size_t v24 = address->sa_len;
  }
  memcpy(__dst, address, v24);
  if (__dst[0].sa_family != 2 && __dst[0].sa_family != 30)
  {
    __nwlog_obj();
    char v88 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446466;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    *(_WORD *)&applier[12] = 1024;
    *(_DWORD *)&applier[14] = __dst[0].sa_family;
    id v89 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(buffer) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v89, &buffer, type))
    {
      if (buffer == 17)
      {
        __nwlog_obj();
        int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v91 = buffer;
        if (os_log_type_enabled(v90, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = __dst[0].sa_family;
          _os_log_impl(&dword_181A5C000, v90, v91, "%{public}s Unsupported address family %u", applier, 0x12u);
        }
      }

      else if (type[0])
      {
        uint64_t v110 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v111 = buffer;
        BOOL v112 = os_log_type_enabled(v90, (os_log_type_t)buffer);
        if (v110)
        {
          if (v112)
          {
            *(_DWORD *)applier = 136446722;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 1024;
            *(_DWORD *)&applier[14] = __dst[0].sa_family;
            *(_WORD *)&applier[18] = 2082;
            *(void *)&applier[20] = v110;
            _os_log_impl( &dword_181A5C000,  v90,  v111,  "%{public}s Unsupported address family %u, dumping backtrace:%{public}s",  applier,  0x1Cu);
          }

          free(v110);
          goto LABEL_255;
        }

        if (v112)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = __dst[0].sa_family;
          _os_log_impl( &dword_181A5C000,  v90,  v111,  "%{public}s Unsupported address family %u, no backtrace",  applier,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        int v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v139 = buffer;
        if (os_log_type_enabled(v90, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = __dst[0].sa_family;
          _os_log_impl( &dword_181A5C000,  v90,  v139,  "%{public}s Unsupported address family %u, backtrace limit exceeded",  applier,  0x12u);
        }
      }
    }

    free(backtrace_string);
    goto LABEL_227;
  }

  if (!(a11 + a9))
  {
    uint32_t v50 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446210;
    *(void *)&__str[4] = "strict_calloc";
    id v51 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v51);
    if (result) {
      goto LABEL_241;
    }
    free(v51);
  }

  os_log_type_t v16 = (char *)calloc(1uLL, a11 + a9);
  if (!v16)
  {
    int v52 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1LL;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = a11 + a9;
    int v53 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v53);
    if (result) {
      goto LABEL_241;
    }
    free(v53);
  }

  memcpy(v16, a8, a9);
  memcpy(&v16[a9], a10, a11);
  id v17 = calloc(1uLL, a11);
  if (!v17)
  {
    os_log_type_t v54 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__str = 136446722;
    *(void *)&__str[4] = "strict_calloc";
    *(_WORD *)&__str[12] = 2048;
    *(void *)&__str[14] = 1LL;
    *(_WORD *)&__str[22] = 2048;
    *(void *)&__str[24] = a11;
    size_t v55 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v55);
    if (result) {
      goto LABEL_241;
    }
    free(v55);
  }

  uint64_t v110 = 0u;
  uint64_t v111 = 0u;
  BOOL v108 = 0u;
  BOOL v109 = 0u;
  char v106 = 0u;
  int v107 = 0u;
  __int16 v104 = 0u;
  char v105 = 0u;
  char v102 = 0u;
  unsigned int v103 = 0u;
  BOOL v100 = 0u;
  unsigned int v101 = 0u;
  os_log_type_t v98 = 0u;
  BOOL v99 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x100uLL, "%s chunked response", a3);
  strlen(__str);
  nw_endpoint_t v18 = cchpke_initiator_export();
  if (v18)
  {
    id v19 = v18;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v20 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      id v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      BOOL v114 = 1024;
      LODWORD(v115) = v19;
      _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_ERROR, "%{public}s Export error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (v17) {
      free(v17);
    }
LABEL_23:
    if (!v16) {
      return (BOOL)v16;
    }
    os_log_type_t v21 = v16;
    goto LABEL_60;
  }

  id v22 = cchpke_params_sizeof_kdf_hash();
  if (!v22)
  {
    size_t v69 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    id v113 = "strict_calloc";
    int v70 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v70);
    if (result) {
      goto LABEL_241;
    }
    free(v70);
  }

  int v23 = (char *)calloc(1uLL, v22);
  if (!v23)
  {
    char v71 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    id v113 = "strict_calloc";
    BOOL v114 = 2048;
    uint64_t v115 = 1LL;
    uint64_t v116 = 2048;
    nw_endpoint_t v117 = v22;
    __int16 v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_241;
    }
    free(v72);
  }

  ccsha256_di();
  size_t v24 = cchkdf_extract();
  if (v16) {
    free(v16);
  }
  if (v17) {
    free(v17);
  }
  if (v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v25 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      id v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      BOOL v114 = 1024;
      LODWORD(v115) = v24;
      _os_log_impl(&dword_181A5C000, v25, OS_LOG_TYPE_ERROR, "%{public}s Extract error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (!v23) {
      return 0LL;
    }
    os_log_type_t v21 = v23;
    goto LABEL_60;
  }

  if (!__size)
  {
    __int16 v73 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    id v113 = "strict_calloc";
    uint64_t v74 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v74);
    if (result) {
      goto LABEL_241;
    }
    free(v74);
  }

  id v26 = (char *)calloc(1uLL, __size);
  if (!v26)
  {
    BOOL v75 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    id v113 = "strict_calloc";
    BOOL v114 = 2048;
    uint64_t v115 = 1LL;
    uint64_t v116 = 2048;
    nw_endpoint_t v117 = __size;
    __int16 v76 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v76);
    if (result) {
      goto LABEL_241;
    }
    free(v76);
  }

  uint64_t v27 = cchkdf_expand();
  if (v27)
  {
    id v28 = v27;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v29 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      id v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      BOOL v114 = 1024;
      LODWORD(v115) = v28;
      _os_log_impl(&dword_181A5C000, v29, OS_LOG_TYPE_ERROR, "%{public}s Key expand error: %d", (uint8_t *)&buf, 0x12u);
    }

    if (v23) {
      free(v23);
    }
    if (!v26) {
      return 0LL;
    }
    os_log_type_t v21 = v26;
    goto LABEL_60;
  }

  id v30 = v93;
  if (!v93)
  {
    __int16 v77 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
    buf = 136446210;
    id v113 = "strict_calloc";
    __int16 v78 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v78);
    if (result) {
      goto LABEL_241;
    }
    free(v78);
    id v30 = 0LL;
  }

  unsigned int v31 = (char *)calloc(1uLL, v30);
  if (!v31)
  {
    nw_protocol_metadata_t v79 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v79, OS_LOG_TYPE_ERROR);
    buf = 136446722;
    id v113 = "strict_calloc";
    BOOL v114 = 2048;
    uint64_t v115 = 1LL;
    uint64_t v116 = 2048;
    nw_endpoint_t v117 = v30;
    uint64_t v80 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v80);
    if (result) {
      goto LABEL_241;
    }
    free(v80);
    id v30 = v93;
    unsigned int v31 = 0LL;
  }

  nw_endpoint_t v32 = cchkdf_expand();
  if (v23) {
    free(v23);
  }
  if (v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v33 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      id v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      BOOL v114 = 1024;
      LODWORD(v115) = v32;
      __int16 v34 = "%{public}s Nonce expand error: %d";
      nw_endpoint_t v35 = (os_log_s *)v33;
      os_log_type_t v36 = 18;
LABEL_55:
      _os_log_impl(&dword_181A5C000, v35, OS_LOG_TYPE_ERROR, v34, (uint8_t *)&buf, v36);
      goto LABEL_56;
    }

    goto LABEL_56;
  }

  if (v30 <= 7)
  {
    id v37 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      id v113 = "nw_http_decrypt_chunked_oblivious_response_chunk";
      BOOL v114 = 2048;
      uint64_t v115 = v30;
      __int16 v34 = "%{public}s Bad nonce length: %zu";
      nw_endpoint_t v35 = v37;
      os_log_type_t v36 = 22;
      goto LABEL_55;
    }

LABEL_264:
          goto LABEL_265;
        }

        if ((v164 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v165 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v166 = nw_endpoint_handler_get_id_string(v294);
            __int16 v167 = nw_endpoint_handler_dry_run_string(v294);
            nw_endpoint_t v168 = nw_endpoint_handler_copy_endpoint(v294);
            __int16 v169 = nw_endpoint_get_logging_description(v168);
            dataa = nw_endpoint_handler_state_string(v294);
            v299 = nw_endpoint_handler_mode_string(v294);
            id v170 = nw_endpoint_handler_copy_current_path(v294);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_flow_prepare_output_frames";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v166;
            *(_WORD *)&_BYTE buf[22] = 2082;
            v338 = v167;
            *(_WORD *)v339 = 2082;
            *(void *)&v339[2] = v169;
            *(_WORD *)&v339[10] = 2082;
            *(void *)&v339[12] = dataa;
            *(_WORD *)&v339[20] = 2082;
            *(void *)&v339[22] = v299;
            __int16 v340 = 2114;
            id v341 = v170;
            _os_log_impl( &dword_181A5C000,  v165,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failing the write request s due to the connection being closed",  buf,  0x48u);
          }

          goto LABEL_264;
        }

          free(v112);
          goto LABEL_265;
        }

        __nwlog_obj();
        int v107 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
        BOOL v108 = (char *)_os_log_send_and_compose_impl();

        v180[0] = 16;
        handler[0] = 0;
        if (__nwlog_fault(v108, v180, handler))
        {
          if (v180[0] == 17)
          {
            __nwlog_obj();
            BOOL v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v110 = v180[0];
            if (os_log_type_enabled(v109, (os_log_type_t)v180[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              _os_log_impl(&dword_181A5C000, v109, v110, "%{public}s called with null parameters", buf, 0xCu);
            }
          }

          else if (handler[0])
          {
            nw_endpoint_t v123 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_t v124 = v180[0];
            nw_endpoint_t v125 = os_log_type_enabled(v109, (os_log_type_t)v180[0]);
            if (v123)
            {
              if (v125)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v123;
                _os_log_impl( &dword_181A5C000,  v109,  v124,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v123);
              goto LABEL_254;
            }

            if (v125)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              _os_log_impl( &dword_181A5C000,  v109,  v124,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            BOOL v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v142 = v180[0];
            if (os_log_type_enabled(v109, (os_log_type_t)v180[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
              _os_log_impl( &dword_181A5C000,  v109,  v142,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

                  if (v187) {
                    free(v187);
                  }
                  uint64_t v87 = 0;
                  if (v82 == &nw_protocol_ref_counted_handle) {
LABEL_102:
                  }
                    nw::release_if_needed<nw_protocol *>((uint64_t *)v235);
LABEL_103:
                  if (v79 == &nw_protocol_ref_counted_handle)
                  {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)v244);
                    if ((v87 & 1) == 0)
                    {
LABEL_284:

LABEL_285:
                      goto LABEL_286;
                    }
                  }

                  else if ((v87 & 1) == 0)
                  {
                    goto LABEL_284;
                  }

                  char v88 = nw_channel_set_path_flow_registration(*(void *)(a3 + 48), v56, *(void **)(a3 + 24));

                  if (!v88)
                  {
LABEL_286:
                    if ((v7[405] & 0x80000000) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      nw_endpoint_t v176 = (os_log_s *)(id)gLogObj;
                      if (os_log_type_enabled(v176, OS_LOG_TYPE_ERROR))
                      {
                        id v178 = *((void *)v7 + 41);
                        char v177 = (char *)*((void *)v7 + 42);
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_protocol_instance_bring_up_channel";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v46 + 407;
                        *(_WORD *)&_BYTE buf[22] = 2080;
                        __int16 v239 = " ";
                        v240 = 2112;
                        id v241 = v177;
                        v242 = 2112;
                        __int16 v243 = v178;
                        _os_log_impl( &dword_181A5C000,  v176,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sFailed to attach channel protocol for %@ -> %@",  buf,  0x34u);
                      }
                    }

                    nw_protocol_instance_tear_down_path_inner(v46, a3);
                    *(_OWORD *)int v191 = v250;
                    __int16 v179 = (void *)*((void *)v7 + 41);
                    *((void *)v7 + 40) = 0LL;
                    *((void *)v7 + 41) = 0LL;

                    id v180 = (void *)*((void *)v7 + 42);
                    *((void *)v7 + 42) = 0LL;

                    nw_endpoint_t v181 = (void *)*((void *)v7 + 43);
                    *((void *)v7 + 43) = 0LL;

                    goto LABEL_291;
                  }

                  *(_OWORD *)int v191 = v250;
                  id v89 = *(const char **)(a3 + 32);
                  if (v89)
                  {
                    int v90 = (void *)*((void *)v89 + 5);
                    if (v90 == &nw_protocol_ref_counted_handle)
                    {
                      __int16 v97 = *((void *)v89 + 11);
                      if (v97) {
                        *((void *)v89 + 11) = v97 + 1;
                      }
                      int v91 = -1;
                    }

                    else
                    {
                      int v91 = 0;
                    }

                    *(void *)id v244 = v89;
                    v244[8] = v91;
                    os_log_type_t v98 = (void *)*((void *)v46 - 7);
                    if (v98 == &nw_protocol_ref_counted_handle)
                    {
                      BOOL v100 = *((void *)v46 - 1);
                      if (v100) {
                        *((void *)v46 - 1) = v100 + 1;
                      }
                      BOOL v99 = -1;
                    }

                    else
                    {
                      BOOL v99 = 0;
                    }

                    *(void *)__int16 v235 = v7 - 96;
                    v236 = v99;
                    unsigned int v101 = *((void *)v89 + 3);
                    if (v101)
                    {
                      char v102 = *(void (**)(const char *, char *))(v101 + 24);
                      if (v102)
                      {
                        v102(v89, v191);
                        if (v98 != &nw_protocol_ref_counted_handle) {
                          goto LABEL_127;
                        }
                        goto LABEL_126;
                      }
                    }

                    __nwlog_obj();
                    BOOL v154 = (void *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v155 = (const char *)*((void *)v89 + 2);
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_connect";
                    if (!v155) {
                      os_log_type_t v155 = "invalid";
                    }
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v155;
                    *(_WORD *)&_BYTE buf[22] = 2048;
                    __int16 v239 = v89;
                    id v156 = (char *)_os_log_send_and_compose_impl();

                    LOBYTE(uu) = 16;
                    LOBYTE(v231) = 0;
                    if (__nwlog_fault(v156, &uu, &v231))
                    {
                      if (uu == 17)
                      {
                        __nwlog_obj();
                        id v157 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        id v158 = uu;
                        if (os_log_type_enabled(v157, (os_log_type_t)uu))
                        {
                          int v159 = (const char *)*((void *)v89 + 2);
                          if (!v159) {
                            int v159 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          *(void *)&uint8_t buf[4] = "__nw_protocol_connect";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v159;
                          *(_WORD *)&_BYTE buf[22] = 2048;
                          __int16 v239 = v89;
                          _os_log_impl( &dword_181A5C000,  v157,  v158,  "%{public}s protocol %{public}s (%p) has invalid connect callback",  buf,  0x20u);
                        }

    if (v101) {
      free(v101);
    }
    __int16 v29 = 0LL;
    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    goto LABEL_267;
  }

  objc_storeStrong((id *)v222 + 1, v25);
  objc_storeStrong((id *)v222 + 72, *(id *)(a1 + 40));
  if (!*(_DWORD *)&buf[12])
  {
    id v113 = v255;
    if (v255 == 1)
    {
      __nwlog_obj();
      unsigned int v186 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
      {
        char v187 = *(void *)(a1 + 32);
        v188 = *(void *)(a1 + 40);
        *(_DWORD *)applier = 136446978;
        *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v187;
        *(_WORD *)&applier[22] = 2114;
        *(void *)&applier[24] = v220;
        *(_WORD *)&applier[32] = 2114;
        *(void *)&applier[34] = v188;
        _os_log_impl( &dword_181A5C000,  v186,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ received operation code retry from %{public}@ on %{public}@",  applier,  0x2Au);
      }

      __int16 v29 = v220;
      nwsc_restart_outgoing_requests_waiting_for_path(*(void **)(a1 + 32), v220);
      goto LABEL_248;
    }

    if ((_BYTE)v255)
    {
      __nwlog_obj();
      BOOL v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
      {
        nw_endpoint_t v189 = *(void *)(a1 + 32);
        nw_endpoint_t v190 = *(void *)(a1 + 40);
        *(_DWORD *)applier = 136447234;
        *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v189;
        *(_WORD *)&applier[22] = 1024;
        *(_DWORD *)&applier[24] = v113;
        *(_WORD *)&applier[28] = 2114;
        *(void *)&applier[30] = v220;
        *(_WORD *)&applier[38] = 2114;
        *(void *)&applier[40] = v190;
        nw_endpoint_t v117 = "%{public}s %{public}@ received unsupported operation code %u from %{public}@ on %{public}@";
        unsigned int v118 = v114;
        BOOL v119 = OS_LOG_TYPE_ERROR;
        uint64_t v120 = 48;
        goto LABEL_246;
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v114 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v115 = *(void *)(a1 + 32);
        uint64_t v116 = *(void *)(a1 + 40);
        *(_DWORD *)applier = 136446978;
        *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v115;
        *(_WORD *)&applier[22] = 2114;
        *(void *)&applier[24] = v220;
        *(_WORD *)&applier[32] = 2114;
        *(void *)&applier[34] = v116;
        nw_endpoint_t v117 = "%{public}s %{public}@ received operation code no-op from %{public}@ on %{public}@";
        unsigned int v118 = v114;
        BOOL v119 = OS_LOG_TYPE_DEFAULT;
        uint64_t v120 = 42;
LABEL_246:
        _os_log_impl(&dword_181A5C000, v118, v119, v117, applier, v120);
      }
    }

    __int16 v29 = v220;
LABEL_248:
    new_sequence_number = nw_service_connector_get_new_sequence_number();
    nwsc_send_feedback(*(void **)(a1 + 32), *(void **)(a1 + 40), new_sequence_number, 0, 0, 0LL);
    goto LABEL_267;
  }

  if (v12 <= 0x5A)
  {
    __nwlog_obj();
    id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      id v28 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v27;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&applier[24] = v12;
      *(_WORD *)&applier[32] = 2114;
      *(void *)&applier[34] = v28;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ second read copyout insufficient start req length %zu, cancelling %{public}@",  applier,  0x2Au);
    }

    goto LABEL_30;
  }

  char v121 = (NWConcrete_nw_unique_connection_request *)v222;
  *((void *)v222 + 5_Block_object_dispose(va, 8) = bswap64(*(unint64_t *)&buf[4]);
  *((_OWORD *)v222 + 30) = *(_OWORD *)((unint64_t)buf | 0xC);
  unsigned int v122 = buf[28];
  if (v12 < (unint64_t)buf[28] + 91)
  {
    __nwlog_obj();
    nw_endpoint_t v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
    {
      nw_endpoint_t v124 = *(void *)(a1 + 32);
      nw_endpoint_t v125 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136447234;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v124;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&applier[24] = v12;
      *(_WORD *)&applier[32] = 1024;
      *(_DWORD *)&applier[34] = v122;
      *(_WORD *)&applier[38] = 2114;
      *(void *)&applier[40] = v125;
      _os_log_impl( &dword_181A5C000,  v123,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ second read copyout insufficient start req length %zu for service length %u, cancelling %{public}@",  applier,  0x30u);
    }

    __int16 v29 = v220;
    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    goto LABEL_267;
  }

  *(_OWORD *)(v222 + 24) = 0u;
  *((_DWORD *)v222 + 114) = 0;
  *(_OWORD *)(v222 + 424) = 0u;
  *(_OWORD *)(v222 + 440) = 0u;
  *(_OWORD *)(v222 + 392) = 0u;
  *(_OWORD *)(v222 + 40_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v222 + 360) = 0u;
  *(_OWORD *)(v222 + 376) = 0u;
  *(_OWORD *)(v222 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v222 + 344) = 0u;
  *(_OWORD *)(v222 + 296) = 0u;
  *(_OWORD *)(v222 + 312) = 0u;
  *(_OWORD *)(v222 + 264) = 0u;
  *(_OWORD *)(v222 + 280) = 0u;
  *(_OWORD *)(v222 + 232) = 0u;
  *(_OWORD *)(v222 + 24_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v222 + 200) = 0u;
  *(_OWORD *)(v222 + 216) = 0u;
  *(_OWORD *)(v222 + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v222 + 184) = 0u;
  *(_OWORD *)(v222 + 136) = 0u;
  *(_OWORD *)(v222 + 152) = 0u;
  *(_OWORD *)(v222 + 104) = 0u;
  *(_OWORD *)(v222 + 120) = 0u;
  *(_OWORD *)(v222 + 72) = 0u;
  *(_OWORD *)(v222 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v222 + 40) = 0u;
  *(_OWORD *)(v222 + 56) = 0u;
  memcpy(v222 + 24, &buf[29], v122);
  id v131 = *(unsigned __int16 *)(a1 + 48);
  *((_DWORD *)v222 + 142) = v131 + 2;
  id v132 = (char *)malloc(v131 + 2);
  if (v132)
  {
LABEL_177:
    v121->incomingReqBytesToVerify = v132;
    *(_WORD *)id v132 = *(_WORD *)(a1 + 50);
    nw_endpoint_t v133 = nw_dispatch_data_copyout(v9, (uint64_t)(v132 + 2), v131);
    if (v133 == *(unsigned __int16 *)(a1 + 48))
    {
      id v134 = *(_OWORD *)&buf[v122 + 29];
      uint32x4_t v135 = *(_OWORD *)((char *)&v253[1] + v122 + 5);
      id v136 = *(__int128 *)((char *)&v254 + v122 + 13);
      *(_OWORD *)&v121->signature[32] = *(_OWORD *)((char *)&v253[3] + v122 + 5);
      *(_OWORD *)&v121->signature[48] = v136;
      *(_OWORD *)v121->signature = v134;
      *(_OWORD *)&v121->signature[16] = v135;
      nw_endpoint_t v137 = (size_t)&v121->incomingReqBytesToVerify[v122];
      *(_OWORD *)(v137 + 45) = 0u;
      *(_OWORD *)(v137 + 61) = 0u;
      *(_OWORD *)(v137 + 77) = 0u;
      *(_OWORD *)(v137 + 29) = 0u;
      int v138 = v121;
      __int16 v29 = v220;
      nwsc_process_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 32), v138);
      nwsc_restart_outgoing_requests_waiting_for_path(*(void **)(a1 + 32), v220);
      goto LABEL_267;
    }

    id v193 = v133;
    __nwlog_obj();
    id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      id v194 = *(void *)(a1 + 32);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v194;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&applier[24] = v193;
      *(_WORD *)&applier[32] = 2114;
      *(void *)&applier[34] = v121;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ copyout for sig insufficient req length %zu, cancelling %{public}@",  applier,  0x2Au);
    }

      if (*((_BYTE *)v8 + 1537))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        nw_endpoint_t v130 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          id v132 = *(_DWORD *)(a3 + 176);
          id v131 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447746;
          nw_endpoint_t v153 = "nw_http2_drain_next_frame_for_stream";
          BOOL v154 = 2082;
          os_log_type_t v155 = a3 + 191;
          id v156 = 2080;
          *(void *)id v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v131;
          id v158 = 1024;
          int v159 = v132;
          int v160 = 2048;
          *(void *)int v161 = v146;
          *(_WORD *)&v161[8] = 1024;
          int v162 = v132;
          _os_log_impl( &dword_181A5C000,  v130,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> clearing output available from protocol %p for stream %d",  buf,  0x3Cu);
        }
      }

      goto LABEL_265;
    }

    if ((*(_WORD *)(a3 + 188) & 0x10) == 0)
    {
LABEL_269:
      if (*((_BYTE *)v8 + 1537))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v136 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v138 = *(_DWORD *)(a3 + 176);
          nw_endpoint_t v137 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447746;
          nw_endpoint_t v153 = "nw_http2_drain_next_frame_for_stream";
          BOOL v154 = 2082;
          os_log_type_t v155 = a3 + 191;
          id v156 = 2080;
          *(void *)id v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v137;
          id v158 = 1024;
          int v159 = v138;
          int v160 = 2048;
          *(void *)int v161 = v146;
          *(_WORD *)&v161[8] = 1024;
          int v162 = v138;
          _os_log_impl( &dword_181A5C000,  v136,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> enqueueing output available to protocol %p for stream %d",  buf,  0x3Cu);
        }
      }

      goto LABEL_270;
    }

    if ((v118 & 0x80000) == 0 && *((_BYTE *)v8 + 1537))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v142 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v144 = *(_DWORD *)(a3 + 176);
        int v143 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447234;
        nw_endpoint_t v153 = "nw_http2_drain_next_frame_for_stream";
        BOOL v154 = 2082;
        os_log_type_t v155 = a3 + 191;
        id v156 = 2080;
        *(void *)id v157 = " ";
        *(_WORD *)&v157[8] = 1024;
        *(_DWORD *)&v157[10] = v143;
        id v158 = 1024;
        int v159 = v144;
        _os_log_impl( &dword_181A5C000,  v142,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> sending deferred end stream",  buf,  0x2Cu);
      }
    }

    nw_http2_send_end_stream(a1, a3);
    nw_endpoint_t v117 = *(void *)(a3 + 16);
  }

  BOOL v119 = *(unsigned __int8 *)(a3 + 190);
  if (v117)
  {
    goto LABEL_264;
  }

  if (((v119 >> 3) & 1) == 0) {
    goto LABEL_269;
  }
LABEL_270:
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
    && *((_BYTE *)v8 + 1537))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v139 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      id v141 = *(_DWORD *)(a3 + 176);
      nw_endpoint_t v140 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447746;
      nw_endpoint_t v153 = "nw_http2_set_stream_output_available_pending";
      BOOL v154 = 2082;
      os_log_type_t v155 = a3 + 191;
      id v156 = 2080;
      *(void *)id v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v140;
      id v158 = 1024;
      int v159 = v141;
      int v160 = 1024;
      *(_DWORD *)int v161 = v141;
      *(_WORD *)&v161[4] = 1024;
      *(_DWORD *)&v161[6] = 1;
      _os_log_impl( &dword_181A5C000,  v139,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> called for stream %d, needs output available: %{BOOL}d",  buf,  0x38u);
    }
  }

  *(_WORD *)(a3 + 188) |= 0x20u;
  *(_WORD *)(a1 + 388) |= 0x800u;
  return v15;
}

LABEL_303:
    }
  }

  else if ((nw_endpoint_handler_get_logging_disabled(v291) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v206 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v206, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v207 = nw_endpoint_handler_get_id_string(v291);
      v208 = nw_endpoint_handler_dry_run_string(v291);
      nw_endpoint_t v209 = nw_endpoint_handler_copy_endpoint(v291);
      v210 = nw_endpoint_get_logging_description(v209);
      v211 = nw_endpoint_handler_state_string(v291);
      v212 = nw_endpoint_handler_mode_string(v291);
      id v213 = nw_endpoint_handler_copy_current_path(v291);
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_flow_service_writes";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v207;
      *(_WORD *)&_BYTE buf[22] = 2082;
      v338 = v208;
      *(_WORD *)v339 = 2082;
      *(void *)&v339[2] = v210;
      *(_WORD *)&v339[10] = 2082;
      *(void *)&v339[12] = v211;
      *(_WORD *)&v339[20] = 2082;
      *(void *)&v339[22] = v212;
      __int16 v340 = 2114;
      id v341 = v213;
      _os_log_impl( &dword_181A5C000,  v206,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No output handler",  buf,  0x48u);
    }

    goto LABEL_303;
  }

        if (v148) {
          free(v148);
        }
        goto LABEL_71;
      }
    }

    else
    {
      __int16 v243 = 0;
    }

    if ((*(_WORD *)(v37 + 204) & 0x4000) != 0) {
      goto LABEL_57;
    }
    id v44 = 0LL;
LABEL_79:
    unsigned int v62 = (void *)*((void *)handle + 27);
    int v63 = v44;
    if (!v62 || v41) {
      break;
    }
    if (!alloc || !v246 || v252 >= v238)
    {
      if (alloc)
      {
        alloc = (uint64_t)data1;
      }

      else
      {
        unsigned int v118 = 0LL;
        data = data1;
        if (!data1) {
          goto LABEL_221;
        }
      }

      if (dispatch_data_get_size(data))
      {
        BOOL v119 = (void *)*((void *)handle + 40);
        if (!v119 || (*((_BYTE *)v248 + 36) & 1) == 0)
        {
          unsigned int v118 = data;
          goto LABEL_221;
        }

        *((void *)handle + 40) = 0LL;

        last_error = v248->last_error;
        v248->last_error = 0LL;

        *((_BYTE *)v248 + 36) &= ~1u;
        unsigned int v118 = data;
      }

      else
      {

        unsigned int v118 = 0LL;
      }

      uint64_t handle = v251;
LABEL_221:

      if (v44) {
        nw_endpoint_t v125 = v243 != 0;
      }
      else {
        nw_endpoint_t v125 = 0;
      }
      if (!v125) {
        goto LABEL_231;
      }
      unsigned int v126 = v44;
      if (v126 == (nw_content_context *)&__block_literal_global_41831
        || v126 == (nw_content_context *)&__block_literal_global_5_41854)
      {

        goto LABEL_231;
      }

      if (v126 == (nw_content_context *)&__block_literal_global_3_41839
        || v126 == (nw_content_context *)&__block_literal_global_4)
      {
      }

      else
      {
        id v127 = (*((_BYTE *)v126 + 118) & 1) == 0;

        if (v127)
        {
LABEL_231:

          nw_endpoint_t v64 = 0;
          data = 0LL;
          data1 = (dispatch_data_s *)alloc;
          goto LABEL_232;
        }
      }

      *((_WORD *)v251 + 166) |= 0x80u;
      goto LABEL_231;
    }

    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v158 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
      {
        int v159 = nw_endpoint_handler_get_id_string(v229);
        int v160 = nw_endpoint_handler_dry_run_string(v229);
        buffera = v158;
        int v161 = nw_endpoint_handler_copy_endpoint(v229);
        int v162 = nw_endpoint_get_logging_description(v161);
        int v163 = nw_endpoint_handler_state_string(v229);
        char v164 = nw_endpoint_handler_mode_string(v229);
        v165 = nw_endpoint_handler_copy_current_path(v229);
        *(_DWORD *)buf = 136449026;
        *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v159;
        *(_WORD *)&_BYTE buf[22] = 2082;
        nw_endpoint_t v273 = (uint64_t (*)(uint64_t, uint64_t))v160;
        *(_WORD *)v274 = 2082;
        *(void *)&v274[2] = v162;
        *(_WORD *)&v274[10] = 2082;
        *(void *)&v274[12] = v163;
        v275 = 2082;
        v276 = v164;
        id v277 = 2114;
        v278 = v165;
        v279 = 2048;
        *(void *)nw_endpoint_t v280 = v37;
        *(_WORD *)&v280[8] = 2112;
        *(void *)&v280[10] = data;
        *(_WORD *)&v280[18] = 2048;
        *(void *)&v280[20] = v246;
        *(_WORD *)&v280[28] = 1024;
        *(_DWORD *)&v280[30] = v252;
        v281 = 1024;
        v282 = v238;
        _os_log_impl( &dword_181A5C000,  buffera,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping 0 length frame %p, a ggregated_data %@, next_frame %p, aggregrated_amount_read %u, aggregated_data_length %u",  buf,  0x72u);

        id v158 = buffera;
      }

      nw_endpoint_t v64 = 0;
LABEL_232:
      uint64_t handle = v251;
      id v44 = v63;
LABEL_233:
      __int16 v41 = v249;
LABEL_234:
      if (v64 < v41) {
        goto LABEL_305;
      }
    }

      if (!v186)
      {
LABEL_305:
        id v17 = 0;
        size_t v20 = 0LL;
        *(_DWORD *)(a1[7] + 644LL) = 1;
LABEL_20:
        os_log_type_t v21 = a1[7];
        id v22 = *(void (****)(void))(v21 + 544);
        if (v22 != v20)
        {
          if (v22)
          {
            (**v22)(*(void *)(v21 + 544));
            free(v22);
          }

          *(void *)(v21 + 544) = v20;
          os_log_type_t v21 = a1[7];
        }

        if ((*(_BYTE *)(v21 + 198) & 1) == 0)
        {
          if (gLogDatapath)
          {
            nw_endpoint_t v190 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
            {
              int v191 = a1[7];
              uint64_t v192 = v191 + 114;
              if (v17 > 5) {
                id v193 = "<unknown>";
              }
              else {
                id v193 = off_189BC6808[v17];
              }
              id v200 = *(unsigned int *)(v191 + 644);
              else {
                v201 = off_189BC6808[v200];
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v192;
              *(_WORD *)&_BYTE buf[22] = 2080;
              int v232 = (uint64_t)" ";
              *(_WORD *)char v233 = 2080;
              *(void *)&v233[2] = v193;
              *(_WORD *)&v233[10] = 2080;
              *(void *)&v233[12] = v201;
              _os_log_impl( &dword_181A5C000,  v190,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sfound encoding %s, alternative encoding %s",  buf,  0x34u);
            }
          }
        }

        goto LABEL_26;
      }

        if (v162) {
          free(v162);
        }
        LODWORD(v1_Block_object_dispose(va, 8) = 0;
        goto LABEL_180;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        nw_endpoint_t v190 = (os_log_s *)__nwlog_obj();
        int v191 = __len[1];
        if (os_log_type_enabled(v190, __len[1]))
        {
          *(_DWORD *)buf = 136446210;
          v364 = "nw_http1_connection_send_bytes";
          v165 = v190;
          uint64_t v166 = v191;
          __int16 v167 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_302;
        }

        goto LABEL_303;
      }

      id v178 = (char *)__nw_create_backtrace_string();
      __int16 v179 = (os_log_s *)__nwlog_obj();
      id v180 = __len[1];
      nw_endpoint_t v181 = os_log_type_enabled(v179, __len[1]);
      if (!v178)
      {
        id v9 = v348;
        if (v181)
        {
          *(_DWORD *)buf = 136446210;
          v364 = "nw_http1_connection_send_bytes";
          v165 = v179;
          uint64_t v166 = v180;
          __int16 v167 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_302;
        }

        goto LABEL_303;
      }

      if (v181)
      {
        *(_DWORD *)buf = 136446466;
        v364 = "nw_http1_connection_send_bytes";
        v365 = 2082;
        *(void *)v366 = v178;
        nw_endpoint_t v182 = v179;
        uint64_t v183 = v180;
        uint64_t v184 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_286:
        _os_log_impl(&dword_181A5C000, v182, v183, v184, buf, 0x16u);
      }

          _os_log_impl(&dword_181A5C000, v78, v79, v80, buf, 0x12u);
          goto LABEL_304;
        }

        __int16 v72 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v86 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          int v107 = "nw_socket_set_bidirectional_tcp_sockopts";
          BOOL v108 = 2080;
          *(void *)BOOL v109 = a1 + 308;
          *(_WORD *)&v109[8] = 1024;
          *(_DWORD *)&v109[10] = v72;
          _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt TCP_KEEPCNT failed %{darwin.errno}d",  buf,  0x1Cu);
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v74 = (os_log_s *)gLogObj;
        if ((_DWORD)v72 == 22)
        {
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            int v107 = "nw_socket_set_bidirectional_tcp_sockopts";
            BOOL v108 = 1024;
            *(_DWORD *)BOOL v109 = 22;
            BOOL v75 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
            goto LABEL_250;
          }

          goto LABEL_306;
        }

        *(_DWORD *)buf = 136446466;
        int v107 = "nw_socket_set_bidirectional_tcp_sockopts";
        BOOL v108 = 1024;
        *(_DWORD *)BOOL v109 = v72;
        __int16 v77 = (char *)_os_log_send_and_compose_impl();
        BOOL v100 = OS_LOG_TYPE_ERROR;
        os_log_type_t v98 = 0;
        if (v100 == OS_LOG_TYPE_FAULT)
        {
          __int16 v78 = (os_log_s *)__nwlog_obj();
          nw_protocol_metadata_t v79 = v100;
          if (!os_log_type_enabled(v78, v100)) {
            goto LABEL_304;
          }
          *(_DWORD *)buf = 136446466;
          int v107 = "nw_socket_set_bidirectional_tcp_sockopts";
          BOOL v108 = 1024;
          *(_DWORD *)BOOL v109 = v72;
          uint64_t v80 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
          goto LABEL_303;
        }

        if (!v98)
        {
          __int16 v78 = (os_log_s *)__nwlog_obj();
          nw_protocol_metadata_t v79 = v100;
          if (!os_log_type_enabled(v78, v100)) {
            goto LABEL_304;
          }
          *(_DWORD *)buf = 136446466;
          int v107 = "nw_socket_set_bidirectional_tcp_sockopts";
          BOOL v108 = 1024;
          *(_DWORD *)BOOL v109 = v72;
          uint64_t v80 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_303;
        }

        unsigned int v83 = (char *)__nw_create_backtrace_string();
        __int16 v78 = (os_log_s *)__nwlog_obj();
        nw_protocol_metadata_t v79 = v100;
        int v91 = os_log_type_enabled(v78, v100);
        if (!v83)
        {
          if (!v91) {
            goto LABEL_304;
          }
          *(_DWORD *)buf = 136446466;
          int v107 = "nw_socket_set_bidirectional_tcp_sockopts";
          BOOL v108 = 1024;
          *(_DWORD *)BOOL v109 = v72;
          uint64_t v80 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d, no backtrace";
          goto LABEL_303;
        }

        if (v91)
        {
          *(_DWORD *)buf = 136446722;
          int v107 = "nw_socket_set_bidirectional_tcp_sockopts";
          BOOL v108 = 1024;
          *(_DWORD *)BOOL v109 = v72;
          *(_WORD *)&v109[4] = 2082;
          *(void *)&v109[6] = v83;
          unsigned int v85 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d, dumping backtrace:%{public}s";
          goto LABEL_286;
        }

void sub_181B6BDF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32)
{
  _Unwind_Resume(a1);
}

void nw_protocol_default_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a3)
    {
      uint64_t v3 = *(void *)(a1 + 32);
      if (v3)
      {
        uint64_t v4 = *(void *)(v3 + 24);
        if (v4)
        {
          uint64_t v5 = *(void (**)(void))(v4 + 248);
          if (v5) {
            v5();
          }
        }
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_protocol_default_get_message_properties";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_protocol_default_get_message_properties";
      id v9 = "%{public}s called with null protocol";
      goto LABEL_20;
    }

    if (!v12)
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_protocol_default_get_message_properties";
      id v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v15 = "nw_protocol_default_get_message_properties";
        __int16 v16 = 2082;
        id v17 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_protocol_default_get_message_properties";
      id v9 = "%{public}s called with null protocol, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    }
  }

void nw_endpoint_handler_service_reads(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v28 = "nw_endpoint_handler_service_reads";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v8, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          id v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_181A5C000, v9, v20, "%{public}s called with null handler", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (!v25)
      {
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          id v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl( &dword_181A5C000,  v9,  v24,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          id v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_181A5C000, v9, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        id v28 = "nw_endpoint_handler_service_reads";
        __int16 v29 = 2082;
        id v30 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v22,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181B6C97C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_flow_service_reads( NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2, nw_flow_protocol *a3, int a4)
{
  LODWORD(v4) = a4;
  uint64_t v141 = *MEMORY[0x1895F89C0];
  unsigned int v118 = a1;
  uint64_t v115 = a2;
  if (!a3)
  {
    __nwlog_obj();
    int v84 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unsigned int v126 = "nw_flow_service_reads";
    unsigned int v85 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(type.tqh_first) = 16;
    LOBYTE(v124) = 0;
    if (__nwlog_fault(v85, &type, &v124))
    {
      if (LOBYTE(type.tqh_first) == 17)
      {
        __nwlog_obj();
        uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t tqh_first = (os_log_type_t)type.tqh_first;
        if (os_log_type_enabled(v86, (os_log_type_t)type.tqh_first))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v126 = "nw_flow_service_reads";
          _os_log_impl(&dword_181A5C000, v86, tqh_first, "%{public}s called with null flow_protocol", buf, 0xCu);
        }
      }

      else
      {
        if ((_BYTE)v124)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v90 = (os_log_type_t)type.tqh_first;
          BOOL v91 = os_log_type_enabled(v89, (os_log_type_t)type.tqh_first);
          if (backtrace_string)
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446466;
              unsigned int v126 = "nw_flow_service_reads";
              __int16 v127 = 2082;
              int v128 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s called with null flow_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
          }

          else
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446210;
              unsigned int v126 = "nw_flow_service_reads";
              _os_log_impl( &dword_181A5C000,  v89,  v90,  "%{public}s called with null flow_protocol, no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_132;
        }

        __nwlog_obj();
        uint64_t v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v100 = (os_log_type_t)type.tqh_first;
        if (os_log_type_enabled(v86, (os_log_type_t)type.tqh_first))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v126 = "nw_flow_service_reads";
          _os_log_impl( &dword_181A5C000,  v86,  v100,  "%{public}s called with null flow_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B6DADC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24)
{
  _Unwind_Resume(a1);
}

_BYTE *nw_read_request_list_report(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1) {
    return v2;
  }
  uint64_t v3 = (id *)v1;
  do
  {
    if (((_BYTE)v3[22] & 1) == 0)
    {
      if (((_BYTE)v3[22] & 0xA) != 0 || (id v5 = v3[9], v3[11] >= v5) && (v5 || v3[10] || v3[17] && !v3[10]))
      {
        if (_nw_signposts_once == -1)
        {
          if (_nw_signposts_enabled) {
            goto LABEL_9;
          }
        }

        else
        {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_51910);
          if (_nw_signposts_enabled)
          {
LABEL_9:
          }
        }

        nw_read_request_report(v3, 0LL);
      }
    }

    uint64_t v4 = (id *)v3[1];

    uint64_t v3 = v4;
  }

  while (v4);
  do
  {
    if ((v2[176] & 1) == 0) {
      break;
    }
    BOOL v6 = nw_read_request_list_remove_head(v2);

    uint64_t v2 = (_BYTE *)v6;
  }

  while (v6);
  return v2;
}

void sub_181B6DD60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_connected(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }

    if (a2)
    {
      BOOL v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 8_Block_object_dispose(va, 8) = v7 + 1;
        }
      }

      uint64_t v8 = a1[3];
      if (v8)
      {
        id v9 = *(void (**)(void *, uint64_t))(v8 + 40);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }

      __nwlog_obj();
      __int16 v18 = *(const char **)(v3 + 16);
      *(_DWORD *)buf = 136446722;
      nw_endpoint_t v42 = "__nw_protocol_connected";
      if (!v18) {
        __int16 v18 = "invalid";
      }
      __int16 v43 = 2082;
      id v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      id v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          unsigned int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            unsigned int v22 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          nw_endpoint_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          unint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
          goto LABEL_76;
        }

        if (!v39)
        {
          os_log_type_t v20 = (os_log_s *)__nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          id v37 = *(const char **)(v3 + 16);
          if (!v37) {
            id v37 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          nw_endpoint_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          unint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
          goto LABEL_76;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = (os_log_s *)__nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            int v32 = *(const char **)(v3 + 16);
            if (!v32) {
              int v32 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            nw_endpoint_t v42 = "__nw_protocol_connected";
            __int16 v43 = 2082;
            id v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            id v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_77;
        }

        if (v31)
        {
          uint64_t v38 = *(const char **)(v3 + 16);
          if (!v38) {
            uint64_t v38 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          nw_endpoint_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          unint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
        }
      }

uint64_t nw_endpoint_handler_copy_connected_path(void *a1)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v29 = "nw_endpoint_handler_copy_connected_path";
    __int16 v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v29 = "nw_endpoint_handler_copy_connected_path";
            __int16 v30 = 2082;
            BOOL v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_181A5C000, v19, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B6E990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_is_viable(void *a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v31 = "nw_endpoint_handler_is_viable";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_endpoint_handler_is_viable";
        _os_log_impl(&dword_181A5C000, v11, v23, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v31 = "nw_endpoint_handler_is_viable";
          __int16 v32 = 2082;
          int v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_41;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_endpoint_handler_is_viable";
        _os_log_impl(&dword_181A5C000, v11, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_endpoint_handler_is_viable";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181B6F01C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_https_proxy_over_tls(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[98] >> 5) & 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_https_proxy_over_tls";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_https_proxy_over_tls";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_tls(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (void *)*((void *)v1 + 19);
    uint64_t v4 = (void *)nw_protocol_boringssl_copy_definition();
    uint64_t v5 = nw_protocol_stack_includes_protocol(v3, v4);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_parameters_get_tls";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_parameters_get_tls";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_parameters_get_tls";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B6F584(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_handler *nw_endpoint_handler_copy_connected_flow_handler(void *a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v31 = "nw_endpoint_handler_copy_connected_flow_handler";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_181A5C000, v11, v23, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          __int16 v32 = 2082;
          int v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_181A5C000, v11, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl( &dword_181A5C000,  v11,  v27,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181B6FBFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_access_proxy_handler(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = (void (**)(void, void))v4;
  if (!v3)
  {
    __nwlog_obj();
    id v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_endpoint_handler_access_proxy_handler";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v26 = "nw_endpoint_handler_access_proxy_handler";
          __int16 v27 = 2082;
          char v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v10) {
          goto LABEL_9;
        }
        goto LABEL_44;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181B70120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_fillout_establishment_report_on_nw_queue(void *a1, int a2)
{
  uint64_t v113 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v76 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
    id v77 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v109) = 16;
    LOBYTE(v10_Block_object_dispose(va, 8) = 0;
    if (__nwlog_fault(v77, &v109, &v108))
    {
      if (v109 == 17)
      {
        __nwlog_obj();
        __int16 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v79 = v109;
        if (os_log_type_enabled(v78, (os_log_type_t)v109))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v78, v79, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if ((_BYTE)v108)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v81 = v109;
        BOOL v82 = os_log_type_enabled(v78, (os_log_type_t)v109);
        if (backtrace_string)
        {
          if (v82)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
            __int16 v111 = 2082;
            BOOL v112 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v78,  v81,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_116;
        }

        if (v82)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_181A5C000, v78, v81, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v87 = v109;
        if (os_log_type_enabled(v78, (os_log_type_t)v109))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl( &dword_181A5C000,  v78,  v87,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B70FB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

unint64_t nw_connection_get_event_milliseconds(void *a1, int a2, int a3, _WORD *a4, uint64_t a5)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  unint64_t v9 = a1;
  int v10 = v9;
  if (!v9)
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v31 = "nw_connection_get_event_milliseconds";
    unsigned int v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v20, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          int v31 = "nw_connection_get_event_milliseconds";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null connection", buf, 0xCu);
        }
      }

      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            int v31 = "nw_connection_get_event_milliseconds";
            __int16 v32 = 2082;
            nw_endpoint_t v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          int v31 = "nw_connection_get_event_milliseconds";
          _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          int v31 = "nw_connection_get_event_milliseconds";
          _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_endpoint_flow_copy_protocol_establishment_reports(void *a1)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    nw_endpoint_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
    id v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v71 = 0;
    if (__nwlog_fault(v41, &type, &v71))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_181A5C000, v42, v43, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v71)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v42, type);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            __int16 v74 = 2082;
            BOOL v75 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v42,  v49,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_84;
        }

        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_181A5C000, v42, v49, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v63 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl( &dword_181A5C000,  v42,  v63,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_101:
      if (v52) {
        free(v52);
      }
      uint64_t v32 = 0LL;
      goto LABEL_44;
    }

    __nwlog_obj();
    nw_endpoint_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
    __int16 v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v71 = 0;
    if (__nwlog_fault(v45, &type, &v71))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else
      {
        if (v71)
        {
          nw_endpoint_t v55 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v57 = type;
          BOOL v58 = os_log_type_enabled(v56, type);
          if (v55)
          {
            if (v58)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
              __int16 v74 = 2082;
              BOOL v75 = v55;
              _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v55);
          }

          else
          {
            if (v58)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
              _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_95;
        }

        __nwlog_obj();
        uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v64 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl( &dword_181A5C000,  v46,  v64,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v76) {
      free(v76);
    }
    goto LABEL_55;
  }

  __nwlog_obj();
  char v71 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v113 = "nw_flow_passthrough_disconnected";
  __int16 v72 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v110 = 0;
  if (__nwlog_fault(v72, &type, &v110))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v74 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_181A5C000, v73, v74, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v110)
    {
      os_log_type_t v79 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v80 = type;
      os_log_type_t v81 = os_log_type_enabled(v73, type);
      if (v79)
      {
        if (v81)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v113 = "nw_flow_passthrough_disconnected";
          nw_endpoint_t v114 = 2082;
          id_str = v79;
          _os_log_impl( &dword_181A5C000,  v73,  v80,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v79);
        goto LABEL_96;
      }

      if (v81)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_181A5C000, v73, v80, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v92 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl( &dword_181A5C000,  v73,  v92,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

        __int16 v45 = 22;
LABEL_92:
        *a4 = v45;
        return 1;
      }

      if (!v42) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v50 = "m_sum16";
      id v51 = 1024;
      *(_DWORD *)int v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      nw_endpoint_t v40 = "%{public}s off %u > mlen %u in m_sum16, no backtrace";
    }

    else
    {
      id v38 = (os_log_s *)__nwlog_obj();
      unsigned int v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446722;
      BOOL v50 = "m_sum16";
      id v51 = 1024;
      *(_DWORD *)int v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      nw_endpoint_t v40 = "%{public}s off %u > mlen %u in m_sum16, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, 0x18u);
    goto LABEL_98;
  }

      if (v31) {
        free(v31);
      }
      unint64_t v12 = 0LL;
      goto LABEL_18;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v56 = "nw_protocol_udp_finalize_output_frames";
    char v24 = (char *)_os_log_send_and_compose_impl();
    v49[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v49[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v26 = v49[0];
      if (os_log_type_enabled(v25, v49[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v56 = "nw_protocol_udp_finalize_output_frames";
        nw_endpoint_t v27 = "%{public}s called with null udp";
        goto LABEL_94;
      }

      goto LABEL_95;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v26 = v49[0];
      if (os_log_type_enabled(v25, v49[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v56 = "nw_protocol_udp_finalize_output_frames";
        nw_endpoint_t v27 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_94;
      }

      goto LABEL_95;
    }

    uint64_t v35 = (char *)__nw_create_backtrace_string();
    BOOL v25 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v26 = v49[0];
    id v38 = os_log_type_enabled(v25, v49[0]);
    if (!v35)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v56 = "nw_protocol_udp_finalize_output_frames";
        nw_endpoint_t v27 = "%{public}s called with null udp, no backtrace";
        goto LABEL_94;
      }

      goto LABEL_95;
    }

    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v56 = "nw_protocol_udp_finalize_output_frames";
      os_log_type_t v57 = 2082;
      BOOL v58 = v35;
      int v37 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_64;
    }

    goto LABEL_65;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v56 = "nw_protocol_udp_finalize_output_frames";
  char v24 = (char *)_os_log_send_and_compose_impl();
  v49[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (v49[0] != OS_LOG_TYPE_FAULT)
  {
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v25 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v26 = v49[0];
      if (os_log_type_enabled(v25, v49[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v56 = "nw_protocol_udp_finalize_output_frames";
        nw_endpoint_t v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_94;
      }

      goto LABEL_95;
    }

    uint64_t v35 = (char *)__nw_create_backtrace_string();
    BOOL v25 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v26 = v49[0];
    int v36 = os_log_type_enabled(v25, v49[0]);
    if (!v35)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v56 = "nw_protocol_udp_finalize_output_frames";
        nw_endpoint_t v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_94;
      }

      goto LABEL_95;
    }

    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v56 = "nw_protocol_udp_finalize_output_frames";
      os_log_type_t v57 = 2082;
      BOOL v58 = v35;
      int v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_64:
      _os_log_impl(&dword_181A5C000, v25, v26, v37, buf, 0x16u);
    }

      if (v14) {
        free(v14);
      }
      return 0LL;
    }

    if (!v35)
    {
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        id v38 = "__nw_protocol_get_parameters";
        uint64_t v17 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v15 = (os_log_s *)__nwlog_obj();
    char v16 = type;
    uint64_t v32 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        id v38 = "__nw_protocol_get_parameters";
        uint64_t v17 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      id v38 = "__nw_protocol_get_parameters";
      unsigned int v39 = 2082;
      nw_endpoint_t v40 = backtrace_string;
      nw_endpoint_t v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

      if (v14) {
        free(v14);
      }
      return 0LL;
    }

    if (!v35)
    {
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        id v38 = "__nw_protocol_get_remote_endpoint";
        uint64_t v17 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v15 = (os_log_s *)__nwlog_obj();
    char v16 = type;
    uint64_t v32 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        id v38 = "__nw_protocol_get_remote_endpoint";
        uint64_t v17 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_100;
      }

      goto LABEL_101;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      id v38 = "__nw_protocol_get_remote_endpoint";
      unsigned int v39 = 2082;
      nw_endpoint_t v40 = backtrace_string;
      nw_endpoint_t v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }

LABEL_102:
      if (v29) {
        free(v29);
      }
      goto LABEL_42;
    }

    if (!output_buffer[0])
    {
      __nwlog_obj();
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = v49[0];
      if (os_log_type_enabled(v30, (os_log_type_t)v49[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v52 = "nw_ws_write_header";
        _os_log_impl( &dword_181A5C000,  v30,  v47,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_101;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v38 = v49[0];
    unsigned int v39 = os_log_type_enabled(v30, (os_log_type_t)v49[0]);
    if (!backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        int v52 = "nw_ws_write_header";
        _os_log_impl(&dword_181A5C000, v30, v38, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }

      goto LABEL_101;
    }

    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      int v52 = "nw_ws_write_header";
      id v53 = 2082;
      os_log_type_t v54 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v30,  v38,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v43) {
    free(v43);
  }
LABEL_9:
}

      if (!v24)
      {
LABEL_18:

        goto LABEL_88;
      }

      free(v50);
      if (!v23) {
        goto LABEL_142;
      }
      goto LABEL_141;
    }

      if (!v48)
      {
LABEL_103:
        uint64_t v42 = 0LL;
LABEL_37:
        _Block_object_dispose(type, 8);
        if ((v78 & 1) != 0 && v77) {
          os_release(v77);
        }
        _Block_object_dispose(v79, 8);
        if (v60) {
          os_release(v60);
        }
        return v42;
      }

            free(backtrace_string);
          }
        }

                    if (!valuePtr) {
                      valuePtr = 80;
                    }
                    os_log_type_t v47 = 2001;
                  }

                  else
                  {
                    if ((*((_BYTE *)v5 + 159) & 2) != 0) {
                      BOOL v50 = 4002;
                    }
                    else {
                      BOOL v50 = 4001;
                    }
                    if ((*((_BYTE *)v5 + 159) & 1) != 0) {
                      os_log_type_t v47 = 2002;
                    }
                    else {
                      os_log_type_t v47 = v50;
                    }
                    if (!valuePtr) {
                      valuePtr = 443;
                    }
                  }

                  string_ptr = xpc_string_get_string_ptr(type);
                  host_with_numeric_port = (nw_protocol_options_t)nw_endpoint_create_host_with_numeric_port( string_ptr,  (unsigned __int16)valuePtr);
                  if (nw_proxy_copy_http_connect_definition::onceToken != -1) {
                    dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_92);
                  }
                  int v52 = (id)nw_proxy_copy_http_connect_definition::proxy_definition;
                  options = nw_proxy_create_options(v52);
                  direct = nw_proxy_config_create(host_with_numeric_port, options);

                  nw_proxy_config_set_type(direct, v47);
                  if (v47 == 4002)
                  {
                    *(_DWORD *)buf = 4;
                    os_log_type_t v54 = nw_protocol_copy_tcp_definition();
                    nw_endpoint_t v55 = nw_proxy_config_copy_protocol_stack(direct, v54, buf);

                    BOOL v56 = v5;
                    os_log_type_t v57 = nw_tls_create_options();
                    if ((*((_BYTE *)v5 + 159) & 4) != 0 && os_variant_allows_internal_security_policies())
                    {
                      xstringa = v57;
                      sec_protocol_options_set_peer_authentication_required(xstringa, 0);
                    }

                    nw_protocol_stack_append_application_protocol(v55, v57);
                  }
                }

                else
                {
                  os_log_type_t v43 = (const __CFString *)CFDictionaryGetValue(v17, @"kCFStreamPropertySOCKSVersion");
                  if (v43 && CFStringCompare(v43, @"kCFStreamSocketSOCKSVersion4", 0LL) == kCFCompareEqualTo)
                  {
                    nw_endpoint_t v44 = (nw_protocol_definition *)nw_protocol_socksv4_copy_definition();
                    host_with_numeric_port = nw_framer_create_options(v44);
                    os_log_type_t v49 = 3001;
                  }

                  else
                  {
                    if (nw_protocol_socksv5_copy_definition::onceToken[0] != -1) {
                      dispatch_once(nw_protocol_socksv5_copy_definition::onceToken, &__block_literal_global_83827);
                    }
                    if (nw_protocol_socksv5_copy_definition::definition) {
                      nw_endpoint_t v44 = (nw_protocol_definition *)os_retain((void *)nw_protocol_socksv5_copy_definition::definition);
                    }
                    else {
                      nw_endpoint_t v44 = 0LL;
                    }
                    host_with_numeric_port = nw_framer_create_options(v44);
                    os_log_type_t v49 = 3002;
                  }

                  __int16 v73 = v49;

                  BOOL v58 = CFDictionaryGetValue(v17, @"kCFStreamPropertySOCKSUser");
                  if (v58 && (id v59 = CFGetTypeID(v58), v59 == CFStringGetTypeID())) {
                    xstring = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
                  }
                  else {
                    xstring = 0LL;
                  }
                  __int16 v60 = CFDictionaryGetValue(v17, @"kCFStreamPropertySOCKSPassword");
                  if (v60 && (os_log_type_t v61 = CFGetTypeID(v60), v61 == CFStringGetTypeID())) {
                    BOOL v62 = (void *)_CFXPCCreateXPCObjectFromCFObject();
                  }
                  else {
                    BOOL v62 = 0LL;
                  }
                  os_log_type_t v63 = xpc_string_get_string_ptr(type);
                  os_log_type_t v64 = nw_endpoint_create_host_with_numeric_port(v63, (unsigned __int16)valuePtr);
                  direct = nw_proxy_config_create((void *)v64, host_with_numeric_port);
                  nw_proxy_config_set_type(direct, v73);
                  if (xstring)
                  {
                    os_log_type_t v65 = xpc_string_get_string_ptr(xstring);
                    if (v62) {
                      uint64_t v66 = xpc_string_get_string_ptr(v62);
                    }
                    else {
                      uint64_t v66 = 0LL;
                    }
                    nw_proxy_config_set_username_and_password((nw_proxy_config_t)direct, v65, v66);
                  }
                }

  [MEMORY[0x189607968] numberWithBool:self->_useAWDL];
  id v68 = (void *)objc_claimAutoreleasedReturnValue();
  [v4 setObject:v68 forKey:@"useAWDL"];

  has = (__int16)self->_has;
  if ((has & 0x4000) == 0)
  {
LABEL_22:
    if ((has & 0x1000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_103;
  }

              free(v44);
              goto LABEL_102;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v36 = (id)gLogObj;
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            int v37 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v80[0]) = 0;
            if (__nwlog_fault(v37, type, v80))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v38 = (os_log_s *)(id)gLogObj;
                unsigned int v39 = type[0];
                if (os_log_type_enabled(v38, type[0]))
                {
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  _os_log_impl(&dword_181A5C000, v38, v39, "%{public}s CFURLCopyHostName failed", applier, 0xCu);
                }
              }

              else if (LOBYTE(v80[0]))
              {
                os_log_type_t v47 = __nw_create_backtrace_string();
                if (v47)
                {
                  id v48 = (char *)v47;
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v49 = (os_log_s *)(id)gLogObj;
                  BOOL v50 = type[0];
                  if (os_log_type_enabled(v49, type[0]))
                  {
                    *(_DWORD *)applier = 136446466;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    *(_WORD *)&applier[12] = 2082;
                    *(void *)&applier[14] = v48;
                    _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s CFURLCopyHostName failed, dumping backtrace:%{public}s",  applier,  0x16u);
                  }

                  free(v48);
                  if (!v37) {
                    goto LABEL_87;
                  }
                  goto LABEL_86;
                }

                __nwlog_obj();
                id v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v57 = type[0];
                if (os_log_type_enabled(v38, type[0]))
                {
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  _os_log_impl( &dword_181A5C000,  v38,  v57,  "%{public}s CFURLCopyHostName failed, no backtrace",  applier,  0xCu);
                }
              }

              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v38 = (os_log_s *)(id)gLogObj;
                BOOL v56 = type[0];
                if (os_log_type_enabled(v38, type[0]))
                {
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  _os_log_impl( &dword_181A5C000,  v38,  v56,  "%{public}s CFURLCopyHostName failed, backtrace limit exceeded",  applier,  0xCu);
                }
              }
            }

            if (!v37)
            {
LABEL_87:
              CFRelease(Request);
              CFRelease(v8);
              goto LABEL_88;
            }

  __break(1u);
  return result;
}

  if (v19) {
LABEL_102:
  }
    free(v19);
}

  if (v19) {
LABEL_102:
  }
    free(v19);
}

  if (v19) {
LABEL_102:
  }
    free(v19);
}

  if (v19) {
LABEL_102:
  }
    free(v19);
}

        __nwlog_obj();
        BOOL v58 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446722;
        os_log_type_t v91 = "nw_service_connector_verify_read_succeeded";
        int v92 = 2082;
        id v93 = a8;
        size_t v94 = 1024;
        *(_DWORD *)nw_endpoint_t v95 = v21;
        id v59 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v88 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v61 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v91 = "nw_service_connector_verify_read_succeeded";
            int v92 = 2082;
            id v93 = a8;
            size_t v94 = 1024;
            *(_DWORD *)nw_endpoint_t v95 = v21;
            _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d",  buf,  0x1Cu);
          }
        }

        else if (v88)
        {
          id v67 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v86 = type;
          id v68 = os_log_type_enabled(v60, type);
          if (v67)
          {
            if (v68)
            {
              *(_DWORD *)buf = 136446978;
              os_log_type_t v91 = "nw_service_connector_verify_read_succeeded";
              int v92 = 2082;
              id v93 = a8;
              size_t v94 = 1024;
              *(_DWORD *)nw_endpoint_t v95 = v21;
              *(_WORD *)&v95[4] = 2082;
              *(void *)&v95[6] = v67;
              _os_log_impl( &dword_181A5C000,  v60,  v86,  "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
            }

            free(v67);
LABEL_143:
            if (v59) {
              free(v59);
            }
LABEL_88:
            if (v21 != 89) {
              nw_connection_cancel(v16);
            }
            goto LABEL_91;
          }

          if (v68)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v91 = "nw_service_connector_verify_read_succeeded";
            int v92 = 2082;
            id v93 = a8;
            size_t v94 = 1024;
            *(_DWORD *)nw_endpoint_t v95 = v21;
            _os_log_impl( &dword_181A5C000,  v60,  v86,  "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
          }
        }

        else
        {
          __nwlog_obj();
          __int16 v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v71 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v91 = "nw_service_connector_verify_read_succeeded";
            int v92 = 2082;
            id v93 = a8;
            size_t v94 = 1024;
            *(_DWORD *)nw_endpoint_t v95 = v21;
            _os_log_impl( &dword_181A5C000,  v60,  v71,  "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
          }
        }

        goto LABEL_143;
    }
  }

  char v20 = v17;
  os_log_type_t v21 = v20[3];

  if (!data) {
    goto LABEL_11;
  }
LABEL_27:
  if (v21)
  {
    if (a3) {
      goto LABEL_29;
    }
    goto LABEL_73;
  }

  if (data) {
    size_t size = dispatch_data_get_size(data);
  }
  else {
    size_t size = 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v41 = (os_log_s *)(id)gLogObj;
  uint64_t v42 = v41;
  if (size != a4)
  {
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      __int16 v45 = "outgoing";
      *(_DWORD *)buf = 136447746;
      os_log_type_t v91 = "nw_service_connector_verify_read_succeeded";
      int v92 = 2114;
      id v93 = v15;
      if (a3) {
        __int16 v45 = "incoming";
      }
      size_t v94 = 2082;
      *(void *)nw_endpoint_t v95 = a8;
      *(_WORD *)&v95[8] = 1024;
      *(_DWORD *)&v95[10] = size;
      *(_WORD *)&v95[14] = 1024;
      *(_DWORD *)&v95[16] = a4;
      *(_WORD *)&v95[20] = 2082;
      *(void *)&v95[22] = v45;
      *(_WORD *)&v95[30] = 2114;
      *(void *)&v95[32] = v16;
      _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received %{public}s read with length %u but expected %u on %{public}s %{public}@",  buf,  0x40u);
    }

    goto LABEL_72;
  }

  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    os_log_type_t v43 = "outgoing";
    *(_DWORD *)buf = 136447490;
    os_log_type_t v91 = "nw_service_connector_verify_read_succeeded";
    int v92 = 2114;
    id v93 = v15;
    if (a3) {
      os_log_type_t v43 = "incoming";
    }
    size_t v94 = 2082;
    *(void *)nw_endpoint_t v95 = a8;
    *(_WORD *)&v95[8] = 1024;
    *(_DWORD *)&v95[10] = a4;
    *(_WORD *)&v95[14] = 2082;
    *(void *)&v95[16] = v43;
    *(_WORD *)&v95[24] = 2114;
    *(void *)&v95[26] = v16;
    _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ received %{public}s read with length %u on %{public}s %{public}@",  buf,  0x3Au);
  }

  nw_endpoint_t v44 = 1LL;
LABEL_93:

  return v44;
}

    free(v15);
    goto LABEL_102;
  }

  *((_BYTE *)v11 + 616) |= 1u;
  id v269 = 0u;
  memset(v270, 0, 28);
  v267 = 0u;
  v268 = 0u;
  nw_endpoint_t v265 = 0u;
  v266 = 0u;
  v263 = 0u;
  v264 = 0u;
  os_log_type_t v261 = 0u;
  BOOL v262 = 0u;
  os_log_type_t v259 = 0u;
  v260 = 0u;
  v257 = 0u;
  v258 = 0u;
  v255 = 0u;
  v256 = 0u;
  id v254 = 0u;
  memset(v253, 0, sizeof(v253));
  memset(buf, 0, sizeof(buf));
  *(void *)&__dst[0].sa_len = 0LL;
  *(void *)&__dst[0].sa_data[6] = __dst;
  *(void *)&__dst[1].sa_len = 0x2000000000LL;
  *(void *)&__dst[1].sa_data[6] = 0LL;
  *(void *)&buffer = 0LL;
  *((void *)&buffer + 1) = &buffer;
  *(void *)&nw_endpoint_t v250 = 0x2000000000LL;
  *((void *)&v250 + 1) = &buf[2];
  if (v9)
  {
    *(void *)applier = MEMORY[0x1895F87A8];
    *(void *)&applier[8] = 0x40000000LL;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    *(void *)&applier[24] = &unk_189BBF598;
    *(void *)&applier[40] = &buffer;
    *(void *)&applier[48] = 346LL;
    *(void *)&applier[32] = __dst;
    dispatch_data_apply(v9, applier);
    unint64_t v12 = *(void *)(*(void *)&__dst[0].sa_data[6] + 24LL);
  }

  else
  {
    unint64_t v12 = 0LL;
  }

  _Block_object_dispose(&buffer, 8);
  _Block_object_dispose(__dst, 8);
  if (v12 <= 0x4E)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v19 = *(void *)(a1 + 32);
      char v20 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v19;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&applier[24] = v12;
      *(_WORD *)&applier[32] = 2114;
      *(void *)&applier[34] = v20;
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ second read copyout insufficient req length %zu, cancelling %{public}@",  applier,  0x2Au);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    goto LABEL_269;
  }

  os_log_type_t v21 = *(_WORD *)&buf[2];
  os_log_type_t v22 = nw_connection_copy_endpoint(*(nw_connection_t *)(a1 + 40));
  if (nw_endpoint_get_type(v22) != nw_endpoint_type_address)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v52 = (id)gLogObj;
    id v53 = *(void *)(a1 + 32);
    os_log_type_t v54 = nw_endpoint_get_type(v22);
    nw_endpoint_t v55 = *(void *)(a1 + 40);
    *(_DWORD *)applier = 136447234;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    *(_WORD *)&applier[12] = 2114;
    *(void *)&applier[14] = v53;
    *(_WORD *)&applier[22] = 2114;
    *(void *)&applier[24] = v22;
    *(_WORD *)&applier[32] = 1024;
    *(_DWORD *)&applier[34] = v54;
    *(_WORD *)&applier[38] = 2114;
    *(void *)&applier[40] = v55;
    BOOL v56 = (char *)_os_log_send_and_compose_impl();

    __dst[0].sa_len = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v56, __dst, &buffer))
    {
      if (__dst[0].sa_len == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v57 = (os_log_s *)(id)gLogObj;
        sa_len = __dst[0].sa_len;
        if (os_log_type_enabled(v57, (os_log_type_t)__dst[0].sa_len))
        {
          id v59 = *(void *)(a1 + 32);
          __int16 v60 = nw_endpoint_get_type(v22);
          os_log_type_t v61 = *(void *)(a1 + 40);
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v59;
          *(_WORD *)&applier[22] = 2114;
          *(void *)&applier[24] = v22;
          *(_WORD *)&applier[32] = 1024;
          *(_DWORD *)&applier[34] = v60;
          *(_WORD *)&applier[38] = 2114;
          *(void *)&applier[40] = v61;
          _os_log_impl( &dword_181A5C000,  v57,  sa_len,  "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@",  applier,  0x30u);
        }
      }

      else if ((_BYTE)buffer)
      {
        char v71 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v72 = __dst[0].sa_len;
        __int16 v73 = os_log_type_enabled(v57, (os_log_type_t)__dst[0].sa_len);
        if (v71)
        {
          if (v73)
          {
            __int16 v74 = *(void *)(a1 + 32);
            BOOL v75 = nw_endpoint_get_type(v22);
            __int16 v76 = *(void *)(a1 + 40);
            *(_DWORD *)applier = 136447490;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v74;
            *(_WORD *)&applier[22] = 2114;
            *(void *)&applier[24] = v22;
            *(_WORD *)&applier[32] = 1024;
            *(_DWORD *)&applier[34] = v75;
            *(_WORD *)&applier[38] = 2114;
            *(void *)&applier[40] = v76;
            *(_WORD *)&applier[48] = 2082;
            *(void *)&applier[50] = v71;
            _os_log_impl( &dword_181A5C000,  v57,  v72,  "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@, dumping backtrace:%{public}s",  applier,  0x3Au);
          }

          free(v71);
          goto LABEL_138;
        }

        if (v73)
        {
          __int16 v107 = *(void *)(a1 + 32);
          __int16 v108 = nw_endpoint_get_type(v22);
          __int16 v109 = *(void *)(a1 + 40);
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v107;
          *(_WORD *)&applier[22] = 2114;
          *(void *)&applier[24] = v22;
          *(_WORD *)&applier[32] = 1024;
          *(_DWORD *)&applier[34] = v108;
          *(_WORD *)&applier[38] = 2114;
          *(void *)&applier[40] = v109;
          _os_log_impl( &dword_181A5C000,  v57,  v72,  "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@, no backtrace",  applier,  0x30u);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v92 = __dst[0].sa_len;
        if (os_log_type_enabled(v57, (os_log_type_t)__dst[0].sa_len))
        {
          id v93 = *(void *)(a1 + 32);
          size_t v94 = nw_endpoint_get_type(v22);
          nw_endpoint_t v95 = *(void *)(a1 + 40);
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v93;
          *(_WORD *)&applier[22] = 2114;
          *(void *)&applier[24] = v22;
          *(_WORD *)&applier[32] = 1024;
          *(_DWORD *)&applier[34] = v94;
          *(_WORD *)&applier[38] = 2114;
          *(void *)&applier[40] = v95;
          _os_log_impl( &dword_181A5C000,  v57,  v92,  "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@, backtrace limit exceeded",  applier,  0x30u);
        }
      }
    }

    if (v42) {
      free(v42);
    }
    int v7 = 0LL;
    goto LABEL_21;
  }

  __nwlog_obj();
  int v37 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v58 = "nw_browser_create";
  id v38 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v56.receiver) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v38, &v56, &type))
  {
    if (LOBYTE(v56.receiver) == 17)
    {
      __nwlog_obj();
      unsigned int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)v56.receiver;
      if (os_log_type_enabled(v39, (os_log_type_t)v56.receiver))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_browser_create";
        _os_log_impl(&dword_181A5C000, v39, receiver, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }

    else if (type)
    {
      __int16 v45 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v46 = (os_log_type_t)v56.receiver;
      os_log_type_t v47 = os_log_type_enabled(v39, (os_log_type_t)v56.receiver);
      if (v45)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v58 = "nw_browser_create";
          id v59 = 2082;
          *(void *)__int16 v60 = v45;
          _os_log_impl( &dword_181A5C000,  v39,  v46,  "%{public}s called with null descriptor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v45);
        goto LABEL_95;
      }

      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_browser_create";
        _os_log_impl(&dword_181A5C000, v39, v46, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unsigned int v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v51 = (os_log_type_t)v56.receiver;
      if (os_log_type_enabled(v39, (os_log_type_t)v56.receiver))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_browser_create";
        _os_log_impl( &dword_181A5C000,  v39,  v51,  "%{public}s called with null descriptor, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      if (v26)
      {
        BOOL v50 = (char *)v26;
        goto LABEL_95;
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
    int v10 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      char v16 = "%{public}s called with null http3_stream";
      goto LABEL_81;
    }

    if (!v52)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      char v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_81;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    uint64_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    char v24 = os_log_type_enabled(v18, type);
    if (!v21)
    {
      if (!v24) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      char v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_81;
    }

    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      BOOL v56 = 2082;
      os_log_type_t v57 = (nw_protocol_identifier *)v21;
      char v23 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
    int v10 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      char v16 = "%{public}s called with null protocol";
LABEL_81:
      uint64_t v42 = v18;
      os_log_type_t v43 = v19;
      nw_endpoint_t v44 = 12;
LABEL_92:
      _os_log_impl(&dword_181A5C000, v42, v43, v16, buf, v44);
      goto LABEL_93;
    }

    if (!v52)
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_81;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    uint64_t v18 = (os_log_s *)__nwlog_obj();
    os_log_type_t v19 = type;
    os_log_type_t v22 = os_log_type_enabled(v18, type);
    if (!v21)
    {
      if (!v22) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      char v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_81;
    }

    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      nw_endpoint_t v55 = "nw_protocol_http3_uni_stream_input_finished";
      BOOL v56 = 2082;
      os_log_type_t v57 = (nw_protocol_identifier *)v21;
      char v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_42:
      _os_log_impl(&dword_181A5C000, v18, v19, v23, buf, 0x16u);
    }
  }

  free(v21);
  if (v10)
  {
LABEL_94:
    BOOL v50 = (char *)v10;
LABEL_95:
    free(v50);
  }

    if (v42) {
      free(v42);
    }
    goto LABEL_6;
  }

  if (v1->policy_result.routing_result == 4) {
    tunnel_interface_index = v1->policy_result.routing_result_parameter.tunnel_interface_index;
  }
  else {
    tunnel_interface_index = 0;
  }
  flow_divert_aggregate_unit = v1->policy_result.flow_divert_aggregate_unit;
  if (tunnel_interface_index | flow_divert_aggregate_unit)
  {
    unsigned int v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
    if (v6)
    {
      endpoint = v2->endpoint;
      id v8 = endpoint;
      unint64_t v9 = -[OS_nw_endpoint type](v8, "type");

      if (v9 != 2)
      {
        if (v9 == 1)
        {
          mach_vm_address_t address = nw_endpoint_get_address(v2->endpoint);
          if (address)
          {
            xpc_dictionary_set_data(v6, "flow-host-address", address, address->sa_len);
LABEL_69:
            parent_endpoint_domain = nw_endpoint_get_parent_endpoint_domain((uint64_t)v2->endpoint);
            goto LABEL_76;
          }

          __nwlog_obj();
          char v20 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          id v53 = "nw_path_copy_flow_divert_token";
          os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          os_log_type_t v49 = 0;
          if (__nwlog_fault(v21, &type, &v49))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              char v23 = type;
              if (os_log_type_enabled(v22, type))
              {
                *(_DWORD *)buf = 136446210;
                id v53 = "nw_path_copy_flow_divert_token";
                _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s nw_endpoint_get_address failed", buf, 0xCu);
              }
            }

            else if (v49)
            {
              char v28 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v29 = type;
              uint64_t v30 = os_log_type_enabled(v22, type);
              if (v28)
              {
                if (v30)
                {
                  *(_DWORD *)buf = 136446466;
                  id v53 = "nw_path_copy_flow_divert_token";
                  os_log_type_t v54 = 2082;
                  nw_endpoint_t v55 = v28;
                  _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s nw_endpoint_get_address failed, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v28);
                goto LABEL_67;
              }

              if (v30)
              {
                *(_DWORD *)buf = 136446210;
                id v53 = "nw_path_copy_flow_divert_token";
                _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s nw_endpoint_get_address failed, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              uint64_t v34 = type;
              if (os_log_type_enabled(v22, type))
              {
                *(_DWORD *)buf = 136446210;
                id v53 = "nw_path_copy_flow_divert_token";
                _os_log_impl( &dword_181A5C000,  v22,  v34,  "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v73 = (id)gLogObj;
  if (mode > 5) {
    __int16 v74 = "unknown-mode";
  }
  else {
    __int16 v74 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
  id v93 = 2082;
  id_str = (void *)v74;
  nw_endpoint_t v95 = 2082;
  char v96 = "flow";
  BOOL v75 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v89) = 0;
  if (!__nwlog_fault((const char *)v75, type, &v89))
  {
LABEL_120:
    if (!v75) {
      goto LABEL_122;
    }
LABEL_121:
    free(v75);
    goto LABEL_122;
  }

  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v76 = (os_log_s *)(id)gLogObj;
    id v77 = type[0];
    if (os_log_type_enabled(v76, type[0]))
    {
      if (mode > 5) {
        __int16 v78 = "unknown-mode";
      }
      else {
        __int16 v78 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
      id v93 = 2082;
      id_str = (void *)v78;
      nw_endpoint_t v95 = 2082;
      char v96 = "flow";
      _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v73 = (id)gLogObj;
  if (mode > 5) {
    __int16 v74 = "unknown-mode";
  }
  else {
    __int16 v74 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
  id v93 = 2082;
  id_str = (void *)v74;
  nw_endpoint_t v95 = 2082;
  char v96 = "flow";
  BOOL v75 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v89) = 0;
  if (!__nwlog_fault((const char *)v75, type, &v89))
  {
LABEL_120:
    if (!v75) {
      goto LABEL_122;
    }
LABEL_121:
    free(v75);
    goto LABEL_122;
  }

  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v76 = (os_log_s *)(id)gLogObj;
    id v77 = type[0];
    if (os_log_type_enabled(v76, type[0]))
    {
      if (mode > 5) {
        __int16 v78 = "unknown-mode";
      }
      else {
        __int16 v78 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
      id v93 = 2082;
      id_str = (void *)v78;
      nw_endpoint_t v95 = 2082;
      char v96 = "flow";
      _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

            uint64_t v86 = nw_protocol_boringssl_identifier();
            if (v86)
            {
              os_log_type_t v87 = nw_endpoint_handler_copy_endpoint(v45);
              uint64_t internal = nw_protocol_create_internal(v86, v87, (const char *)v344, 1);

              if (internal)
              {
                nw_endpoint_handler_set_protocol_instance(v45, v341, v340, internal);
                if (internal != v49)
                {
                  os_log_type_t v89 = *(void **)(internal + 24);
                  if (v89 && *v89)
                  {
                    if ((nw_protocol_add_input_handler(internal, v49) & 1) != 0)
                    {
                      if (output_handler->handle == &nw_protocol_ref_counted_handle)
                      {
                        callbacks = output_handler[1].callbacks;
                        if (callbacks) {
                          output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler
                        }
                                                                                + 1);
                        *(void *)os_log_type_t type = output_handler;
                        BOOL v90 = v353 | 1;
                      }

                      else
                      {
                        *(void *)os_log_type_t type = output_handler;
                        BOOL v90 = v353 & 0xFE;
                      }

                      v353 = v90;
                      if (*(_UNKNOWN **)(v49 + 40) == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v120 = *(void *)(v49 + 88);
                        if (v120) {
                          *(void *)(v49 + 8_Block_object_dispose(va, 8) = v120 + 1;
                        }
                        v350 = v49;
                        BOOL v119 = v351 | 1;
                      }

                      else
                      {
                        v350 = v49;
                        BOOL v119 = v351 & 0xFE;
                      }

                      v351 = v119;
                      if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
                      {
                        unsigned int v122 = *(void *)(internal + 88);
                        if (v122) {
                          *(void *)(internal + 8_Block_object_dispose(va, 8) = v122 + 1;
                        }
                        *(void *)v347 = internal;
                        char v121 = v348 | 1;
                      }

                      else
                      {
                        *(void *)v347 = internal;
                        char v121 = v348 & 0xFE;
                      }

                      v348 = v121;
                      char v123 = output_handler->callbacks;
                      if (v123)
                      {
                        replace_input_handler = (uint64_t (*)(nw_protocol *, uint64_t, uint64_t))v123->replace_input_handler;
                        if (replace_input_handler)
                        {
                          nw_endpoint_t v125 = replace_input_handler(output_handler, v49, internal);
                          if ((v348 & 1) == 0) {
                            goto LABEL_158;
                          }
                          goto LABEL_157;
                        }
                      }

                      __nwlog_obj();
                      v286 = (void *)objc_claimAutoreleasedReturnValue();
                      name = output_handler->identifier->name;
                      *(_DWORD *)buf = 136446722;
                      v355 = "__nw_protocol_replace_input_handler";
                      if (!name) {
                        name = "invalid";
                      }
                      v356 = 2082;
                      v357 = (char *)name;
                      v358 = 2048;
                      v359 = (const char *)output_handler;
                      os_log_t log = (char *)_os_log_send_and_compose_impl();

                      v349 = OS_LOG_TYPE_ERROR;
                      uint64_t v346 = 0;
                      if (__nwlog_fault(log, &v349, &v346))
                      {
                        if (v349 == OS_LOG_TYPE_FAULT)
                        {
                          __nwlog_obj();
                          v288 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                          v289 = v349;
                          if (os_log_type_enabled(v288, v349))
                          {
                            v290 = output_handler->identifier->name;
                            if (!v290) {
                              v290 = "invalid";
                            }
                            *(_DWORD *)buf = 136446722;
                            v355 = "__nw_protocol_replace_input_handler";
                            v356 = 2082;
                            v357 = (char *)v290;
                            v358 = 2048;
                            v359 = (const char *)output_handler;
                            _os_log_impl( &dword_181A5C000,  v288,  v289,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback",  buf,  0x20u);
                          }

          if (v66) {
            free(v66);
          }
          os_log_type_t v63 = (dispatch_object_s *)*((void *)v305 + 3);
          uint64_t v15 = MEMORY[0x1895F87A8];
          if (v63)
          {
LABEL_104:
            dispatch_release(v63);
            *((void *)v305 + 3) = 0LL;
          }

        if (!*((void *)handle + 18))
        {
          if ((v28 & 0x8000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v51 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
            {
              int v52 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446978;
              __int16 v76 = "nw_protocol_http2_process_connected";
              id v77 = 2082;
              __int16 v78 = handle + 390;
              os_log_type_t v79 = 2080;
              __int16 v80 = " ";
              os_log_type_t v81 = 1024;
              __int16 v82 = v52;
              _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> no listen handler on server, deferring processing of input and connected st ate until listen handler is present",  buf,  0x26u);
            }
          }

          *((_WORD *)handle + 194) |= 0x1000u;
          return 1LL;
        }

        if ((v28 & 0x8000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v29 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v65 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            __int16 v76 = "nw_protocol_http2_process_connected";
            id v77 = 2082;
            __int16 v78 = handle + 390;
            os_log_type_t v79 = 2080;
            __int16 v80 = " ";
            os_log_type_t v81 = 1024;
            __int16 v82 = v65;
            int v31 = "%{public}s %{public}s%s<i%u> listen handler present, processing input without waiting";
            goto LABEL_159;
          }
        }

    if (!a14)
    {
LABEL_88:
      if (a15) {
        goto LABEL_89;
      }
      goto LABEL_103;
    }

    if (!v4) {
      goto LABEL_20;
    }
    goto LABEL_29;
  }

  return 1LL;
}

  if (v52) {
    free(v52);
  }
  os_log_type_t v21 = 0LL;
LABEL_71:

  return v21;
}

void sub_181B72158( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_establishment_report *nw_protocol_establishment_report_create( void *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v6 = a1;
  if (v6)
  {
    int v7 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_establishment_report);
    id v8 = v7;
    if (v7)
    {
      objc_storeStrong((id *)&v7->protocol, a1);
      v8->handshake_milliseconds = a2;
      v8->handshake_rtt_milliseconds = a3;
      unint64_t v9 = v8;
LABEL_4:

      goto LABEL_5;
    }

    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_protocol_establishment_report_create";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v16, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_protocol_establishment_report_create";
          _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null report", buf, 0xCu);
        }
      }

      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v30 = "nw_protocol_establishment_report_create";
            __int16 v31 = 2082;
            uint64_t v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v17,  v23,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }

        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_protocol_establishment_report_create";
          _os_log_impl(&dword_181A5C000, v17, v23, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v30 = "nw_protocol_establishment_report_create";
          _os_log_impl( &dword_181A5C000,  v17,  v26,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B72688(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_establishment_report_set_client_accurate_ecn_state(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 6) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_protocol_establishment_report_set_server_accurate_ecn_state(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 7) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null report, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null report, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_endpoint_handler_get_resolved_endpoint_count(void *a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v27 = "nw_endpoint_handler_get_mode";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v27 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            char v27 = "nw_endpoint_handler_get_mode";
            __int16 v28 = 2082;
            uint64_t v29 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          char v27 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v27 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B73634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_resolution_source(void *a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_endpoint_handler_get_mode";
    unint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          int v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            int v36 = "nw_endpoint_handler_get_mode";
            __int16 v37 = 2082;
            id v38 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          int v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          int v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B73DB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_resolution_protocol(void *a1)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v36 = "nw_endpoint_handler_get_mode";
    unint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          int v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            int v36 = "nw_endpoint_handler_get_mode";
            __int16 v37 = 2082;
            id v38 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          int v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          int v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B7451C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_handler_copy_preferred_resolved_endpoint(void *a1)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_endpoint_handler_get_mode";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v10, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v29 = "nw_endpoint_handler_get_mode";
            __int16 v30 = 2082;
            os_log_type_t v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B74A78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_resolved_endpoints(void *a1)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_endpoint_handler_get_mode";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v10, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v31 = "nw_endpoint_handler_get_mode";
            __int16 v32 = 2082;
            char v33 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v31 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B75018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_copy_resolved_endpoints_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  nw_endpoint_t v4 = nw_endpoint_handler_copy_endpoint(a3);
  nw_array_append(*(void *)(a1 + 32), v4);

  return 1LL;
}

void nw_endpoint_handler_get_svcb_report(void *a1, BOOL *a2, BOOL *a3, BOOL *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  id v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_endpoint_handler_get_mode";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v30 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v30 = "nw_endpoint_handler_get_mode";
            __int16 v31 = 2082;
            __int16 v32 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v30 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v30 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B7558C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_get_svcb_report(void *a1, BOOL *a2, BOOL *a3, BOOL *a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = v7;
  if (v7)
  {
    if (a2) {
      *a2 = (*((_BYTE *)v7 + 347) & 2) != 0;
    }
    if (a3) {
      *a3 = (*((_BYTE *)v7 + 347) & 4) != 0;
    }
    if (a4) {
      *a4 = (*((_BYTE *)v7 + 347) & 8) != 0;
    }
    goto LABEL_8;
  }

  __nwlog_obj();
  unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v20 = "nw_resolver_get_svcb_report";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_resolver_get_svcb_report";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v20 = "nw_resolver_get_svcb_report";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_resolver_get_svcb_report";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_resolver_get_svcb_report";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_handler_get_extended_dns_error(void *a1, _WORD *a2, char **a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  BOOL v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_endpoint_handler_get_mode";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v14, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "nw_endpoint_handler_get_mode";
            __int16 v43 = 2082;
            nw_endpoint_t v44 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v15,  v29,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B76068(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_array_prepend(uint64_t a1, void *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  nw_endpoint_t v4 = a2;
  if (a1 && a2)
  {
    if (atomic_load((unsigned __int8 *)(a1 + 40)))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      int v5 = 136446210;
      BOOL v6 = "nw_array_prepend";
      id v3 = (void *)_os_log_send_and_compose_impl();
      else {
        free(v3);
      }
    }

    else
    {
      std::vector<nw_object_wrapper_t>::emplace<nw_object *&>((unint64_t *)(a1 + 16), *(void *)(a1 + 16), &v4);
    }
  }

void std::vector<nw_object_wrapper_t>::emplace<nw_object *&>(unint64_t *a1, uint64_t a2, void **a3)
{
  unint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  uint64_t v7 = a2 - *a1;
  uint64_t v8 = v7 >> 3;
  unint64_t v9 = *a1 + (v7 & 0xFFFFFFFFFFFFFFF8LL);
  unint64_t v10 = a1[2];
  if (v5 < v10)
  {
    if (*a3) {
      os_log_type_t v11 = os_retain(*a3);
    }
    else {
      os_log_type_t v11 = 0LL;
    }
    unint64_t v16 = v9 + 8;
    if (v9 == v5)
    {
      *(void *)unint64_t v9 = v11;
      a1[1] = v16;
      return;
    }

    unint64_t v17 = a1[1];
    uint64_t v18 = v17 - v16;
    id v19 = (_OWORD *)(v17 - 8);
    if (v17 - 8 >= v17)
    {
      __int16 v31 = (void *)a1[1];
    }

    else
    {
      unint64_t v20 = (v7 & 0xFFFFFFFFFFFFFFF8LL) + v18;
      unint64_t v21 = v20 + v6;
      unint64_t v22 = v20 + v6 + 8;
      if (v17 > v22) {
        unint64_t v22 = a1[1];
      }
      unint64_t v23 = v22 + ~v6 - v20;
      if (v23 > 0xE7
        && (v17 < v21 + (v23 & 0xFFFFFFFFFFFFFFF8LL) + 8
          ? (BOOL v24 = (unint64_t)v19 >= (v23 & 0xFFFFFFFFFFFFFFF8LL) + v17 + 8)
          : (BOOL v24 = 1),
            v24))
      {
        uint64_t v25 = (v23 >> 3) + 1;
        uint64_t v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
        char v27 = (void *)((char *)v19 + v26);
        char v28 = (_OWORD *)(v17 + 16);
        uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __int128 v30 = v19[1];
          *(v28 - 1) = *v19;
          *char v28 = v30;
          *id v19 = 0uLL;
          v19[1] = 0uLL;
          v19 += 2;
          v28 += 2;
          v29 -= 4LL;
        }

        while (v29);
        __int16 v31 = (void *)(v17 + v26);
        if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_38;
        }
      }

      else
      {
        char v27 = (void *)(v17 - 8);
        __int16 v31 = (void *)a1[1];
      }

      do
      {
        *v31++ = *v27;
        *v27++ = 0LL;
      }

      while ((unint64_t)v27 < v17);
    }

nw_multipath_service_t nw_parameters_get_multipath_service(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    nw_multipath_service_t v3 = *(_DWORD *)(*((void *)v1 + 13) + 103LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  unint64_t v16 = "nw_parameters_get_multipath_service";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v16 = "nw_parameters_get_multipath_service";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v16 = "nw_parameters_get_multipath_service";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v16 = "nw_parameters_get_multipath_service";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v16 = "nw_parameters_get_multipath_service";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_endpoint_handler_uses_multipath(void *a1)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    if (v2[29]._os_unfair_lock_opaque != 2)
    {
      BOOL v10 = 0LL;
LABEL_30:
      os_unfair_lock_unlock(v2 + 28);
      goto LABEL_31;
    }

    nw_multipath_service_t v3 = *(id *)&v2[62]._os_unfair_lock_opaque;
    nw_endpoint_t v4 = v3;
    if (v3)
    {
      *(void *)os_log_type_t type = 0LL;
      uint64_t v37 = type;
      uint64_t v38 = 0x2020000000LL;
      char v39 = 0;
      if (!nw_endpoint_flow_is_multipath(v3))
      {
LABEL_28:
        BOOL v10 = *((_BYTE *)v37 + 24) != 0;
        _Block_object_dispose(type, 8);
LABEL_29:

        goto LABEL_30;
      }

      id v5 = nw_endpoint_flow_copy_connected_socket_wrapper(v4);
      unint64_t v6 = (void *)v4[117];
      if (v6)
      {
        uint64_t v7 = v6;
        id v8 = v7[4];

        uint64_t v9 = v4[90];
        if (!v9) {
          goto LABEL_14;
        }
      }

      else
      {
        id v8 = 0LL;
        uint64_t v9 = v4[90];
        if (!v9) {
          goto LABEL_14;
        }
      }

      BOOL v11 = *(const char **)(v9 + 16);
      if (!v11 || strcmp(v11, "quic"))
      {
LABEL_14:
        if (v5)
        {
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = __nw_endpoint_flow_uses_multipath_block_invoke;
          uint64_t v42 = &unk_189BC78E8;
          __int16 v43 = type;
          nw_fd_wrapper_get_fd(v5, buf);
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v17 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
            _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, "%{public}s Protocol not supported", buf, 0xCu);
          }
        }

void sub_181B76FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_is_multipath(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 220);
    if ((v2[8]._os_unfair_lock_opaque & 2) != 0)
    {
      uint64_t is_multipath = (v2[8]._os_unfair_lock_opaque & 0x8000) != 0;
    }

    else
    {
      nw_multipath_service_t v3 = *(NWConcrete_nw_endpoint_handler **)&v2[234]._os_unfair_lock_opaque;
      if (v3)
      {
        nw_endpoint_t v4 = nw_endpoint_handler_copy_flow(v3);
        uint64_t is_multipath = nw_endpoint_flow_is_multipath();
      }

      else
      {
        uint64_t is_multipath = 0LL;
      }
    }

    os_unfair_lock_unlock(v2 + 220);
    goto LABEL_8;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v18 = "nw_endpoint_flow_is_multipath";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v18 = "nw_endpoint_flow_is_multipath";
          __int16 v19 = 2082;
          unint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B772D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_alternate_path_state(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v196 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  id v8 = a2;
  uint64_t v9 = a3;
  id v10 = a4;
  BOOL v11 = v10;
  id v174 = v7;
  if (v7)
  {
    if (v8)
    {
      if (v9)
      {
LABEL_4:
        id v170 = v8;
        __int16 v171 = v9;
        __int16 v173 = v11;
        if (*((_DWORD *)v7 + 29) != 2 || (os_log_type_t v12 = (void *)nw_endpoint_handler_copy_connected_path(v7)) == 0LL)
        {
          id v19 = v7[8];
          v172 = 0LL;
          BOOL v18 = 0;
          char v20 = 1;
          int is_viable = 1;
          __int16 v175 = v19;
          if (!v11) {
            goto LABEL_53;
          }
          goto LABEL_48;
        }

        id v13 = v12;
        int is_viable = nw_endpoint_handler_is_viable(v7);
        char v15 = v7;
        uint64_t v16 = *((unsigned int *)v7 + 29);

        if ((_DWORD)v16 == 2)
        {
          __int16 v17 = (char *)nw_endpoint_handler_copy_flow(v15);
          BOOL v18 = v17[34] < 0;

          goto LABEL_47;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = (id)gLogObj;
        else {
          os_log_type_t v22 = off_189BBBBC0[v16];
        }
        *(_DWORD *)buf = 136446722;
        __int16 v179 = "nw_endpoint_handler_reported_do_not_reuse";
        __int16 v180 = 2082;
        nw_endpoint_t v181 = (void *)v22;
        __int16 v182 = 2082;
        uint64_t v183 = "flow";
        unint64_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v176 = 0;
        if (__nwlog_fault(v23, &type, &v176))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v24 = (os_log_s *)(id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              else {
                os_log_type_t v26 = off_189BBBBC0[v16];
              }
              *(_DWORD *)buf = 136446722;
              __int16 v179 = "nw_endpoint_handler_reported_do_not_reuse";
              __int16 v180 = 2082;
              nw_endpoint_t v181 = (void *)v26;
              __int16 v182 = 2082;
              uint64_t v183 = "flow";
              _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
            }

LABEL_191:
                  uint64_t v43 = 1LL;
                  goto LABEL_123;
                }

                if ((v20 & 1) != 0) {
                  os_log_type_t v89 = (os_log_s *)nw_path_copy_interface(v49);
                }
                else {
                  os_log_type_t v89 = (os_log_s *)nw_path_copy_connected_interface(v172);
                }
                BOOL v90 = v89;
                os_log_type_t v91 = v49;
                uint64_t v43 = 0LL;
                if (nw_path_is_tunnelled(v49))
                {
LABEL_156:
                  BOOL v56 = v90;
                  goto LABEL_122;
                }

                BOOL v56 = v90;
                if (!v90) {
                  goto LABEL_122;
                }
                if (nw_interface_get_type(v90) == nw_interface_type_loopback)
                {
                  uint64_t v43 = 0LL;
                  goto LABEL_122;
                }

                int v97 = *((_DWORD *)v90 + 2);
                if (v97 == nw_path_get_interface_index(v35))
                {
                  uint64_t v43 = 0LL;
                  BOOL v56 = v90;
                  goto LABEL_122;
                }

                os_log_type_t v98 = (nw_endpoint *)nw_path_copy_endpoint(v91);
                id v99 = (nw_endpoint *)nw_path_copy_endpoint(v35);
                char v164 = v98;
                uint64_t v166 = v99;
                if (v98) {
                  nw_endpoint_type_t v100 = nw_endpoint_get_type(v98);
                }
                else {
                  nw_endpoint_type_t v100 = nw_endpoint_type_invalid;
                }
                unsigned int v101 = v174;
                if (v99) {
                  LODWORD(v99) = nw_endpoint_get_type(v99);
                }
                id v169 = nw_endpoint_handler_copy_current_path(v170);
                if (v100 != (_DWORD)v99
                  || nw_path_may_span_multiple_interfaces(v169)
                  && nw_endpoint_handler_has_matching_handler(v170, v171))
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v174) & 1) != 0)
                  {
                    uint64_t v43 = 0LL;
                    goto LABEL_155;
                  }

                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  char v102 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                  {
                    unsigned int v103 = nw_endpoint_handler_get_id_string(v174);
                    nw_endpoint_t v104 = nw_endpoint_handler_dry_run_string(v174);
                    nw_endpoint_t v105 = nw_endpoint_handler_copy_endpoint(v174);
                    BOOL v106 = nw_endpoint_get_logging_description(v105);
                    __int16 v107 = nw_endpoint_handler_state_string(v174);
                    __int16 v108 = nw_endpoint_handler_mode_string(v174);
                    id v109 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448258;
                    __int16 v179 = "nw_endpoint_handler_get_alternate_path_state";
                    __int16 v180 = 2082;
                    nw_endpoint_t v181 = (void *)v103;
                    __int16 v182 = 2082;
                    uint64_t v183 = v104;
                    __int16 v184 = 2082;
                    id v185 = (void *)v106;
                    __int16 v186 = 2082;
                    char v187 = v107;
                    __int16 v188 = 2082;
                    nw_endpoint_t v189 = v108;
                    __int16 v190 = 2114;
                    id v191 = v109;
                    __int16 v192 = 2114;
                    id v193 = v166;
                    __int16 v194 = 2114;
                    nw_endpoint_t v195 = v164;
                    _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] suppressing bette r path notification (comparing %{public}@ to %{public}@)",  buf,  0x5Cu);
                  }

                  uint64_t v43 = 0LL;
LABEL_154:

LABEL_155:
                  goto LABEL_156;
                }

                int v110 = nw_endpoint_handler_get_minimize_logging(v174);
                char v111 = nw_endpoint_handler_get_logging_disabled(v174);
                if (v110)
                {
                  if ((v111 & 1) != 0) {
                    goto LABEL_148;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  BOOL v112 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
                  {
                    os_log_t loga = nw_endpoint_handler_get_id_string(v174);
                    id v156 = nw_endpoint_handler_dry_run_string(v174);
                    nw_endpoint_t v157 = nw_endpoint_handler_copy_endpoint(v174);
                    id v158 = nw_endpoint_get_logging_description(v157);
                    int v159 = nw_endpoint_handler_state_string(v174);
                    int v160 = nw_endpoint_handler_mode_string(v174);
                    id v161 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448258;
                    __int16 v179 = "nw_endpoint_handler_get_alternate_path_state";
                    __int16 v180 = 2082;
                    nw_endpoint_t v181 = (void *)loga;
                    __int16 v182 = 2082;
                    uint64_t v183 = v156;
                    __int16 v184 = 2082;
                    id v185 = (void *)v158;
                    __int16 v186 = 2082;
                    char v187 = v159;
                    __int16 v188 = 2082;
                    nw_endpoint_t v189 = v160;
                    __int16 v190 = 2114;
                    id v191 = v161;
                    __int16 v192 = 2114;
                    id v193 = (nw_endpoint *)v35;
                    __int16 v194 = 2114;
                    nw_endpoint_t v195 = v91;
                    _os_log_impl( &dword_181A5C000,  v112,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{pub lic}@ preferred to path %{public}@",  buf,  0x5Cu);
                  }
                }

                else
                {
                  if ((v111 & 1) != 0)
                  {
LABEL_148:
                    if ((nw_endpoint_handler_get_logging_disabled(v101) & 1) != 0)
                    {
                      uint64_t v43 = 1LL;
                      goto LABEL_155;
                    }

                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    char v102 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v120 = nw_endpoint_handler_get_id_string(v101);
                      char v121 = nw_endpoint_handler_dry_run_string(v101);
                      nw_endpoint_t v122 = nw_endpoint_handler_copy_endpoint(v101);
                      char v123 = nw_endpoint_get_logging_description(v122);
                      uint64_t v124 = nw_endpoint_handler_state_string(v101);
                      nw_endpoint_t v125 = nw_endpoint_handler_mode_string(v101);
                      id v126 = nw_endpoint_handler_copy_current_path(v101);
                      *(_DWORD *)buf = 136448258;
                      __int16 v179 = "nw_endpoint_handler_get_alternate_path_state";
                      __int16 v180 = 2082;
                      nw_endpoint_t v181 = (void *)v120;
                      __int16 v182 = 2082;
                      uint64_t v183 = v121;
                      __int16 v184 = 2082;
                      id v185 = (void *)v123;
                      __int16 v186 = 2082;
                      char v187 = v124;
                      __int16 v188 = 2082;
                      nw_endpoint_t v189 = v125;
                      __int16 v190 = 2114;
                      id v191 = v126;
                      __int16 v192 = 2114;
                      id v193 = v166;
                      __int16 v194 = 2114;
                      nw_endpoint_t v195 = v164;
                      _os_log_impl( &dword_181A5C000,  v102,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] comparing %{pub lic}@ to %{public}@",  buf,  0x5Cu);
                    }

                    uint64_t v43 = 1LL;
                    goto LABEL_154;
                  }

                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  BOOL v112 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v112, OS_LOG_TYPE_INFO))
                  {
                    os_log_t log = v112;
                    uint64_t v113 = nw_endpoint_handler_get_id_string(v174);
                    nw_endpoint_t v114 = nw_endpoint_handler_dry_run_string(v174);
                    nw_endpoint_t v115 = nw_endpoint_handler_copy_endpoint(v174);
                    uint64_t v116 = nw_endpoint_get_logging_description(v115);
                    nw_endpoint_t v117 = nw_endpoint_handler_state_string(v174);
                    unsigned int v118 = nw_endpoint_handler_mode_string(v174);
                    id v119 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448258;
                    __int16 v179 = "nw_endpoint_handler_get_alternate_path_state";
                    __int16 v180 = 2082;
                    nw_endpoint_t v181 = (void *)v113;
                    __int16 v182 = 2082;
                    uint64_t v183 = v114;
                    __int16 v184 = 2082;
                    id v185 = (void *)v116;
                    __int16 v186 = 2082;
                    char v187 = v117;
                    __int16 v188 = 2082;
                    nw_endpoint_t v189 = v118;
                    __int16 v190 = 2114;
                    id v191 = v119;
                    __int16 v192 = 2114;
                    id v193 = (nw_endpoint *)v35;
                    __int16 v194 = 2114;
                    nw_endpoint_t v195 = v91;
                    _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{pub lic}@ preferred to path %{public}@",  buf,  0x5Cu);

                    BOOL v112 = log;
                  }
                }

                unsigned int v101 = v174;
                goto LABEL_148;
              }

              int v39 = v37[67];

              if (!v39) {
                goto LABEL_64;
              }
            }

  if (v71) {
    free(v71);
  }
LABEL_38:

  os_log_type_t v31 = *(char **)(*((void *)v6 + 3) + 48LL);
  os_log_type_t v32 = v30;
  os_log_type_t v33 = v32;
  if (v31)
  {
    *(void *)buf = v27;
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke;
    *(void *)&__int16 v135 = &unk_189BB6060;
    *((void *)&v135 + 1) = v32;
    nw_endpoint_t v136 = (os_log_type_t *)v31;
    __int16 v137 = "other";
    nw_hash_table_apply(v31, (uint64_t)buf);

    goto LABEL_40;
  }

  __nwlog_obj();
  __int16 v74 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
  BOOL v75 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  BOOL v133 = 0;
  if (__nwlog_fault(v75, type, &v133))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v77 = type[0];
      if (os_log_type_enabled(v76, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_181A5C000, v76, v77, "%{public}s called with null hash_table", buf, 0xCu);
      }
    }

    else if (v133)
    {
      char v102 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unsigned int v103 = type[0];
      nw_endpoint_t v104 = os_log_type_enabled(v76, type[0]);
      if (v102)
      {
        if (v104)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v102;
          _os_log_impl( &dword_181A5C000,  v76,  v103,  "%{public}s called with null hash_table, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v102);
        goto LABEL_196;
      }

      if (v104)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_181A5C000, v76, v103, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      nw_endpoint_t v115 = type[0];
      if (os_log_type_enabled(v76, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl( &dword_181A5C000,  v76,  v115,  "%{public}s called with null hash_table, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    goto LABEL_251;
  }

  __nwlog_obj();
  os_log_type_t v32 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  BOOL v133 = "nw_protocol_implementation_output_available";
  os_log_type_t v33 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v128[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v33, type, v128))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v133 = "nw_protocol_implementation_output_available";
        _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v128[0])
    {
      uint64_t v44 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v45 = type[0];
      uint64_t v46 = os_log_type_enabled(v34, type[0]);
      if (v44)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v133 = "nw_protocol_implementation_output_available";
          id v134 = 2082;
          __int16 v135 = v44;
          _os_log_impl( &dword_181A5C000,  v34,  v45,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v44);
        goto LABEL_176;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v133 = "nw_protocol_implementation_output_available";
        _os_log_impl(&dword_181A5C000, v34, v45, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v92 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v133 = "nw_protocol_implementation_output_available";
        _os_log_impl( &dword_181A5C000,  v34,  v92,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

                  if ((v24[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    os_log_type_t v98 = (os_log_s *)(id)gLogObj;
                    uint64_t v16 = v25;
                    if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v24 + 407;
                      *(_WORD *)&_BYTE buf[22] = 2080;
                      uint64_t v120 = " ";
                      LOWORD(v121) = 2048;
                      *(void *)((char *)&v121 + 2) = a2;
                      _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p",  buf,  0x2Au);
                    }

                    goto LABEL_195;
                  }

                  goto LABEL_200;
                }

                __nwlog_obj();
                os_log_type_t v81 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                id v82 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v111) = 0;
                if (__nwlog_fault(v82, type, &v111))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    unsigned int v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    __int16 v84 = type[0];
                    if (os_log_type_enabled(v83, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                      _os_log_impl(&dword_181A5C000, v83, v84, "%{public}s called with null protocol", buf, 0xCu);
                    }
                  }

                  else if ((_BYTE)v111)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    unsigned int v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    id v88 = type[0];
                    os_log_type_t v89 = os_log_type_enabled(v83, type[0]);
                    if (backtrace_string)
                    {
                      if (v89)
                      {
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = backtrace_string;
                        _os_log_impl( &dword_181A5C000,  v83,  v88,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                      }

                      free(backtrace_string);
                      goto LABEL_189;
                    }

                    if (v89)
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                      _os_log_impl( &dword_181A5C000,  v83,  v88,  "%{public}s called with null protocol, no backtrace",  buf,  0xCu);
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    unsigned int v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    int v97 = type[0];
                    if (os_log_type_enabled(v83, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                      _os_log_impl( &dword_181A5C000,  v83,  v97,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
                    }
                  }
                }

        if (!v71)
        {
LABEL_193:
          uint64_t v61 = 0LL;
          __int16 v17 = v95;
          goto LABEL_147;
        }

          os_log_type_t v130 = *v7++;
          __int16 v129 = v130;
          v21 += (unint64_t)(v130 & 0x7F) << v14;
          v14 += 7;
        }

        while ((v130 & 0x80) != 0);
        if (v14 >= 0x40)
        {
          id v146 = 3658;
          if (v21 > -1 || v129 > 1) {
            id v148 = v10;
          }
          else {
            id v148 = v7;
          }
          id v149 = 3658;
LABEL_285:
          BOOL v154 = v14 == 70;
          if (v14 == 70) {
            id v161 = v149;
          }
          else {
            id v161 = v146;
          }
          if (v154) {
            id v10 = v148;
          }
          goto LABEL_349;
        }

        if ((unint64_t)v21 >> 24)
        {
          id v161 = 3658;
          goto LABEL_348;
        }

        if (v69) {
          free(v69);
        }

LABEL_32:
        if (nw_get_http3_override_onceToken != -1) {
          dispatch_once(&nw_get_http3_override_onceToken, &__block_literal_global_8_72852);
        }
        if (nw_get_http3_override_value != 1 && nw_get_http3_override_value != 2)
        {
          os_log_type_t v28 = (void *)v102[5];
          if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
            dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
          }
          os_log_type_t v29 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
          nw_endpoint_add_alternative(v28, &__block_literal_global_6237, v29);
          if (v29) {
            os_release(v29);
          }
        }

        goto LABEL_40;
      }

      hostname = nw_endpoint_get_hostname((nw_endpoint_t)v102[5]);
      port = nw_endpoint_get_port((nw_endpoint_t)v102[5]);
      v92[0] = MEMORY[0x1895F87A8];
      v92[1] = 0x40000000LL;
      id v93 = ___ZL32nw_protocol_http_alt_svc_connectP11nw_protocolS0__block_invoke;
      id v94 = &unk_189BC57B8;
      nw_endpoint_t v95 = &v101;
      char v96 = &v97;
      id v88 = (id *)v90;
      os_log_type_t v12 = v92;
      if (hostname)
      {
        if (port)
        {
          id v13 = objc_alloc_init(MEMORY[0x189601F58]);
          [NSString stringWithUTF8String:hostname];
          os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
          [v13 setHost:v14];

          [v13 setPort:port];
          [v88[1] HTTPServiceEntriesWithFilter:v13];
          char v15 = (void *)objc_claimAutoreleasedReturnValue();
          memset(v114, 0, sizeof(v114));
          nw_endpoint_t v115 = 0u;
          uint64_t v116 = 0u;
          uint64_t v16 = [v15 countByEnumeratingWithState:v114 objects:buf count:16];
          if (v16)
          {
            __int16 v17 = v16;
            BOOL v18 = **(void **)&v114[16];
            do
            {
              for (int i = 0LL; i != v17; ++i)
              {
                if (**(void **)&v114[16] != v18) {
                  objc_enumerationMutation(v15);
                }
                char v20 = *(void **)(*(void *)&v114[8] + 8 * i);
                objc_msgSend(v20, "alternateHost", v86, v87);
                id v21 = (void *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v22 = [v21 UTF8String];
                unint64_t v23 = [v20 alternatePort];
                v93((uint64_t)v12, (const char *)v22, v23);
              }

              __int16 v17 = [v15 countByEnumeratingWithState:v114 objects:buf count:16];
            }

            while (v17);
          }

          goto LABEL_24;
        }

        __nwlog_obj();
        BOOL v56 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_alt_svc_enumerate";
        id v53 = (char *)_os_log_send_and_compose_impl();

        v114[0] = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v53, v114, &type))
        {
          if (v114[0] == 17)
          {
            __nwlog_obj();
            unint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v57 = v114[0];
            if (os_log_type_enabled(v54, (os_log_type_t)v114[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_alt_svc_enumerate";
              _os_log_impl(&dword_181A5C000, v54, v57, "%{public}s called with null port", buf, 0xCu);
            }
          }

          else if (type)
          {
            __int16 v76 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            unint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            id v77 = v114[0];
            nw_endpoint_t v78 = os_log_type_enabled(v54, (os_log_type_t)v114[0]);
            if (v76)
            {
              if (v78)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http_alt_svc_enumerate";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v76;
                _os_log_impl( &dword_181A5C000,  v54,  v77,  "%{public}s called with null port, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v76);
              if (!v53) {
                goto LABEL_24;
              }
              goto LABEL_184;
            }

            if (v78)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_alt_svc_enumerate";
              _os_log_impl(&dword_181A5C000, v54, v77, "%{public}s called with null port, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            unint64_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            __int16 v84 = v114[0];
            if (os_log_type_enabled(v54, (os_log_type_t)v114[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_alt_svc_enumerate";
              _os_log_impl( &dword_181A5C000,  v54,  v84,  "%{public}s called with null port, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          goto LABEL_182;
        }

  if (v78) {
    free(v78);
  }
LABEL_193:

LABEL_247:
  nw_endpoint_t v114 = (unsigned __int8 *)v402[3];
  nw_endpoint_t v115 = *v114;
  uint64_t v116 = lock;
  if (v115 == 13)
  {
    *(void *)out = 0LL;
    *(void *)&out[8] = out;
    *(void *)&out[16] = 0x3032000000LL;
    *(void *)&out[24] = __Block_byref_object_copy__79337;
    *(void *)&out[32] = __Block_byref_object_dispose__79338;
    *(void *)&out[40] = 0LL;
    v387[0] = MEMORY[0x1895F87A8];
    v387[1] = 3221225472LL;
    v388 = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_157;
    v389 = &unk_189BC9210;
    v391 = out;
    v390 = v298;
    nw_endpoint_t v117 = v390;
    unsigned int v118 = v387;
    os_unfair_lock_lock(lock);
    v388((uint64_t)v118);
    os_unfair_lock_unlock(lock);

    id v119 = *(void *)(*(void *)&out[8] + 40LL);
    if (v119)
    {
      v385[0] = MEMORY[0x1895F87A8];
      v385[1] = 3221225472LL;
      v385[2] = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2;
      v385[3] = &unk_189BC7758;
      v386 = v117;
      (*(void (**)(uint64_t, NWConcrete_nw_agent_client *, void *))(v119 + 16))(v119, v296, v385);

      goto LABEL_268;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v120 = (id)gLogObj;
    *(_DWORD *)v413 = 136446210;
    v414 = "nw_agent_read_message_on_queue";
    char v121 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v405 = 0;
    if (__nwlog_fault(v121, &type, &v405))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_endpoint_t v122 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v123 = type;
        if (os_log_type_enabled(v122, type))
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_read_message_on_queue";
          _os_log_impl(&dword_181A5C000, v122, v123, "%{public}s No handler for CLIENT_TRIGGER", v413, 0xCu);
        }

        goto LABEL_265;
      }

      if (v405)
      {
        uint64_t v124 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_endpoint_t v122 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_endpoint_t v125 = type;
        id v126 = os_log_type_enabled(v122, type);
        if (v124)
        {
          if (v126)
          {
            *(_DWORD *)v413 = 136446466;
            v414 = "nw_agent_read_message_on_queue";
            v415 = 2082;
            v416 = v124;
            _os_log_impl( &dword_181A5C000,  v122,  v125,  "%{public}s No handler for CLIENT_TRIGGER, dumping backtrace:%{public}s",  v413,  0x16u);
          }

          free(v124);
          goto LABEL_266;
        }

        if (v126)
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_read_message_on_queue";
          _os_log_impl( &dword_181A5C000,  v122,  v125,  "%{public}s No handler for CLIENT_TRIGGER, no backtrace",  v413,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        nw_endpoint_t v122 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v127 = type;
        if (os_log_type_enabled(v122, type))
        {
          *(_DWORD *)v413 = 136446210;
          v414 = "nw_agent_read_message_on_queue";
          _os_log_impl( &dword_181A5C000,  v122,  v127,  "%{public}s No handler for CLIENT_TRIGGER, backtrace limit exceeded",  v413,  0xCu);
        }
      }

                  if ((nw_endpoint_handler_get_logging_disabled(v45) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    int v143 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
                    {
                      nw_endpoint_t v144 = nw_endpoint_handler_get_id_string(v45);
                      uint64_t v145 = nw_endpoint_handler_dry_run_string(v45);
                      id v146 = nw_endpoint_handler_copy_endpoint(v45);
                      nw_endpoint_t v147 = nw_endpoint_get_logging_description(v146);
                      id v148 = v45;
                      id v149 = nw_endpoint_handler_state_string(v45);
                      char v150 = nw_endpoint_handler_mode_string(v148);
                      nw_endpoint_t v151 = nw_endpoint_handler_copy_current_path(v148);
                      *(_DWORD *)buf = 136447746;
                      v355 = "nw_endpoint_start_tls_while_connected";
                      v356 = 2082;
                      v357 = (char *)v144;
                      v358 = 2082;
                      v359 = v145;
                      v360 = 2082;
                      v361 = (void *)v147;
                      v362 = 2082;
                      v363 = v149;
                      v364 = 2082;
                      v365 = v150;
                      v366 = 2114;
                      v367 = v151;
                      _os_log_impl( &dword_181A5C000,  v143,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach TLS protocol",  buf,  0x48u);
                    }
                  }

                  goto LABEL_197;
                }

                __nwlog_obj();
                __int16 v107 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136446466;
                v355 = "nw_protocol_utilities_add_input_handler";
                v356 = 2048;
                v357 = (char *)v49;
                __int16 v108 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v350) = 0;
                if (__nwlog_fault(v108, type, &v350))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    id v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    int v110 = type[0];
                    if (os_log_type_enabled(v109, type[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v355 = "nw_protocol_utilities_add_input_handler";
                      v356 = 2048;
                      v357 = (char *)v49;
                      _os_log_impl( &dword_181A5C000,  v109,  v110,  "%{public}s Cannot add input handler %p to itself",  buf,  0x16u);
                    }
                  }

                  else
                  {
                    if ((_BYTE)v350)
                    {
                      BOOL v112 = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      uint64_t v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      nw_endpoint_t v114 = type[0];
                      nw_endpoint_t v115 = os_log_type_enabled(v113, type[0]);
                      if (v112)
                      {
                        if (v115)
                        {
                          *(_DWORD *)buf = 136446722;
                          v355 = "nw_protocol_utilities_add_input_handler";
                          v356 = 2048;
                          v357 = (char *)v49;
                          v358 = 2082;
                          v359 = v112;
                          _os_log_impl( &dword_181A5C000,  v113,  v114,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
                        }

                        free(v112);
                      }

                      else
                      {
                        if (v115)
                        {
                          *(_DWORD *)buf = 136446466;
                          v355 = "nw_protocol_utilities_add_input_handler";
                          v356 = 2048;
                          v357 = (char *)v49;
                          _os_log_impl( &dword_181A5C000,  v113,  v114,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
                        }
                      }

                      goto LABEL_189;
                    }

                    __nwlog_obj();
                    id v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    id v142 = type[0];
                    if (os_log_type_enabled(v109, type[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v355 = "nw_protocol_utilities_add_input_handler";
                      v356 = 2048;
                      v357 = (char *)v49;
                      _os_log_impl( &dword_181A5C000,  v109,  v142,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
                    }
                  }
                }

void sub_181B78A24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_used_fallback_locked(void *a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    if ((*((_BYTE *)v1 + 109) & 0x40) != 0) {
      nw_multipath_service_t v3 = nw_endpoint_handler_copy_connected_flow_handler(v1[18]);
    }
    else {
      nw_multipath_service_t v3 = v1[19];
    }
    nw_endpoint_t v4 = v3;
    if (v3)
    {
      id v5 = v3;
      id v6 = v5[4];

      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = (v7[12] >> 16) & 1LL;
      }

      else
      {
        uint64_t v8 = 0LL;
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    goto LABEL_12;
  }

  __nwlog_obj();
  id v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v21 = "nw_connection_used_fallback_locked";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v21 = "nw_connection_used_fallback_locked";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          id v21 = "nw_connection_used_fallback_locked";
          __int16 v22 = 2082;
          unint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        id v21 = "nw_connection_used_fallback_locked";
        _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v21 = "nw_connection_used_fallback_locked";
        _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B78EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_async_client(void *a1, dispatch_qos_class_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  if (nw_parameters_is_persona_set((uint64_t)v5[2]))
  {
    id v7 = v5[2];
    BOOL v8 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v7,  0,  0);

    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = __nw_connection_async_client_block_invoke;
    v9[3] = &unk_189BC9440;
    id v10 = v5;
    dispatch_qos_class_t v12 = a2;
    id v11 = v6;
    nw_utilities_execute_block_as_persona_from_parameters((void *)v8, v9);
  }

  else
  {
    __nw_connection_async_client(v5, a2, v6);
  }
}

void sub_181B78FD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_connected_path(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    id v19 = __Block_byref_object_copy__24148;
    char v20 = __Block_byref_object_dispose__24149;
    id v21 = 0LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_copy_connected_path_block_invoke;
    v13[3] = &unk_189BC9210;
    os_log_type_t v14 = v1;
    os_log_type_t v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_connected_path_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_copy_connected_path_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v6 = nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
    os_log_type_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_endpoint_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v9 = 136446466;
        os_log_type_t v10 = "nw_connection_copy_connected_path_block_invoke";
        __int16 v11 = 1024;
        int v12 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Client called nw_connection_copy_connected_path on unconnected nw_connection",  (uint8_t *)&v9,  0x12u);
      }
    }
  }

id nw_connection_copy_connected_local_endpoint(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    id v19 = __Block_byref_object_copy__24148;
    char v20 = __Block_byref_object_dispose__24149;
    id v21 = 0LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_copy_connected_local_endpoint_block_invoke;
    v13[3] = &unk_189BC9210;
    os_log_type_t v14 = v1;
    os_log_type_t v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_connected_local_endpoint_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_copy_connected_local_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v6 = (nw_path *)nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    nw_endpoint_t v4 = v6;
    if (v6)
    {
      nw_endpoint_t v7 = nw_path_copy_effective_local_endpoint(v6);
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
      int v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)) {
        goto LABEL_24;
      }
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (!v10 || nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104))) {
        goto LABEL_24;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v11 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_local_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v12;
      uint64_t v13 = "%{public}s [C%u] Connection has no local endpoint";
    }

    else
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (!v14 || nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
      {
        nw_endpoint_t v4 = 0LL;
        goto LABEL_24;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v11 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
LABEL_23:

LABEL_24:
        return;
      }

      int v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_local_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v15;
      uint64_t v13 = "%{public}s [C%u] Connection has no connected path";
    }

    _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v16, 0x12u);
    goto LABEL_23;
  }

  uint64_t v3 = *(void *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    nw_endpoint_t v4 = (nw_path *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_local_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v5;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Client called nw_connection_copy_connected_local_endpoint on unconnected nw_connection",  (uint8_t *)&v16,  0x12u);
    }

    goto LABEL_24;
  }

id nw_connection_copy_connected_remote_endpoint(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    int v19 = __Block_byref_object_copy__24148;
    uint64_t v20 = __Block_byref_object_dispose__24149;
    id v21 = 0LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_copy_connected_remote_endpoint_block_invoke;
    v13[3] = &unk_189BC9210;
    uint64_t v14 = v1;
    int v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_connected_remote_endpoint_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_copy_connected_remote_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v6 = (nw_path *)nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    nw_endpoint_t v4 = v6;
    if (v6)
    {
      nw_endpoint_t v7 = nw_path_copy_effective_remote_endpoint(v6);
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
      int v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)) {
        goto LABEL_24;
      }
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (!v10 || nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104))) {
        goto LABEL_24;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v11 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_remote_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v12;
      uint64_t v13 = "%{public}s [C%u] Connection has no remote endpoint";
    }

    else
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (!v14 || nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
      {
        nw_endpoint_t v4 = 0LL;
        goto LABEL_24;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v11 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
LABEL_23:

LABEL_24:
        return;
      }

      int v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_remote_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v15;
      uint64_t v13 = "%{public}s [C%u] Connection has no connected path";
    }

    _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v16, 0x12u);
    goto LABEL_23;
  }

  uint64_t v3 = *(void *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    nw_endpoint_t v4 = (nw_path *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_remote_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v5;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Client called nw_connection_copy_connected_remote_endpoint on unconnected nw_connection",  (uint8_t *)&v16,  0x12u);
    }

    goto LABEL_24;
  }

id nw_path_copy_parameters(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[2];
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_path_copy_parameters";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_path_copy_parameters";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

_DWORD *network_proxy_create_from_parameters(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v14 = "network_proxy_create_from_parameters";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "network_proxy_create_from_parameters";
      os_log_type_t v8 = "%{public}s called with null parameters";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v14 = "network_proxy_create_from_parameters";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (!v10)
      {
LABEL_21:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "network_proxy_create_from_parameters";
      os_log_type_t v8 = "%{public}s called with null parameters, no backtrace";
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "network_proxy_create_from_parameters";
      os_log_type_t v8 = "%{public}s called with null parameters, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_21;
  }

  nw_parameters_t v1 = a1;
  uint64_t v2 = v1[23];

  if (v2)
  {
    uint64_t v2 = v2;
    int v3 = v2[38];

    if (v3 != 1)
    {
      os_release(v2);
      return 0LL;
    }
  }

  return v2;
}

nw_protocol_metadata_t nw_connection_copy_protocol_metadata( nw_connection_t connection, nw_protocol_definition_t definition)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v3 = connection;
  nw_endpoint_t v4 = definition;
  if (v3)
  {
    nw_connection_copy_protocol_metadata_internal(v3, v4, 0);
    int v5 = (nw_protocol_metadata *)objc_claimAutoreleasedReturnValue();
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v18 = "nw_connection_copy_protocol_metadata";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_connection_copy_protocol_metadata";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v18 = "nw_connection_copy_protocol_metadata";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_connection_copy_protocol_metadata";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_connection_copy_protocol_metadata";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B7A808(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_protocol_metadata_internal(void *a1, void *a2, char a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  id v6 = a2;
  if (v5)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    os_log_type_t v25 = __Block_byref_object_copy__24148;
    os_log_type_t v26 = __Block_byref_object_dispose__24149;
    id v27 = 0LL;
    v17[0] = MEMORY[0x1895F87A8];
    v17[2] = __nw_connection_copy_protocol_metadata_internal_block_invoke;
    v17[3] = &unk_189BB97E8;
    v17[1] = 3221225472LL;
    __int16 v18 = v5;
    uint64_t v20 = buf;
    id v19 = v6;
    char v21 = a3;
    os_unfair_lock_lock(v5 + 34);
    __nw_connection_copy_protocol_metadata_internal_block_invoke((uint64_t)v17);
    os_unfair_lock_unlock(v5 + 34);
    id v7 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v10, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_copy_protocol_metadata_internal_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    int v6 = *(unsigned __int8 *)(a1 + 56);
    id v7 = *(id *)(a1 + 40);
    id v8 = nw_endpoint_handler_copy_protocol_metadata(*(void **)(v2 + 144), v7, 0, v6);

    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8LL);
    os_log_type_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_endpoint_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v11 = 136446466;
        os_log_type_t v12 = "nw_connection_copy_protocol_metadata_internal_block_invoke";
        __int16 v13 = 1024;
        int v14 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Client called nw_connection_copy_protocol_metadata_internal on unconnected nw_connection",  (uint8_t *)&v11,  0x12u);
      }
    }
  }

void sub_181B7AD08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_protocol_metadata(void *a1, void *a2, int a3, int a4)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = v8;
  if (v7)
  {
    if (v8)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 28);
      if (*((_DWORD *)v7 + 29) == 2) {
        id v10 = nw_endpoint_flow_copy_protocol_metadata(v7, *((void **)v7 + 31), v9, a3, a4);
      }
      else {
        id v10 = 0LL;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 28);
      goto LABEL_7;
    }

    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
    __int16 v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v13, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
          _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null definition", buf, 0xCu);
        }

void sub_181B7B20C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_protocol_metadata(void *a1, void *a2, void *a3, int a4, int a5)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a1;
  id v10 = a2;
  id v11 = a3;
  if (v10)
  {
    if (a4) {
      nw_endpoint_flow_update_connected_metadata(v9, a5);
    }
    os_unfair_lock_lock(v10 + 220);
    uint64_t v12 = 262LL;
    if (a5) {
      uint64_t v12 = 264LL;
    }
    __int16 v13 = (unsigned __int8 *)*(id *)&v10[v12]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v10 + 220);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    BOOL v30 = __Block_byref_object_copy__80314;
    uint64_t v31 = __Block_byref_object_dispose__80315;
    id v32 = 0LL;
    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    v24[2] = __nw_endpoint_flow_copy_protocol_metadata_block_invoke;
    v24[3] = &unk_189BC7960;
    id v25 = v11;
    os_log_type_t v26 = buf;
    nw_array_apply(v13, (uint64_t)v24);
    id v14 = *(id *)(*(void *)&buf[8] + 40LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_7;
  }

  __nwlog_obj();
  os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
  os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (__nwlog_fault(v17, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
        _os_log_impl(&dword_181A5C000, v18, v21, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
        _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B7B5BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_flow_copy_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  int v5 = a3;
  nw_protocol_definition_t v6 = nw_protocol_metadata_copy_definition(v5);

  return 1LL;
}

void sub_181B7B648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_definition_t nw_protocol_metadata_copy_definition(nw_protocol_metadata_t metadata)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = metadata;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (nw_protocol_definition *)v1[1];
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_metadata_copy_definition";
  nw_protocol_definition_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_metadata_copy_definition";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_protocol_metadata_is_tls(nw_protocol_metadata_t metadata)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = metadata;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1;
    id v4 = v3[1];

    int v5 = (void *)nw_protocol_boringssl_copy_definition();
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, (uint64_t)v5);

    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_protocol_metadata_is_tls";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_metadata_is_tls";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_protocol_metadata_is_tls";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_metadata_is_tls";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_metadata_is_tls";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B7BBC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_uses_interface_type(nw_path_t path, nw_interface_type_t interface_type)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  nw_path_t v3 = path;
  nw_path_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v34 = "nw_path_uses_interface_type";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v24, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        BOOL v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v34 = "nw_path_uses_interface_type";
            __int16 v35 = 2082;
            int v36 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }

        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "nw_path_uses_interface_type";
          _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B7BF78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_copy_interface(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  p_isa = (void **)&v1->super.isa;
  if (!v1)
  {
    __nwlog_obj();
    nw_path_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_path_copy_interface";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        nw_protocol_definition_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_protocol_definition_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            char v16 = "nw_path_copy_interface";
            __int16 v17 = 2082;
            int v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }

        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        nw_protocol_definition_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_copy_interface";
          _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B7C244(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *__cdecl nw_interface_get_name(nw_interface_t interface)
{
  else {
    return 0LL;
  }
}

BOOL nw_connection_uses_multipath(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v19 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_uses_multipath_block_invoke;
    v13[3] = &unk_189BC9210;
    BOOL v14 = v1;
    int v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_uses_multipath_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  BOOL v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
  nw_protocol_definition_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_uses_multipath_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = nw_endpoint_handler_uses_multipath(*(void **)(v2 + 144));
  }

  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_path_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v6 = 136446466;
        os_log_type_t v7 = "nw_connection_uses_multipath_block_invoke";
        __int16 v8 = 1024;
        int v9 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_INFO,  "%{public}s [C%u]  has no connected handler",  (uint8_t *)&v6,  0x12u);
      }
    }
  }

BOOL nw_connection_used_tfo(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v19 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_used_tfo_block_invoke;
    v13[3] = &unk_189BC9210;
    BOOL v14 = v1;
    int v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_used_tfo_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_used_tfo";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_tfo";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_used_tfo";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_tfo";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_tfo";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_used_tfo_block_invoke(uint64_t a1)
{
  buf.var97 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = *(_BYTE **)(a1 + 32);
  if ((v1[109] & 0x40) == 0) {
    return;
  }
  BOOL v3 = v1;
  id v4 = v3[2];

  if (!nw_parameters_get_multipath(v4))
  {

LABEL_8:
    uint64_t v6 = nw_endpoint_handler_copy_connected_path(*(void **)(*(void *)(a1 + 32) + 144LL));
    os_log_type_t v7 = (void *)v6;
    if (v6)
    {
      os_log_type_t v8 = (os_log_s *)*(id *)(v6 + 96);
      if (v8)
      {
        int v9 = v8;
        memset(&buf, 0, 408);
      }

      else
      {
        uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 16LL);
        if (v12 && !nw_path_parameters_get_logging_disabled(*(void *)(v12 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v13 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            unsigned int v14 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)&buf.var0 = 136446466;
            *(void *)&buf.var4 = "nw_connection_used_tfo_block_invoke";
            LOWORD(buf.var6) = 1024;
            *(unsigned int *)((char *)&buf.var6 + 2) = v14;
            _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] No connected interface",  &buf.var0,  0x12u);
          }
        }

        int v9 = 0LL;
      }
    }

    else
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (!v10 || nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104))) {
        goto LABEL_27;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v9 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        unsigned int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)&buf.var0 = 136446466;
        *(void *)&buf.var4 = "nw_connection_used_tfo_block_invoke";
        LOWORD(buf.var6) = 1024;
        *(unsigned int *)((char *)&buf.var6 + 2) = v11;
        _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_ERROR, "%{public}s [C%u] No connected path", &buf.var0, 0x12u);
      }
    }

LABEL_27:
    return;
  }

  int is_multipath = nw_endpoint_handler_is_multipath(*(void **)(*(void *)(a1 + 32) + 144LL));

  if (!is_multipath) {
    goto LABEL_8;
  }
  id xdict = nw_endpoint_handler_copy_multipath_tcp_info(*(void **)(*(void *)(a1 + 32) + 144LL));
  if (xdict)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = __nw_connection_used_tfo_block_invoke_2;
    applier[3] = &unk_189BC71C0;
    applier[4] = *(void *)(a1 + 40);
    xpc_dictionary_apply(xdict, applier);
  }
}

void sub_181B7CCE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
}

void sub_181B7CCFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_is_unlisted_tracker(void *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  uint64_t v18 = 0LL;
  char v19 = &v18;
  uint64_t v20 = 0x2020000000LL;
  char v21 = 0;
  if (v1)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_is_unlisted_tracker_block_invoke;
    v13[3] = &unk_189BC9210;
    int v15 = &v18;
    unsigned int v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_is_unlisted_tracker_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *((_BYTE *)v19 + 24) != 0;

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)tcp_info buf = 136446210;
  os_log_type_t v23 = "nw_connection_is_unlisted_tracker";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v23 = "nw_connection_is_unlisted_tracker";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          os_log_type_t v23 = "nw_connection_is_unlisted_tracker";
          __int16 v24 = 2082;
          id v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v23 = "nw_connection_is_unlisted_tracker";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v23 = "nw_connection_is_unlisted_tracker";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_connection_is_unlisted_tracker_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = (*(_BYTE *)(*(void *)(result + 32) + 110LL) & 2) != 0;
  return result;
}

id nw_connection_copy_establishment_report_on_queue(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(*((void **)v1 + 3));
    BOOL v3 = (void *)v2[52];
    if (!v3)
    {
      nw_connection_fillout_establishment_report_on_nw_queue(v2, 0);
      BOOL v3 = (void *)v2[52];
    }

    id v4 = v3;
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)tcp_info buf = 136446210;
  __int16 v17 = "nw_connection_copy_establishment_report_on_queue";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v17 = "nw_connection_copy_establishment_report_on_queue";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          __int16 v17 = "nw_connection_copy_establishment_report_on_queue";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v12)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v17 = "nw_connection_copy_establishment_report_on_queue";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v17 = "nw_connection_copy_establishment_report_on_queue";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181B7D318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_get_privacy_stance(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)tcp_info buf = 0LL;
    *(void *)&buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_get_privacy_stance_block_invoke;
    v13[3] = &unk_189BC9210;
    int v15 = buf;
    char v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_get_privacy_stance_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    uint64_t v3 = *(unsigned int *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)tcp_info buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_connection_get_privacy_stance_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 32) + 504LL);
  return result;
}

void nw_connection_end_activity(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    os_log_type_t v23 = "nw_connection_end_activity";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v23 = "nw_connection_end_activity";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          os_log_type_t v23 = "nw_connection_end_activity";
          __int16 v24 = 2082;
          id v25 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_40:
        free(v7);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v23 = "nw_connection_end_activity";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v23 = "nw_connection_end_activity";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181B7DB28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_get_vpn_config_id(NWConcrete_nw_path *a1, unsigned __int8 (*a2)[16])
{
  return nw_path_get_vpn_config_uuid(a1, a2, 0LL, 1, 0);
}

uint64_t nw_path_get_policy_id(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 340);
  }
  return result;
}

uint64_t nw_path_uses_interface_subtype(void *a1, int a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    int v5 = nw_path_copy_connected_interface(v3);
    uint64_t v6 = v5;
    if (v5)
    {
      os_log_type_t v7 = v5;
      int v8 = *((_DWORD *)v7 + 25);

      if (v8 == a2) {
        goto LABEL_15;
      }
    }

    if (v4[94] != 1)
    {
      int v9 = v4[95];
      if (v9 == 4 || v9 == 30) {
        goto LABEL_16;
      }
    }

    os_log_type_t v11 = (void *)*((void *)v4 + 12);
    if (v11)
    {
      os_log_type_t v12 = v11;
      int v13 = v12[25];

      if (v13 == a2) {
        goto LABEL_15;
      }
    }

    BOOL v14 = (void *)*((void *)v4 + 13);
    if (v14)
    {
      int v15 = v14;
      int v16 = v15[25];

      if (v16 == a2) {
        goto LABEL_15;
      }
    }

    BOOL v17 = (void *)*((void *)v4 + 14);
    if (v17 && (os_log_type_t v18 = v17, v19 = v18[25], v18, v19 == a2)) {
LABEL_15:
    }
      uint64_t v20 = 1LL;
    else {
LABEL_16:
    }
      uint64_t v20 = 0LL;

    goto LABEL_18;
  }

  __nwlog_obj();
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)tcp_info buf = 136446210;
  uint64_t v33 = "nw_path_uses_interface_subtype";
  os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v30 = 0;
  if (__nwlog_fault(v23, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v33 = "nw_path_uses_interface_subtype";
        _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          uint64_t v33 = "nw_path_uses_interface_subtype";
          __int16 v34 = 2082;
          __int16 v35 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v28)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v33 = "nw_path_uses_interface_subtype";
        _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v33 = "nw_path_uses_interface_subtype";
        _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_connection_add_client_event(void *a1, int a2, void *a3)
{
}

void nw_endpoint_handler_report_connection_idle(void *a1, int a2)
{
  LODWORD(v2) = a2;
  uint64_t v81 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
    __int16 v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_181A5C000, v45, v46, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = type;
      BOOL v57 = os_log_type_enabled(v45, type);
      if (backtrace_string)
      {
        if (v57)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
          __int16 v67 = 2082;
          id v68 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v45,  v56,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_88:
        uint64_t v22 = 0LL;
        if (!v24) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }

      if (v57)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_181A5C000, v45, v56, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v45, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl( &dword_181A5C000,  v45,  v58,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_88;
  }

  int v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    os_log_type_t v7 = nw_endpoint_handler_copy_flow(v5);
    __int128 v62 = v4;
    if (nw_endpoint_handler_get_minimize_logging(v5))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
      {
LABEL_47:
        uint64_t v41 = *((void *)v7 + 51);
        buf[0] = v2;
        if (v41)
        {
          uint64_t v42 = *(void *)(v41 + 24);
          if (v42)
          {
            uint64_t v43 = *(void (**)(void))(v42 + 160);
            if (v43) {
              v43();
            }
          }
        }

        uint64_t v22 = v62;
        goto LABEL_64;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v5);
        BOOL v48 = nw_endpoint_handler_dry_run_string(v5);
        int v49 = (int)v2;
        nw_endpoint_t v61 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v61);
        uint64_t v2 = nw_endpoint_handler_state_string(v5);
        __int128 v51 = nw_endpoint_handler_mode_string(v5);
        id v52 = nw_endpoint_handler_copy_current_path(v5);
        id v53 = v52;
        *(_DWORD *)tcp_info buf = 136448002;
        uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
        unint64_t v54 = "not ";
        id v68 = (void *)id_string;
        __int16 v67 = 2082;
        if (v49) {
          unint64_t v54 = "";
        }
        __int16 v69 = 2082;
        int v70 = v48;
        __int16 v71 = 2082;
        uint64_t v72 = (void *)logging_description;
        __int16 v73 = 2082;
        __int16 v74 = v2;
        LOBYTE(v2) = v49;
        __int16 v75 = 2082;
        __int16 v76 = v51;
        __int16 v77 = 2114;
        id v78 = v52;
        __int16 v79 = 2082;
        __int16 v80 = v54;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting connection %{public }sidle to protocols",  buf,  0x52u);
      }
    }

    else
    {
      int v8 = v5;
      char v9 = *((_BYTE *)v8 + 268);

      if ((v9 & 0x20) != 0) {
        goto LABEL_47;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v11 = v8;

        os_log_type_t v12 = v11;
        char v13 = *((_BYTE *)v8 + 268);

        if ((v13 & 1) != 0) {
          BOOL v14 = "dry-run ";
        }
        else {
          BOOL v14 = "";
        }
        nw_endpoint_t v15 = nw_endpoint_handler_copy_endpoint(v12);
        int v16 = nw_endpoint_get_logging_description(v15);
        id_str = v11->id_str;
        BOOL v17 = v12;
        os_log_type_t v18 = v17;
        uint64_t v19 = v17[30];
        else {
          uint64_t v20 = off_189BBBBF0[v19];
        }
        uint64_t v59 = v20;

        id v32 = v18;
        uint64_t v33 = v32;
        __int16 v34 = "path";
        switch(v5->mode)
        {
          case 0:
            break;
          case 1:
            __int16 v34 = "resolver";
            break;
          case 2:
            __int16 v34 = nw_endpoint_flow_mode_string(v32[31]);
            break;
          case 3:
            __int16 v34 = "proxy";
            break;
          case 4:
            __int16 v34 = "fallback";
            break;
          case 5:
            __int16 v34 = "transform";
            break;
          default:
            __int16 v34 = "unknown-mode";
            break;
        }

        uint64_t v38 = v33;
        os_unfair_lock_lock((os_unfair_lock_t)v38 + 28);
        id v39 = v38[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v38 + 28);

        uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
        char v40 = "not ";
        *(_DWORD *)tcp_info buf = 136448002;
        if ((_DWORD)v2) {
          char v40 = "";
        }
        __int16 v67 = 2082;
        id v68 = id_str;
        __int16 v69 = 2082;
        int v70 = v14;
        __int16 v71 = 2082;
        uint64_t v72 = (void *)v16;
        __int16 v73 = 2082;
        __int16 v74 = v59;
        __int16 v75 = 2082;
        __int16 v76 = v34;
        __int16 v77 = 2114;
        id v78 = v39;
        __int16 v79 = 2082;
        __int16 v80 = v40;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting connection %{public }sidle to protocols",  buf,  0x52u);
      }
    }

    goto LABEL_47;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v21 = (id)gLogObj;
  uint64_t v22 = v4;
  else {
    os_log_type_t v23 = off_189BBBBC0[mode];
  }
  *(_DWORD *)tcp_info buf = 136446722;
  uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
  __int16 v67 = 2082;
  id v68 = (void *)v23;
  __int16 v69 = 2082;
  int v70 = "flow";
  __int16 v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v63 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (os_log_s *)(id)gLogObj;
    os_log_type_t v26 = type;
    if (os_log_type_enabled(v25, type))
    {
      else {
        os_log_type_t v27 = off_189BBBBC0[mode];
      }
      *(_DWORD *)tcp_info buf = 136446722;
      uint64_t v66 = "nw_endpoint_handler_report_connection_idle";
      __int16 v67 = 2082;
      id v68 = (void *)v27;
      __int16 v69 = 2082;
      int v70 = "flow";
      _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

void sub_181B7E89C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_flow_passthrough_notify( uint64_t a1, nw_protocol *a2, unsigned int a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v9 = a1;
  uint64_t v168 = *MEMORY[0x1895F89C0];
  id v10 = *(id *)(*(void *)(a1 + 40) + 160LL);
  os_log_type_t v11 = v10;
  if (v10)
  {
    os_log_type_t v12 = (NWConcrete_nw_endpoint_handler *)v10;
    uint64_t mode = v12->mode;

    if ((_DWORD)mode != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v14 = (NWConcrete_nw_endpoint_mode_handler *)(id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        else {
          BOOL v17 = off_189BBBBC0[mode];
        }
        *(_DWORD *)tcp_info buf = 136446722;
        nw_endpoint_t v153 = "nw_flow_passthrough_notify";
        __int16 v154 = 2082;
        id v155 = (void *)v17;
        __int16 v156 = 2082;
        nw_endpoint_t v157 = "flow";
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }

      goto LABEL_74;
    }

    BOOL v14 = nw_endpoint_handler_copy_flow(v12);
    nw_endpoint_t v15 = v12;
    int state = v15->state;

    id v146 = v15;
    if (state == 5)
    {
      switch(a3)
      {
        case 7u:
        case 0x15u:
          goto LABEL_74;
        case 0xDu:
        case 0xFu:
        case 0x10u:
          goto LABEL_35;
        case 0x13u:
          goto LABEL_52;
        case 0x16u:
          goto LABEL_37;
        case 0x17u:
          goto LABEL_46;
        case 0x19u:
          goto LABEL_51;
        default:
          goto LABEL_70;
      }

      goto LABEL_74;
    }

    if (nw_endpoint_handler_get_minimize_logging(v15))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_t log = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v15);
        int v128 = nw_endpoint_handler_dry_run_string(v15);
        nw_endpoint_t v141 = nw_endpoint_handler_copy_endpoint(v15);
        logging_description = nw_endpoint_get_logging_description(v141);
        uint64_t v124 = nw_endpoint_handler_state_string(v15);
        int v110 = nw_endpoint_handler_mode_string(v15);
        id v111 = nw_endpoint_handler_copy_current_path(v15);
        BOOL v112 = v111;
        if (a3 > 0x1A) {
          uint64_t v113 = "unknown";
        }
        else {
          uint64_t v113 = off_189BBE330[a3];
        }
        *(_DWORD *)tcp_info buf = 136448002;
        nw_endpoint_t v153 = "nw_flow_passthrough_notify";
        __int16 v154 = 2082;
        id v155 = (void *)id_string;
        __int16 v156 = 2082;
        nw_endpoint_t v157 = v128;
        __int16 v158 = 2082;
        int v159 = logging_description;
        __int16 v160 = 2082;
        id v161 = v124;
        __int16 v162 = 2082;
        int v163 = v110;
        __int16 v164 = 2114;
        id v165 = v111;
        __int16 v166 = 2082;
        __int16 v167 = v113;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received notification %{public}s",  buf,  0x52u);
      }
    }

    else
    {
      os_log_type_t v18 = v15;
      char v19 = *((_BYTE *)v18 + 268);

      if ((v19 & 0x20) != 0)
      {
LABEL_34:
        switch(a3)
        {
          case 7u:
          case 0x15u:
            goto LABEL_74;
          case 0xCu:
            int v75 = *((char *)v14 + 34);
            if ((v75 & 0x80000000) == 0)
            {
              *((_BYTE *)v14 + 34) = v75 | 0x80;
              v146->event = (nw_endpoint_handler_event_s)524291;
              nw_endpoint_handler_report(v146, 0LL, &v146->event.domain, 0LL);
            }

            goto LABEL_70;
          case 0xDu:
          case 0xFu:
          case 0x10u:
LABEL_35:
            uint64_t v38 = *(void *)(v9 + 32);
            if (!v38) {
              goto LABEL_74;
            }
            goto LABEL_71;
          case 0x13u:
LABEL_52:
            nw_endpoint_flow_rebuild_stack(v146, a2);
            goto LABEL_74;
          case 0x16u:
LABEL_37:
            if (*((_DWORD *)v14 + 251) <= 0x13u)
            {
              int minimize_logging = nw_endpoint_handler_get_minimize_logging(v146);
              char logging_disabled = nw_endpoint_handler_get_logging_disabled(v146);
              if (minimize_logging)
              {
                if ((logging_disabled & 1) != 0) {
                  goto LABEL_45;
                }
                uint64_t v114 = v9;
                __int16 v137 = v14;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                uint64_t v41 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
                {
                  os_log_t logc = nw_endpoint_handler_get_id_string(v146);
                  nw_endpoint_t v115 = nw_endpoint_handler_dry_run_string(v146);
                  nw_endpoint_t v116 = nw_endpoint_handler_copy_endpoint(v146);
                  nw_endpoint_t v117 = nw_endpoint_get_logging_description(v116);
                  unsigned int v118 = nw_endpoint_handler_state_string(v146);
                  id v119 = nw_endpoint_handler_mode_string(v146);
                  id v120 = nw_endpoint_handler_copy_current_path(v146);
                  int v121 = *((_DWORD *)v137 + 251);
                  *(_DWORD *)tcp_info buf = 136448002;
                  nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                  __int16 v154 = 2082;
                  id v155 = (void *)logc;
                  __int16 v156 = 2082;
                  nw_endpoint_t v157 = v115;
                  __int16 v158 = 2082;
                  int v159 = v117;
                  __int16 v160 = 2082;
                  id v161 = v118;
                  __int16 v162 = 2082;
                  int v163 = v119;
                  BOOL v14 = v137;
                  __int16 v164 = 2114;
                  id v165 = v120;
                  __int16 v166 = 1024;
                  LODWORD(v167) = v121;
                  _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart wi th count %u, rebuilding stack",  buf,  0x4Eu);

                  uint64_t v9 = v114;
                }
              }

              else
              {
                if ((logging_disabled & 1) != 0)
                {
LABEL_45:
                  ++*((_DWORD *)v14 + 251);
                  nw_endpoint_flow_rebuild_stack(v146, (nw_protocol *)v9);
                  v146->event = (nw_endpoint_handler_event_s)262147;
                  nw_endpoint_handler_report(v146, 0LL, &v146->event.domain, 0LL);
                  goto LABEL_74;
                }

                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                uint64_t v41 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
                {
                  os_log_t loga = v41;
                  uint64_t v42 = nw_endpoint_handler_get_id_string(v146);
                  uint64_t v43 = nw_endpoint_handler_dry_run_string(v146);
                  nw_endpoint_t v44 = nw_endpoint_handler_copy_endpoint(v146);
                  uint64_t v139 = v9;
                  unint64_t v45 = v14;
                  os_log_type_t v46 = nw_endpoint_get_logging_description(v44);
                  uint64_t v47 = nw_endpoint_handler_state_string(v146);
                  BOOL v48 = nw_endpoint_handler_mode_string(v146);
                  id v49 = nw_endpoint_handler_copy_current_path(v146);
                  int v50 = *((_DWORD *)v45 + 251);
                  *(_DWORD *)tcp_info buf = 136448002;
                  nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                  __int16 v154 = 2082;
                  id v155 = (void *)v42;
                  __int16 v156 = 2082;
                  nw_endpoint_t v157 = v43;
                  __int16 v158 = 2082;
                  int v159 = v46;
                  __int16 v160 = 2082;
                  id v161 = v47;
                  __int16 v162 = 2082;
                  int v163 = v48;
                  BOOL v14 = v45;
                  __int16 v164 = 2114;
                  id v165 = v49;
                  __int16 v166 = 1024;
                  LODWORD(v167) = v50;
                  uint64_t v41 = loga;
                  _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart wi th count %u, rebuilding stack",  buf,  0x4Eu);

                  uint64_t v9 = v139;
                }
              }

              goto LABEL_45;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v57 = (id)gconnectionLogObj;
            os_log_type_t v58 = nw_endpoint_handler_get_id_string(v146);
            uint64_t v59 = nw_endpoint_handler_dry_run_string(v146);
            nw_endpoint_t v136 = v14;
            nw_endpoint_t v60 = nw_endpoint_handler_copy_endpoint(v146);
            uint64_t v140 = v9;
            nw_endpoint_t v61 = nw_endpoint_get_logging_description(v60);
            __int128 v62 = nw_endpoint_handler_state_string(v146);
            char v63 = nw_endpoint_handler_mode_string(v146);
            id v64 = nw_endpoint_handler_copy_current_path(v146);
            *(_DWORD *)tcp_info buf = 136447746;
            nw_endpoint_t v153 = "nw_flow_passthrough_notify";
            __int16 v154 = 2082;
            id v155 = (void *)v58;
            __int16 v156 = 2082;
            nw_endpoint_t v157 = v59;
            __int16 v158 = 2082;
            int v159 = v61;
            __int16 v160 = 2082;
            id v161 = v62;
            __int16 v162 = 2082;
            int v163 = v63;
            __int16 v164 = 2114;
            id v165 = v64;
            os_log_type_t v65 = (char *)_os_log_send_and_compose_impl();

            BOOL v14 = v136;
            uint64_t v9 = v140;

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v150 = 0;
            if ((__nwlog_fault(v65, &type, &v150) & 1) == 0) {
              goto LABEL_106;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v66 = (os_log_s *)(id)gconnectionLogObj;
              os_log_type_t v67 = type;
              if (os_log_type_enabled(v66, type))
              {
                os_log_type_t v130 = v65;
                id v68 = nw_endpoint_handler_get_id_string(v146);
                __int16 v69 = nw_endpoint_handler_dry_run_string(v146);
                nw_endpoint_t v70 = nw_endpoint_handler_copy_endpoint(v146);
                __int16 v71 = nw_endpoint_get_logging_description(v70);
                uint64_t v72 = nw_endpoint_handler_state_string(v146);
                __int16 v73 = nw_endpoint_handler_mode_string(v146);
                id v74 = nw_endpoint_handler_copy_current_path(v146);
                *(_DWORD *)tcp_info buf = 136447746;
                nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                __int16 v154 = 2082;
                id v155 = (void *)v68;
                __int16 v156 = 2082;
                nw_endpoint_t v157 = v69;
                __int16 v158 = 2082;
                int v159 = v71;
                __int16 v160 = 2082;
                id v161 = v72;
                __int16 v162 = 2082;
                int v163 = v73;
                __int16 v164 = 2114;
                id v165 = v74;
                _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with out connecting too many times, failing flow",  buf,  0x48u);

                BOOL v14 = v136;
                uint64_t v9 = v140;
                os_log_type_t v65 = v130;
              }
            }

            else if (v150)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                __int16 v84 = (char *)backtrace_string;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                id v85 = (os_log_s *)(id)gconnectionLogObj;
                os_log_type_t v86 = type;
                if (os_log_type_enabled(v85, type))
                {
                  __int16 v131 = v65;
                  os_log_type_t v87 = nw_endpoint_handler_get_id_string(v146);
                  os_log_t logb = nw_endpoint_handler_dry_run_string(v146);
                  nw_endpoint_t v88 = nw_endpoint_handler_copy_endpoint(v146);
                  os_log_type_t v89 = nw_endpoint_get_logging_description(v88);
                  BOOL v90 = nw_endpoint_handler_state_string(v146);
                  os_log_type_t v91 = nw_endpoint_handler_mode_string(v146);
                  id v92 = nw_endpoint_handler_copy_current_path(v146);
                  *(_DWORD *)tcp_info buf = 136448002;
                  nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                  __int16 v154 = 2082;
                  id v155 = (void *)v87;
                  __int16 v156 = 2082;
                  nw_endpoint_t v157 = logb;
                  __int16 v158 = 2082;
                  int v159 = v89;
                  __int16 v160 = 2082;
                  id v161 = v90;
                  __int16 v162 = 2082;
                  int v163 = v91;
                  __int16 v164 = 2114;
                  id v165 = v92;
                  __int16 v166 = 2082;
                  __int16 v167 = v84;
                  _os_log_impl( &dword_181A5C000,  v85,  v86,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart wi thout connecting too many times, failing flow, dumping backtrace:%{public}s",  buf,  0x52u);

                  BOOL v14 = v136;
                  uint64_t v9 = v140;
                  os_log_type_t v65 = v131;
                }

                free(v84);
                goto LABEL_106;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v66 = (os_log_s *)(id)gconnectionLogObj;
              os_log_type_t v102 = type;
              if (os_log_type_enabled(v66, type))
              {
                BOOL v133 = v65;
                unsigned int v103 = nw_endpoint_handler_get_id_string(v146);
                nw_endpoint_t v104 = nw_endpoint_handler_dry_run_string(v146);
                nw_endpoint_t v105 = nw_endpoint_handler_copy_endpoint(v146);
                BOOL v106 = nw_endpoint_get_logging_description(v105);
                __int16 v107 = nw_endpoint_handler_state_string(v146);
                __int16 v108 = nw_endpoint_handler_mode_string(v146);
                id v109 = nw_endpoint_handler_copy_current_path(v146);
                *(_DWORD *)tcp_info buf = 136447746;
                nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                __int16 v154 = 2082;
                id v155 = (void *)v103;
                __int16 v156 = 2082;
                nw_endpoint_t v157 = v104;
                __int16 v158 = 2082;
                int v159 = v106;
                __int16 v160 = 2082;
                id v161 = v107;
                __int16 v162 = 2082;
                int v163 = v108;
                __int16 v164 = 2114;
                id v165 = v109;
                _os_log_impl( &dword_181A5C000,  v66,  v102,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with out connecting too many times, failing flow, no backtrace",  buf,  0x48u);

                BOOL v14 = v136;
                uint64_t v9 = v140;
                os_log_type_t v65 = v133;
              }
            }

            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              uint64_t v66 = (os_log_s *)(id)gconnectionLogObj;
              os_log_type_t v94 = type;
              if (os_log_type_enabled(v66, type))
              {
                os_log_type_t v132 = v65;
                nw_endpoint_t v95 = nw_endpoint_handler_get_id_string(v146);
                char v96 = nw_endpoint_handler_dry_run_string(v146);
                nw_endpoint_t v97 = nw_endpoint_handler_copy_endpoint(v146);
                os_log_type_t v98 = nw_endpoint_get_logging_description(v97);
                id v99 = nw_endpoint_handler_state_string(v146);
                nw_endpoint_type_t v100 = nw_endpoint_handler_mode_string(v146);
                id v101 = nw_endpoint_handler_copy_current_path(v146);
                *(_DWORD *)tcp_info buf = 136447746;
                nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                __int16 v154 = 2082;
                id v155 = (void *)v95;
                __int16 v156 = 2082;
                nw_endpoint_t v157 = v96;
                __int16 v158 = 2082;
                int v159 = v98;
                __int16 v160 = 2082;
                id v161 = v99;
                __int16 v162 = 2082;
                int v163 = v100;
                __int16 v164 = 2114;
                id v165 = v101;
                _os_log_impl( &dword_181A5C000,  v66,  v94,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with out connecting too many times, failing flow, backtrace limit exceeded",  buf,  0x48u);

                BOOL v14 = v136;
                uint64_t v9 = v140;
                os_log_type_t v65 = v132;
              }
            }

LABEL_106:
            if (v65) {
              free(v65);
            }
LABEL_108:
            nw_protocol_disconnected((void *)v9, *(void *)(v9 + 32));
LABEL_74:

            goto LABEL_75;
          case 0x17u:
LABEL_46:
            if (a4 && a5 == 1)
            {
              int v51 = *a4;
              char v52 = *((_BYTE *)v14 + 35);
              *((_BYTE *)v14 + 35) = v52 & 0xEF | (16 * v51);
              if (!v51 && (v52 & 8) != 0)
              {
                *((_BYTE *)v14 + 35) = v52 & 0xE7 | (16 * v51);
                nw_endpoint_flow_start_child(v146);
              }

              goto LABEL_74;
            }

            __nwlog_obj();
            id v53 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)tcp_info buf = 136446210;
            nw_endpoint_t v153 = "nw_flow_passthrough_notify";
            unint64_t v54 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v150 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v56 = type;
              if (os_log_type_enabled(v55, type))
              {
                *(_DWORD *)tcp_info buf = 136446210;
                nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child",  buf,  0xCu);
              }
            }

            else
            {
              if (v150)
              {
                id v78 = v14;
                __int16 v79 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                __int16 v80 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v81 = type;
                BOOL v82 = os_log_type_enabled(v80, type);
                if (v79)
                {
                  if (v82)
                  {
                    *(_DWORD *)tcp_info buf = 136446466;
                    nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                    __int16 v154 = 2082;
                    id v155 = v79;
                    _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  BOOL v14 = v78;
                  free(v79);
                }

                else
                {
                  if (v82)
                  {
                    *(_DWORD *)tcp_info buf = 136446210;
                    nw_endpoint_t v153 = "nw_flow_passthrough_notify";
                    _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child, no backtrace",  buf,  0xCu);
                  }

                  BOOL v14 = v78;
                }

void sub_181B7FB44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_protocol_common_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)tcp_info buf = 136446210;
    id v39 = "nw_protocol_common_notify";
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v33 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            id v39 = "nw_protocol_common_notify";
            __int16 v40 = 2082;
            uint64_t v41 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v33)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v39 = "nw_protocol_common_notify";
          os_log_type_t v12 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_75;
        }
      }

      else
      {
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v39 = "nw_protocol_common_notify";
          os_log_type_t v12 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_75;
        }
      }

      goto LABEL_76;
    }

    id v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_76;
    }
    *(_DWORD *)tcp_info buf = 136446210;
    id v39 = "nw_protocol_common_notify";
    os_log_type_t v12 = "%{public}s called with null protocol";
LABEL_75:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_76;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)tcp_info buf = 136446210;
    id v39 = "nw_protocol_common_notify";
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v36)
      {
        BOOL v14 = (char *)__nw_create_backtrace_string();
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v34 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v34)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            id v39 = "nw_protocol_common_notify";
            __int16 v40 = 2082;
            uint64_t v41 = v14;
            int v16 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_66;
          }

          goto LABEL_67;
        }

        if (v34)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v39 = "nw_protocol_common_notify";
          os_log_type_t v12 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_75;
        }
      }

      else
      {
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v39 = "nw_protocol_common_notify";
          os_log_type_t v12 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_75;
        }
      }

      goto LABEL_76;
    }

    id v10 = (os_log_s *)__nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_76;
    }
    *(_DWORD *)tcp_info buf = 136446210;
    id v39 = "nw_protocol_common_notify";
    os_log_type_t v12 = "%{public}s called with null other_protocol";
    goto LABEL_75;
  }

  if (a3 <= 0x15)
  {
    if (((1 << a3) & 0x200080) != 0) {
      return;
    }
    if (((1 << a3) & 0x1A000) != 0)
    {
      uint64_t v4 = *(void *)(a1 + 32);
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 24);
        if (!v5) {
          return;
        }
        uint64_t v6 = *(void (**)(uint64_t, uint64_t))(v5 + 160);
        if (!v6) {
          return;
        }
        os_log_type_t v7 = *(void **)(v4 + 40);
        if (v7 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v8 = *(void *)(v4 + 88);
          if (v8) {
            *(void *)(v4 + 8_Block_object_dispose(va, 8) = v8 + 1;
          }
        }

        if (*(_UNKNOWN **)(a2 + 40) != &nw_protocol_ref_counted_handle)
        {
          v6(v4, a2);
          goto LABEL_38;
        }

        uint64_t v13 = *(void *)(a2 + 88);
        if (v13) {
          *(void *)(a2 + 8_Block_object_dispose(va, 8) = v13 + 1;
        }
        v6(v4, a2);
        goto LABEL_37;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)tcp_info buf = 136446210;
      id v39 = "nw_protocol_common_notify";
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v36 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)gLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_76;
        }
        *(_DWORD *)tcp_info buf = 136446210;
        id v39 = "nw_protocol_common_notify";
        os_log_type_t v12 = "%{public}s notify requires an output handler";
        goto LABEL_75;
      }

      if (!v36)
      {
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_76;
        }
        *(_DWORD *)tcp_info buf = 136446210;
        id v39 = "nw_protocol_common_notify";
        os_log_type_t v12 = "%{public}s notify requires an output handler, backtrace limit exceeded";
        goto LABEL_75;
      }

      BOOL v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v14)
      {
        if (!v15) {
          goto LABEL_76;
        }
        *(_DWORD *)tcp_info buf = 136446210;
        id v39 = "nw_protocol_common_notify";
        os_log_type_t v12 = "%{public}s notify requires an output handler, no backtrace";
        goto LABEL_75;
      }

      if (v15)
      {
        *(_DWORD *)tcp_info buf = 136446466;
        id v39 = "nw_protocol_common_notify";
        __int16 v40 = 2082;
        uint64_t v41 = v14;
        int v16 = "%{public}s notify requires an output handler, dumping backtrace:%{public}s";
LABEL_66:
        _os_log_impl(&dword_181A5C000, v10, v11, v16, buf, 0x16u);
        goto LABEL_67;
      }

      goto LABEL_67;
    }

    if (!a3)
    {
      __nwlog_obj();
      *(_DWORD *)tcp_info buf = 136446210;
      id v39 = "nw_protocol_common_notify";
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v36 = 0;
      if (__nwlog_fault(v9, &type, &v36))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          id v10 = (os_log_s *)__nwlog_obj();
          os_log_type_t v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            id v39 = "nw_protocol_common_notify";
            os_log_type_t v12 = "%{public}s called with null type";
            goto LABEL_75;
          }
        }

        else if (v36)
        {
          BOOL v14 = (char *)__nw_create_backtrace_string();
          id v10 = (os_log_s *)__nwlog_obj();
          os_log_type_t v11 = type;
          BOOL v35 = os_log_type_enabled(v10, type);
          if (v14)
          {
            if (v35)
            {
              *(_DWORD *)tcp_info buf = 136446466;
              id v39 = "nw_protocol_common_notify";
              __int16 v40 = 2082;
              uint64_t v41 = v14;
              int v16 = "%{public}s called with null type, dumping backtrace:%{public}s";
              goto LABEL_66;
            }

            goto LABEL_67;
          }

          if (v35)
          {
            *(_DWORD *)tcp_info buf = 136446210;
            id v39 = "nw_protocol_common_notify";
            os_log_type_t v12 = "%{public}s called with null type, no backtrace";
            goto LABEL_75;
          }
        }

        else
        {
          id v10 = (os_log_s *)__nwlog_obj();
          os_log_type_t v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            id v39 = "nw_protocol_common_notify";
            os_log_type_t v12 = "%{public}s called with null type, backtrace limit exceeded";
            goto LABEL_75;
          }
        }
      }

BOOL nw_connection_used_fallback(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)tcp_info buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v19 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_used_fallback_block_invoke;
    v13[3] = &unk_189BC9210;
    BOOL v15 = buf;
    BOOL v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_used_fallback_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)tcp_info buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_connection_used_fallback_block_invoke(uint64_t a1)
{
  uint64_t result = nw_connection_used_fallback_locked(*(void **)(a1 + 32));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

void nw_connection_send( nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
  BOOL v6 = is_complete;
  *(void *)&v51[13] = *MEMORY[0x1895F89C0];
  nw_connection_t v9 = connection;
  os_log_type_t v10 = content;
  BOOL v11 = context;
  nw_connection_send_completion_t v12 = completion;
  uint64_t v13 = v12;
  if (!v9)
  {
    __nwlog_obj();
    BOOL v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    id v49 = "nw_connection_send";
    BOOL v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        id v49 = "nw_connection_send";
        _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v32, type);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          id v49 = "nw_connection_send";
          __int16 v50 = 2082;
          *(void *)int v51 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v32,  v37,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_73:
        if (!v31) {
          goto LABEL_39;
        }
        goto LABEL_74;
      }

      if (v38)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        id v49 = "nw_connection_send";
        _os_log_impl(&dword_181A5C000, v32, v37, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        id v49 = "nw_connection_send";
        _os_log_impl( &dword_181A5C000,  v32,  v42,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181B814C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_write_request *nw_write_request_create( void *a1, void *a2, void *a3, int a4, void *a5, void *a6)
{
  uint64_t v75 = *MEMORY[0x1895F89C0];
  id v11 = a1;
  id v12 = a2;
  id v13 = a3;
  os_log_type_t v65 = a5;
  id aBlock = a6;
  id v64 = v13;
  if (!aBlock)
  {
    uint64_t v17 = v11;
    __nwlog_obj();
    nw_endpoint_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    uint64_t v72 = "nw_write_request_create";
    id v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v69 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v72 = "nw_write_request_create";
        _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s called with null completion", buf, 0xCu);
      }

      goto LABEL_122;
    }

    if (!v69)
    {
      __nwlog_obj();
      char v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v61 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v72 = "nw_write_request_create";
        _os_log_impl( &dword_181A5C000,  v46,  v61,  "%{public}s called with null completion, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_122;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v54 = type;
    BOOL v55 = os_log_type_enabled(v46, type);
    if (!backtrace_string)
    {
      if (v55)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v72 = "nw_write_request_create";
        _os_log_impl(&dword_181A5C000, v46, v54, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }

      goto LABEL_122;
    }

    if (v55)
    {
      *(_DWORD *)tcp_info buf = 136446466;
      uint64_t v72 = "nw_write_request_create";
      __int16 v73 = 2082;
      id v74 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v46,  v54,  "%{public}s called with null completion, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_93;
  }

  if (!v12)
  {
    uint64_t v17 = v11;
    __nwlog_obj();
    BOOL v48 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    uint64_t v72 = "nw_write_request_create";
    id v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v69 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v72 = "nw_write_request_create";
        _os_log_impl(&dword_181A5C000, v46, v49, "%{public}s called with null context", buf, 0xCu);
      }

void sub_181B821FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_add_write_request(void *a1, void *a2)
{
  uint64_t v175 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
    uint64_t mode = v5->mode;

    if ((_DWORD)mode == 2)
    {
      os_log_type_t v7 = nw_endpoint_handler_copy_flow(v5);
      if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unsigned int v83 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v5);
          uint64_t v149 = nw_endpoint_handler_dry_run_string(v5);
          nw_endpoint_t v152 = nw_endpoint_handler_copy_endpoint(v5);
          id v85 = id_string;
          logging_description = nw_endpoint_get_logging_description(v152);
          os_log_type_t v87 = nw_endpoint_handler_state_string(v5);
          nw_endpoint_t v88 = nw_endpoint_handler_mode_string(v5);
          id v89 = nw_endpoint_handler_copy_current_path(v5);
          int v90 = (*((unsigned __int8 *)v7 + 35) >> 1) & 1;
          *(_DWORD *)tcp_info buf = 136448002;
          __int16 v156 = "nw_endpoint_handler_add_write_request";
          __int16 v157 = 2082;
          id_str = (char *)v85;
          __int16 v159 = 2082;
          __int16 v160 = v149;
          __int16 v161 = 2082;
          __int16 v162 = (void *)logging_description;
          __int16 v163 = 2082;
          __int16 v164 = v87;
          __int16 v165 = 2082;
          __int16 v166 = v88;
          __int16 v167 = 2114;
          id v168 = v89;
          __int16 v169 = 1024;
          LODWORD(v170) = v90;
          _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connected_child_handles_requests %u",  buf,  0x4Eu);
        }
      }

      if ((*((_BYTE *)v7 + 35) & 2) != 0)
      {
        uint64_t v18 = *((void *)v7 + 117);
        if (!v18)
        {
          os_log_type_t v25 = v5;
          BOOL v26 = (*((_BYTE *)v25 + 268) & 0x20) == 0;

          if (v26)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            double v27 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              nw_endpoint_t v151 = v27;
              char v28 = v25;

              os_log_type_t v29 = v28;
              BOOL v30 = (*((_BYTE *)v25 + 268) & 1) == 0;

              if (v30) {
                id v31 = "";
              }
              else {
                id v31 = "dry-run ";
              }
              nw_endpoint_t v32 = nw_endpoint_handler_copy_endpoint(v29);
              os_log_type_t v33 = nw_endpoint_get_logging_description(v32);
              os_log_type_t v34 = v29;
              os_log_type_t v35 = v34;
              uint64_t v36 = v34[30];
              else {
                BOOL v37 = off_189BBBBF0[v36];
              }

              id v53 = v35;
              os_log_type_t v54 = "path";
              switch(v5->mode)
              {
                case 0:
                  break;
                case 1:
                  os_log_type_t v54 = "resolver";
                  break;
                case 2:
                  os_log_type_t v54 = nw_endpoint_flow_mode_string(v53[31]);
                  break;
                case 3:
                  os_log_type_t v54 = "proxy";
                  break;
                case 4:
                  os_log_type_t v54 = "fallback";
                  break;
                case 5:
                  os_log_type_t v54 = "transform";
                  break;
                default:
                  os_log_type_t v54 = "unknown-mode";
                  break;
              }

              id v148 = v54;

              nw_endpoint_t v60 = v53;
              id v61 = v3;
              os_log_type_t v62 = v7;
              char v63 = v37;
              id v64 = (id *)v60;
              os_log_type_t v65 = v28;
              id v66 = v4;
              nw_endpoint_t v67 = v32;
              id v68 = v33;
              char v69 = v31;
              nw_endpoint_t v70 = v60 + 28;
              os_unfair_lock_lock(v60 + 28);
              id v71 = v64[8];
              uint64_t v72 = v70;
              __int16 v73 = v69;
              id v74 = v68;
              nw_endpoint_t v75 = v67;
              id v4 = v66;
              uint64_t v76 = v65;
              __int16 v77 = v71;
              os_unfair_lock_unlock(v72);

              id v78 = v63;
              os_log_type_t v7 = v62;
              id v3 = v61;
              *(_DWORD *)tcp_info buf = 136447746;
              __int16 v156 = "nw_endpoint_handler_add_write_request";
              __int16 v157 = 2082;
              id_str = v76->id_str;
              __int16 v159 = 2082;
              __int16 v160 = v73;
              __int16 v161 = 2082;
              __int16 v162 = (void *)v74;
              __int16 v163 = 2082;
              __int16 v164 = v78;
              __int16 v165 = 2082;
              __int16 v166 = v148;
              __int16 v167 = 2114;
              id v168 = v77;
              _os_log_impl( &dword_181A5C000,  v151,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot send, no connected handler",  buf,  0x48u);

              goto LABEL_90;
            }

LABEL_131:
            if (v96) {
              free(v96);
            }
            goto LABEL_133;
          }

          os_log_type_t v40 = v5;
          BOOL v41 = (*((_BYTE *)v40 + 268) & 0x20) == 0;

          if (v41)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            double v27 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              nw_endpoint_t v151 = v27;
              os_log_type_t v42 = v40;

              os_log_type_t v43 = v42;
              BOOL v44 = (*((_BYTE *)v40 + 268) & 1) == 0;

              if (v44) {
                id v45 = "";
              }
              else {
                id v45 = "dry-run ";
              }
              nw_endpoint_t v46 = nw_endpoint_handler_copy_endpoint(v43);
              os_log_type_t v47 = nw_endpoint_get_logging_description(v46);
              BOOL v48 = v43;
              os_log_type_t v49 = v48;
              uint64_t v50 = v48[30];
              else {
                os_log_type_t v51 = off_189BBBBF0[v50];
              }
              uint64_t v145 = v51;

              os_log_type_t v56 = v49;
              BOOL v57 = v56;
              int v58 = v5->mode;
              uint64_t v59 = "path";
              switch(v58)
              {
                case 0:
                  break;
                case 1:
                  uint64_t v59 = "resolver";
                  break;
                case 2:
                  uint64_t v59 = nw_endpoint_flow_mode_string(v56[31]);
                  break;
                case 3:
                  uint64_t v59 = "proxy";
                  break;
                case 4:
                  uint64_t v59 = "fallback";
                  break;
                case 5:
                  uint64_t v59 = "transform";
                  break;
                default:
                  uint64_t v59 = "unknown-mode";
                  break;
              }

              __int16 v79 = v57;
              os_unfair_lock_lock((os_unfair_lock_t)v79 + 28);
              id v80 = v79[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v79 + 28);

              *(_DWORD *)tcp_info buf = 136447746;
              __int16 v156 = "nw_endpoint_handler_add_write_request";
              __int16 v157 = 2082;
              id_str = v42->id_str;
              __int16 v159 = 2082;
              __int16 v160 = v45;
              __int16 v161 = 2082;
              __int16 v162 = (void *)v47;
              __int16 v163 = 2082;
              __int16 v164 = v145;
              __int16 v165 = 2082;
              __int16 v166 = v59;
              __int16 v167 = 2114;
              id v168 = v80;
              _os_log_impl( &dword_181A5C000,  v151,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot send after flow table is released",  buf,  0x48u);

LABEL_90:
              uint64_t v24 = 0LL;
LABEL_177:
              double v27 = v151;
              goto LABEL_178;
            }

            goto LABEL_52;
          }

LABEL_132:
          if (v20)
          {
LABEL_133:
            os_log_type_t v65 = (char *)v20;
LABEL_134:
            free(v65);
          }

LABEL_132:
        if (!v16)
        {
LABEL_135:

          goto LABEL_136;
        }

        goto LABEL_133;
      }

      if (!v72)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v56 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          nw_endpoint_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl( &dword_181A5C000,  v17,  v56,  "%{public}s received invalid result type, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_131;
      }

      id v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      BOOL v41 = os_log_type_enabled(v17, type);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          nw_endpoint_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_181A5C000, v17, v40, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }

        goto LABEL_131;
      }

      if (v41)
      {
        *(_DWORD *)tcp_info buf = 136446466;
        nw_endpoint_t v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        uint64_t v76 = 2082;
        *(void *)__int16 v77 = v39;
        _os_log_impl( &dword_181A5C000,  v17,  v40,  "%{public}s received invalid result type, dumping backtrace:%{public}s",  buf,  0x16u);
      }

LABEL_132:
        if (!v16)
        {
LABEL_135:

          goto LABEL_136;
        }

        goto LABEL_133;
      }

      if (!v72)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v56 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          nw_endpoint_t v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl( &dword_181A5C000,  v17,  v56,  "%{public}s received invalid result type, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_131;
      }

      id v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      BOOL v41 = os_log_type_enabled(v17, type);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          nw_endpoint_t v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_181A5C000, v17, v40, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }

        goto LABEL_131;
      }

      if (v41)
      {
        *(_DWORD *)tcp_info buf = 136446466;
        nw_endpoint_t v75 = "networkd_privileged_run_probes_block_invoke";
        uint64_t v76 = 2082;
        *(void *)__int16 v77 = v39;
        _os_log_impl( &dword_181A5C000,  v17,  v40,  "%{public}s received invalid result type, dumping backtrace:%{public}s",  buf,  0x16u);
      }

LABEL_132:
        if (!v17)
        {
LABEL_135:

          goto LABEL_136;
        }

        goto LABEL_133;
      }

      if (!v77)
      {
        __nwlog_obj();
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v59 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl( &dword_181A5C000,  v18,  v59,  "%{public}s received invalid result type, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_131;
      }

      os_log_type_t v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v39 = type;
      os_log_type_t v40 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_181A5C000, v18, v39, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }

        goto LABEL_131;
      }

      if (v40)
      {
        *(_DWORD *)tcp_info buf = 136446466;
        id v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        os_log_type_t v81 = 2082;
        *(void *)os_log_type_t v82 = v38;
        _os_log_impl( &dword_181A5C000,  v18,  v39,  "%{public}s received invalid result type, dumping backtrace:%{public}s",  buf,  0x16u);
      }

LABEL_132:
        if (!v17)
        {
LABEL_135:

          goto LABEL_136;
        }

        goto LABEL_133;
      }

      if (!v77)
      {
        __nwlog_obj();
        uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v59 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl( &dword_181A5C000,  v18,  v59,  "%{public}s received invalid result type, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_131;
      }

      os_log_type_t v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v39 = type;
      os_log_type_t v40 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_181A5C000, v18, v39, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }

        goto LABEL_131;
      }

      if (v40)
      {
        *(_DWORD *)tcp_info buf = 136446466;
        id v80 = "networkd_privileged_set_radio_type_block_invoke";
        os_log_type_t v81 = 2082;
        *(void *)os_log_type_t v82 = v38;
        _os_log_impl( &dword_181A5C000,  v18,  v39,  "%{public}s received invalid result type, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    os_log_type_t v35 = (dispatch_data_t)MEMORY[0x1895F8AA8];
    uint64_t v36 = MEMORY[0x1895F8AA8];
    BOOL v37 = *(const void **)(v12 + 136);
    if (v37)
    {
      os_log_type_t v35 = dispatch_data_create(v37, *(void *)(v12 + 160), 0LL, 0LL);
    }

    unsigned int v103 = 0LL;
    nw_endpoint_t v104 = &v103;
    char v105 = 0x2020000000LL;
    BOOL v106 = 0LL;
    os_log_type_t v38 = *(unsigned __int8 **)(v12 + 104);
    *(void *)tcp_info buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL24nw_ws_process_pong_frameP13nw_ws_state_t_block_invoke;
    *(void *)BOOL v108 = &unk_189BC7960;
    uint64_t metadata = v35;
    *(void *)&v108[8] = metadata;
    *(void *)&v108[16] = &v103;
    if (!nw_array_apply(v38, (uint64_t)buf))
    {
      id v39 = nw_array_create();
      os_log_type_t v40 = 0LL;
      BOOL v41 = *(void **)(v12 + 104);
      if (v41)
      {
        while (1)
        {
          nw_array_get_object_at_index((uint64_t)v41, v40);
          os_log_type_t v42 = (void *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v43 = v42;
          if (v40 <= v104[3]) {
            break;
          }
          BOOL v44 = nw_array_get_object_at_index(*(void *)(v12 + 104), v40);
          nw_array_append(v39, (void *)v44);
LABEL_60:

          ++v40;
          BOOL v41 = *(void **)(v12 + 104);
          if (!v41) {
            goto LABEL_64;
          }
        }

        BOOL v44 = (uint64_t)nw_ws_ping_request_copy_pong_handler(v42);
        id v45 = nw_ws_ping_request_copy_client_queue(v43);
        nw_endpoint_t v46 = (dispatch_queue_s *)v45;
        if (v44 && v45)
        {
          block = MEMORY[0x1895F87A8];
          nw_endpoint_t v116 = 3221225472LL;
          nw_endpoint_t v117 = ___ZL24nw_ws_process_pong_frameP13nw_ws_state_t_block_invoke_2;
          BOOL v118 = &unk_189BC8740;
          id v119 = (os_log_s *)(id)v44;
          dispatch_async(v46, &block);
          os_log_type_t v47 = v119;
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v47 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)id v111 = 136446466;
            BOOL v112 = "nw_ws_process_pong_frame";
            uint64_t v113 = 2082;
            uint64_t v114 = v12 + 275;
            _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s pong handler and client queue should both be nil",  v111,  0x16u);
          }
        }

LABEL_59:
        goto LABEL_60;
      }

  if (v41) {
    free(v41);
  }
LABEL_69:
  char v28 = 1LL;
LABEL_70:

  return v28;
}
}

    if (v39) {
      free(v39);
    }
    goto LABEL_25;
  }

          id v39 = 1LL;
          goto LABEL_132;
        }
}

  os_log_type_t v100 = (sockaddr *)v57;
  if ((*((_BYTE *)v5 + 161) & 4) != 0 && (sc_out_establishment_report = v5->sc_out_establishment_report) != 0LL)
  {
    buffer = 0LL;
    p_buffer = &buffer;
    nw_endpoint_t v116 = 0x2020000000LL;
    nw_endpoint_t v117 = 0;
    id v68 = MEMORY[0x1895F87A8];
    v113[0] = MEMORY[0x1895F87A8];
    v113[1] = 3221225472LL;
    v113[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke;
    v113[3] = &unk_189BBACF0;
    v113[4] = v119;
    char v69 = sc_out_establishment_report;
    nw_endpoint_t v70 = v113;
    id v71 = v45;
    uint64_t v72 = (unsigned __int8 *)*((void *)v69 + 9);
    *(void *)tcp_info buf = v68;
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_establishment_report_enumerate_resolution_reports_block_invoke;
    *(void *)&uint64_t v124 = &unk_189BC8628;
    __int16 v73 = v70;
    *((void *)&v124 + 1) = v73;
    id v74 = v72;
    id v45 = v71;
    nw_array_apply(v74, (uint64_t)buf);

    nw_endpoint_t v75 = *(unsigned __int8 **)(*(void *)&v119[8] + 40LL);
    v112[0] = v68;
    v112[1] = 3221225472LL;
    v112[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_3;
    v112[3] = &unk_189BC50D0;
    v112[4] = &buffer;
    nw_array_apply(v75, (uint64_t)v112);
    uint64_t v76 = *((_WORD *)p_buffer + 12) != 0;
    v58 += *((unsigned __int16 *)p_buffer + 12);
    _Block_object_dispose(&buffer, 8);
  }

  else
  {
    uint64_t v76 = 0;
  }

  __int16 v77 = v58 + 4;
  if ((_WORD)v58 == 0xFFFC)
  {
    __nwlog_obj();
    nw_endpoint_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v95, OS_LOG_TYPE_ERROR);
    *(_DWORD *)tcp_info buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_malloc";
    char v96 = (void *)_os_log_send_and_compose_impl();

    free(v96);
  }

  id v78 = malloc((unsigned __int16)(v58 + 4));
  if (v78)
  {
LABEL_137:
    buffer = 0LL;
    p_buffer = &buffer;
    nw_endpoint_t v116 = 0x2020000000LL;
    const char *v78 = (v102 << 16) | (v45 << 24) | (bswap32(v58 + 2) >> 16);
    __int16 v79 = 4;
    nw_endpoint_t v117 = 4;
    if ((unsigned __int16)(v58 + 4) >= 5u && BYTE4(v101))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v80 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)tcp_info buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&_BYTE buf[22] = 2082;
        *(void *)&uint64_t v124 = "path_flags";
        WORD4(v124) = 1024;
        *(_DWORD *)((char *)&v124 + 10) = BYTE4(v101);
        _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ sending reply tlv: %{public}s(%#x)",  buf,  0x26u);
      }

      os_log_type_t v81 = nw_shoes_add_tlv( (uint64_t)v78 + *((unsigned __int16 *)p_buffer + 12),  (unsigned __int16)(v77 - *((_WORD *)p_buffer + 12)),  4u,  1uLL,  &__src);
      __int16 v79 = *((_WORD *)p_buffer + 12) + v81;
      *((_WORD *)p_buffer + 12) = v79;
    }

    os_log_type_t v82 = v79 >= v77;
    unsigned int v83 = v101;
    if (v82) {
      unsigned int v83 = 0;
    }
    if (v83 == 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v84 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v84, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)tcp_info buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&_BYTE buf[22] = 2082;
        *(void *)&uint64_t v124 = "connected_endpoint";
        _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ sending reply tlv: %{public}s",  buf,  0x20u);
      }

      id v85 = nw_shoes_add_tlv( (uint64_t)v78 + *((unsigned __int16 *)p_buffer + 12),  (unsigned __int16)(v77 - *((_WORD *)p_buffer + 12)),  7u,  v100->sa_len,  v100);
      *((_WORD *)p_buffer + 12) += v85;
    }

    if (v76)
    {
      os_log_type_t v86 = *(unsigned __int8 **)(*(void *)&v119[8] + 40LL);
      v107[0] = MEMORY[0x1895F87A8];
      v107[1] = 3221225472LL;
      v107[2] = ___ZL40nw_socks5_connection_send_reply_on_queueP31NWConcrete_nw_socks5_connectionbU13block_pointerFvbE_block_invoke_166;
      v107[3] = &unk_189BB8300;
      id v109 = &buffer;
      id v111 = v58 + 4;
      BOOL v108 = v5;
      nw_endpoint_t v110 = v78;
      nw_array_apply(v86, (uint64_t)v107);
    }

    os_log_type_t v21 = dispatch_data_create(v78, (unsigned __int16)(v58 + 4), 0LL, (dispatch_block_t)*MEMORY[0x1895F8A88]);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v87 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v87, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)tcp_info buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v5;
      *(_WORD *)&_BYTE buf[22] = 2112;
      *(void *)&uint64_t v124 = v21;
      _os_log_impl(&dword_181A5C000, v87, OS_LOG_TYPE_INFO, "%{public}s %{public}@ sending SHOES %@", buf, 0x20u);
    }

    _Block_object_dispose(&buffer, 8);
    if (v21) {
      goto LABEL_153;
    }
    goto LABEL_158;
  }

  __nwlog_obj();
  os_log_type_t v98 = v45;
  id v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v99, OS_LOG_TYPE_ERROR);
  *(_DWORD *)tcp_info buf = 136446466;
  *(void *)&uint8_t buf[4] = "strict_malloc";
  *(_WORD *)&_BYTE buf[12] = 2048;
  *(void *)&buf[14] = (unsigned __int16)(v58 + 4);
  nw_endpoint_t v97 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v97))
  {
    free(v97);
    id v45 = v98;
    goto LABEL_137;
  }

    goto LABEL_132;
  }

  BOOL v6 = nw_parameters_create();
  if (v6)
  {
    os_log_type_t v7 = (void *)nw_protocol_boringssl_copy_definition();
    options = nw_protocol_create_options(v7);

    if (options)
    {
      if (nw_parameters_add_protocol_stack_member(v6, 4, 0, options))
      {

LABEL_11:
        nw_connection_t v9 = nw_protocol_create_options((void *)g_tcp_definition);
        if (v9)
        {
          if (nw_parameters_add_protocol_stack_member(v6, 3, 0, v9))
          {
            *((_BYTE *)v6 + 92) = 2;
            os_log_type_t v10 = v6;
            goto LABEL_80;
          }

        free(v41);
        goto LABEL_132;
      }

      if (v55)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl( &dword_181A5C000,  v42,  v54,  "%{public}s called with null (configure_udp != (_nw_parameters_configure_protocol_disable)), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v58 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        os_log_type_t v62 = "nw_parameters_create_secure_udp";
        _os_log_impl( &dword_181A5C000,  v42,  v58,  "%{public}s called with null (configure_udp != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_132;
  }

  os_log_type_t v10 = v7;
  id v11 = v10;
  if (!v8)
  {
    __nwlog_obj();
    BOOL v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
    id v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v58 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
        _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v58)
    {
      os_log_type_t v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v43 = type;
      BOOL v44 = os_log_type_enabled(v32, type);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v42;
          _os_log_impl( &dword_181A5C000,  v32,  v43,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v42);
        goto LABEL_127;
      }

      if (v44)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
        _os_log_impl(&dword_181A5C000, v32, v43, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_transaction_metadata_increment_inbound_body_size";
        _os_log_impl( &dword_181A5C000,  v32,  v54,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }

        if (!v53)
        {
LABEL_133:
          os_log_type_t v21 = 0LL;
          goto LABEL_45;
        }

      free(v51);
      goto LABEL_132;
    }

    __nwlog_obj();
    *(_DWORD *)tcp_info buf = 136446210;
    BOOL v101 = "nw_webtransport_http3_get_quic_stream_id";
    os_log_type_t v51 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v98 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v52 = (os_log_s *)__nwlog_obj();
      id v53 = type;
      if (!os_log_type_enabled(v52, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      BOOL v101 = "nw_webtransport_http3_get_quic_stream_id";
      os_log_type_t v54 = "%{public}s called with null webtransport_session";
    }

    else
    {
      if (!v98)
      {
        BOOL v52 = (os_log_s *)__nwlog_obj();
        id v53 = type;
        if (!os_log_type_enabled(v52, type)) {
          goto LABEL_130;
        }
        *(_DWORD *)tcp_info buf = 136446210;
        BOOL v101 = "nw_webtransport_http3_get_quic_stream_id";
        os_log_type_t v54 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_129;
      }

      BOOL v57 = (char *)__nw_create_backtrace_string();
      BOOL v52 = (os_log_s *)__nwlog_obj();
      id v53 = type;
      int v58 = os_log_type_enabled(v52, type);
      if (v57)
      {
        if (v58)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          BOOL v101 = "nw_webtransport_http3_get_quic_stream_id";
          os_log_type_t v102 = 2082;
          unsigned int v103 = v57;
          _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v57);
        if (!v51) {
          goto LABEL_132;
        }
        goto LABEL_131;
      }

      if (!v58) {
        goto LABEL_130;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      BOOL v101 = "nw_webtransport_http3_get_quic_stream_id";
      os_log_type_t v54 = "%{public}s called with null webtransport_session, no backtrace";
    }

      if (v35) {
        free(v35);
      }
      return 1LL;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = handle + 205;
    *(_DWORD *)tcp_info buf = 136446722;
    id v64 = "nw_protocol_http2_transport_connect";
    os_log_type_t v65 = 2082;
    id v66 = handle + 205;
    nw_endpoint_t v67 = 2048;
    *(void *)id v68 = a2;
    uint64_t v19 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v61 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      dispatch_qos_class_t v20 = (os_log_s *)gLogObj;
      os_log_type_t v21 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
LABEL_28:
        *(_DWORD *)tcp_info buf = 136446722;
        id v64 = "nw_protocol_http2_transport_connect";
        os_log_type_t v65 = 2082;
        id v66 = v18;
        nw_endpoint_t v67 = 2048;
        *(void *)id v68 = a2;
        BOOL v22 = "%{public}s %{public}s hash node for protocol %p did not have stream as extra";
LABEL_50:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0x20u);
      }

  os_log_type_t v87 = *(void *)(v12 + 616);
  nw_endpoint_t v88 = *(void *)(v12 + 632);
  BOOL v26 = (unsigned __int16 *)(v12 + 872);
  id v89 = *v230 & 0x204;
  if ((*v230 & 0x2000) != 0)
  {
    os_log_type_t v100 = v87 | v88;
    BOOL v101 = (v87 | v88) == 0;
    os_log_type_t v102 = ((*(unsigned __int16 *)(v12 + 872) | (*(unsigned __int8 *)(v12 + 874) << 16)) >> 9) & 1;
    if (v89 == 4) {
      os_log_type_t v102 = 1;
    }
    a3 = v229;
    uint64_t v5 = v228;
    if (v100 || !v102)
    {
      if (v89 == 4) {
        goto LABEL_170;
      }
      if (!v101) {
        goto LABEL_170;
      }
      *(_DWORD *)(v12 + 864) = 5;
      if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
        goto LABEL_170;
      }
      int v90 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_170;
      }
      BOOL v106 = *(void *)(v12 + 488);
      __int16 v107 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
      BOOL v108 = *(_DWORD *)(v12 + 860);
      if (v106) {
        LODWORD(v106) = *(_DWORD *)(v106 + 424);
      }
      *(_DWORD *)tcp_info buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&_BYTE buf[22] = 2080;
      *(void *)&_BYTE buf[24] = " ";
      *(_WORD *)&_BYTE buf[32] = 1024;
      *(_DWORD *)&buf[34] = v107;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v108;
      *(_WORD *)v236 = 1024;
      *(_DWORD *)&v236[2] = v106;
      os_log_type_t v94 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: connection error";
    }

    else
    {
      *(_DWORD *)(v12 + 864) = 4;
      if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
        goto LABEL_170;
      }
      int v90 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_170;
      }
      unsigned int v103 = *(void *)(v12 + 488);
      nw_endpoint_t v104 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
      char v105 = *(_DWORD *)(v12 + 860);
      if (v103) {
        LODWORD(v103) = *(_DWORD *)(v103 + 424);
      }
      *(_DWORD *)tcp_info buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_http1_update_connection_input_state";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&_BYTE buf[22] = 2080;
      *(void *)&_BYTE buf[24] = " ";
      *(_WORD *)&_BYTE buf[32] = 1024;
      *(_DWORD *)&buf[34] = v104;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v105;
      *(_WORD *)v236 = 1024;
      *(_DWORD *)&v236[2] = v103;
      os_log_type_t v94 = "%{public}s %{public}s%s<i%u:c%u:s%u> connection input state: connection complete";
    }

    if (!v51) {
      goto LABEL_93;
    }
    int v58 = (char *)v51;
    goto LABEL_92;
  }

  *(void *)(v6 + 24) = v17;
  os_log_type_t v7 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  if ((*(_WORD *)(v7 + 428) & 0x100) != 0) {
    goto LABEL_29;
  }
LABEL_110:
  id v64 = *(void **)(v7 + 352);
  os_log_type_t v65 = nw_frame_unclaimed_length((_DWORD *)a2);
  nw_http_transaction_metadata_increment_outbound_body_transfer_size(v64, v65);
  id v66 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  nw_endpoint_t v67 = (const char *)nw_frame_unclaimed_length((_DWORD *)a2);
  id v68 = *(void *)(v66 + 176);
  *(void *)(v66 + 176) = &v67[v68];
  if (__CFADD__(v68, v67))
  {
    if (gLogDatapath)
    {
      BOOL v108 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
      {
        id v109 = *(void *)(v66 + 176);
        *(_DWORD *)tcp_info buf = 136446978;
        uint64_t v140 = "increment_outbound_body_size";
        nw_endpoint_t v141 = 2082;
        id v142 = "outbound_body_size";
        int v143 = 2048;
        nw_endpoint_t v144 = v67;
        uint64_t v145 = 2048;
        *(void *)id v146 = v109;
        _os_log_impl( &dword_181A5C000,  v108,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
      }
    }

    *(void *)(v66 + 176) = -1LL;
  }

  char v69 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  *(_WORD *)(v69 + 428) |= 0x400u;
  nw_endpoint_t v70 = *(void *)(*(void *)(*(void *)(a1[5] + 8LL) + 24LL) + 256LL);
  *(_WORD *)(v70 + 872) |= 0x20u;
  nw_http_transaction_metadata_mark_outbound_message_end(*(void **)(*(void *)(*(void *)(a1[5] + 8LL) + 24LL) + 352LL));
  id v71 = a1[5];
  uint64_t v72 = *(void *)(*(void *)(v71 + 8) + 24LL);
  if (!*(_BYTE *)(v72 + 168) || *(void *)(v72 + 160) == *(void *)(v72 + 176)) {
    return 1LL;
  }
  if ((*(_BYTE *)(v72 + 158) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v74 = (os_log_s *)gLogObj;
    nw_endpoint_t v75 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    id v71 = a1[5];
    if (v75)
    {
      uint64_t v76 = *(void *)(*(void *)(v71 + 8) + 24LL);
      __int16 v77 = (const char *)(v76 + 74);
      id v78 = *(void *)(v76 + 256);
      if (v78) {
        LODWORD(v7_Block_object_dispose(va, 8) = *(_DWORD *)(v78 + 860);
      }
      __int16 v79 = *(_DWORD *)(*(void *)(v76 + 248) + 372LL);
      id v80 = *(_DWORD *)(v76 + 424);
      if (*(_BYTE *)(v76 + 168)) {
        os_log_type_t v81 = *(void *)(v76 + 160);
      }
      else {
        os_log_type_t v81 = -1LL;
      }
      os_log_type_t v82 = *(void *)(v76 + 176);
      *(_DWORD *)tcp_info buf = 136448002;
      uint64_t v140 = "nw_protocol_http1_finalize_output_frames_block_invoke";
      nw_endpoint_t v141 = 2082;
      id v142 = v77;
      int v143 = 2080;
      nw_endpoint_t v144 = " ";
      uint64_t v145 = 1024;
      *(_DWORD *)id v146 = v79;
      *(_WORD *)&v146[4] = 1024;
      *(_DWORD *)&v146[6] = v78;
      LOWORD(v147) = 1024;
      *(_DWORD *)((char *)&v147 + 2) = v80;
      HIWORD(v147) = 2048;
      id v148 = v81;
      uint64_t v149 = 2048;
      char v150 = v82;
      _os_log_impl( &dword_181A5C000,  v74,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> Content length header %llu does not equal body size %llu",  buf,  0x46u);
      id v71 = a1[5];
    }
  }

  nw_protocol_error( *(void **)(*(void *)(*(void *)(v71 + 8) + 24LL) + 48LL),  *(void *)(*(void *)(v71 + 8) + 24LL));
  unsigned int v83 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  nw_protocol_disconnected(*(void **)(v83 + 48), v83);
  return 0LL;
}

    free(v53);
    if (!v44) {
      return 0LL;
    }
    goto LABEL_152;
  }

  os_log_type_t v8 = strlen(a1);
  if (!v8)
  {
    id v13 = 0;
    id v11 = 0;
    BOOL v14 = 0;
    id v12 = 0;
    BOOL v15 = 0LL;
    goto LABEL_12;
  }

  nw_connection_t v9 = *(unsigned __int8 *)a1;
  os_log_type_t v10 = (v9 - 46);
  if (((1LL << (v9 - 46)) & 0x1F8000001F80000LL) == 0)
  {
    double v27 = 0LL;
    if (v10 == 12)
    {
      id v12 = 0;
      id v11 = 1;
      goto LABEL_9;
    }

          if (*(_DWORD *)(a2 + 144))
          {
            if ((unint64_t)v13 > 0x62
              || (__int16 v166 = v9,
                  os_log_type_t v87 = 4LL * (*(_DWORD *)a1 & 1),
                  nw_endpoint_t v88 = &(&static_table)[3 * v13],
                  int v90 = *((unsigned int *)v88 + 4),
                  id v89 = *((unsigned int *)v88 + 5),
                  __int16 v165 = (v89 + v90),
                  (os_log_type_t v91 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 40) + 8LL))( *(void *)(a2 + 32),  0LL,  v165 + v87)) == 0))
            {
              __int16 v161 = 3585;
LABEL_277:
              os_log_type_t v10 = v7;
              id v4 = __src;
              goto LABEL_349;
            }

            os_log_type_t v92 = (_DWORD *)v91;
            __int16 v164 = v8;
            *(_BYTE *)(v91 + 35) = v87;
            *(_BYTE *)(v91 + 31) = v13;
            *(_BYTE *)(v91 + 33) |= 0x3Au;
            *(_WORD *)(v91 + 24) = v90;
            *(_WORD *)(v91 + 26) = v89;
            *(_DWORD *)(v91 + _Block_object_dispose(va, 8) = name_hashes[v13];
            *(_DWORD *)(v91 + 12) = nameval_hashes[v13];
            BOOL v93 = (char *)(*(void *)v91 + *(int *)(v91 + 16));
            memcpy(v93, (&static_table)[3 * v13], v90);
            os_log_type_t v94 = &v93[v90];
            if ((_DWORD)v87)
            {
              *(_WORD *)os_log_type_t v94 = 8250;
              v94 += 2;
            }

            v92[5] = (unsigned __int16)((_WORD)v94 - *v92);
            memcpy(v94, (&static_table)[3 * v13 + 1], v89);
            if ((_DWORD)v87) {
              *(_WORD *)&v94[v89] = 2573;
            }
            id v4 = __src;
            if ((*(unsigned int (**)(void, _DWORD *))(*(void *)(a1 + 40) + 16LL))( *(void *)(a2 + 32),  v92))
            {
LABEL_250:
              __int16 v161 = 3585;
              goto LABEL_348;
            }

            *(_DWORD *)(a1 + 28) += v165;
            nw_connection_t v9 = v166;
            os_log_type_t v8 = v164;
          }

          else
          {
            nw_endpoint_t v95 = *(_DWORD *)(a1 + 20);
            if (v95) {
              char v96 = (2 * v95 - (int)v13 + *(_DWORD *)(a2 + 68)) % (2 * v95);
            }
            else {
              char v96 = 0;
            }
            id v4 = __src;
            nw_endpoint_t v97 = header_out_dynamic_entry((unsigned int *)a1, a2, v96);
            os_log_type_t v98 = *(_DWORD *)(a2 + 104);
            if ((v98 & 2) != 0)
            {
              *(_DWORD *)(a2 + 104) = v98 | (32 * (*(_DWORD *)(a2 + 64) == v96));
              if (v97) {
                goto LABEL_250;
              }
            }

            else
            {
              *(_DWORD *)(a2 + 104) = v98 | 0x40;
              if (v97) {
                goto LABEL_250;
              }
            }
          }
        }

        else
        {
          if ((v11 & 0x40) != 0)
          {
            *(_DWORD *)(a2 + 14_Block_object_dispose(va, 8) = v11 & 0x20;
            *(_DWORD *)(a2 + 144) = *v10 & 0x10;
            *(_DWORD *)(a2 + 160) = 0;
            *(_DWORD *)(a2 + 136) = 3;
            nw_connection_t v9 = 4LL;
LABEL_102:
            os_log_type_t v7 = v10 + 1;
            id v66 = *v10;
            nw_endpoint_t v67 = ~(-1 << v9);
            uint64_t v19 = v66 & v67;
            if ((v66 & v67) >= v67)
            {
              BOOL v14 = 0;
              uint64_t v18 = 1;
              do
              {
                if (v7 >= v8)
                {
                  if ((v18 & 1) != 0) {
                    id v142 = 0;
                  }
                  else {
                    id v142 = *(_DWORD *)(a2 + 168);
                  }
                  char v150 = v142 + (_DWORD)v7 - (_DWORD)v10;
                  if (v150 < 0xB)
                  {
                    *(void *)(a2 + 176) = v19;
                    goto LABEL_327;
                  }

                  __int16 v161 = 3621;
                  goto LABEL_349;
                }

                free(v44);
                goto LABEL_132;
              }

              if (v53)
              {
                *(_DWORD *)tcp_info buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_path_parse_necp_client_id";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v22 + 5;
                *(_WORD *)&_BYTE buf[22] = 2048;
                char v153 = v18;
                __int16 v154 = 2048;
                *(void *)id v155 = v6;
                _os_log_impl( &dword_181A5C000,  v45,  v52,  "%{public}s TLV length (%zu) at offset %zu goes beyond total length (%zu), no backtrace",  buf,  0x2Au);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v45 = (os_log_s *)(id)gLogObj;
              os_log_type_t v62 = type;
              if (os_log_type_enabled(v45, type))
              {
                *(_DWORD *)tcp_info buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_path_parse_necp_client_id";
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v22 + 5;
                *(_WORD *)&_BYTE buf[22] = 2048;
                char v153 = v18;
                __int16 v154 = 2048;
                *(void *)id v155 = v6;
                _os_log_impl( &dword_181A5C000,  v45,  v62,  "%{public}s TLV length (%zu) at offset %zu goes beyond total length (%zu), backtrace limit exceeded",  buf,  0x2Au);
              }
            }

    if (!v30) {
      return;
    }
    goto LABEL_132;
  }

  if (a2)
  {
    BOOL v6 = *(unsigned __int16 *)(a2 + 188);
    if ((v6 & 4) == 0)
    {
      if (((v6 | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v7 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          nw_connection_t v9 = *(_DWORD *)(a2 + 176);
          os_log_type_t v8 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)tcp_info buf = 136447234;
          uint64_t v72 = "nw_http2_protocol_close";
          __int16 v73 = 2082;
          id v74 = (void *)(a2 + 191);
          nw_endpoint_t v75 = 2080;
          uint64_t v76 = " ";
          __int16 v77 = 1024;
          id v78 = v8;
          __int16 v79 = 1024;
          LODWORD(v80[0]) = v9;
          os_log_type_t v10 = "%{public}s %{public}s%s<i%u:s%d> protocol already closed, skipping callbacks";
          id v11 = (os_log_s *)v7;
          id v12 = 44;
LABEL_111:
          _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, v10, buf, v12);
          return;
        }
      }

      return;
    }

    id v13 = v6 & 0xFFFFFFFB | (*(unsigned __int8 *)(a2 + 190) << 16);
    *(_WORD *)(a2 + 18_Block_object_dispose(va, 8) = v6 & 0xFFFB;
    *(_BYTE *)(a2 + 190) = BYTE2(v13);
  }

        if (capsule_handling_disabled) {
          nw_endpoint_t v95 = 0x10000;
        }
        else {
          nw_endpoint_t v95 = 0;
        }
        char v96 = (*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0xFFFEFFFF;
        *(_WORD *)(v56 + 18_Block_object_dispose(va, 8) = *(_WORD *)(v56 + 188);
        *(_BYTE *)(v56 + 190) = (v96 | v95) >> 16;
        singleton = v186;
        if (!v186)
        {
          if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_59_74543);
          }
          singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_transaction_definition_definition);
        }

        *(void *)(v56 + 96) = singleton;
        if (v28)
        {
          nw_http_transaction_metadata_set_first_on_connection(singleton);
          singleton = *(id **)(v56 + 96);
        }

        nw_http_transaction_metadata_set_connection_metadata(singleton, *((void **)handle + 32));
        if (((*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0x80000) == 0
          && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v175 = (os_log_s *)gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            char v177 = *(_DWORD *)(v56 + 176);
            char v176 = *(_DWORD *)(v56 + 180);
            identifier = a2->identifier;
            *(_DWORD *)tcp_info buf = 136448002;
            id v191 = "nw_protocol_http2_add_input_handler";
            __int16 v192 = 2082;
            id v193 = v56 + 191;
            __int16 v194 = 2080;
            nw_endpoint_t v195 = (uint64_t)" ";
            uint64_t v196 = 1024;
            nw_endpoint_t v197 = v176;
            os_log_type_t v198 = 1024;
            *(_DWORD *)id v199 = v177;
            *(_WORD *)&v199[4] = 2048;
            *(void *)&v199[6] = a2;
            *(_WORD *)&v199[14] = 2080;
            *(void *)&v199[16] = identifier;
            *(_WORD *)&v199[24] = 2048;
            *(void *)id v200 = v53;
            _os_log_impl( &dword_181A5C000,  v175,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> setting input protocol %p (%s) output_handler_context to %p",  buf,  0x4Au);
          }
        }

        a2->output_handler_context = v53;
        nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
        if (a1->default_input_handler)
        {
          if (!v28) {
            goto LABEL_147;
          }
        }

        else
        {
          nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
          *(_OWORD *)uint64_t handle = *(_OWORD *)a2->flow_id;
          if (!v28) {
            goto LABEL_147;
          }
        }

        if (!*((void *)handle + 36))
        {
          os_log_type_t v130 = object;
          __int16 v131 = *(id *)(v130[13] + 136LL);

          os_log_type_t v132 = (void *)*((void *)handle + 35);
          if (v132)
          {
            os_release(v132);
            *((void *)handle + 35) = 0LL;
          }

          id v133 = nw_path_copy_flow_registration(v131, (uint64_t)handle);
          *((void *)handle + 35) = v133;
          if (v131)
          {
            os_release(v131);
            id v133 = (id)*((void *)handle + 35);
          }

          if (v133)
          {
            id v134 = nw_path_flow_registration_copy_endpoint(v133);
            __int16 v135 = nw_path_flow_registration_copy_parameters(*((void **)handle + 35));
            nw_endpoint_t v136 = nw_endpoint_copy_association_with_evaluator(v134, v135, 0LL);
            *((void *)handle + 36) = v136;
            if (v134)
            {
              os_release(v134);
              nw_endpoint_t v136 = (id *)*((void *)handle + 36);
            }

            if (v136)
            {
              nw_endpoint_t v137 = nw_protocol_instance_stub_create((nw_protocol *)handle);
              *((void *)handle + 37) = v137;
              nw_association_register_internal( *((void **)handle + 36),  v130,  v137,  0,  0,  &__block_literal_global_53_83388);
              uint64_t v138 = nw_association_copy_current_path(*((void **)handle + 36), v135);
              if (v138)
              {
                uint64_t v139 = v138;
                uint64_t v140 = nw_path_copy_for_flow_registration(v138, *((void **)handle + 35));
                if (v140)
                {
                  nw_endpoint_t v141 = (void *)v140;
                  id v142 = (void *)*((void *)handle + 15);
                  if (v142 != v141)
                  {
                    if (v142)
                    {
                      os_release(v142);
                      *((void *)handle + 15) = 0LL;
                    }

                    *((void *)handle + 15) = os_retain(v141);
                  }

                  if (nw_path_has_flows(v141)) {
                    int v143 = 32;
                  }
                  else {
                    int v143 = 0;
                  }
                  handle[194] = handle[194] & 0xFFDF | v143;
                  nw_endpoint_t v144 = nw_parameters_copy_effective_proxy_config(v130);
                  if (v144)
                  {
                    uint64_t v145 = v144;
                    if (nw_path_has_proxy_config(v139, v144))
                    {
                      id v146 = (void *)*((void *)handle + 38);
                      if (v146) {
                        os_release(v146);
                      }
                      *((void *)handle + 3_Block_object_dispose(va, 8) = v145;
                    }

                    else
                    {
                      os_release(v145);
                    }
                  }

                  os_release(v139);
                }

                else
                {
                  nw_endpoint_t v141 = v139;
                }

                os_release(v141);
              }
            }

            if (v135) {
              os_release(v135);
            }
          }
        }

          if (v92) {
            free(v92);
          }
          os_log_type_t v16 = 0;
          if (v12 != &nw_protocol_ref_counted_handle)
          {
LABEL_15:
            if (v10 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v7 + 40) == &nw_protocol_ref_counted_handle)
            {
              os_log_type_t v43 = *(void *)(v7 + 88);
              if (v43)
              {
                BOOL v44 = v43 - 1;
                *(void *)(v7 + 8_Block_object_dispose(va, 8) = v44;
                if (!v44)
                {
                  id v45 = *(void (***)(void))(v7 + 64);
                  if (v45)
                  {
                    *(void *)(v7 + 64) = 0LL;
                    v45[2](v45);
                    _Block_release(v45);
                  }

                  if ((*(_BYTE *)(v7 + 72) & 1) != 0)
                  {
                    nw_endpoint_t v46 = *(const void **)(v7 + 64);
                    if (v46) {
                      _Block_release(v46);
                    }
                  }

                  free((void *)v7);
                }
              }
            }

            if (v16)
            {
              uint64_t v17 = 0;
              uint64_t v18 = v111;
              uint64_t v19 = v107[0];
              while (v19)
              {
                uint64_t v23 = *(_DWORD *)(v19 + 52);
                if (v23) {
                  v23 -= *(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60);
                }
                uint64_t v19 = *(void *)(v19 + 32);
                dispatch_qos_class_t v20 = __CFADD__(v17, v23);
                os_log_type_t v21 = v17 + v23;
                v17 += v23;
                if (v20) {
                  BOOL v22 = -1;
                }
                else {
                  BOOL v22 = v21;
                }
                if (v22 >= v111) {
                  goto LABEL_34;
                }
              }

              if (v17 < v111) {
                goto LABEL_27;
              }
LABEL_34:
              if ((a3[17] & 1) == 0)
              {
                if (gLogDatapath)
                {
                  uint64_t v72 = (os_log_s *)__nwlog_obj();
                  __int16 v73 = os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG);
                  uint64_t v18 = v111;
                  if (v73)
                  {
                    *(_DWORD *)tcp_info buf = 136447490;
                    nw_endpoint_t v115 = "nw_protocol_ipv4_frame_output_finalizer";
                    nw_endpoint_t v116 = 2082;
                    nw_endpoint_t v117 = (char *)a3 + 137;
                    BOOL v118 = 2080;
                    id v119 = " ";
                    nw_endpoint_t v120 = 2048;
                    int v121 = (char *)a3;
                    nw_endpoint_t v122 = 1024;
                    uint64_t v123 = v16;
                    uint64_t v124 = 1024;
                    nw_endpoint_t v125 = v111;
                    _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p Got %u packets to fragment %u bytes",  buf,  0x36u);
                    uint64_t v18 = v111;
                  }
                }
              }

              v93[0] = MEMORY[0x1895F87A8];
              v93[1] = 0x40000000LL;
              os_log_type_t v94 = ___ZL39nw_protocol_ipv4_frame_output_finalizerP8nw_framebPv_block_invoke_30;
              nw_endpoint_t v95 = &unk_189BC89F8;
              BOOL v101 = v18;
              char v96 = v109;
              nw_endpoint_t v97 = v107;
              os_log_type_t v98 = a3;
              id v99 = a1;
              os_log_type_t v102 = __buf;
              os_log_type_t v100 = v6;
              char v28 = v107[0];
              do
              {
                if (!v28) {
                  break;
                }
                os_log_type_t v29 = *(void *)(v28 + 32);
                BOOL v30 = ((uint64_t (*)(void *))v94)(v93);
                char v28 = v29;
              }

              while ((v30 & 1) != 0);
              id v31 = *(a3 - 8);
              if (v31)
              {
                nw_endpoint_t v32 = *(void **)(v31 + 40);
                if (v32 == &nw_protocol_ref_counted_handle)
                {
                  os_log_type_t v33 = *(void *)(v31 + 88);
                  if (v33) {
                    *(void *)(v31 + 8_Block_object_dispose(va, 8) = v33 + 1;
                  }
                }

                os_log_type_t v34 = *(void *)(v31 + 24);
                if (v34)
                {
                  os_log_type_t v35 = *(void (**)(uint64_t, void *))(v34 + 96);
                  if (v35)
                  {
                    v35(v31, v107);
LABEL_46:
                    if (v32 != &nw_protocol_ref_counted_handle) {
                      goto LABEL_48;
                    }
                    if (*(_UNKNOWN **)(v31 + 40) != &nw_protocol_ref_counted_handle) {
                      goto LABEL_48;
                    }
                    os_log_type_t v47 = *(void *)(v31 + 88);
                    if (!v47) {
                      goto LABEL_48;
                    }
                    BOOL v48 = v47 - 1;
                    *(void *)(v31 + 8_Block_object_dispose(va, 8) = v48;
                    if (v48) {
                      goto LABEL_48;
                    }
                    os_log_type_t v49 = *(void (***)(void))(v31 + 64);
                    if (v49)
                    {
                      *(void *)(v31 + 64) = 0LL;
                      v49[2](v49);
                      _Block_release(v49);
                    }

                    if ((*(_BYTE *)(v31 + 72) & 1) != 0)
                    {
                      uint64_t v50 = *(const void **)(v31 + 64);
                      if (v50) {
                        _Block_release(v50);
                      }
                    }

                    goto LABEL_78;
                  }
                }

                __nwlog_obj();
                id v64 = *(const char **)(v31 + 16);
                *(_DWORD *)tcp_info buf = 136446722;
                nw_endpoint_t v115 = "__nw_protocol_finalize_output_frames";
                if (!v64) {
                  id v64 = "invalid";
                }
                nw_endpoint_t v116 = 2082;
                nw_endpoint_t v117 = (char *)v64;
                BOOL v118 = 2048;
                id v119 = (const char *)v31;
                os_log_type_t v65 = (char *)_os_log_send_and_compose_impl();
                uint64_t v113 = OS_LOG_TYPE_ERROR;
                BOOL v112 = 0;
                if (__nwlog_fault(v65, &v113, &v112))
                {
                  if (v113 == OS_LOG_TYPE_FAULT)
                  {
                    id v66 = (os_log_s *)__nwlog_obj();
                    nw_endpoint_t v67 = v113;
                    if (!os_log_type_enabled(v66, v113)) {
                      goto LABEL_161;
                    }
                    id v68 = *(const char **)(v31 + 16);
                    if (!v68) {
                      id v68 = "invalid";
                    }
                    *(_DWORD *)tcp_info buf = 136446722;
                    nw_endpoint_t v115 = "__nw_protocol_finalize_output_frames";
                    nw_endpoint_t v116 = 2082;
                    nw_endpoint_t v117 = (char *)v68;
                    BOOL v118 = 2048;
                    id v119 = (const char *)v31;
                    char v69 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
                    goto LABEL_160;
                  }

                  if (!v112)
                  {
                    id v66 = (os_log_s *)__nwlog_obj();
                    nw_endpoint_t v67 = v113;
                    if (!os_log_type_enabled(v66, v113)) {
                      goto LABEL_161;
                    }
                    os_log_type_t v87 = *(const char **)(v31 + 16);
                    if (!v87) {
                      os_log_type_t v87 = "invalid";
                    }
                    *(_DWORD *)tcp_info buf = 136446722;
                    nw_endpoint_t v115 = "__nw_protocol_finalize_output_frames";
                    nw_endpoint_t v116 = 2082;
                    nw_endpoint_t v117 = (char *)v87;
                    BOOL v118 = 2048;
                    id v119 = (const char *)v31;
                    char v69 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
                    goto LABEL_160;
                  }

                  __int16 v77 = (char *)__nw_create_backtrace_string();
                  id v66 = (os_log_s *)__nwlog_obj();
                  nw_endpoint_t v67 = v113;
                  id v78 = os_log_type_enabled(v66, v113);
                  if (v77)
                  {
                    if (v78)
                    {
                      __int16 v79 = *(const char **)(v31 + 16);
                      if (!v79) {
                        __int16 v79 = "invalid";
                      }
                      *(_DWORD *)tcp_info buf = 136446978;
                      nw_endpoint_t v115 = "__nw_protocol_finalize_output_frames";
                      nw_endpoint_t v116 = 2082;
                      nw_endpoint_t v117 = (char *)v79;
                      BOOL v118 = 2048;
                      id v119 = (const char *)v31;
                      nw_endpoint_t v120 = 2082;
                      int v121 = v77;
                      _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                    }

                    free(v77);
                    goto LABEL_161;
                  }

                  if (v78)
                  {
                    nw_endpoint_t v88 = *(const char **)(v31 + 16);
                    if (!v88) {
                      nw_endpoint_t v88 = "invalid";
                    }
                    *(_DWORD *)tcp_info buf = 136446722;
                    nw_endpoint_t v115 = "__nw_protocol_finalize_output_frames";
                    nw_endpoint_t v116 = 2082;
                    nw_endpoint_t v117 = (char *)v88;
                    BOOL v118 = 2048;
                    id v119 = (const char *)v31;
                    char v69 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_160:
                    _os_log_impl(&dword_181A5C000, v66, v67, v69, buf, 0x20u);
                  }
                }

void sub_181B838B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21)
{
  _Unwind_Resume(a1);
}

uint64_t nw_flow_add_write_request(void *a1, void **a2, void *a3)
{
  uint64_t v176 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a3;
  os_log_type_t v7 = v5;
  os_log_type_t v8 = v7;
  id v155 = v6;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v100 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    __int16 v159 = "nw_endpoint_handler_get_mode";
    BOOL v101 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v156 = 0;
    if (__nwlog_fault(v101, &type, &v156))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v103 = type;
        if (os_log_type_enabled(v102, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          __int16 v159 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v102, v103, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v156)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v109 = type;
        BOOL v110 = os_log_type_enabled(v102, type);
        if (backtrace_string)
        {
          if (v110)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            __int16 v159 = "nw_endpoint_handler_get_mode";
            __int16 v160 = 2082;
            __int16 v161 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v102,  v109,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_146;
        }

        if (v110)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          __int16 v159 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_181A5C000, v102, v109, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v102 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v118 = type;
        if (os_log_type_enabled(v102, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          __int16 v159 = "nw_endpoint_handler_get_mode";
          _os_log_impl( &dword_181A5C000,  v102,  v118,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B84F60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

BOOL nw_write_request_list_append(void *a1, void *a2)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v4)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    id v45 = "nw_write_request_list_append";
    nw_endpoint_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v19, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        dispatch_qos_class_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v45 = "nw_write_request_list_append";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null request", buf, 0xCu);
        }
      }

      else if (v42)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        dispatch_qos_class_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            id v45 = "nw_write_request_list_append";
            __int16 v46 = 2082;
            uint64_t v47 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v31,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_68;
        }

        if (v32)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v45 = "nw_write_request_list_append";
          _os_log_impl(&dword_181A5C000, v20, v31, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        dispatch_qos_class_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          id v45 = "nw_write_request_list_append";
          _os_log_impl( &dword_181A5C000,  v20,  v38,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181B858AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *nw_write_request_copy_next_incomplete_request(void *a1, char a2, int a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  os_log_type_t v7 = a1;
  id v8 = a4;
  if (!v7)
  {
    __nwlog_obj();
    id v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    BOOL v22 = "nw_write_request_copy_next_incomplete_request";
    id v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          BOOL v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null request", buf, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            BOOL v22 = "nw_write_request_copy_next_incomplete_request";
            __int16 v23 = 2082;
            uint64_t v24 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }

        if (v17)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          BOOL v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          BOOL v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

BOOL nw_content_context_is_blocked_by_antecedents(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = 0LL;
    if (v1 != (os_unfair_lock_s *)&__block_literal_global_5_41854
      && v1 != (os_unfair_lock_s *)&__block_literal_global_4
      && v1 != (os_unfair_lock_s *)&__block_literal_global_3_41839
      && v1 != (os_unfair_lock_s *)&__block_literal_global_41831)
    {
      os_unfair_lock_lock(v1 + 28);
      uint64_t v4 = *(void *)&v2[14]._os_unfair_lock_opaque;
      if (v4) {
        BOOL v3 = (*(_BYTE *)(v4 + 118) & 4) == 0;
      }
      else {
        BOOL v3 = 0LL;
      }
      os_unfair_lock_unlock(v2 + 28);
    }

    goto LABEL_10;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)tcp_info buf = 136446210;
  BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v12)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_flow_passthrough_get_output_frames( nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    uint64_t v24 = "nw_flow_passthrough_get_output_frames";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v24 = "nw_flow_passthrough_get_output_frames";
        BOOL v15 = "%{public}s called with null protocol";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          uint64_t v24 = "nw_flow_passthrough_get_output_frames";
          __int16 v25 = 2082;
          BOOL v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v12) {
          return 0LL;
        }
LABEL_39:
        free(v12);
        return 0LL;
      }

      if (v18)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v24 = "nw_flow_passthrough_get_output_frames";
        BOOL v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v24 = "nw_flow_passthrough_get_output_frames";
        BOOL v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

uint64_t nw_frame_create_external(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  objc_opt_class();
  uint64_t v8 = _os_object_alloc();
  uint64_t v9 = v8;
  if (v8)
  {
    int v10 = *(unsigned __int16 *)(v8 + 204) | (*(unsigned __int8 *)(v8 + 206) << 16);
    if (a1) {
      v10 |= 4u;
    }
    *(_WORD *)(v8 + 204) = v10 | 2;
    *(_BYTE *)(v8 + 206) = BYTE2(v10);
    nw_frame_reset(v8, 0LL, a2, a3, a4);
    return v9;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)tcp_info buf = 136446210;
  char v21 = "nw_frame_create_external";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      char v21 = "nw_frame_create_external";
      os_log_type_t v14 = "%{public}s nw_frame_obj_alloc failed";
      goto LABEL_18;
    }

    if (!v18)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      char v21 = "nw_frame_create_external";
      os_log_type_t v14 = "%{public}s nw_frame_obj_alloc failed, backtrace limit exceeded";
      goto LABEL_18;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v12 = (os_log_s *)gLogObj;
    os_log_type_t v13 = type;
    BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)tcp_info buf = 136446466;
        char v21 = "nw_frame_create_external";
        __int16 v22 = 2082;
        __int16 v23 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s nw_frame_obj_alloc failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_19;
    }

    if (v16)
    {
      *(_DWORD *)tcp_info buf = 136446210;
      char v21 = "nw_frame_create_external";
      os_log_type_t v14 = "%{public}s nw_frame_obj_alloc failed, no backtrace";
LABEL_18:
      _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    }
  }

id *nw_flow_copy_write_request(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1;
  uint64_t v102 = *MEMORY[0x1895F89C0];
  id v4 = *(id *)(a1 + 160);
  BOOL v78 = v4;
  uint64_t v79 = v3;
  id v5 = *(void **)(v3 + 192);
  id v6 = *(void **)(v3 + 200);
  if (!v5) {
    goto LABEL_4;
  }
LABEL_2:
  if (!v6) {
    goto LABEL_7;
  }
  while (1)
  {
    os_log_type_t v7 = nw_write_request_copy_next_incomplete_request( v6,  (*(_DWORD *)(a2 + 4) & 2) != 0,  (*(unsigned __int16 *)(v3 + 332) >> 1) & 1,  *(void **)(v3 + 224));
    if (!v7) {
      break;
    }
LABEL_8:
    uint64_t v8 = v7;
    id v82 = v8[8];
    BOOL v83 = v8;

    if (v82)
    {
      uint64_t v9 = (os_unfair_lock_s *)v82;
      int v10 = v9;
      if (a3)
      {
        if (v9 != (os_unfair_lock_s *)&__block_literal_global_5_41854
          && v9 != (os_unfair_lock_s *)&__block_literal_global_4
          && v9 != (os_unfair_lock_s *)&__block_literal_global_3_41839
          && v9 != (os_unfair_lock_s *)&__block_literal_global_41831)
        {
          *a3 = 0LL;
          if ((v9[29]._os_unfair_lock_opaque & 0x10000) == 0)
          {
            os_unfair_lock_lock(v9 + 28);
            unint64_t v14 = *(void *)&v10[16]._os_unfair_lock_opaque;
            if (v14)
            {
              if ((v10[29]._os_unfair_lock_opaque & 0x20000) == 0)
              {
                BYTE2(v10[29]._os_unfair_lock_opaque) |= 2u;
                uint64_t v15 = *(void *)&v10[18]._os_unfair_lock_opaque;
                uint64_t v16 = mach_absolute_time();
                unint64_t v17 = nw_delta_nanos(v15, v16);
                unint64_t v18 = (v17 / 0xF4240);
                if (v17 > 0xF423FFFFFFFFFLL) {
                  unint64_t v18 = 0xFFFFFFFFLL;
                }
                unint64_t v14 = *(void *)&v10[16]._os_unfair_lock_opaque;
                if (v14 < v18)
                {
                  os_unfair_lock_unlock(v10 + 28);

                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v4);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v4);
                  if (minimize_logging)
                  {
                    if ((logging_disabled & 1) != 0)
                    {
LABEL_87:
                      int v28 = 60;
                      goto LABEL_55;
                    }

                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    char v21 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v4);
                      nw_endpoint_t v69 = nw_endpoint_handler_dry_run_string(v4);
                      nw_endpoint_t v70 = nw_endpoint_handler_copy_endpoint(v4);
                      logging_description = nw_endpoint_get_logging_description(v70);
                      uint64_t v72 = nw_endpoint_handler_state_string(v4);
                      os_log_t logb = nw_endpoint_handler_mode_string(v4);
                      id v73 = nw_endpoint_handler_copy_current_path(v4);
                      *(_DWORD *)tcp_info buf = 136448002;
                      os_log_type_t v87 = "nw_flow_copy_write_request";
                      __int16 v88 = 2082;
                      id v89 = (void *)id_string;
                      __int16 v90 = 2082;
                      os_log_type_t v91 = v69;
                      __int16 v92 = 2082;
                      BOOL v93 = logging_description;
                      __int16 v94 = 2082;
                      nw_endpoint_t v95 = v72;
                      __int16 v96 = 2082;
                      size_t v97 = logb;
                      __int16 v98 = 2114;
                      id v99 = v73;
                      __int16 v100 = 2112;
                      BOOL v101 = v10;
                      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ is expired, failing request",  buf,  0x52u);
                    }
                  }

                  else
                  {
                    if ((logging_disabled & 1) != 0) {
                      goto LABEL_87;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    char v21 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
                    {
                      __int16 v22 = nw_endpoint_handler_get_id_string(v4);
                      __int16 v23 = nw_endpoint_handler_dry_run_string(v4);
                      nw_endpoint_t v24 = nw_endpoint_handler_copy_endpoint(v4);
                      __int16 v25 = nw_endpoint_get_logging_description(v24);
                      BOOL v26 = nw_endpoint_handler_state_string(v4);
                      os_log_t log = nw_endpoint_handler_mode_string(v4);
                      id v27 = nw_endpoint_handler_copy_current_path(v4);
                      *(_DWORD *)tcp_info buf = 136448002;
                      os_log_type_t v87 = "nw_flow_copy_write_request";
                      __int16 v88 = 2082;
                      id v89 = (void *)v22;
                      __int16 v90 = 2082;
                      os_log_type_t v91 = v23;
                      __int16 v92 = 2082;
                      BOOL v93 = v25;
                      __int16 v94 = 2082;
                      nw_endpoint_t v95 = v26;
                      __int16 v96 = 2082;
                      size_t v97 = log;
                      __int16 v98 = 2114;
                      id v99 = v27;
                      __int16 v100 = 2112;
                      BOOL v101 = v10;
                      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ is expired, failing request",  buf,  0x52u);
                    }
                  }

                  int v28 = 60;
                  goto LABEL_54;
                }
              }

              uint64_t v29 = *(void *)&v10[18]._os_unfair_lock_opaque;
              uint64_t v30 = dword_18C45F3A4;
              if (!dword_18C45F3A4)
              {
                mach_timebase_info((mach_timebase_info_t)&time_base);
                uint64_t v30 = dword_18C45F3A4;
              }

              *a3 = 1000000 * v14 * v30 / time_base + v29;
            }

            os_unfair_lock_unlock(v10 + 28);
          }
        }

        goto LABEL_37;
      }

      __nwlog_obj();
      BOOL v52 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)tcp_info buf = 136446210;
      os_log_type_t v87 = "nw_content_context_is_expired";
      uint64_t v53 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v84 = 0;
      if (__nwlog_fault(v53, &type, &v84))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v55 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            os_log_type_t v87 = "nw_content_context_is_expired";
            _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null expire_time", buf, 0xCu);
          }

          goto LABEL_62;
        }

        if (v84)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          id v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v65 = type;
          BOOL v66 = os_log_type_enabled(v64, type);
          if (backtrace_string)
          {
            if (v66)
            {
              *(_DWORD *)tcp_info buf = 136446466;
              os_log_type_t v87 = "nw_content_context_is_expired";
              __int16 v88 = 2082;
              id v89 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v64,  v65,  "%{public}s called with null expire_time, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
          }

          else
          {
            if (v66)
            {
              *(_DWORD *)tcp_info buf = 136446210;
              os_log_type_t v87 = "nw_content_context_is_expired";
              _os_log_impl( &dword_181A5C000,  v64,  v65,  "%{public}s called with null expire_time, no backtrace",  buf,  0xCu);
            }
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v67 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            os_log_type_t v87 = "nw_content_context_is_expired";
            _os_log_impl( &dword_181A5C000,  v54,  v67,  "%{public}s called with null expire_time, backtrace limit exceeded",  buf,  0xCu);
          }

void sub_181B871E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27)
{
  _Unwind_Resume(a1);
}

id nw_content_context_copy_error(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1 == (os_unfair_lock_s *)&__block_literal_global_5_41854
    || v1 == (os_unfair_lock_s *)&__block_literal_global_4
    || v1 == (os_unfair_lock_s *)&__block_literal_global_3_41839
    || v1 == (os_unfair_lock_s *)&__block_literal_global_41831)
  {
    id v6 = 0LL;
  }

  else
  {
    os_unfair_lock_lock(v1 + 28);
    id v6 = *(id *)&v2[24]._os_unfair_lock_opaque;
    if (!v6)
    {
      if (*(void *)&v2[14]._os_unfair_lock_opaque) {
        id v6 = (id)nw_content_context_copy_error();
      }
      else {
        id v6 = 0LL;
      }
    }

    os_unfair_lock_unlock(v2 + 28);
  }

  return v6;
}

void sub_181B8735C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

dispatch_data_t nw_write_request_copy_data(void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!*((void *)v1 + 9))
  {
    size_t v4 = *((void *)v1 + 14);
    id v5 = (dispatch_data_s *)*((void *)v1 + 7);
    if (v4)
    {
      size_t size = dispatch_data_get_size(*((dispatch_data_t *)v1 + 7));
      if (size < v4)
      {
        size_t v7 = size;
        nw_write_request_report(v2, 0LL, 0LL);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v9 = v2[14];
          int v12 = 136446722;
          os_log_type_t v13 = "nw_write_request_copy_data";
          __int16 v14 = 2048;
          size_t v15 = v7;
          __int16 v16 = 2048;
          uint64_t v17 = v9;
          _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s Invalid consumed bytes (%zu < %zu)",  (uint8_t *)&v12,  0x20u);
        }

        goto LABEL_2;
      }

      dispatch_data_t subrange = dispatch_data_create_subrange(v5, v4, size - v4);
    }

    else
    {
      dispatch_data_t subrange = v5;
    }

    dispatch_data_t v3 = subrange;
    goto LABEL_11;
  }

LABEL_2:
  dispatch_data_t v3 = 0LL;
LABEL_11:

  return v3;
}
}

  size_t v4 = 1LL;
LABEL_57:

  return v4;
}

void sub_181B874B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_frame_set_external_data(uint64_t a1, dispatch_data_t data, unsigned int *a3)
{
  *(void *)&v30[13] = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v4 = (os_log_s *)gLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        int v28 = "__nw_frame_set_external_data";
        _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
        return 0LL;
      }

      return result;
    }

    uint64_t v8 = *(void **)(a1 + 96);
    if (v8)
    {
      os_release(v8);
      *(void *)(a1 + 96) = 0LL;
    }

    *(_DWORD *)(a1 + 56) = 0;
    if (!data
      || ((unsigned int v9 = *(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 60), size = dispatch_data_get_size(data), v9 >= size)
        ? (unsigned int v11 = size)
        : (unsigned int v11 = v9),
          !v11))
    {
      *(_DWORD *)(a1 + 52) = 0;
      *(_WORD *)(a1 + 196) = 0;
      return 1LL;
    }

    dispatch_retain(data);
    *(void *)(a1 + 96) = data;
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 60) + v11;
    if ((*(_WORD *)(a1 + 204) & 0x80) == 0)
    {
LABEL_34:
      if (a3) {
        *a3 = v11;
      }
      return 1LL;
    }

    if (!HIWORD(v11))
    {
      __int16 v12 = v11;
LABEL_33:
      *(_WORD *)(a1 + 196) = v12;
      goto LABEL_34;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)tcp_info buf = 136446466;
    int v28 = "__nw_frame_set_external_data";
    __int16 v29 = 1024;
    *(_DWORD *)uint64_t v30 = v11;
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v13, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)tcp_info buf = 136446466;
          int v28 = "__nw_frame_set_external_data";
          __int16 v29 = 1024;
          *(_DWORD *)uint64_t v30 = v11;
          __int16 v16 = "%{public}s Frame-length is too big for aggregate_buffer_length: %u";
LABEL_29:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0x12u);
        }
      }

      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)tcp_info buf = 136446722;
            int v28 = "__nw_frame_set_external_data";
            __int16 v29 = 1024;
            *(_DWORD *)uint64_t v30 = v11;
            v30[2] = 2082;
            *(void *)&v30[3] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Frame-length is too big for aggregate_buffer_length: %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_30;
        }

        if (v18)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          int v28 = "__nw_frame_set_external_data";
          __int16 v29 = 1024;
          *(_DWORD *)uint64_t v30 = v11;
          __int16 v16 = "%{public}s Frame-length is too big for aggregate_buffer_length: %u, no backtrace";
          goto LABEL_29;
        }
      }

      else
      {
        __int16 v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)tcp_info buf = 136446466;
          int v28 = "__nw_frame_set_external_data";
          __int16 v29 = 1024;
          *(_DWORD *)uint64_t v30 = v11;
          __int16 v16 = "%{public}s Frame-length is too big for aggregate_buffer_length: %u, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }

uint64_t nw_write_request_consume_bytes(void *a1, uint64_t a2)
{
  v49[1] = *(id *)MEMORY[0x1895F89C0];
  id v3 = a1;
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_32859);
  }
  size_t v4 = (void *)*((void *)v3 + 7);
  uint64_t v5 = *((void *)v3 + 9);
  if (v4)
  {
    if (!v5)
    {
      size_t size = dispatch_data_get_size(*((dispatch_data_t *)v3 + 7));
      size_t v7 = *((void *)v3 + 14) + a2;
      if (v7 < size)
      {
        *((void *)v3 + 14) = v7;
        goto LABEL_65;
      }

      *((void *)v3 + 14) = 0LL;
LABEL_34:
      *((void *)v3 + 7) = 0LL;

      if ((*((_BYTE *)v3 + 128) & 1) != 0) {
        nw_content_context_mark_completed_send(*((void **)v3 + 8), 0LL);
      }
      if (_nw_signposts_once == -1)
      {
        if (_nw_signposts_enabled) {
          goto LABEL_38;
        }
      }

      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_32859);
        if (_nw_signposts_enabled)
        {
LABEL_38:
        }
      }

      uint64_t v23 = *((_BYTE *)v3 + 128) & 1;
      goto LABEL_70;
    }

void sub_181B88304( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  _Unwind_Resume(a1);
}

void nw_content_context_mark_completed_send(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    if (v3 != &__block_literal_global_5_41854
      && v3 != &__block_literal_global_4
      && v3 != &__block_literal_global_3_41839
      && v3 != &__block_literal_global_41831)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v3 + 28);
      *((_BYTE *)v3 + 118) |= 4u;
      objc_storeStrong((id *)v3 + 12, a2);
      *((void *)v3 + 9) = 0LL;
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 28);
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)tcp_info buf = 136446210;
  uint64_t v16 = "nw_content_context_mark_completed_send";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v16 = "nw_content_context_mark_completed_send";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          uint64_t v16 = "nw_content_context_mark_completed_send";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v11)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v16 = "nw_content_context_mark_completed_send";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v16 = "nw_content_context_mark_completed_send";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_frame_set_metadata(uint64_t a1, nw_protocol_metadata *object, int a3, int a4)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)tcp_info buf = 136446210;
    nw_endpoint_t v60 = "__nw_frame_set_metadata";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      os_log_type_t v44 = type[0];
      if (!os_log_type_enabled(v43, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      nw_endpoint_t v60 = "__nw_frame_set_metadata";
      __int16 v22 = "%{public}s called with null frame";
    }

    else if (v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      os_log_type_t v44 = type[0];
      BOOL v46 = os_log_type_enabled(v43, type[0]);
      if (backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          nw_endpoint_t v60 = "__nw_frame_set_metadata";
          __int16 v61 = 2082;
          uint64_t v62 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_70;
      }

      if (!v46) {
        goto LABEL_70;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      nw_endpoint_t v60 = "__nw_frame_set_metadata";
      __int16 v22 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      os_log_type_t v43 = (os_log_s *)__nwlog_obj();
      os_log_type_t v44 = type[0];
      if (!os_log_type_enabled(v43, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      nw_endpoint_t v60 = "__nw_frame_set_metadata";
      __int16 v22 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    os_log_type_t v40 = v43;
    os_log_type_t v41 = v44;
    uint32_t v42 = 12;
    goto LABEL_69;
  }

  if (object)
  {
    *(_BYTE *)(a1 + 186) = *(_BYTE *)(a1 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(object) & 3;
    dscp_xpc_object_t value = nw_ip_metadata_get_dscp_value(object);
    if (dscp_value < 0x40)
    {
      *(_BYTE *)(a1 + 184) = dscp_value;
LABEL_8:
      nw_service_class_t service_class = nw_ip_metadata_get_service_class(object);
      if (service_class > nw_service_class_signaling) {
        int v10 = 0;
      }
      else {
        int v10 = dword_182667530[service_class];
      }
      *(_DWORD *)(a1 + 176) = v10;
      *(_DWORD *)(a1 + 180) = nw_ip_metadata_get_fragmentation_value(object);
LABEL_14:
      uint64_t v11 = a1 + 204;
      if ((*(_WORD *)(a1 + 204) & 8) == 0) {
        goto LABEL_15;
      }
      int v56 = a4;
      uint64_t v23 = object;
      *(_OWORD *)os_log_type_t type = *((_OWORD *)v23 + 1);

      id v24 = *(uint64_t **)(a1 + 64);
      if (!v24) {
        goto LABEL_47;
      }
      char v25 = 0;
      if (a4) {
        char v26 = 64;
      }
      else {
        char v26 = 0;
      }
      while (1)
      {
        os_log_type_t v27 = v23;
        id v28 = v23[1];

        os_log_type_t v29 = (void *)v24[6];
        if (v29)
        {
          BOOL v30 = v29;
          id v31 = v30[1];

          if (nw_protocol_definition_is_equal_unsafe((uint64_t)v28, (uint64_t)v31)
            && !uuid_compare((const unsigned __int8 *)type, (const unsigned __int8 *)v24 + 16))
          {
            os_retain(v27);
            int v32 = (void *)v24[6];
            if (v32) {
              os_release(v32);
            }
            v24[6] = (uint64_t)v27;
            *((_BYTE *)v24 + 66) = *((_BYTE *)v24 + 66) & 0xBF | v26;
            char v25 = 1;
            if (!v31) {
              goto LABEL_40;
            }
LABEL_39:
            os_release(v31);
            goto LABEL_40;
          }

          if (v31) {
            goto LABEL_39;
          }
        }

uint64_t nw_flow_passthrough_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    size_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    dispatch_time_t v20 = "nw_flow_passthrough_finalize_output_frames";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        dispatch_time_t v20 = "nw_flow_passthrough_finalize_output_frames";
        uint64_t v11 = "%{public}s called with null protocol";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v14 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          dispatch_time_t v20 = "nw_flow_passthrough_finalize_output_frames";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          return 0LL;
        }
LABEL_39:
        free(v8);
        return 0LL;
      }

      if (v14)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        dispatch_time_t v20 = "nw_flow_passthrough_finalize_output_frames";
        uint64_t v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        dispatch_time_t v20 = "nw_flow_passthrough_finalize_output_frames";
        uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

void *nw_frame_array_append_array(void *result, void *a2, int a3)
{
  uint64_t v3 = *a2;
  if (a3)
  {
    if (!v3) {
      return result;
    }
    id v4 = (void *)result[1];
    ++result;
    void *v4 = v3;
    *(void *)(*a2 + 40LL) = *result;
  }

  else
  {
    if (!v3) {
      return result;
    }
    uint64_t v5 = (void *)result[1];
    ++result;
    *uint64_t v5 = v3;
    *(void *)(*a2 + 24LL) = *result;
  }

  int *result = a2[1];
  *a2 = 0LL;
  a2[1] = a2;
  return result;
}

uint64_t nw_frame_uses_external_data(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return (*(unsigned __int16 *)(a1 + 204) >> 1) & 1;
  }
  __nwlog_obj();
  *(_DWORD *)tcp_info buf = 136446210;
  uint64_t v11 = "__nw_frame_uses_external_data";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v11 = "__nw_frame_uses_external_data";
        uint64_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          uint64_t v11 = "__nw_frame_uses_external_data";
          __int16 v12 = 2082;
          int v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v11 = "__nw_frame_uses_external_data";
        uint64_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        uint64_t v11 = "__nw_frame_uses_external_data";
        uint64_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_frame_get_external_data(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)tcp_info buf = 136446210;
    int v15 = "__nw_frame_get_external_data";
    id v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_28;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      int v15 = "__nw_frame_get_external_data";
      unint64_t v9 = "%{public}s called with null frame";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          int v15 = "__nw_frame_get_external_data";
          __int16 v16 = 2082;
          char v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (!v11)
      {
LABEL_28:
        if (v6) {
          free(v6);
        }
        return 0LL;
      }

      *(_DWORD *)tcp_info buf = 136446210;
      int v15 = "__nw_frame_get_external_data";
      unint64_t v9 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_28;
      }
      *(_DWORD *)tcp_info buf = 136446210;
      int v15 = "__nw_frame_get_external_data";
      unint64_t v9 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_28;
  }

  if ((*(_WORD *)(a1 + 204) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)tcp_info buf = 136446210;
      int v15 = "__nw_frame_get_external_data";
      _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
    }

    return 0LL;
  }

  if (a2) {
    *a2 = *(_DWORD *)(a1 + 56);
  }
  if (a3)
  {
    int v5 = *(_DWORD *)(a1 + 52);
    if (v5) {
      v5 -= *(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60);
    }
    *a3 = v5;
  }

  return *(void *)(a1 + 96);
}

_BYTE *nw_write_request_list_prune(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1;
    do
    {
      if ((v3[128] & 2) == 0)
      {
        if (*((void *)v3 + 9))
        {
          if ((v3[128] & 0x10) == 0) {
            break;
          }
        }

        else if (*((void *)v3 + 7))
        {
          break;
        }

        if (v3 != v2 && (v3[128] & 8) != 0) {
          break;
        }
        nw_write_request_report(v3, 0LL, 0LL);
        if ((v3[128] & 2) == 0) {
          break;
        }
      }

      BOOL v4 = nw_write_request_list_remove_head(v3);

      uint64_t v3 = (_BYTE *)v4;
    }

    while (v4);
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  return v3;
}

void sub_181B89BE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_async_client_if_needed_with_override( void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  BOOL v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if (nw_parameters_is_persona_set(v7[2]))
  {
    os_log_type_t v10 = (void *)v7[2];
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = __nw_connection_async_client_if_needed_with_override_block_invoke;
    v11[3] = &unk_189BC16F8;
    char v12 = v7;
    id v13 = v8;
    dispatch_qos_class_t v15 = a3;
    id v14 = v9;
    nw_utilities_execute_block_as_persona_from_parameters(v10, v11);
  }

  else
  {
    __nw_connection_async_client_if_needed_with_override(v7, v8, a3, v9);
  }
}

void sub_181B89CE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

BOOL nw_write_request_list_remove_head(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    dispatch_time_t v20 = "nw_write_request_list_remove_head";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          dispatch_time_t v20 = "nw_write_request_list_remove_head";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null head", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            dispatch_time_t v20 = "nw_write_request_list_remove_head";
            __int16 v21 = 2082;
            __int16 v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null head, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v15)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          dispatch_time_t v20 = "nw_write_request_list_remove_head";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null head, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          dispatch_time_t v20 = "nw_write_request_list_remove_head";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null head, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t nw_flow_handle_send_complete( NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2, nw_flow_protocol *a3)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a2;
  output_handler = a3->protocol.output_handler;
  write_requests = a3->write_requests;
  if (write_requests
    && (v9 = write_requests, char v10 = *((_BYTE *)v9 + 128), v9, (v10 & 8) != 0)
    || (BOOL v11 = a3->initial_write_requests) != 0LL
    && (v12 = v11, char v13 = *((_BYTE *)v12 + 128), v12, (v13 & 8) != 0))
  {
    initial_write_requests = a3->initial_write_requests;
    if (initial_write_requests) {
      nw_write_request_consume_bytes(initial_write_requests, 0LL);
    }
    os_log_type_t v16 = a3->write_requests;
    if (v16) {
      nw_write_request_consume_bytes(v16, 0LL);
    }
    output_finished = (void (*)(nw_protocol *, nw_flow_protocol *))output_handler->callbacks->output_finished;
    if (output_finished)
    {
      output_finished(output_handler, a3);
    }

    else if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v18 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v5);
        uint64_t v35 = nw_endpoint_handler_dry_run_string(v5);
        nw_endpoint_t v36 = nw_endpoint_handler_copy_endpoint(v5);
        dispatch_time_t v20 = id_string;
        logging_description = nw_endpoint_get_logging_description(v36);
        __int16 v22 = nw_endpoint_handler_state_string(v5);
        uint64_t v23 = nw_endpoint_handler_mode_string(v5);
        id v24 = nw_endpoint_handler_copy_current_path(v5);
        identifier = output_handler->identifier;
        *(_DWORD *)tcp_info buf = 136448002;
        os_log_type_t v40 = "nw_flow_handle_send_complete";
        __int16 v41 = 2082;
        uint32_t v42 = v20;
        __int16 v43 = 2082;
        os_log_type_t v44 = v35;
        __int16 v45 = 2082;
        BOOL v46 = logging_description;
        __int16 v47 = 2082;
        uint64_t v48 = v22;
        __int16 v49 = 2082;
        id v50 = v23;
        __int16 v51 = 2114;
        id v52 = v24;
        __int16 v53 = 2082;
        os_log_type_t v54 = identifier;
        _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Protocol %{public}s does not support output_finished",  buf,  0x52u);
      }
    }

    char v26 = (OS_nw_write_request *)nw_write_request_list_prune(a3->initial_write_requests);
    os_log_type_t v27 = a3->initial_write_requests;
    a3->initial_write_requests = v26;

    id v28 = (OS_nw_write_request *)nw_write_request_list_prune(a3->write_requests);
    os_log_type_t v29 = a3->write_requests;
    a3->write_requests = v28;

    if (&v6->shared_protocol == a3)
    {
      if (v6->client_queue)
      {
        id write_close_handler = v6->write_close_handler;
        if (write_close_handler)
        {
          int v32 = _Block_copy(write_close_handler);
          client_queue = (dispatch_queue_s *)v6->client_queue;
          block[0] = MEMORY[0x1895F87A8];
          block[1] = 3221225472LL;
          block[2] = ___ZL28nw_flow_handle_send_completeP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP16nw_flow_protocol_block_invoke;
          block[3] = &unk_189BC8740;
          id v38 = v32;
          id v34 = v32;
          dispatch_async(client_queue, block);
        }
      }
    }

    uint64_t v14 = 1LL;
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  return v14;
}

void sub_181B8A358( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_181B8A3E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_write_request;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_connection_receive( nw_connection_t connection, uint32_t minimum_incomplete_length, uint32_t maximum_length, nw_connection_receive_completion_t completion)
{
}

NWConcrete_nw_read_request *nw_read_request_create( unint64_t a1, unint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  char v13 = v12;
  if (a2) {
    BOOL v14 = a1 == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    unint64_t v15 = 1LL;
  }
  else {
    unint64_t v15 = a1;
  }
  if (!v12)
  {
    __nwlog_obj();
    __int16 v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    __int16 v53 = "nw_read_request_create";
    char v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v53 = "nw_read_request_create";
        _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s called with null completion", buf, 0xCu);
      }
    }

    else if (v50)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = type;
      BOOL v48 = os_log_type_enabled(v44, type);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          __int16 v53 = "nw_read_request_create";
          __int16 v54 = 2082;
          uint64_t v55 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v44,  v47,  "%{public}s called with null completion, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_54;
      }

      if (v48)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v53 = "nw_read_request_create";
        _os_log_impl(&dword_181A5C000, v44, v47, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v53 = "nw_read_request_create";
        _os_log_impl( &dword_181A5C000,  v44,  v49,  "%{public}s called with null completion, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_54;
  }

  if (v15 <= a2)
  {
    if (v10)
    {
      dispatch_time_t v20 = (os_unfair_lock_s *)v10;
      if (v20 == (os_unfair_lock_s *)&__block_literal_global_5_41854)
      {
      }

      else
      {
        __int16 v21 = v20;
        if (v20 == (os_unfair_lock_s *)&__block_literal_global_4
          || v20 == (os_unfair_lock_s *)&__block_literal_global_3_41839
          || v20 == (os_unfair_lock_s *)&__block_literal_global_41831)
        {

          goto LABEL_20;
        }

        os_unfair_lock_lock(v20 + 28);
        char v22 = BYTE2(v21[29]._os_unfair_lock_opaque);
        os_unfair_lock_unlock(v21 + 28);

        if ((v22 & 0x40) == 0)
        {
LABEL_20:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v23 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            __int16 v53 = "nw_read_request_create";
            _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot receive a reply for a protocol that does not support replies",  buf,  0xCu);
          }

          goto LABEL_56;
        }
      }
    }

    os_log_type_t v27 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_read_request);
    if (v27)
    {
      id v28 = _Block_copy(v13);
      data_id completion = v27->data_completion;
      v27->data_id completion = v28;

      objc_storeStrong((id *)&v27->connection, a4);
      v27->qos_class = qos_class_self();
      v27->min = v15;
      v27->max = a2;
      objc_storeStrong((id *)&v27->repliable_message, a3);
      v27->variant = 1;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_51910);
      }
      BOOL v30 = v27;
      goto LABEL_65;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v31 = (id)gLogObj;
    *(_DWORD *)tcp_info buf = 136446210;
    __int16 v53 = "nw_read_request_create";
    int v32 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (__nwlog_fault(v32, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v33 = (os_log_s *)(id)gLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          __int16 v53 = "nw_read_request_create";
          _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed",  buf,  0xCu);
        }
      }

      else if (v50)
      {
        nw_endpoint_t v36 = __nw_create_backtrace_string();
        if (v36)
        {
          uint64_t v37 = (char *)v36;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v38 = (os_log_s *)(id)gLogObj;
          os_log_type_t v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            __int16 v53 = "nw_read_request_create";
            __int16 v54 = 2082;
            uint64_t v55 = v37;
            _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v37);
          if (!v32) {
            goto LABEL_65;
          }
          goto LABEL_64;
        }

        __nwlog_obj();
        char v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          __int16 v53 = "nw_read_request_create";
          _os_log_impl( &dword_181A5C000,  v33,  v41,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v33 = (os_log_s *)(id)gLogObj;
        os_log_type_t v40 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          __int16 v53 = "nw_read_request_create";
          _os_log_impl( &dword_181A5C000,  v33,  v40,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v32)
    {
LABEL_65:

      goto LABEL_66;
    }

void sub_181B8AE64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_add_read_request(void *a1, void *a2)
{
  uint64_t v124 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
    uint64_t mode = v5->mode;

    if ((_DWORD)mode == 2)
    {
      BOOL v7 = nw_endpoint_handler_copy_flow(v5);
      id v8 = v7;
      if ((*((_BYTE *)v7 + 35) & 2) != 0)
      {
        uint64_t v21 = *((void *)v7 + 117);
        if (!v21)
        {
          os_log_type_t v27 = v5;
          char v28 = *((_BYTE *)v27 + 268);

          if ((v28 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v11 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v29 = v27;

              BOOL v30 = v29;
              char v31 = *((_BYTE *)v27 + 268);

              if ((v31 & 1) != 0) {
                int v32 = "dry-run ";
              }
              else {
                int v32 = "";
              }
              nw_endpoint_t v33 = nw_endpoint_handler_copy_endpoint(v30);
              logging_description = nw_endpoint_get_logging_description(v33);
              id_str = v29->id_str;
              os_log_type_t v35 = v30;
              nw_endpoint_t v36 = v35;
              uint64_t v37 = v35[30];
              else {
                id v38 = off_189BBBBF0[v37];
              }
              __int16 v90 = v38;

              __int16 v54 = v36;
              uint64_t v55 = v54;
              int v56 = v5->mode;
              unint64_t v57 = "path";
              switch(v56)
              {
                case 0:
                  break;
                case 1:
                  unint64_t v57 = "resolver";
                  break;
                case 2:
                  unint64_t v57 = nw_endpoint_flow_mode_string(v54[31]);
                  break;
                case 3:
                  unint64_t v57 = "proxy";
                  break;
                case 4:
                  unint64_t v57 = "fallback";
                  break;
                case 5:
                  unint64_t v57 = "transform";
                  break;
                default:
                  unint64_t v57 = "unknown-mode";
                  break;
              }

              nw_endpoint_t v69 = v55;
              os_unfair_lock_lock((os_unfair_lock_t)v69 + 28);
              id v70 = v69[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v69 + 28);

              *(_DWORD *)tcp_info buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = id_str;
              *(_WORD *)&_BYTE buf[22] = 2082;
              os_log_type_t v109 = v32;
              __int16 v110 = 2082;
              id v111 = logging_description;
              __int16 v112 = 2082;
              uint64_t v113 = v90;
              __int16 v114 = 2082;
              BOOL v115 = v57;
              __int16 v116 = 2114;
              id v117 = v70;
              _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot receive, no connected handler",  buf,  0x48u);
            }

            goto LABEL_94;
          }

void sub_181B8C12C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

BOOL nw_flow_add_read_request(void *a1, uint64_t a2, void *a3)
{
  uint64_t v259 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    __int16 v94 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    v242 = "nw_flow_add_read_request";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v239 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v95 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        v242 = "nw_flow_add_read_request";
        _os_log_impl(&dword_181A5C000, v22, v95, "%{public}s called with null handler", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (!v239)
    {
      __nwlog_obj();
      char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v112 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        v242 = "nw_flow_add_read_request";
        _os_log_impl( &dword_181A5C000,  v22,  v112,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_118;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v99 = type;
    BOOL v100 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v100)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        v242 = "nw_flow_add_read_request";
        _os_log_impl(&dword_181A5C000, v22, v99, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }

      goto LABEL_118;
    }

    if (v100)
    {
      *(_DWORD *)tcp_info buf = 136446466;
      v242 = "nw_flow_add_read_request";
      __int16 v243 = 2082;
      id_str = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v22,  v99,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_157;
  }

  uint64_t v5 = a1;
  uint64_t mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    if (a3)
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_89);
      }
      v234 = a3;
      v238 = nw_endpoint_handler_copy_flow(v5);
      if ((*((_BYTE *)v238 + 34) & 8) != 0)
      {
        if (!nw_endpoint_handler_get_minimize_logging(v5))
        {
          BOOL v7 = v5;
          char v8 = *((_BYTE *)v7 + 268);

          if ((v8 & 0x20) != 0) {
            goto LABEL_59;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v9 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            id v10 = v7;

            id v11 = v10;
            char v12 = *((_BYTE *)v7 + 268);

            if ((v12 & 1) != 0) {
              char v13 = "dry-run ";
            }
            else {
              char v13 = "";
            }
            nw_endpoint_t v226 = nw_endpoint_handler_copy_endpoint(v11);
            logging_description = nw_endpoint_get_logging_description(v226);
            id v15 = v11;
            id v16 = v15;
            uint64_t v17 = v15[30];
            else {
              uint64_t v18 = off_189BBBBF0[v17];
            }
            os_log_type_t v219 = v18;

            char v31 = v16;
            int v32 = v31;
            nw_endpoint_t v33 = "path";
            switch(v5->mode)
            {
              case 0:
                break;
              case 1:
                nw_endpoint_t v33 = "resolver";
                break;
              case 2:
                nw_endpoint_t v33 = nw_endpoint_flow_mode_string(v31[31]);
                break;
              case 3:
                nw_endpoint_t v33 = "proxy";
                break;
              case 4:
                nw_endpoint_t v33 = "fallback";
                break;
              case 5:
                nw_endpoint_t v33 = "transform";
                break;
              default:
                nw_endpoint_t v33 = "unknown-mode";
                break;
            }

            os_log_type_t v35 = v32;
            os_unfair_lock_lock((os_unfair_lock_t)v35 + 28);
            id v36 = v35[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v35 + 28);

            id v37 = v36;
            *(_DWORD *)tcp_info buf = 136448258;
            v242 = "nw_flow_add_read_request";
            __int16 v243 = 2082;
            id_str = v10->id_str;
            __int16 v245 = 2082;
            v246 = v13;
            __int16 v247 = 2082;
            v248 = (void *)logging_description;
            __int16 v249 = 2082;
            nw_endpoint_t v250 = v219;
            __int16 v251 = 2082;
            v252 = v33;
            __int16 v253 = 2114;
            id v254 = v37;
            __int16 v255 = 2048;
            next_max_size_t size = nw_read_request_get_next_max_size(v234);
            __int16 v257 = 2048;
            uint64_t maximum_datagram_count = nw_read_request_get_maximum_datagram_count(v234);
            _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Read request submitted: % zu bytes, %zu datagrams",  buf,  0x5Cu);
          }

          goto LABEL_58;
        }

        if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v9 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v5);
            BOOL v101 = nw_endpoint_handler_dry_run_string(v5);
            nw_endpoint_t v227 = nw_endpoint_handler_copy_endpoint(v5);
            uint64_t v102 = nw_endpoint_get_logging_description(v227);
            os_log_type_t v103 = nw_endpoint_handler_state_string(v5);
            nw_endpoint_t v104 = nw_endpoint_handler_mode_string(v5);
            id v105 = nw_endpoint_handler_copy_current_path(v5);
            *(_DWORD *)tcp_info buf = 136448258;
            v242 = "nw_flow_add_read_request";
            __int16 v243 = 2082;
            id_str = (char *)id_string;
            __int16 v245 = 2082;
            v246 = v101;
            __int16 v247 = 2082;
            v248 = (void *)v102;
            __int16 v249 = 2082;
            nw_endpoint_t v250 = v103;
            __int16 v251 = 2082;
            v252 = v104;
            __int16 v253 = 2114;
            id v254 = v105;
            __int16 v255 = 2048;
            next_max_size_t size = nw_read_request_get_next_max_size(v234);
            __int16 v257 = 2048;
            uint64_t maximum_datagram_count = nw_read_request_get_maximum_datagram_count(v234);
            _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Read request submitted: % zu bytes, %zu datagrams",  buf,  0x5Cu);
          }

LABEL_249:
        BOOL v91 = 0LL;
        goto LABEL_250;
      }

      if (a2)
      {
        uint64_t v38 = *(void *)(a2 + 312);
        if (v38)
        {
          if (*(void *)(v38 + 16) != *(void *)(v38 + 24))
          {
            uint64_t v39 = nw_array_get_object_at_index(v38, 0LL);

            if (v39)
            {
              if (!nw_flow_has_final_read((nw_flow_protocol *)a2))
              {
                os_log_type_t v40 = *(void **)(v39 + 16);
                if (v40
                  && v40 != &__block_literal_global_3_41839
                  && v40 != &__block_literal_global_41831
                  && v40 != &__block_literal_global_4
                  && v40 != &__block_literal_global_5_41854)
                {
                  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    nw_endpoint_t v203 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v203, OS_LOG_TYPE_DEBUG))
                    {
                      char v224 = nw_endpoint_handler_get_id_string(v5);
                      v217 = nw_endpoint_handler_dry_run_string(v5);
                      nw_endpoint_t v232 = nw_endpoint_handler_copy_endpoint(v5);
                      locka = nw_endpoint_get_logging_description(v232);
                      __int16 v204 = nw_endpoint_handler_state_string(v5);
                      id v205 = nw_endpoint_handler_mode_string(v5);
                      id v206 = nw_endpoint_handler_copy_current_path(v5);
                      uint64_t v207 = *(void *)(v39 + 16);
                      *(_DWORD *)tcp_info buf = 136448002;
                      v242 = "nw_flow_add_read_request";
                      __int16 v243 = 2082;
                      id_str = (char *)v224;
                      __int16 v245 = 2082;
                      v246 = v217;
                      __int16 v247 = 2082;
                      v248 = (void *)locka;
                      __int16 v249 = 2082;
                      nw_endpoint_t v250 = v204;
                      __int16 v251 = 2082;
                      v252 = v205;
                      __int16 v253 = 2114;
                      id v254 = v206;
                      __int16 v255 = 2048;
                      next_max_size_t size = v207;
                      _os_log_impl( &dword_181A5C000,  v203,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Setting final o n non-static context %p",  buf,  0x52u);
                    }
                  }

                  nw_content_context_set_is_final(*(nw_content_context_t *)(v39 + 16), 1);
                }

                if (!*(_BYTE *)(v39 + 25) && *(_BYTE *)(v39 + 24) && !*(void *)(v39 + 32))
                {
                  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v208 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v208, OS_LOG_TYPE_DEBUG))
                    {
                      int v225 = nw_endpoint_handler_get_id_string(v5);
                      nw_endpoint_t v218 = nw_endpoint_handler_dry_run_string(v5);
                      nw_endpoint_t v233 = nw_endpoint_handler_copy_endpoint(v5);
                      lockb = nw_endpoint_get_logging_description(v233);
                      nw_endpoint_t v209 = nw_endpoint_handler_state_string(v5);
                      v210 = nw_endpoint_handler_mode_string(v5);
                      id v211 = nw_endpoint_handler_copy_current_path(v5);
                      *(_DWORD *)tcp_info buf = 136447746;
                      v242 = "nw_flow_add_read_request";
                      __int16 v243 = 2082;
                      id_str = (char *)v225;
                      __int16 v245 = 2082;
                      v246 = v218;
                      __int16 v247 = 2082;
                      v248 = (void *)lockb;
                      __int16 v249 = 2082;
                      nw_endpoint_t v250 = v209;
                      __int16 v251 = 2082;
                      v252 = v210;
                      __int16 v253 = 2114;
                      id v254 = v211;
                      _os_log_impl( &dword_181A5C000,  v208,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Setting is_comp lete on last final read",  buf,  0x48u);
                    }
                  }

                  *(_BYTE *)(v39 + 25) = 1;
                }
              }

              os_log_type_t v41 = *(dispatch_data_s **)(v39 + 8);
              if (v41) {
                size_t size = dispatch_data_get_size(v41);
              }
              else {
                size_t size = 0LL;
              }
              os_log_type_t v75 = *(void **)(v39 + 16);
              if (!v75) {
                os_log_type_t v75 = &__block_literal_global_3_41839;
              }
              id v76 = v75;
              os_log_type_t v77 = v234;
              request_receive = nw_read_request_receive( v234,  *(void **)(v39 + 8),  v76,  *(unsigned __int8 *)(v39 + 25),  *(void **)(v39 + 32));
              if (size)
              {
                *((void *)v238 + 134) += size;
                if ((*((_BYTE *)v238 + 34) & 0x20) == 0) {
                  nw_context_count_input_bytes(*(void **)(a2 + 184), size);
                }
              }

              if (request_receive)
              {
                if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  __int16 v118 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG))
                  {
                    id v221 = nw_endpoint_handler_get_id_string(v5);
                    v215 = nw_endpoint_handler_dry_run_string(v5);
                    nw_endpoint_t v228 = nw_endpoint_handler_copy_endpoint(v5);
                    id v119 = nw_endpoint_get_logging_description(v228);
                    __int16 v120 = nw_endpoint_handler_state_string(v5);
                    id v121 = nw_endpoint_handler_mode_string(v5);
                    id v122 = nw_endpoint_handler_copy_current_path(v5);
                    size_t v123 = dispatch_data_get_size(request_receive);
                    *(_DWORD *)tcp_info buf = 136448258;
                    v242 = "nw_flow_add_read_request";
                    __int16 v243 = 2082;
                    id_str = (char *)v221;
                    __int16 v245 = 2082;
                    v246 = v215;
                    __int16 v247 = 2082;
                    v248 = (void *)v119;
                    __int16 v249 = 2082;
                    nw_endpoint_t v250 = v120;
                    __int16 v251 = 2082;
                    v252 = v121;
                    __int16 v253 = 2114;
                    id v254 = v122;
                    __int16 v255 = 2048;
                    next_max_size_t size = size - v123;
                    __int16 v257 = 2048;
                    uint64_t maximum_datagram_count = size;
                    _os_log_impl( &dword_181A5C000,  v118,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Consumed %zu/%zu final bytes",  buf,  0x5Cu);
                  }
                }

                os_log_type_t v79 = *(void **)(v39 + 16);
                int v80 = *(unsigned __int8 *)(v39 + 24);
                int v81 = *(unsigned __int8 *)(v39 + 25);
                id v82 = *(void **)(v39 + 32);
                os_log_type_t v83 = request_receive;
                id v84 = v79;
                id v85 = v82;
                if (!*(void *)(a2 + 312))
                {
                  BOOL v86 = nw_array_create();
                  os_log_type_t v87 = *(void **)(a2 + 312);
                  *(void *)(a2 + 312) = v86;
                }

                nw_flow_final_read_create(v83, v84, v80 != 0, v81 != 0, v85);
                id v88 = (void *)objc_claimAutoreleasedReturnValue();
                nw_array_prepend(*(void *)(a2 + 312), v88);

                os_log_type_t v77 = v234;
              }

              else
              {
                if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                  }
                  os_log_type_t v198 = (os_log_s *)(id)gconnectionLogObj;
                  if (os_log_type_enabled(v198, OS_LOG_TYPE_DEBUG))
                  {
                    unint64_t v223 = nw_endpoint_handler_get_id_string(v5);
                    unsigned int v216 = nw_endpoint_handler_dry_run_string(v5);
                    nw_endpoint_t v231 = nw_endpoint_handler_copy_endpoint(v5);
                    id v199 = nw_endpoint_get_logging_description(v231);
                    id v200 = nw_endpoint_handler_state_string(v5);
                    v201 = nw_endpoint_handler_mode_string(v5);
                    id v202 = nw_endpoint_handler_copy_current_path(v5);
                    *(_DWORD *)tcp_info buf = 136448002;
                    v242 = "nw_flow_add_read_request";
                    __int16 v243 = 2082;
                    id_str = (char *)v223;
                    __int16 v245 = 2082;
                    v246 = v216;
                    __int16 v247 = 2082;
                    v248 = (void *)v199;
                    __int16 v249 = 2082;
                    nw_endpoint_t v250 = v200;
                    __int16 v251 = 2082;
                    v252 = v201;
                    __int16 v253 = 2114;
                    id v254 = v202;
                    __int16 v255 = 2048;
                    next_max_size_t size = size;
                    _os_log_impl( &dword_181A5C000,  v198,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Consumed all %zu final bytes",  buf,  0x52u);
                  }

                  os_log_type_t v77 = v234;
                }

                *(_WORD *)(a2 + 332) |= 0x80u;
              }

              request_list_report = nw_read_request_list_report(v77);
              __int16 v90 = request_list_report;
              if (request_list_report) {
                nw_read_request_fail(request_list_report, 57);
              }

              goto LABEL_115;
            }
          }
        }

            if (v131) {
              free(v131);
            }
            BOOL v27 = 0LL;
            goto LABEL_21;
          }

          __nwlog_obj();
          BOOL v107 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)os_log_type_t type = 136446210;
          *(void *)&os_log_type_t type[4] = "nw_connection_group_copy_workloop";
          BOOL v108 = (char *)_os_log_send_and_compose_impl();

          v137[0] = OS_LOG_TYPE_ERROR;
          id v142 = 0;
          if (__nwlog_fault(v108, v137, &v142))
          {
            if (v137[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              __int16 v110 = v137[0];
              if (os_log_type_enabled(v109, v137[0]))
              {
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&os_log_type_t type[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_181A5C000, v109, v110, "%{public}s called with null parameters", type, 0xCu);
              }
            }

            else if (v142)
            {
              __int16 v120 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              os_log_type_t v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              nw_endpoint_t v130 = v137[0];
              id v121 = os_log_type_enabled(v109, v137[0]);
              if (v120)
              {
                if (v121)
                {
                  *(_DWORD *)os_log_type_t type = 136446466;
                  *(void *)&os_log_type_t type[4] = "nw_connection_group_copy_workloop";
                  *(_WORD *)&type[12] = 2082;
                  *(void *)&type[14] = v120;
                  _os_log_impl( &dword_181A5C000,  v109,  v130,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  type,  0x16u);
                }

                free(v120);
                goto LABEL_240;
              }

              if (v121)
              {
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&os_log_type_t type[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v109,  v130,  "%{public}s called with null parameters, no backtrace",  type,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              os_log_type_t v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              id v125 = v137[0];
              if (os_log_type_enabled(v109, v137[0]))
              {
                *(_DWORD *)os_log_type_t type = 136446210;
                *(void *)&os_log_type_t type[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v109,  v125,  "%{public}s called with null parameters, backtrace limit exceeded",  type,  0xCu);
              }
            }
          }

LABEL_194:
        uint64_t v124 = v5;
        BOOL v91 = (*((_BYTE *)v124 + 268) & 0x20) == 0;

        if (!v91) {
          goto LABEL_250;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v125 = (id)gconnectionLogObj;
        id v126 = v124;

        os_log_type_t v127 = v126;
        BOOL v128 = (*((_BYTE *)v124 + 268) & 1) == 0;

        if (v128) {
          int v129 = "";
        }
        else {
          int v129 = "dry-run ";
        }
        nw_endpoint_t v130 = nw_endpoint_handler_copy_endpoint(v127);
        BOOL v131 = nw_endpoint_get_logging_description(v130);
        os_log_type_t v132 = v127;
        os_log_type_t v133 = v132;
        uint64_t v134 = v132[30];
        else {
          __int16 v135 = off_189BBBBF0[v134];
        }
        __int16 v235 = v135;

        nw_endpoint_t v136 = v133;
        os_log_type_t v137 = "path";
        switch(v5->mode)
        {
          case 0:
            break;
          case 1:
            os_log_type_t v137 = "resolver";
            break;
          case 2:
            os_log_type_t v137 = nw_endpoint_flow_mode_string(v136[31]);
            break;
          case 3:
            os_log_type_t v137 = "proxy";
            break;
          case 4:
            os_log_type_t v137 = "fallback";
            break;
          case 5:
            os_log_type_t v137 = "transform";
            break;
          default:
            os_log_type_t v137 = "unknown-mode";
            break;
        }

        uint64_t v229 = v137;

        os_log_type_t v138 = v126;
        nw_endpoint_t v139 = v130;
        uint64_t v140 = v124;
        nw_endpoint_t v141 = v133;
        id v142 = v129;
        int v143 = v5;
        id v144 = v125;
        uint64_t v145 = v136;
        os_unfair_lock_lock((os_unfair_lock_t)v145 + 28);
        lock = (os_unfair_lock_s *)(v145 + 14);
        id v146 = v145[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v145 + 28);
        id v222 = v145;

        nw_endpoint_t v147 = v144;
        id v148 = v143;
        uint64_t v149 = v142;
        char v150 = v141;
        nw_endpoint_t v151 = v140;
        nw_endpoint_t v152 = v139;
        char v153 = v138->id_str;
        *(_DWORD *)tcp_info buf = 136447746;
        v242 = "nw_flow_add_read_request";
        __int16 v243 = 2082;
        id_str = v138->id_str;
        __int16 v245 = 2082;
        v246 = v149;
        __int16 v247 = 2082;
        v248 = (void *)v131;
        __int16 v249 = 2082;
        nw_endpoint_t v250 = v235;
        __int16 v251 = 2082;
        v252 = v229;
        __int16 v253 = 2114;
        id v254 = v146;
        __int16 v154 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v239 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v155 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v156 = type;
          if (os_log_type_enabled(v155, type))
          {
            __int16 v157 = v222;

            __int16 v158 = v157;
            BOOL v159 = (*((_BYTE *)v151 + 268) & 1) == 0;

            if (v159) {
              __int16 v160 = "";
            }
            else {
              __int16 v160 = "dry-run ";
            }
            nw_endpoint_t v161 = nw_endpoint_handler_copy_endpoint(v158);
            __int16 v162 = nw_endpoint_get_logging_description(v161);
            __int16 v163 = v158;
            __int16 v164 = v163;
            uint64_t v165 = v150[30];
            else {
              __int16 v166 = off_189BBBBF0[v165];
            }
            nw_endpoint_t v237 = v166;

            id v185 = v164;
            __int16 v186 = "path";
            switch(v148->mode)
            {
              case 0:
                break;
              case 1:
                __int16 v186 = "resolver";
                break;
              case 2:
                __int16 v186 = nw_endpoint_flow_mode_string(v185[31]);
                break;
              case 3:
                __int16 v186 = "proxy";
                break;
              case 4:
                __int16 v186 = "fallback";
                break;
              case 5:
                __int16 v186 = "transform";
                break;
              default:
                __int16 v186 = "unknown-mode";
                break;
            }

            char v230 = v186;

            nw_endpoint_t v195 = v185;
            os_unfair_lock_lock(lock);
            id v196 = v222[8];
            os_unfair_lock_unlock(lock);

            *(_DWORD *)tcp_info buf = 136447746;
            v242 = "nw_flow_add_read_request";
            __int16 v243 = 2082;
            id_str = v153;
            __int16 v245 = 2082;
            v246 = v160;
            __int16 v247 = 2082;
            v248 = (void *)v162;
            __int16 v249 = 2082;
            nw_endpoint_t v250 = v237;
            __int16 v251 = 2082;
            v252 = v230;
            __int16 v253 = 2114;
            id v254 = v196;
            _os_log_impl( &dword_181A5C000,  v155,  v156,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No final data returned fr om nw_flow_remove_next_final_read",  buf,  0x48u);
          }
        }

        else if (v239)
        {
          __int16 v167 = __nw_create_backtrace_string();
          if (v167)
          {
            __int16 v168 = (char *)v167;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            __int16 v169 = (os_log_s *)(id)gconnectionLogObj;
            os_log_type_t v170 = type;
            if (os_log_type_enabled(v169, type))
            {
              id v171 = nw_endpoint_handler_get_id_string(v222);
              __int16 v172 = nw_endpoint_handler_dry_run_string(v222);
              nw_endpoint_t v236 = nw_endpoint_handler_copy_endpoint(v222);
              size_t v173 = nw_endpoint_get_logging_description(v236);
              __int16 v174 = nw_endpoint_handler_state_string(v222);
              uint64_t v175 = nw_endpoint_handler_mode_string(v222);
              id v176 = nw_endpoint_handler_copy_current_path(v222);
              *(_DWORD *)tcp_info buf = 136448002;
              v242 = "nw_flow_add_read_request";
              __int16 v243 = 2082;
              id_str = (char *)v171;
              __int16 v245 = 2082;
              v246 = v172;
              __int16 v247 = 2082;
              v248 = (void *)v173;
              __int16 v249 = 2082;
              nw_endpoint_t v250 = v174;
              __int16 v251 = 2082;
              v252 = v175;
              __int16 v253 = 2114;
              id v254 = v176;
              __int16 v255 = 2082;
              next_max_size_t size = (uint64_t)v168;
              _os_log_impl( &dword_181A5C000,  v169,  v170,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No final data returned from nw_flow_remove_next_final_read, dumping backtrace:%{public}s",  buf,  0x52u);
            }

            free(v168);
            goto LABEL_247;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v155 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v187 = type;
          if (os_log_type_enabled(v155, type))
          {
            __int16 v188 = nw_endpoint_handler_get_id_string(v222);
            nw_endpoint_t v189 = nw_endpoint_handler_dry_run_string(v222);
            nw_endpoint_t v190 = nw_endpoint_handler_copy_endpoint(v222);
            id v191 = nw_endpoint_get_logging_description(v190);
            __int16 v192 = nw_endpoint_handler_state_string(v222);
            id v193 = nw_endpoint_handler_mode_string(v222);
            id v194 = nw_endpoint_handler_copy_current_path(v222);
            *(_DWORD *)tcp_info buf = 136447746;
            v242 = "nw_flow_add_read_request";
            __int16 v243 = 2082;
            id_str = (char *)v188;
            __int16 v245 = 2082;
            v246 = v189;
            __int16 v247 = 2082;
            v248 = (void *)v191;
            __int16 v249 = 2082;
            nw_endpoint_t v250 = v192;
            __int16 v251 = 2082;
            v252 = v193;
            __int16 v253 = 2114;
            id v254 = v194;
            _os_log_impl( &dword_181A5C000,  v155,  v187,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No final data returned fr om nw_flow_remove_next_final_read, no backtrace",  buf,  0x48u);
          }
        }

        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v155 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v177 = type;
          if (os_log_type_enabled(v155, type))
          {
            id v178 = nw_endpoint_handler_get_id_string(v222);
            __int16 v179 = nw_endpoint_handler_dry_run_string(v222);
            nw_endpoint_t v180 = nw_endpoint_handler_copy_endpoint(v222);
            nw_endpoint_t v181 = nw_endpoint_get_logging_description(v180);
            __int16 v182 = nw_endpoint_handler_state_string(v222);
            uint64_t v183 = nw_endpoint_handler_mode_string(v222);
            id v184 = nw_endpoint_handler_copy_current_path(v222);
            *(_DWORD *)tcp_info buf = 136447746;
            v242 = "nw_flow_add_read_request";
            __int16 v243 = 2082;
            id_str = (char *)v178;
            __int16 v245 = 2082;
            v246 = v179;
            __int16 v247 = 2082;
            v248 = (void *)v181;
            __int16 v249 = 2082;
            nw_endpoint_t v250 = v182;
            __int16 v251 = 2082;
            v252 = v183;
            __int16 v253 = 2114;
            id v254 = v184;
            _os_log_impl( &dword_181A5C000,  v155,  v177,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No final data returned fr om nw_flow_remove_next_final_read, backtrace limit exceeded",  buf,  0x48u);
          }
        }

LABEL_247:
        if (v154) {
          free(v154);
        }
        goto LABEL_249;
      }

      __nwlog_obj();
      BOOL v108 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)tcp_info buf = 136446210;
      v242 = "nw_flow_remove_next_final_read";
      os_log_type_t v109 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v239 = 0;
      if (__nwlog_fault(v109, &type, &v239))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v111 = type;
          if (os_log_type_enabled(v110, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            v242 = "nw_flow_remove_next_final_read";
            _os_log_impl(&dword_181A5C000, v110, v111, "%{public}s called with null flow_protocol", buf, 0xCu);
          }
        }

        else if (v239)
        {
          uint64_t v113 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          __int16 v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v114 = type;
          BOOL v115 = os_log_type_enabled(v110, type);
          if (v113)
          {
            if (v115)
            {
              *(_DWORD *)tcp_info buf = 136446466;
              v242 = "nw_flow_remove_next_final_read";
              __int16 v243 = 2082;
              id_str = v113;
              _os_log_impl( &dword_181A5C000,  v110,  v114,  "%{public}s called with null flow_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v113);
            goto LABEL_192;
          }

          if (v115)
          {
            *(_DWORD *)tcp_info buf = 136446210;
            v242 = "nw_flow_remove_next_final_read";
            _os_log_impl( &dword_181A5C000,  v110,  v114,  "%{public}s called with null flow_protocol, no backtrace",  buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          __int16 v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v117 = type;
          if (os_log_type_enabled(v110, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            v242 = "nw_flow_remove_next_final_read";
            _os_log_impl( &dword_181A5C000,  v110,  v117,  "%{public}s called with null flow_protocol, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

  if (v63) {
    free(v63);
  }
  return 0LL;
}

    char v150 = 1LL;
    goto LABEL_297;
  }

  flags = nw_resolver_derive_service_flags(v1, *((void **)v1 + 3), *((void **)v1 + 2));
  out_signature_length = 0LL;
  attr = 0LL;
  if (nw_endpoint_get_signature(*((nw_endpoint_t *)v1 + 3), &out_signature_length) && out_signature_length)
  {
    attr = DNSServiceAttributeCreate();
    DNSServiceAttrSetValidationData();
  }

  uint64_t v5 = -65569;
  char v224 = (DNSServiceRef *)((char *)v1 + 72);
  int v225 = (char *)v1 + 256;
  os_log_type_t v219 = "invalid";
  id v221 = "DNSServiceCreateDelegateConnection";
  id v6 = 1;
  while (1)
  {
    char v8 = v6;
    id v9 = (void *)*((void *)v1 + 2);
    id v10 = v1;
    id v11 = v9;
    char v12 = getpid();
    if (!nw_parameters_has_delegated_proc_pid(v11, v12) && !nw_parameters_has_delegated_proc_uuid(v11))
    {
      Connection = DNSServiceCreateConnection((DNSServiceRef *)v1 + 8);
      goto LABEL_76;
    }

    if (!nw_parameters_has_delegated_proc_pid(v11, v12))
    {
      pid = 0;
      Connection = 0;
      goto LABEL_43;
    }

    pid = nw_parameters_get_pid(v11);
    if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
    {
      if (*v225)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        BOOL v14 = (os_log_s *)(id)gconnectionLogObj;
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_30;
        }
        *(_DWORD *)tcp_info buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_resolver_instantiate_dns_connection_for_parameters";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = (char *)v1 + 256;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&_BYTE buf[24] = pid;
        id v15 = v14;
        id v16 = "%{public}s [C%{public}s] Delegating DNS service to PID %d";
        uint64_t v17 = 28;
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)(id)gLogObj;
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
LABEL_30:

          goto LABEL_31;
        }

        id v19 = *((_DWORD *)v1 + 85);
        *(_DWORD *)tcp_info buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_resolver_instantiate_dns_connection_for_parameters";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v19;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = pid;
        id v15 = v14;
        id v16 = "%{public}s [R%u] Delegating DNS service to PID %d";
        uint64_t v17 = 24;
      }

      _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, v16, buf, v17);
      goto LABEL_30;
    }

            nw_protocol_instance_tear_down_path_inner(v89, v185);
            id v9 = 0LL;
LABEL_195:
            *((void *)v4 + 40) = 0LL;
            nw_path_override_interface(*((void **)v4 + 36), 0LL, 0);
            __int16 v118 = (void *)*((void *)v4 + 41);
            *((void *)v4 + 41) = 0LL;

            id v119 = (void *)*((void *)v4 + 42);
            *((void *)v4 + 42) = 0LL;

            __int16 v120 = (void *)*((void *)v4 + 43);
            *((void *)v4 + 43) = 0LL;

LABEL_196:
            _Block_object_dispose(v202, 8);
            _Block_object_dispose(&v219, 8);
            _Block_object_dispose(&__dst, 8);
            goto LABEL_197;
          }

          if (v4[405] < 0) {
            goto LABEL_144;
          }
          __nwlog_obj();
          __int16 v98 = (void *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_ERROR))
          {
LABEL_143:

            goto LABEL_144;
          }

          *(_DWORD *)tcp_info buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_attach_socket_protocol";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v89 + 407;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v208 = " ";
          nw_endpoint_t v209 = 2048;
          v210 = a2;
          os_log_type_t v99 = "%{public}s %{public}s%sPath %lx has no registered flow";
        }

        else
        {
          if (v4[405] < 0) {
            goto LABEL_144;
          }
          __nwlog_obj();
          __int16 v98 = (void *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_ERROR)) {
            goto LABEL_143;
          }
          *(_DWORD *)tcp_info buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_attach_socket_protocol";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v89 + 407;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v208 = " ";
          nw_endpoint_t v209 = 2048;
          v210 = a2;
          os_log_type_t v99 = "%{public}s %{public}s%sNo path found for %lx";
        }

        _os_log_impl(&dword_181A5C000, (os_log_t)v98, OS_LOG_TYPE_ERROR, v99, buf, 0x2Au);
        goto LABEL_143;
      }

      __dst = *(_OWORD *)v53;
      if ((v4[405] & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v72 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
        {
          id v73 = *(void *)(v7 + 48);
          *(_DWORD *)tcp_info buf = 136447746;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v4 + 407;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v208 = " ";
          nw_endpoint_t v209 = 2048;
          v210 = a2;
          id v211 = 1040;
          *(_DWORD *)v212 = 16;
          *(_WORD *)&v212[4] = 2096;
          *(void *)&v212[6] = &__dst;
          *(_WORD *)&v212[14] = 2112;
          *(void *)&v212[16] = v73;
          _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sPath %lx requested channel flow %{uuid_t}.16P over %@",  buf,  0x44u);
        }

        nw_endpoint_t v52 = *(void **)(v7 + 56);
      }

      id v74 = (NWConcrete_nw_path *)nw_path_flow_registration_force_update(v52);
      LODWORD(v202[0]) = 0;
      if (nw_path_flow_registration_get_nexus_instance( v74,  *(NWConcrete_nw_path_flow_registration **)(v7 + 56),  &v219,  v202))
      {
        nw_protocol_instance_bring_up_channel(v4, a2, v185, v74);
LABEL_174:

        id v9 = 1LL;
LABEL_197:
        id v71 = endpointa;
LABEL_198:

        goto LABEL_19;
      }

      if ((v4[405] & 0x80000000) == 0)
      {
        __nwlog_obj();
        os_log_type_t v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
        {
          id v76 = *(void *)(v7 + 48);
          *(_DWORD *)tcp_info buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v4 + 407;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v208 = " ";
          nw_endpoint_t v209 = 2048;
          v210 = a2;
          id v211 = 2112;
          *(void *)v212 = v76;
          _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNo nexus assignment yet, saving path %lx over %@",  buf,  0x34u);
        }
      }

      os_log_type_t v77 = (void *)*((void *)v4 + 9);
      if (!v77)
      {
        BOOL v78 = xpc_array_create(0LL, 0LL);
        os_log_type_t v79 = (void *)*((void *)v4 + 9);
        *((void *)v4 + 9) = v78;

        os_log_type_t v77 = (void *)*((void *)v4 + 9);
      }

      xpc_array_set_uint64(v77, 0xFFFFFFFFFFFFFFFFLL, a2);
      if (*((void *)v4 + 8)) {
        goto LABEL_174;
      }
      int v80 = nw_protocol_instance_copy_association(v4);
      int v81 = (void *)*((void *)v4 + 8);
      *((void *)v4 + _Block_object_dispose(va, 8) = v80;

      id v82 = (void *)*((void *)v4 + 8);
      os_log_type_t v83 = v4[405];
      if (v82)
      {
        if ((v83 & 0x80000000) == 0)
        {
          __nwlog_obj();
          id v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)tcp_info buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v4 + 407;
            *(_WORD *)&_BYTE buf[22] = 2080;
            v208 = " ";
            _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRegistering association",  buf,  0x20u);
          }

          id v82 = (void *)*((void *)v4 + 8);
        }

        id v85 = (void *)*((void *)v4 + 6);
        v189[0] = MEMORY[0x1895F87A8];
        v189[1] = 3221225472LL;
        v189[2] = __nw_protocol_instance_establish_path_block_invoke_62;
        v189[3] = &unk_189BBBAA8;
        nw_endpoint_t v190 = v4;
        nw_association_register_internal(v82, v85, v190, 0, 1, v189);
        BOOL v86 = (os_log_s *)v190;
      }

      else
      {
        if (v83 < 0) {
          goto LABEL_174;
        }
        __nwlog_obj();
        BOOL v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)tcp_info buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v4 + 407;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v208 = " ";
          _os_log_impl( &dword_181A5C000,  v86,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFailed to access protocol instance association",  buf,  0x20u);
        }
      }

      goto LABEL_174;
    }

    BOOL v14 = nw_parameters_create();
    nw_parameters_require_interface(v14, *(nw_interface_t *)(v7 + 48));
    id v15 = nw_path_create_evaluator_for_endpoint(0LL, v14);
    id v16 = (os_unfair_lock_s *)v15;
    if (v15)
    {
      uint64_t v17 = v15;
      os_unfair_lock_lock(v16 + 24);
      uint64_t v18 = (nw_path *)v17[6];
      os_unfair_lock_unlock(v16 + 24);
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    if (nw_path_has_ipv6(v18) && (id v19 = (void *)*((void *)v4 + 46)) != 0LL)
    {
      if ((v4[405] & 0x80000000) == 0)
      {
        __nwlog_obj();
        dispatch_time_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          logging_description = nw_endpoint_get_logging_description(*((void **)v4 + 46));
          *(_DWORD *)tcp_info buf = 136446979;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v4 + 407;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v208 = " ";
          nw_endpoint_t v209 = 2081;
          v210 = (uint64_t)logging_description;
          _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sUsing IPv6 Preferred Address %{private}s to establish a new path",  buf,  0x2Au);
        }

        id v19 = (void *)*((void *)v4 + 46);
      }
    }

    else
    {
      if (!nw_path_has_ipv4(v18) || (id v19 = (void *)*((void *)v4 + 45)) == 0LL)
      {
        char v13 = 0LL;
        goto LABEL_41;
      }

      if ((v4[405] & 0x80000000) == 0)
      {
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v23 = nw_endpoint_get_logging_description(*((void **)v4 + 45));
          *(_DWORD *)tcp_info buf = 136446979;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v4 + 407;
          *(_WORD *)&_BYTE buf[22] = 2080;
          v208 = " ";
          nw_endpoint_t v209 = 2081;
          v210 = (uint64_t)v23;
          _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sUsing IPv4 Preferred Address %{private}s to establish a new path",  buf,  0x2Au);
        }

        id v19 = (void *)*((void *)v4 + 45);
      }
    }

    char v13 = v19;
    os_log_type_t v24 = *(void **)(v7 + 120);
    *(void *)(v7 + 120) = v13;

LABEL_41:
    if (v13) {
      goto LABEL_43;
    }
    char v13 = *(id *)(v7 + 152);
    if (v13) {
      goto LABEL_43;
    }
    goto LABEL_49;
  }

  if ((v4[405] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)tcp_info buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_establish_path";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v4 + 407;
      *(_WORD *)&_BYTE buf[22] = 2080;
      v208 = " ";
      nw_endpoint_t v209 = 2048;
      v210 = a2;
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo path found for %lx", buf, 0x2Au);
    }

    goto LABEL_17;
  }

    if (v81) {
      free(v81);
    }
    goto LABEL_75;
  }

  id v10 = *((void *)v8 + 94);
  if (!v10)
  {
    __nwlog_obj();
    id v84 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    os_log_type_t v127 = "nw_protocol_utilities_add_input_handler";
    id v85 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v124 = 0;
    if (__nwlog_fault(v85, &type, &v124))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v87 = type;
        if (os_log_type_enabled(v86, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          os_log_type_t v127 = "nw_protocol_utilities_add_input_handler";
          _os_log_impl(&dword_181A5C000, v86, v87, "%{public}s called with null input_protocol", buf, 0xCu);
        }
      }

      else if (v124)
      {
        os_log_type_t v97 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v98 = type;
        os_log_type_t v99 = os_log_type_enabled(v86, type);
        if (v97)
        {
          if (v99)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            os_log_type_t v127 = "nw_protocol_utilities_add_input_handler";
            BOOL v128 = 2082;
            int v129 = v97;
            _os_log_impl( &dword_181A5C000,  v86,  v98,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v97);
          goto LABEL_199;
        }

        if (v99)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          os_log_type_t v127 = "nw_protocol_utilities_add_input_handler";
          _os_log_impl( &dword_181A5C000,  v86,  v98,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v116 = type;
        if (os_log_type_enabled(v86, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          os_log_type_t v127 = "nw_protocol_utilities_add_input_handler";
          _os_log_impl( &dword_181A5C000,  v86,  v116,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

                free(v88);
                goto LABEL_195;
              }

              if (!nw_path_parameters_get_logging_disabled(*(void *)(v18 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                id v19 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
                {
                  dispatch_time_t v20 = *(_DWORD *)(v13 + 448);
                  *(_DWORD *)tcp_info buf = 136446466;
                  BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
                  os_log_type_t v116 = 1024;
                  *(_DWORD *)os_log_type_t v117 = v20;
                  _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Connection parameters were modified",  buf,  0x12u);
                }
              }
            }

            else
            {
LABEL_7:
              os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
            }
          }

          uint64_t v21 = *(void **)(v13 + 16);
          goto LABEL_19;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v35 = (id)gLogObj;
        *(_DWORD *)tcp_info buf = 136446210;
        BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
        id v36 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v112 = 0;
        if (__nwlog_fault(v36, &type, &v112))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v37 = (os_log_s *)(id)gLogObj;
            uint64_t v38 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)tcp_info buf = 136446210;
              BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed",  buf,  0xCu);
            }
          }

          else if (v112)
          {
            nw_endpoint_t v52 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v37 = (os_log_s *)(id)gLogObj;
            __int16 v53 = type;
            __int16 v54 = os_log_type_enabled(v37, type);
            if (v52)
            {
              if (v54)
              {
                *(_DWORD *)tcp_info buf = 136446466;
                BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
                os_log_type_t v116 = 2082;
                *(void *)os_log_type_t v117 = v52;
                _os_log_impl( &dword_181A5C000,  v37,  v53,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v52);
              if (!v36) {
                goto LABEL_120;
              }
              goto LABEL_85;
            }

            if (v54)
            {
              *(_DWORD *)tcp_info buf = 136446210;
              BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v37,  v53,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v37 = (os_log_s *)(id)gLogObj;
            uint64_t v60 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)tcp_info buf = 136446210;
              BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl( &dword_181A5C000,  v37,  v60,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v36) {
          goto LABEL_120;
        }
LABEL_85:
        free(v36);
        goto LABEL_120;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v31 = (id)gLogObj;
      *(_DWORD *)tcp_info buf = 136446210;
      BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
      int v32 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v112 = 0;
      if (__nwlog_fault(v32, &type, &v112))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          nw_endpoint_t v33 = (os_log_s *)(id)gLogObj;
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s nw_parameters_copy failed", buf, 0xCu);
          }
        }

        else if (v112)
        {
          uint64_t v39 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          nw_endpoint_t v33 = (os_log_s *)(id)gLogObj;
          os_log_type_t v40 = type;
          os_log_type_t v41 = os_log_type_enabled(v33, type);
          if (v39)
          {
            if (v41)
            {
              *(_DWORD *)tcp_info buf = 136446466;
              BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
              os_log_type_t v116 = 2082;
              *(void *)os_log_type_t v117 = v39;
              _os_log_impl( &dword_181A5C000,  v33,  v40,  "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v39);
            if (!v32) {
              goto LABEL_74;
            }
            goto LABEL_73;
          }

          if (v41)
          {
            *(_DWORD *)tcp_info buf = 136446210;
            BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_181A5C000, v33, v40, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          nw_endpoint_t v33 = (os_log_s *)(id)gLogObj;
          __int16 v58 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            BOOL v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl( &dword_181A5C000,  v33,  v58,  "%{public}s nw_parameters_copy failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v32)
      {
LABEL_74:
        uint64_t v59 = 0LL;
LABEL_122:

        id v74 = v110;
        goto LABEL_123;
      }

        if (v69) {
          free(v69);
        }
        os_log_type_t v23 = 0LL;
LABEL_27:

        os_log_type_t v24 = *(_BYTE *)(v3 + 600);
        if ((v24 & 1) != 0)
        {
          BOOL v25 = *(void **)(v3 + 592);
          if (v25)
          {
            os_release(v25);
            os_log_type_t v24 = *(_BYTE *)(v3 + 600);
          }
        }

        *(void *)(v3 + 592) = v23;
        *(_BYTE *)(v3 + 600) = v24 | 1;
        *(void *)os_log_type_t v106 = 0LL;
        BOOL v107 = (uint64_t)v106;
        BOOL v108 = 0x3802000000LL;
        os_log_type_t v109 = __Block_byref_object_copy__35;
        __int16 v110 = __Block_byref_object_dispose__36;
        object = 0LL;
        v112 |= 1u;
        uint64_t v102 = 0LL;
        os_log_type_t v103 = &v102;
        nw_endpoint_t v104 = 0x2000000000LL;
        id v105 = 0;
        os_log_type_t v26 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)parameters);
        iterate_block[0] = MEMORY[0x1895F87A8];
        iterate_block[1] = 0x40000000LL;
        iterate_block[2] = ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke;
        iterate_block[3] = &unk_189BBB000;
        iterate_void block[4] = &v102;
        iterate_block[5] = v106;
        iterate_block[6] = v3;
        nw_protocol_stack_iterate_application_protocols(v26, iterate_block);
        if (!*((_BYTE *)v103 + 24))
        {
LABEL_42:
          os_log_type_t v34 = (void *)sec_protocol_configuration_copy_singleton();
          if (sec_protocol_configuration_tls_required() && cStr)
          {
            os_log_type_t v35 = sec_protocol_configuration_tls_required_for_host();
            if ((v11 & 1) != 0)
            {
              if (*(void *)(v107 + 40)) {
                id v36 = v35;
              }
              else {
                id v36 = 0;
              }
              if (v36 == 1)
              {
                id v37 = (void *)sec_protocol_configuration_copy_transformed_options_for_host();
                if (v37)
                {
                  os_release(v37);
                  char v12 = 1LL;
                  if (!v34) {
                    goto LABEL_79;
                  }
                  goto LABEL_78;
                }
              }

              goto LABEL_224;
            }

            if (v35)
            {
              if ((*(_BYTE *)(v3 + 198) & 1) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v38 = (os_log_s *)gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)tcp_info buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_http_security_connect";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v3 + 114;
                  *(_WORD *)&_BYTE buf[22] = 2080;
                  size_t v123 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sATS requires TLS but is not currently enforced",  buf,  0x20u);
                }
              }
            }
          }

          else if ((v11 & 1) != 0)
          {
            goto LABEL_224;
          }

          char v12 = 1LL;
          if (!*(void *)(v3 + 576) || !cStr) {
            goto LABEL_77;
          }
          uint64_t v39 = v20;
          os_log_type_t v40 = nw_protocol_options_copy_definition(v39);
          if (nw_protocol_copy_http_security_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http_security_definition_onceToken, &__block_literal_global_33_73355);
          }
          os_log_type_t v41 = nw_protocol_definition_is_equal( v40,  (nw_protocol_definition_t)nw_protocol_copy_http_security_definition_http_security_definition);

          if (v41)
          {
            *(void *)BOOL v128 = 0LL;
            *(void *)&v128[8] = v128;
            *(void *)&v128[16] = 0x2020000000LL;
            LOBYTE(v129) = 0;
            *(void *)tcp_info buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = __nw_http_security_options_get_skip_hsts_lookup_block_invoke;
            size_t v123 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BC60A8;
            uint64_t v124 = (void (*)(uint64_t))v128;
            nw_protocol_options_access_handle(v39, buf);
            char v42 = *(_BYTE *)(*(void *)&v128[8] + 24LL) == 0;
            _Block_object_dispose(v128, 8);

            if (!v42) {
              goto LABEL_224;
            }
LABEL_64:
            __int16 v43 = (id *)*(id *)(v3 + 576);
            if (v43)
            {
              os_log_type_t v44 = v43;
              char v45 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x600u);
              buf[0] = 0;
              BOOL v46 = [v44[1] shouldPromoteHostToHTTPS:v45 isPreload:buf];
              nw_endpoint_t v47 = buf[0];

              if (v46)
              {
                *(void *)BOOL v128 = 0LL;
                *(void *)&v128[8] = v128;
                *(void *)&v128[16] = 0x3802000000LL;
                int v129 = __Block_byref_object_copy__39;
                nw_endpoint_t v130 = __Block_byref_object_dispose__40;
                BOOL v131 = nw_http_security_options_copy_handler(v39);
                v132 |= 1u;
                BOOL v48 = (dispatch_queue_s *)nw_http_security_options_copy_handler_queue(v39);
                os_log_type_t v49 = v48;
                if (*(void *)(*(void *)&v128[8] + 40LL))
                {
                  if (!v48) {
                    goto LABEL_73;
                  }
                  nw_protocol_plugin_retry_begin_async(v3 + 344);
                  *(void *)tcp_info buf = MEMORY[0x1895F87A8];
                  *(void *)&buf[8] = 0x40000000LL;
                  *(void *)&buf[16] = ___ZL24nw_http_security_connectP25nw_protocol_http_securityP11nw_protocol_block_invoke_41;
                  size_t v123 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BBB108;
                  uint64_t v124 = (void (*)(uint64_t))v128;
                  id v125 = type;
                  os_log_type_t v127 = v47;
                  id v126 = v3;
                  dispatch_async(v49, buf);
                }

                else if (!v48)
                {
                  goto LABEL_73;
                }

                dispatch_release(v49);
LABEL_73:
                _Block_object_dispose(v128, 8);
                if ((v132 & 1) != 0 && v131) {
                  _Block_release(v131);
                }
                char v12 = 0LL;
LABEL_77:
                if (!v34)
                {
LABEL_79:
                  if (v26) {
                    os_release(v26);
                  }
                  _Block_object_dispose(&v102, 8);
                  _Block_object_dispose(v106, 8);
                  if ((v112 & 1) != 0 && object) {
                    os_release(object);
                  }
                  os_release(v20);
LABEL_85:
                  _Block_object_dispose(type, 8);
                  if ((v119 & 1) != 0 && v118) {
                    os_release(v118);
                  }
                  return v12;
                }

        *(_DWORD *)(a2 + 140) = v21;
        if (!(_DWORD)v21)
        {
          if (header_out_write_value((int *)a1, a2, 0, 1))
          {
            nw_endpoint_t v161 = 3653;
            goto LABEL_348;
          }

    if (v83) {
      free(v83);
    }
    goto LABEL_208;
  }

  if (!v134)
  {
    __nwlog_obj();
    BOOL v86 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
    os_log_type_t v87 = (char *)_os_log_send_and_compose_impl();

    uu[0] = OS_LOG_TYPE_ERROR;
    nw_endpoint_t v136 = 0;
    if (__nwlog_fault(v87, uu, &v136))
    {
      if (uu[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v89 = uu[0];
        if (os_log_type_enabled(v88, uu[0]))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl(&dword_181A5C000, v88, v89, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v136)
      {
        BOOL v100 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v101 = uu[0];
        uint64_t v102 = os_log_type_enabled(v88, uu[0]);
        if (v100)
        {
          if (v102)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v100;
            _os_log_impl( &dword_181A5C000,  v88,  v101,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v100);
          goto LABEL_200;
        }

        if (v102)
        {
          *(_DWORD *)tcp_info buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl(&dword_181A5C000, v88, v101, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        size_t v123 = uu[0];
        if (os_log_type_enabled(v88, uu[0]))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          *(void *)&uint8_t buf[4] = "-[nw_ip_channel_inbox initWithPath:flow:parameters:delegate:]";
          _os_log_impl( &dword_181A5C000,  v88,  v123,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

            if (v60) {
              free(v60);
            }
            goto LABEL_51;
          }
                        }

                        if (!v79) {
                          goto LABEL_197;
                        }
                        goto LABEL_196;
                      }

                      if (v64 == 20)
                      {
                        if (nw_context_copy_implicit_context::onceToken != -1) {
                          dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
                        }
                        id v82 = (id)nw_context_copy_implicit_context::implicit_context;
                        os_log_type_t v83 = v82 == v141;

                        if (v83)
                        {
                          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                          id v84 = nw_path_create_bridged_flow_director(v141, &type);
                          if (type) {
                            id v85 = v84;
                          }
                          else {
                            id v85 = 0;
                          }
                          if (v85 == 1)
                          {
                            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                            networkd_settings_init();
                            BOOL v86 = (os_log_s *)(id)gLogObj;
                            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
                            {
                              *(_DWORD *)tcp_info buf = 136446210;
                              *(void *)&uint8_t buf[4] = "nw_path_necp_check_for_updates";
                              os_log_type_t v87 = "%{public}s In-process flow divert director created";
                              id v88 = v86;
                              os_log_type_t v89 = OS_LOG_TYPE_DEFAULT;
                              goto LABEL_190;
                            }
                          }

                          else
                          {
                            if ((v84 & 1) != 0) {
                              goto LABEL_198;
                            }
                            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                            networkd_settings_init();
                            BOOL v86 = (os_log_s *)(id)gLogObj;
                            if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)tcp_info buf = 136446210;
                              *(void *)&uint8_t buf[4] = "nw_path_necp_check_for_updates";
                              os_log_type_t v87 = "%{public}s Failed to create in-process flow divert director";
                              id v88 = v86;
                              os_log_type_t v89 = OS_LOG_TYPE_ERROR;
LABEL_190:
                              _os_log_impl(&dword_181A5C000, v88, v89, v87, buf, 0xCu);
                            }
                          }

                          goto LABEL_198;
                        }

                        goto LABEL_198;
                      }

                      v63 += v65 + 5;
                      if (v77 > v19) {
                        goto LABEL_197;
                      }
                      continue;
                    }

                    break;
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v67 = (id)gLogObj;
                  *(_DWORD *)tcp_info buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
                  *(_WORD *)&_BYTE buf[12] = 2048;
                  *(void *)&buf[14] = v63;
                  *(_WORD *)&_BYTE buf[22] = 2048;
                  char v153 = v13;
                  __int16 v154 = 1024;
                  *(_DWORD *)id v155 = v65;
                  id v68 = (void *)_os_log_send_and_compose_impl();

                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  id v148 = 0;
                  if (__nwlog_fault((const char *)v68, &type, &v148))
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      nw_endpoint_t v69 = (os_log_s *)(id)gLogObj;
                      id v70 = type;
                      if (os_log_type_enabled(v69, type))
                      {
                        *(_DWORD *)tcp_info buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
                        *(_WORD *)&_BYTE buf[12] = 2048;
                        *(void *)&buf[14] = v63;
                        *(_WORD *)&_BYTE buf[22] = 2048;
                        char v153 = v13;
                        __int16 v154 = 1024;
                        *(_DWORD *)id v155 = v65;
                        _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u",  buf,  0x26u);
                      }

                      goto LABEL_144;
                    }

                    if (v148)
                    {
                      id v71 = (char *)__nw_create_backtrace_string();
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      id v72 = (os_log_s *)(id)gLogObj;
                      id v73 = type;
                      id v74 = os_log_type_enabled(v72, type);
                      if (v71)
                      {
                        if (v74)
                        {
                          *(_DWORD *)tcp_info buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
                          *(_WORD *)&_BYTE buf[12] = 2048;
                          *(void *)&buf[14] = v63;
                          *(_WORD *)&_BYTE buf[22] = 2048;
                          char v153 = v13;
                          __int16 v154 = 1024;
                          *(_DWORD *)id v155 = v65;
                          *(_WORD *)&v155[4] = 2082;
                          *(void *)&v155[6] = v71;
                          _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, dumping backtrace:%{public}s",  buf,  0x30u);
                        }

                        free(v71);
                        if (!v68)
                        {
LABEL_159:
                          id v19 = v144;
                          char v8 = (unsigned __int8 *)v145;
                          dispatch_time_t v20 = v143;
                          goto LABEL_160;
                        }

      goto LABEL_195;
    }

    __nwlog_obj();
    char v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    __int16 v94 = "nw_agent_client_attach_protocol_block_invoke";
    int v32 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v91 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v94 = "nw_agent_client_attach_protocol_block_invoke";
        _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s called with null (client->framer_protocol == NULL)",  buf,  0xCu);
      }
    }

    else if (v91)
    {
      id v73 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_endpoint_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v74 = type;
      os_log_type_t v75 = os_log_type_enabled(v33, type);
      if (v73)
      {
        if (v75)
        {
          *(_DWORD *)tcp_info buf = 136446466;
          __int16 v94 = "nw_agent_client_attach_protocol_block_invoke";
          os_log_type_t v95 = 2082;
          *(void *)nw_endpoint_t v96 = v73;
          _os_log_impl( &dword_181A5C000,  v33,  v74,  "%{public}s called with null (client->framer_protocol == NULL), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v73);
        goto LABEL_184;
      }

      if (v75)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v94 = "nw_agent_client_attach_protocol_block_invoke";
        _os_log_impl( &dword_181A5C000,  v33,  v74,  "%{public}s called with null (client->framer_protocol == NULL), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_endpoint_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v87 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        __int16 v94 = "nw_agent_client_attach_protocol_block_invoke";
        _os_log_impl( &dword_181A5C000,  v33,  v87,  "%{public}s called with null (client->framer_protocol == NULL), backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_184:
    if (v32) {
      free(v32);
    }
    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v23 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    os_log_type_t v24 = *(void *)(a1 + 32) + 8LL;
    *(_DWORD *)tcp_info buf = 136446722;
    __int16 v94 = "nw_agent_client_attach_protocol_block_invoke_2";
    os_log_type_t v95 = 1042;
    *(_DWORD *)nw_endpoint_t v96 = 16;
    *(_WORD *)&v96[4] = 2098;
    *(void *)&v96[6] = v24;
    _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s Not attaching protocol to closed client %{public,uuid_t}.16P",  buf,  0x1Cu);
  }
}

    if ((*((char *)v11 + 32) & 0x80000000) == 0)
    {
      if (!a2)
      {
        os_log_type_t v137 = v281;
        if (nw_endpoint_flow_connect(v280))
        {
LABEL_223:
          *((_BYTE *)v11 + 32) |= 0x80u;
          goto LABEL_236;
        }

        goto LABEL_208;
      }

      uint64_t handle = a2->handle;
      os_log_type_t v137 = v281;
      if (handle == &nw_protocol_ref_counted_handle)
      {
        callbacks = a2[1].callbacks;
        if (callbacks) {
          a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
        *(void *)&v307 = a2;
        id v184 = BYTE8(v307) | 1;
      }

      else
      {
        *(void *)&v307 = a2;
        id v184 = BYTE8(v307) & 0xFE;
      }

      BYTE8(v307) = v184;
      id v199 = (void *)*((void *)v11 + 52);
      if (v199 == &nw_protocol_ref_counted_handle)
      {
        v201 = *((void *)v11 + 58);
        if (v201) {
          *((void *)v11 + 5_Block_object_dispose(va, 8) = v201 + 1;
        }
        v289 = (uint64_t)v11 + 376;
        id v200 = v290 | 1;
      }

      else
      {
        v289 = (uint64_t)v11 + 376;
        id v200 = v290 & 0xFE;
      }

      v290 = v200;
      id v202 = a2->callbacks;
      if (v202)
      {
        connect = (uint64_t (*)(void))v202->connect;
        if (connect)
        {
          __int16 v204 = connect();
          if (v199 != &nw_protocol_ref_counted_handle) {
            goto LABEL_221;
          }
          goto LABEL_220;
        }
      }

      __nwlog_obj();
      v248 = (void *)objc_claimAutoreleasedReturnValue();
      identifier = a2->identifier;
      *(_DWORD *)tcp_info buf = 136446722;
      v292 = "__nw_protocol_connect";
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      v293 = 2082;
      id v294 = (char *)identifier;
      v295 = 2048;
      v296 = a2;
      nw_endpoint_t v250 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v287 = 0;
      if (__nwlog_fault(v250, &type, &v287))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v251 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v252 = type;
          if (os_log_type_enabled(v251, type))
          {
            __int16 v253 = a2->identifier;
            if (!v253) {
              __int16 v253 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)tcp_info buf = 136446722;
            v292 = "__nw_protocol_connect";
            v293 = 2082;
            id v294 = (char *)v253;
            v295 = 2048;
            v296 = a2;
            _os_log_impl( &dword_181A5C000,  v251,  v252,  "%{public}s protocol %{public}s (%p) has invalid connect callback",  buf,  0x20u);
          }

LABEL_192:
      if (v109) {
        free(v109);
      }
      goto LABEL_194;
    }

    __nwlog_obj();
    nw_endpoint_t v96 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)tcp_info buf = 136446210;
    v242 = "nw_flow_add_read_request";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v239 = 0;
    if (__nwlog_fault(v21, &type, &v239))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v97 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)tcp_info buf = 136446210;
          v242 = "nw_flow_add_read_request";
          _os_log_impl(&dword_181A5C000, v22, v97, "%{public}s called with null read_request", buf, 0xCu);
        }

    goto LABEL_193;
  }

  if (!v93)
  {
    __nwlog_obj();
    BOOL v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v92 = type;
    if (os_log_type_enabled(v65, type))
    {
      *(_DWORD *)tcp_info buf = 136446210;
      nw_endpoint_t v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl( &dword_181A5C000,  v65,  v92,  "%{public}s called with null should_release_snapshot, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_192;
  }

  id v84 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  BOOL v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  id v85 = type;
  BOOL v86 = os_log_type_enabled(v65, type);
  if (!v84)
  {
    if (v86)
    {
      *(_DWORD *)tcp_info buf = 136446210;
      nw_endpoint_t v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl( &dword_181A5C000,  v65,  v85,  "%{public}s called with null should_release_snapshot, no backtrace",  buf,  0xCu);
    }

    goto LABEL_192;
  }

  if (v86)
  {
    *(_DWORD *)tcp_info buf = 136446466;
    nw_endpoint_t v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
    os_log_type_t v97 = 2082;
    __int16 v98 = (uint64_t)v84;
    _os_log_impl( &dword_181A5C000,  v65,  v85,  "%{public}s called with null should_release_snapshot, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v84);
  if (v64) {
LABEL_194:
  }
    free(v64);
LABEL_8:

  if (*a2) {
    goto LABEL_11;
  }
  char v12 = calloc(1uLL, 0xB8uLL);
  if (v12)
  {
LABEL_10:
    *a2 = (uint64_t)v12;
    *a3 = 184LL;
    *a4 = 1;
LABEL_11:
    char v13 = v10[18];
    BOOL v14 = v13;
    if (v13)
    {
      id v15 = (NWConcrete_nw_endpoint_handler *)v13;
      uint64_t mode = v15->mode;

      if ((_DWORD)mode == 2)
      {
        uint64_t v17 = nw_endpoint_handler_copy_flow(v15);
        uint64_t v18 = *((void *)v17 + 133);

        goto LABEL_49;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      else {
        dispatch_time_t v20 = off_189BBBBC0[mode];
      }
      *(_DWORD *)tcp_info buf = 136446722;
      nw_endpoint_t v96 = "nw_endpoint_handler_get_sent_application_byte_count";
      os_log_type_t v97 = 2082;
      __int16 v98 = (uint64_t)v20;
      os_log_type_t v99 = 2082;
      BOOL v100 = (uint64_t)"flow";
      uint64_t v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      id v93 = 0;
      if (__nwlog_fault(v21, &type, &v93))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v22 = (os_log_s *)(id)gLogObj;
          os_log_type_t v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            else {
              os_log_type_t v24 = off_189BBBBC0[mode];
            }
            *(_DWORD *)tcp_info buf = 136446722;
            nw_endpoint_t v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            os_log_type_t v97 = 2082;
            __int16 v98 = (uint64_t)v24;
            os_log_type_t v99 = 2082;
            BOOL v100 = (uint64_t)"flow";
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
          }
        }

        else if (v93)
        {
          BOOL v25 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v22 = (os_log_s *)(id)gLogObj;
          os_log_type_t v26 = type;
          BOOL v27 = os_log_type_enabled(v22, type);
          if (v25)
          {
            if (v27)
            {
              else {
                char v28 = off_189BBBBC0[mode];
              }
              *(_DWORD *)tcp_info buf = 136446978;
              nw_endpoint_t v96 = "nw_endpoint_handler_get_sent_application_byte_count";
              os_log_type_t v97 = 2082;
              __int16 v98 = (uint64_t)v28;
              os_log_type_t v99 = 2082;
              BOOL v100 = (uint64_t)"flow";
              BOOL v101 = 2082;
              uint64_t v102 = v25;
              _os_log_impl( &dword_181A5C000,  v22,  v26,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v25);
            if (!v21) {
              goto LABEL_48;
            }
            goto LABEL_47;
          }

          if (v27)
          {
            else {
              char v31 = off_189BBBBC0[mode];
            }
            *(_DWORD *)tcp_info buf = 136446722;
            nw_endpoint_t v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            os_log_type_t v97 = 2082;
            __int16 v98 = (uint64_t)v31;
            os_log_type_t v99 = 2082;
            BOOL v100 = (uint64_t)"flow";
            _os_log_impl( &dword_181A5C000,  v22,  v26,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v22 = (os_log_s *)(id)gLogObj;
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v22, type))
          {
            else {
              BOOL v30 = off_189BBBBC0[mode];
            }
            *(_DWORD *)tcp_info buf = 136446722;
            nw_endpoint_t v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            os_log_type_t v97 = 2082;
            __int16 v98 = (uint64_t)v30;
            os_log_type_t v99 = 2082;
            BOOL v100 = (uint64_t)"flow";
            _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
          }
        }

  if (v53) {
    free(v53);
  }
}

      if (v101) {
        free(v101);
      }
      return 1LL;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v102 = (os_log_s *)__nwlog_obj();
      os_log_type_t v103 = v130[0];
      if (os_log_type_enabled(v102, (os_log_type_t)v130[0]))
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
        nw_endpoint_t v104 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_191;
      }

      goto LABEL_192;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v102 = (os_log_s *)__nwlog_obj();
    os_log_type_t v103 = v130[0];
    os_log_type_t v106 = os_log_type_enabled(v102, (os_log_type_t)v130[0]);
    if (!backtrace_string)
    {
      if (v106)
      {
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
        nw_endpoint_t v104 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_191;
      }

      goto LABEL_192;
    }

    if (v106)
    {
      *(_DWORD *)tcp_info buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http_authentication_handle_challenge";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      BOOL v107 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_172:
      _os_log_impl(&dword_181A5C000, v102, v103, v107, buf, 0x16u);
    }

        if (v68) {
          free(v68);
        }

        BOOL v14 = endpoint;
        goto LABEL_225;
      }

      __nwlog_obj();
      os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)os_log_type_t v132 = 136446210;
      *(void *)&v132[4] = "nw_http_cookie_options_get_should_not_save_cookies";
      LODWORD(v109) = 12;
      BOOL v108 = v132;
      id v37 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      id v121 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v37, type, &v121))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v41 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)os_log_type_t v132 = 136446210;
            *(void *)&v132[4] = "nw_http_cookie_options_get_should_not_save_cookies";
            _os_log_impl(&dword_181A5C000, v38, v41, "%{public}s protocol options are not http_cookie", v132, 0xCu);
          }

        free(v71);
        goto LABEL_193;
      }

      __nwlog_obj();
      char v45 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)BOOL v107 = 136446210;
      *(void *)&v107[4] = "nw_http_cookie_options_get_should_not_send_cookies";
      char v42 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(v111[0]) = 16;
      LOBYTE(v110[0]) = 0;
      if (__nwlog_fault(v42, v111, v110))
      {
        id v93 = v42;
        if (LOBYTE(v111[0]) == 17)
        {
          __nwlog_obj();
          __int16 v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v46 = v111[0];
          if (os_log_type_enabled(v43, v111[0]))
          {
            *(_DWORD *)BOOL v107 = 136446210;
            *(void *)&v107[4] = "nw_http_cookie_options_get_should_not_send_cookies";
            _os_log_impl(&dword_181A5C000, v43, v46, "%{public}s protocol options are not http_cookie", v107, 0xCu);
          }

                    goto LABEL_193;
                  }

                  if (!v112)
                  {
                    __nwlog_obj();
                    os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    uint64_t v102 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)tcp_info buf = 136446210;
                      BOOL v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl( &dword_181A5C000,  v89,  v102,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
                    }

                    goto LABEL_192;
                  }

                  nw_endpoint_t v96 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  os_log_type_t v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v97 = type;
                  __int16 v98 = os_log_type_enabled(v89, type);
                  if (!v96)
                  {
                    if (v98)
                    {
                      *(_DWORD *)tcp_info buf = 136446210;
                      BOOL v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl( &dword_181A5C000,  v89,  v97,  "%{public}s called with null parameters, no backtrace",  buf,  0xCu);
                    }

                    goto LABEL_192;
                  }

                  if (v98)
                  {
                    *(_DWORD *)tcp_info buf = 136446466;
                    BOOL v115 = "nw_endpoint_handler_create_from_protocol_listener";
                    os_log_type_t v116 = 2082;
                    *(void *)os_log_type_t v117 = v96;
                    _os_log_impl( &dword_181A5C000,  v89,  v97,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v96);
                }

    if (v80) {
      free(v80);
    }
    goto LABEL_155;
  }

  if (!*(void *)(v6 + 224)) {
    goto LABEL_98;
  }
  int v32 = *(dispatch_data_s **)(v6 + 392);
  if (!v32)
  {
    if ((v7 & 0x400) != 0)
    {
      __int16 v58 = *(void **)(v6 + 448);
      if (v58)
      {
        if (v4)
        {
          if (v139)
          {
            *(void *)os_log_type_t type = 0LL;
            nw_endpoint_t v141 = (uint64_t)type;
            id v142 = 0x2000000000LL;
            LOBYTE(v143) = 0;
            *(void *)__int16 v160 = MEMORY[0x1895F87A8];
            *(void *)&v160[8] = 0x40000000LL;
            *(void *)&v160[16] = ___ZL29nw_masque_match_demux_patternPKhmP19nw_protocol_options_block_invoke;
            nw_endpoint_t v161 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BBA808;
            __int16 v163 = v139;
            __int16 v164 = v4;
            __int16 v162 = type;
            nw_demux_options_enumerate_patterns(v58, (uint64_t)v160);
            uint64_t v59 = *(unsigned __int8 *)(v141 + 24);
            _Block_object_dispose(type, 8);
            if (v59)
            {
              uint64_t v60 = *(void *)(a1 + 32);
              if ((!v60 || (*(_BYTE *)(v60 + 529) & 1) == 0) && gLogDatapath)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                os_log_type_t v111 = (os_log_s *)gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                {
                  os_log_type_t v112 = *(void *)(a1 + 32);
                  uint64_t v113 = (const char *)(v112 + 531);
                  os_log_type_t v114 = "";
                  if (!v112) {
                    uint64_t v113 = "";
                  }
                  *(void *)&v160[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
                  *(_WORD *)&v160[12] = 2082;
                  *(_DWORD *)__int16 v160 = 136446978;
                  if (v112) {
                    os_log_type_t v114 = " ";
                  }
                  *(void *)&v160[14] = v113;
                  *(_WORD *)&v160[22] = 2080;
                  nw_endpoint_t v161 = (uint64_t (*)(uint64_t, uint64_t))v114;
                  LOWORD(v162) = 1024;
                  *(_DWORD *)((char *)&v162 + 2) = v139;
                  _os_log_impl( &dword_181A5C000,  v111,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDetected packet of length %u to forward directly to demux (fast path)",  v160,  0x26u);
                }
              }

              __int16 v61 = *(void *)(a1 + 56);
              goto LABEL_157;
            }
          }
        }
      }
    }

    goto LABEL_98;
  }

  nw_endpoint_t v33 = dispatch_data_get_size(v32);
  if (v33 + 1 >= v139) {
    goto LABEL_98;
  }
  os_log_type_t v34 = v33;
  os_log_type_t v35 = *(dispatch_data_s **)(v6 + 408);
  if (v35)
  {
    if (dispatch_data_get_size(v35) != v34) {
      goto LABEL_98;
    }
  }

  if ((*v4 & 0xC0) != 0x40) {
    goto LABEL_98;
  }
  id v36 = dispatch_data_create(v4 + 1, v34, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A98]);
  is_equal = nw_dispatch_data_is_equal(v36, *(dispatch_data_s **)(*(void *)(a1 + 32) + 392LL));
  uint64_t v38 = is_equal;
  if (is_equal)
  {
    uint64_t v39 = *(void *)(a1 + 32);
    if ((!v39 || (*(_BYTE *)(v39 + 529) & 1) == 0) && gLogDatapath)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      nw_endpoint_t v96 = (os_log_s *)gprivacy_proxyLogObj;
      os_log_type_t v97 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
      uint64_t v39 = *(void *)(a1 + 32);
      if (v97)
      {
        __int16 v98 = v39 == 0;
        if (v39) {
          os_log_type_t v99 = (const char *)(v39 + 531);
        }
        else {
          os_log_type_t v99 = "";
        }
        *(_DWORD *)__int16 v160 = 136446978;
        *(void *)&v160[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
        *(_WORD *)&v160[12] = 2082;
        *(void *)&v160[14] = v99;
        if (v98) {
          BOOL v100 = "";
        }
        else {
          BOOL v100 = " ";
        }
        *(_WORD *)&v160[22] = 2080;
        nw_endpoint_t v161 = (uint64_t (*)(uint64_t, uint64_t))v100;
        LOWORD(v162) = 1024;
        *(_DWORD *)((char *)&v162 + 2) = v139;
        _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDetected packet of length %u to forward directly to demux (fast path)",  v160,  0x26u);
        uint64_t v39 = *(void *)(a1 + 32);
      }
    }

    os_log_type_t v40 = *(dispatch_data_s **)(v39 + 408);
    if (v40)
    {
      nw_dispatch_data_copyout(v40, (uint64_t)(v4 + 1), v34);
      os_log_type_t v41 = *(void *)(a1 + 32);
      if (!v41 || (*(_BYTE *)(v41 + 529) & 1) == 0)
      {
        if (gLogDatapath)
        {
          if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
          }
          BOOL v115 = (os_log_s *)gprivacy_proxyLogObj;
          if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v116 = *(void *)(a1 + 32);
            os_log_type_t v117 = "";
            __int16 v118 = v116 == 0;
            if (v116) {
              id v119 = (const char *)(v116 + 531);
            }
            else {
              id v119 = "";
            }
            *(_DWORD *)__int16 v160 = 136446722;
            *(void *)&v160[4] = "nw_protocol_masque_finalize_output_frames_block_invoke";
            if (!v118) {
              os_log_type_t v117 = " ";
            }
            *(_WORD *)&v160[12] = 2082;
            *(void *)&v160[14] = v119;
            *(_WORD *)&v160[22] = 2080;
            nw_endpoint_t v161 = (uint64_t (*)(uint64_t, uint64_t))v117;
            _os_log_impl( &dword_181A5C000,  v115,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sReplacing with virtual CID before forwarding",  v160,  0x20u);
          }
        }
      }
    }

    char v42 = *(void *)(a1 + 56);
    *(void *)(a2 + 32) = 0LL;
    __int16 v43 = *(uint64_t **)(v42 + 8);
    *(void *)(a2 + 40) = v43;
    NWConcrete_nw_endpoint_handler *v43 = a2;
    *(void *)(v42 + _Block_object_dispose(va, 8) = a2 + 32;
  }

  if (v36) {
    dispatch_release(v36);
  }
  if (!v38)
  {
LABEL_98:
    uint64_t v62 = *(void *)(*(void *)(a1 + 48) + 32LL);
    *(void *)os_log_type_t type = 0LL;
    nw_endpoint_t v141 = (uint64_t)type;
    if ((*(unsigned int (**)(void))(*(void *)(v62 + 24) + 88LL))())
    {
      *(void *)__int16 v160 = 0LL;
      *(void *)&v160[8] = v160;
      *(void *)&v160[16] = 0x2000000000LL;
      LOBYTE(v161) = 0;
      v120[0] = MEMORY[0x1895F87A8];
      v120[1] = 0x40000000LL;
      id v121 = ___ZL41nw_protocol_masque_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke_129;
      id v122 = &unk_189BBA798;
      BOOL v128 = v139;
      int v63 = *(void *)(a1 + 32);
      size_t v123 = v160;
      uint64_t v124 = type;
      id v125 = v63;
      id v126 = v4;
      os_log_type_t v127 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
      uint64_t v64 = *(void *)type;
      do
      {
        if (!v64) {
          break;
        }
        BOOL v65 = *(void *)(v64 + 32);
        BOOL v66 = ((uint64_t (*)(void *))v121)(v120);
        uint64_t v64 = v65;
      }

      while ((v66 & 1) != 0);
LABEL_102:
      _Block_object_dispose(v160, 8);
LABEL_114:
      nw_frame_finalize(a2);
      return 1LL;
    }

    uint64_t v67 = *(void *)(a1 + 32);
    if (v67 && (*(_BYTE *)(v67 + 529) & 1) != 0) {
      goto LABEL_114;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    nw_endpoint_t v52 = (os_log_s *)gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_114;
    }
    id v68 = *(void *)(a1 + 32);
    __int16 v54 = "";
    nw_endpoint_t v69 = v68 == 0;
    if (v68) {
      uint64_t v56 = (const char *)(v68 + 531);
    }
    else {
      uint64_t v56 = "";
    }
    unint64_t v57 = v139;
    *(_DWORD *)__int16 v160 = 136446722;
    if (!v69) {
      __int16 v54 = " ";
    }
    goto LABEL_113;
  }

  return 1LL;
}

          BOOL v128 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)tcp_info buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_master_frame_array";
            _os_log_impl(&dword_181A5C000, v128, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
          }

          goto LABEL_90;
        }

        if (*(void *)(v43 + 248))
        {
          if ((*(_BYTE *)(v43 + 158) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v44 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              char v45 = *(void *)(v43 + 256);
              BOOL v46 = *(_DWORD *)(*(void *)(v43 + 248) + 372LL);
              if (v45) {
                LODWORD(v45) = *(_DWORD *)(v45 + 860);
              }
              nw_endpoint_t v47 = *(_DWORD *)(v43 + 424);
              *(_DWORD *)tcp_info buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v43 + 74;
              *(_WORD *)&_BYTE buf[22] = 2080;
              uint64_t v140 = (uint64_t)" ";
              *(_WORD *)nw_endpoint_t v141 = 1024;
              *(_DWORD *)&v141[2] = v46;
              *(_WORD *)&v141[6] = 1024;
              *(_DWORD *)&v141[8] = v45;
              *(_WORD *)&v141[12] = 1024;
              *(_DWORD *)&v141[14] = v47;
              *(_WORD *)&v141[18] = 2048;
              *(void *)&v141[20] = v43;
              id v142 = 2048;
              int v143 = v2;
              _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:c%u:s%u> stream (%p) finished with connection %p",  buf,  0x46u);
            }
          }

          if (gLogDatapath)
          {
            id v126 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)tcp_info buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_181A5C000, v126, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }

          *(void *)tcp_info buf = v4;
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_39716;
          uint64_t v140 = (uint64_t)&__block_descriptor_tmp_55_39717;
          *(void *)nw_endpoint_t v141 = v2 + 632;
          v141[8] = 0;
          BOOL v48 = *(void *)(v2 + 632);
          do
          {
            if (!v48) {
              break;
            }
            os_log_type_t v49 = *(void *)(v48 + 32);
            BOOL v50 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            BOOL v48 = v49;
          }

          while ((v50 & 1) != 0);
          *(void *)(v43 + 256) = 0LL;
          *(void *)(v2 + 48_Block_object_dispose(va, 8) = 0LL;
          nw_protocol_set_output_handler(v43, 0LL);
          nw_protocol_set_input_handler(v2, 0LL);
          goto LABEL_83;
        }

        id v121 = v14;
        __nwlog_obj();
        *(_DWORD *)tcp_info buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
        id v122 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v144) = 16;
        uint64_t v134 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v122, &v144, &v134))
        {
          if (v144 == 17)
          {
            size_t v123 = (os_log_s *)__nwlog_obj();
            uint64_t v124 = v144;
            if (os_log_type_enabled(v123, (os_log_type_t)v144))
            {
              *(_DWORD *)tcp_info buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
              id v125 = "%{public}s called with null http1_stream->protocol_http1";
LABEL_218:
              _os_log_impl(&dword_181A5C000, v123, v124, v125, buf, 0xCu);
            }
          }

          else if (v134)
          {
            int v129 = (char *)__nw_create_backtrace_string();
            size_t v123 = (os_log_s *)__nwlog_obj();
            uint64_t v124 = v144;
            nw_endpoint_t v130 = os_log_type_enabled(v123, (os_log_type_t)v144);
            if (v129)
            {
              if (v130)
              {
                *(_DWORD *)tcp_info buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v129;
                _os_log_impl( &dword_181A5C000,  v123,  v124,  "%{public}s called with null http1_stream->protocol_http1, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v129);
              goto LABEL_219;
            }

            if (v130)
            {
              *(_DWORD *)tcp_info buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
              id v125 = "%{public}s called with null http1_stream->protocol_http1, no backtrace";
              goto LABEL_218;
            }
          }

          else
          {
            size_t v123 = (os_log_s *)__nwlog_obj();
            uint64_t v124 = v144;
            if (os_log_type_enabled(v123, (os_log_type_t)v144))
            {
              *(_DWORD *)tcp_info buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_disassociate_from_connection";
              id v125 = "%{public}s called with null http1_stream->protocol_http1, backtrace limit exceeded";
              goto LABEL_218;
            }
          }
        }

        *(_DWORD *)tcp_info buf = 136446466;
        BOOL v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
        __int16 v92 = 2082;
        id v93 = v72;
        _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
        goto LABEL_193;
      }

      __nwlog_obj();
      *(_DWORD *)tcp_info buf = 136446210;
      BOOL v91 = "_http_safe_append";
      BOOL v30 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t v89 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault((const char *)v30, &__src, &v89))
      {
        if (__src == 17)
        {
          char v31 = (os_log_s *)__nwlog_obj();
          int v32 = __src;
          if (!os_log_type_enabled(v31, (os_log_type_t)__src)) {
            goto LABEL_142;
          }
          *(_DWORD *)tcp_info buf = 136446210;
          BOOL v91 = "_http_safe_append";
          nw_endpoint_t v33 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_141;
        }

        if (v89 == OS_LOG_TYPE_DEFAULT)
        {
          char v31 = (os_log_s *)__nwlog_obj();
          int v32 = __src;
          if (!os_log_type_enabled(v31, (os_log_type_t)__src)) {
            goto LABEL_142;
          }
          *(_DWORD *)tcp_info buf = 136446210;
          BOOL v91 = "_http_safe_append";
          nw_endpoint_t v33 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_141;
        }

        __int16 v53 = (char *)__nw_create_backtrace_string();
        char v31 = (os_log_s *)__nwlog_obj();
        int v32 = __src;
        __int16 v54 = os_log_type_enabled(v31, (os_log_type_t)__src);
        if (v53)
        {
          if (v54)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            BOOL v91 = "_http_safe_append";
            __int16 v92 = 2082;
            id v93 = v53;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v53);
          if (!v30)
          {
LABEL_144:
            *((void *)v85 + 3) = 0LL;
            __nwlog_obj();
            *(_DWORD *)tcp_info buf = 136446210;
            BOOL v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
            id v68 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(__src) = 16;
            os_log_type_t v89 = OS_LOG_TYPE_DEFAULT;
            if ((__nwlog_fault(v68, &__src, &v89) & 1) == 0) {
              goto LABEL_220;
            }
            if (__src == 17)
            {
              nw_endpoint_t v69 = (os_log_s *)__nwlog_obj();
              id v70 = __src;
              if (!os_log_type_enabled(v69, (os_log_type_t)__src)) {
                goto LABEL_220;
              }
              *(_DWORD *)tcp_info buf = 136446210;
              BOOL v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
              id v71 = "%{public}s called with null cursor";
            }

            else if (v89)
            {
              id v72 = (char *)__nw_create_backtrace_string();
              nw_endpoint_t v69 = (os_log_s *)__nwlog_obj();
              id v70 = __src;
              id v73 = os_log_type_enabled(v69, (os_log_type_t)__src);
              if (v72)
              {
                if (!v73) {
                  goto LABEL_193;
                }
                goto LABEL_192;
              }

              if (!v73) {
                goto LABEL_220;
              }
              *(_DWORD *)tcp_info buf = 136446210;
              BOOL v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
              id v71 = "%{public}s called with null cursor, no backtrace";
            }

            else
            {
              nw_endpoint_t v69 = (os_log_s *)__nwlog_obj();
              id v70 = __src;
              if (!os_log_type_enabled(v69, (os_log_type_t)__src)) {
                goto LABEL_220;
              }
              *(_DWORD *)tcp_info buf = 136446210;
              BOOL v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
              id v71 = "%{public}s called with null cursor, backtrace limit exceeded";
            }

            if (v90) {
              free(v90);
            }
            uint64_t v64 = 0LL;
            goto LABEL_195;
          }

          if ((~v4 & 6) != 0) {
            goto LABEL_197;
          }
LABEL_193:
          if (_nw_signposts_once == -1)
          {
            if (!_nw_signposts_enabled) {
              goto LABEL_197;
            }
          }

          else
          {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
            if (!_nw_signposts_enabled) {
              goto LABEL_197;
            }
          }

  __break(1u);
  return result;
}

        free(v111);
        if (!v100) {
          goto LABEL_528;
        }
        goto LABEL_527;
      }

      if (setsockopt(v97, 0xFFFF, 512, type, 4u))
      {
        BOOL v108 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        __nwlog_obj();
        os_log_type_t v109 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)tcp_info buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v108;
        BOOL v100 = (char *)_os_log_send_and_compose_impl();

        v283.sa_len = 16;
        LOBYTE(v286) = 0;
        if (v283.sa_len == 17)
        {
          __nwlog_obj();
          BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v110 = v283.sa_len;
          if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v108;
            _os_log_impl(&dword_181A5C000, v101, v110, "%{public}s SO_REUSEPORT failed %{darwin.errno}d", buf, 0x12u);
          }

          goto LABEL_525;
        }

        if (!(_BYTE)v286)
        {
          __nwlog_obj();
          BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v133 = v283.sa_len;
          if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v108;
            _os_log_impl( &dword_181A5C000,  v101,  v133,  "%{public}s SO_REUSEPORT failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }

          goto LABEL_525;
        }

        os_log_type_t v111 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v122 = v283.sa_len;
        size_t v123 = os_log_type_enabled(v101, (os_log_type_t)v283.sa_len);
        if (!v111)
        {
          if (v123)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v108;
            _os_log_impl( &dword_181A5C000,  v101,  v122,  "%{public}s SO_REUSEPORT failed %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }

          goto LABEL_525;
        }

        if (v123)
        {
          *(_DWORD *)tcp_info buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v108;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v111;
          _os_log_impl( &dword_181A5C000,  v101,  v122,  "%{public}s SO_REUSEPORT failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        goto LABEL_192;
      }

      if (ioctl(v97, 0x8004667EuLL, type) < 0)
      {
        nw_endpoint_t v130 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        __nwlog_obj();
        BOOL v131 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)tcp_info buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v130;
        BOOL v100 = (char *)_os_log_send_and_compose_impl();

        v283.sa_len = 16;
        LOBYTE(v286) = 0;
        if (v283.sa_len == 17)
        {
          __nwlog_obj();
          BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v132 = v283.sa_len;
          if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v130;
            _os_log_impl(&dword_181A5C000, v101, v132, "%{public}s FIONBIO failed %{darwin.errno}d", buf, 0x12u);
          }

          goto LABEL_525;
        }

        if (!(_BYTE)v286)
        {
          __nwlog_obj();
          BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v156 = v283.sa_len;
          if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v130;
            _os_log_impl( &dword_181A5C000,  v101,  v156,  "%{public}s FIONBIO failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }

          goto LABEL_525;
        }

        os_log_type_t v111 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v140 = v283.sa_len;
        nw_endpoint_t v141 = os_log_type_enabled(v101, (os_log_type_t)v283.sa_len);
        if (!v111)
        {
          if (v141)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v130;
            _os_log_impl( &dword_181A5C000,  v101,  v140,  "%{public}s FIONBIO failed %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }

          goto LABEL_525;
        }

        if (v141)
        {
          *(_DWORD *)tcp_info buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v130;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v111;
          _os_log_impl( &dword_181A5C000,  v101,  v140,  "%{public}s FIONBIO failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        goto LABEL_192;
      }

      if (nw_parameters_get_use_awdl(*((void **)v14 + 6)) && setsockopt(v97, 0xFFFF, 4356, type, 4u))
      {
        os_log_type_t v117 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        __nwlog_obj();
        __int16 v118 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)tcp_info buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v117;
        BOOL v100 = (char *)_os_log_send_and_compose_impl();

        v283.sa_len = 16;
        LOBYTE(v286) = 0;
        if (v283.sa_len == 17)
        {
          __nwlog_obj();
          BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v119 = v283.sa_len;
          if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v117;
            _os_log_impl(&dword_181A5C000, v101, v119, "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d", buf, 0x12u);
          }

          goto LABEL_525;
        }

        if (!(_BYTE)v286)
        {
          __nwlog_obj();
          BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          nw_endpoint_t v161 = v283.sa_len;
          if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v117;
            _os_log_impl( &dword_181A5C000,  v101,  v161,  "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }

          goto LABEL_525;
        }

        os_log_type_t v111 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v154 = v283.sa_len;
        id v155 = os_log_type_enabled(v101, (os_log_type_t)v283.sa_len);
        if (!v111)
        {
          if (v155)
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v117;
            _os_log_impl( &dword_181A5C000,  v101,  v154,  "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }

          goto LABEL_525;
        }

        if (v155)
        {
          *(_DWORD *)tcp_info buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v117;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v111;
          _os_log_impl( &dword_181A5C000,  v101,  v154,  "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        goto LABEL_192;
      }

      if (!nw_parameters_get_no_wake_from_sleep(*((void **)v14 + 6))
        || !setsockopt(v97, 0xFFFF, 0x10000, type, 4u))
      {
LABEL_311:
        __int16 v163 = (void *)*((void *)v14 + 5);
        if (v163 && nw_interface_get_subtype(v163) == 4001 && setsockopt(v97, 0xFFFF, 4376, type, 4u))
        {
          __int16 v164 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          __nwlog_obj();
          uint64_t v165 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)tcp_info buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v97;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v164;
          BOOL v100 = (char *)_os_log_send_and_compose_impl();

          v283.sa_len = 16;
          LOBYTE(v286) = 0;
          if (v283.sa_len == 17)
          {
            __nwlog_obj();
            BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            __int16 v166 = v283.sa_len;
            if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
            {
              *(_DWORD *)tcp_info buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v97;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v164;
              _os_log_impl( &dword_181A5C000,  v101,  v166,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d",  buf,  0x18u);
            }

            goto LABEL_525;
          }

          if (!(_BYTE)v286)
          {
            __nwlog_obj();
            BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            nw_endpoint_t v189 = v283.sa_len;
            if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
            {
              *(_DWORD *)tcp_info buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v97;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v164;
              _os_log_impl( &dword_181A5C000,  v101,  v189,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x18u);
            }

            goto LABEL_525;
          }

          os_log_type_t v111 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          nw_endpoint_t v181 = v283.sa_len;
          __int16 v182 = os_log_type_enabled(v101, (os_log_type_t)v283.sa_len);
          if (!v111)
          {
            if (v182)
            {
              *(_DWORD *)tcp_info buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v97;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v164;
              _os_log_impl( &dword_181A5C000,  v101,  v181,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, no backtrace",  buf,  0x18u);
            }

            goto LABEL_525;
          }

          if (v182)
          {
            *(_DWORD *)tcp_info buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v97;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v164;
            *(_WORD *)&_BYTE buf[24] = 2082;
            *(void *)&buf[26] = v111;
            _os_log_impl( &dword_181A5C000,  v101,  v181,  "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          goto LABEL_192;
        }

        if (v293)
        {
          __int16 v167 = v23->sa_family;
          if (v167 == 30)
          {
            if (setsockopt(v97, 41, 125, &v293, 4u))
            {
              id v171 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
              __nwlog_obj();
              __int16 v172 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v170 = v172;
              if (v171 != 6)
              {
                *(_DWORD *)tcp_info buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v293;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v171;
                BOOL v100 = (char *)_os_log_send_and_compose_impl();

                v283.sa_len = 16;
                LOBYTE(v286) = 0;
                if (v283.sa_len == 17)
                {
                  __nwlog_obj();
                  BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  id v184 = v283.sa_len;
                  if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
                  {
                    *(_DWORD *)tcp_info buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v293;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v171;
                    _os_log_impl( &dword_181A5C000,  v101,  v184,  "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d",  buf,  0x18u);
                  }

                  goto LABEL_525;
                }

                if (!(_BYTE)v286)
                {
                  __nwlog_obj();
                  BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  id v205 = v283.sa_len;
                  if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
                  {
                    *(_DWORD *)tcp_info buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v293;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v171;
                    _os_log_impl( &dword_181A5C000,  v101,  v205,  "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x18u);
                  }

                  goto LABEL_525;
                }

                os_log_type_t v111 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                __int16 v192 = v283.sa_len;
                id v193 = os_log_type_enabled(v101, (os_log_type_t)v283.sa_len);
                if (!v111)
                {
                  if (v193)
                  {
                    *(_DWORD *)tcp_info buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v293;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v171;
                    _os_log_impl( &dword_181A5C000,  v101,  v192,  "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d, no backtrace",  buf,  0x18u);
                  }

                  goto LABEL_525;
                }

                if (v193)
                {
                  *(_DWORD *)tcp_info buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                  *(_WORD *)&_BYTE buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v293;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v171;
                  *(_WORD *)&_BYTE buf[24] = 2082;
                  *(void *)&buf[26] = v111;
                  _os_log_impl( &dword_181A5C000,  v101,  v192,  "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
                }

                goto LABEL_192;
              }

              if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)tcp_info buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v293;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = 6;
                _os_log_impl( &dword_181A5C000,  v170,  OS_LOG_TYPE_ERROR,  "%{public}s IPV6_BOUND_IF %u failed %{darwin.errno}d",  buf,  0x18u);
              }

              goto LABEL_326;
            }
          }

          else
          {
            if (v167 != 2) {
              goto LABEL_333;
            }
            if (setsockopt(v97, 0, 25, &v293, 4u))
            {
              __int16 v168 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
              __nwlog_obj();
              __int16 v169 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v170 = v169;
              if (v168 != 6)
              {
                *(_DWORD *)tcp_info buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v293;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v168;
                BOOL v100 = (char *)_os_log_send_and_compose_impl();

                v283.sa_len = 16;
                LOBYTE(v286) = 0;
                if (v283.sa_len == 17)
                {
                  __nwlog_obj();
                  BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  uint64_t v183 = v283.sa_len;
                  if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
                  {
                    *(_DWORD *)tcp_info buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v293;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v168;
                    _os_log_impl( &dword_181A5C000,  v101,  v183,  "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d",  buf,  0x18u);
                  }

                  goto LABEL_525;
                }

                if (!(_BYTE)v286)
                {
                  __nwlog_obj();
                  BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  __int16 v204 = v283.sa_len;
                  if (os_log_type_enabled(v101, (os_log_type_t)v283.sa_len))
                  {
                    *(_DWORD *)tcp_info buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v293;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v168;
                    _os_log_impl( &dword_181A5C000,  v101,  v204,  "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x18u);
                  }

                  goto LABEL_525;
                }

                os_log_type_t v111 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                BOOL v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                nw_endpoint_t v190 = v283.sa_len;
                id v191 = os_log_type_enabled(v101, (os_log_type_t)v283.sa_len);
                if (!v111)
                {
                  if (v191)
                  {
                    *(_DWORD *)tcp_info buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v293;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v168;
                    _os_log_impl( &dword_181A5C000,  v101,  v190,  "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d, no backtrace",  buf,  0x18u);
                  }

                  goto LABEL_525;
                }

                if (v191)
                {
                  *(_DWORD *)tcp_info buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                  *(_WORD *)&_BYTE buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v293;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v168;
                  *(_WORD *)&_BYTE buf[24] = 2082;
                  *(void *)&buf[26] = v111;
                  _os_log_impl( &dword_181A5C000,  v101,  v190,  "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
                }

                goto LABEL_192;
              }

              if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)tcp_info buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v293;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = 6;
                _os_log_impl( &dword_181A5C000,  v170,  OS_LOG_TYPE_ERROR,  "%{public}s IP_BOUND_IF %u failed %{darwin.errno}d",  buf,  0x18u);
              }

LABEL_193:
      id v11 = v286;
      goto LABEL_194;
    }

    goto LABEL_194;
  }

  if ((*((_BYTE *)v286 + 33) & 1) != 0)
  {
    if ((nw_endpoint_handler_get_logging_disabled(v280) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v126 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
      {
        nw_endpoint_t v161 = nw_endpoint_handler_get_id_string(v280);
        __int16 v162 = nw_endpoint_handler_dry_run_string(v280);
        __int16 v163 = nw_endpoint_handler_copy_endpoint(v280);
        __int16 v164 = nw_endpoint_get_logging_description(v163);
        uint64_t v165 = nw_endpoint_handler_state_string(v280);
        __int16 v166 = nw_endpoint_handler_mode_string(v280);
        __int16 v167 = nw_endpoint_handler_copy_current_path(v280);
        *(_DWORD *)tcp_info buf = 136447746;
        v292 = "nw_endpoint_flow_setup_protocols";
        v293 = 2082;
        id v294 = (char *)v161;
        v295 = 2082;
        v296 = (nw_protocol *)v162;
        v297 = 2082;
        v298 = (void *)v164;
        v299 = 2082;
        v300 = (void *)v165;
        size_t v301 = 2082;
        v302 = v166;
        v303 = 2114;
        v304 = v167;
        _os_log_impl( &dword_181A5C000,  v126,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] joined protocol stack, starting",  buf,  0x48u);
      }

      goto LABEL_192;
    }

    goto LABEL_194;
  }

  if (!*((void *)v286 + 116))
  {
    if ((nw_endpoint_handler_get_logging_disabled(v280) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      size_t v173 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
      {
        __int16 v174 = nw_endpoint_handler_get_id_string(v280);
        uint64_t v175 = nw_endpoint_handler_dry_run_string(v280);
        id v176 = nw_endpoint_handler_copy_endpoint(v280);
        os_log_type_t v177 = nw_endpoint_get_logging_description(v176);
        id v178 = nw_endpoint_handler_state_string(v280);
        __int16 v179 = nw_endpoint_handler_mode_string(v280);
        nw_endpoint_t v180 = nw_endpoint_handler_copy_current_path(v280);
        *(_DWORD *)tcp_info buf = 136447746;
        v292 = "nw_endpoint_flow_setup_protocols";
        v293 = 2082;
        id v294 = (char *)v174;
        v295 = 2082;
        v296 = (nw_protocol *)v175;
        v297 = 2082;
        v298 = (void *)v177;
        v299 = 2082;
        v300 = (void *)v178;
        size_t v301 = 2082;
        v302 = v179;
        v303 = 2114;
        v304 = v180;
        _os_log_impl( &dword_181A5C000,  v173,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] persistent protocol stack, starting",  buf,  0x48u);
      }

      id v11 = v286;
    }

    *((_BYTE *)v11 + 35) |= 8u;
    goto LABEL_194;
  }

  char v150 = *((void *)v286 + 118);
  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v280);
  if (v150)
  {
    if ((logging_disabled & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v126 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
      {
        nw_endpoint_t v152 = nw_endpoint_handler_get_id_string(v280);
        char v153 = nw_endpoint_handler_dry_run_string(v280);
        __int16 v154 = nw_endpoint_handler_copy_endpoint(v280);
        id v155 = nw_endpoint_get_logging_description(v154);
        os_log_type_t v156 = nw_endpoint_handler_state_string(v280);
        __int16 v157 = nw_endpoint_handler_mode_string(v280);
        __int16 v158 = nw_endpoint_handler_copy_current_path(v280);
        *(_DWORD *)tcp_info buf = 136447746;
        v292 = "nw_endpoint_flow_setup_protocols";
        v293 = 2082;
        id v294 = (char *)v152;
        v295 = 2082;
        v296 = (nw_protocol *)v153;
        v297 = 2082;
        v298 = (void *)v155;
        v299 = 2082;
        v300 = (void *)v156;
        size_t v301 = 2082;
        v302 = v157;
        v303 = 2114;
        v304 = v158;
        _os_log_impl( &dword_181A5C000,  v126,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] has candidate children, starting",  buf,  0x48u);
      }

      goto LABEL_192;
    }

            dispatch_time_t v20 = 0LL;
            *(_BYTE *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL) = 1;
            goto LABEL_193;
          }

          goto LABEL_185;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v112 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)tcp_info buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
          v300 = 2048;
          size_t v301 = protocol_for_definition;
          _os_log_impl( &dword_181A5C000,  v112,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid",  buf,  0x16u);
        }

        goto LABEL_162;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v108 = (id)gLogObj;
      *(_DWORD *)tcp_info buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
      v300 = 2048;
      size_t v301 = protocol_for_definition;
      os_log_type_t v109 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v298 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v109, type, &v298))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v111 = type[0];
          if (os_log_type_enabled(v110, type[0]))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
            v300 = 2048;
            size_t v301 = protocol_for_definition;
            _os_log_impl(&dword_181A5C000, v110, v111, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
          }
        }

        else
        {
          if (v298)
          {
            os_log_type_t v114 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v115 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v116 = type[0];
            os_log_type_t v117 = os_log_type_enabled(v115, type[0]);
            if (v114)
            {
              if (v117)
              {
                *(_DWORD *)tcp_info buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
                v300 = 2048;
                size_t v301 = protocol_for_definition;
                v302 = 2082;
                v303 = v114;
                _os_log_impl( &dword_181A5C000,  v115,  v116,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v114);
            }

            else
            {
              if (v117)
              {
                *(_DWORD *)tcp_info buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
                v300 = 2048;
                size_t v301 = protocol_for_definition;
                _os_log_impl( &dword_181A5C000,  v115,  v116,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
              }
            }

            goto LABEL_183;
          }

          __nwlog_obj();
          __int16 v110 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v119 = type[0];
          if (os_log_type_enabled(v110, type[0]))
          {
            *(_DWORD *)tcp_info buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
            v300 = 2048;
            size_t v301 = protocol_for_definition;
            _os_log_impl( &dword_181A5C000,  v110,  v119,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
          }
        }
      }